nentModel.Design;

namespace Babel
{
    public abstract class BabelPackage : Microsoft.VisualStudio.Shell.Package, IOleComponent
    {
        uint componentID = 0;
        protected BabelPackage()
        {
            ServiceCreatorCallback callback = new ServiceCreatorCallback(
                delegate(IServiceContainer container, Type serviceType)
                {
                    if (typeof(Babel.LanguageService) == serviceType)
                    {
                        Babel.LanguageService language = new Babel.LanguageService();
                        language.SetSite(this);

                        // register for idle time callbacks
                        IOleComponentManager mgr = GetService(typeof(SOleComponentManager)) as IOleComponentManager;
                        if (componentID == 0 && mgr != null)
                        {
                            OLECRINFO[] crinfo = new OLECRINFO[1];
                            crinfo[0].cbSize = (uint)Marshal.SizeOf(typeof(OLECRINFO));
                            crinfo[0].grfcrf = (uint)_OLECRF.olecrfNeedIdleTime |
                                                          (uint)_OLECRF.olecrfNeedPeriodicIdleTime;
                            crinfo[0].grfcadvf = (uint)_OLECADVF.olecadvfModal |
                                                          (uint)_OLECADVF.olecadvfRedrawOff |
                                                          (uint)_OLECADVF.olecadvfWarningsOff;
                            crinfo[0].uIdleTimeInterval = 1000;
                            int hr = mgr.FRegisterComponent(this, crinfo, out componentID);
                        }

                        return language;
                    }
                    else
                    {
                        return null;
                    }
                });

            // proffer the LanguageService
            (this as IServiceContainer).AddService(typeof(Babel.LanguageService), callback, true);
        }

        protected override void Dispose(bool disposing)
        {
            try
            {
                if (componentID != 0)
                {
                    IOleComponentManager mgr = GetService(typeof(SOleComponentManager)) as IOleComponentManager;
                    if (mgr != null)
                    {
                        mgr.FRevokeComponent(componentID);
                    }
                    componentID = 0;
                }
            }
            finally
            {
                base.Dispose(disposing);
            }
        }

        #region IOleComponent Members
        public int FContinueMessageLoop(uint uReason, IntPtr pvLoopData, MSG[] pMsgPeeked)
        {
            return 1;
        }

        public int FDoIdle(uint grfidlef)
        {
            BabelLanguageService ls = GetService(typeof(Babel.LanguageService)) as BabelLanguageService;
            
            if (ls != null)
            {
                ls.OnIdle((grfidlef & (uint)_OLEIDLEF.oleidlefPeriodic) != 0);
            }

            return 0;
        }

        public int FPreTranslateMessage(MSG[] pMsg)
        {
            return 0;
        }

        public int FQueryTerminate(int fPromptUser)
        {
            return 1;
        }

        public int FReserved1(uint dwReserved, uint message, IntPtr wParam, IntPtr lParam)
        {
            return 1;
        }

        public IntPtr HwndGetWindow(uint dwWhich, uint dwReserved)
        {
            return IntPtr.Zero;
        }

        public void OnActivationChange(IOleComponent pic, int fSameComponent, OLECRINFO[] pcrinfo, int fHostIsActivating, OLECHOSTINFO[] pchostinfo, uint dwReserved)
        {
        }

        public void OnAppActivate(int fActive, uint dwOtherThreadID)
        {
        }

        public void OnEnterState(uint uStateID, int fEnter)
        {
        }

        public void OnLoseActivation()
        {
        }

        public void Terminate()
        {
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Babel\IScanner.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/


using System;
using System.Collections.Generic;
using System.Text;


namespace Babel.ParserGenerator
{
    /// <summary>
    /// Classes implementing this interface must supply a
    /// method that merges two location objects to return
    /// a new object of the same type.
    /// MPPG-generated parsers have the default location
    /// action equivalent to "@$ = @1.Merge(@N);" where N
    /// is the right-hand-side length of the production.
    /// </summary>
    /// <typeparam name="YYLTYPE"></typeparam>
    public interface IMerge<YYLTYPE>
    {
        YYLTYPE Merge(YYLTYPE last);
    }

    /// <summary>
    /// This is the default class that carries location
    /// information from the scanner to the parser.
    /// If you don't declare "%YYLTYPE Foo" the parser
    /// will expect to deal with this type.
    /// </summary>
    public class LexLocation : IMerge<LexLocation>
    {
        public int sLin; // start line
        public int sCol; // start column
        public int eLin; // end line
        public int eCol; // end column

        public LexLocation() 
        { }

        public LexLocation(int sl, int sc, int el, int ec)
        { sLin = sl; sCol = sc; eLin = el; eCol = ec; }

        public LexLocation Merge(LexLocation last)
        { return new LexLocation(this.sLin, this.sCol, last.eLin, last.eCol); }
    }

    public interface IColorScan
    {
        void SetSource(string source, int offset);
        int GetNext(ref int state, out int start, out int end);
    }
   
    /// <summary>
    /// Abstract scanner class that MPPG expects its scanners to extend.
    /// </summary>
    /// <typeparam name="YYSTYPE"></typeparam>
    /// <typeparam name="YYLTYPE"></typeparam>
	public abstract class AScanner<YYSTYPE,YYLTYPE> 
        where YYSTYPE : struct
        where YYLTYPE : IMerge<YYLTYPE>
    {
		public YYSTYPE yylval;              // lexical value: set by scanner
        public YYLTYPE yylloc;              // location value: set by scanner

        public abstract int yylex();

        public virtual void yyerror(string format, params object[] args) {}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Babel\LineScanner.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using Babel.Parser;
using Microsoft.VisualStudio.Package;

namespace Babel
{
	/// <summary>
	/// LineScanner wraps the GPLEX scanner to provide the IScanner interface
	/// required by the Managed Package Framework. This includes mapping tokens
	/// to color definitions.
	/// </summary>
	public class LineScanner : IScanner
	{
		Babel.ParserGenerator.IColorScan lex = null;

		public LineScanner()
		{
			this.lex = new Babel.Lexer.Scanner();
		}

		public bool ScanTokenAndProvideInfoAboutIt(TokenInfo tokenInfo, ref int state)
		{
			int start, end;
			int token = lex.GetNext(ref state, out start, out end);

			// !EOL and !EOF
			if (token != (int)Tokens.EOF)
			{
				Configuration.TokenDefinition definition = Configuration.GetDefinition(token);
				tokenInfo.StartIndex = start;
				tokenInfo.EndIndex = end;
				tokenInfo.Color = definition.TokenColor;
				tokenInfo.Type = definition.TokenType;
				tokenInfo.Trigger = definition.TokenTriggers;

				return true;
			}
			else
			{
				return false;
			}
		}

		public void SetSource(string source, int offset)
		{
			lex.SetSource(source, offset);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Babel\Methods.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.VisualStudio.TextManager.Interop;
using Microsoft.VisualStudio.Package;

namespace Babel
{
	public class Methods : Microsoft.VisualStudio.Package.Methods
	{
		IList<Method> methods;
		public Methods(IList<Method> methods)
		{
			this.methods = methods;
		}

		public override int GetCount()
		{
			return methods.Count;
		}

		public override string GetName(int index)
		{
			return methods[index].Name;
		}

		public override string GetDescription(int index)
		{
			return methods[index].Description;
		}

		public override string GetType(int index)
		{
			return methods[index].Type;
		}

		public override int GetParameterCount(int index)
		{
			return (methods[index].Parameters == null) ? 0 : methods[index].Parameters.Count;
		}

		public override void GetParameterInfo(int index, int paramIndex, out string name, out string display, out string description)
		{
			Parameter parameter = methods[index].Parameters[paramIndex];
			name = parameter.Name;
			display = parameter.Display;
			description = parameter.Description;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Babel\Parser.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.VisualStudio.TextManager.Interop;
using Microsoft.VisualStudio.Package;

namespace Babel.Parser
{
	public partial class Parser
	{
		public void MBWInit(ParseRequest request)
		{
			this.request = request;
			braces = new List<TextSpan[]>();
		}

		ParseRequest request;
		IList<TextSpan[]> braces;

		public IList<TextSpan[]> Braces
		{
			get { return this.braces; }
		}

		public ParseRequest Request
		{
			get { return this.request; }
		}

		public AuthoringSink Sink
		{
			get { return this.request.Sink; }
		}

		// brace matching, pairs and triples
		public void DefineMatch(int priority, params TextSpan[] locations)
		{			
			if (locations.Length == 2)
				braces.Add(new TextSpan[] { locations[0], 
					locations[1]});

			else if (locations.Length >= 3)
				braces.Add(new TextSpan[] { locations[0], 
					locations[1],
					locations[2]});
		}

		public void DefineMatch(params TextSpan[] locations)
		{
			DefineMatch(0, locations);
		}

		// hidden regions - not working?
		public void DefineRegion(TextSpan span)
		{
			Sink.AddHiddenRegion(span);
		}

		// auto hidden?
		// public void DefineHiddenRegion
		// etc. see NewHiddenRegion structure


		// error reporting
		public void ReportError(TextSpan span, string message, Severity severity)
		{
			Sink.AddError(request.FileName, message, span, severity);
		}

		#region Error Overloads (Severity)
		public void ReportError(TextSpan location, string message)
		{
			ReportError(location, message, Severity.Error);
		}

		public void ReportFatal(TextSpan location, string message)
		{
			ReportError(location, message, Severity.Fatal);
		}

		public void ReportWarning(TextSpan location, string message)
		{
			ReportError(location, message, Severity.Warning);
		}

		public void ReportHint(TextSpan location, string message)
		{
			ReportError(location, message, Severity.Hint);
		}
		#endregion

		#region TextSpan Conversion
		public TextSpan TextSpan(int startLine, int startIndex, int endIndex)
		{
			return TextSpan(startLine, startIndex, startLine, endIndex);
		}

		public TextSpan TextSpan(int startLine, int startIndex, int endLine, int endIndex)
		{
			TextSpan ts;
			ts.iStartLine = startLine - 1;
			ts.iStartIndex = startIndex;
			ts.iEndLine = endLine - 1;
			ts.iEndIndex = endIndex;
			return ts;
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Babel\Rule.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/



namespace Babel.ParserGenerator
{
    public class Rule
    {
        public int lhs; // symbol
		public int[] rhs; // symbols

        public Rule(int lhs, int[] rhs)
        {
            this.lhs = lhs;
            this.rhs = rhs;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Babel\LanguageService.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Collections.Generic;
using Microsoft.VisualStudio;
using Microsoft.VisualStudio.TextManager.Interop;
using Microsoft.VisualStudio.Package;

namespace Babel
{
	public abstract class BabelLanguageService : Microsoft.VisualStudio.Package.LanguageService
	{
		#region Custom Colors
		public override int GetColorableItem(int index, out IVsColorableItem item)
		{
			if (index <= Configuration.ColorableItems.Count)
			{
				item = Configuration.ColorableItems[index - 1];
				return Microsoft.VisualStudio.VSConstants.S_OK;
			}
			else
			{
				throw new ArgumentNullException("index");
			}
		}

		public override int GetItemCount(out int count)
		{
			count = Configuration.ColorableItems.Count;
			return Microsoft.VisualStudio.VSConstants.S_OK;
		}
		#endregion

		#region MPF Accessor and Factory specialisation
		private LanguagePreferences preferences;
		public override LanguagePreferences GetLanguagePreferences()
		{
			if (this.preferences == null)
			{
				this.preferences = new LanguagePreferences(this.Site,
														typeof(Babel.LanguageService).GUID,
														this.Name);
				this.preferences.Init();
			}

			return this.preferences;
		}

		public override Microsoft.VisualStudio.Package.Source CreateSource(IVsTextLines buffer)
		{
			return new Source(this, buffer, this.GetColorizer(buffer));
		}

		private IScanner scanner;
		public override IScanner GetScanner(IVsTextLines buffer)
		{
			if (scanner == null)
				this.scanner = new LineScanner();

			return this.scanner;
		}
		#endregion

		public override void OnIdle(bool periodic)
		{
			// from IronPythonLanguage sample
			// this appears to be necessary to get a parse request with ParseReason = Check?
			Source src = (Source) GetSource(this.LastActiveTextView);
			if (src != null && src.LastParseTime >= Int32.MaxValue >> 12)
			{
				src.LastParseTime = 0;
			}
			base.OnIdle(periodic);
		}


		public override Microsoft.VisualStudio.Package.AuthoringScope ParseSource(ParseRequest req)
		{
			Source source = (Source) this.GetSource(req.FileName);
            bool yyparseResult = false;

			// req.DirtySpan seems to be set even though no changes have occurred
			// source.IsDirty also behaves strangely
			// might be possible to use source.ChangeCount to sync instead

            if (req.DirtySpan.iStartIndex != req.DirtySpan.iEndIndex
                || req.DirtySpan.iStartLine != req.DirtySpan.iEndLine)
			{
                Babel.Parser.ErrorHandler handler = new Babel.Parser.ErrorHandler();
                Babel.Lexer.Scanner scanner = new Babel.Lexer.Scanner(); // string interface
                Parser.Parser parser = new Parser.Parser();  // use noarg constructor

                parser.scanner = scanner;
                scanner.Handler = handler;
                parser.SetHandler(handler);
                scanner.SetSource(req.Text, 0);

                parser.MBWInit(req);
                yyparseResult = parser.Parse();

				// store the parse results
                // source.ParseResult = aast;
                source.ParseResult = null;
                source.Braces = parser.Braces;

				// for the time being, just pull errors back from the error handler
                if (handler.ErrNum > 0)
                {
                    foreach (Babel.Parser.Error error in handler.SortedErrorList())
                    {
                        TextSpan span = new TextSpan();
                        span.iStartLine = span.iEndLine = error.line - 1;
                        span.iStartIndex = error.column;
                        span.iEndIndex = error.column + error.length;
                        req.Sink.AddError(req.FileName, error.message, span, Severity.Error);
                    }
                }
			}

			switch (req.Reason)
			{
				case ParseReason.Check:
				case ParseReason.HighlightBraces:
				case ParseReason.MatchBraces:
				case ParseReason.MemberSelectAndHighlightBraces:
					// send matches to sink
					// this should (probably?) be filtered on req.Line / col
				    if (source.Braces != null)
					{
						foreach (TextSpan[] brace in source.Braces)
						{
							if (brace.Length == 2)
								req.Sink.MatchPair(brace[0], brace[1], 1);
							else if (brace.Length >= 3)
								req.Sink.MatchTriple(brace[0], brace[1], brace[2], 1);
						}
					}
					break;
				default:
					break;
			}

			return new AuthoringScope(source.ParseResult);
		}

		public override string Name
		{
			get { return Configuration.Name; }
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Babel\State.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/


using System.Collections.Generic;


namespace Babel.ParserGenerator
{
    public class State
    {
		public int num;
		public Dictionary<int, int> parser_table;  // Terminal -> ParseAction
        public Dictionary<int, int> Goto;          // NonTerminal -> State;
        public int defaultAction = 0;			   // ParseAction


        public State(int[] actions, int[] gotos): this(actions) 
        {
            Goto = new Dictionary<int, int>();
            for (int i = 0; i < gotos.Length; i += 2)
                Goto.Add(gotos[i], gotos[i + 1]);
        }

        public State(int[] actions)
        {
            parser_table = new Dictionary<int, int>();
			for (int i = 0; i < actions.Length; i += 2)
				parser_table.Add(actions[i], actions[i + 1]);
        }

        public State(int defaultAction)
        {
            this.defaultAction = defaultAction;
        }

		public State(int defaultAction, int[] gotos): this(defaultAction)
		{
			Goto = new Dictionary<int, int>();
			for (int i = 0; i < gotos.Length; i += 2)
				Goto.Add(gotos[i], gotos[i + 1]);
		}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\LanguageService100\Colorizer.cs ===
using Microsoft.VisualStudio.TextManager.Interop;
using System;
using System.Collections;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;
using System.Drawing;

namespace Microsoft.VisualStudio.Package {

    /// <include file='doc\Colorizer.uex' path='docs/doc[@for="Colorizer"]/*' />
    [CLSCompliant(false)]
    [System.Runtime.InteropServices.ComVisible(true)]
    public class Colorizer : IVsColorizer, IDisposable {
        IScanner scanner;
        TokenInfo[] cachedLineInfo;
        int cachedLine;
        int cachedLineState;
        string cachedLineText;
        int suspended;
        LanguageService svc;
        internal IVsTextLines buffer;

        /// <include file='doc\Colorizer.uex' path='docs/doc[@for="Colorizer.Colorizer"]/*' />
        public Colorizer(LanguageService svc, IVsTextLines buffer, IScanner scanner) {
            this.cachedLine = -1;
            this.scanner = scanner;
            this.svc = svc;
            this.buffer = buffer;
        }

        /// <include file='doc\Colorizer.uex' path='docs/doc[@for="ColorableItem.Finalize"]/*' />
        ~Colorizer() {
#if LANGTRACE
            Trace.WriteLine("~Colorizer");
#endif
            Dispose(false);
        }

        /// <include file='doc\Colorizer.uex' path='docs/doc[@for="Colorizer.Dispose"]/*' />
        public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing) {
            // We do not null out the scanner since we don't need to, it's a managed object, and 
            // we may need it if a paint message comes in after colorizer is closed since the core
            // text editor will still call ColorizeLine in that case.  This stops the text from
            // going black when the window is closed.
            // this.scanner = null; 
            this.cachedLineInfo = null;
            this.svc = null;
            this.buffer = null;
        }

        /// <include file='doc\Colorizer.uex' path='docs/doc[@for="Colorizer.Scanner"]/*' />
        public IScanner Scanner {
            get { return this.scanner; }
        }

        /// <include file='doc\Colorizer.uex' path='docs/doc[@for="Colorizer.CloseColorizer"]/*' />
        public virtual void CloseColorizer() {
            if (this.svc != null) {
                svc.OnCloseColorizer(this);
            }
            Dispose(true);
        }

        /// <include file='doc\Colorizer.uex' path='docs/doc[@for="Colorizer.GetStateMaintenanceFlag"]/*' />
        public virtual int GetStateMaintenanceFlag(out int flag) {
            flag = 1;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Colorizer.uex' path='docs/doc[@for="Colorizer.GetStartState"]/*' />
        public virtual int GetStartState(out int start) {
            start = 0;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Colorizer.uex' path='docs/doc[@for="Colorizer.GetStateAtEndOfLine"]/*' />
        public virtual int GetStateAtEndOfLine(int line, int length, IntPtr ptr, int state) {
            return ColorizeLine(line, length, ptr, state, null);
        }

        TokenInfo tokenInfo = new TokenInfo();

        /// <include file='doc\Colorizer.uex' path='docs/doc[@for="Colorizer.ColorizeLine"]/*' />
        public virtual int ColorizeLine(int line, int length, IntPtr ptr, int state, uint[] attrs) {
            int linepos = 0;
            if (this.scanner != null) {
                try {
                    string text = Marshal.PtrToStringUni(ptr, length);

                    this.scanner.SetSource(text, 0);

                    tokenInfo.EndIndex = -1;
                    
                    while (this.scanner.ScanTokenAndProvideInfoAboutIt(tokenInfo, ref state)) {
                        if (attrs != null) {
                            for (; linepos < tokenInfo.StartIndex; linepos++)
                                attrs[linepos] = (uint)TokenColor.Text;

                            uint color = (uint)tokenInfo.Color;
                            if (tokenInfo.Type == TokenType.Comment ||
                                tokenInfo.Type == TokenType.LineComment ||
                                tokenInfo.Type == TokenType.String ||
                                tokenInfo.Type == TokenType.Text) {
                                color |= (uint)COLORIZER_ATTRIBUTE.HUMAN_TEXT_ATTR;
                            }
                            for (; linepos <= tokenInfo.EndIndex; linepos++)
                                attrs[linepos] = color;
                        }
                    }
#if LANGTRACE
                } catch (Exception e) {
                    Debug.Assert(false, "ColorizeLine caught exception:\n" + e.ToString());
#else
                } catch (Exception) {
#endif
                }
            }
            if (attrs != null) {
                // Must initialize the colors in all cases, otherwise you get 
                // random color junk on the screen.
                for (; linepos < length; linepos++)
                    attrs[linepos] = (uint)TokenColor.Text;
            }
            return state;
        }

        /// <include file='doc\Colorizer.uex' path='docs/doc[@for="Colorizer.GetColorInfo"]/*' />
        public virtual int GetColorInfo(string line, int length, int state) {
            if (this.scanner == null) return 0;

            this.scanner.SetSource(line, 0);

            ArrayList cache = new ArrayList();
            TokenInfo tokenInfo = new TokenInfo();

            tokenInfo.EndIndex = -1;

            bool firstTime = true;

            while (this.scanner.ScanTokenAndProvideInfoAboutIt(tokenInfo, ref state)) {
                if (firstTime && tokenInfo.StartIndex > 1) {
                    cache.Add(new TokenInfo(0, tokenInfo.StartIndex - 1, TokenType.WhiteSpace));
                }

                firstTime = false;
                cache.Add(tokenInfo);
                tokenInfo = new TokenInfo();
            }

            if (cache.Count > 0) {
                tokenInfo = (TokenInfo)cache[cache.Count - 1];
            }

            if (tokenInfo.EndIndex < length - 1) {
                cache.Add(new TokenInfo(tokenInfo.EndIndex + 1, length - 1, TokenType.WhiteSpace));
            }

            this.cachedLineInfo = (TokenInfo[])cache.ToArray(typeof(TokenInfo));
            return state;
        }

        /// <include file='doc\Colorizer.uex' path='docs/doc[@for="Colorizer.GetLineInfo"]/*' />
        public virtual TokenInfo[] GetLineInfo(IVsTextLines buffer, int line, IVsTextColorState colorState) {

            int length;

            NativeMethods.ThrowOnFailure(buffer.GetLengthOfLine(line, out length));
            if (length == 0)
                return null;

            string text;

            NativeMethods.ThrowOnFailure(buffer.GetLineText(line, 0, line, length, out text));

            int state;

            NativeMethods.ThrowOnFailure(colorState.GetColorStateAtStartOfLine(line, out state));

            if (this.cachedLine == line && this.cachedLineText == text &&
                this.cachedLineState == state && this.cachedLineInfo != null) {
                return this.cachedLineInfo;
            }

            // recolorize the line, and cache the results
            this.cachedLineInfo = null;
            this.cachedLine = line;
            this.cachedLineText = text;
            this.cachedLineState = state;

            // GetColorInfo will update the cache. Note that here we don't use NativeMethods.ThrowOnFailure
            // because the return code is the current parsing state, not an HRESULT.
            GetColorInfo(text, length, state);

            //now it should be in the cache
            return this.cachedLineInfo;
        }

        /// <include file='doc\Colorizer.uex' path='docs/doc[@for="Colorizer.Suspend"]/*' />
        public virtual void Suspend() {
            suspended++;
        }

        /// <include file='doc\Colorizer.uex' path='docs/doc[@for="Colorizer.Resume"]/*' />
        public virtual void Resume() {
            suspended--;
            Debug.Assert(suspended >= 0);
        }

    }

    /// <include file='doc\Colorizer.uex' path='docs/doc[@for="ColorableItem"]/*' />
    [CLSCompliant(false)]
    [System.Runtime.InteropServices.ComVisible(true)]
    public class ColorableItem : IVsColorableItem, IVsHiColorItem, IVsMergeableUIItem {
        string name, displayName;
        COLORINDEX foreColor, backColor;
        Color hiForeColor, hiBackColor;
        FONTFLAGS fontFlags;

        /// <include file='doc\Colorizer.uex' path='docs/doc[@for="ColorableItem.ColorableItem"]/*' />
        public ColorableItem(string name, string displayName, COLORINDEX foreColor, COLORINDEX backColor, Color hiForeColor, Color hiBackColor, FONTFLAGS fontFlags) {
            this.name = name;
            this.displayName = displayName;
            this.foreColor = foreColor;
            this.backColor = backColor;
            this.fontFlags = fontFlags;
            this.hiForeColor = hiForeColor;
            this.hiBackColor = hiBackColor;
        }

        #region IVsColorableItem methods
        /// <include file='doc\Colorizer.uex' path='docs/doc[@for="ColorableItem.GetDefaultColors"]/*' />
        public virtual int GetDefaultColors(COLORINDEX[] foreColor, COLORINDEX[] backColor) {
            if (foreColor != null) foreColor[0] = this.foreColor;
            if (backColor != null) backColor[0] = this.backColor;
            return NativeMethods.S_OK;
        }
        /// <include file='doc\Colorizer.uex' path='docs/doc[@for="ColorableItem.GetDefaultFontFlags"]/*' />
        public virtual int GetDefaultFontFlags(out uint fontFlags) {
            fontFlags = (uint)this.fontFlags;
            return NativeMethods.S_OK;
        }
        /// <include file='doc\Colorizer.uex' path='docs/doc[@for="ColorableItem.GetDisplayName"]/*' />
        public virtual int GetDisplayName(out string name) {
            name = this.displayName;
            return NativeMethods.S_OK;
        }
        #endregion

        #region IVsHiColorItem methods
        /// <include file='doc\Colorizer.uex' path='docs/doc[@for="Colorizer.GetColorData"]/*' />
        public virtual int GetColorData(int cdElement, out uint crColor) 
        {
            crColor = 0;

            switch (cdElement) 
            {
                case (int)__tagVSCOLORDATA.CD_FOREGROUND: 
                    {
                        if (!this.hiForeColor.IsEmpty) 
                        {
                            crColor = ColorToRgb(this.hiForeColor);
                            return NativeMethods.S_OK;
                        }
                        break;
                    }
                case (int)__tagVSCOLORDATA.CD_BACKGROUND: 
                    {
                        if (!this.hiBackColor.IsEmpty) 
                        {
                            crColor = ColorToRgb(this.hiBackColor);
                            return NativeMethods.S_OK;
                        }
                        break;
                    }
                default:
                    return NativeMethods.E_FAIL;
            }

            return NativeMethods.E_FAIL;
        }

        private uint ColorToRgb(Color color) 
        {
            byte red = (byte)color.R;
            short green = (short)(byte)color.G;
            int blue = (byte)color.B;

            return (uint)(red | (green << 8) | (blue << 16));
        }
        #endregion


        #region IVsMergeableUIItem Members

        /// <include file='doc\Colorizer.uex' path='docs/doc[@for="ColorableItem.GetCanonicalName"]/*' />
        public virtual int GetCanonicalName(out string name) {
            name = this.name;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Colorizer.uex' path='docs/doc[@for="ColorableItem.GetDescription"]/*' />
        public virtual int GetDescription(out string desc) {
            // The reason this is not implemented is because the core text editor
            // doesn't use it.
            desc = null;
            return NativeMethods.E_NOTIMPL;
        }

        /// <include file='doc\Colorizer.uex' path='docs/doc[@for="ColorableItem.GetMergingPriority"]/*' />
        public virtual int GetMergingPriority(out int priority) {
            priority = -1;
            return NativeMethods.E_NOTIMPL;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\LanguageService100\CodeWindowManager.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using Microsoft.VisualStudio.Shell;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.TextManager.Interop;
using Ole = Microsoft.VisualStudio.OLE.Interop;
using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
using IServiceProvider = System.IServiceProvider;

namespace Microsoft.VisualStudio.Package {
    /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="CodeWindowManager"]/*' />
    /// <summary>
    /// CodeWindowManager provides a default implementation of the VSIP interface IVsCodeWindowManager
    /// and manages the LanguageService, Source, ViewFilter, and DocumentProperties objects associated
    /// with the given IVsCodeWindow.  It calls CreateViewFilter on your LanguageService for each new
    /// IVsTextView created by Visual Studio and installs the resulting filter into the command chain.
    /// You do not have to override this method, since a default view filter will be created.
    /// If your LanguageService returns an object from CreateDocumentProperties then you will have
    /// properties in the Properties Window associated with your source files.
    /// The CodeWindowManager also provides support for optional drop down combos in the IVsDropdownBar for 
    /// listing types and members by installing the TypeAndMemberDropdownBars object returned from your 
    /// LanguageService CreateDropDownHelper method.  The default return from CreateDropDownHelper is null, 
    /// which results in no drop down combos.
    /// </summary>
    [CLSCompliant(false)]
    [System.Runtime.InteropServices.ComVisible(true)]
    public class CodeWindowManager : IVsCodeWindowManager {
        TypeAndMemberDropdownBars dropDownHelper;
        IVsCodeWindow codeWindow;
        ArrayList viewFilters;
        LanguageService service;
        Source source;
        DocumentProperties properties;

        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="CodeWindowManager.CodeWindowManager"]/*' />
        /// <summary>
        /// The CodeWindowManager is constructed by the base LanguageService class when VS calls
        /// the IVsLanguageInfo.GetCodeWindowManager method.  You can override CreateCodeWindowManager
        /// on your LanguageService if you want to plug in a different CodeWindowManager.
        /// </summary>
        public CodeWindowManager(LanguageService service, IVsCodeWindow codeWindow, Source source) {
            this.service = service;
            this.codeWindow = codeWindow;
            this.viewFilters = new ArrayList();
            this.source = source;
            this.properties = service.CreateDocumentProperties(this);
        }

        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="TypeAndMemberDropdownBars.Finalize"]/*' />
        ~CodeWindowManager() {
#if	LANGTRACE
            Trace.WriteLine("~CodeWindowManager");
#endif
        }

        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="CodeWindowManager.Close"]/*' />
        /// <summary>Closes all view filters, and the document properties window</summary>
        public void Close() {
#if	LANGTRACE
            Trace.WriteLine("CodeWindowManager::Close");
#endif
            if (this.properties != null) this.properties.Close();
            CloseFilters();
            this.viewFilters = null;
            properties = null;
            service = null;
            source = null;
            this.codeWindow = null;
        }

        void CloseFilters() {
            if (this.viewFilters != null) {
                foreach (ViewFilter f in this.viewFilters) {
                    f.Close();
                }
                this.viewFilters.Clear();
            }
        }

        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="CodeWindowManager.LanguageService;"]/*' />
        /// <summary>Returns the LanguageService object that created this code window manager</summary>
        public LanguageService LanguageService {
            get { return this.service; }
        }
        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="CodeWindowManager.Source;"]/*' />
        /// <summary>returns the Source object associated with the IVsTextLines buffer for this code window</summary>
        public Source Source {
            get { return this.source; }
        }
        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="CodeWindowManager.GetFilter;"]/*' />
        /// <summary>
        /// Returns the ViewFilter for the given view or null if no matching filter is found.
        /// </summary>
        public ViewFilter GetFilter(IVsTextView view) {
            if (this.viewFilters != null) {
                foreach (ViewFilter f in this.viewFilters) {
                    if (f.TextView == view)
                        return f;
                }
            }
            return null;
        }

        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="CodeWindowManager.Properties;"]/*' />
        /// <summary>Returns the DocumentProperties, if any.  You can update this property if you want to 
        /// change the document properties on the fly.</summary>
        public DocumentProperties Properties {
            get { return this.properties; }
            set {
                if (this.properties != value) {
                    if (this.properties != null) this.properties.Close();
                    this.properties = value;
                    if (value != null) value.Refresh();
                }
            }
        }
        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="CodeWindowManager.DropDownHelper"]/*' />
        /// <summary>Return the optional TypeAndMemberDropdownBars object for the drop down combos</summary>
        public TypeAndMemberDropdownBars DropDownHelper {
            get { return this.dropDownHelper; }
        }
        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="CodeWindowManager.CodeWindow"]/*' />
        /// <summary>Return the IVsCodeWindow associated with this code window manager.</summary>
        public IVsCodeWindow CodeWindow {
            get { return this.codeWindow; }
        }
      
        #region IVsCodeWindowManager methods
        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="CodeWindowManager.AddAdornments"]/*' />
        /// <summary>Install the optional TypeAndMemberDropdownBars, and primary and secondary view filters</summary>
        public virtual int AddAdornments() {
#if	LANGTRACE
            Trace.WriteLine("CodeWindowManager::AddAdornments");
#endif
            int hr = 0;
            this.service.AddCodeWindowManager(this);

            this.source.Open();

            IVsTextView textView;
            NativeMethods.ThrowOnFailure(this.codeWindow.GetPrimaryView(out textView));

            this.dropDownHelper = this.service.CreateDropDownHelper(textView);
            if (this.dropDownHelper != null) {
                IVsDropdownBar pBar;
                IVsDropdownBarManager dbm = (IVsDropdownBarManager)this.codeWindow;
                int rc = dbm.GetDropdownBar(out pBar);
                if (rc == 0 && pBar != null)
                    NativeMethods.ThrowOnFailure(dbm.RemoveDropdownBar());
                //this.dropDownHelper = new TypeAndMemberDropdownBars(this.service);
                this.dropDownHelper.SynchronizeDropdowns(textView, 0, 0);
                NativeMethods.ThrowOnFailure(dbm.AddDropdownBar(2, this.dropDownHelper));
            }
            // attach view filter to primary view.
            if (textView != null)
                this.OnNewView(textView); // always returns S_OK.

            // attach view filter to secondary view.
            textView = null;
            hr = this.codeWindow.GetSecondaryView(out textView);
            if (hr == NativeMethods.S_OK && textView != null)
                this.OnNewView(textView); // always returns S_OK.

            return NativeMethods.S_OK;
        }

        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="CodeWindowManager.RemoveAdornments"]/*' />
        /// <summary>Remove drop down combos, view filters, and notify the LanguageService that the Source and
        /// CodeWindowManager is now closed</summary>
        public virtual int RemoveAdornments() {
#if	LANGTRACE
            Trace.WriteLine("CodeWindowManager::RemoveAdornments");
#endif
            try {
                if (this.dropDownHelper != null) {
                    IVsDropdownBarManager dbm = (IVsDropdownBarManager)this.codeWindow;
                    NativeMethods.ThrowOnFailure(dbm.RemoveDropdownBar());
                    this.dropDownHelper.Done();
                    this.dropDownHelper = null;
                }
            } finally {
                CloseFilters();

                if (this.source != null && this.source.Close()) {
                    this.service.OnCloseSource(this.source);
                    this.source.Dispose();
                }
                this.source = null;

                service.RemoveCodeWindowManager(this);
                this.codeWindow = null;
                this.Close();
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="CodeWindowManager.OnNewView"]/*' />
        /// <summary>Install a new view filter for the given view. This method calls your
        /// CreateViewFilter method.</summary>
        public virtual int OnNewView(IVsTextView newView) {
#if	LANGTRACE
            Trace.WriteLine("CodeWindowManager::OnNewView");
#endif
            ViewFilter filter = this.service.CreateViewFilter(this, newView);
            if (filter != null) this.viewFilters.Add(filter);
            return NativeMethods.S_OK;
        }

        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="CodeWindowManager.OnKillFocus"]/*' />
        public virtual void OnKillFocus(IVsTextView textView) {
        }

        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="CodeWindowManager.OnSetFocus"]/*' />
        /// <summary>Refresh the document properties</summary>
        public virtual void OnSetFocus(IVsTextView textView) {
            if (this.properties != null) {
                this.properties.Refresh();
            }
        }
        #endregion

    }



    /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="TypeAndMemberDropdownBars"]/*' />
    /// <summary>
    /// Represents the two drop down bars on the top of a text editor window that allow 
    /// types and type members to be selected by name.
    /// </summary>
    [CLSCompliant(false)]
    public abstract class TypeAndMemberDropdownBars : IVsDropdownBarClient {
        /// <summary>The language service object that created this object and calls its SynchronizeDropdowns method</summary>
        private LanguageService languageService;

        /// <summary>The correspoding VS object that represents the two drop down bars. The VS object uses call backs to pull information from
        /// this object and makes itself known to this object by calling SetDropdownBar</summary>
        private IVsDropdownBar dropDownBar;

        /// <summary>The icons that prefix the type names and member signatures</summary>
        private ImageList imageList;

        /// <summary>The current text editor window</summary>
        private IVsTextView textView;

        /// <summary>The list of types that appear in the type drop down list.</summary>
        private ArrayList dropDownTypes;

        /// <summary>The list of types that appear in the member drop down list. </summary>
        private ArrayList dropDownMembers;

        private int selectedType = -1;
        private int selectedMember = -1;

        const int DropClasses = 0;
        const int DropMethods = 1;

        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="TypeAndMemberDropdownBars.TypeAndMemberDropdownBars"]/*' />
        protected TypeAndMemberDropdownBars(LanguageService languageService) {
            this.languageService = languageService;
            this.dropDownTypes = new ArrayList();
            this.dropDownMembers = new ArrayList();
        }

        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="TypeAndMemberDropdownBars.Done"]/*' />
        public void Done() { 
            if (this.imageList != null) {
                imageList.Dispose();
                imageList = null;
            }
        }


        internal void SynchronizeDropdowns(IVsTextView textView, int line, int col) {
            if (this.dropDownBar == null) return;
            this.textView = textView;
            if (OnSynchronizeDropdowns(languageService, textView, line, col, this.dropDownTypes, this.dropDownMembers, ref this.selectedType, ref this.selectedMember)) {
                NativeMethods.ThrowOnFailure(this.dropDownBar.RefreshCombo(TypeAndMemberDropdownBars.DropClasses, this.selectedType));
                NativeMethods.ThrowOnFailure(this.dropDownBar.RefreshCombo(TypeAndMemberDropdownBars.DropMethods, this.selectedMember));
            }
        }



        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="TypeAndMemberDropdownBars.OnSynchronizeDropdowns"]/*' />
        /// <summary>
        /// This method is called to update the drop down bars to match the current contents of the text editor window. 
        /// It is called during OnIdle when the caret position changes.  You can provide new drop down members here.
        /// It is up to you to sort the ArrayLists if you want them sorted in any particular order.
        /// </summary>
        /// <param name="languageService">The language service</param>
        /// <param name="textView">The editor window</param>
        /// <param name="line">The line on which the cursor is now positioned</param>
        /// <param name="col">The column on which the cursor is now position</param>
        /// <param name="dropDownTypes">The current list of types (you can update this)</param>
        /// <param name="dropDownMembers">The current list of members (you can update this)</param>
        /// <param name="selectedType">The selected type (you can update this)</param>
        /// <param name="selectedMember">The selected member (you can update this)</param>
        /// <returns>true if something was updated</returns>
        public abstract bool OnSynchronizeDropdowns(LanguageService languageService, IVsTextView textView, int line, int col, ArrayList dropDownTypes, ArrayList dropDownMembers, ref int selectedType, ref int selectedMember);


        // IVsDropdownBarClient methods
        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="TypeAndMemberDropdownBars.GetComboAttributes"]/*' />
        public virtual int GetComboAttributes(int combo, out uint entries, out uint entryType, out IntPtr iList) {
            entries = 0;
            entryType = 0;
            if (combo == TypeAndMemberDropdownBars.DropClasses && this.dropDownTypes != null)
                entries = (uint)this.dropDownTypes.Count;
            else if (this.dropDownMembers != null)
                entries = (uint)this.dropDownMembers.Count;
            entryType = (uint)(DropDownItemType.HasText | DropDownItemType.HasFontAttribute | DropDownItemType.HasImage);
            if (this.imageList == null)
                this.imageList = this.languageService.GetImageList();
            iList = this.imageList.Handle;
            return NativeMethods.S_OK;
        }

        private enum DropDownItemType {
            HasText = 1,
            HasFontAttribute = 2,
            HasImage = 4
        }

        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="TypeAndMemberDropdownBars.GetComboTipText"]/*' />
        public virtual int GetComboTipText(int combo, out string text) {
            if (combo == TypeAndMemberDropdownBars.DropClasses)
                text = SR.GetString(SR.ComboTypesTip);
            else
                text = SR.GetString(SR.ComboMembersTip);
            return NativeMethods.S_OK;
        }

        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="TypeAndMemberDropdownBars.GetEntryAttributes"]/*' />
        public virtual int GetEntryAttributes(int combo, int entry, out uint fontAttrs) {
            fontAttrs = (uint)DROPDOWNFONTATTR.FONTATTR_PLAIN;
            DropDownMember member = GetMember(combo, entry);
            if (member != null) {
                fontAttrs = (uint)member.FontAttr;
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="TypeAndMemberDropdownBars.GetEntryImage"]/*' />
        public virtual int GetEntryImage(int combo, int entry, out int imgIndex) {
            // this happens during drawing and has to be fast 
            imgIndex = -1;
            DropDownMember member = GetMember(combo, entry);
            if (member != null) {
                imgIndex = member.Glyph;
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="TypeAndMemberDropdownBars.GetEntryText"]/*' />
        public virtual int GetEntryText(int combo, int entry, out string text) {
            text = null;
            DropDownMember member = GetMember(combo, entry);
            if (member != null) {
                text = member.Label;
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="TypeAndMemberDropdownBars.OnComboGetFocus"]/*' />
        public virtual int OnComboGetFocus(int combo) {
            return NativeMethods.S_OK;
        }

        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="TypeAndMemberDropdownBars.GetMember"]/*' />
        public DropDownMember GetMember(int combo, int entry) {
            if (combo == TypeAndMemberDropdownBars.DropClasses) {
                if (this.dropDownTypes != null && entry >= 0 && entry < this.dropDownTypes.Count)
                    return (DropDownMember)this.dropDownTypes[entry];
            } else {
                if (this.dropDownMembers != null && entry >= 0 && entry < this.dropDownMembers.Count)
                    return (DropDownMember)this.dropDownMembers[entry];
            }
            return null;
        }

        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="TypeAndMemberDropdownBars.OnItemChosen"]/*' />
        public virtual int OnItemChosen(int combo, int entry) {
            DropDownMember member = GetMember(combo, entry);

            if (member != null && this.textView != null) {
                int line = member.Span.iStartLine;
                int col = member.Span.iStartIndex;
                try {
                    // Here we don't want to throw or to check the return value.
                    textView.CenterLines(line, 16);
                } catch (COMException) { }
                NativeMethods.ThrowOnFailure(this.textView.SetCaretPos(line, col));
                NativeMethods.SetFocus(this.textView.GetWindowHandle());
                this.SynchronizeDropdowns(this.textView, line, col);
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="TypeAndMemberDropdownBars.SetFocus"]/*' />
        [DllImport("user32.dll")]
        static extern void SetFocus(IntPtr hwnd);

        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="TypeAndMemberDropdownBars.OnItemSelected"]/*' />
        public virtual int OnItemSelected(int combo, int index) {
            //nop
            return NativeMethods.S_OK;
        }

        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="TypeAndMemberDropdownBars.SetDropdownBar"]/*' />
        public virtual int SetDropdownBar(IVsDropdownBar bar) {
            this.dropDownBar = bar;
            return NativeMethods.S_OK;
        }
    }

    /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="DropDownMember"]/*' />
    [CLSCompliant(false)]
    public class DropDownMember : IComparable {

        private string label;
        private TextSpan span;
        private int glyph;
        private DROPDOWNFONTATTR fontAttr;

        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="DropDownMember.Label;"]/*' />
        public string Label {
            get {
                return this.label;
            }
            set {
                this.label = value;
            }
        }

        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="DropDownMember.Span;"]/*' />
        public TextSpan Span {
            get {
                return this.span;
            }
            set {
                this.span = value;
            }
        }
        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="DropDownMember.Glyph;"]/*' />
        public int Glyph {
            get {
                return this.glyph;
            }
            set {
                this.glyph = value;
            }
        }
        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="DropDownMember.FontAttr;"]/*' />
        public DROPDOWNFONTATTR FontAttr {
            get {
                return this.fontAttr;
            }
            set {
                this.fontAttr = value;
            }
        }

        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="DropDownMember.DropDownMember"]/*' />
        public DropDownMember(string label, TextSpan span, int glyph, DROPDOWNFONTATTR fontAttribute) {
            if (label == null) {
                throw new ArgumentNullException("label");
            }
            this.Label = label;
            this.Span = span;
            this.Glyph = glyph;
            this.FontAttr = fontAttribute;
        }

        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="DropDownMember.CompareTo"]/*' />
        public int CompareTo(object obj) {
            // if this overload is used then it assumes a case-sensitive current culture comparison
            // which allows for case-senstive languages to work
            return CompareTo(obj, StringComparison.CurrentCulture);
        }

        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="DropDownMember.CompareTo"]/*' />
        public int CompareTo(object obj, StringComparison stringComparison)
        {
            if (obj is DropDownMember)
            {
                return String.Compare(this.Label, ((DropDownMember)obj).Label, stringComparison);
            }
            return -1;
        }

        // Omitting Equals violates FxCop rule: IComparableImplementationsOverrideEquals.
        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="DropDownMember.Equals"]/*' />
        public override bool Equals(Object obj) {
            if (!(obj is DropDownMember))
                return false;
            return (this.CompareTo(obj, StringComparison.CurrentCulture) == 0);
        }

        // Omitting getHashCode violates FxCop rule: EqualsOverridesRequireGetHashCodeOverride.
        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="DropDownMember.GetHashCode"]/*' />
        public override int GetHashCode() {
            return this.Label.GetHashCode();
        }


        // Omitting any of the following operator overloads
        // violates FxCop rule: IComparableImplementationsOverrideOperators.
        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="DropDownMember.Operator=="]/*' />
        public static bool operator ==(DropDownMember m1, DropDownMember m2) {
            if (object.Equals(null, m1)) {
                return object.Equals(null, m2);
            }
            return m1.Equals(m2);
        }
        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="DropDownMember.Operator!="]/*' />
        public static bool operator !=(DropDownMember m1, DropDownMember m2) {
            return !(m1 == m2);
        }
        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="DropDownMember.OperatorMT"]/*' />
        public static bool operator <(DropDownMember m1, DropDownMember m2) {
            if (null == m1) {
                // Assume null < anything else and == null.
                return (null != m2);
            }
            else if (null == m2) {
                return false;
            }
            return (m1.CompareTo(m2, StringComparison.CurrentCulture) < 0);
        }
        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="DropDownMember.OperatorGT"]/*' />
        public static bool operator >(DropDownMember m1, DropDownMember m2) {
            if (null == m1) {
                // Assume null < anything else and == null.
                return false;
            }
            else if (null == m2) {
                return true;
            }
            return (m1.CompareTo(m2, StringComparison.CurrentCulture) > 0);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Babel\ParserStack.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/


namespace Babel.ParserGenerator
{
    public class ParserStack<T>
    {
        public T[] array = new T[1];
		public int top = 0;


        public void Push(T value)
        {
            if (top >= array.Length)
            {
                T[] newarray = new T[array.Length * 2];
                System.Array.Copy(array, newarray, top);
                array = newarray;
            }
            array[top++] = value;
        }

        public T Pop()
        {
            return array[--top];
        }

		public T Top()
		{
			return array[top - 1];
		}

        public bool IsEmpty()
        {
            return top == 0;
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Babel\ShiftReduceParser.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Collections.Generic;
using System.Text;
using System.Diagnostics;


namespace Babel.ParserGenerator
{
	public abstract class ShiftReduceParser<YYSTYPE,YYLTYPE> 
        where YYSTYPE : struct
        where YYLTYPE : IMerge<YYLTYPE>
    {
		public bool Trace = false;
		public AScanner<YYSTYPE,YYLTYPE> scanner;

		protected YYSTYPE yyval;
        protected YYLTYPE yyloc;
        // Experimental : last yylloc prior to call of yylex()
        protected YYLTYPE lastL;

        private int next;
        private State current_state;

        private bool recovering;
		private int tokensSinceLastError;

        private   ParserStack<State>   state_stack = new ParserStack<State>();
		protected ParserStack<YYSTYPE> value_stack = new ParserStack<YYSTYPE>();
        protected ParserStack<YYLTYPE> location_stack = new ParserStack<YYLTYPE>();

		protected string[] nonTerminals;
        protected State[]  states;
		protected Rule[]   rules;

        protected int errToken;
		protected int eofToken;



		protected abstract void Initialize();


		public bool Parse()
		{
			Initialize();	// allow derived classes to instantiate rules, states and nonTerminals

			next = 0;
			current_state = states[0];

			state_stack.Push(current_state);
			value_stack.Push(yyval);
            location_stack.Push(yyloc);

			while (true)
			{
				if (Trace)
					Console.Error.WriteLine("Entering state {0} ", current_state.num);

				int action = current_state.defaultAction;

				if (current_state.parser_table != null)
				{
					if (next == 0)
					{
						if (Trace)
							Console.Error.Write("Reading a token: ");

                        // We save the last token span, so that the location span
                        // of production right hand sides that begin or end with a
                        // nullable production will be correct.
                        lastL = scanner.yylloc;
                        next = scanner.yylex();
					}

					if (Trace)
						Console.Error.WriteLine("Next token is {0}", TerminalToString(next));

					if (current_state.parser_table.ContainsKey(next))
						action = current_state.parser_table[next];
				}

				if (action > 0)         // shift
				{
					Shift(action);
				}
				else if (action < 0)   // reduce
				{
					Reduce(-action);

					if (action == -1)	// accept
						return true;
				}
				else if (action == 0)   // error
					if (!ErrorRecovery())
						return false;
			}
		}


        protected void Shift(int state_nr)
        {
			if (Trace)
				Console.Error.Write("Shifting token {0}, ", TerminalToString(next));
            
            current_state = states[state_nr];

            value_stack.Push(scanner.yylval);
            state_stack.Push(current_state);
            location_stack.Push(scanner.yylloc);

			if (recovering)
			{
				if (next != errToken)
					tokensSinceLastError++;

				if (tokensSinceLastError > 5)
					recovering = false;
			}

			if (next != eofToken)
				next = 0;
        }


        protected void Reduce(int rule_nr)
        {
			if (Trace)
				DisplayRule(rule_nr);

			Rule rule = rules[rule_nr];
            //
            //  Default action "$$ = $1" for unit productions.
            //
            if (rule.rhs.Length == 1)
                yyval = value_stack.Top(); // default action: $$ = $1;
            else
                yyval = new YYSTYPE();
            //
            //  Default action "@$ = @1.Merge(@N)" for location info.
            //
            if (rule.rhs.Length == 1)
                yyloc = location_stack.Top();
            else if (rule.rhs.Length == 0)
                // The location span for an empty production will start with the
                // beginning of the next lexeme, and end with the finish of the
                // previous lexeme.  This gives the correct behaviour when this
                // nonsence value is used in later Merge operations.
                yyloc = (scanner.yylloc != null ? scanner.yylloc.Merge(lastL) : default(YYLTYPE));
            else
            {
                YYLTYPE at1 = location_stack.array[location_stack.top - rule.rhs.Length];
                YYLTYPE atN = location_stack.Top();
                if (at1 != null && atN != null) yyloc = at1.Merge(atN);
            }

            DoAction(rule_nr);

            for (int i = 0; i < rule.rhs.Length; i++)
            {
                state_stack.Pop();
                value_stack.Pop();
                location_stack.Pop();
            }

			if (Trace)
				DisplayStack();

			current_state = state_stack.Top();
            
			if (current_state.Goto.ContainsKey(rule.lhs))
				current_state = states[current_state.Goto[rule.lhs]];

            state_stack.Push(current_state);
            value_stack.Push(yyval);
            location_stack.Push(yyloc);
        }


		protected abstract void DoAction(int action_nr);

        public bool ErrorRecovery()
        {
            bool discard;

            if (!recovering) // if not recovering from previous error
                ReportError();

            if (!FindErrorRecoveryState())
               return false;
            //
            //  The interim fix for the "looping in error recovery"
            //  artifact involved moving the setting of the recovering 
            //  bool until after invalid tokens have been discarded.
            //
            ShiftErrorToken();
            discard = DiscardInvalidTokens();
            recovering = true;
            tokensSinceLastError = 0;
            return discard;
        }


		public void ReportError()
		{
            StringBuilder errorMsg = new StringBuilder();
            errorMsg.AppendFormat("syntax error, unexpected {0}", TerminalToString(next));

            if (current_state.parser_table.Count < 7)
            {
                bool first = true;
                foreach (int terminal in current_state.parser_table.Keys)
                {
                    if (first)
                        errorMsg.Append(", expecting ");
                    else
                        errorMsg.Append(", or ");

                    errorMsg.Append(TerminalToString(terminal));
                    first = false;
                }
            }
            scanner.yyerror(errorMsg.ToString());
            // System.Diagnostics.Trace.WriteLine(errorMsg.ToString());
		}


		public void ShiftErrorToken()
		{
			int old_next = next;
			next = errToken;

            //System.Diagnostics.Trace.WriteLine(
            //    String.Format("Shifting error in state {0}", current_state.num));

			Shift(current_state.parser_table[next]);

			if (Trace)
				Console.Error.WriteLine("Entering state {0} ", current_state.num);

            //System.Diagnostics.Trace.WriteLine(
            //    String.Format("Entering state {0}", current_state.num));

			next = old_next;
		}


		public bool FindErrorRecoveryState()
		{
			while (true)    // pop states until one found that accepts error token
			{
				if (current_state.parser_table != null &&
					current_state.parser_table.ContainsKey(errToken) &&
					current_state.parser_table[errToken] > 0) // shift
					return true;

				if (Trace)
					Console.Error.WriteLine("Error: popping state {0}", state_stack.Top().num);

                //System.Diagnostics.Trace.WriteLine(
                //    String.Format("Error: popping state {0}", state_stack.Top().num));

				state_stack.Pop();
				value_stack.Pop();
                location_stack.Pop();

				if (Trace)
					DisplayStack();

				if (state_stack.IsEmpty())
				{
					if (Trace)
                        Console.Error.Write("Aborting: didn't find a state that accepts error token");
                    //System.Diagnostics.Trace.WriteLine("Aborting: didn't find a state that accepts error token");
                    return false;
				}
				else
					current_state = state_stack.Top();
			}
		}


		public bool DiscardInvalidTokens()
		{
			
			int action = current_state.defaultAction;

            if (current_state.parser_table != null)
            {
                // Discard tokens until find one that works ...
                while (true)
                {
                    if (next == 0)
                    {
                        if (Trace)
                            Console.Error.Write("Reading a token: ");

                        next = scanner.yylex();
                    }

                    if (Trace)
                        Console.Error.WriteLine("Next token is {0}", TerminalToString(next));

                    if (next == eofToken)
                        return false;

                    if (current_state.parser_table.ContainsKey(next))
                        action = current_state.parser_table[next];

                    if (action != 0)
                        return true;
                    else
                    {
                        if (Trace)
                            Console.Error.WriteLine("Error: Discarding {0}", TerminalToString(next));
                        next = 0;
                    }
                }
            }
            else if (recovering && tokensSinceLastError == 0)
            {
                // 
                //  Boolean recovering is not set until after the first
                //  error token has been shifted.  Thus if we get back 
                //  here with recovering set and no tokens read we are
                //  looping on the same error recovery action.  This 
                //  happens if current_state.parser_table is null because
                //  the state has an LR(0) reduction, but not all
                //  lookahead tokens are valid.  This only occurs for
                //  error productions that *end* on "error".
                //
                //  This action discards tokens one at a time until
                //  the looping stops.  Another attack would be to always
                //  use the LALR(1) table if a production ends on "error"
                //
                if (Trace)
                    Console.Error.WriteLine("Error: panic discard of {0}", TerminalToString(next));
                next = 0;
                return true;
            }
            else
                return true;

		}


        protected void yyclearin()  // experimental in this version.
        {
            next = 0;
        }

		protected void yyerrok()
		{
			recovering = false;
		}


		protected void AddState(int statenr, State state)
		{
			states[statenr] = state;
			state.num = statenr;
		}




		private void DisplayStack()
		{
			Console.Error.Write("State now");
			for (int i=0; i<state_stack.top; i++)
				Console.Error.Write(" {0}", state_stack.array[i].num);
			Console.Error.WriteLine();
		}


		private void DisplayRule(int rule_nr)
		{
			Console.Error.Write("Reducing stack by rule {0}, ", rule_nr);
			DisplayProduction(rules[rule_nr]);
		}


		private void DisplayProduction(Rule rule)
		{
			if (rule.rhs.Length == 0)
				Console.Error.Write("/* empty */ ");
			else
				foreach (int symbol in rule.rhs)
					Console.Error.Write("{0} ", SymbolToString(symbol));

			Console.Error.WriteLine("-> {0}", SymbolToString(rule.lhs));
		}


		protected abstract string TerminalToString(int terminal);


		private string SymbolToString(int symbol)
		{
			if (symbol < 0)
				return nonTerminals[-symbol];
			else
				return TerminalToString(symbol);
		}


		protected string CharToString(char ch)
		{
			switch (ch)
			{
				case '\a': return @"'\a'";
				case '\b': return @"'\b'";
				case '\f': return @"'\f'";
				case '\n': return @"'\n'";
				case '\r': return @"'\r'";
				case '\t': return @"'\t'";
				case '\v': return @"'\v'";
				case '\0': return @"'\0'";
				default: return string.Format("'{0}'", ch);
			}
		}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Babel\Source.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.VisualStudio.TextManager.Interop;
using Microsoft.VisualStudio.Package;

namespace Babel
{
	public class Source : Microsoft.VisualStudio.Package.Source
	{
		public Source(BabelLanguageService service, IVsTextLines textLines, Colorizer colorizer)
			: base(service, textLines, colorizer)
		{
		}

		private object parseResult;
		public object ParseResult
		{
			get { return parseResult; }
			set { parseResult = value; }
		}

		private IList<TextSpan[]> braces;
		public IList<TextSpan[]> Braces
		{
			get { return braces; }
			set { braces = value; }
		}

        public override CommentInfo GetCommentFormat()
        {
             return Configuration.MyCommentInfo;
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\LanguageService100\DocumentProperties.cs ===
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using Microsoft.VisualStudio.Shell;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.TextManager.Interop;
using System.ComponentModel;
using Ole = Microsoft.VisualStudio.OLE.Interop;
using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
using IServiceProvider = System.IServiceProvider;

namespace Microsoft.VisualStudio.Package {

/// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="DocumentProperties"]/*' />
/// <summary>
/// This class can be used as a base class for document properties which are 
/// displayed in the Properties Window when the document is active.  Simply add
/// some public properties and they will show up in the properties window.  
/// </summary>
    [CLSCompliant(false)]
    public abstract class DocumentProperties : LocalizableProperties, ISelectionContainer, IDisposable {
        internal CodeWindowManager mgr;
        internal IVsTrackSelectionEx tracker;
        private bool visible;

        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="DocumentProperties.DocumentProperties"]/*' />
        protected DocumentProperties(CodeWindowManager mgr) {
            this.mgr = mgr;
            this.visible = true;
            if (mgr != null) {
                IOleServiceProvider sp = mgr.CodeWindow as IOleServiceProvider;
                if (sp != null) {
                    ServiceProvider site = new ServiceProvider(sp);
                    this.tracker = site.GetService(typeof(SVsTrackSelectionEx)) as IVsTrackSelectionEx;
                }
            }
        }

        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="DocumentProperties.Visible"]/*' />
        [BrowsableAttribute(false)]
        public bool Visible {
            get { return this.visible; }
            set { if (this.visible != value) { this.visible = value; Refresh(); } }
        }

        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="DocumentProperties.UpdateSelection"]/*' />
        /// <summary>
        /// Call this method when you want the document properties window updated with new information.
        /// </summary>
        public void Refresh() {
            if (this.tracker != null && this.visible) {
                NativeMethods.ThrowOnFailure(tracker.OnSelectChange(this));
            }
        }

        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="DocumentProperties.GetSource"]/*' />
        /// This is not a property because all public properties show up in the Properties window.
        public Source GetSource() {
            if (this.mgr == null) return null;
            return this.mgr.Source;
        }

        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="DocumentProperties.GetCodeWindowManager"]/*' />
        /// This is not a property because all public properties show up in the Properties window.
        public CodeWindowManager GetCodeWindowManager() {
            return this.mgr;
        }

        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="DocumentProperties.Close"]/*' />
        public void Close() {
            if (this.tracker != null && this.visible)
                NativeMethods.ThrowOnFailure(tracker.OnSelectChange(null));

            this.Dispose(true);
        }

        #region IDisposable Members


        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="DocumentProperties.Dispose"]/*' />
        public void Dispose() {
            Dispose(true);
            // This object will be cleaned up by the Dispose method.
            // Therefore, you should call GC.SupressFinalize
            GC.SuppressFinalize(this);
        }


        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="DocumentProperties.Dispose"]/*' />
        protected virtual void Dispose(bool disposing) {
            // If disposing equals true, dispose all managed 
            // and unmanaged resources.
            if (disposing) {
                // Dispose managed resources.
                
            }
            this.tracker = null;
            this.mgr = null;
        }

        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="DocumentProperties.Finalize"]/*' />
        ~DocumentProperties() {
            Dispose(false);
        }
        #endregion

        #region ISelectionContainer methods.
        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="DocumentProperties.CountObjects"]/*' />
        public virtual int CountObjects(uint flags, out uint pc) {
            pc = this.visible ? (uint)1 : (uint)0;
            return NativeMethods.S_OK;
        }
        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="DocumentProperties.GetObjects"]/*' />
        public virtual int GetObjects(uint flags, uint count, object[] ppUnk) {
            if (count == 1) {
                ppUnk[0] = this;
            }
            return NativeMethods.S_OK;
        }
        /// <include file='doc\CodeWindowManager.uex' path='docs/doc[@for="DocumentProperties.SelectObjects"]/*' />
        public virtual int SelectObjects(uint sel, object[] selobj, uint flags) {
            // nop
            return NativeMethods.S_OK;
        }
    #endregion
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\LanguageService100\DocumentTask.cs ===
using System;
//using System.CodeDom.Compiler;
using System.Runtime.InteropServices;
using System.Xml;
using System.Collections;
using System.IO;
using System.Text;
using System.Drawing;
using System.Windows.Forms;
using System.Diagnostics;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.TextManager.Interop;
using Microsoft.VisualStudio.Shell;
using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
using IServiceProvider = System.IServiceProvider;
using VsShell = Microsoft.VisualStudio.Shell.VsShellUtilities;

namespace Microsoft.VisualStudio.Package {

    // DocumentTask is associated with an IVsTextLineMarker in a specified document and 
    // implements Navigate() to jump to that marker.
    /// <include file='doc\DocumentTask.uex' path='docs/doc[@for="DocumentTask"]/*' />
    [CLSCompliant(false)]
    [System.Runtime.InteropServices.ComVisible(true)]
    public class DocumentTask : ErrorTask, IVsTextMarkerClient, IDisposable {
        // Since all taskitems support this field we define it generically. Can use put_Text to set it.
        IServiceProvider site;
        string fileName;
        IVsTextLineMarker textLineMarker;
        TextSpan span;        
        bool markerValid;

        /// <include file='doc\DocumentTask.uex' path='docs/doc[@for="DocumentTask.DocumentTask"]/*' />
        public DocumentTask(IServiceProvider site, IVsTextLines buffer, MARKERTYPE markerType, TextSpan span, string fileName) {

            this.site = site;
            this.fileName = fileName;
            this.span = span;
            this.Document = this.fileName;
            this.Column = span.iStartIndex;
            this.Line = span.iStartLine;

            if (markerType != MARKERTYPE.MARKER_OTHER_ERROR) {
                // create marker so task item navigation works even after file is edited.
                IVsTextLineMarker[] marker = new IVsTextLineMarker[1];
                NativeMethods.ThrowOnFailure(buffer.CreateLineMarker((int)markerType, span.iStartLine, span.iStartIndex, span.iEndLine, span.iEndIndex, this, marker));
                this.textLineMarker = marker[0];
                this.markerValid = true;
            }
            
            
        }
        /// <include file='doc\DocumentTask.uex' path='docs/doc[@for="DocumentTask.Finalize"]/*' />
        ~DocumentTask() {
            Dispose(false);
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="DocumentTask.IsMarkerValid"]/*' />
        public bool IsMarkerValid {
            get {
                return this.markerValid;
            }
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="DocumentTask.Site"]/*' />
        public IServiceProvider Site {
            get { return this.site; }
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="DocumentTask.Dispose"]/*' />
        public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="DocumentTask.Dispose1"]/*' />
        protected virtual void Dispose(bool disposing) {
            if (this.textLineMarker != null){
                this.textLineMarker.UnadviseClient();
            }
            this.textLineMarker = null;
            this.site = null;
        }

        /// <include file='doc\DocumentTask.uex' path='docs/doc[@for="DocumentTask.OnNavigate"]/*' />
        protected override void OnNavigate(EventArgs e) {

            TextSpan span = this.span;
            if (textLineMarker != null) {
                TextSpan[] spanArray = new TextSpan[1];
                NativeMethods.ThrowOnFailure(textLineMarker.GetCurrentSpan(spanArray));
                span = spanArray[0];
            }

            IVsUIHierarchy hierarchy;
            uint itemID;
            IVsWindowFrame docFrame;
            IVsTextView textView;
            VsShell.OpenDocument(this.site, this.fileName, NativeMethods.LOGVIEWID_Code, out hierarchy, out itemID, out docFrame, out textView);
            NativeMethods.ThrowOnFailure(docFrame.Show());
            if (textView != null) {
                NativeMethods.ThrowOnFailure(textView.SetCaretPos(span.iStartLine, span.iStartIndex));
                TextSpanHelper.MakePositive(ref span);
                NativeMethods.ThrowOnFailure(textView.SetSelection(span.iStartLine, span.iStartIndex, span.iEndLine, span.iEndIndex));
                NativeMethods.ThrowOnFailure(textView.EnsureSpanVisible(span));
            }
            base.OnNavigate(e);
        }

        /// <include file='doc\DocumentTask.uex' path='docs/doc[@for="DocumentTask.OnRemoved"]/*' />
        protected override void OnRemoved(EventArgs e) {
            if (textLineMarker != null) {
                NativeMethods.ThrowOnFailure(textLineMarker.Invalidate());
                this.markerValid = false;
            }
            textLineMarker = null;
            this.site = null;
            base.OnRemoved(e);
        }

        /// <include file='doc\DocumentTask.uex' path='docs/doc[@for="DocumentTask.Span"]/*' />
        public TextSpan Span {
            get {
                if (textLineMarker != null) {
                    TextSpan[] aSpan = new TextSpan[1];
                    NativeMethods.ThrowOnFailure(textLineMarker.GetCurrentSpan(aSpan));
                    return aSpan[0];
                }
                return this.span;
            }
        }

        /// <include file='doc\DocumentTask.uex' path='docs/doc[@for="DocumentTask.TextLineMarker"]/*' />
        public IVsTextLineMarker TextLineMarker {
            get { return this.textLineMarker; }
        }

        #region IVsTextMarkerClient methods

        /*---------------------------------------------------------
            IVsTextMarkerClient
        -----------------------------------------------------------*/
        /// <include file='doc\DocumentTask.uex' path='docs/doc[@for="DocumentTask.MarkerInvalidated"]/*' />
        public virtual void MarkerInvalidated() {
            this.markerValid = false;            
        }

        /// <include file='doc\DocumentTask.uex' path='docs/doc[@for="DocumentTask.OnBufferSave"]/*' />
        public virtual void OnBufferSave(string fileName) {
        }

        /// <include file='doc\DocumentTask.uex' path='docs/doc[@for="DocumentTask.OnBeforeBufferClose"]/*' />
        public virtual void OnBeforeBufferClose() {
        }

        /// <include file='doc\DocumentTask.uex' path='docs/doc[@for="DocumentTask.OnAfterSpanReload"]/*' />
        public virtual void OnAfterSpanReload() {
        }

        /// <include file='doc\DocumentTask.uex' path='docs/doc[@for="DocumentTask.OnAfterMarkerChange"]/*' />
        public virtual int OnAfterMarkerChange(IVsTextMarker marker) {
            return NativeMethods.S_OK;
        }

        /// <include file='doc\DocumentTask.uex' path='docs/doc[@for="DocumentTask.GetTipText"]/*' />
        public virtual int GetTipText(IVsTextMarker marker, string[] tipText) {
            if (this.Text != null && this.Text.Length > 0) tipText[0] = this.Text;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\DocumentTask.uex' path='docs/doc[@for="DocumentTask.GetMarkerCommandInfo"]/*' />
        public virtual int GetMarkerCommandInfo(IVsTextMarker marker, int item, string[] text, uint[] commandFlags) {
            // Returning S_OK results in error message appearing in editor's
            // context menu when you right click over the error message.
            if (commandFlags != null && commandFlags.Length > 0)
                commandFlags[0] = 0;
            if (text != null && text.Length > 0)
                text[0] = null;
            return NativeMethods.E_NOTIMPL;
        }

        /// <include file='doc\DocumentTask.uex' path='docs/doc[@for="DocumentTask.ExecMarkerCommand"]/*' />
        public virtual int ExecMarkerCommand(IVsTextMarker marker, int item) {
            return NativeMethods.S_OK;
        }
        #endregion 
    };

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\LanguageService100\ExpansionProvider.cs ===
//#define TRACE_EXEC
using System;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.TextManager.Interop;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell;
using System.Runtime.InteropServices;
using System.Collections;
using System.IO;
using Microsoft.Win32;
using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
using IServiceProvider = System.IServiceProvider;
using System.Diagnostics;
using System.Xml;
using System.Text;
using VsCommands = Microsoft.VisualStudio.VSConstants.VSStd97CmdID;
using VsCommands2K = Microsoft.VisualStudio.VSConstants.VSStd2KCmdID;

namespace Microsoft.VisualStudio.Package {

    /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="DefaultFieldValue"]/*' />
    public class DefaultFieldValue {
        private string field;
        private string value;

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="DefaultFieldValue.DefaultFieldValue"]/*' />
        public DefaultFieldValue(string field, string value) {
            this.field = field;
            this.value = value;
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="DefaultFieldValue.Field"]/*' />
        public string Field {
            get { return this.field; }
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="DefaultFieldValue.Value"]/*' />
        public string Value {
            get { return this.value; }
        }
    }

    /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionProvider"]/*' />
    [CLSCompliant(false)]
    [System.Runtime.InteropServices.ComVisible(true)]
    public class ExpansionProvider : IDisposable, IVsExpansionClient {
        IVsTextView view;
        Source source;
        IVsExpansion vsExpansion;
        IVsExpansionSession expansionSession;
        bool expansionActive;
        bool expansionPrepared;
        bool completorActiveDuringPreExec;
        ArrayList fieldDefaults; // CDefaultFieldValues
        string titleToInsert;
        string pathToInsert;

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionProvider.ExpansionProvider"]/*' />
        public ExpansionProvider(Source src) {
            if (src == null){
                throw new ArgumentNullException("src");
            }
            this.fieldDefaults = new ArrayList();
            if (src == null)
                throw new System.ArgumentNullException();

            this.source = src;
            this.vsExpansion = null; // do we need a Close() method here?

            // QI for IVsExpansion
            IVsTextLines buffer = src.GetTextLines();
            this.vsExpansion = (IVsExpansion)buffer;
            if (this.vsExpansion == null) {
                throw new ArgumentNullException("(IVsExpansion)src.GetTextLines()");
            }
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionProvider.Finalize"]/*' />
        ~ExpansionProvider() {
#if LANGTRACE
            Trace.WriteLine("~ExpansionProvider");
#endif
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionProvider.Dispose"]/*' />
        public virtual void Dispose() {
            EndTemplateEditing(true);
            this.source = null;
            this.vsExpansion = null;
            this.view = null;
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionProvider.Source"]/*' />
        public Source Source {
            get { return this.source; }
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionProvider.TextView"]/*' />
        public IVsTextView TextView {
            get { return this.view; }
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionProvider.Expansion"]/*' />
        public IVsExpansion Expansion {
            get { return this.vsExpansion; }
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionProvider.ExpansionSession"]/*' />
        public IVsExpansionSession ExpansionSession {
            get { return this.expansionSession; }
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionProvider.HandleQueryStatus"]/*' />
        public virtual bool HandleQueryStatus(ref Guid guidCmdGroup, uint nCmdId, out int hr) {
            // in case there's something to conditinally support later on...
            hr = 0;
            return false;
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionProvider.InTemplateEditingMode"]/*' />
        public virtual bool InTemplateEditingMode {
            get {
                return this.expansionActive;
            }
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionProvider.InTemplateEditingMode"]/*' />
        public virtual TextSpan GetExpansionSpan() {
            if (this.expansionSession == null){
                throw new System.InvalidOperationException(SR.GetString(SR.NoExpansionSession));
            }
            TextSpan[] pts = new TextSpan[1];
            int hr = this.expansionSession.GetSnippetSpan(pts);
            if (NativeMethods.Succeeded(hr)) {
                return pts[0];
            }
            return new TextSpan();
        }


        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionProvider.HandlePreExec"]/*' />
        public virtual bool HandlePreExec(ref Guid guidCmdGroup, uint nCmdId, uint nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut) {
            if (!this.expansionActive || this.expansionSession == null) {
				return false;
            }

            this.completorActiveDuringPreExec = this.IsCompletorActive(this.view);            

            if (guidCmdGroup == typeof(VsCommands2K).GUID) {
                VsCommands2K cmd = (VsCommands2K)nCmdId;
#if TRACE_EXEC
                Trace.WriteLine(String.Format("ExecCommand: {0}", cmd.ToString()));
#endif
                switch (cmd) {
                    case VsCommands2K.CANCEL:
                        if (this.completorActiveDuringPreExec)
                            return false;
                        EndTemplateEditing(true);
                        return true;
                    case VsCommands2K.RETURN:
                        bool leaveCaret = false;
                        int line = 0, col = 0;
                        if (NativeMethods.Succeeded(this.view.GetCaretPos(out line, out col))) {
                            TextSpan span = GetExpansionSpan();
                            if (!TextSpanHelper.ContainsExclusive(span, line, col)) {
                                leaveCaret = true;
                            }
                        }
                        if (this.completorActiveDuringPreExec)
                            return false;
                        EndTemplateEditing(leaveCaret);
                        if (leaveCaret)
                            return false;
                        return true;
                    case VsCommands2K.BACKTAB:
                        if (this.completorActiveDuringPreExec)
                            return false;
                        this.expansionSession.GoToPreviousExpansionField();
                        return true;
                    case VsCommands2K.TAB:
                        if (this.completorActiveDuringPreExec)
                            return false;
                        this.expansionSession.GoToNextExpansionField(0); // fCommitIfLast=false
                        return true;
#if TRACE_EXEC
                    case VsCommands2K.TYPECHAR:
                        if (pvaIn != IntPtr.Zero) {
                            Variant v = Variant.ToVariant(pvaIn);
                            char ch = v.ToChar();
                            Trace.WriteLine(String.Format("TYPECHAR: {0}, '{1}', {2}", cmd.ToString(), ch.ToString(), (int)ch));
                        }
                        return true;
#endif
                }
            }
            return false;
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionProvider.HandlePostExec"]/*' />
        public virtual bool HandlePostExec(ref Guid guidCmdGroup, uint nCmdId, uint nCmdexecopt, bool commit, IntPtr pvaIn, IntPtr pvaOut) {
            if (guidCmdGroup == typeof(VsCommands2K).GUID) {
                VsCommands2K cmd = (VsCommands2K)nCmdId;
                switch (cmd) {
                    case VsCommands2K.RETURN:
                        if (this.completorActiveDuringPreExec && commit) {
                            // if the completor was active during the pre-exec we want to let it handle the command first
                            // so we didn't deal with this in pre-exec. If we now get the command, we want to end
                            // the editing of the expansion. We also return that we handled the command so auto-indenting doesn't happen
                            EndTemplateEditing(false);
                            this.completorActiveDuringPreExec = false;
                            return true;
                        }
                        break;
                }
            }
            this.completorActiveDuringPreExec = false;
            return false;
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionProvider.DisplayExpansionBrowser"]/*' />
        public virtual bool DisplayExpansionBrowser(IVsTextView view, string prompt, string[] types, bool includeNullType, string[] kinds, bool includeNullKind) {
            if (this.expansionActive) this.EndTemplateEditing(true);

            if (this.source.IsCompletorActive) {
                this.source.DismissCompletor();
            }

            this.view = view;
            IServiceProvider site = this.source.LanguageService.Site;
            IVsTextManager2 textmgr = site.GetService(typeof(SVsTextManager)) as IVsTextManager2;
            if (textmgr == null) return false;
            
            IVsExpansionManager exmgr;
            textmgr.GetExpansionManager(out exmgr);
            Guid languageSID = this.source.LanguageService.GetLanguageServiceGuid();
            int hr = 0;
            if (exmgr != null) {
                hr = exmgr.InvokeInsertionUI(view, // pView
                    this, // pClient
                    languageSID, // guidLang
                    types, // bstrTypes
                    (types == null) ? 0 : types.Length, // iCountTypes
                    includeNullType ? 1 : 0,  // fIncludeNULLType
                    kinds, // bstrKinds
                    (kinds == null) ? 0 : kinds.Length, // iCountKinds
                    includeNullKind ? 1 : 0, // fIncludeNULLKind
                    prompt, // bstrPrefixText
                    ">" //bstrCompletionChar
                    );
                if (NativeMethods.Succeeded(hr)) {
                    return true;
                }
            }

            return false;
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionProvider.InsertSpecificExpansion"]/*' />
        public virtual bool InsertSpecificExpansion(IVsTextView view, XmlElement snippet, TextSpan pos, string relativePath) {
            if (this.expansionActive) this.EndTemplateEditing(true);

            if (this.source.IsCompletorActive) {
                this.source.DismissCompletor();
            }

            this.view = view;
            MSXML.IXMLDOMDocument doc = new MSXML.DOMDocumentClass();
            if (!doc.loadXML(snippet.OuterXml)) {
                throw new ArgumentException(doc.parseError.reason);
            }
            Guid guidLanguage = this.source.LanguageService.GetLanguageServiceGuid();

            int hr = this.vsExpansion.InsertSpecificExpansion(doc, pos, this, guidLanguage, relativePath, out this.expansionSession);
            if (hr != NativeMethods.S_OK) {
                this.EndTemplateEditing(true);
            } else {
                // When inserting a snippet it is possible that the edit session is ended inside the insert
                // function (e.g. if the template has no editable fields). In this case we should not stay
                // in template edit mode because otherwise our filter will stole messages to the editor.
                if (!this.expansionActive) {
                    this.expansionSession = null;
                }
                return true;
            }
            return false;
        }

        bool IsCompletorActive(IVsTextView view){
            if (this.source.IsCompletorActive)
                return true;

            IVsTextViewEx viewex = view as IVsTextViewEx;
            if (viewex  != null) {
                return viewex.IsCompletorWindowActive() == VSConstants.S_OK;
            }

            return false;
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionProvider.InsertNamedExpansion"]/*' />
        public virtual bool InsertNamedExpansion(IVsTextView view, string title, string path, TextSpan pos, bool showDisambiguationUI) {

            if (this.source.IsCompletorActive) {
                this.source.DismissCompletor();
            }

            this.view = view;
            if (this.expansionActive) this.EndTemplateEditing(true);

            Guid guidLanguage = this.source.LanguageService.GetLanguageServiceGuid();

            int hr = this.vsExpansion.InsertNamedExpansion(title, path, pos, this, guidLanguage, showDisambiguationUI ? 1 : 0, out this.expansionSession);

            if (hr != NativeMethods.S_OK) {
                this.EndTemplateEditing(true);
                return false;
            } else if (hr == NativeMethods.S_OK) {
                // When inserting a snippet it is possible that the edit session is ended inside the insert
                // function (e.g. if the template has no editable fields). In this case we should not stay
                // in template edit mode because otherwise our filter will stole messages to the editor.
                if (!this.expansionActive) {
                    this.expansionSession = null;
                }
                return true;
            }
            return false;
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionProvider.FindExpansionByShortcut"]/*' />
        /// <summary>Returns S_OK if match found, S_FALSE if expansion UI is shown, and error otherwise</summary>
        public virtual int FindExpansionByShortcut(IVsTextView view, string shortcut, TextSpan span, bool showDisambiguationUI, out string title, out string path) {
            if (this.expansionActive) this.EndTemplateEditing(true);
            this.view = view;
            title = path = null;

            LanguageService svc = this.source.LanguageService;
            IVsExpansionManager mgr = svc.Site.GetService(typeof(SVsExpansionManager)) as IVsExpansionManager;
            if (mgr == null) return NativeMethods.E_FAIL ;
            Guid guidLanguage = svc.GetLanguageServiceGuid();

            TextSpan[] pts = new TextSpan[1];
            pts[0] = span;
            int hr = mgr.GetExpansionByShortcut(this, guidLanguage, shortcut, this.TextView, pts, showDisambiguationUI ? 1 : 0, out path, out title);
            return hr;
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionProvider.GetExpansionFunction1"]/*' />
        public virtual IVsExpansionFunction GetExpansionFunction(XmlElement xmlFunctionNode, string fieldName) {
            string functionName = null;
            ArrayList rgFuncParams = new ArrayList();

            // first off, get the function string from the node
            string function = xmlFunctionNode.InnerText;

            if (function == null || function.Length == 0)
                return null;

            bool inIdent = false;
            bool inParams = false;
            int token = 0;

            // initialize the vars needed for our super-complex function parser :-)
            for (int i = 0, n = function.Length; i < n; i++) {
                char ch = function[i];

                // ignore and skip whitespace
                if (!Char.IsWhiteSpace(ch)) {
                    switch (ch) {
                        case ',':
                            if (!inIdent || !inParams)
                                i = n; // terminate loop
                            else {
                                // we've hit a comma, so end this param and move on...
                                string name = function.Substring(token, i - token);
                                rgFuncParams.Add(name);
                                inIdent = false;
                            }
                            break;
                        case '(':
                            if (!inIdent || inParams)
                                i = n; // terminate loop
                            else {
                                // we've hit the (, so we know the token before this is the name of the function
                                functionName = function.Substring(token, i - token);
                                inIdent = false;
                                inParams = true;
                            }
                            break;
                        case ')':
                            if (!inParams)
                                i = n; // terminate loop
                            else {
                                if (inIdent) {
                                    // save last param and stop
                                    string name = function.Substring(token, i - token);
                                    rgFuncParams.Add(name);
                                    inIdent = false;
                                }
                                i = n; // terminate loop
                            }
                            break;
                        default:
                            if (!inIdent) {
                                inIdent = true;
                                token = i;
                            }
                            break;
                    }
                }
            }

            if (functionName != null && functionName.Length > 0) {
                ExpansionFunction func = this.source.LanguageService.CreateExpansionFunction(this, functionName);
                if (func != null) {
                    func.FieldName = fieldName;
                    func.Arguments = (string[])rgFuncParams.ToArray(typeof(string));
                    return func;
                }
            }
            return null;
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionProvider.PrepareTemplate"]/*' />
        public virtual void PrepareTemplate(string title, string path) {            
            if (title == null)
                throw new System.ArgumentNullException("title");

            // stash the title and path for when we actually insert the template
            this.titleToInsert = title;
            this.pathToInsert = path;
            this.expansionPrepared = true;
        }

        void SetFieldDefault(string field, string value) {
            if (!this.expansionPrepared) {
                throw new System.InvalidOperationException(SR.GetString(SR.TemplateNotPrepared));
            }
            if (field == null) throw new System.ArgumentNullException("field");
            if (value == null) throw new System.ArgumentNullException("value");

            // we have an expansion "prepared" to insert, so we can now save this
            // field default to set when the expansion is actually inserted
            this.fieldDefaults.Add(new DefaultFieldValue(field, value));
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionProvider.BeginTemplateEditing"]/*' />
        public virtual void BeginTemplateEditing(int line, int col) {
            if (!this.expansionPrepared) {
                throw new System.InvalidOperationException(SR.GetString(SR.TemplateNotPrepared));
            }

            TextSpan tsInsert = new TextSpan();
            tsInsert.iStartLine = tsInsert.iEndLine = line;
            tsInsert.iStartIndex = tsInsert.iEndIndex = col;

            Guid languageSID = this.source.LanguageService.GetType().GUID;

            int hr = this.vsExpansion.InsertNamedExpansion(
                this.titleToInsert,
                this.pathToInsert,
                tsInsert,
                (IVsExpansionClient)this,
                languageSID,
                0, // fShowDisambiguationUI,
                out this.expansionSession
            );

            if (hr != NativeMethods.S_OK) {
                this.EndTemplateEditing(true);
            }
            this.pathToInsert = null;
            this.titleToInsert = null;
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionProvider.EndTemplateEditing"]/*' />
        public virtual void EndTemplateEditing(bool leaveCaret) {
            if (!this.expansionActive || this.expansionSession == null) {
                this.expansionActive = false;
                return;
            }

            this.expansionSession.EndCurrentExpansion(leaveCaret ? 1 : 0); // fLeaveCaret=true
            this.expansionSession = null;
            this.expansionActive = false;
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionProvider.GetFieldSpan"]/*' />
        public virtual bool GetFieldSpan(string field, out TextSpan pts) {
            if (this.expansionSession == null) {
                throw new System.InvalidOperationException(SR.GetString(SR.NoExpansionSession));
            }
            if (this.expansionSession != null) {
                TextSpan[] apt = new TextSpan[1];
                this.expansionSession.GetFieldSpan(field, apt);
                pts = apt[0];
                return true;
            } else {
                pts = new TextSpan();
                return false;
            }
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionProvider.GetFieldValue"]/*' />
        public virtual bool GetFieldValue(string field, out string value) {
            if (this.expansionSession == null) {
                throw new System.InvalidOperationException(SR.GetString(SR.NoExpansionSession));
            }
            if (this.expansionSession != null) {
                this.expansionSession.GetFieldValue(field, out value);
            } else {
                value = null;
            }
            return value != null;
        }

        #region IVsExpansionClient Members

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionProvider.EndExpansion"]/*' />
        public int EndExpansion() {
            this.expansionActive = false;
            this.expansionSession = null;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionProvider.FormatSpan"]/*' />
        public virtual int FormatSpan(IVsTextLines buffer, TextSpan[] ts) {
            if (this.source.GetTextLines() != buffer) {
                throw new System.ArgumentException(SR.GetString(SR.UnknownBuffer), "buffer");
            }
            int rc = NativeMethods.E_NOTIMPL;
            if (ts != null) {
                for (int i = 0, n = ts.Length; i < n; i++) {
                    if (this.source.LanguageService.Preferences.EnableFormatSelection) {
                        TextSpan span = ts[i];
                        // We should not merge edits in this case because it might clobber the
                        // $varname$ spans which are markers for yellow boxes.
                        using (EditArray edits = new EditArray(this.source, this.view, false, SR.GetString(SR.FormatSpan))) {
                            this.source.ReformatSpan(edits, span);
                            edits.ApplyEdits();
                        }
                        rc = NativeMethods.S_OK;
                    }
                }
            }
            return rc;
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionProvider.IsValidKind"]/*' />
        public virtual int IsValidKind(IVsTextLines buffer, TextSpan[] ts, string bstrKind, out int /*BOOL*/ fIsValid)
        {
            fIsValid = 0;
            if (this.source.GetTextLines() != buffer)
            {
                throw new System.ArgumentException(SR.GetString(SR.UnknownBuffer), "buffer");
            }

            fIsValid = 1;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionProvider.IsValidType"]/*' />
        public virtual int IsValidType(IVsTextLines buffer, TextSpan[] ts, string[] rgTypes, int iCountTypes, out int /*BOOL*/ fIsValid)
        {
            fIsValid = 0;
            if (this.source.GetTextLines() != buffer) {
                throw new System.ArgumentException(SR.GetString(SR.UnknownBuffer), "buffer");
            }
            
            fIsValid = 1;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionProvider.OnItemChosen"]/*' />
        public virtual int OnItemChosen(string pszTitle, string pszPath) {
            TextSpan ts;
            view.GetCaretPos(out ts.iStartLine, out ts.iStartIndex);
            ts.iEndLine = ts.iStartLine;
            ts.iEndIndex = ts.iStartIndex;

            if (this.expansionSession != null) { // previous session should have been ended by now!
                EndTemplateEditing(true);
            }

            Guid languageSID = this.source.LanguageService.GetType().GUID;

            // insert the expansion
            using (CompoundActionBase cab = CompoundActionFactory.GetCompoundAction(this.view, this.source, SR.FormatSpan)) { 
                return this.vsExpansion.InsertNamedExpansion(pszTitle,
                    pszPath, 
                    ts,
                    (IVsExpansionClient)this,
                    languageSID,
                    0, // fShowDisambiguationUI, (FALSE)
                    out this.expansionSession);
            }
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionProvider.PositionCaretForEditing"]/*' />
        public virtual int PositionCaretForEditing(IVsTextLines pBuffer, TextSpan[] ts) {
            // NOP
            return NativeMethods.S_OK;
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionProvider.OnAfterInsertion"]/*' />
        public virtual int OnAfterInsertion(IVsExpansionSession session) {
            return NativeMethods.S_OK;
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionProvider.OnBeforeInsertion"]/*' />
        public virtual int OnBeforeInsertion(IVsExpansionSession session) {
            if (session == null)
                return NativeMethods.E_UNEXPECTED;

            this.expansionPrepared = false;
            this.expansionActive = true;

            // stash the expansion session pointer while the expansion is active
            if (this.expansionSession == null) {
                this.expansionSession = session;
            } else {
                // these better be the same!
                Debug.Assert(this.expansionSession == session);
            }

            // now set any field defaults that we have.
            foreach (DefaultFieldValue dv in this.fieldDefaults) {
                this.expansionSession.SetFieldDefault(dv.Field, dv.Value);
            }
            this.fieldDefaults.Clear();
            return NativeMethods.S_OK;
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionProvider.GetExpansionFunction"]/*' />
        public virtual int GetExpansionFunction(MSXML.IXMLDOMNode xmlFunctionNode, string fieldName, out IVsExpansionFunction func) {

            XmlDocument doc = new XmlDocument();
            doc.LoadXml(xmlFunctionNode.xml);
            func = GetExpansionFunction(doc.DocumentElement, fieldName);
            return NativeMethods.S_OK;
        }

        #endregion

    }


    /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionFunction"]/*' />
    [CLSCompliant(false)]
    [System.Runtime.InteropServices.ComVisible(true)]
    public abstract class ExpansionFunction : IVsExpansionFunction {
        ExpansionProvider provider;
        string fieldName;
        string[] args;
        string[] list;

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionFunction.ExpansionFunction"]/*' />
        /// <summary>You must construct this object with an ExpansionProvider</summary>
        private ExpansionFunction() {
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionFunction.ExpansionFunction2"]/*' />
        public ExpansionFunction(ExpansionProvider provider) {
            this.provider = provider;
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionFunction.ExpansionProvider"]/*' />
        public ExpansionProvider ExpansionProvider {
            get { return this.provider; }
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionFunction.Arguments"]/*' />
        public string[] Arguments {
            get { return this.args; }
            set { this.args = value; }
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionFunction.FieldName"]/*' />
        public string FieldName {
            get { return this.fieldName; }
            set { this.fieldName = value; }
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionFunction.GetCurrentValue"]/*' />
        public abstract string GetCurrentValue();

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionFunction.GetDefaultValue"]/*' />
        public virtual string GetDefaultValue() {
            // This must call GetCurrentValue sincs during initialization of the snippet
            // VS will call GetDefaultValue and not GetCurrentValue.
            return GetCurrentValue();
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionFunction.GetIntellisenseList"]/*' />
        /// <summary>Override this method if you want intellisense drop support on a list of possible values.</summary>
        public virtual string[] GetIntellisenseList() {
            return null;
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionFunction.GetArgument"]/*' />
        /// <summary>
        /// Gets the value of the specified argument, resolving any fields referenced in the argument.
        /// In the substitution, "$$" is replaced with "$" and any floating '$' signs are left unchanged,
        /// for example "$US 23.45" is returned as is.  Only if the two dollar signs enclose a string of
        /// letters or digits is this considered a field name (e.g. "$foo123$").  If the field is not found
        /// then the unresolved string "$foo" is returned.
        /// </summary>
        public string GetArgument(int index) {
            if (args == null || args.Length == 0 || index > args.Length) return null;
            string arg = args[index];
            if (arg == null) return null;
            int i = arg.IndexOf('$');
            if (i >= 0) {
                StringBuilder sb = new StringBuilder();
                int len = arg.Length;
                int start = 0;

                while (i >= 0 && i + 1 < len) {
                    sb.Append(arg.Substring(start, i - start));
                    start = i;
                    i++;
                    if (arg[i] == '$') {
                        sb.Append('$');
                        start = i + 1; // $$ is resolved to $.
                    } else {
                        // parse name of variable.
                        int j = i;
                        for (; j < len; j++) {
                            if (!Char.IsLetterOrDigit(arg[j]))
                                break;
                        }
                        if (j == len) {
                            // terminating '$' not found.
                            sb.Append('$');
                            start = i;
                            break;
                        } else if (arg[j] == '$') {
                            string name = arg.Substring(i, j - i);
                            string value;
                            if (GetFieldValue(name, out value)) {
                                sb.Append(value);
                            } else {
                                // just return the unresolved variable.
                                sb.Append('$');
                                sb.Append(name);
                                sb.Append('$');
                            }
                            start = j + 1;
                        } else {
                            // invalid syntax, e.g. "$US 23.45" or some such thing                            
                            sb.Append('$');
                            sb.Append(arg.Substring(i, j - i));
                            start = j;
                        }
                    }
                    i = arg.IndexOf('$', start);
                }
                if (start < len) {
                    sb.Append(arg.Substring(start, len - start));
                }
                arg = sb.ToString();
            }
            // remove quotes around string literals.
            if (arg.Length > 2 && arg[0] == '"' && arg[arg.Length - 1] == '"') {
                arg = arg.Substring(1, arg.Length - 2);
            } else if (arg.Length > 2 && arg[0] == '\'' && arg[arg.Length - 1] == '\'') {
                arg = arg.Substring(1, arg.Length - 2);
            }
            return arg;
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionFunction.GetFieldValue"]/*' />
        public bool GetFieldValue(string name, out string value) {
            value = null;
            if (this.provider != null && this.provider.ExpansionSession != null) {
                int hr = this.provider.ExpansionSession.GetFieldValue(name, out value);
                return NativeMethods.Succeeded(hr);
            }
            return false;
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="DefaultFieldValue.GetSelection"]/*' />
        public TextSpan GetSelection() {
            TextSpan result = new TextSpan();
            ExpansionProvider provider = this.ExpansionProvider;
            if (provider != null && provider.TextView != null) {
                NativeMethods.ThrowOnFailure(provider.TextView.GetSelection(out result.iStartLine,
                    out result.iStartIndex, out result.iEndLine, out result.iEndIndex));
            }
            return result;
        }

        #region IVsExpansionFunction Members

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionFunction.FieldChanged"]/*' />
        public virtual int FieldChanged(string bstrField, out int fRequeryValue) {
            // Returns true if we care about this field changing.
            // We care if the field changes if one of the arguments refers to it.
            if (this.args != null) {
                string var = "$" + bstrField + "$";
                foreach (string arg in this.args) {
                    if (arg == var) {
                        fRequeryValue = 1; // we care!
                        return NativeMethods.S_OK;
                    }
                }
            }
            fRequeryValue = 0;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionFunction.GetCurrentValue1"]/*' />
        public int GetCurrentValue(out string bstrValue, out int hasDefaultValue) {
            try {
                bstrValue = this.GetCurrentValue();
            } catch {
                bstrValue = String.Empty;
            }
            hasDefaultValue = (bstrValue == null) ? 0 : 1;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionFunction.GetDefaultValue1"]/*' />
        public int GetDefaultValue(out string bstrValue, out int hasCurrentValue) {
            try {
                bstrValue = this.GetDefaultValue();
            } catch {
                bstrValue = String.Empty;
            }
            hasCurrentValue = (bstrValue == null) ? 0 : 1;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionFunction.GetFunctionType"]/*' />
        public virtual int GetFunctionType(out uint pFuncType) {
            if (this.list == null) {
                this.list = this.GetIntellisenseList();
            }
            pFuncType = (this.list == null) ? (uint)_ExpansionFunctionType.eft_Value : (uint)_ExpansionFunctionType.eft_List;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionFunction.GetListCount"]/*' />
        public virtual int GetListCount(out int iListCount) {
            if (this.list == null) {
                this.list = this.GetIntellisenseList();
            }
            if (this.list != null) {
                iListCount = this.list.Length;
            } else {
                iListCount = 0;
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionFunction.GetListText"]/*' />
        public virtual int GetListText(int iIndex, out string ppszText) {
            if (this.list == null) {
                this.list = this.GetIntellisenseList();
            }
            if (this.list != null) {
                ppszText = this.list[iIndex];
            } else {
                ppszText = null;
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ExpansionFunction.ReleaseFunction"]/*' />
        public virtual int ReleaseFunction() {
            this.provider = null;
            return NativeMethods.S_OK;
        }

        #endregion
    }

    [Guid("4970C2BC-AF33-4a73-A34F-18B0584C40E4")]
    internal class SVsExpansionManager {
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\LanguageService100\EditArray.cs ===
﻿using System;
using System.Collections;
using System.Text;
using Microsoft.VisualStudio.TextManager.Interop;
using System.Diagnostics;

namespace Microsoft.VisualStudio.Package {
    /// <include file='doc\EditArray.uex' path='docs/doc[@for="EditSpan"]/*' />
    /// <summary>
    /// This class encapsulates one atomic edit operation.
    /// Add these to an EditArray then when you are ready call ApplyEdits().
    /// </summary>
    [CLSCompliant(false)]
    public class EditSpan {
        TextSpan span; // existing span to delete
        string text; // new text to insert.
        int lineCount;
        int lengthOfLastLine;

        /// <include file='doc\EditArray.uex' path='docs/doc[@for="EditSpan.EditSpan"]/*' />
        /// <summary>
        /// Construct a new edit span object
        /// </summary>
        /// <param name="toReplace">The text span to remove from the buffer (can be empty)</param>
        /// <param name="insertText">The text to insert in it's place (can be null)</param>
        public EditSpan(TextSpan toReplace, string insertText) {
            if (!TextSpanHelper.IsPositive(toReplace)) {
                TextSpanHelper.MakePositive(ref toReplace);
            }
            this.span = toReplace;
            this.text = insertText;
            this.lineCount = -1;
        }

        /// <include file='doc\EditArray.uex' path='docs/doc[@for="EditSpan.Span"]/*' />
        public TextSpan Span {
            get { return this.span; }
            set { this.span = value; }
        }
        /// <include file='doc\EditArray.uex' path='docs/doc[@for="EditSpan.Text"]/*' />
        public string Text {
            get { return this.text; }
            set { this.text = value; this.lineCount = -1; }
        }

        /// <include file='doc\EditArray.uex' path='docs/doc[@for="EditSpan.LineCount"]/*' />
        /// <summary>
        /// Returns the number of lines in the new text being inserted.
        /// </summary>
        public int LineCount {
            get {
                // number of newlines in the inserted text.
                if (this.lineCount == -1) CalcLines();
                return this.lineCount;
            }
        }

        /// <include file='doc\EditArray.uex' path='docs/doc[@for="EditSpan.LengthOfLastLine"]/*' />
        /// <summary>
        /// Returns the length of the last line of text being inserted.
        /// </summary>
        public int LengthOfLastLine { // length of the last line of text.
            get {
                // number of newlines in the inserted text.
                if (this.lineCount == -1) CalcLines();
                return this.lengthOfLastLine;
            }
        }

        void CalcLines() {
            int pos = 0;
            this.lineCount = 0;
            for (int j = 0, m = text.Length; j < m; j++) {
                char ch = text[j];
                if (ch == '\r' || ch == '\n') {
                    if (ch == '\r' && j + 1 < m && text[j + 1] == '\n') {
                        j++; // treat '\r\n' as a single line.
                    }
                    this.lineCount++;
                    pos = 0;
                } else {
                    pos++;
                }
            }
            this.lengthOfLastLine = pos;
        }

    }

    /// <include file='doc\EditArray.uex' path='docs/doc[@for="EditArray"]/*' />
    /// <summary>
    /// This class encapsulates a batch edit operation.  The reason this class exists is because
    /// performing thousands of tiny edits on a large document can be pretty slow, so the best thing
    /// to do is merge the edits into bigger chunks and that is exactly what this class will do
    /// for you.  The trick is that when merging edits you need to be careful not to include any 
    /// IVsTextLineMarkers in the merged chunks, because editing over the top of the marker
    /// will blow it away, which is not what the user wants.  The user wants to keep all their
    /// breakpoints and bookmarks, and red and blue squigglies and so on.  So this class also takes
    /// care of that.
    /// </summary>
    [CLSCompliant(false)]
    public class EditArray : IEnumerable, IDisposable {
        ArrayList editList;
        Source source;
        TextSpan selection;
        bool merge;
        IVsTextView view;
        string description;
        int changeCount;
        CompoundActionBase ca;

        /// <include file='doc\EditArray.uex' path='docs/doc[@for="EditArray.EditArray1"]/*' />
        /// <summary>
        /// This constructor takes a view and will use CompoundViewAction to make the updates
        /// and it will update the current selection accordingly.
        /// <param name="source">The buffer to operate on</param>
        /// <param name="view">The text view to use for CompoundViewAction and whose selection you want updated</param>
        /// <param name="merge">Whether to attempt to merge edits</param>
        /// <param name="description">Name used in compound action</param>
        /// </summary>
        public EditArray(Source source, IVsTextView view, bool merge, string description) {
            
            this.source = source;
            this.editList = new ArrayList();
            this.merge = merge;
            this.description = description;
            if (view != null) {
                TextSpan[] pSpan = new TextSpan[1];
                view.GetSelectionSpan(pSpan);
                this.selection = pSpan[0];
                this.view = view;
            }
            this.ca = CompoundActionFactory.GetCompoundAction(this.view, this.source, description);
            this.ca.FlushEditActions();
            // Sanity check - make sure others are not modifying the buffer while the
            // caller is preparing the big edit operation.
            this.changeCount = source.ChangeCount;
        }

        ~EditArray() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing) {
            if (ca != null) {
                ca.Close();
                ca = null;
            }
            view = null;
            source = null;
        }

        public void Dispose() {
            Dispose(true);
        }

        /// <include file='doc\EditArray.uex' path='docs/doc[@for="EditArray.Count"]/*' />
        /// <summary>
        /// Return the number of edits in the array.
        /// </summary>
        public int Count {
            get {
                return this.editList.Count;
            }
        }

        /// <include file='doc\EditArray.uex' path='docs/doc[@for="EditArray.TextView"]/*' />
        public IVsTextView TextView {
            get {
                return this.view;
            }
        }

        /// <include file='doc\EditArray.uex' path='docs/doc[@for="EditArray.Source"]/*' />
        public Source Source {
            get {
                return this.source;
            }
        }

        /// <include file='doc\EditArray.uex' path='docs/doc[@for="EditArray.ToString"]/*' />
        public override string ToString() {
            StringBuilder s=new StringBuilder();
            for (int i = this.editList.Count - 1; i >= 0; i--) {
                EditSpan e = (EditSpan)this.editList[i];
                s.AppendFormat("({0},{1}:{2},{3})  >>> '{4}'",e.Span.iStartLine, e.Span.iStartIndex, e.Span.iEndLine, e.Span.iEndIndex, GetDebugString(e.Text));
                s.AppendLine();
            }
            return s.ToString();
        }

        /// <include file='doc\EditArray.uex' path='docs/doc[@for="EditArray.Add"]/*' />
        /// <summary>
        /// Add a new atomic edit to the array.  The edits cannot intersect each other.  
        /// The spans in each edit must be based on the current state of the buffer, 
        /// and not based on post-edit spans.  This EditArray will calculate the
        /// post edit spans for you.
        /// </summary>
        /// <param name="editSpan"></param>
        public void Add(EditSpan editSpan) {
            if (editSpan == null) {
                throw new ArgumentNullException("editSpan");
            }

            for (int i = this.editList.Count - 1; i>=0; i--){
                EditSpan e = (EditSpan)this.editList[i];
                if (TextSpanHelper.Intersects(editSpan.Span, e.Span)){
                    string msg = SR.GetString(SR.EditIntersects, i);
#if LANGTRACE
                    Debug.Assert(false, msg);
                    TraceEdits();
#endif
                    throw new System.ArgumentException(msg);
                }
                if (TextSpanHelper.StartsAfterStartOf(editSpan.Span, e.Span)) {
                    this.editList.Insert(i + 1, editSpan);
                    return;
                }
            }
            this.editList.Insert(0, editSpan);
        }
#if LANGTRACE
        void TraceEdits() {
            for (int j = 0; j < this.editList.Count - 1; j++) {
                EditSpan f = (EditSpan)this.editList[j];
                TextSpan span = f.Span;
                string t = this.source.GetText(span);
                Trace.WriteLine(
                    string.Format("{0}: {1},{2},{3},{4} '{5}'=>'{6}'",
                        j, span.iStartLine, span.iStartIndex, span.iEndLine, span.iEndIndex,
                        GetDebugString(t), GetDebugString(f.Text)));
            }
        }
#endif
        string GetDebugString(string s) {
            if (string.IsNullOrEmpty(s)) return "";
            s = s.Replace("\n", "\\n");
            s = s.Replace("\r", "\\r");
            s = s.Replace("\t", "\\t");
            s = s.Replace(" ", "#");
            return s;
        }

        ArrayList GetTextMarkers() {
            ArrayList markers = new ArrayList();
            TextSpan docSpan = this.source.GetDocumentSpan();
            IVsTextLines buffer = this.source.GetTextLines();
            IVsEnumLineMarkers ppEnum;
            int iMarkerType = 0;
            uint dwFlags = (uint)ENUMMARKERFLAGS.EM_ALLTYPES;
            int hr = buffer.EnumMarkers(docSpan.iStartLine, docSpan.iStartIndex, docSpan.iEndLine, docSpan.iEndIndex, iMarkerType, dwFlags, out ppEnum);
            if (hr == NativeMethods.S_OK) {
                IVsTextLineMarker marker;
                TextSpan[] pSpan = new TextSpan[1];
                while (ppEnum.Next(out marker) == NativeMethods.S_OK) {
                    if (marker != null) {
                        if (marker.GetCurrentSpan(pSpan) == NativeMethods.S_OK) {
                            markers.Add(pSpan[0]);
                        }
                    }
                }
            }
            return markers;
        }

        const int ChunkThreshold = 1000; // don't combine chunks separate by more than 1000 characters.

        ArrayList MergeEdits(ArrayList edits) {

            StringBuilder buffer = new StringBuilder();
            EditSpan combined = null;
            ArrayList merged = new ArrayList();
            ArrayList markers = GetTextMarkers();
            int markerPos = 0;
            TextSpan marker = (markers.Count > 0) ? (TextSpan)markers[0] : new TextSpan();

            foreach (EditSpan editSpan in edits) {

                TextSpan span = editSpan.Span;
                string text = editSpan.Text;

                if (markerPos < markers.Count &&
                    (TextSpanHelper.StartsAfterStartOf(span, marker) || TextSpanHelper.EndsAfterStartOf(span, marker))) {
                    AddCombinedEdit(combined, buffer, merged);
                    if (TextSpanHelper.Intersects(span, marker)) {
                        combined = null;
                        // Have to apply this as a distinct edit operation.
                        merged.Add(editSpan);
                    } else {
                        combined = editSpan;
                        buffer.Append(text);
                    }
                    while (++markerPos < markers.Count) {
                        marker = (TextSpan)markers[markerPos];
                        if (!TextSpanHelper.StartsAfterStartOf(span, marker) && !TextSpanHelper.EndsAfterStartOf(span, marker)) {
                            break;
                        }
                    }
                } else if (combined == null) {
                    combined = editSpan;
                    buffer.Append(text);
                } else {
                    // A little sanity check here, if there are too many characters in between the two 
                    // edits, then keep them separate.
                    TextSpan s = combined.Span;
                    string between = this.source.GetText(s.iEndLine, s.iEndIndex, span.iStartLine, span.iStartIndex);
                    if (between.Length > ChunkThreshold) {
                        AddCombinedEdit(combined, buffer, merged);
                        combined = editSpan;
                        buffer.Append(text);
                    } else {
                        // merge edit spans by adding the text in-between the current and previous spans.
                        buffer.Append(between);
                        buffer.Append(text); // and add the new text.
                        s.iEndIndex = span.iEndIndex;
                        s.iEndLine = span.iEndLine;
                        combined.Span = s;
                    }
                }
            }
            AddCombinedEdit(combined, buffer, merged);
            return merged;
        }

        void AddCombinedEdit(EditSpan combined, StringBuilder buffer, ArrayList merged) {
            if (combined != null) {
                // add combined edit span.
                combined.Text = buffer.ToString();
                merged.Add(combined);
                buffer.Length = 0;
            }
        }

        void UpdateSelection(ArrayList edits) {
            int lineDelta = 0;
            int indexDelta = 0;
            int currentLine = 0;
            bool updateStart = true;
            bool updateEnd = true;
            bool selectionIsEmpty = TextSpanHelper.IsEmpty(this.selection);

            foreach (EditSpan es in edits) {
                TextSpan span = es.Span;
                string text = es.Text;
                int lastLine = currentLine;
                int lastDelta = indexDelta;

                if (currentLine != span.iStartLine) {
                    // We have moved to a new line, so the indexDelta is no longer relevant.
                    currentLine = span.iStartLine;
                    indexDelta = 0;
                }

                // Now adjust the span based on the current deltas.
                span.iStartIndex += indexDelta;
                if (currentLine == span.iEndLine) {
                    span.iEndIndex += indexDelta;
                }
                span.iStartLine += lineDelta;
                span.iEndLine += lineDelta;

                if (updateStart) {
                    TextSpan original = es.Span;
                    if (TextSpanHelper.ContainsInclusive(original, this.selection.iStartLine, this.selection.iStartIndex)) {
                        bool atEnd = (this.selection.iStartLine == original.iEndLine &&
                                this.selection.iStartIndex == original.iEndIndex);
                        this.selection.iStartLine = span.iStartLine;
                        this.selection.iStartIndex = span.iStartIndex;
                        if (atEnd){
                            // Selection was positioned at the end of the span, so
                            // skip past the inserted text to approximate that location.
                            if (es.LineCount > 0) {
                                this.selection.iStartLine += es.LineCount;
                                this.selection.iStartIndex = es.LengthOfLastLine;
                            } else {
                                this.selection.iStartIndex += es.LengthOfLastLine;
                            }
                        }
                        updateStart = false; // done
                    } else if (TextSpanHelper.StartsAfterStartOf(original, this.selection)) {
                        if (this.selection.iStartLine == lastLine) {
                            this.selection.iStartIndex += lastDelta;
                        }
                        this.selection.iStartLine += lineDelta;
                        updateStart = false; // done.
                    }
                    if (!updateStart && selectionIsEmpty) {
                        this.selection.iEndLine = this.selection.iStartLine;
                        this.selection.iEndIndex = this.selection.iStartIndex;
                        updateEnd = false; // done
                    }
                }
                if (updateEnd) {
                    TextSpan original = es.Span;
                    if (TextSpanHelper.StartsAfterEndOf(original, this.selection)) {
                        if (this.selection.iEndLine == lastLine) {
                            this.selection.iEndIndex += lastDelta;
                        }
                        this.selection.iEndLine += lineDelta;
                        updateEnd = false; // done.
                    } else if (TextSpanHelper.ContainsInclusive(original, this.selection.iEndLine, this.selection.iEndIndex)) {
                        this.selection.iEndLine = span.iStartLine;
                        this.selection.iEndIndex = span.iStartIndex;
                        // Now include the text we are inserting in the selection
                        if (es.LineCount > 0) {
                            this.selection.iEndLine += es.LineCount;
                            this.selection.iEndIndex = es.LengthOfLastLine;
                        } else {
                            this.selection.iEndIndex += es.LengthOfLastLine;
                        }
                        updateEnd = false; // done.
                    }
                }

                // Now adjust the deltas based on whether we just deleted anything.
                if (span.iStartLine != span.iEndLine) {
                    // We are deleting one or more lines.
                    lineDelta += (span.iStartLine - span.iEndLine);
                    indexDelta = -span.iEndIndex;
                    currentLine = span.iStartLine;
                } else if (span.iStartIndex != span.iEndIndex) {
                    indexDelta += (span.iStartIndex - span.iEndIndex);
                }

                // Now adjust the deltas based on what we just inserted
                if (!string.IsNullOrEmpty(text)) {
                    lineDelta += es.LineCount;
                    if (span.iStartLine != span.iEndLine) { // we removed multiple lines
                        if (es.LineCount == 0) { // but we are not inserting any new lines
                            // Then we are appending to this line.
                            indexDelta = span.iStartIndex + es.LengthOfLastLine;
                        } else {
                            indexDelta = es.LengthOfLastLine; // otherwise we just started a new line.
                        }
                    } else if (es.LineCount != 0) { // we inserted new lines
                        // then calculate delta between new position versus position on original line.
                        indexDelta += es.LengthOfLastLine - span.iStartIndex;
                    } else {
                        indexDelta += es.LengthOfLastLine; // then delta is simply what we just inserted
                    }
                }
            }

            if (updateStart) {
                // Then start of selection is off the end of the list of edits.
                if (this.selection.iStartLine == currentLine) {
                    this.selection.iStartIndex += indexDelta;
                }
                this.selection.iStartLine += lineDelta;
            }
            if (updateEnd) {
                // Then end of selection is off the end of the list of edits.
                if (this.selection.iEndLine == currentLine) {
                    this.selection.iEndIndex += indexDelta;
                }
                this.selection.iEndLine += lineDelta;
            }
        }

        /// <include file='doc\EditArray.uex' path='docs/doc[@for="EditArray.ApplyEdits"]/*' />
        public void ApplyEdits() {
            try {
                if (this.editList.Count == 0) return;

                if (this.changeCount != this.source.ChangeCount) {
                    throw new InvalidOperationException(SR.GetString(SR.BufferChanged));
                }

                using (this.ca) {
                    Apply();
                    ca.FlushEditActions();
                }
                this.ca = null;
                if (this.view != null) {
                    // Update selection.
                    this.view.SetSelection(this.selection.iStartLine, this.selection.iStartIndex, this.selection.iEndLine, this.selection.iEndIndex);
                    this.view.EnsureSpanVisible(this.selection);
                } 
            } finally {
                // If compound actions are not null then we need to abort them.
                Dispose();
            }
        }

        void Apply() {
            // use original edit spans to update the selection location so that we get the finest
            // granied selection update possible.  It should not be done on merged edits.
            ArrayList edits = this.editList;

            if (this.view != null) {
                // Now calculate the updated selection position based on what the edits are going to
                // do to the buffer.
                this.UpdateSelection(edits);
            }
            if (merge) {
                // Merge the edits into larger chunks for performance reasons.
                edits = this.MergeEdits(edits);
            }

            // Now apply the edits in reverse order because that one each edit will not interfere with the
            // span of the next edit.
            for (int i = edits.Count - 1; i >= 0; i--) {
                EditSpan es = (EditSpan)edits[i];
                TextSpan span = es.Span;
                string text = es.Text;
                this.source.SetText(span, text);
            }
            this.editList.Clear(); // done!
        }

        /// <include file='doc\EditArray.uex' path='docs/doc[@for="EditArray.GetEnumerator"]/*' />
        /// <summary>Allows enumeration of EditSpan objects</summary>
        public IEnumerator GetEnumerator() {
            return editList.GetEnumerator();
        }
        
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\LanguageService100\LanguageService.cs ===
using Microsoft.VisualStudio.Package;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.TextManager.Interop;
using Microsoft.VisualStudio.Shell;
using Microsoft.Win32;
using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Windows.Forms;
using System.Xml;
using System.Security.Permissions;
using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
using IServiceProvider = System.IServiceProvider;
using ShellConstants = Microsoft.VisualStudio.Shell.Interop.Constants;
using OleConstants = Microsoft.VisualStudio.OLE.Interop.Constants;
using VsShell = Microsoft.VisualStudio.Shell.VsShellUtilities;


namespace Microsoft.VisualStudio.Package {
    /// <include file='doc\LanguageService.uex' path='docs/doc[@for="ParseReason"]/*' />
    public enum ParseReason {
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="ParseReason.None"]/*' />
        None,
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="ParseReason.MemberSelect"]/*' />
        MemberSelect,
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="ParseReason.HighlightBraces"]/*' />
        HighlightBraces,
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="ParseReason.MemberSelectAndHighlightBraces"]/*' />
        MemberSelectAndHighlightBraces,
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="ParseReason.MatchBraces"]/*' />
        MatchBraces,
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="ParseReason.Check"]/*' />
        Check,
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="ParseReason.CompleteWord"]/*' />
        CompleteWord,
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="ParseReason.DisplayMemberList"]/*' />
        DisplayMemberList,
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="ParseReason.QuickInfo"]/*' />
        QuickInfo,
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="ParseReason.MethodTip"]/*' />
        MethodTip,
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="ParseReason.Autos"]/*' />
        Autos,
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="ParseReason.CodeSpan"]/*' />
        CodeSpan,
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="ParseReason.Goto"]/*' />
        Goto
    };

    /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService"]/*' />
    [CLSCompliant(false), ComVisible(true)]
    public abstract class LanguageService : IDisposable, IVsLanguageInfo, IVsLanguageDebugInfo,
        IVsProvideColorableItems, IVsLanguageContextProvider, IOleServiceProvider,
        IObjectWithSite, ISynchronizeInvoke, IVsDebuggerEvents,
        IVsFormatFilterProvider, IVsAutoOutliningClient { //, IVsOutliningCapableLanguage {

        private IServiceProvider site;
        private ArrayList codeWindowManagers;
        private LanguagePreferences preferences;
        private ArrayList sources;
        private ArrayList colorizers;
        private bool disposed;
        private IVsDebugger debugger;
        private uint cookie;
        private DBGMODE dbgMode;
        private int lcid;
        private bool isParsing;
        private Thread mainThread;
        private MainThreadTask task;
        private MainThreadTask tail;
        private TaskControl control;

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.LanguageService"]/*' />
        protected LanguageService() {
            this.codeWindowManagers = new ArrayList();
            this.sources = new ArrayList();
            this.colorizers = new ArrayList();
            this.mainThread = Thread.CurrentThread;
            this.parseRequestDone = new ParseWaitHandle(this);
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.Initialize"]/*' />
        public virtual void Initialize() {
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.Site;"]/*' />
        public IServiceProvider Site {
            get { return this.site; }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.MainThreadId"]/*' />
        public int MainThreadId {
            get {
                return this.mainThread.ManagedThreadId;
            }
        }

        protected bool ParseThreadIsAlive{
            get {
                return this.parseThread != null && this.parseThread.IsAlive;
            }
        }
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.Preferences"]/*' />
        public LanguagePreferences Preferences {
            get {
                if (this.preferences == null && !disposed) {
                    this.preferences = this.GetLanguagePreferences();
                }
                return this.preferences;
            }
            set {
                this.preferences = value;
            }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.Done"]/*' />
        /// <summary>
        /// Cleanup the sources, uiShell, shell, preferences and imageList objects
        /// and unregister this language service with VS.
        /// </summary>
        public virtual void Dispose() {
            OnActiveViewChanged(null);
            this.disposed = true;
            this.StopThread();
            this.lastActiveView = null;
            if (this.control != null) {
                this.control.Dispose();
                this.control = null;
            }
            if (this.sources != null) {
                lock (this.sources) {
                    foreach (Source s in this.sources) {
                        s.Dispose();
                    }
                    this.sources.Clear();
                }
                this.sources = null;
            }
            if (this.colorizers != null) {
                foreach (Colorizer c in this.colorizers) {
                    c.Dispose();
                }
                this.colorizers.Clear();
                this.colorizers = null;
            }

            if (this.codeWindowManagers != null) {
                foreach (CodeWindowManager m in this.codeWindowManagers) {
                    m.Close();
                }
                this.codeWindowManagers.Clear();
                this.codeWindowManagers = null;
            }

            if (this.preferences != null) {
                this.preferences.Dispose();
                this.preferences = null;
            }
            if (this.debugger != null && this.cookie != 0) {
                NativeMethods.ThrowOnFailure(this.debugger.UnadviseDebuggerEvents(this.cookie));
                this.cookie = 0;
                this.debugger = null;
            }
            if (this.task != null)
                this.task.Dispose();
            this.task = null;
            this.site = null;
        }

        // Methods implemented by subclass.
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.GetLanguagePreferences"]/*' />
        /// It is expected that you will have one static language preferences object
        /// for your package.
        public abstract LanguagePreferences GetLanguagePreferences();

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.GetScanner"]/*' />
        public abstract IScanner GetScanner(IVsTextLines buffer);

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.ParseSource"]/*' />
        public abstract AuthoringScope ParseSource(ParseRequest req);

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.Name"]/*' />
        /// <summary>Return the name of the language, such as "HTML" or "C++", and so on.</summary>
        public abstract string Name { get; }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.GetLanguageServiceGuid"]/*' />
        public Guid GetLanguageServiceGuid() {
            return this.GetType().GUID;
        }

        #region IVsProvideColorableItems
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.GetItemCount"]/*' />
        public virtual int GetItemCount(out int count) {
            count = 0;
            return NativeMethods.E_NOTIMPL;
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.GetColorableItem"]/*' />
        public virtual int GetColorableItem(int index, out IVsColorableItem item) {
            item = null;
            return NativeMethods.E_NOTIMPL;
        }
        #endregion

        #region IVsLanguageContextProvider
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.IVsLanguageContextProvider.UpdateLanguageContext"]/*' />
        /// <internalonly/>
        int IVsLanguageContextProvider.UpdateLanguageContext(uint dwHint, IVsTextLines buffer, TextSpan[] ptsSelection, object ptr) {
            if (ptr != null && ptr is IVsUserContext) {
                UpdateLanguageContext((LanguageContextHint)dwHint, buffer, ptsSelection, (IVsUserContext)ptr);
            }
            return NativeMethods.S_OK;
        }

        /// <summary>
        /// Call this method if you want UpdateLanguageContext to be called again.
        /// </summary>
        public void SetUserContextDirty(string fileName) {
            if (string.IsNullOrEmpty(fileName)) return;
            IVsWindowFrame windowFrame = null;
            uint itemID = VSConstants.VSITEMID_NIL;
            IVsUIHierarchy hierarchy = null;
            if (VsShell.IsDocumentOpen(this.Site, fileName, Guid.Empty, out hierarchy, out itemID, out windowFrame)) {
                IVsUserContext context;
                if (windowFrame != null) {
                    object prop;
                    int hr = windowFrame.GetProperty((int)__VSFPROPID.VSFPROPID_UserContext, out prop);
                    context = (IVsUserContext)prop;
                    if (NativeMethods.Succeeded(hr) && context != null) {
                        context.SetDirty(1);
                    }
                }
            }
        }

        #endregion

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.UpdateLanguageContext"]/*' />
        public virtual void UpdateLanguageContext(LanguageContextHint hint, IVsTextLines buffer, TextSpan[] ptsSelection, IVsUserContext context) {
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.GetImageList"]/*' />
        public virtual ImageList GetImageList() {
            ImageList ilist = new ImageList();
            ilist.ImageSize = new Size(16, 16);
            ilist.TransparentColor = Color.FromArgb(255, 0, 255);
            Stream stream = typeof(LanguageService).Assembly.GetManifestResourceStream("Resources.completionset.bmp");
            ilist.Images.AddStrip(new Bitmap(stream));
            return ilist;
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.IsMacroRecordingOn"]/*' />
        public bool IsMacroRecordingOn() {
            IVsShell shell = this.GetService(typeof(SVsShell)) as IVsShell;
            if (shell != null) {
                object pvar;
                NativeMethods.ThrowOnFailure(shell.GetProperty((int)__VSSPROPID.VSSPROPID_RecordState, out pvar));
                shell = null;
                if (pvar != null) {
                    return ((VSRECORDSTATE)pvar == VSRECORDSTATE.VSRECORDSTATE_ON);
                }
            }
            return false;
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.GetIVsDebugger"]/*' />
        public IVsDebugger GetIVsDebugger() {
            if (this.debugger == null) {
                Guid guid = typeof(Microsoft.VisualStudio.Shell.Interop.IVsDebugger).GUID;
                this.debugger = this.GetService(typeof(IVsDebugger)) as IVsDebugger;
                if (this.debugger != null) {
                    NativeMethods.ThrowOnFailure(debugger.AdviseDebuggerEvents(this, out this.cookie));

                    // Get the initial state of the debugger
                    DBGMODE[] mode = new DBGMODE[1];
                    NativeMethods.ThrowOnFailure(debugger.GetMode(mode));
                    this.dbgMode = mode[0];
                }
            }
            return debugger;
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.GetIVsTextMacroHelperIfRecordingOn"]/*' />
        public IVsTextMacroHelper GetIVsTextMacroHelperIfRecordingOn() {
            if (IsMacroRecordingOn()) {
                IVsTextManager textmgr = (IVsTextManager)this.GetService(typeof(SVsTextManager));
                return (IVsTextMacroHelper)textmgr;
            }
            return null;
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.OpenDocument"]/*' />
        public void OpenDocument(string path) {
            VsShell.OpenDocument(this.site, path);
        }

        internal int lastLine = -1;
        internal int lastCol = -1;
        internal string lastFileName;
        internal IVsTextView lastActiveView;

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.LastActiveTextView"]/*' />
        /// <devdoc>
        /// Returns the last active IVsTextView that is managed by this language service.
        /// </devdoc>
        public IVsTextView LastActiveTextView {
            get { return this.lastActiveView; }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.IsActive"]/*' />
        /// <devdoc>
        /// Return whether or not the last active text view is one of ours or not.
        /// </devdoc>
        public bool IsActive {
            get {
                if (disposed) return false;
                if (this.lastActiveView == null) return false;
                return this.GetSource(this.lastActiveView) != null;
            }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.OnIdle"]/*' />
        public virtual void OnIdle(bool periodic) {
            RunTasks();
            if (!this.IsActive)
                return;

            // here's our chance to synchronize combo's and so on, 
            // first we see if the caret has moved.                
            IVsTextView view = this.lastActiveView;
            if (view == null) return;
            Source s = this.GetSource(view);
            if (s == null) return;

            int line = -1, col = -1;
            NativeMethods.ThrowOnFailure(view.GetCaretPos(out line, out col));
            
            if (line != this.lastLine || col != this.lastCol || this.lastFileName == null) {
                this.lastLine = line;
                this.lastCol = col;
                this.lastFileName = s.GetFilePath(); 
                CodeWindowManager cwm = this.GetCodeWindowManagerForView(view);
                if (cwm != null) {
                    this.OnCaretMoved(cwm, view, line, col);
                }
            }
            s.OnIdle(periodic);
            RunTasks();
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.GetDropDownHelper"]/*' />
        /// <devdoc>
        /// Return your implementation of TypeAndMemberDropdownBars if you want 
        /// drop down combos to appear at the top of your code window.
        /// </devdoc>
        public virtual TypeAndMemberDropdownBars CreateDropDownHelper(IVsTextView forView) {
            return null;
        }
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.OnActiveViewChanged"]/*' />
        public virtual void OnActiveViewChanged(IVsTextView textView) {
            if (this.lastActiveView != textView) {
                this.lastActiveView = textView;
                this.lastFileName = null;
            }
        }
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.OnCaretMoved"]/*' />
        public virtual void OnCaretMoved(CodeWindowManager mgr, IVsTextView textView, int line, int col) {
            if (mgr.DropDownHelper != null)
                mgr.DropDownHelper.SynchronizeDropdowns(textView, line, col);
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.SynchronizeDropdowns"]/*' />
        public virtual void SynchronizeDropdowns() {
            IVsTextView textView = this.LastActiveTextView;
            if (textView != null) {
                CodeWindowManager mgr = this.GetCodeWindowManagerForView(textView);
                if (mgr != null && mgr.DropDownHelper != null) {
                    try {
                        int line = -1, col = -1;
                        if (NativeMethods.Failed(textView.GetCaretPos(out line, out col)))
                            return;
                        mgr.DropDownHelper.SynchronizeDropdowns(textView, line, col);
                    } catch { }
                }
            }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.OnChangesCommitted"]/*' />
        protected virtual void OnChangesCommitted(uint flags, Microsoft.VisualStudio.TextManager.Interop.TextSpan[] ptsChanged) {
        }

        // Override this method to plug in your own custom colorizer.
        // You shouldn't need to do this since the colorizer simply
        // uses your Scanner to get the color information.
        // This method returns the same colorizer for each unique buffer,
        // which you must do also.
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.GetColorizer"]/*' />
        public virtual Colorizer GetColorizer(IVsTextLines buffer) {
            foreach (Colorizer c in this.colorizers) {
                if (c.buffer == buffer) {
                    return c; 
                }
            }
            Colorizer result = new Colorizer(this, buffer, this.GetScanner(buffer));
            this.colorizers.Add(result);
            return result;
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.CreateSource"]/*' />
        public virtual Source CreateSource(IVsTextLines buffer) {
            return new Source(this, buffer, this.GetColorizer(buffer));
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.GetSources"]/*' />
        /// <summary>For enumerating all the known 'Source' objects.</summary>
        public IEnumerable GetSources() {
            return this.sources;
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.GetSource"]/*' />
        // We have to make sure we return the same colorizer for each text buffer,
        // so we keep a hashtable of IVsTextLines -> Source objects, the Source
        // object owns the Colorizer for that buffer.  If this method returns null
        // then it means the text buffer does not belong to this language service.
        public Source GetSource(IVsTextLines buffer) {
            if (buffer == null) return null;
            lock (this.sources) {
                foreach (Source src in this.sources) {
                    if (NativeMethods.IsSameComObject(src.GetTextLines(), buffer)) {
                        return src;
                    }
                }
            }
            return null;
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.GetSource2"]/*' />
        public Source GetSource(IVsTextView view) {
            if (view == null) return null;
            IVsTextLines buffer;
            NativeMethods.ThrowOnFailure(view.GetBuffer(out buffer));
            return GetSource(buffer);
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.GetSource1"]/*' />
        public Source GetSource(string fname) {
            if (this.sources != null) {
                lock (this.sources) {
                    foreach (Source s in this.sources) {
                        if (NativeMethods.IsSamePath(s.GetFilePath(), fname))
                            return s;
                    }
                }
            }
            return null;
        }

        internal virtual void OnCloseColorizer(Colorizer c) {
            if (this.colorizers != null) {
                if (this.colorizers.Contains(c)) {
                    this.colorizers.Remove(c);
                }
            }
        }

        // Aborting the thread is rather drastic, and breaks the XML editor 
        // because it is building a shared parse tree exposed by XmlModel API.
        // In cases like this the parse tree may still be used even after source
        // is closed, so aborting the thread messes with this concept. So this
        // new virtual method allows a language service to override this behavior.
        public virtual bool CanStopThread(Source src) {
            return true;
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.OnCloseSource"]/*' />
        public virtual void OnCloseSource(Source source) {
            if (!this.isParsing || CanStopThread(source)) {
                ClearTask();
                StopThread();
            }
            if (this.sources != null) {
                lock (this.sources) {
                    if (this.sources.Contains(source)) {
                        this.sources.Remove(source);
                    }
                }
            }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.IsSourceOpen"]/*' />
        public virtual bool IsSourceOpen(Source src) {
            if (this.sources != null) {
                lock (this.sources) {
                    return this.sources.Contains(src);
                }
            }
            return false;
        }


        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.IsDebugging"]/*' />
        public bool IsDebugging {
            get {
                if (this.debugger == null) {
                    this.debugger = GetIVsDebugger();
                }
                return this.dbgMode != DBGMODE.DBGMODE_Design;
            }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.CreateDocumentProperties"]/*' />
        // Override this method to create your own custom document properties for
        // display in the Properties Window when the editor for this Source is active.
        // Default is null which means there will be no document properties.
        public virtual DocumentProperties CreateDocumentProperties(CodeWindowManager mgr) {
            return null;
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.CreateExpansionFunction"]/*' />
        /// If the functionName is supported, return a new IVsExpansionFunction object.
        public virtual ExpansionFunction CreateExpansionFunction(ExpansionProvider provider, string functionName) {
            return null;
        }
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.CreateExpansionProvider"]/*' />
        public virtual ExpansionProvider CreateExpansionProvider(Source src) {
            return new ExpansionProvider(src);
        }

        #region IVsLanguageInfo methods
        // GetCodeWindowManager -- this gives us the VsCodeWindow which is what we need to
        // add adornments and so forth.
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.GetCodeWindowManager"]/*' />
        public int GetCodeWindowManager(IVsCodeWindow codeWindow, out IVsCodeWindowManager mgr) {
            //set the inheritKeyBinding guid so that navigation keys work. Do this before deriving class's  
            //CreateCodeWindowManager method gets called, so they may override if required
            IOleServiceProvider sp = codeWindow as IOleServiceProvider;
            if (sp != null) {
                ServiceProvider site = new ServiceProvider(sp);
                object window = site.GetService(typeof(IVsWindowFrame).GUID);
                if (window is IVsWindowFrame) {
                    IVsWindowFrame frame = (IVsWindowFrame)window;
                    Guid CMDUIGUID_TextEditor = new Guid(0x8B382828, 0x6202, 0x11d1, 0x88, 0x70, 0x00, 0x00, 0xF8, 0x75, 0x79, 0xD2);
                    NativeMethods.ThrowOnFailure(frame.SetGuidProperty((int)__VSFPROPID.VSFPROPID_InheritKeyBindings, ref CMDUIGUID_TextEditor));
                }
            }

            Initialize();
            IVsTextLines buffer = null;
            NativeMethods.ThrowOnFailure(codeWindow.GetBuffer(out buffer));
            mgr = CreateCodeWindowManager(codeWindow, GetOrCreateSource(buffer));
            return NativeMethods.S_OK;
        }

        public Source GetOrCreateSource(IVsTextLines buffer) {
            // see if we already have a Source object.
            lock (this.sources) {
                Source s = GetSource(buffer);
                if (s == null) {
                    // Ok, then create one.
                    s = CreateSource(buffer);
                    this.sources.Add(s);
                }
                return s;
            }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.CreateCodeWindowManager"]/*' />
        public virtual CodeWindowManager CreateCodeWindowManager(IVsCodeWindow codeWindow, Source source) {
            return new CodeWindowManager(this, codeWindow, source);
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.GetColorizer1"]/*' />
        public int GetColorizer(IVsTextLines buffer, out IVsColorizer result) {
            // Do NOT create source object yet - this might be an invisible editor in which
            // case Source object will create shutdown problems 
            result = this.GetColorizer(buffer);
            return NativeMethods.S_OK;
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.GetLanguageName"]/*' />        
        public virtual int GetLanguageName(out string name) {
            name = this.Name;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.GetFileExtensions"]/*' />
        public virtual int GetFileExtensions(out string extensions) {
            extensions = "";
            return NativeMethods.S_OK;
        }

        #endregion

        #region IVsLanguageDebugInfo methods
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.GetLanguageID"]/*' />
        public virtual int GetLanguageID(IVsTextBuffer buffer, int line, int col, out Guid langId) {
            langId = GetLanguageServiceGuid();
            return NativeMethods.S_OK;
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.GetLocationOfName"]/*' />
        public virtual int GetLocationOfName(string name, out string pbstrMkDoc, TextSpan[] spans) {
            pbstrMkDoc = null;
            return NativeMethods.E_NOTIMPL;
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.GetNameOfLocation"]/*' />
        public virtual int GetNameOfLocation(IVsTextBuffer buffer, int line, int col, out string name, out int lineOffset) {
            name = null;
            lineOffset = 0;
            /*
        
       
      
     

    
  
       
      
  
     
    
   
        

        
        
      */
            return NativeMethods.S_OK;
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.GetProximityExpressions"]/*' />
        public virtual int GetProximityExpressions(IVsTextBuffer buffer, int line, int col, int cLines, out IVsEnumBSTR ppEnum) {
            ppEnum = null;
            /*
       
      
     

   
    

  
 


        
        

       
      
     
        
        

       
        
       
  
        
      */
            return NativeMethods.S_FALSE;
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.IsMappedLocation"]/*' />
        public virtual int IsMappedLocation(IVsTextBuffer buffer, int line, int col) {
            return NativeMethods.S_FALSE;
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.ResolveName"]/*' />
        public virtual int ResolveName(string name, uint flags, out IVsEnumDebugName ppNames) {
            ppNames = null;
            return NativeMethods.E_NOTIMPL;
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.ValidateBreakpointLocation"]/*' />
        public virtual int ValidateBreakpointLocation(IVsTextBuffer buffer, int line, int col, TextSpan[] pCodeSpan) {
            return NativeMethods.E_NOTIMPL;
        }
        #endregion

        /// <include file='doc\Package.uex' path='docs/doc[@for="LanguageService.GetService"]' />
        public object GetService(Type serviceType) {
            if (this.site != null) {
                return this.site.GetService(serviceType);
            }
            return null;
        }

        #region Microsoft.VisualStudio.OLE.Interop.IServiceProvider methods
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.QueryService"]/*' />
        public virtual int QueryService(ref Guid guidService, ref Guid iid, out IntPtr obj) {
            obj = IntPtr.Zero;
            if (this.site != null) {
                IOleServiceProvider psp = this.GetService(typeof(IOleServiceProvider)) as IOleServiceProvider;
                if (psp != null)
                    NativeMethods.ThrowOnFailure(psp.QueryService(ref guidService, ref iid, out obj));
                return 0;
            }
            return (int)NativeMethods.E_UNEXPECTED;
        }
        #endregion

        // Override this method if you want to insert your own view filter
        // into the command chain.  
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.CreateViewFilter"]/*' />
        public virtual ViewFilter CreateViewFilter(CodeWindowManager mgr, IVsTextView newView) {
            return new ViewFilter(mgr, newView);
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.AddCodeWindowManager"]/*' />
        public void AddCodeWindowManager(CodeWindowManager m) {
            this.codeWindowManagers.Add(m);
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.RemoveCodeWindowManager"]/*' />
        public void RemoveCodeWindowManager(CodeWindowManager m) {
            this.codeWindowManagers.Remove(m);
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.GetCodeWindowManagerForView"]/*' />
        public CodeWindowManager GetCodeWindowManagerForView(IVsTextView view) {
            if (view == null) return null;
            foreach (CodeWindowManager m in this.codeWindowManagers) {
                if (m.CodeWindow != null) {
                    IVsTextView pView;
                    int hr = m.CodeWindow.GetLastActiveView(out pView);
                    if (hr == NativeMethods.S_OK && pView == view)
                        return m;
                }
            }
            return null;
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.GetCodeWindowManagerForSource"]/*' />
        public CodeWindowManager GetCodeWindowManagerForSource(Source src) {
            if (src == null) return null;
            foreach (CodeWindowManager m in this.codeWindowManagers) {
                if (m.Source == src) {
                    return m;
                }
            }
            return null;
        }

        public IVsTextView GetPrimaryViewForSource(Source src) {
            IVsTextView view = null;
            CodeWindowManager mgr = this.GetCodeWindowManagerForSource(src);
            if (mgr != null) {
                IVsCodeWindow w = mgr.CodeWindow;
                if (w != null) {
                    w.GetPrimaryView(out view);
                }
            }
            return view;
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.DispatchCommand"]/*' />
        public int DispatchCommand(Guid cmdGuid, uint cmdId, IntPtr pvaIn, IntPtr pvaOut) {
            return DispatchCommand(cmdGuid, cmdId, (uint)OLECMDEXECOPT.OLECMDEXECOPT_DODEFAULT, pvaIn, pvaOut);
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.DispatchCommand2"]/*' />
        /// <summary>Executes the given command if it is enabled and supported using the
        /// current SUIHostCommandDispatcher.</summary>
        public int DispatchCommand(Guid cmdGuid, uint cmdId, uint cmdExecOpt, IntPtr pvaIn, IntPtr pvaOut) {
            int hr = NativeMethods.E_FAIL;
            IOleCommandTarget cmdTarget = this.Site.GetService(typeof(SUIHostCommandDispatcher)) as IOleCommandTarget;
            if (cmdTarget != null) {
                OLECMD[] prgCmds = new OLECMD[1];
                prgCmds[0].cmdID = cmdId;
                hr = cmdTarget.QueryStatus(ref cmdGuid, 1, prgCmds, IntPtr.Zero);
                if (ErrorHandler.Succeeded(hr)) {
                    if ((prgCmds[0].cmdf & (uint)OLECMDF.OLECMDF_ENABLED) != 0) {
                        hr = cmdTarget.Exec(ref cmdGuid, cmdId, cmdExecOpt, pvaIn, pvaOut);
                    } else {
                        hr = NativeMethods.S_FALSE;
                    }
                }
            }
            return hr;
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.ScrollToEnd"]/*' />
        public void ScrollToEnd(IVsWindowFrame frame) {
            IVsTextView view = VsShell.GetTextView(frame);
            if (view != null) {
                ScrollToEnd(view);
            }
        }
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.ScrollToEnd2"]/*' />
        public void ScrollToEnd(IVsTextView view) {
            IVsTextLines buffer;
            NativeMethods.ThrowOnFailure(view.GetBuffer(out buffer));
            int lines;
            NativeMethods.ThrowOnFailure(buffer.GetLineCount(out lines));
            int lineHeight;
            NativeMethods.ThrowOnFailure(view.GetLineHeight(out lineHeight));
            Microsoft.VisualStudio.NativeMethods.RECT bounds = new Microsoft.VisualStudio.NativeMethods.RECT();
            NativeMethods.GetClientRect(view.GetWindowHandle(), ref bounds);
            int visibleLines = ((bounds.bottom - bounds.top) / lineHeight) - 1;
            // If the view hasn't been shown yet, the bounds will be empty, yielding -1 for visibleLinse.
            if (visibleLines < 0) {
                visibleLines = 0;
            }

            // The line number needed to be passed to SetTopLine is ZERO based, so need to subtract ONE from number of total lines
            int top = Math.Max(0, lines - visibleLines - 1);
            Debug.Assert(lines > top, "Cannot set top line to be greater than total number of lines");
            NativeMethods.ThrowOnFailure(view.SetTopLine(top));
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.BeginParse"]/*' />
        public IAsyncResult BeginParse(ParseRequest request, ParseResultHandler handler) {
            lock (this) { // protect this.parseRequest pointer & this.isParsing boolean.
                StartThread();
                request.Callback = handler;
                this.parseRequest = request;
                this.stop = false;
                this.isParsing = true;
                this.parseRequestPending.Set(); // fire off the parse!
            }
            // Note if the thread is already running, this will just fall through and that's ok.
            // We simply want to be sure the thread will eventually pick up our parse request.
            // We do NOT want to block until the thread calls Set() at the top of the loop because
            // that can cause deadlocks because this is not a ParseRequestHandle.
            bool started = this.parseRequestStarted.WaitOne(10000, false); // give it time to get going.
#if PARSETHREAD
            Debug.Assert(started, "Timed out on a wait for thread to start");
#endif
            return new AsyncResult(this, request, this.parseRequestDone);
        }

        public IAsyncResult GetParseResult() {
#if PARSETHREAD
            if (this.parseRequest != null)
                Trace.WriteLine("AsyncResult hangle for " + this.parseRequest.Timestamp);
            else {
                Trace.WriteLine("LS.ParseRequest is null; event signaled: " + this.parseRequestDone.IsSet());
            }
#endif
            return new AsyncResult(this, this.parseRequest, this.parseRequestDone);
        }

        class AsyncResult : IAsyncResult {
            LanguageService service;
            ParseRequest request;
            ParseWaitHandle handle;

            public AsyncResult(LanguageService svc, ParseRequest request, ParseWaitHandle handle) {
                this.service = svc;
                this.request = request;
                this.handle = handle;
            }
            public object AsyncState {
                get { return request; }
            }

            public WaitHandle AsyncWaitHandle {
                get { return this.handle; }
            }

            public bool CompletedSynchronously {
                get { return request.IsSynchronous; }
            }

            public bool IsCompleted {
                get { return this.handle.IsSet(); }
            }
        }

        /// <summary>
        /// This class provides a special wrapper on WaitHandle that allows a caller
        /// to block on a parse request, while still pumping the RunTasks queue so they
        /// don't cause a deadlock.
        /// </summary>
        class ParseWaitHandle : WaitHandle {
            LanguageService service;
            ManualResetEvent evt = new ManualResetEvent(false);
            bool set = false;

            public ParseWaitHandle(LanguageService service) {
                this.service = service;
            }

            public void Set() {
                set = true;
                evt.Set();
            }
            public void Reset() {
                set = false;
                evt.Reset();
            }
            public bool IsSet(){
                return this.set;
            }
            public override bool WaitOne() {
                while (!this.WaitOne(10, false)) {                    
                }
                return true;
            }

            public override bool WaitOne(int millisecondsTimeout, bool exitContext) {
                int total = 0;
                bool result = false;
                while (total <= millisecondsTimeout && !result) {
                    result = evt.WaitOne(10, false);
                    total += 10;
                    service.RunTasks();
                }
                return result;
            }

            public override bool WaitOne(TimeSpan timeout, bool exitContext) {
                return WaitOne(timeout.Milliseconds, exitContext);
            }            
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.CreateParseRequest"]/*' />
        public virtual ParseRequest CreateParseRequest(Source s, int line, int idx, TokenInfo info, string sourceText, 
                                                       string fname, ParseReason reason, IVsTextView view) {
            bool sync = false;
            if (!this.Preferences.EnableAsyncCompletion) {
                sync = true; //unless registry value indicates that sync ops always prefer async 
            }
            return new ParseRequest(line, idx, info, sourceText, fname, reason, view, s.CreateAuthoringSink(reason, line, idx), sync);
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.OnParseComplete"]/*' />
        /// <summary>Override this method if you need to do any post-parse work on the main UI thread.
        /// Be sure to call this base method in order to get the dynamic help context updated.</summary>
        public virtual void OnParseComplete(ParseRequest req) {
            SetUserContextDirty(req.FileName);
            if (!ViewFilter.IsExecutingCommand) {
                RefreshUI();
            }
        }

        internal void RefreshUI() {
            IVsUIShell uiShell = this.GetService(typeof(SVsUIShell)) as IVsUIShell;
            if (uiShell != null) {
                uiShell.UpdateCommandUI(1);
            }
        }

        internal void StartThread() {
            Debug.Assert(this.MainThreadId == Thread.CurrentThread.ManagedThreadId);
            if (this.parseThread == null && !disposed) {
#if DEBUG
                Debug.Assert(threadCount == 0, "There should never be more than one ParseThread!");
#endif
                this.parseThread = new Thread(new ThreadStart(ParseThread));
                // Initialize this thread's culture info with that of the shell's LCID
                this.parseThread.CurrentUICulture = new CultureInfo(this.lcid);
                this.parseThread.Name = "Parse Thread";
                this.parseThread.Start();
            }
        }

        internal void StopThread() {
#if PARSETHREAD
            Trace.WriteLine("StopThread");
#endif
            if (this.parseThread != null) {
                this.stop = true;
                this.ParseThreadPaused = false;
                ManualResetEvent ptt = this.parseThreadTerminated;
                this.parseRequestPending.Set();
                if (!ptt.WaitOne(10, false)) { // give it a few milliseconds...
                    // Then kill it right away so devenv.exe shuts down quickly and so that
                    // the parse thread doesn't try to access services that are already shutdown.
                    try {
                        Thread t = this.parseThread;
                        if (t != null) {
                            t.Abort();
                            OnParseAborted();
                        }
                    } catch {
                    }
                    this.parseThread = null;
                }
            }
            this.CleanupThread();
        }

        public virtual void OnParseAborted() {
#if PARSETHREAD
            Trace.WriteLine("OnParseAborted");
#endif            
        }

        internal void CleanupThread() {
#if PARSETHREAD
            Trace.WriteLine("CleanupThread");
#endif
            this.parseRequestPending.Reset();
            this.parseThreadTerminated.Reset();
            this.parseRequestDone.Set();
            this.parseRequestStarted.Reset();
            this.parseThread = null;
            this.isParsing = false;
            this.stop = false;
            this.ParseThreadPaused = false;
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.OnParseComplete"]/*' />
        public bool IsParsing {
            get { return this.isParsing; }
            set { this.isParsing = value; }
        }

        public void AbortBackgroundParse() {
            this.StopThread();
        }

        public bool ParseThreadPaused {
            get { return this.paused; }
            set {
                if (this.paused != value) {
#if PARSETHREAD
                    Trace.WriteLine("ParseThreadPaused="+value);
#endif
                    if (value) {
                        parseRequestResume.Reset();
                    } else {
                        parseRequestResume.Set(); // signal thread to go!
                    }
                    this.parseRequestPending.Reset();
                    this.paused = value;
                }
            }
        }

        internal ParseRequest parseRequest;
        // this is a signal to the ParseThread to tell it a parseRequest is waiting to be processed.
        private ManualResetEvent parseRequestPending = new ManualResetEvent(false);
        // this is a signal to the UI thread that the parse thread has started.
        private ManualResetEvent parseRequestStarted = new ManualResetEvent(false);
        // this is a signal to the UI thread that the parse thread has terminated.
        private ManualResetEvent parseThreadTerminated = new ManualResetEvent(false);
        // this is a signal to the parse thread that it can resume processing.
        private ManualResetEvent parseRequestResume = new ManualResetEvent(false);

        // this is a special wait handle that is used to do non-deadlocking wait on UI thread
        private ParseWaitHandle parseRequestDone;

        internal Thread parseThread;
        bool stop;
        bool paused;
#if DEBUG
        int threadCount;
#endif
        internal void ParseThread() {
            try {
#if DEBUG
                Debug.Assert(threadCount == 0, "There should never be more than one ParseThread!");
                threadCount++;
#endif

                while (!stop) {
                    if (paused) {
#if PARSETHREAD
                        Trace.WriteLine("### ParseThread paused");
#endif
                        parseRequestResume.WaitOne();
#if PARSETHREAD
                        Trace.WriteLine("### ParseThread resumed");
#endif
                    }
                    if (!parseRequestPending.WaitOne(10000, true)) {
                        break;
                    }
                    if (this.stop) break;

                    this.parseRequestDone.Reset(); // must reset this before firing off the parse!
#if PARSETHREAD
                    Trace.WriteLine("Thread started " + this.parseRequest.Timestamp + " event signaled: " + this.parseRequestDone.IsSet());
#endif
                    // Signal that the thread is now in business.
                    this.parseRequestStarted.Set();

                    ParseRequest req = null;
                    lock (this) {
                        req = this.parseRequest;
                        this.parseRequest = null; 
                        this.parseRequestPending.Reset();
                        if (req == null) {
                            this.parseRequestDone.Set(); // not parsing after all, let UI thread work
                            continue;
                        }
                        if (req.Terminate) {
                            break;
                        }
                        this.isParsing = true;
                    }
                    

                    try {
#if PARSETHREAD
                        Trace.WriteLine("### ParseThread churning through "+req.Timestamp+" event signaled: " + this.parseRequestDone.IsSet());
#endif
                        this.ParseRequest(req);
                        if (this.parseRequest == null || req.Reason == ParseReason.Check) {
                            // If another parse request has already come in then the
                            // user must be typing really fast (e.g. macros) and 
                            // so we throw this response away, and go right on to the
                            // next request.
                            // Note this must be asynchronous (do NOT call invoke).
                            // Reason being that the UI thread may then want to call
                            // StopThread, which would deadlock if this was synchronous.
#if PARSETHREAD
                            Trace.WriteLine("...ParseThread starting callback " + req.Timestamp);
#endif
                            this.BeginInvoke(req.Callback, new object[1] { req });
#if PARSETHREAD
                            Trace.WriteLine("...ParseThread ending callback " + req.Timestamp);
#endif
                        }
                    } catch {
                        //ingnore exceptions on background parse and re-use this.parseThread to process
                        //next request. Except ThreadAbortException will bubble to outer try/finally
                    } finally {
                        //could be ThreadAbortException - outer catch will get the exception
                        //if not just set state so while loop can continue
                        OnParseDone(req);
                    }
                }
#if PARSETHREAD
            } catch (Exception e) {
                Trace.WriteLine("Background Thread Exception" + this.parseThread+" "+e);
#else
            } catch {
#endif
            } finally {
                //lets play safe and always cleanup thread
#if DEBUG
                threadCount--;
#endif
                CleanupThread();
                parseThreadTerminated.Set();
            }
        }

        private void OnParseDone(ParseRequest req) {
#if PARSETHREAD
            Trace.WriteLine("OnParseDone "+req.Timestamp);
#endif
            lock (this) {
                if (this.parseRequestDone != null) {
                    this.parseRequestDone.Set();
                }
                this.isParsing = false;
            }
        }

        void SafeWaitForParseComplete() {
            bool success = false;
            if (this.isParsing) {
#if PARSETHREAD
                Trace.WriteLine("SafeWaitComplete Waitng ");
#endif
                // The background thread is parsing, so let's wait for it to finish, so
                // the language service doesn't have to worry about concurrent parsing.
                IAsyncResult result = this.GetParseResult();
                Debug.Assert(result != null);
                if (result != null && !result.IsCompleted && this.ParseThreadIsAlive) {
                    success = result.AsyncWaitHandle.WaitOne(60000, false);
                }
#if PARSETHREAD
                Trace.WriteLine("SafeWaitComplete Done Waitng ");
                Debug.Assert(success || !this.ParseThreadIsAlive || result.IsCompleted, "Bgr thread should finish fine " + success + " " + !this.ParseThreadIsAlive + " " + result.IsCompleted);
#endif
            }
#if PARSETHREAD
            Debug.Assert(!this.isParsing, "Noone should parse here!!!");
#endif
        }

        internal void ParseRequest(ParseRequest req) {
            // For synchronous parse this can be called from the UI thread, in which case we
            // have to set isParsing to true here to stop background OnIdle parse from happening!
            bool uiThread = Thread.CurrentThread.ManagedThreadId == this.MainThreadId;
            bool saved = this.ParseThreadPaused;
            try {
                // If we are on the UI thread then we need to pause the background thread!
                if (uiThread) {
                    this.ParseThreadPaused = true;
                    SafeWaitForParseComplete();
#if PARSETHREAD
                    Debug.Assert(!this.IsParsing, "Threading issue!!!");
#endif
                }
                this.isParsing = true;
                int start = Environment.TickCount;
                req.Scope = this.ParseSource(req);
                req.parseTime = TimeUtilities.TimeSince(start);
#if LANGTRACE
                Trace.WriteLine("ParseRequest in " + (req.parseTime) + " ticks");
#endif
            } finally {
                this.isParsing = false; 
                this.ParseThreadPaused = saved;                
            }
        }

        #region IObjectWithSite
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.IObjectWithSite.GetSite"]/*' />
        public void GetSite(ref Guid iid, out IntPtr ptr) {
            IntPtr pUnk = Marshal.GetIUnknownForObject(this.site);
            Marshal.QueryInterface(pUnk, ref iid, out ptr);
            Marshal.Release(pUnk);
        }
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.IObjectWithSite.SetSite"]/*' />
        /// <internalonly/>
        public void SetSite(object site) {
            if (site is IServiceProvider) {
                this.site = (IServiceProvider)site;
            } else if (site is IOleServiceProvider) {
                this.site = new ServiceProvider((IOleServiceProvider)site);
            }
            Microsoft.VisualStudio.Shell.Package pkg = (Microsoft.VisualStudio.Shell.Package)this.site.GetService(typeof(Microsoft.VisualStudio.Shell.Package));
            this.lcid = pkg.GetProviderLocale();
            this.control = new TaskControl(this);
        }
        #endregion

#if IVsOutliningCapableLanguage                 
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.CollapseToDefinitions"]/*' />
        public virtual void CollapseToDefinitions(IVsTextLines buffer, IVsOutliningSession session) {
            Source source = this.GetSource(buffer);
            source.CollapseAllHiddenRegions(session);
        }
#endif

        void Queue(MainThreadTask task) {
            lock (this.control) { // do not lock "this" because it causes deadlocks.
                if (this.tail != null) { // might actually be running!
                    this.tail.Next = task; // quietly append the new task
                } else {
                    this.task = task;
                    if (this.control != null) {
                        // Ping RunTasks right away rather than waiting for OnIdle.
                        this.control.PostRunTasks();
                    }
                }
                this.tail = task;
            }
        }

        MainThreadTask Dequeue() {
            lock (this.control) {
                MainThreadTask result = null;
                if (this.task != null) {
                    result = this.task;
                    this.task = result.Next;
                    if (this.task == null) {
                        this.tail = null;
                    }
                }
                return result;
            }
        }

        void ClearTask() {
            lock (this.control) {
                this.task = this.tail = null;
            }
        }

        internal void RunTasks() {
            MainThreadTask task = Dequeue();
            while (task != null) {
                task.Run();
                task = Dequeue();
            }
        }

        #region ISynchronizeInvoke Members

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.BeginInvoke"]/*' />
        [HostProtection(Synchronization = true, ExternalThreading = true)]
        public IAsyncResult BeginInvoke(Delegate method, object[] args) {
            MainThreadTask task = new MainThreadTask(this.mainThread, method, args);
            Queue(task);
            return task; // wait for onidle.
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.Invoke"]/*' />
        public object Invoke(Delegate method, object[] args) {
            MainThreadTask task = new MainThreadTask(this.mainThread, method, args);
            if (!task.CompletedSynchronously) {
                Queue(task);
                task.AsyncWaitHandle.WaitOne(); // wait for onidle loop.
            }
            object result = task.AsyncState;
            return result;
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.EndInvoke"]/*' />
        public object EndInvoke(IAsyncResult result) {
            result.AsyncWaitHandle.WaitOne();
            return result.AsyncState;
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.InvokeRequired"]/*' />
        public bool InvokeRequired {
            get {
                return this.mainThread != Thread.CurrentThread;
            }
        }
        #endregion


        #region IVsDebuggerEvents Members

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.OnModeChange"]/*' />
        public virtual int OnModeChange(DBGMODE dbgmodeNew) {
            this.dbgMode = dbgmodeNew;
            return NativeMethods.S_OK;
        }

        #endregion


        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.QueryInvalidEncoding"]/*' />
        /// Return true if the given encoding information is invalid for your language service
        /// Default always returns false.  If you return true, then also return an error
        /// message to display to the user.
        public virtual bool QueryInvalidEncoding(__VSTFF format, out string errorMessage) {
            errorMessage = null;
            return false;
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.GetFormatFilterList"]/*' />
        // Provides the list of available extensions for Save As.
        // The following default filter string is automatically added
        // by Visual Studio:
        // "All Files (*.*)\n*.*\nText Files (*.txt)\n*.txt\n"
        public abstract string GetFormatFilterList();

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.CurFileExtensionFormat"]/*' />
        // Provides the index to the filter matching the extension of the file passed in.
        // The default behavior for this method is to look for the matching extension 
        // in the list returned from GetFormatFilterList and return the index to that extension.
        // It expects GetFormatFilterList to return newline separated or '|' separated 
        // list of label/extension pairs. It expects the extensions to be in the format "*.x"
        // where x is the extension you want to match.  Returns -1 if there is no match.
        public virtual int CurFileExtensionFormat(string fileName) {

            string filter = GetFormatFilterList();
            if (string.IsNullOrEmpty(filter)) return -1;

            string fileext = FilePathUtilities.GetFileExtension(fileName);

            string[] sa = null;
            if (filter.Contains("\n")) {
                sa = filter.Split('\n');
            } else if (filter.Contains("|")) {
                sa = filter.Split('|');
            } else {
                throw new ArgumentException(SR.GetString(SR.UnrecognizedFilterFormat), "GetFormatFilterList");
            }

            for (int i = 0, n = sa.Length - 1; i < n; i += 2) {
                string ext = sa[i + 1].Trim();
                if (ext.Length > 1 && string.Compare(ext.Substring(1), fileext, StringComparison.OrdinalIgnoreCase) == 0) {
                    return i / 2;
                }
            }
            return -1;
        }

        #region IVsFormatFilterProvider Members
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.IVsFormatFilterProvider.QueryInvalidEncoding"]/*' />
        /// <internalonly/>
        int IVsFormatFilterProvider.QueryInvalidEncoding(uint format, out string pbstrMessage) {
            if (QueryInvalidEncoding((__VSTFF)format, out pbstrMessage)) {
                return NativeMethods.S_OK;
            }
            return NativeMethods.S_FALSE;
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.IVsFormatFilterProvider.CurFileExtensionFormat"]/*' />
        /// <internalonly/>
        int IVsFormatFilterProvider.CurFileExtensionFormat(string bstrFileName, out uint pdwExtnIndex) {
            pdwExtnIndex = 0;
            if (!string.IsNullOrEmpty(bstrFileName)) {
                int i = CurFileExtensionFormat(bstrFileName);
                if (i >= 0) {
                    pdwExtnIndex = (uint)i;
                    return NativeMethods.S_OK;
                }
            }
            return NativeMethods.E_FAIL; // return 0 - but no match found.
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="LanguageService.IVsFormatFilterProvider.GetFormatFilterList"]/*' />
        /// <internalonly/>
        int IVsFormatFilterProvider.GetFormatFilterList(out string pbstrFilterList) {
            pbstrFilterList = GetFormatFilterList();
            if (pbstrFilterList.Contains("|")) {
                string[] sa = pbstrFilterList.Split('|');
                pbstrFilterList = string.Join("\n", sa);
            }
            if (pbstrFilterList == null)
                return NativeMethods.E_FAIL;

            // Must be terminated with a new line character.
            // (since inside VS this results in the proper Win32 saveas dialog double null 
            // termination format since the new lines are replaced with nulls).
            // (See dlgsave.cpp line 163 in the InvokeSaveAsDlg function).
            if (!pbstrFilterList.EndsWith("\n", StringComparison.OrdinalIgnoreCase))
                pbstrFilterList = pbstrFilterList + "\n";

            return NativeMethods.S_OK;
        }

        #endregion

        #region IVsAutoOutliningClient
        public virtual int QueryWaitForAutoOutliningCallback(out int fWait)
        {
            // Wait to perform outlining depersist/load, calling IVsTextViewEx.PersistOutliningState()
            // in Source.ProcessHiddenRegions()
            fWait = 1;
            return VSConstants.S_OK;
        }
        #endregion
    } // end class LanguageService

    internal class MainThreadTask : IAsyncResult, IDisposable {
        ManualResetEvent evt = new ManualResetEvent(false);
        Delegate method;
        object[] args;
        bool completed;
        bool completedSynchronously;
        Thread main;
        object result;
        MainThreadTask next;
        ExecutionContext context;
        Exception error;

        public MainThreadTask(Thread main, Delegate method, object[] args) {
            this.main = main;
            this.method = method;
            this.args = args;
            if (Thread.CurrentThread == main) {
                Run(); // run synchronously!
                this.completedSynchronously = true;
            } else {
                this.context = ExecutionContext.Capture();
            }
        }

        public MainThreadTask Next {
            get { return this.next; }
            set { this.next = value; }
        }

        public void Run() {
            if (!this.completed && this.method != null) {
                if (this.context == null) {
                    RunSecure(null);
                } else {
                    ExecutionContext.Run(this.context, new ContextCallback(RunSecure), null);
                }
            }
        }

        void RunSecure(object state) {
            try {
                this.result = method.DynamicInvoke(args);
            } catch (Exception e) {
                // Save the exception for the original thread who made this request.
                this.error = e;
            } finally {
                this.completed = true;
                this.evt.Set();
            }
        }

        public object AsyncState {
            get {
                if (this.error != null) {
                    // throw the exception on the original thread.
                    throw this.error;
                }
                return this.result;
            }
        }

        public WaitHandle AsyncWaitHandle {
            get { return this.evt; }
        }

        public bool CompletedSynchronously {
            get { return this.completedSynchronously; }
        }

        public bool IsCompleted {
            get { return this.completed; }
        }

        public void Dispose() {
            if (this.evt != null) {
                this.evt.Close();
                this.evt = null;
            }
            this.method = null;
            this.args = null;
        }
    }

    /// <include file='doc\LanguageService.uex' path='docs/doc[@for="ParseResultHandler"]/*' />
    [CLSCompliant(false)]
    public delegate void ParseResultHandler(ParseRequest request);

    /// <include file='doc\LanguageService.uex' path='docs/doc[@for="ParseRequest"]/*' />
    [CLSCompliant(false)]
    public class ParseRequest {
        int line, col;
        TextSpan dirtySpan;
        string fileName;
        string text;
        ParseReason reason;
        IVsTextView view;
        bool terminate;
        ParseResultHandler callback;
        AuthoringSink sink;
        AuthoringScope scope;
        TokenInfo tokenInfo;
        int timestamp;
        internal int parseTime;
        bool isSynchronous;
        internal IAsyncResult result;

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="ParseRequest.IsSynchronous;"]/*' />
        public bool IsSynchronous {
            get { return isSynchronous; }
            set { isSynchronous = value; }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="ParseRequest.Line;"]/*' />
        public int Line {
            get { return this.line; }
            set { this.line = value; }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="ParseRequest.Col;"]/*' />
        public int Col {
            get { return this.col; }
            set { this.col = value; }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="ParseRequest.DirtySpan;"]/*' />
        public TextSpan DirtySpan {
            get { return this.dirtySpan; }
            set { this.dirtySpan = value; }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="ParseRequest.FileName;"]/*' />
        public string FileName {
            get { return this.fileName; }
            set { this.fileName = value; }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="ParseRequest.Text;"]/*' />
        public string Text {
            get { return this.text; }
            set { this.text = value; }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="ParseRequest.Reason;"]/*' />
        public ParseReason Reason {
            get { return this.reason; }
            set { this.reason = value; }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="ParseRequest.View;"]/*' />
        public IVsTextView View {
            get { return this.view; }
            set { this.view = value; }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="ParseRequest.Terminate;"]/*' />
        public bool Terminate {
            get { return this.terminate; }
            set { this.terminate = value; }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="ParseRequest.Callback;"]/*' />
        public ParseResultHandler Callback {
            get { return this.callback; }
            set { this.callback = value; }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="ParseRequest.Sink;"]/*' />
        public AuthoringSink Sink {
            get { return this.sink; }
            set { this.sink = value; }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="ParseRequest.Scope;"]/*' />
        public AuthoringScope Scope {
            get { return this.scope; }
            set { this.scope = value; }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="ParseRequest.TokenInfo;"]/*' />
        public TokenInfo TokenInfo {
            get { return this.tokenInfo; }
            set { this.tokenInfo = value; }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="ParseRequest.Timestamp;"]/*' />
        public int Timestamp {
            get { return this.timestamp; }
            set { this.timestamp = value; }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="ParseRequest.ParseRequest"]/*' />
        public ParseRequest(bool terminate) {
            this.Terminate = terminate;
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="ParseRequest.ParseRequest1"]/*' />
        public ParseRequest(int line, int col, TokenInfo info, string src, string fname, 
            ParseReason reason, IVsTextView view, AuthoringSink sink, bool synchronous) {
            this.Line = line;
            this.Col = col;
            this.FileName = fname;
            this.Text = src;
            this.Reason = reason;
            this.View = view;
            this.Sink = sink;
            this.TokenInfo = info;
            this.isSynchronous = synchronous;
        }
    }

    /// <include file='doc\LanguageService.uex' path='docs/doc[@for="AuthoringScope"]/*' />
    [CLSCompliant(false)]
    public abstract class AuthoringScope {
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="AuthoringScope.GetDataTipText"]/*' />
        public abstract string GetDataTipText(int line, int col, out TextSpan span);

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="AuthoringScope.GetDeclarations"]/*' />
        //REVIEW: why pass in the view and the info?
        public abstract Declarations GetDeclarations(IVsTextView view, int line, int col, TokenInfo info, ParseReason reason);

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="AuthoringScope.GetMethods"]/*' />
        public abstract Methods GetMethods(int line, int col, string name);

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="AuthoringScope.Goto"]/*' />
        public abstract string Goto(Microsoft.VisualStudio.VSConstants.VSStd97CmdID cmd, IVsTextView textView, int line, int col, out TextSpan span);
    }

    /// <include file='doc\LanguageService.uex' path='docs/doc[@for="Declarations"]/*' />
    [CLSCompliant(false)]
    public abstract class Declarations : IDisposable {

        private string lastBestMatch;

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="Declarations.LastBestMatch"]/*' />
        public string LastBestMatch {
            get {
                return this.lastBestMatch;
            }
            set {
                this.lastBestMatch = value;
            }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="Declarations.Declarations"]/*' />
        protected Declarations() {
            this.LastBestMatch = "";
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="Declarations.Dispose"]/*' />
        public virtual void Dispose() {
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="Declarations.GetCount"]/*' />
        public abstract int GetCount();

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="Declarations.GetDisplayText"]/*' />
        public abstract string GetDisplayText(int index);

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="Declarations.GetName"]/*' />
        public abstract String GetName(int index);

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="Declarations.GetDescription"]/*' />
        public abstract String GetDescription(int index);

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="Declarations.GetGlyph"]/*' />
        public abstract int GetGlyph(int index);

        /// <include file='doc\Source.uex' path='docs/doc[@for="Declarations.GetInitialExtent"]/*' />
        /// <summary>Override this method if you want to customize how the initial extent
        /// is calculated.  If you do not implement this method the the Source object 
        /// GetWordExtent will be used by default.</summary>
        public virtual bool GetInitialExtent(IVsTextView textView, out int line, out int startIdx, out int endIdx) {
            line = startIdx = endIdx = 0;
            return false;
        }

        // return whether this is a uniqueMatch or not
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="Declarations.GetBestMatch"]/*' />
        public virtual void GetBestMatch(String value, out int index, out bool uniqueMatch) {
            index = -1;
            uniqueMatch = false;
            this.LastBestMatch = "";
            if (value != null) {
                int count = GetCount();
                bool found = false;
                bool foundInsensitive = false;
                bool uniqueInsensitive = false;
                int indexInsensitive = -1;
                // Don't assume the list is sorted!                
                // But give case-sensitive comparison the preference.
                for (int i = 0; i < count; i++) {
                    if (IsPerfectMatch(value, i)){
                        if (!found) {
                            uniqueMatch = true;
                            found = true;
                            index = i;
                        } else {
                            uniqueMatch = false;
                            break;
                        }
                    } 
                    if (IsMatch(value, i)) {
                        if (!foundInsensitive) {
                            uniqueInsensitive = true;
                            foundInsensitive = true;
                            indexInsensitive = i;
                        } else {
                            uniqueInsensitive = false;
                        }
                    }
                }
                if (!found && foundInsensitive) {
                    uniqueMatch = uniqueInsensitive;
                    index = indexInsensitive;
                }
                return;
            }
            if (value == null || value.Length == 0) {
                // no match found - return S_FALSE
                COMException ce = new COMException("", unchecked((int)0x00000001));
                throw ce;
            } else {
                this.LastBestMatch = value;
                index = GetCount();
                uniqueMatch = true;
            }
            return;
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="Declarations.IsMatch"]/*' />
        public virtual bool IsMatch(string textSoFar, int index) {
            int len = textSoFar.Length;
            string text = GetName(index);
            return String.Compare(text, 0, textSoFar, 0, len, true, CultureInfo.CurrentUICulture) == 0;
        }

        public virtual bool IsPerfectMatch(string textSoFar, int index) {
            int len = textSoFar.Length;
            string text = GetName(index);
            return String.Compare(text, 0, textSoFar, 0, len, false, CultureInfo.CurrentUICulture) == 0;
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="Declarations.IsCommitChar"]/*' />
        public virtual bool IsCommitChar(string textSoFar, int selected, char commitCharacter) {
            // Usual language identifier rules...
            return !(Char.IsLetterOrDigit(commitCharacter) || commitCharacter == '_');
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="Declarations.OnCommit"]/*' />
        public virtual string OnCommit(IVsTextView textView, string textSoFar, char commitCharacter, int index, ref TextSpan initialExtent) {
            return GetName(index);
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="Declarations.OnAutoComplete"]/*' />
        // This method allows the implementer to do something after completion is finished, for example,
        // in the XML editor the when the user selects a start tag name "<foo", this method is used to
        // insert the end tag automatically "></foo>".  The framework makes sure this method is called at
        // the right time, after VS has actually inserted the result from OnCommit, in this case "foo".
        // It returns one more character to process, which may itself be a trigger for more intellisense.
        public virtual char OnAutoComplete(IVsTextView textView, string committedText, char commitCharacter, int index) {
            // do nothing by default.
            return '\0';
        }
    }

    //-------------------------------------------------------------------------------------
    /// <include file='doc\LanguageService.uex' path='docs/doc[@for="Methods"]/*' />
    [CLSCompliant(false)]
    public abstract class Methods {

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="Methods.DefaultMethod"]/*' />
        /// <summary>Returns the method that should be selected first (based on what was found
        /// at parse time at the ParseRequest source location).</summary>
        public virtual int DefaultMethod {
            get { return 0; }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="Methods.GetName"]/*' />
        public abstract string GetName(int index);

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="Methods.GetCount"]/*' />
        public abstract int GetCount();

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="Methods.GetDescription"]/*' />
        public abstract string GetDescription(int index);

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="Methods.GetType"]/*' />
        public abstract string GetType(int index);

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="Methods.GetParameterCount"]/*' />
        public abstract int GetParameterCount(int index);

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="Methods.GetParameterInfo"]/*' />
        public abstract void GetParameterInfo(int index, int parameter, out string name, out string display, out string description);

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="Methods.OpenBracket"]/*' />
        public virtual string OpenBracket {
            get { return "("; }
        }
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="Methods.CloseBracket"]/*' />
        public virtual string CloseBracket {
            get { return ")"; }
        }
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="Methods.Delimiter"]/*' />
        public virtual string Delimiter {
            get { return ","; }
        }
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="Methods.TypePrefixed"]/*' />
        public virtual bool TypePrefixed {
            get { return false; }
        }
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="Methods.TypePrefix"]/*' />
        public virtual string TypePrefix {
            get { return null; }
        }
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="Methods.TypePostfix"]/*' />
        public virtual string TypePostfix {
            get { return null; }
        }
    }

    internal class CallInfo {
        internal int currentParameter;
        internal StringCollection names;
        internal ArrayList sourceLocations;
    };

    internal class MethodCalls {
        private Stack calls;
        private CallInfo call;

        public MethodCalls() {
            this.calls = new Stack();
            this.Push(new StringCollection(), new ArrayList());
        }

        public void Push(StringCollection names, ArrayList sourceLocations) {
            this.calls.Push(call);
            this.call = new CallInfo();
            this.call.names = names;
            this.call.sourceLocations = sourceLocations;
        }

        public void NextParameter() {
            this.call.currentParameter++;
        }

        public void Pop() {
            if (this.calls.Count <= 0) {
                Debug.Assert(false); return;
            }
            call = (CallInfo)this.calls.Pop();
        }

        public CallInfo GetCurrentMethodCall() {
            return this.call;
        }
    }

    internal class BraceMatch {
        private TextSpan[] spans;
        private int priority;

        public BraceMatch(TextSpan[] spans, int priority) {
            if ((null == spans) || (2 > spans.Length)) {
                throw new ArgumentNullException("spans");
            }
            this.spans = spans;
            this.priority = priority;
        }

        public int Count {
            get { return spans.Length; }
        }

        public int Priority {
            get { return priority; }
        }

        public TextSpan Span(int index) {
            if ((index < 0) || (index >= spans.Length)) {
                throw new ArgumentOutOfRangeException("index");
            }
            return spans[index];
        }
    }

    /// <include file='doc\LanguageService.uex' path='docs/doc[@for="AuthoringSink"]/*' />
    /// <summary>
    /// AuthoringSink is used to gather information from the parser to help in the following:
    /// - error reporting
    /// - matching braces (ctrl-])
    /// - intellisense: Member Selection, CompleteWord, QuickInfo, MethodTips
    /// - management of the autos window in the debugger
    /// - breakpoint validation
    /// </summary>
    [CLSCompliant(false)]
    public class AuthoringSink {
        internal ParseReason reason;
        internal StringCollection Names;
        internal ArrayList SourceLocations;
        internal int line;
        internal int col;
        internal MethodCalls MethodCalls;
        internal ArrayList Spans;
        private List<BraceMatch> braces;
        internal bool foundMatchingBrace;
        internal ArrayList hiddenRegions;
        internal bool processHiddenRegions;
        internal ArrayList errors;
        private int[] errorCounts;
        private int maxErrors;

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="AuthoringSink.AuthoringSink"]/*' />
        public AuthoringSink(ParseReason reason, int line, int col, int maxErrors) {
            this.reason = reason;
            this.errors = new ArrayList();
            this.line = line;
            this.col = col;
            this.Names = new StringCollection();
            this.SourceLocations = new ArrayList();
            this.MethodCalls = new MethodCalls();
            this.Spans = new ArrayList();
            this.braces = new List<BraceMatch>();
            this.hiddenRegions = new ArrayList();
            this.errorCounts = new int[4];
            this.maxErrors = maxErrors;
        }

        internal IList<BraceMatch> Braces {
            get { return braces; }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="AuthoringSink.Line"]/*' />
        public int Line {
            get { return this.line; }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="AuthoringSink.Column"]/*' />
        public int Column {
            get { return this.col; }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="AuthoringSink.Reason"]/*' />
        public ParseReason Reason {
            get { return this.reason; }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="AuthoringSink.FoundMatchingBrace"]/*' />
        public bool FoundMatchingBrace {
            get { return this.foundMatchingBrace; }
            set { this.foundMatchingBrace = value; }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="AuthoringSink.UpdateHiddenRegions"]/*' />
        /// <summary>Determines whether or not hidden regions should be updated
        /// or not based on the calls to AddHiddenRegion.  Default is false.</summary>
        public bool ProcessHiddenRegions {
            get { return this.processHiddenRegions; }
            set { this.processHiddenRegions = value; }
        }

        private void AddBraces(BraceMatch b) {
            this.foundMatchingBrace = true;
            int i = 0;
            for (int n = this.Braces.Count; i < n; i++) {
                BraceMatch a = this.Braces[i];
                if (a.Priority < b.Priority)
                    break;
            }
            this.Braces.Insert(i, b);
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="AuthoringSink.BraceMatching"]/*' />
        /// <summary>Use this property to find if your parser should call MatchPair or MatchTriple</summary>
        public bool BraceMatching {
            get {
                switch (this.reason) {
                    case ParseReason.MatchBraces:
                    case ParseReason.HighlightBraces:
                    case ParseReason.MemberSelectAndHighlightBraces:
                        return true;
                }
                return false;
            }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="AuthoringSink.MatchPair"]/*' />
        /// <summary>
        /// Whenever a matching pair is parsed, e.g. '{' and '}', this method is called
        /// with the text span of both the left and right item. The
        /// information is used when a user types "ctrl-]" in VS
        /// to find a matching brace and when auto-highlight matching
        /// braces is enabled.  A priority can also be given so that multiple overlapping pairs 
        /// can be prioritized for brace matching.  The matching pair with the highest priority 
        /// (largest integer value) wins.
        /// </summary>
        public virtual void MatchPair(TextSpan span, TextSpan endContext, int priority) {
            MatchMultiple(new TextSpan[] { span, endContext }, priority);
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="AuthoringSink.MatchTriple"]/*' />
        /// <summary>
        /// Matching tripples are used to highlight in bold a completed statement.  For example
        /// when you type the closing brace on a foreach statement VS highlights in bold the statement
        /// that was closed.  The first two source contexts are the beginning and ending of the statement that
        /// opens the block (for example, the span of the "foreach(...){" and the third source context
        /// is the closing brace for the block (e.g., the "}").  A priority can also be given so that
        /// multiple overlapping pairs can be prioritized for brace matching.  
        /// The matching pair with the highest priority  (largest integer value) wins.
        /// </summary>
        public virtual void MatchTriple(TextSpan startSpan, TextSpan middleSpan, TextSpan endSpan, int priority) {
            MatchMultiple(new TextSpan[] { startSpan, middleSpan, endSpan }, priority);
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="AuthoringSink.MatchMultiple"]/*' />
        /// <summary>
        /// Matching multiples are used to highlight in bold a completed statement.  For example
        /// a language can define a construct like if ... elif ... elif ... else ... endif
        /// A priority can also be given so that multiple overlapping pairs can be prioritized for 
        /// brace matching.
        /// The matching pair with the highest priority  (largest integer value) wins.
        /// </summary>
        public virtual void MatchMultiple(TextSpan[] spans, int priority) {
            if ((null == spans) || (2 > spans.Length)) {
                throw new ArgumentNullException("spans");
            }
            if (!BraceMatching) {
                return;
            }
            for (int i=0; i<spans.Length; ++i) {
                TextSpanHelper.MakePositive(ref spans[i]);
            }
            bool shouldAdd = false;
            foreach (TextSpan s in spans) {
                if (TextSpanHelper.ContainsInclusive(s, this.line, this.col)) {
                    shouldAdd = true;
                    break;
                }
            }
            if (!shouldAdd) {
                return;
            }
            foreach (TextSpan s in spans) {
                this.Spans.Add(s);
            }
            AddBraces(new BraceMatch(spans, priority));
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="AuthoringSink.FindNames"]/*' />
        /// <summary>Use this property to find if your parser should call StartName or QualifyName</summary>
        public bool FindNames {
            get {
                switch (this.reason) {
                    case ParseReason.MemberSelect:
                    case ParseReason.CompleteWord:
                    case ParseReason.MemberSelectAndHighlightBraces:
                    case ParseReason.DisplayMemberList:
                    case ParseReason.QuickInfo:
                    case ParseReason.MethodTip:
                    case ParseReason.Autos:
                        return true;
                }
                return false;
            }
        }
        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="AuthoringSink.StartName"]/*' />
        /// <summary>
        /// In support of Member Selection, CompleteWord, QuickInfo, 
        /// MethodTip, and Autos, the StartName and QualifyName methods
        /// are called.
        /// StartName is called for each identifier that is parsed (e.g. "Console")
        /// </summary>
        public virtual void StartName(TextSpan span, string name) {
            if (FindNames) {
                int startLine = span.iStartLine;
                int startCol = span.iStartIndex;
                int endLine = span.iEndLine;
                int endCol = span.iEndIndex;
                if (startLine < 0 || startCol < 0 || startLine > endLine || (startLine == endLine && endCol < startCol)) {
                    Debug.Assert(false);
                    return;
                }
                if (startLine <= this.line && endLine >= this.line) {
                    this.Names.Add(name);
                    this.SourceLocations.Add(span);
                }
            }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="AuthoringSink.QualifyName"]/*' />
        /// <summary>
        /// QualifyName is called for each qualification with both
        /// the text span of the selector (e.g. ".")  and the text span 
        /// of the name ("WriteLine").
        /// </summary>
        public virtual void QualifyName(TextSpan selectorContext, TextSpan nameContext, string name) {
            if (FindNames) {
                int startLine1 = selectorContext.iStartLine;
                int startCol1 = selectorContext.iStartIndex;
                int endCol1 = selectorContext.iEndIndex;
                int endLine1 = selectorContext.iEndLine;
                int startLine2 = nameContext.iStartLine;
                int startCol2 = nameContext.iStartIndex;
                int endCol2 = nameContext.iEndIndex;
                int endLine2 = nameContext.iEndLine;
                if (startLine1 < 0 || startCol1 < 0 || (startLine1 == endLine1 && endCol1 < startCol1) || startLine2 < startLine1 || startCol2 < 0 || (startLine2 == endLine2 && endCol2 < startCol2)) {
                    Debug.Assert(false);
                    return;
                }
                if (startLine2 <= this.line && endLine2 >= this.line) {
                    this.Names.Add(name);
                    this.SourceLocations.Add(nameContext);
                }
            }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="AuthoringSink.AutoExpression"]/*' />
        /// <summary>
        /// AutoExpression is in support of IVsLanguageDebugInfo.GetProximityExpressions.
        /// It is called for each expression that might be interesting for
        /// a user in the "Auto Debugging" window. All names that are
        /// set using StartName and QualifyName are already automatically
        /// added to the "Auto" window! This means that AutoExpression
        /// is rarely used.
        /// </summary>
        public virtual void AutoExpression(TextSpan expr) {
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="AuthoringSink.CodeSpan"]/*' />
        /// <summary>
        /// CodeSpan is in support of IVsLanguageDebugInfo.ValidateBreakpointLocation.
        /// It is called for each region that contains "executable" code.
        /// This is used to validate breakpoints. Comments are
        /// automatically taken care of based on TokenInfo returned from scanner. 
        /// Normally this method is called when a procedure is started/ended.
        /// </summary>
        public virtual void CodeSpan(TextSpan span) {
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="AuthoringSink.MethodParameters"]/*' />
        /// <summary>Use this property to find if your parser should call StartParameters, NextParameter or EndParameters</summary>
        public bool MethodParameters {
            get {
                switch (this.reason) {
                    case ParseReason.MethodTip:
                    case ParseReason.QuickInfo:
                        return true;
                }
                return false;
            }
        }


        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="AuthoringSink.StartParameters"]/*' />
        /// <summary>
        /// The StartParameters, Parameter and EndParameter methods are
        /// called in support of method tip intellisense (ECMD_PARAMINFO).
        /// [StartParameters] is called when the parameters of a method
        /// are started, ie. "(".
        /// [Parameter] is called on the start of a new parameter, ie. ",".
        /// [EndParameter] is called on the end of the paramters, ie. ")".
        /// </summary>
        public virtual void StartParameters(TextSpan context) {
            if (MethodParameters) {
                int startLine = context.iStartLine;
                int startCol = context.iStartIndex;
                if (startLine < 0 || startCol < 0) {
                    Debug.Assert(false);
                    return;
                }
                if (this.line > startLine || (this.line == startLine && this.col >= startCol)) {
                    this.MethodCalls.Push(this.Names, this.SourceLocations);
                    this.Names = new StringCollection();
                    this.SourceLocations = new ArrayList();
                }
            }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="AuthoringSink.NextParameter"]/*' />
        /// <summary>
        /// NextParameter is called after StartParameters on the start of each new parameter, ie. ",".
        /// </summary>
        public virtual void NextParameter(TextSpan context) {
            if (MethodParameters) {
                int startLine = context.iStartLine;
                int startCol = context.iStartIndex;
                if (startLine < 0 || startCol < 0) {
                    Debug.Assert(false);
                    return;
                }
                if (this.line > startLine || (this.line == startLine && this.col > startCol)) {
                    this.MethodCalls.NextParameter();
                }
            }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="AuthoringSink.EndParameters"]/*' />
        /// <summary>
        /// EndParameter is called on the end of the paramters, ie. ")".
        /// </summary>
        public virtual void EndParameters(TextSpan context) {
            if (MethodParameters) {
                int startLine = context.iStartLine;
                int startCol = context.iStartIndex;
                if (startLine < 0 || startCol < 0) {
                    Debug.Assert(false);
                    return;
                }
                if (this.line > startLine || (this.line == startLine && this.col > startCol)) {
                    this.MethodCalls.Pop();
                }
            }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="AuthoringSink.AddTask"]/*' />
        /// <summary>
        /// Add an error message. This method also filters out duplicates so you only
        /// see the unique errors in the error list window.
        /// </summary>
        public virtual void AddError(string path, string message, TextSpan context, Severity sev) {
            if (this.reason != ParseReason.Check)
                return;
            if (context.iStartLine < 0 || context.iEndLine < context.iStartLine || context.iStartIndex < 0 || (context.iEndLine == context.iStartLine && context.iEndIndex < context.iStartIndex)) {
                Debug.Assert(false);
                return;
            }
            int i = (int)sev;
            if (this.errorCounts[i] == this.maxErrors)
                return; // reached maximum

            // Make sure the error is unique.
            foreach (ErrorNode n in this.errors) {
                if ((TextSpanHelper.IsSameSpan(n.context, context) ||
                     TextSpanHelper.IsEmbedded(n.context, context) ||
                     TextSpanHelper.IsEmbedded(context, n.context)) &&
                    n.message == message &&
                    n.severity == sev &&
                    n.uri == path) {
                    return; // then it's a duplicate!
                }
            }
            this.errorCounts[i]++;
            this.errors.Add(new ErrorNode(path, message, context, sev));
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="AuthoringSink.HiddenRegions"]/*' />
        /// <summary>Use this property to find if your parser should call AddHiddenRegion</summary>
        public bool HiddenRegions {
            get {
                return (this.reason == ParseReason.Check);
            }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="AuthoringSink.AddHiddenRegion"]/*' />
        /// <summary>
        /// This is in support of outlining.
        /// </summary>
        public virtual void AddHiddenRegion(TextSpan context) {
            AddHiddenRegion(context, null);
        }
        public virtual void AddHiddenRegion(TextSpan context, string banner) {
            if (!HiddenRegions)
                return;

            NewHiddenRegion r = new NewHiddenRegion();
            r.iType = (int)HIDDEN_REGION_TYPE.hrtCollapsible;
            r.dwBehavior = (int)HIDDEN_REGION_BEHAVIOR.hrbClientControlled;
            r.dwState = (int)HIDDEN_REGION_STATE.hrsExpanded;
            r.tsHiddenText = context;
            r.pszBanner = banner;
            r.dwClient = (uint)Source.HiddenRegionCookie;
            AddHiddenRegion(r);
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="AuthoringSink.AddHiddenRegion"]/*' />
        /// <summary>
        /// AddHiddenRegion calls this for you, you can call it directly or override it
        /// to modify the default behavior.
        /// </summary>
        public virtual void AddHiddenRegion(NewHiddenRegion r) {
            if (!HiddenRegions)
                return;

            // Sort the regions by their start positions so that if they add more than 
            // MaxRegions then they get the outer top level ones first.
            int i = this.hiddenRegions.Count - 1;
            while (i >= 0) {
                NewHiddenRegion s = (NewHiddenRegion)this.hiddenRegions[i];
                if (TextSpanHelper.StartsAfterStartOf(r.tsHiddenText, s.tsHiddenText))
                    break;
                i--;
            }
            this.hiddenRegions.Insert(i + 1, r);
        }

    }; // AuthoringSink

    internal class ErrorNode {
        public string uri;
        public string message;
        public TextSpan context;
        public Severity severity;
        public ErrorNode(string uri, string message, TextSpan context, Severity severity) {
            this.uri = uri;
            this.message = message;
            this.context = context;
            this.severity = severity;
        }
    }

    internal class TaskControl : UserControl {
        LanguageService svc;
        const int WM_USER = 0x0400;
        const int WM_RUNTASKS = WM_USER + 500;
        IntPtr hwnd;
        bool posted;

        public TaskControl(LanguageService svc) {
            this.svc = svc;
            this.hwnd = this.Handle;
        }

        protected override void Dispose(bool disposing) {
            this.svc = null;
            base.Dispose(disposing);
        }

        // This causes a thread switch to the main UI thread where we can safely call RunTasks().
        public void PostRunTasks() {
            if (!this.posted) {
                this.posted = true;
                NativeMethods.PostMessage(this.hwnd, WM_RUNTASKS, IntPtr.Zero, IntPtr.Zero);
            }
        }

        protected override void WndProc(ref Message m) {
            if (m.Msg == WM_RUNTASKS && this.svc != null) {
                this.posted = false;
                svc.RunTasks();
            }
            base.WndProc(ref m);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\LanguageService100\EditorView.cs ===
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.TextManager.Interop;
using Microsoft.VisualStudio.Shell;
using System;
using System.Collections;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
using IServiceProvider = System.IServiceProvider;
using ShellConstants = Microsoft.VisualStudio.Shell.Interop.Constants;
using OleConstants = Microsoft.VisualStudio.OLE.Interop.Constants;
using System.Diagnostics;
using System.ComponentModel.Design;

namespace Microsoft.VisualStudio.Package {

    /// <include file='doc\EditorView.uex' path='docs/doc[@for="SimpleEditorView"]/*' />
    /// <summary>
    /// This class View provides an abstract base class for simple editor views
    /// that follow the VS simple embedding model.
    /// </summary>
    [CLSCompliant(false)]
    [System.Runtime.InteropServices.ComVisible(true)]
    public abstract class SimpleEditorView : IOleCommandTarget, IVsWindowPane, IVsToolboxUser, IVsStatusbarUser, IVsWindowPaneCommit, IOleComponent // for idle processing.
        //IServiceProvider,
        //IVsMultiViewDocumentView,
        //IVsFindTarget,
        //IVsWindowFrameNotify,
        //IVsCodeWindow,
        //IVsBroadcastMessageEvents,
        //IVsDocOutlineProvider,
        //IVsDebuggerEvents,
        // ??? VxDTE::IExtensibleObject,
        //IVsBackForwardNavigation
        // ??? public ISelectionContainer,
    {

        IServiceProvider site;
        OleMenuCommandService commandService;
        IVsTextLines buffer;
        IOleComponentManager componentManager;
        uint componentID;

        /// <include file='doc\EditorView.uex' path='docs/doc[@for="SimpleEditorView.Site;"]/*' />
        protected IServiceProvider Site {
            get { return this.site; }
            set { 
                this.site = value;
                IOleCommandTarget parentTarget = null;
                if (null != site) {
                    parentTarget = site.GetService(typeof(IMenuCommandService)) as IOleCommandTarget;
                    if (null == parentTarget) {
                        parentTarget = site.GetService(typeof(IOleCommandTarget)) as IOleCommandTarget;
                    }
                }
                if (null == commandService) {
                    if (null != parentTarget) {
                        commandService = new OleMenuCommandService(site, parentTarget);
                    } else {
                        commandService = new OleMenuCommandService(site);
                    }
                } else {
                    commandService.ParentTarget = parentTarget;
                }
            }
        }
        protected IMenuCommandService MenuCommandService {
            get { return commandService; }
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="SimpleEditorView.Buffer;"]/*' />
        protected IVsTextLines Buffer {
            get { return this.buffer; }
            set { this.buffer = value; }
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="SimpleEditorView.ComponentManager;"]/*' />
        protected IOleComponentManager ComponentManager {
            get { return this.componentManager; }
            set { this.componentManager = value; }
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="SimpleEditorView.ComponentId;"]/*' />
        protected uint ComponentId {
            get { return this.componentID; }
            set { this.componentID = value; }
        }

        /// <include file='doc\EditorView.uex' path='docs/doc[@for="SimpleEditorView.SimpleEditorView"]/*' />
        protected SimpleEditorView(IVsTextLines buffer) {
            this.buffer = buffer;
        }

        #region IOleCommandTarget methods
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="SimpleEditorView.IOleCommandTarget.QueryStatus"]/*' />
        /// <internalonly/>
        /// <summary>
        /// IOleCommandTarget implementation
        /// </summary>
        public virtual int QueryStatus(ref Guid guidCmdGroup, uint cmds, OLECMD[] prgCmds, IntPtr pCmdText) {
            if (null == commandService) {
                return (int)OleConstants.OLECMDERR_E_NOTSUPPORTED;
            }
            return ((IOleCommandTarget)commandService).QueryStatus(ref guidCmdGroup, cmds, prgCmds, pCmdText);
        }

        /// <include file='doc\EditorView.uex' path='docs/doc[@for="SimpleEditorView.IOleCommandTarget.Exec"]/*' />
        /// <internalonly/>
        public virtual int Exec(ref Guid guidCmdGroup, uint id, uint options, IntPtr pvaIn, IntPtr pvaOut) {
            if (null == commandService) {
                return (int)OleConstants.OLECMDERR_E_NOTSUPPORTED;
            }
            return ((IOleCommandTarget)commandService).Exec(ref guidCmdGroup, id, options, pvaIn, pvaOut);
        }
        #endregion


        #region IVsWindowPane methods

        /// <include file='doc\EditorView.uex' path='docs/doc[@for="SimpleEditorView.ClosePane"]/*' />
        public virtual int ClosePane() {
            return this.componentManager.FRevokeComponent(this.componentID);
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="SimpleEditorView.CreatePaneWindow"]/*' />
        public abstract int CreatePaneWindow(IntPtr hwndParent, int x, int y, int cx, int cy, out IntPtr hwnd);
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="SimpleEditorView.GetDefaultSize"]/*' />
        public virtual int GetDefaultSize(SIZE[] size) {
            size[0].cx = 100;
            size[0].cy = 100;
            return NativeMethods.S_OK;
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="SimpleEditorView.LoadViewState"]/*' />
        public virtual int LoadViewState(Microsoft.VisualStudio.OLE.Interop.IStream stream) {
            return NativeMethods.S_OK;
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="SimpleEditorView.SaveViewState"]/*' />
        public virtual int SaveViewState(Microsoft.VisualStudio.OLE.Interop.IStream stream) {
            return NativeMethods.S_OK;
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="SimpleEditorView.SetSite"]/*' />
        public virtual int SetSite(Microsoft.VisualStudio.OLE.Interop.IServiceProvider site) {
            this.site = new ServiceProvider(site);

            if (this.buffer != null) {
                // register our independent view with the IVsTextManager so that it knows
                // the user is working with a view over the text buffer. this will trigger
                // the text buffer to prompt the user whether to reload the file if it is
                // edited outside of the development Environment.
                IVsTextManager textManager = (IVsTextManager)this.site.GetService(typeof(SVsTextManager));
                int hr = 0;
                if (textManager != null) {
                    IVsWindowPane windowPane = (IVsWindowPane)this;
                    hr = textManager.RegisterIndependentView(this, this.buffer);
                    if (!NativeMethods.Succeeded(hr))
                        Debug.Assert(false, "RegisterIndependentView failed");
                }
            }

            //register with ComponentManager for Idle processing
            this.componentManager = (IOleComponentManager)this.site.GetService(typeof(SOleComponentManager));
            if (componentID == 0) {
                OLECRINFO[] crinfo = new OLECRINFO[1];

                crinfo[0].cbSize = (uint)Marshal.SizeOf(typeof(OLECRINFO));
                crinfo[0].grfcrf = (uint)_OLECRF.olecrfNeedIdleTime | (uint)_OLECRF.olecrfNeedPeriodicIdleTime | (uint)_OLECRF.olecrfNeedAllActiveNotifs | (uint)_OLECRF.olecrfNeedSpecActiveNotifs;
                crinfo[0].grfcadvf = (uint)_OLECADVF.olecadvfModal | (uint)_OLECADVF.olecadvfRedrawOff | (uint)_OLECADVF.olecadvfWarningsOff;
                crinfo[0].uIdleTimeInterval = 1000;
                int hr = this.componentManager.FRegisterComponent(this, crinfo, out this.componentID);
                if (!NativeMethods.Succeeded(hr))
                    Debug.Assert(false, "FRegisterComponent failed");
            }
            return NativeMethods.S_OK;
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="SimpleEditorView.TranslateAccelerator"]/*' />
        public virtual int TranslateAccelerator(MSG[] msg) {
            return (int)NativeMethods.S_FALSE;
        }
        #endregion 

        #region IVsToolboxUser methods
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="SimpleEditorView.IsSupported"]/*' />
        public virtual int IsSupported(Microsoft.VisualStudio.OLE.Interop.IDataObject data) {
            return (int)NativeMethods.S_FALSE;
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="SimpleEditorView.ItemPicked"]/*' />
        public virtual int ItemPicked(Microsoft.VisualStudio.OLE.Interop.IDataObject data) {
            return NativeMethods.S_OK;
        }
        #endregion

        #region IVsStatusbarUser methods
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="SimpleEditorView.SetInfo"]/*' />
        public virtual int SetInfo() {
            return NativeMethods.S_OK;
        }
        #endregion

            #region IVsWindowPaneCommit methods
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="SimpleEditorView.CommitPendingEdit"]/*' />
        public virtual int CommitPendingEdit(out int fCommitFailed) {
            fCommitFailed = 0;
            return NativeMethods.S_OK;
        }
            #endregion

            #region IOleComponent Methods
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="SimpleEditorView.FDoIdle"]/*' />
        public virtual int FDoIdle(uint grfidlef) {
            return 0;
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="SimpleEditorView.Terminate"]/*' />
        public virtual void Terminate() {
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="SimpleEditorView.FPreTranslateMessage"]/*' />
        public virtual int FPreTranslateMessage(MSG[] msg) {
            return 0;
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="SimpleEditorView.OnEnterState"]/*' />
        public virtual void OnEnterState(uint uStateID, int fEnter) {
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="SimpleEditorView.OnAppActivate"]/*' />
        public virtual void OnAppActivate(int fActive, uint dwOtherThreadID) {
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="SimpleEditorView.OnLoseActivation"]/*' />
        public virtual void OnLoseActivation() {
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="SimpleEditorView.OnActivationChange"]/*' />
        public virtual void OnActivationChange(Microsoft.VisualStudio.OLE.Interop.IOleComponent pic, int fSameComponent, OLECRINFO[] pcrinfo, int fHostIsActivating, OLECHOSTINFO[] pchostinfo, uint dwReserved) {
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="SimpleEditorView.FContinueMessageLoop"]/*' />
        public virtual int FContinueMessageLoop(uint uReason, IntPtr pvLoopData, MSG[] pMsgPeeked) {
            return 1;
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="SimpleEditorView.FQueryTerminate"]/*' />
        public virtual int FQueryTerminate(int fPromptUser) {
            return 1;
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="SimpleEditorView.HwndGetWindow"]/*' />
        public virtual IntPtr HwndGetWindow(uint dwWhich, uint dwReserved) {
            return IntPtr.Zero;
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="SimpleEditorView.FReserved1"]/*' />
        public virtual int FReserved1(uint reserved, uint message, IntPtr wParam, IntPtr lParam) {
            return 1;
        }
            #endregion 
    }

#if CUT

    /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView"]/*' />
    /// <summary>
    /// This class View provides an abstract base class for custom editor views that
    /// support Ole Inplace activation (ActiveX controls).
    /// </summary>
    [CLSCompliant(false)]
    [System.Runtime.InteropServices.ComVisible(true)]
    public abstract class OleEditorView : SimpleEditorView, IOleCommandTarget, IVsWindowPane, IVsToolboxUser, IVsStatusbarUser, IOleObject, IOleInPlaceActiveObject, IOleInPlaceObject, IOleInPlaceComponent
        //IServiceProvider,
        //IOleDocumentView,
        //IOleDocument,
        //IOleInPlaceUIWindow,
        //IVsMultiViewDocumentView,
        //IVsFindTarget,
        //IVsWindowFrameNotify,
        //IVsCodeWindow,
        //IVsWindowPaneCommit,
        //IVsBroadcastMessageEvents,
        //IVsDocOutlineProvider,
        //IVsDebuggerEvents,
        // ??? VxDTE::IExtensibleObject,
        //IVsBackForwardNavigation
        // ??? public IVsTextLinesEvents,
        // ??? public ISelectionContainer,
        // ??? public IVsTextBufferDataEvents,
        {
        internal EventSinkCollection eventSinks = new EventSinkCollection();
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.pCompUIMgr;"]/*' />
        protected IOleComponentUIManager pCompUIMgr;
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.pIPCompSite;"]/*' />
        protected IOleInPlaceComponentSite pIPCompSite;
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.pClientSite;"]/*' />
        protected IOleClientSite pClientSite;
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.monikers"]/*' />
        protected Hashtable monikers = new Hashtable();
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.OleEditorView"]/*' />
        protected OleEditorView(IVsTextLines buffer) : base(buffer) {
        }
    
        #region IOleObject methods
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.Advise"]/*' />
        public virtual void Advise(IAdviseSink sink, out uint cookie) {
            cookie = eventSinks.Add(sink);
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.Close"]/*' />
        public virtual void Close(uint dwSaveOption) {
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.DoVerb"]/*' />
        public virtual int DoVerb(int iVerb, MSG[] msg, IOleClientSite site, int index, IntPtr hwndParent, RECT[] posRect) {
            return NativeMethods.S_OK;
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.EnumAdvise"]/*' />
        public virtual void EnumAdvise(out IEnumSTATDATA ppEnumAdvise) {
            ppEnumAdvise = null;
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.EnumVerbs"]/*' />
        public virtual int EnumVerbs(out IEnumOLEVERB ppEnumVerbs) {
            ppEnumVerbs = null;
            return NativeMethods.S_OK;
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.GetClientSite"]/*' />
        public virtual void GetClientSite(out IOleClientSite site) {
            site = this.pClientSite;
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.GetClipboardData"]/*' />
        public virtual void GetClipboardData(uint reserved, out Microsoft.VisualStudio.OLE.Interop.IDataObject obj) {
            obj = null;
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.GetExtent"]/*' />
        public virtual void GetExtent(uint dwDrawAspect, SIZEL[] size) {
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.GetMiscStatus"]/*' />
        public virtual int GetMiscStatus(uint dwAspect, out uint status) {
            status = 0;
            return NativeMethods.S_OK;
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.GetMoniker"]/*' />
        public virtual void GetMoniker(uint iAssign, uint whichMoniker, out IMoniker moniker) {
            object key = (object)whichMoniker;

            moniker = (IMoniker)monikers[key];
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.GetUserClassID"]/*' />
        public virtual void GetUserClassID(out Guid pClsid) {
            pClsid = this.GetType().GUID;
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.GetUserType"]/*' />
        public virtual int GetUserType(uint formOfType, IntPtr userType) {
            return NativeMethods.S_OK;
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.InitFromData"]/*' />
        public virtual int InitFromData(Microsoft.VisualStudio.OLE.Interop.IDataObject data, int fCreation, uint reserved) {
            return NativeMethods.S_OK;
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.IsUpToDate"]/*' />
        public virtual int IsUpToDate() {
            return NativeMethods.S_OK;
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.SetClientSite"]/*' />
        public virtual void SetClientSite(IOleClientSite site) {
            this.pClientSite = site;
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.SetColorScheme"]/*' />
        public virtual void SetColorScheme(LOGPALETTE[] logicalPalette) {
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.SetExtent"]/*' />
        public virtual void SetExtent(uint drawAspect, SIZEL[] size) {
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.SetHostNames"]/*' />
        public virtual void SetHostNames(string containerApp, string containerObj) {
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.SetMoniker"]/*' />
        public virtual void SetMoniker(uint whichMoniker, IMoniker moniker) {
            object key = (object)whichMoniker;

            if (monikers.Contains(key)) monikers.Remove(key);

            monikers.Add(key, moniker);
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.Unadvise"]/*' />
        public virtual void Unadvise(uint dwCookie) {
            eventSinks.RemoveAt(dwCookie);
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.Update"]/*' />
        public virtual int Update() {
            return NativeMethods.S_OK;
        }
        #endregion 
    

        #region IOleInPlaceActiveObject
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.EnableModeless"]/*' />
        public virtual void EnableModeless(int fEnable) {
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.OnDocWindowActivate"]/*' />
        public virtual void OnDocWindowActivate(int fActivate) {
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.OnFrameWindowActivate"]/*' />
        public virtual void OnFrameWindowActivate(int fActivate) {
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.ResizeBorder"]/*' />
        public virtual void ResizeBorder(RECT[] border, ref Guid iid, IOleInPlaceUIWindow window, int fFrameWindow) {
        }
        #endregion 



        #region IOleInPlaceObject methods
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.ContextSensitiveHelp"]/*' />
        public virtual void ContextSensitiveHelp(int fEnterHelp) {
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.GetWindow"]/*' />
        public virtual void GetWindow(out IntPtr hwnd) {
            hwnd = IntPtr.Zero;
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.InPlaceDeactivate"]/*' />
        public virtual void InPlaceDeactivate() {
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.ReactivateAndUndo"]/*' />
        public virtual void ReactivateAndUndo() {
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.SetObjectRects"]/*' />
        public virtual void SetObjectRects(RECT[] posRect, RECT[] clipRect) {
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.UIDeactivate"]/*' />
        public virtual void UIDeactivate() {
        }
        #endregion 

        #region IOleInPlaceComponent methods


        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.FQueryClose"]/*' />
        public virtual int FQueryClose(int fPromptUser) {
            return 0;
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.GetCntrContextMenu"]/*' />
        public virtual int GetCntrContextMenu(uint dwRoleActiveObject, ref Guid clsidActiveObject, int nMenuIdActiveObject, POINTS[] pos, out Guid clsidCntr, OLEMENUID[] menuid, out uint pgrf) {
            clsidCntr = Guid.Empty;
            pgrf = 0;
            return NativeMethods.S_OK;
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.GetCntrHelp"]/*' />
        public virtual int GetCntrHelp(ref uint pdwRole, ref Guid pclsid, POINT posMouse, uint dwHelpCmd, string pszHelpFileIn, out string pwsHelpFileOut, uint dwDataIn, out uint dwDataOut) {
            pwsHelpFileOut = pszHelpFileIn;
            dwDataOut = dwDataIn;
            return NativeMethods.S_OK;
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.GetCntrMessage"]/*' />
        public virtual int GetCntrMessage(ref uint pdwRolw, ref Guid clsid, string titleIn, string textIn, string helpFileIn, out string titleOut, out string textOut, out string helpFileOut, ref uint dwHelpContextId, OLEMSGBUTTON[] msgbutton, OLEMSGDEFBUTTON[] msgdefbutton, OLEMSGICON[] msgicon, ref int sysAlert) {
            titleOut = titleIn;
            textOut = textIn;
            helpFileOut = helpFileIn;
            return NativeMethods.S_OK;
        }
        void IOleInPlaceComponent.OnEnterState(uint dwStateId, int fEnter) {
            ((IOleComponent)this).OnEnterState(dwStateId, fEnter);
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.OnWindowActivate"]/*' />
        public virtual int OnWindowActivate(uint windowType, int fActivate) {
            return NativeMethods.S_OK;
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.TranslateCntrAccelerator"]/*' />
        public virtual int TranslateCntrAccelerator(MSG[] msg) {
            return NativeMethods.S_OK;
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="OleEditorView.UseComponentUIManager"]/*' />
        public virtual int UseComponentUIManager(uint dwCompRole, out uint pgrfCompFlags, IOleComponentUIManager pCompUIMgr, IOleInPlaceComponentSite pIPCompSite) {
            pgrfCompFlags = 0;
            this.pCompUIMgr = pCompUIMgr;
            this.pIPCompSite = pIPCompSite;
            return NativeMethods.S_OK;
        }
        #endregion
    }
#endif
    /// <include file='doc\EditorView.uex' path='docs/doc[@for="EditorControl"]/*' />
    /// <summary>
    /// This class wraps a managed WinForm control and uses that as the editor window.
    /// </summary>
    [CLSCompliant(false)]
    [System.Runtime.InteropServices.ComVisible(true)]
    public class EditorControl : SimpleEditorView {
        Control control;
        
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="EditorControl.EditorControl"]/*' />
        public EditorControl(IServiceProvider site, IVsTextLines buffer, Control ctrl) : base(buffer) {
            this.control = ctrl;
            this.Site = site;
        }

        /// <include file='doc\EditorView.uex' path='docs/doc[@for="EditorControl.Control;"]/*' />
        protected Control Control {
            get { return this.control; }
            set { this.control = value; }
        }

        /// <include file='doc\EditorView.uex' path='docs/doc[@for="EditorControl.ClosePane"]/*' />
        public override int ClosePane() {
            if (control != null) {
                control.Dispose();
                control = null;
            }

            return base.ClosePane();
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="EditorControl.CreatePaneWindow"]/*' />
        public override int CreatePaneWindow(IntPtr hwndParent, int x, int y, int cx, int cy, out IntPtr hwnd) {
            control.SuspendLayout();
            control.Left = x;
            control.Top = y;
            control.Width = cx;
            control.Height = cy;
            control.ResumeLayout();
            control.CreateControl();

            //For some reason VS throws debug asserts if WS_MAXIMIZEBOX is set
            //so we'll just turn off this window style here.
            int windowStyle = (int)NativeMethods.GetWindowLong(new HandleRef(control, control.Handle), NativeMethods.GWL_STYLE);
            windowStyle = windowStyle & ~(0x00010000); //WS_MAXIMIZEBOX;
            NativeMethods.SetWindowLong(this.Control.Handle, NativeMethods.GWL_STYLE, windowStyle);
            //End of workaround

            NativeMethods.SetParent(control.Handle, hwndParent);
            hwnd = control.Handle;
            return NativeMethods.S_OK;
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="EditorControl.CommitPendingEdit"]/*' />
        public override int CommitPendingEdit(out int fCommitFailed) {
            fCommitFailed = 0;
            return NativeMethods.S_OK;
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="EditorControl.FDoIdle"]/*' />
        public override int FDoIdle(uint grfidlef) {
            return 0;
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="EditorControl.OnAppActivate"]/*' />
        public override void OnAppActivate(int fActive, uint dwOtherThreadID) {
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="EditorControl.FQueryTerminate"]/*' />
        public override int FQueryTerminate(int fPromptUser) {
            return 1;
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="EditorControl.OnLoseActivation"]/*' />
        public override void OnLoseActivation() {
        }
        /// <include file='doc\EditorView.uex' path='docs/doc[@for="EditorControl.HwndGetWindow"]/*' />
        public override IntPtr HwndGetWindow(uint dwWhich, uint dwReserved) {
            return control.Handle;
        }
        
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\LanguageService100\EditorFactory.cs ===
using System;
using System.Globalization;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.TextManager.Interop;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell;
using System.Runtime.InteropServices;
using System.Collections;
using System.Collections.Specialized;
using System.IO;
using Microsoft.Win32;
using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
using IServiceProvider = System.IServiceProvider;
using System.Diagnostics;
using VSRegistry = Microsoft.VisualStudio.Shell.VSRegistry;

namespace Microsoft.VisualStudio.Package {

    /// <include file='doc\EditorFactory.uex' path='docs/doc[@for="EditorFactory"]/*' />
    /// <summary>
    /// You must inherit from this class and simply add a [ComVisible] and 
    /// [GuidAttribute] and then specify the EditorFactoryGuid, EditorFactoryGuid 
    /// and EditorName variables in your Registration class.
    /// This base class provides a default editor factory implementation
    /// that hosts the Visual Studio Core editor.  
    /// </summary>
    [CLSCompliant(false), ComVisible(true)]
    public class EditorFactory : IVsEditorFactory {
        Microsoft.VisualStudio.Shell.Package package;
        IServiceProvider site;

        /// <include file='doc\EditorFactory.uex' path='docs/doc[@for="EditorFactory.GUID_VsBufferDetectLangSID;"]/*' />
        public static readonly Guid GuidVSBufferDetectLangSid = new Guid(0x17F375AC, 0xC814, 0x11D1, 0x88, 0xAD, 0x00, 0x00, 0xF8, 0x75, 0x79, 0xD2);

        __PROMPTONLOADFLAGS promptFlags = __PROMPTONLOADFLAGS.codepageNoPrompt;

        /// <include file='doc\EditorFactory.uex' path='docs/doc[@for="EditorFactory.EditorInfo"]/*' />
        public class EditorInfo {
            private string name;
            private Guid guid;
            private int priority;
            private EditorInfo next;

            /// <include file='doc\EditorFactory.uex' path='docs/doc[@for="EditorFactory.EditorInfo.Name"]/*' />
            public string Name {
                get { return name; }
                set { name = value; }
            }

            /// <include file='doc\EditorFactory.uex' path='docs/doc[@for="EditorFactory.EditorInfo.Guid"]/*' />
            public Guid Guid {
                get { return guid; }
                set { guid = value; }
            }

            /// <include file='doc\EditorFactory.uex' path='docs/doc[@for="EditorFactory.EditorInfo.Priority"]/*' />
            public int Priority {
                get { return priority; }
                set { priority = value; }
            }

            /// <include file='doc\EditorFactory.uex' path='docs/doc[@for="EditorFactory.EditorInfo.Next"]/*' />
            public EditorInfo Next {
                get { return next; }
                set { next = value; }
            }
        }

        // all registered editors.
        static Hashtable editors;  // extension -> EditorInfo

        // Registered exenstions for this editor under HKLM\Software\Microsoft\Visual Studio\8.0\Editors\\{" + this.GetType().GUID.ToString() + "}\\Extensions
        StringDictionary editorExtensions; // string -> string

        // all known extensions under HKLM\Software\Microsoft\Visual Studio\8.0\Language Services\Extensions
        static StringDictionary languageExtensions; // string -> language service guid.

        /// <include file='doc\EditorFactory.uex' path='docs/doc[@for="EditorFactory.EditorFactory"]/*' />
        public EditorFactory(Microsoft.VisualStudio.Shell.Package package) {
            this.package = package;
            this.site = package;
        }

        /// <include file='doc\EditorFactory.uex' path='docs/doc[@for="EditorFactory.EditorFactory"]/*' />
        public EditorFactory() { }

        /// <include file='doc\EditorFactory.uex' path='docs/doc[@for="EditorFactory.Finalize"]/*' />
        ~EditorFactory() {
            site = null;
#if LANGTRACE
            Trace.WriteLine("~EditorFactory");
#endif
        }

        /// <include file='doc\EditorFactory.uex' path='docs/doc[@for="EditorFactory.GetSite"]/*' />
        protected IServiceProvider GetSite() {
            return this.site;
        }
        /// <include file='doc\EditorFactory.uex' path='docs/doc[@for="EditorFactory.GetPackage"]/*' />
        protected Microsoft.VisualStudio.Shell.Package GetPackage() {
            return this.package;
        }

        /// <include file='doc\EditorFactory.uex' path='docs/doc[@for="EditorFactory.IsRegisteredExtension"]/*' />
        /// <summary>Returns true if the given extension is one of our registered extensions</summary>
        public virtual bool IsRegisteredExtension(string extension) {
            return GetEditorExtensions().ContainsKey(extension);
        }

        /// <include file='doc\EditorFactory.uex' path='docs/doc[@for="EditorFactory.GetExtensions"]/*' />
        /// <summary>Return list of file extensions registered for this editor factory under 
        /// HKLM\Software\Microsoft\Visual Studio\8.0\Editors\\{" + this.GetType().GUID.ToString() + "}\\Extensions
        /// </summary>
        public virtual string[] GetExtensions() {
            ArrayList list = new ArrayList(this.GetEditorExtensions().Keys);
            return (string[])list.ToArray(typeof(string));
        }

        /// <include file='doc\EditorFactory.uex' path='docs/doc[@for="EditorFactory.GetLanguageService"]/*' />
        /// <summary>Returns the guid of the language service registered for this file extension
        /// HKLM\Software\Microsoft\Visual Studio\8.0\Language Services\Extensions</summary>
        public virtual string GetLanguageService(string fileExtension) {
            return GetLanguageExtensions(this.site)[fileExtension] as string;
        }

        /// <include file='doc\EditorFactory.uex' path='docs/doc[@for="EditorFactory.WithEncoding"]/*' />
        public virtual __PROMPTONLOADFLAGS CodePagePrompt {
            get { return this.promptFlags; }
            set { this.promptFlags = value; }
        }

        bool CheckAllFileTypes() {
            return GetEditorExtensions().ContainsKey("*");
        }

        // Return your language service Guid here, this is used to set the language service on the 
        // IVsTextLines buffer returned from CreateEditorInstance.
        /// <include file='doc\EditorFactory.uex' path='docs/doc[@for="EditorFactory.GetLanguageServiceGuid"]/*' />
        public virtual Guid GetLanguageServiceGuid() {
            return Guid.Empty;
        }

        /// <include file='doc\EditorFactory.uex' path='docs/doc[@for="EditorFactory.GetRegisteredEditor"]/*' />
        /// <summary>Returns the guid of the highest priority editor registered for this extension.
        /// This will also pick up user defined file extension to editor associations</summary>
        public virtual Guid GetRegisteredEditor(string extension) {
            EditorInfo ei = GetRegisteredEditorInfo(extension);
            if (ei != null) {
                return ei.Guid;
            }
            return Guid.Empty;
        }

        /// <include file='doc\EditorFactory.uex' path='docs/doc[@for="EditorFactory.GetRegisteredEditor"]/*' />
        /// <summary>Returns the guid of the highest priority editor registered for this extension.
        /// This will also pick up user defined file extension to editor associations.
        /// You can then access all registered editors via the .Next property.</summary>
        public virtual EditorInfo GetRegisteredEditorInfo(string extension) {
            string key = extension.ToUpperInvariant();
            return (EditorInfo)GetEditors(this.site)[key];
        }

        /// <include file='doc\EditorFactory.uex' path='docs/doc[@for="EditorFactory.GetUserDefinedEditor"]/*' />
        /// <summary>Returns the guid of the editor that the user has defined for this file extension or
        /// Guid.Empty if none is found</summary>
        public Guid GetUserDefinedEditor(string extension) {
            StringDictionary map = this.GetFileExtensionMappings();
            object v = map[extension];
            if (v != null) {
                return GetGuid(v.ToString());
            }
            return Guid.Empty;
        }

        /// <summary>Returns true if the file extension is one that you registered for this editor
        /// factory, or your have registered the "*" extension and (this file type matches your 
        /// GetLanguageServiceGuid() or there is no other language service registered for this file extension).</summary>
        bool IsFileExtensionWeShouldEditAnyway(string ext) {

            if (!this.CheckAllFileTypes())
                return false;// you did not register "*".

            Guid langSid = GetLanguageServiceGuid();

            string guid = this.GetLanguageService(ext);
            if (!string.IsNullOrEmpty(guid)) {
                // There is a language service associated with this file extension, see if it is ours or not.
                if (GetGuid(guid) != langSid) {
                    // Then it is not our extension.
                    return false;
                }
            }
            return true;
        }

        static Guid GetGuid(string value) {
            // we want to ignore badly registered guids.
            try {
                Guid guid = new Guid(value);
                return guid;
            } catch (FormatException) {
                // ignore badly registered file extensions
                return Guid.Empty;
            }
        }

        /// <include file='doc\EditorFactory.uex' path='docs/doc[@for="EditorFactory.IsOurFileFormat"]/*' />
        // This method is called when the user has not explicitly requested your editor
        // and if the file extension doesn't match an explicit extension you registered,
        // and if you have registered the extension "*" to determine if this file is 
        // really something you want to take over or not.  If you return false then VS
        // will find the next best editor in the list.
        public virtual bool IsOurFileFormat(string moniker) {
            return true;
        }

        #region IVsEditorFactory

        /// <include file='doc\EditorFactory.uex' path='docs/doc[@for="EditorFactory.CreateEditorInstance"]/*' />
        /// <summary>
        /// This method checks to see if the specified file is one that your editor supports
        /// and if so, creates the core text editor and associated your language service 
        /// with it.  To figure out if the file is one that your editor supports it performs
        /// the following check:
        /// <list>
        /// <item>
        /// Call IsRegisteredExtension to see if the file extension is explicitly 
        /// registered to your editor.      
        /// </item>
        /// <item>
        /// Call GetUserDefinedEditor to see if the user has explicitly mapped the
        /// extension to your editor.
        /// </item>
        /// <item>
        /// If your editor registered the "*" extension, then it also calls 
        /// IsFileExtensionWeShouldEditAnyway and IsOurFileFormat to let you sniff
        /// the file and see if you think it contains stuff that your editor recognizes
        /// </item>
        /// </list>
        /// If all this is true then it goes ahead with the next step which is to
        /// get an IVsTextLines buffer and set it up as follows:
        /// <list>
        /// <item>
        /// If existingDocData is non-null then it checks to see if it can get an
        /// IVsTextLines buffer from this docData, and if not, returns VS_E_INCOMPATIBLEDOCDATA.
        /// Otherwise it creates a new VsTextBufferClass.
        /// </item>
        /// Calls IVsUserData.SetData on the IVsTextLines buffer with any code page prompt
        /// flags you have provided via the CodePagePrompt property.
        /// </list>
        /// <list>
        /// Calls SetLanguageServiceID to pass in your language service Guid and 
        /// sets the GuidVSBufferDetectLangSid IVsUserData to false to stop the core
        /// text editor from looking up a different language service.
        /// </list>
        /// Lastly it calls CreateEditorView to create the docView.
        /// </summary>
        public virtual int CreateEditorInstance(uint createDocFlags, string moniker, string physicalView, IVsHierarchy pHier, uint itemid, IntPtr existingDocData, out IntPtr docView, out IntPtr docData, out string editorCaption, out Guid cmdUI, out int cancelled) {
            docView = IntPtr.Zero;
            docData = IntPtr.Zero;
            editorCaption = null;
            cmdUI = Guid.Empty;
            cancelled = 0;
            int hr = NativeMethods.S_OK;

            if (this.promptFlags == __PROMPTONLOADFLAGS.codepagePrompt && existingDocData != IntPtr.Zero) {
                //since we are trying to open with encoding just return
                hr = (int)NativeMethods.VS_E_INCOMPATIBLEDOCDATA;
                goto cleanup;
            }

            bool takeover = false;
            if (!string.IsNullOrEmpty(moniker)) {
                string ext = FilePathUtilities.GetFileExtension(moniker);
                docData = IntPtr.Zero;
                docView = IntPtr.Zero;
                editorCaption = null;

                bool openSpecific = (createDocFlags & (uint)__VSCREATEEDITORFLAGS2.CEF_OPENSPECIFIC) != 0;

                bool isOurs = IsRegisteredExtension(ext);
                bool isUserDefined = (GetUserDefinedEditor(ext) == this.GetType().GUID);

                // If this file extension belongs to a different language service, then we should not open it,
                // unless the user specifically requested our editor in the Open With... dialog.
                if (!isOurs && !isUserDefined && !this.IsFileExtensionWeShouldEditAnyway(ext) && !openSpecific) {
                    return (int)NativeMethods.VS_E_UNSUPPORTEDFORMAT;
                }

                takeover = (CheckAllFileTypes() && !isOurs);
                if (takeover && !isOurs && !isUserDefined && !openSpecific) {
                    if (!IsOurFileFormat(moniker)) {
                        return (int)NativeMethods.VS_E_UNSUPPORTEDFORMAT;
                    }
                }
            }

            IVsTextLines buffer = null;
            if (existingDocData != IntPtr.Zero) {
                object dataObject = Marshal.GetObjectForIUnknown(existingDocData);
                buffer = dataObject as IVsTextLines;
                if (buffer == null) {
                    IVsTextBufferProvider bp = dataObject as IVsTextBufferProvider;
                    if (bp != null) {
                        NativeMethods.ThrowOnFailure(bp.GetTextBuffer(out buffer));
                    }
                }
                if (buffer == null) {
                    // unknown docData type then, so we have to force VS to close the other editor.
                    hr = (int)NativeMethods.VS_E_INCOMPATIBLEDOCDATA;
                    goto cleanup;
                }

            } else {
                // Create a new IVsTextLines buffer.
                Type textLinesType = typeof(IVsTextLines);
                Guid riid = textLinesType.GUID;
                Guid clsid = typeof(VsTextBufferClass).GUID;
                buffer = (IVsTextLines)package.CreateInstance(ref clsid, ref riid, textLinesType);
                if (!string.IsNullOrEmpty(moniker)) {
                    IVsUserData iud = buffer as IVsUserData;
                    if (iud != null) {
                        Guid GUID_VsBufferMoniker = typeof(IVsUserData).GUID;
                        // Must be set in time for language service GetColorizer call in case the colorizer
                        // is file name dependent.
                        NativeMethods.ThrowOnFailure(iud.SetData(ref GUID_VsBufferMoniker, moniker));
                    }
                }
                IObjectWithSite ows = buffer as IObjectWithSite;
                if (ows != null) {
                    ows.SetSite(this.site.GetService(typeof(IOleServiceProvider)));
                }
            }

            if (this.promptFlags == __PROMPTONLOADFLAGS.codepagePrompt && buffer is IVsUserData) {
                IVsUserData iud = (IVsUserData)buffer;
                Guid GUID_VsBufferEncodingPromptOnLoad = new Guid(0x99ec03f0, 0xc843, 0x4c09, 0xbe, 0x74, 0xcd, 0xca, 0x51, 0x58, 0xd3, 0x6c);
                NativeMethods.ThrowOnFailure(iud.SetData(ref GUID_VsBufferEncodingPromptOnLoad, (uint)this.CodePagePrompt));
            }

            Guid langSid = GetLanguageServiceGuid();
            if (langSid != Guid.Empty) {
                Guid vsCoreSid = new Guid("{8239bec4-ee87-11d0-8c98-00c04fc2ab22}");
                Guid currentSid;
                NativeMethods.ThrowOnFailure(buffer.GetLanguageServiceID(out currentSid));
                // If the language service is set to the default SID, then
                // set it to our language
                if (currentSid == vsCoreSid) {
                    NativeMethods.ThrowOnFailure(buffer.SetLanguageServiceID(ref langSid));
                } else if (currentSid != langSid) {
                    // Some other language service has it, so return VS_E_INCOMPATIBLEDOCDATA
                    hr = (int)NativeMethods.VS_E_INCOMPATIBLEDOCDATA;
                    goto cleanup;
                }

                takeover = true;
            }

            if (takeover) {
                IVsUserData vud = (IVsUserData)buffer;
                Guid bufferDetectLang = GuidVSBufferDetectLangSid;
                NativeMethods.ThrowOnFailure(vud.SetData(ref bufferDetectLang, false));
            }

            if (existingDocData != IntPtr.Zero) {
                docData = existingDocData;
                Marshal.AddRef(docData);
            } else {
                docData = Marshal.GetIUnknownForObject(buffer);                
            }
            docView = CreateEditorView(moniker, buffer, physicalView, out editorCaption, out cmdUI);

            if (docView == IntPtr.Zero) {
                // We couldn't create the view, so return this special error code so
                // VS can try another editor factory.
                hr = (int)NativeMethods.VS_E_UNSUPPORTEDFORMAT;
            }

        cleanup:
            if (docView == IntPtr.Zero) {
                if (existingDocData != docData && docData != IntPtr.Zero) {
                    Marshal.Release(docData);
                    docData = IntPtr.Zero;
                }
            }
            return hr;
        }

        /// <include file='doc\EditorFactory.uex' path='docs/doc[@for="EditorFactory.CreateEditorView"]/*' />
        /// <summary>Return docView IUnknown COM object.</summary>
        public virtual IntPtr CreateEditorView(string moniker, IVsTextLines buffer, string physicalView, out string editorCaption, out Guid cmdUI) {
            Type tcw = typeof(IVsCodeWindow);
            Guid riid = tcw.GUID;
            // Once this is done the project's assembly reference to "$(EnvRefPath)\Microsoft.VisualStudio.Editor.dll" may be removed
            Guid clsid = typeof(VsCodeWindowClass).GUID;
            IntPtr docView = IntPtr.Zero;
            IVsCodeWindow window = (IVsCodeWindow)package.CreateInstance(ref clsid, ref riid, tcw);

            NativeMethods.ThrowOnFailure(window.SetBuffer(buffer));
            NativeMethods.ThrowOnFailure(window.SetBaseEditorCaption(null));
            NativeMethods.ThrowOnFailure(window.GetEditorCaption(READONLYSTATUS.ROSTATUS_Unknown, out editorCaption));

            Guid CMDUIGUID_TextEditor = new Guid(0x8B382828, 0x6202, 0x11d1, 0x88, 0x70, 0x00, 0x00, 0xF8, 0x75, 0x79, 0xD2);
            cmdUI = CMDUIGUID_TextEditor;
            docView = Marshal.GetIUnknownForObject(window);

            return docView;
        }

        /// <include file='doc\EditorFactory.uex' path='docs/doc[@for="EditorFactory.MapLogicalView"]/*' />
        /// <devdoc>The default implementation supports LOGVIEWID_Code, LOGVIEWID_TextView,
        /// LOGVIEWID_Debugging, and LOGVIEWID_Primary returning null for
        /// the physicalView string.</devdoc>
        public virtual int MapLogicalView(ref Guid logicalView, out string physicalView) {
            physicalView = null;
            // The default suppo
            if (logicalView == NativeMethods.LOGVIEWID_Code ||
                logicalView == NativeMethods.LOGVIEWID_TextView ||
                logicalView == NativeMethods.LOGVIEWID_Debugging ||
                logicalView == NativeMethods.LOGVIEWID_Primary) {
                physicalView = null;
                return NativeMethods.S_OK;
            }
            return NativeMethods.E_NOTIMPL;
        }

        /// <include file='doc\EditorFactory.uex' path='docs/doc[@for="EditorFactory.SetSite"]/*' />
        public virtual int SetSite(Microsoft.VisualStudio.OLE.Interop.IServiceProvider psp) {
            this.site = new ServiceProvider(psp);
            return NativeMethods.S_OK;
        }

        StringDictionary GetEditorExtensions() {
            if (this.editorExtensions != null)
                return this.editorExtensions;

            Guid ourGuid = this.GetType().GUID;
            StringDictionary map = new StringDictionary();
            Hashtable editors = GetEditors(this.site);
            foreach (string ext in editors.Keys) {
                EditorInfo ei = (EditorInfo)editors[ext];
                while (ei != null) {
                    if (ei.Guid == ourGuid) {
                        map[ext] = ext;
                        break;
                    }
                    ei = ei.Next;
                }
            }
            return this.editorExtensions = map;
        }

        static StringDictionary GetLanguageExtensions(IServiceProvider site) {
            if (EditorFactory.languageExtensions != null)
                return EditorFactory.languageExtensions;

            StringDictionary extensions = new StringDictionary();
            using (RegistryKey rootKey = VSRegistry.RegistryRoot(__VsLocalRegistryType.RegType_Configuration)) {
                if (rootKey != null) {

                    string relpath = "Languages\\File Extensions";
                    using (RegistryKey key = rootKey.OpenSubKey(relpath, false)) {
                        if (key != null) {
                            foreach (string ext in key.GetSubKeyNames()) {
                                using (RegistryKey extkey = key.OpenSubKey(ext, false)) {
                                    if (extkey != null) {
                                        string fe = ext;
                                        string guid = extkey.GetValue(null) as string; // get default value
                                        if (!extensions.ContainsKey(fe)) {
                                            extensions.Add(fe, guid);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return EditorFactory.languageExtensions = extensions;
        }

        static Hashtable GetEditors(IServiceProvider site) {
            if (EditorFactory.editors != null)
                return EditorFactory.editors;

            Hashtable editors = new Hashtable();
            using (RegistryKey rootKey = VSRegistry.RegistryRoot(__VsLocalRegistryType.RegType_Configuration)) {
                if (rootKey != null) {
                    RegistryKey editorsKey = rootKey.OpenSubKey("Editors", false);
                    if (editorsKey != null) {
                        using (editorsKey) {
                            foreach (string editorGuid in editorsKey.GetSubKeyNames()) {
                                Guid guid = GetGuid(editorGuid);
                                using (RegistryKey editorKey = editorsKey.OpenSubKey(editorGuid, false)) {
                                    object value = editorKey.GetValue(null);
                                    string name = (value != null) ? value.ToString() : editorGuid.ToString();
                                    RegistryKey extensions = editorKey.OpenSubKey("Extensions", false);
                                    if (extensions != null) {
                                        foreach (string s in extensions.GetValueNames()) {
                                            if (!string.IsNullOrEmpty(s)) {
                                                EditorInfo ei = new EditorInfo();
                                                ei.Name = name;
                                                ei.Guid = guid;
                                                object obj = extensions.GetValue(s);
                                                if (obj is int) {
                                                    ei.Priority = (int)obj;
                                                }
                                                string ext = (s == "*") ? s : "." + s;
                                                AddEditorInfo(editors, ext, ei);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return EditorFactory.editors = editors;
        }

        static void AddEditorInfo(Hashtable editors, string ext, EditorInfo ei) {
            ext = ext.ToUpperInvariant();
            EditorInfo other = (EditorInfo)editors[ext];
            if (other != null) {
                EditorInfo previous = null;
                while (other != null && other.Priority > ei.Priority) {
                    previous = other;
                    other = other.Next;
                }
                if (previous == null) {
                    editors[ext] = ei;
                    ei.Next = other;
                } else {
                    ei.Next = previous.Next;
                    previous.Next = ei;
                }
            } else {
                editors[ext] = ei;
            }
        }

        StringDictionary GetFileExtensionMappings() {
            StringDictionary map = new StringDictionary();
            using (RegistryKey settings = package.UserRegistryRoot) {
                RegistryKey key = settings.OpenSubKey("Default Editors", false);
                if (key != null) {
                    using (key) {
                        foreach (string name in key.GetSubKeyNames()) {
                            using (RegistryKey extkey = key.OpenSubKey(name, false)) {
                                if (extkey != null) {
                                    object obj = extkey.GetValue("Custom");
                                    if (obj is string) {
                                        string ext = "." + name;
                                        map[ext] = obj.ToString(); // extension -> editor.
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return map;
        }

        /// <include file='doc\EditorFactory.uex' path='docs/doc[@for="EditorFactory.Close"]/*' />
        public virtual int Close() {
            this.site = null;
            this.package = null;
            return NativeMethods.S_OK;
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\LanguageService100\Scanner.cs ===
using System;

namespace Microsoft.VisualStudio.Package {
    /// <include file='doc\Scanner.uex' path='docs/doc[@for="IScanner"]/*' />
    /// <summary>
    /// Scans individual source lines and provides coloring and trigger information about tokens.
    /// </summary>
    public interface IScanner {
        /// <include file='doc\Scanner.uex' path='docs/doc[@for="IScanner.SetSource"]/*' />
        /// <summary>
        /// Used to (re)initialize the scanner before scanning a small portion of text, such as single source line for syntax coloring purposes
        /// </summary>
        /// <param name="source">The source text portion to be scanned</param>
        /// <param name="offset">The index of the first character to be scanned</param>
        void SetSource(string source, int offset);

        /// <include file='doc\Scanner.uex' path='docs/doc[@for="IScanner.ScanTokenAndProvideInfoAboutIt"]/*' />
        /// <summary>
        /// Scan the next token and fill in syntax coloring details about it in tokenInfo.
        /// </summary>
        /// <param name="tokenInfo">Keeps information about token.</param>
        /// <param name="state">Keeps track of scanner state. In: state after last token. Out: state after current token.</param>
        /// <returns></returns>
        bool ScanTokenAndProvideInfoAboutIt(TokenInfo tokenInfo, ref int state);
    }
    /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenColor"]/*' />
    public enum TokenColor {
        /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenColor.Text"]/*' />
        Text,
        /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenColor.Keyword"]/*' />
        Keyword,
        /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenColor.Comment"]/*' />
        Comment,
        /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenColor.Identifier"]/*' />
        Identifier,
        /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenColor.String"]/*' />
        String,
        /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenColor.Number"]/*' />
        Number
    }
    /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenInfo"]/*' />
    public class TokenInfo {
        int startIndex;
        int endIndex;
        TokenColor color;
        TokenType type;
        TokenTriggers trigger;
        int token;

        /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenInfo.StartIndex;"]/*' />
        public int StartIndex {
            get { return this.startIndex; }
            set { this.startIndex = value; }
        }
        /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenInfo.EndIndex;"]/*' />
        public int EndIndex {
            get { return this.endIndex; }
            set { this.endIndex = value; }
        }
        /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenInfo.Color;"]/*' />
        public TokenColor Color {
            get { return this.color; }
            set { this.color = value; }
        }
        /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenInfo.Type;"]/*' />
        public TokenType Type {
            get { return this.type; }
            set { this.type = value; }
        }
        /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenInfo.Trigger;"]/*' />
        public TokenTriggers Trigger {
            get { return this.trigger; }
            set { this.trigger = value; }
        }

        /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenInfo.StartIndex;"]/*' />
        /// <summary>Language Specific</summary>
        public int Token {
            get { return token; }
            set { token = value; }
        }
        
        /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenInfo.TokenInfo"]/*' />
        public TokenInfo() { }
        /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenInfo.TokenInfo1"]/*' />
        public TokenInfo(int startIndex, int endIndex, TokenType type) { this.startIndex = startIndex; this.endIndex = endIndex; this.type = type; }
    }

    /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenTriggers"]/*' />
    /// <summary>
    /// TokenTriggers:
    /// If a character has (a) trigger(s) associated with it, it may
    /// fire one or both of the following triggers:
    /// MemberSelect - a member selection tip window
    /// MatchBraces - highlight matching braces
    /// or the following trigger:
    /// MethodTip - a method tip window
    ///     
    /// The following triggers exist for speed reasons: the (fast) lexer 
    /// determines when a (slow) parse might be needed. 
    /// The Trigger.MethodTip trigger is subdivided in 4 
    /// other triggers. It is the best to be as specific as possible;
    /// it is better to return Trigger.ParamStart than Trigger.Param
    /// (or Trigger.MethodTip) 
    /// </summary>
    [FlagsAttribute]
    public enum TokenTriggers {
        /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenTriggers.None"]/*' />
        None = 0x00,
        /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenTriggers.MemberSelect"]/*' />
        MemberSelect = 0x01,
        /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenTriggers.MatchBraces"]/*' />
        MatchBraces = 0x02,
        /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenTriggers.MethodTip"]/*' />
        MethodTip = 0xF0,
        /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenTriggers.ParamStart"]/*' />
        ParameterStart = 0x10,
        /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenTriggers.ParamNext"]/*' />
        ParameterNext = 0x20,
        /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenTriggers.ParamEnd"]/*' />
        ParameterEnd = 0x40,
        /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenTriggers.Param"]/*' />
        Parameter = 0x80
    }

    /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenType"]/*' />
    public enum TokenType {
        /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenType.Unknown"]/*' />
        Unknown,
        /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenType.Text"]/*' />
        Text,
        /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenType.Keyword"]/*' />
        Keyword,
        /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenType.Identifier"]/*' />
        Identifier,
        /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenType.String"]/*' />
        String,
        /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenType.Literal"]/*' />
        Literal,
        /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenType.Operator"]/*' />
        Operator,
        /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenType.Delimiter"]/*' />
        Delimiter,
        /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenType.WhiteSpace"]/*' />
        WhiteSpace,
        /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenType.LineComment"]/*' />
        LineComment,
        /// <include file='doc\Scanner.uex' path='docs/doc[@for="TokenType.Comment"]/*' />
        Comment,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\LanguageService100\Preferences.cs ===
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.TextManager.Interop;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.Designer.Interfaces;
using Microsoft.VisualStudio.Shell;
using Microsoft.Win32;
using System;
using System.Collections;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using Microsoft.VisualStudio;
using System.Globalization;
using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
using IServiceProvider = System.IServiceProvider;
using VSRegistry = Microsoft.VisualStudio.Shell.VSRegistry;

namespace Microsoft.VisualStudio.Package {
    /// <include file='doc\Utilities.uex' path='docs/doc[@for="IndentingStyle"]/*' />
    public enum IndentingStyle {
        /// <include file='doc\Utilities.uex' path='docs/doc[@for="IndentingStyle.None"]/*' />
        None,
        /// <include file='doc\Utilities.uex' path='docs/doc[@for="IndentingStyle.Block"]/*' />
        Block,
        /// <include file='doc\Utilities.uex' path='docs/doc[@for="IndentingStyle.Smart"]/*' />
        Smart
    }

    /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences"]/*' />
    /// <summary>
    /// LanguagePreferences encapsulates the standard General and Tab settings for a language service
    /// and provides a way of getting and setting the values.  It is expected that you
    /// will have one global LanguagePreferences created by your package.  The General and Tabs
    /// settings are automatically persisted in .vssettings files by the core editor package.
    /// All you need to do is register your language under AutomationProperties/TextEditor
    /// and specify:
    /// <code>
    ///  YourLanguage = s '%YourLocalizedName%'
    ///  {
    ///     val Name = s 'YourLanguage'
    ///     val Package = s '{F5E7E720-1401-11D1-883B-0000F87579D2}'
    ///     val ProfileSave = d 1
    ///     val ResourcePackage = s '%YourPackage%'
    ///  }
    /// </code>
    /// Therefore this class hides all it's properties from user setting persistence using
    /// DesignerSerializationVisibility.Hidden.  This is so that if you give this object
    /// to the Package.ExportSettings method as the AutomationObject then it will only
    /// write out your new settings which is what you want, otherwise the General and Tab
    /// settings will appear in two places in the .vsssettings file.
    /// </summary>
    [CLSCompliant(false),ComVisible(true), Guid("934a92fd-b63a-49c7-9284-11aec8c1e03f")]
    public class LanguagePreferences : IVsTextManagerEvents2, IDisposable {
        IServiceProvider site;
        Guid langSvc;
        LANGPREFERENCES2 prefs;
        NativeMethods.ConnectionPointCookie connection;
        bool enableCodeSense;
        bool enableMatchBraces;
        bool enableQuickInfo;
        bool enableShowMatchingBrace;
        bool enableMatchBracesAtCaret;
        bool enableFormatSelection;
        bool enableCommenting;
        int maxErrorMessages;
        int codeSenseDelay;
        bool enableAsyncCompletion;
        bool autoOutlining;
        int maxRegionTime;
        _HighlightMatchingBraceFlags braceFlags;
        string name;
        
        /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.LanguagePreferences"]/*' />
        /// <summary>
        /// Gets the language preferences.
        /// </summary>
        public LanguagePreferences(IServiceProvider site, Guid langSvc, string name) {
            this.site = site;
            this.langSvc = langSvc;
            this.name = name;
        }

        /// <include file='doc\Preferences.uex' path='docs/doc[@for="LanguagePreferences.LanguagePreferences1"]/*' />
        public LanguagePreferences() { }

        /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.LanguageName;"]/*' />
        protected string LanguageName {
            get { return this.name; }
            set { this.name = value; }
        }

        /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.Site;"]/*' />
        /// <summary>
        /// This property is not public for a reason. If it were public it would
        /// get called during LoadSettingsFromStorage which will break it.  
        /// Instead use GetSite().
        /// </summary>
        protected IServiceProvider Site {
            get { return this.site; }
            set { this.site = value; }
        }

        /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.Site;"]/*' />
        public IServiceProvider GetSite() {
            return this.site;
        }

        // Our base language service perferences (from Babel originally)
        /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.EnableCodeSense;"]/*' />
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool EnableCodeSense {
            get { return this.enableCodeSense; }
            set { this.enableCodeSense = value; }
        }

        /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.EnableMatchBraces;"]/*' />
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool EnableMatchBraces {
            get {
                return this.enableMatchBraces; }
            set { this.enableMatchBraces = value; }
        }

        /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.EnableQuickInfo;"]/*' />
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool EnableQuickInfo {
            get { return this.enableQuickInfo; }
            set { this.enableQuickInfo = value; }
        }

        /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.EnableShowMatchingBrace;"]/*' />
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool EnableShowMatchingBrace {
            get { return this.enableShowMatchingBrace; }
            set { this.enableShowMatchingBrace = value; }
        }

        /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.EnableMatchBracesAtCaret;"]/*' />
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool EnableMatchBracesAtCaret {
            get { return this.enableMatchBracesAtCaret; }
            set { this.enableMatchBracesAtCaret = value; }
        }

        /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.MaxErrorMessages;"]/*' />
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public int MaxErrorMessages {
            get { return this.maxErrorMessages; }
            set { this.maxErrorMessages = value; }
        }

        /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.CodeSenseDelay;"]/*' />
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public int CodeSenseDelay {
            get { return this.codeSenseDelay; }
            set { this.codeSenseDelay = value; }
        }

        /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.EnableAsyncCompletion;"]/*' />
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool EnableAsyncCompletion {
            get { return this.enableAsyncCompletion; }
            set { this.enableAsyncCompletion = value; }
        }

        /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.EnableFormatSelection;"]/*' />
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool EnableFormatSelection {
            get { return this.enableFormatSelection; }
            set { this.enableFormatSelection = value; }
        }

        /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.EnableCommenting;"]/*' />
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool EnableCommenting {
            get { return this.enableCommenting; }
            set { this.enableCommenting = value; }
        }

        /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.MaxRegionTime;"]/*' />
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public int MaxRegionTime {
            get { return this.maxRegionTime; }
            set { this.maxRegionTime = value; }
        }

        /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.HighlightMatchingBraceFlags;"]/*' />
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public _HighlightMatchingBraceFlags HighlightMatchingBraceFlags {
            get { return this.braceFlags; }
            set { this.braceFlags = value; }
        }

        /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.Init"]/*' />
        public virtual void Init() {
            using (RegistryKey key = VSRegistry.RegistryRoot(__VsLocalRegistryType.RegType_Configuration)) {
                if (key != null) {
                    InitMachinePreferences(key, name);
                }
            }
            using (RegistryKey key = VSRegistry.RegistryRoot(__VsLocalRegistryType.RegType_UserSettings)) {
                if (key != null) {
                    InitUserPreferences(key, name);
                }
            }
            Connect();
        }

        /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.InitUserPreferences"]/*' />
        public virtual void InitUserPreferences(RegistryKey key, string name) {
            this.GetLanguagePreferences();
        }
		/// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.GetIntegerValue"]/*' />
		public int GetIntegerValue(RegistryKey key, string name, int def) {
			object o = key.GetValue(name);
			if (o is int) return (int)o;
            int result;
            if (o is string && int.TryParse((string)o,NumberStyles.Integer, CultureInfo.InvariantCulture, out result))
                return result;
            return def;
		}
		/// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.GetBooleanValue"]/*' />
		public bool GetBooleanValue(RegistryKey key, string name, bool def) {
			object o = key.GetValue(name);
			if (o is int) return ((int)o != 0);
            bool result;
            if (o is string && bool.TryParse((string)o,out result))
                return result;
            return def; 
		}
		
        /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.InitMachinePreferences"]/*' />
        public virtual void InitMachinePreferences(RegistryKey key, string name)
        {
            using (RegistryKey keyLanguage = key.OpenSubKey("languages\\language services\\" + name, false))
            {
                if (keyLanguage != null) {
                    this.EnableCodeSense = GetBooleanValue(keyLanguage, "CodeSense", true);
                    this.EnableMatchBraces = GetBooleanValue(keyLanguage, "MatchBraces", true);
                    this.EnableQuickInfo = GetBooleanValue(keyLanguage, "QuickInfo", true);
                    this.EnableShowMatchingBrace = GetBooleanValue(keyLanguage, "ShowMatchingBrace", true);
                    this.EnableMatchBracesAtCaret = GetBooleanValue(keyLanguage, "MatchBracesAtCaret", true);
                    this.MaxErrorMessages = GetIntegerValue(keyLanguage, "MaxErrorMessages", 10);
                    this.CodeSenseDelay = GetIntegerValue(keyLanguage, "CodeSenseDelay", 1000);
                    this.EnableAsyncCompletion = GetBooleanValue(keyLanguage, "EnableAsyncCompletion", true);
                    this.EnableFormatSelection = GetBooleanValue(keyLanguage, "EnableFormatSelection", false);
                    this.EnableCommenting = GetBooleanValue(keyLanguage, "EnableCommenting", true);
                    this.AutoOutlining = GetBooleanValue(keyLanguage, "AutoOutlining", true);
                    this.MaxRegionTime = GetIntegerValue(keyLanguage, "MaxRegionTime", 2000); // 2 seconds
                    this.braceFlags = (_HighlightMatchingBraceFlags)GetIntegerValue(keyLanguage, "HighlightMatchingBraceFlags", (int)_HighlightMatchingBraceFlags.HMB_USERECTANGLEBRACES);
                }
            }
        }

        /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.Dispose"]/*' />
        public virtual void Dispose() {
            Disconnect();
            site = null;
        }

        // General tab
        /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.AutoListMembers"]/*' />
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool AutoListMembers {
            get { return prefs.fAutoListMembers != 0; }
            set { prefs.fAutoListMembers = (uint)(value ? 1 : 0); }
        }

        /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.HideAdvancedMembers"]/*' />
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool HideAdvancedMembers {
            get { return prefs.fHideAdvancedAutoListMembers != 0; }
            set { prefs.fHideAdvancedAutoListMembers = (uint)(value ? 1 : 0); }
        }

        /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.ParameterInformation"]/*' />
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool ParameterInformation {
            get { return prefs.fAutoListParams != 0; }
            set { prefs.fAutoListParams = (uint)(value ? 1 : 0); }
        }

        /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.VirtualSpace"]/*' />
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool VirtualSpace {
            get { return prefs.fVirtualSpace != 0; }
            set { prefs.fVirtualSpace = (uint)(value ? 1 : 0); }
        }

        /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.WordWrap"]/*' />
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool WordWrap {
            get { return prefs.fWordWrap != 0; }
            set { prefs.fWordWrap = (uint)(value ? 1 : 0); }
        }

        /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.WordWrapGlyphs"]/*' />
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool WordWrapGlyphs {
            get { return (int)prefs.fWordWrapGlyphs != 0; }
            set { prefs.fWordWrapGlyphs = (uint)(value ? 1 : 0); }
        }

        /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.CutCopyBlankLines"]/*' />
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool CutCopyBlankLines {
            get { return (int)prefs.fCutCopyBlanks != 0; }
            set { prefs.fCutCopyBlanks = (uint)(value ? 1 : 0); }
        }

        /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.LineNumbers"]/*' />
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool LineNumbers {
            get { return prefs.fLineNumbers != 0; }
            set { prefs.fLineNumbers = (uint)(value ? 1 : 0); }
        }

        /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.EnableLeftClickForURLs"]/*' />
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool EnableLeftClickForURLs {
            get { return prefs.fHotURLs != 0; }
            set { prefs.fHotURLs = (uint)(value ? 1 : 0); }
        }

        // Tabs tab
        /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.Indenting"]/*' />
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public IndentingStyle IndentStyle {
            get { return (IndentingStyle)prefs.IndentStyle; }
            set { prefs.IndentStyle = (vsIndentStyle)value; }
        }

        /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.TabSize"]/*' />
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public int TabSize {
            get { return (int)prefs.uTabSize; }
            set { prefs.uTabSize = (uint)value; }
        }

        /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.IndentSize"]/*' />
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public int IndentSize {
            get { return (int)prefs.uIndentSize; }
            set { prefs.uIndentSize = (uint)value; }
        }

        /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.InsertSpaces"]/*' />
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool InsertTabs {
            get { return prefs.fInsertTabs != 0; }
            set { prefs.fInsertTabs = (uint)(value ? 1 : 0); }
        }

        /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.ShowNavigationBar"]/*' />
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool ShowNavigationBar {
            get { return (int)prefs.fDropdownBar != 0; }
            set { prefs.fDropdownBar = (uint)(value ? 1 : 0); }
        }

        /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.EnableAutoOutlining"]/*' />
        public bool AutoOutlining {
            get { return this.autoOutlining; }
            set { this.autoOutlining = value; }
        }

        /// <include file='doc\Preferences.uex' path='docs/doc[@for="LanguagePreferences.GetLanguagePrefs"]/*' />
        public virtual void GetLanguagePreferences() {
            IVsTextManager textMgr = site.GetService(typeof(SVsTextManager)) as IVsTextManager;
            if (textMgr != null) {
                this.prefs.guidLang = langSvc;
                IVsTextManager2 textMgr2 = site.GetService(typeof(SVsTextManager)) as IVsTextManager2;
                if (textMgr != null) {
                    LANGPREFERENCES2[] langPrefs2 = new LANGPREFERENCES2[1];
                    langPrefs2[0] = this.prefs;
                    if (NativeMethods.Succeeded(textMgr2.GetUserPreferences2(null, null, langPrefs2, null))) {
                        this.prefs = langPrefs2[0];
                    } else {
                        Debug.Assert(false, "textMgr2.GetUserPreferences2");
                    }
                }
            }
        }

        /// <include file='doc\PropertySheet.uex' path='docs/doc[@for="LanguagePreferences.Apply"]/*' />
        public virtual void Apply() {
            IVsTextManager2 textMgr2 = site.GetService(typeof(SVsTextManager)) as IVsTextManager2;
            if (textMgr2 != null) {
                this.prefs.guidLang = langSvc;
                LANGPREFERENCES2[] langPrefs2 = new LANGPREFERENCES2[1];
                langPrefs2[0] = this.prefs;
                if (!NativeMethods.Succeeded(textMgr2.SetUserPreferences2(null, null, langPrefs2, null))) {
                    Debug.Assert(false, "textMgr2.SetUserPreferences2");
                }
            }
        }

        private void Connect() {
            if (this.connection == null && this.site != null) {
                IVsTextManager2 textMgr2 = this.site.GetService(typeof(SVsTextManager)) as IVsTextManager2;
                if (textMgr2 != null) {
                    this.connection = new NativeMethods.ConnectionPointCookie(textMgr2, (IVsTextManagerEvents2)this, typeof(IVsTextManagerEvents2));
                }
            }
        }

        private void Disconnect() {
            if (this.connection != null) {
                this.connection.Dispose();
                this.connection = null;
            }
        }

        #region IVsTextManagerEvents2 Members

        /// <include file='doc\Preferences.uex' path='docs/doc[@for="LanguagePreferences.OnRegisterMarkerType"]/*' />
        public virtual int OnRegisterMarkerType(int iMarkerType)
        {
            return NativeMethods.S_OK;
        }
        /// <include file='doc\Preferences.uex' path='docs/doc[@for="LanguagePreferences.OnRegisterView"]/*' />
        public virtual int OnRegisterView(IVsTextView view)
        {
            return NativeMethods.S_OK;
        }
        /// <include file='doc\Preferences.uex' path='docs/doc[@for="LanguagePreferences.OnUnregisterView"]/*' />
        public virtual int OnUnregisterView(IVsTextView view)
        {
            return NativeMethods.S_OK;
        }
        /// <include file='doc\Preferences.uex' path='docs/doc[@for="LanguagePreferences.OnReplaceAllInFilesBegin"]/*' />
        public virtual int OnReplaceAllInFilesBegin()
        {
            return NativeMethods.S_OK;
        }
        /// <include file='doc\Preferences.uex' path='docs/doc[@for="LanguagePreferences.OnReplaceAllInFilesEnd"]/*' />
        public virtual int OnReplaceAllInFilesEnd()
        {
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Preferences.uex' path='docs/doc[@for="LanguagePreferences.OnUserPreferencesChanged2"]/*' />
        public virtual int OnUserPreferencesChanged2(VIEWPREFERENCES2[] viewPrefs, FRAMEPREFERENCES2[] framePrefs, LANGPREFERENCES2[] langPrefs, FONTCOLORPREFERENCES2[] fontColorPrefs)
        {
            if (langPrefs != null && langPrefs.Length > 0 && langPrefs[0].guidLang == this.langSvc) {
                this.prefs = langPrefs[0];
            }
            return NativeMethods.S_OK;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\LanguageService100\Source.cs ===
//#define LANGTRACE
//#define TRACE_SPANS

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Windows.Forms;

using Microsoft.VisualStudio.Shell;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.TextManager.Interop;

using IServiceProvider = System.IServiceProvider;
using VsCommands2K = Microsoft.VisualStudio.VSConstants.VSStd2KCmdID;
using VSErrorHandler = Microsoft.VisualStudio.ErrorHandler;

namespace Microsoft.VisualStudio.Package {
    /// <include file='doc\Source.uex' path='docs/doc[@for="Severity"]/*' />
    public enum Severity {
        /// <include file='doc\Source.uex' path='docs/doc[@for="Severity.Hint"]/*' />
        Hint,
        /// <include file='doc\Source.uex' path='docs/doc[@for="Severity.Warning"]/*' />
        Warning,
        /// <include file='doc\Source.uex' path='docs/doc[@for="Severity.Error"]/*' />
        Error,
        /// <include file='doc\Source.uex' path='docs/doc[@for="Severity.Fatal"]/*' />
        Fatal
    };

    /// <include file='doc\Source.uex' path='docs/doc[@for="CommentInfo"]/*' />
    public struct CommentInfo {
        private string lineStart;
        private string blockStart;
        private string blockEnd;
        private bool useLineComments;


        /// <include file='doc\Source.uex' path='docs/doc[@for="CommentInfo.LineStart;"]/*' />
        public string LineStart {
            get {
                return this.lineStart;
            }
            set {
                this.lineStart = value;
            }
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="CommentInfo.BlockStart;"]/*' />
        public string BlockStart {
            get {
                return this.blockStart;
            }
            set {
                this.blockStart = value;
            }
        }
        /// <include file='doc\Source.uex' path='docs/doc[@for="CommentInfo.BlockEnd;"]/*' />
        public string BlockEnd {
            get {
                return this.blockEnd;
            }
            set {
                this.blockEnd = value;
            }
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="CommentInfo.UseLineComments;"]/*' />
        public bool UseLineComments {
            get {
                return this.useLineComments;
            }
            set {
                this.useLineComments = value;
            }
        }

    }

    //===================================================================================
    // Default Implementations
    //===================================================================================
    /// <include file='doc\Source.uex' path='docs/doc[@for="Source"]/*' />
    /// <summary>
    /// Source represents one source file and manages the parsing and intellisense on this file
    /// and keeping things like the drop down combos in sync with the source and so on.
    /// </summary>
    [CLSCompliant(false)]
    public class Source : IDisposable, IVsTextLinesEvents, IVsHiddenTextClient, IVsUserDataEvents {
        private LanguageService service;
        private IVsTextLines textLines;
        private Colorizer colorizer;
        internal TaskProvider taskProvider;
        private CompletionSet completionSet;
        private int dirtyTime;
        private bool dirty;
        private TextSpan dirtySpan;
        private MethodData methodData;
        private ExpansionProvider expansionProvider;
        private int requestSync;
        private NativeMethods.ConnectionPointCookie textLinesEvents;
        private NativeMethods.ConnectionPointCookie userDataEvents;
        private IVsTextColorState colorState;
        private IVsHiddenTextSession hiddenTextSession;
        internal static int HiddenRegionCookie = 25;
        private bool doOutlining;
        private int openCount;
        private int collapsed;
        private int lastParseTime;
        static internal WORDEXTFLAGS WholeToken = (WORDEXTFLAGS)0x1000;
        private IntPtr pUnkTextLines;
        private bool haveDepersistedOutlining = false;

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.CompletedFirstParse"]/*' />
        public bool CompletedFirstParse {
			get { return this.lastParseTime!=Int32.MaxValue; }
        }

        private bool handlesSnapshots = false;
        protected bool HandlesSnapshots
        {
            get { return handlesSnapshots; }
            set { handlesSnapshots = value; }
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.Source"]/*' />
        public Source(LanguageService service, IVsTextLines textLines, Colorizer colorizer) {
#if LANGTRACE
            Tracing.TraceRef(textLines, "Source.textLines");
#endif
            this.service = service;
            this.textLines = textLines;
            pUnkTextLines = Marshal.GetIUnknownForObject(this.textLines); //so it can't get disposed on us
            this.colorizer = colorizer;
            this.dirty = true;
            this.completionSet = this.CreateCompletionSet();
            this.methodData = this.CreateMethodData();
            this.colorState = (IVsTextColorState)textLines;

            // Register text buffer (IVsTextLines) event handlers
            // Delegate to virtual/overridable method
            RegisterTextBufferEventHandlers(textLines);

            this.doOutlining = this.service.Preferences.AutoOutlining;
            if (this.doOutlining) {
                GetHiddenTextSession();
            }
            this.expansionProvider = GetExpansionProvider();

			this.lastParseTime = Int32.MaxValue;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.Finalize"]/*' />
        ~Source() {
#if LANGTRACE
            Trace.WriteLine("~Source");
#endif
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.RegisterTextBufferEventHandlers"]/*' />
        public virtual void RegisterTextBufferEventHandlers(IVsTextLines textLines)
        {
            // track source changes
            this.textLinesEvents = new NativeMethods.ConnectionPointCookie(textLines, this, typeof(IVsTextLinesEvents));
            this.userDataEvents = new NativeMethods.ConnectionPointCookie(textLines, this, typeof(IVsUserDataEvents));
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.ColorState;"]/*' />
        public IVsTextColorState ColorState {
            get { return this.colorState; }
            set { this.colorState = value; }
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.LanguageService"]/*' />
        public LanguageService LanguageService {
            get { return this.service; }
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.CompletionSet"]/*' />
        public CompletionSet CompletionSet {
            get { return this.completionSet; }
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.GetColorizer"]/*' />
        public Colorizer GetColorizer() {
            return this.colorizer;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.Recolorize"]/*' />
        public void Recolorize(int startLine, int endLine) {
            if (this.colorState != null && this.GetLineCount() > 0) {
                int lastLine = this.GetLineCount() - 1;
                startLine = Math.Min(startLine, lastLine);
                endLine = Math.Min(endLine, lastLine);
                this.colorState.ReColorizeLines(startLine, endLine);
            }
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.CreateAuthoringSink"]/*' />
        public virtual AuthoringSink CreateAuthoringSink(ParseReason reason, int line, int col) {
            int maxErrors = this.service.Preferences.MaxErrorMessages;
            return new AuthoringSink(reason, line, col, maxErrors);
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.CreateCompletionSet"]/*' />
        public virtual CompletionSet CreateCompletionSet() {
            return new CompletionSet(this.service.GetImageList(), this);
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.GetMethodData"]/*' />
        public virtual MethodData CreateMethodData() {
            return new MethodData(this.service.Site);
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.GetTaskProvider"]/*' />
        public virtual TaskProvider GetTaskProvider() {
            if (this.taskProvider == null) {
                this.taskProvider = new ErrorListProvider(service.Site); // task list
                // <temporary hack>
                // Due to the fact that the ErrorList is not yet working...the 
                // following at least results in all tasks from the same language 
                // service into one list.
                this.taskProvider.ProviderGuid = service.GetLanguageServiceGuid();
                this.taskProvider.ProviderName = service.Name;
                // </temporary hack>
            }
            return this.taskProvider;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.GetExpansionProvider"]/*' />
        public virtual ExpansionProvider GetExpansionProvider() {
            if (this.expansionProvider == null && this.service != null) {
                this.expansionProvider = this.service.CreateExpansionProvider(this);
            }
            return this.expansionProvider;
        }
        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.IsCompletorActive"]/*' />
        /// <devdiv>returns true if either CompletionSet or MethodData is being displayed.</devdiv>
        public bool IsCompletorActive {
            get {
                return (this.completionSet != null && this.completionSet.IsDisplayed) ||
                    (this.methodData != null && this.methodData.IsDisplayed);
            }
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.DismissCompletor"]/*' />
        public void DismissCompletor() {
            if (this.completionSet != null && this.completionSet.IsDisplayed) {
                this.completionSet.Close();
            }
            if (this.methodData != null && this.methodData.IsDisplayed) {
                this.methodData.Close();
            }
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.Open"]/*' />
        public void Open() {
            this.openCount++;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.Close"]/*' />
        public bool Close() {
#if LANGTRACE
            Trace.WriteLine("Source::Close");
#endif
            if (--this.openCount == 0) {
                return true;
            }
            return false;
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="Source.Dispose"]/*' />
        public virtual void Dispose() {
#if LANGTRACE
            Trace.WriteLine("Source::Cleanup");
#endif
            try {
                if (this.textLinesEvents != null) {
                    this.textLinesEvents.Dispose();
                    this.textLinesEvents = null;
                }
            } catch (COMException) {
            }
            try {
                if (this.userDataEvents != null) {
                    this.userDataEvents.Dispose();
                    this.userDataEvents = null;
                }
            } catch (COMException) {
            }
            try {
                if (this.hiddenTextSession != null) {
                    // We can't throw or exit here because we need to call Dispose on the
                    // other members that need to be disposed.
                    this.hiddenTextSession.UnadviseClient();
                    this.hiddenTextSession = null;
                }
            } catch (COMException) {
            }
            try {
                if (this.methodData != null) {
                    this.methodData.Dispose();
                    this.methodData = null;
                }
            } catch (COMException) {
            }
            try {
                if (this.completionSet != null) {
                    this.completionSet.Dispose();
                    this.completionSet = null;
                }
            } catch (COMException) {
            }
            try {

                if (this.taskProvider != null) {
                    this.taskProvider.Dispose();
                    this.taskProvider = null;
                }
            } catch (COMException) {
            }
            try {
                this.service = null;
                if (this.colorizer != null) {
                    // The colorizer is owned by the core text editor, so we don't close it, the core text editor
                    // does that for us when it is ready to do so.
                    //colorizer.CloseColorizer();
                    this.colorizer = null;
                }
            } catch (COMException) {
            }
            try {
                if (this.colorState != null) {
                    this.colorState = null;
                }
            } catch (COMException) {
            }
            try {
                if (this.expansionProvider != null) {
                    this.expansionProvider.Dispose();
                    this.expansionProvider = null;
                }

            } catch (COMException) {
            }
            try {

                // Sometimes OnCloseSource is called when language service is changed, (for example
                // when you save the file with a different file extension) in which case we cannot 
                // null out the site because that will cause a crash inside msenv.dll.
                //            if (this.textLines != null) {
                //                ((IObjectWithSite)this.textLines).SetSite(null);
                //            }
                if (this.textLines != null) {
                    this.textLines = null; //rely on GC rather control lifetime through ReleaseCOMObject
                    Marshal.Release(pUnkTextLines);
                }
            } catch (COMException) {
            }
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.IsClosed"]/*' />
        public bool IsClosed {
            get { return this.textLines == null; }
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.LastParseTime"]/*' />
        public int LastParseTime {
            get { return this.lastParseTime; }
            set { this.lastParseTime = value; }
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.GetTextLines"]/*' />
        public IVsTextLines GetTextLines() {
            return this.textLines;
        }
        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.GetLineLength"]/*' />
        public int GetLineLength(int line) {
            int len;
            NativeMethods.ThrowOnFailure(this.textLines.GetLengthOfLine(line, out len));
            return len;
        }
        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.GetLineCount"]/*' />
        public int GetLineCount() {
            int count;
            NativeMethods.ThrowOnFailure(this.textLines.GetLineCount(out count));
            return count;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.GetPositionOfLineIndex"]/*' />
        public int GetPositionOfLineIndex(int line, int col) {
            int position;
            NativeMethods.ThrowOnFailure(this.textLines.GetPositionOfLineIndex(line, col, out position));
            return position;
        }
        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.GetLineIndexOfPosition"]/*' />
        public void GetLineIndexOfPosition(int position, out int line, out int col) {
            NativeMethods.ThrowOnFailure(this.textLines.GetLineIndexOfPosition(position, out line, out col));
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.GetLine"]/*' />
        public string GetLine(int line) {
            int len;
            NativeMethods.ThrowOnFailure(this.textLines.GetLengthOfLine(line, out len));
            return GetText(line, 0, line, len);
        }
        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.GetText"]/*' />
        public string GetText() {
            int endLine, endCol;
            NativeMethods.ThrowOnFailure(this.textLines.GetLastLineIndex(out endLine, out endCol));
            return GetText(0, 0, endLine, endCol);
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.GetText1"]/*' />
        public string GetText(int startLine, int startCol, int endLine, int endCol) {
            string text;
            Debug.Assert(TextSpanHelper.ValidCoord(this, startLine, startCol) && TextSpanHelper.ValidCoord(this, endLine, endCol));
            NativeMethods.ThrowOnFailure(this.textLines.GetLineText(startLine, startCol, endLine, endCol, out text));
            return text;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.GetText2"]/*' />
        public string GetText(TextSpan span) {
            return GetText(span.iStartLine, span.iStartIndex, span.iEndLine, span.iEndIndex);
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.GetTextUpToLine"]/*' />
        public string GetTextUpToLine(int line) {
            Debug.Assert(TextSpanHelper.ValidCoord(this, line, 0));
            int lastLine;
            NativeMethods.ThrowOnFailure(this.textLines.GetLineCount(out lastLine));
            lastLine--;
            if (line > 0) lastLine = Math.Min(line, lastLine);
            int lastIdx;
            NativeMethods.ThrowOnFailure(this.textLines.GetLengthOfLine(lastLine, out lastIdx));
            return GetText(0, 0, lastLine, lastIdx);
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.SetText"]/*' />
        public void SetText(string newText) {
            int endLine, endCol;
            NativeMethods.ThrowOnFailure(this.textLines.GetLastLineIndex(out endLine, out endCol));
            int len = (newText == null) ? 0 : newText.Length;
            IntPtr pText = Marshal.StringToCoTaskMemAuto(newText);
            try {
                NativeMethods.ThrowOnFailure(this.textLines.ReplaceLines(0, 0, endLine, endCol, pText, len, null));
            } finally {
                Marshal.FreeCoTaskMem(pText);
            }
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.SetText"]/*' />
        public void SetText(TextSpan span, string newText) {
            this.SetText(span.iStartLine, span.iStartIndex, span.iEndLine, span.iEndIndex, newText);
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.SetText"]/*' />
        public void SetText(int startLine, int startCol, int endLine, int endCol, string newText) {
            int len = (newText == null) ? 0 : newText.Length;
            int realEndLine, realEndCol;
            // trim to the real bounds of the file so we don't get a COM exception
            NativeMethods.ThrowOnFailure(this.textLines.GetLastLineIndex(out realEndLine, out realEndCol));
            if (endLine > realEndLine) {
                endLine = realEndLine;
                endCol = realEndCol;
            } else if (endLine == realEndLine && endCol > realEndCol) {
                endCol = realEndCol;
            }
            IntPtr pText = Marshal.StringToCoTaskMemAuto(newText);
            try {
                NativeMethods.ThrowOnFailure(this.textLines.ReplaceLines(startLine, startCol, endLine, endCol, pText, len, null));
            } finally {
                Marshal.FreeCoTaskMem(pText);
            }
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.GetUserData"]/*' />
        public object GetUserData(ref Guid key) {
            object data = null;
            IVsUserData iud = null;
            iud = (IVsUserData)this.textLines;
            int rc = NativeMethods.S_OK;
            if (iud != null) {
                rc = iud.GetData(ref key, out data);
            }
            iud = null;
            return (rc == NativeMethods.S_OK) ? data : null;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.SetUserData"]/*' />
        public void SetUserData(ref Guid key, object data) {
            IVsUserData iud = (IVsUserData)this.textLines;
            if (iud != null) {
                NativeMethods.ThrowOnFailure(iud.SetData(ref key, data));
            }
        }
       
        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.Dirty"]/*' />
        public virtual bool IsDirty {
            get {
                return this.dirty;
            }
            set {
                this.dirty = value;
                if (value) {
                    this.dirtyTime = System.Environment.TickCount;
                    this.requestSync = (this.requestSync == Int32.MaxValue) ? 0 : this.requestSync + 1;
                }                
            }
        }
        
        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.ChangeCount"]/*' />
        /// Returns a number indicating whether the buffer has changed since you last called.
        public int ChangeCount {
            get {
                return this.requestSync;
            }
            set {
                this.requestSync = value;
            }
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.DirtySpan"]/*' />
        public virtual TextSpan DirtySpan {
            get {
                return this.dirtySpan;
            }
            set {
                this.dirtySpan = value;
            }
        }

        void AddDirty(TextSpan span) {
            if (!this.IsDirty) {
                this.dirtySpan = span;
            } else {
                this.dirtySpan = TextSpanHelper.Merge(dirtySpan, span);
            }
            this.IsDirty = true;
        }

        #region Reformatting

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="ViewFilter.Reformat"]/*' />
        /// <summary>
        /// This method formats the given span using the given EditArray. The default behavior does nothing.  
        /// So you need to override this method if you want formatting to work.  
        /// An empty input span means reformat the entire document.
        /// You also need to turn on Preferences.EnableFormatSelection.
        /// </summary>
        public virtual void ReformatSpan(EditArray mgr, TextSpan span) {
        }

        #endregion

        #region Commenting

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="Source.GetCommentFormat"]/*' />
        /// <summary>Override this method if you want to provide different comment dilimiters.
        /// You can turn off commenting by setting Preferences.EnableCommenting to false.</summary>
        public virtual CommentInfo GetCommentFormat() {
            CommentInfo info = new CommentInfo();
            info.LineStart = "//";
            info.BlockStart = "/*";
            info.BlockEnd = "*/";
            info.UseLineComments = true;
            return info;
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="Source.CommentSpan"]/*' />
        public virtual TextSpan CommentSpan(TextSpan span) {
            TextSpan result = span;
            CommentInfo commentInfo = this.GetCommentFormat();

            using (new CompoundAction(this, SR.GetString(SR.CommentSelection))) {
                //try to use line comments first, if we can.        
                if (commentInfo.UseLineComments && !string.IsNullOrEmpty(commentInfo.LineStart)) {
                    span = CommentLines(span, commentInfo.LineStart);
                } else if (!string.IsNullOrEmpty(commentInfo.BlockStart) && !string.IsNullOrEmpty(commentInfo.BlockEnd)) {
                    result = CommentBlock(span, commentInfo.BlockStart, commentInfo.BlockEnd);
                }
            }
            return result;
        }

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="Source.CommentBlock"]/*' />
        /// <summary>
        /// Called from Comment Selection. Default behavior is to insert line style comments
        /// at beginning and end of selection. Override to add custome behavior.
        /// </summary>
        /// <param name="span"></param>
        /// <param name="lineComment"></param>
        /// <returns>The final span of the commented lines including the comment delimiters</returns>
        public virtual TextSpan CommentLines(TextSpan span, string lineComment) {
            //comment each line
            for (int line = span.iStartLine; line <= span.iEndLine; line++) {
                int idx = this.ScanToNonWhitespaceChar(line);
                this.SetText(line, idx, line, idx, lineComment);
            }
            span.iEndIndex += lineComment.Length;
            return span;
        }

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="Source.CommentBlock"]/*' />
        /// <summary>
        /// Called from Comment Selection. Default behavior is to insert block style comments
        /// at beginning and end of selection. Override to add custome behavior.
        /// </summary>
        /// <returns>The final span of the commented block including the comment delimiters</returns>
        public virtual TextSpan CommentBlock(TextSpan span, string blockStart, string blockEnd) {
            //sp. case no selection
            if (span.iStartIndex == span.iEndIndex &&
                span.iStartLine == span.iEndLine) {
                span.iStartIndex = this.ScanToNonWhitespaceChar(span.iStartLine);
                span.iEndIndex = this.GetLineLength(span.iEndLine);
            }
            //sp. case partial selection on single line
            if (span.iStartLine == span.iEndLine) {
                span.iEndIndex += blockStart.Length;
            }
            //add start comment
            this.SetText(span.iStartLine, span.iStartIndex, span.iStartLine, span.iStartIndex, blockStart);
            //add end comment
            this.SetText(span.iEndLine, span.iEndIndex, span.iEndLine, span.iEndIndex, blockEnd);
            span.iEndIndex += blockEnd.Length;
            return span;
        }

        /// <summary>
        /// Uncomments the given span of text and returns the span of the uncommented block.
        /// </summary>
        public virtual TextSpan UncommentSpan(TextSpan span) {
            CommentInfo commentInfo = this.GetCommentFormat();

            using (new CompoundAction(this, SR.GetString(SR.UncommentSelection))) {
                // is block comment selected?
                if (commentInfo.UseLineComments && !string.IsNullOrEmpty(commentInfo.LineStart)) {
                    span = UncommentLines(span, commentInfo.LineStart);
                } else if (commentInfo.BlockStart != null && commentInfo.BlockEnd != null) {
                    // TODO: this doesn't work if the selection contains a mix of code and block comments
                    // or multiple block comments!!  We should use the scanner to find the embedded 
                    // comments and uncomment the resulting comment spans only.
                    this.TrimSpan(ref span);
                    span = UncommentBlock(span, commentInfo.BlockStart, commentInfo.BlockEnd);
                }
            }
            return span;
        }

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="ViewFilter.UncommentLines"]/*' />
        public virtual TextSpan UncommentLines(TextSpan span, string lineComment) {
            // Remove line comments
            int clen = lineComment.Length;
            for (int line = span.iStartLine; line <= span.iEndLine; line++) {
                int i = this.ScanToNonWhitespaceChar(line);
                string text = this.GetLine(line);
                if (text.Substring(i, clen) == lineComment) {
                    this.SetText(line, i, line, i + clen, ""); // remove line comment.
                    if (line == span.iStartLine && span.iStartIndex != 0) span.iStartIndex = i;
                }
            }
            span.iStartIndex = 0;
            return span;
        }

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="ViewFilter.UncommentBlock"]/*' />
        /// <summary>Uncomments the given block and returns the span of the uncommented block</summary>
        public virtual TextSpan UncommentBlock(TextSpan span, string blockStart, string blockEnd) {

            int startLen = this.GetLineLength(span.iStartLine);
            int endLen = this.GetLineLength(span.iEndLine);

            TextSpan result = span;

            //sp. case no selection, try and uncomment the current line.
            if (span.iStartIndex == span.iEndIndex &&
                span.iStartLine == span.iEndLine) {
                span.iStartIndex = this.ScanToNonWhitespaceChar(span.iStartLine);
                span.iEndIndex = this.GetLineLength(span.iEndLine);
            }

            // Check that comment start and end blocks are possible.
            if (span.iStartIndex + blockStart.Length <= startLen && span.iEndIndex - blockStart.Length >= 0) {
                string startText = this.GetText(span.iStartLine, span.iStartIndex, span.iStartLine, span.iStartIndex + blockStart.Length);

                if (startText == blockStart) {
                    string endText = null;
                    TextSpan linespan = span;
                    linespan.iStartLine = linespan.iEndLine;
                    linespan.iStartIndex = linespan.iEndIndex - blockEnd.Length;
                    Debug.Assert(TextSpanHelper.IsPositive(linespan));
                    endText = this.GetText(linespan);
                    if (endText == blockEnd) {
                        //yes, block comment selected; remove it        
                        this.SetText(linespan.iStartLine, linespan.iStartIndex, linespan.iEndLine, linespan.iEndIndex, null);
                        this.SetText(span.iStartLine, span.iStartIndex, span.iStartLine, span.iStartIndex + blockStart.Length, null);
                        span.iEndIndex -= blockEnd.Length;
                        if (span.iStartLine == span.iEndLine) span.iEndIndex -= blockStart.Length;
                        result = span;
                    }
                }
            }

            return result;
        }


        #endregion

        #region IVsTextLinesEvents
        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.OnChangeLineText"]/*' />
        public virtual void OnChangeLineText(TextLineChange[] lineChange, int last) {
            TextSpan span = new TextSpan();
            span.iStartIndex = lineChange[0].iStartIndex;
            span.iStartLine = lineChange[0].iStartLine;
            span.iEndLine = lineChange[0].iOldEndLine;
            span.iEndIndex = lineChange[0].iOldEndIndex;
            AddDirty(span);
            span.iEndLine = lineChange[0].iNewEndLine;
            span.iEndIndex = lineChange[0].iNewEndIndex;
            AddDirty(span);
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.OnChangeLineAttributes"]/*' />
        public virtual void OnChangeLineAttributes(int firstLine, int lastLine) {
        }
        #endregion

        //===================================================================================
        // Helper methods:
        //===================================================================================   
        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.GetFilePath"]/*' />
        public virtual string GetFilePath() {
            if (this.textLines == null) return null;
            return FilePathUtilities.GetFilePath(this.textLines);
        }

        /// <summary>
        /// Return the column position of 1st non whitespace character on line
        /// </summary>
        /// <param name="line"></param>
        /// <returns></returns>
        public int ScanToNonWhitespaceChar(int line) {
            string text = GetLine(line);
            int len = text.Length;
            int i = 0;
            while (i < len && Char.IsWhiteSpace(text[i])) {
                i++;
            }
            return i;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.ColumnToVisiblePosition"]/*' />
        /// <summary>
        /// Return the column position that the user will see given the current
        /// tab size setting.  This is the opposite of VisiblePositionToColumn
        /// </summary>
        public int ColumnToVisiblePosition(int line, int col) {
            if (col <= 0) return 0;
            string text = this.GetText(line, 0, line, col); //don't get entire line if we need only partial
            int tabsize = this.LanguageService.Preferences.TabSize;
            int visible = 0;
            for (int i = 0, n = text.Length; i < col && i < n; i++) {
                char ch = text[i];
                int step = 1;
                if (ch == '\t') {
                    step = tabsize - visible % tabsize;
                }
                visible += step;
            }
            return visible;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.VisiblePositionToColumn"]/*' />
        /// <summary>
        /// Convert a user visible position back to char position in the buffer.
        /// This is the opposite of ColumnToVisiblePosition. In this case the 
        /// visible position was off the end of the line, it just returns the 
        /// column position at the end of the line.
        /// </summary>
        public int VisiblePositionToColumn(int line, int visiblePosition) {
            string text = this.GetLine(line);
            int tabsize = this.LanguageService.Preferences.TabSize;
            int visible = 0;
            int i = 0;
            for (int n = text.Length; i < n; i++) {
                char ch = text[i];
                int step = 1;
                if (ch == '\t') {
                    step = visible % tabsize;
                    if (step == 0) step = tabsize;
                }
                visible += step;
                if (visible > visiblePosition)
                    return i;
            }
            return i;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.GetDocumentSpan"]/*' />
        public TextSpan GetDocumentSpan() {
            TextSpan span = new TextSpan();
            span.iStartIndex = span.iStartLine = 0;
            NativeMethods.ThrowOnFailure(this.textLines.GetLastLineIndex(out span.iEndLine, out span.iEndIndex));
            return span;
        }

        string NormalizeString(string message) {
            //remove control characters
            StringBuilder sb = new StringBuilder();
            for (int i = 0, n = message.Length; i < n; i++) {
                char ch = message[i];

                sb.Append(System.Convert.ToInt32(ch) < 0x20 ? ' ' : ch);
            }
            return sb.ToString();
        }

        // helper methods.
        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.CreateErrorTaskItem"]/*' />
        public virtual DocumentTask CreateErrorTaskItem(TextSpan span, string filename, string message, TaskPriority priority, TaskCategory category, MARKERTYPE markerType, TaskErrorCategory errorCategory) {
            // create task item
            
            //TODO this src obj may not be the one matching filename.
            //find the src for the filename only then call ValidSpan.
            //Debug.Assert(TextSpanHelper.ValidSpan(this, span)); 

            DocumentTask taskItem = CreateErrorTaskItem(span, markerType, filename);
            taskItem.Priority = priority;
            taskItem.Category = category;
            taskItem.ErrorCategory = errorCategory;
            taskItem.Text = message;
            taskItem.IsTextEditable = false;
            taskItem.IsCheckedEditable = false;
            return taskItem;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.CreateErrorTaskItem2"]/*' />
        public virtual DocumentTask CreateErrorTaskItem(TextSpan span, MARKERTYPE markerType, string filename) {
            return new DocumentTask(this.service.Site, this.textLines, markerType, span, filename);
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.GetNewLine"]/*' />
        // return the type of new line to use that matches the one at the given line.
        public string GetNewLine(int line) {
            string eol = "\r\n"; // "\x000D\x000A"
            LINEDATAEX[] ld = new LINEDATAEX[1];
            NativeMethods.ThrowOnFailure(this.textLines.GetLineDataEx(0, line, 0, 0, ld, null));
            uint iEolType = (uint)ld[0].iEolType;
            if (iEolType == (uint)EOLTYPE.eolUNI_LINESEP) {
                if (this.textLines is IVsTextLines2) {
                    IVsTextLines2 textLines2 = (IVsTextLines2)this.textLines;
                    int hr = textLines2.GetEolTypeEx(ld, out iEolType);
                    if (NativeMethods.Failed(hr)) {
#if LANGTRACE
                        Trace.WriteLine("Ignoring actual EOL type and continuing");
#endif
                        iEolType = (uint)EOLTYPE.eolUNI_LINESEP;
                    }
                }
            }

            switch (iEolType) {
            case (uint)EOLTYPE.eolCR:
            eol = "\r"; // "\x000D"
            break;
            case (uint)EOLTYPE.eolLF:
            eol = "\n"; // "\x000A"
            break;
            case (uint)EOLTYPE.eolUNI_LINESEP:
            eol = "\u2028";
            break;
            case (uint)EOLTYPE.eolUNI_PARASEP:
            eol = "\u2029";
            break;
            case (uint)_EOLTYPE2.eolUNI_NEL:
            eol = "\u0085";
            break;
            }

            NativeMethods.ThrowOnFailure(this.textLines.ReleaseLineDataEx(ld));

            return eol;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.NormalizeNewlines"]/*' />
        /// <summary>Convert the newlines in the given input string to the style of newline
        /// provided in the second argument.</summary>
        public string NormalizeNewlines(string input, string newline) {
            StringBuilder sb = new StringBuilder();
            for (int i = 0, n = input.Length; i < n; i++) {
                char c = input[i];
                if (c == '\r') {
                    sb.Append(newline);
                    if (i + 1 < n && input[i + 1] == '\n') {
                        i++;
                    }
                } else if (c == '\n') {
                    sb.Append(newline);
                } else {
                    sb.Append(c);
                }
            }
            return sb.ToString();
        }


        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.GetTokenInfoAt"]/*' />
        public virtual int GetTokenInfoAt(TokenInfo[] infoArray, int col, ref TokenInfo info) {
            for (int i = 0, len = infoArray.Length; i < len; i++) {
                int start = infoArray[i].StartIndex;
                int end = infoArray[i].EndIndex;

                if (i == 0 && start > col)
                    return -1;

                if (col >= start && col <= end) {
                    info = infoArray[i];
                    return i;
                }
            }

            return -1;
        }


        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.OnIdle"]/*' />
        public virtual void OnIdle(bool periodic) {
            // Kick of a background parse, but only in the periodic intervals
            if (!periodic || this.service == null || this.service.LastActiveTextView == null) {
                return;
            }

            // Don't do background parsing while intellisense completion is going on
            if ((this.completionSet != null && this.completionSet.IsDisplayed) ||
                (this.methodData != null && this.methodData.IsDisplayed)) {
                return;
            }

            if (this.IsDirty) {
                // Don't kick off a background parse, while the user is typing.
                // this.dirtyTime moves with every keystroke.
                int delay = Math.Max(this.lastParseTime, this.service.Preferences.CodeSenseDelay);

                if (TimeUtilities.TimeSince(this.dirtyTime) > delay) {
                    if (!this.service.IsParsing) {
                        BeginParse();
                    }
                }
            }
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.BeginParse"]/*' />
        public virtual void BeginParse() {
            IVsTextView view = this.service.GetPrimaryViewForSource(this);
            this.BeginParse(0, 0, new TokenInfo(), ParseReason.Check, view, new ParseResultHandler(this.HandleParseResponse));
            this.IsDirty = false;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.GetTokenInfo"]/*' />
        public virtual TokenInfo GetTokenInfo(int line, int col) {
            //get current line 
            TokenInfo info = new TokenInfo();
            //get line info
            TokenInfo[] lineInfo = this.colorizer.GetLineInfo(this.textLines, line, this.colorState);
            if (lineInfo != null) {
                //get character info      
                if (col > 0) col--; 
                this.GetTokenInfoAt(lineInfo, col, ref info);
            }

            return info;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.OnCommand"]/*' />
        public virtual void OnCommand(IVsTextView textView, VsCommands2K command, char ch) {
            if (textView == null || this.service == null || !this.service.Preferences.EnableCodeSense)
                return;

            bool backward = (command == VsCommands2K.BACKSPACE || command == VsCommands2K.BACKTAB ||
                command == VsCommands2K.LEFT || command == VsCommands2K.LEFT_EXT);

            int line, idx;

            NativeMethods.ThrowOnFailure(textView.GetCaretPos(out line, out idx));

            TokenInfo info = GetTokenInfo(line, idx);
            TokenTriggers triggerClass = info.Trigger;

            if ((triggerClass & TokenTriggers.MemberSelect) != 0 && (command == VsCommands2K.TYPECHAR)) {
                ParseReason reason = ((triggerClass & TokenTriggers.MatchBraces) == TokenTriggers.MatchBraces) ? ParseReason.MemberSelectAndHighlightBraces : ParseReason.MemberSelect;
                this.Completion(textView, info, reason);
            } else if ((triggerClass & TokenTriggers.MatchBraces) != 0 && this.service.Preferences.EnableMatchBraces) {
                if ((command != VsCommands2K.BACKSPACE) && ((command == VsCommands2K.TYPECHAR) || this.service.Preferences.EnableMatchBracesAtCaret)) {
                    this.MatchBraces(textView, line, idx, info);
                }
            }
            //displayed & a trigger found
            // todo: This means the method tip disappears if you type "ENTER" 
            // while entering method arguments, which is bad.
            if ((triggerClass & TokenTriggers.MethodTip) != 0 && this.methodData.IsDisplayed) {
                if ((triggerClass & TokenTriggers.MethodTip) == TokenTriggers.ParameterNext) {
                    //this is an optimization
                    methodData.AdjustCurrentParameter((backward && idx > 0) ? -1 : +1);
                } else {
                    //this is the general case
                    this.MethodTip(textView, line, (backward && idx > 0) ? idx - 1 : idx, info);
                }
            } else if ((triggerClass & TokenTriggers.MethodTip) != 0 && (command == VsCommands2K.TYPECHAR) && this.service.Preferences.ParameterInformation) {
                //not displayed & trigger found & character typed & method info enabled
                this.MethodTip(textView, line, idx, info);
            } else if (methodData.IsDisplayed) {
                //displayed & complex command
                this.MethodTip(textView, line, idx, info);
            }
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.GetWordExtent"]/*' />
        public bool GetWordExtent(int line, int idx, WORDEXTFLAGS flags, out int startIdx, out int endIdx) {
            Debug.Assert(line >= 0 && idx >= 0);
            startIdx = endIdx = idx;

            int length;
            NativeMethods.ThrowOnFailure(this.textLines.GetLengthOfLine(line, out length));
            // pin to length of line just in case we return false and skip pinning at the end of this method.
            startIdx = endIdx = Math.Min(idx, length);
            if (length == 0) {
                return false;
            }

            //get the character classes
            TokenInfo[] lineInfo = this.colorizer.GetLineInfo(this.textLines, line, this.colorState);
            if (lineInfo == null || lineInfo.Length == 0) return false;

            int count = lineInfo.Length;
            TokenInfo info = new TokenInfo();
            int index = this.GetTokenInfoAt(lineInfo, idx, ref info);

            if (index < 0) return false;
            // don't do anything in comment or text or literal space, unless we
            // are doing intellisense in which case we want to match the entire value
            // of quoted strings.
            TokenType type = info.Type;
            if ((flags != Source.WholeToken || type != TokenType.String) && (type == TokenType.Comment || type == TokenType.LineComment || type == TokenType.Text || type == TokenType.String || type == TokenType.Literal))
                return false;
            //search for a token
            switch (flags & WORDEXTFLAGS.WORDEXT_MOVETYPE_MASK) {
            case WORDEXTFLAGS.WORDEXT_PREVIOUS:
            index--;
            while (index >= 0 && !MatchToken(flags, lineInfo[index])) index--;
            if (index < 0) return false;
            break;

            case WORDEXTFLAGS.WORDEXT_NEXT:
            index++;
            while (index < count && !MatchToken(flags, lineInfo[index])) index++;
            if (index >= count) return false;
            break;

            case WORDEXTFLAGS.WORDEXT_NEAREST: {
                int prevIdx = index;
                prevIdx--;
                while (prevIdx >= 0 && !MatchToken(flags, lineInfo[prevIdx])) prevIdx--;
                int nextIdx = index;
                while (nextIdx < count && !MatchToken(flags, lineInfo[nextIdx])) nextIdx++;
                if (prevIdx < 0 && nextIdx >= count) return false;
                else if (nextIdx >= count) index = prevIdx;
                else if (prevIdx < 0) index = nextIdx;
                else if (index - prevIdx < nextIdx - index) index = prevIdx;
                else
                    index = nextIdx;
                break;
            }

            case WORDEXTFLAGS.WORDEXT_CURRENT:
            default:
            if (!MatchToken(flags, info))
                return false;

            break;
            }
            info = lineInfo[index];

            // We found something, set the span, pinned to the valid coordinates for the
            // current line.
            startIdx = Math.Min(length, info.StartIndex);
            endIdx = Math.Min(length, info.EndIndex);

            // The scanner endIndex is the last char of the symbol, but
            // GetWordExtent wants it to be the next char after that, so 
            // we increment the endIdx (if we can).
            if (endIdx < length) endIdx++;
            return true;
        }

        static bool MatchToken(WORDEXTFLAGS flags, TokenInfo info) {
            TokenType type = info.Type;
            if ((flags & WORDEXTFLAGS.WORDEXT_FINDTOKEN) != 0)
                return !(type == TokenType.Comment || type == TokenType.LineComment);
            else
                return (type == TokenType.Keyword || type == TokenType.Identifier || type == TokenType.String || type == TokenType.Literal);
        }



        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.TrimSpan(ref span);"]/*' />
        /// Trim whitespace from the beginning and ending of the given span.
        public void TrimSpan(ref TextSpan span) {
            // Scan forwards past whitepsace.
            int length;
            NativeMethods.ThrowOnFailure(this.textLines.GetLengthOfLine(span.iStartLine, out length));

            while (span.iStartLine < span.iEndLine || (span.iStartLine == span.iEndLine && span.iStartIndex < span.iEndIndex)) {
                string text = this.GetText(span.iStartLine, 0, span.iStartLine, length);
                for (int i = span.iStartIndex; i < length; i++) {
                    char ch = text[i];
                    if (ch != ' ' && ch != '\t')
                        break;
                    span.iStartIndex++;
                }
                if (span.iStartIndex >= length) {
                    span.iStartIndex = 0;
                    span.iStartLine++;
                    NativeMethods.ThrowOnFailure(this.textLines.GetLengthOfLine(span.iStartLine, out length));
                } else {
                    break;
                }
            }
            // Scan backwards past whitepsace.
            NativeMethods.ThrowOnFailure(this.textLines.GetLengthOfLine(span.iEndLine, out length));

            while (span.iStartLine < span.iEndLine || (span.iStartLine == span.iEndLine && span.iStartIndex < span.iEndIndex)) {
                string text = GetText(span.iEndLine, 0, span.iEndLine, length);
                for (int i = span.iEndIndex - 1; i >= 0; i--) {
                    char ch = text[i];
                    if (ch != ' ' && ch != '\t')
                        break;
                    span.iEndIndex--;
                }
                if (span.iEndIndex <= 0) {
                    span.iEndLine--;
                    NativeMethods.ThrowOnFailure(this.textLines.GetLengthOfLine(span.iEndLine, out length));
                    span.iEndIndex = length;
                } else {
                    break;
                }
            }
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.Completion"]/*' />
        public virtual void Completion(IVsTextView textView, TokenInfo info, ParseReason reason) {
            int line;
            int idx;
            NativeMethods.ThrowOnFailure(textView.GetCaretPos(out line, out idx));
            this.BeginParse(line, idx, info, reason, textView, new ParseResultHandler(this.HandleCompletionResponse));
        }

        internal void HandleCompletionResponse(ParseRequest req) {
            try {
                if (this.service == null || req == null || req.View == null ||
                    req.Scope == null || req.Timestamp != this.requestSync)
                    return;
#if LANGTRACE
                Trace.WriteLine("Source::HandleCompletionResponse");
#endif
                SetLastParseTime(req.parseTime); // for OnIdle loop

                ParseReason reason = req.Reason;
                if (reason == ParseReason.MemberSelectAndHighlightBraces)
                    HandleMatchBracesResponse(req);

                Declarations decls = req.Scope.GetDeclarations(req.View, req.Line, req.Col, req.TokenInfo, reason);
                // We go to all this effort even when this.service.Preferences.AutoListMembers
                // is false because sometimes the language service also wants to do "auto-insert"
                // operations at the same time as completion.  
                bool completeWord = (reason == ParseReason.CompleteWord);
                int line;
                int idx;
                NativeMethods.ThrowOnFailure(req.View.GetCaretPos(out line, out idx));

                if (decls.GetCount() > 0 &&
                    (this.service.Preferences.AutoListMembers || completeWord || reason == ParseReason.DisplayMemberList) &&
                    line == req.Line && idx == req.Col //ensure user has not chaged cursor location
                    ) {
                    this.completionSet.Init(req.View, decls, completeWord);
                }

#if LANGTRACE
            } catch (Exception e) {
                Trace.WriteLine("HandleCompletionResponse exception: " + e.Message);
#endif
            } catch {
            }
        }

        internal void SetLastParseTime(int time) {
#if LANGTRACE
            Trace.WriteLine("Previous parse time="+this.lastParseTime+"\tNew parse time="+time);
#endif
            this.lastParseTime = time;            
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.MethodTip"]/*' />
        public virtual void MethodTip(IVsTextView textView, int line, int index, TokenInfo info) {
            this.BeginParse(line, index, info, ParseReason.MethodTip, textView, new ParseResultHandler(this.HandleMethodTipResponse));
        }

        internal void HandleMethodTipResponse(ParseRequest req) {
            try {
                if (this.service == null || req.Timestamp != this.requestSync)
                    return;

                CallInfo call = req.Sink.MethodCalls.GetCurrentMethodCall();
                if (call == null) goto fail;
                StringCollection names = call.names;
                if (names.Count == 0) goto fail;
                ArrayList contexts = call.sourceLocations;
                string name = names[names.Count - 1];
                TextSpan span = (TextSpan)contexts[names.Count - 1];
                Methods methods = req.Scope.GetMethods(span.iStartLine, span.iStartIndex, name);

                if (methods == null)
                    goto fail;

                int currentParameter = call.currentParameter;
                this.methodData.Refresh(req.View, methods, currentParameter, span);
                return;
            fail:
                DismissCompletor();
#if LANGTRACE
            } catch (Exception e) {
                Trace.WriteLine("HandleMethodTipResponse exception: " + e.Message);
#endif
            } catch {
            }
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.MatchBraces"]/*' />
        public virtual void MatchBraces(IVsTextView textView, int line, int index, TokenInfo info) {
            this.BeginParse(line, index, info, ParseReason.HighlightBraces, textView, new ParseResultHandler(this.HandleMatchBracesResponse));
        }

        internal void HandleMatchBracesResponse(ParseRequest req) {
            try {
                if (this.service == null || req.Timestamp != this.requestSync)
                    return;

#if LANGTRACE
                Trace.WriteLine("HandleMatchBracesResponse");
#endif
                if (req.Sink.Spans.Count == 0)
                    return;

                // Normalize the spans, and weed out empty ones, since there's no point
                // trying to highlight an empty span.
                ArrayList normalized = new ArrayList();
                foreach (TextSpan span in req.Sink.Spans) {
                    TextSpan norm = span;
                    TextSpanHelper.Normalize(ref norm, this.textLines);
                    if (!TextSpanHelper.ValidSpan(this, norm)) {
                        Debug.Assert(false, "Invalid text span");
                    } else if (!TextSpanHelper.IsEmpty(norm)) {
                        normalized.Add(norm);
                    }
                }

                if (normalized.Count == 0)
                    return;

                //transform spanList into an array of spans
                TextSpan[] spans = (TextSpan[])normalized.ToArray(typeof(TextSpan));

                //highlight
                NativeMethods.ThrowOnFailure(req.View.HighlightMatchingBrace((uint)this.service.Preferences.HighlightMatchingBraceFlags, (uint)spans.Length, spans));
                //try to show the matching line in the statusbar
                if (spans.Length > 0 && this.service.Preferences.EnableShowMatchingBrace) {
                    IVsStatusbar statusBar = (IVsStatusbar)service.Site.GetService(typeof(SVsStatusbar));
                    if (statusBar != null) {
                        TextSpan span = spans[0];
                        bool found = false;
                        // Gather up the other side of the brace match so we can 
                        // display the text in the status bar. There could be more than one
                        // if MatchTriple was involved, in which case we merge them.
                        for (int i = 0, n = spans.Length; i < n; i++) {
                            TextSpan brace = spans[i];
                            if (brace.iStartLine != req.Line) {
                                if (brace.iEndLine != brace.iStartLine) {
                                    brace.iEndLine = brace.iStartLine;
                                    brace.iEndIndex = this.GetLineLength(brace.iStartLine);
                                }
                                if (!found) {
                                    span = brace;
                                } else if (brace.iStartLine == span.iStartLine) {
                                    span = TextSpanHelper.Merge(span, brace);
                                }
                                found = true;
                            }
                        }
                        if (found) {
                            Debug.Assert(TextSpanHelper.IsPositive(span));
                            string text = this.GetText(span);

                            int start;
                            int len = text.Length;

                            for (start = 0; start < len && Char.IsWhiteSpace(text[start]); start++) ;

                            if (start < span.iEndIndex) {
                                if (text.Length > 80) {
                                    text = String.Format(CultureInfo.CurrentUICulture, SR.GetString(SR.Truncated), text.Substring(0, 80));
                                }
                                text = String.Format(CultureInfo.CurrentUICulture, SR.GetString(SR.BraceMatchStatus), text);
                                NativeMethods.ThrowOnFailure(statusBar.SetText(text));
                            }
                        }
                    }
                }
#if LANGTRACE
            } catch (Exception e) {
                Trace.WriteLine("HandleMatchBracesResponse exception: " + e.Message);
#endif
            } catch {
            }
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.GetPairExtents"]/*' />
        public virtual void GetPairExtents(IVsTextView textView, int line, int col, out TextSpan span) {
            span = new TextSpan();
            TextSpan startBraceSpan, endBraceSpan;
            this.GetPairExtents(textView, line, col, out startBraceSpan, out endBraceSpan);
            span.iStartLine = startBraceSpan.iStartLine;
            span.iStartIndex = startBraceSpan.iStartIndex;
            span.iEndLine = endBraceSpan.iStartLine;
            span.iEndIndex = endBraceSpan.iStartIndex;

            TextSpanHelper.MakePositive(ref span);
            Debug.Assert(TextSpanHelper.ValidSpan(this, span));
            return;
        }

        public virtual bool GetPairExtents(IVsTextView textView, int line, int col, out TextSpan startBraceSpan, out TextSpan endBraceSpan) {
            bool found = false;
            startBraceSpan = new TextSpan();
            endBraceSpan = new TextSpan();

            // Synchronously return the matching brace location.      
            ParseRequest req = this.BeginParse(line, col, new TokenInfo(), ParseReason.MatchBraces, textView, null);
            AuthoringSink sink = req.Sink;
            AuthoringScope scope = req.Scope;            

            if (sink.Braces.Count == 0)
                return found;

            // The following algorithm allows for multiple potentially overlapping
            // matches to be returned. This is because the same pairs used here are
            // also used in brace highlighting, and brace highlighting supports
            // MatchMultiple which can include more than 2 spans.  So here
            // we have to find which of the spans we are currently inside.

            foreach (BraceMatch m in sink.Braces) {
                for (int i = 0; i < m.Count; ++i) {
                    if (TextSpanHelper.ContainsInclusive(m.Span(i), line, col)) {
                        if (m.Count - 1 == i) {
                            startBraceSpan = m.Span(0);
                            endBraceSpan = m.Span(i);
                        } else {
                            startBraceSpan = m.Span(i);
                            endBraceSpan = m.Span(i + 1);
                        }
                        return true;
                    }
                }
            }

            return found;
        }

        /// <summary>
        /// BeginParse is called when this Source object needs to be parsed.  The default implementation
        /// uses the LanguageService background parse thread to do the work.
        /// </summary>
        /// <param name="line">The line position where intellisense is being requested (if any)</param>
        /// <param name="idx">The column position where intellisense is being requested</param>
        /// <param name="info">The token at the line/col position or an empty token</param>
        /// <param name="reason">The reason for this parse request</param>
        /// <param name="view">The IVsTextView or null if the view is not known.</param>
        /// <param name="callback">A callback delegate to call when the parse is completed.  If a callback 
        /// delegate is provided then the ParseRequest will be processed asynchronously on a background thread 
        /// and this method will return immediately, then the callback will be called on the UI thread when the 
        /// parse is completed.  The completed ParseRequest will then contain an AuthoringScope object which can 
        /// be used to complete intellisense requests.</param>
        /// <returns></returns>
        public virtual ParseRequest BeginParse(int line, int idx, TokenInfo info, ParseReason reason, IVsTextView view, ParseResultHandler callback) {
            bool synchronous = callback == null || !this.LanguageService.Preferences.EnableAsyncCompletion;

            bool success = false;
            if (synchronous && this.LanguageService.IsParsing) {
                // Have to wait for the background thread to finish so we don't try parsing the same
                // buffer at the same time.  We also have to "stop" the background thread when it's done
                // so it doesn't automatically pick up the next pending parse requrest and continue right on.
                IAsyncResult result = this.LanguageService.GetParseResult();
#if PARSETHREAD
                Trace.WriteLine("Source.BeginParse Waitng for bgr thread");
#endif
                if (!result.IsCompleted) {
                    success=result.AsyncWaitHandle.WaitOne();
                }
#if PARSETHREAD
                Debug.Assert(success || result.IsCompleted, "Why did result not complete well?");
#endif
            }
#if PARSETHREAD
            Trace.WriteLine("Source.BeginParse Go" + " is parsing " + this.LanguageService.IsParsing);
#endif
            // get all the text so we can pass it to the background thread.  This is required unfortunately
            // becase IVsTextLines is not multithread safe (it is an apartment COM object).
            string text = (HandlesSnapshots ? null: this.GetText());
            string fname = this.GetFilePath();
            ParseRequest request = this.LanguageService.CreateParseRequest(this, line, idx, info, text, fname, reason, view);
            request.Timestamp = this.ChangeCount;
            request.DirtySpan = this.DirtySpan;
            if (synchronous) {
                request.IsSynchronous = true; //unless registry value indicates that sync ops always prefer async 
            }
            if (request.IsSynchronous) {
                this.LanguageService.ParseRequest(request);
                this.SetLastParseTime(request.parseTime);
                if (callback != null) callback(request);
            } else {
                request.result = this.LanguageService.BeginParse(request, callback);
            }
            return request;
        }

        internal void HandleParseResponse(ParseRequest req) {
            try {
#if LANGTRACE
                Trace.WriteLine("HandleParseResponse:" + req.Timestamp);
#endif
                if (this.service == null) return;

                SetLastParseTime(req.parseTime); // for OnIdle loop

                if (req.Timestamp == this.requestSync) {
                    // If the request is out of sync with the buffer, then the error spans
                    // and hidden regions could be wrong, so we ignore this parse and wait 
                    // for the next OnIdle parse.
                    ReportTasks(req.Sink.errors);
                    if (req.Sink.ProcessHiddenRegions) {
                        ProcessHiddenRegions(req.Sink.hiddenRegions);
                    }
                }
                this.service.OnParseComplete(req);
#if LANGTRACE
            } catch (Exception e) {
                Trace.WriteLine("HandleParseResponse exception: " + e.Message);
#endif
            } catch {
            }
        }

        internal void FixupMarkerSpan(ref TextSpan span) {
            // This is similar to TextSpanHelper.Normalize except that 
            // we try not to create empty spans at end of line, since VS doesn't like
            // empty spans for text markers.  See comment in CreateMaker in DocumentTask.cs 

            //adjust max. lines
            int lineCount;
            if (NativeMethods.Failed(this.textLines.GetLineCount(out lineCount)))
                return;
            span.iEndLine = Math.Min(span.iEndLine, lineCount - 1);
            //make sure the start is still before the end
            if (!TextSpanHelper.IsPositive(span)) {
                span.iStartLine = span.iEndLine;
                span.iStartIndex = span.iEndIndex;
            }
            //adjust for line length
            int lineLength;
            if (NativeMethods.Failed(this.textLines.GetLengthOfLine(span.iStartLine, out lineLength)))
                return;
            span.iStartIndex = Math.Min(span.iStartIndex, lineLength);
            if (NativeMethods.Failed(this.textLines.GetLengthOfLine(span.iEndLine, out lineLength)))
                return;
            span.iEndIndex = Math.Min(span.iEndIndex, lineLength);

            if (TextSpanHelper.IsEmpty(span) && span.iStartIndex == lineLength && span.iEndLine + 1 < lineCount) {
                // Make the span include the newline if it was empty and at the end of the line.
                span.iEndLine++;
                span.iEndIndex = 0;
            }
        }

        internal void ReportTasks(ArrayList errors) {
            TaskProvider taskProvider = this.GetTaskProvider();

            if (errors == null || errors.Count == 0) {
                if (taskProvider.Tasks.Count > 0) {
                    taskProvider.Tasks.Clear();
                }
                return;
            }
            int removed = 0;
            int added = 0;
            int merged = 0;
            int errorMax = this.service.Preferences.MaxErrorMessages;
            string fname = this.GetFilePath();
            RunningDocumentTable rdt = new RunningDocumentTable(this.service.Site);
            IVsHierarchy thisHeirarchy = rdt.GetHierarchyItem(fname);

            // Here we merge errors lists to reduce flicker.  It is not a very intelligent merge
            // but that is ok, the worst case is the task list flickers a bit.  But 99% of the time
            // one error is added or removed as the user is typing, and this merge will reduce flicker
            // in this case.
            errors = GroupBySeverity(errors);
            taskProvider.SuspendRefresh(); // batch updates.
            int pos = 0;
            TaskErrorCategory mostSevere = TaskErrorCategory.Message;

            for (int i = 0, n = errors.Count; i < n; i++) {
                ErrorNode enode = (ErrorNode)errors[i];
                string filename = enode.uri;
                bool thisFile = (!string.IsNullOrEmpty(filename) && NativeMethods.IsSamePath(fname, filename));

                TextSpan span = enode.context;
                Severity severity = enode.severity;
                string message = enode.message;
                if (message == null) continue;

                message = NormalizeString(message);
                // Don't do multi-line squiggles, instead just squiggle to the
                // end of the first line.
                if (span.iEndLine > span.iStartLine) {
                    span.iEndLine = span.iStartLine;
                    NativeMethods.ThrowOnFailure(this.textLines.GetLengthOfLine(span.iStartLine, out span.iEndIndex));
                }
                //normalize text span
                if (thisFile) {
                    FixupMarkerSpan(ref span);
                } else {
                    TextSpanHelper.MakePositive(ref span);
                }
                //set options
                TaskPriority priority = TaskPriority.Normal;
                TaskCategory category = TaskCategory.BuildCompile;
                MARKERTYPE markerType = MARKERTYPE.MARKER_CODESENSE_ERROR;
                TaskErrorCategory errorCategory = TaskErrorCategory.Warning;

                if (severity == Severity.Fatal || severity == Severity.Error) {
                    priority = TaskPriority.High;
                    errorCategory = TaskErrorCategory.Error;                    
                } else if (severity == Severity.Hint) {
                    category = TaskCategory.Comments;
                    markerType = MARKERTYPE.MARKER_INVISIBLE;
                    errorCategory = TaskErrorCategory.Message;
                } else if (severity == Severity.Warning) {
                    markerType = MARKERTYPE.MARKER_COMPILE_ERROR;
                    errorCategory = TaskErrorCategory.Warning;
                }
                if (errorCategory < mostSevere) {
                    mostSevere = errorCategory;
                }

                IVsHierarchy hierarchy = thisHeirarchy;
                if (!thisFile) {
                    // must be an error reference to another file.
                    hierarchy = rdt.GetHierarchyItem(filename);
                    markerType = MARKERTYPE.MARKER_OTHER_ERROR; // indicate to CreateErrorTaskItem
                }

                bool found = false;
                while (pos < taskProvider.Tasks.Count) {
                    Task current = taskProvider.Tasks[pos];
                    if (current is DocumentTask) {
                        DocumentTask dt = (DocumentTask)current;
                        if (dt.IsMarkerValid && // marker is still valid?
                            NativeMethods.IsSamePath(current.Document, filename) && 
                            current.Text == message && TextSpanHelper.IsSameSpan(span, dt.Span) && 
                            current.Category == category && 
                            current.Priority == priority && 
                            dt.ErrorCategory == errorCategory) {
                            pos++;
                            merged++;
                            found = true;
                            // Since we're reusing the existing entry, let's make sure the line
                            // line number we are displaying the right line number information.
                            // (The DocumentTask gets out of sync with the IVsTextLineMarker because
                            // the IVsTextLineMarker is a bookmark that tracks user edits). 
                            if (dt.Column != span.iStartIndex || dt.Line != span.iStartLine) {
                                dt.Column = span.iStartIndex;
                                dt.Line = span.iStartLine;
                                taskProvider.Refresh(); // mark it as dirty.
                            }
                            break;
                        }
                    }
                    removed++;
                    taskProvider.Tasks.RemoveAt(pos);
                }
                if (!found) {
                    added++;
                    DocumentTask docTask = this.CreateErrorTaskItem(span, filename, message, priority, category, markerType, errorCategory);
                    docTask.HierarchyItem = hierarchy;
                    taskProvider.Tasks.Insert(pos, docTask);
                    pos++;
                }
                //check error count
                if (pos == errorMax) {
                    string maxMsg = SR.GetString(SR.MaxErrorsReached);
                    string localFile = this.GetFilePath();
                    span = this.GetDocumentSpan();
                    span.iStartIndex = span.iEndIndex;
                    span.iStartLine = span.iEndLine;
                    DocumentTask error = this.CreateErrorTaskItem(span, localFile, maxMsg, TaskPriority.High, TaskCategory.CodeSense, MARKERTYPE.MARKER_INVISIBLE, mostSevere);
                    error.HierarchyItem = hierarchy;
                    taskProvider.Tasks.Insert(pos, error);
                    pos++;
                    break;
                }
            }
            // remove trailing errors that should no longer exist.
            while (pos < taskProvider.Tasks.Count) {
                removed++;
                taskProvider.Tasks.RemoveAt(pos);
            }
            taskProvider.ResumeRefresh(); // batch updates.
        }

        private static ArrayList GroupBySeverity(ArrayList errors) {
            // Sort the errors by severity so that if there's more than 'max' errors, then
            // the errors actually reported are the most severe.  I do not use ArrayList.Sort 
            // because that would lose the order inherent in each group of errors provided by 
            // the language service, which is most likely some sort of parse-order which will 
            // make more sense to the user.
            ArrayList result = new ArrayList();
            foreach (Severity s in new Severity[] { Severity.Fatal, Severity.Error, Severity.Warning, Severity.Hint }) {
                foreach (ErrorNode e in errors) {
                    if (e.severity == s) {
                        result.Add(e);
                    }
                }
            }
            return result;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.RemoveTask"]/*' />
        public void RemoveTask(DocumentTask task) {
            for (int i = 0, n = this.taskProvider.Tasks.Count; i < n; i++) {
                Task current = this.taskProvider.Tasks[i];
                if (current == task) {
                    this.taskProvider.Tasks.RemoveAt(i); return;
                }
            }
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.RemoveHiddenRegions"]/*' />
        public virtual void RemoveHiddenRegions() {
            IVsHiddenTextSession session = GetHiddenTextSession();
#if PERFTRACE
            int start = Environment.TickCount;
#endif
            IVsHiddenTextSessionEx2 vsHiddenTextSessionEx2 = session as IVsHiddenTextSessionEx2;
            if (vsHiddenTextSessionEx2 != null)
            {
                vsHiddenTextSessionEx2.StopOutlining();
            }
#if PERFTRACE
            int end = Environment.TickCount;
            int diff = end - start;
            Trace.WriteLine("RemoveHiddenRegions took " + diff + " ms");
#endif            
        }

        internal void ToggleRegions() {
            IVsHiddenTextSession session = GetHiddenTextSession();
            IVsEnumHiddenRegions ppenum;
            TextSpan[] aspan = new TextSpan[1];
            aspan[0] = GetDocumentSpan();
            NativeMethods.ThrowOnFailure(session.EnumHiddenRegions((uint)FIND_HIDDEN_REGION_FLAGS.FHR_BY_CLIENT_DATA, (uint)Source.HiddenRegionCookie, aspan, out ppenum));
            uint fetched;
            bool expandAll =false;
            uint numRegions;
            ppenum.GetCount(out numRegions);
            Debug.Assert(numRegions>=0, "GetCount returned a negative number?!");
            if (!(collapsed == 0 || collapsed == numRegions)) {
                //not all regions are in the same state -- expand all
                expandAll = true;
            }
            IVsHiddenRegion[] aregion = new IVsHiddenRegion[1];
            using (new CompoundAction(this, "ToggleAllRegions")) {
                while (ppenum.Next(1, aregion, out fetched) == NativeMethods.S_OK && fetched == 1) {
                    uint dwState;
                    if (expandAll) {
                        dwState = (uint)HIDDEN_REGION_STATE.hrsExpanded;
                    } else {
                        aregion[0].GetState(out dwState);                    
                        dwState ^= (uint)HIDDEN_REGION_STATE.hrsExpanded;
                    }
                    NativeMethods.ThrowOnFailure(aregion[0].SetState(dwState,
                        (uint)CHANGE_HIDDEN_REGION_FLAGS.chrDefault));
                }
            }
        }

        internal void DisableOutlining() {
            this.OutliningEnabled = false;
            this.RemoveHiddenRegions();
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.ProcessHiddenRegions"]/*' />
        public virtual void ProcessHiddenRegions(ArrayList hiddenRegions) {

            if (!this.doOutlining) {
                return;
            }

            // Compare the existing regions with the new regions and 
            // remove any that do not match the new regions.
            IVsHiddenTextSession session = GetHiddenTextSession();
            IVsEnumHiddenRegions ppenum;
            TextSpan[] aspan = new TextSpan[1];
            aspan[0] = GetDocumentSpan();
            NativeMethods.ThrowOnFailure(session.EnumHiddenRegions((uint)FIND_HIDDEN_REGION_FLAGS.FHR_BY_CLIENT_DATA, (uint)Source.HiddenRegionCookie, aspan, out ppenum));
            uint fetched;
            IVsHiddenRegion[] aregion = new IVsHiddenRegion[1];
            int matched = 0;
            int removed = 0;
            int added = 0;

            // Create a list of IVsHiddenRegion objects, sorted in the same order that the
            // authoring sink sorts.  This is necessary because VS core editor does NOT return
            // the regions in the same order that we add them.
            ArrayList regions = new ArrayList();
            ArrayList spans = new ArrayList();

            while (ppenum.Next(1, aregion, out fetched) == NativeMethods.S_OK && fetched == 1) {
                NativeMethods.ThrowOnFailure(aregion[0].GetSpan(aspan));
                TextSpan s = aspan[0];
                int i = spans.Count - 1;
                while (i >= 0) {
                    TextSpan s2 = (TextSpan)spans[i];
                    if (TextSpanHelper.StartsAfterStartOf(s, s2))
                        break;
                    i--;
                }
                spans.Insert(i + 1, s);
                regions.Insert(i + 1, aregion[0]);
            }

            // Iterate over session hidden regions
            // Session hidden regions are the ones the editor currently knows about
            ArrayList regionsToAdd = new ArrayList();
            int iHiddenRegion = 0;
            int cHiddenRegion = hiddenRegions.Count;
            for (int i = 0; i < regions.Count; ++i)
            {
                IVsHiddenRegion sessionHiddenRegion = (IVsHiddenRegion)regions[i];
                TextSpan sessionSpan = (TextSpan)spans[i];

                // Iterate over preceeding sink hidden regions
                // Sink hidden regions are the ones which resulted from a parse
                NewHiddenRegion hiddenRegion = new NewHiddenRegion();
                while (iHiddenRegion < cHiddenRegion)
                {
                    hiddenRegion = (NewHiddenRegion)hiddenRegions[iHiddenRegion];
                    if (hiddenRegion.tsHiddenText.iStartLine >= sessionSpan.iStartLine)
                    {
                        break;
                    }

                    // Add to "ToAdd" regions (add boxed copy to avoid duplicate copies in sink and "ToAdd" collections)
                    // DevNote: Collect "ToAdd" regions rather than doing a hiddenRegions.RemoveAt() to avoid quadratic perf
                    regionsToAdd.Add(hiddenRegions[iHiddenRegion]);

                    ++iHiddenRegion;
                }

                // Check whether matching sink region
                if ((iHiddenRegion < cHiddenRegion) &&
                    TextSpanHelper.IsSameSpan(hiddenRegion.tsHiddenText, sessionSpan) &&
                    HasSameBanner(hiddenRegion, sessionHiddenRegion))
                {
                    // Match (and continue)
                    ++matched;
                    ++iHiddenRegion;
                }
                else
                {
                    // Remove from session (and continue)
                    NativeMethods.ThrowOnFailure(sessionHiddenRegion.Invalidate((int)CHANGE_HIDDEN_REGION_FLAGS.chrNonUndoable));
                    ++removed;
                }
            }

            // Add following sink hidden regions to "ToAdd" regions
            if (iHiddenRegion < cHiddenRegion)
            {
                regionsToAdd.AddRange(hiddenRegions.GetRange(iHiddenRegion, (cHiddenRegion - iHiddenRegion)));
            }

            // Populate given hidden region collection with regions to add
            // DevNote:  This side effect existed in an earlier quadratic algorithm based on removing from
            // the given collection using hiddenRegions.RemoveAt().  Some VSIP may depend on this side effect
            hiddenRegions.Clear();
            hiddenRegions.AddRange(regionsToAdd);

            int start = Environment.TickCount;
            int count = hiddenRegions.Count;
            int iRegion = 0;
            if (count > 0) {
                // For very large documents this can take a while, so add them in chunks of 
                // 1000 and stop after 5 seconds. 
                int maxTime = this.LanguageService.Preferences.MaxRegionTime;
                int chunkSize = 1000;
                NewHiddenRegion[] chunk = new NewHiddenRegion[chunkSize];
                while (iRegion < count && TimeUtilities.TimeSince(start) < maxTime)
                {
                    int j = 0;
                    NewHiddenRegion r;
                    while (iRegion < count && j < chunkSize)
                    {
                        r = (NewHiddenRegion)hiddenRegions[iRegion];
                        if (!TextSpanHelper.ValidSpan(this, r.tsHiddenText)) {
#if	LANGTRACE
                            Debug.Assert(false, "Invalid span " + r.tsHiddenText.iStartLine + "," + r.tsHiddenText.iStartIndex + "," + r.tsHiddenText.iEndLine + "," + r.tsHiddenText.iEndIndex);
#endif
                            break;
                        } else {
                            chunk[j] = r;
                            added++;
                        }
                        iRegion++;
                        j++;
                    }
                    int hr = session.AddHiddenRegions((int)CHANGE_HIDDEN_REGION_FLAGS.chrNonUndoable, j, chunk, null);
                    if (NativeMethods.Failed(hr)) {
                        break; // stop adding if we start getting errors.
                    }
                }
            }

            // Check whether all hidden regions processed
            if (iRegion == count)
            {
                // Depersist outlining (only once)
                if (!haveDepersistedOutlining)
                {
                    haveDepersistedOutlining = true;
                    IVsTextViewEx view = this.service.GetPrimaryViewForSource(this) as IVsTextViewEx;
                    if (view != null)
                    {
                        view.PersistOutliningState();
                    }
                }
            }

#if	PERFTRACE
            int diff = TimeUtilities.TimeSince(start);
            Trace.WriteLine(String.Format(CultureInfo.InvariantCulture, "Hidden Regions: Matched={0}, Removed={1}, Addded={2}/{3} in {4} ms", matched, removed, added, hiddenRegions.Count, diff));
#endif
        }

        //Banner comparison: in the case of editor controlled region, this is a noop
        //otherwise, compare banners
        //caveat is that GetBanner rountrips null to "...".
        private bool HasSameBanner(NewHiddenRegion r,IVsHiddenRegion region){
            uint behavior;
            region.GetBehavior(out behavior);
            if (behavior == (uint)HIDDEN_REGION_BEHAVIOR.hrbEditorControlled && r.dwBehavior == (uint)HIDDEN_REGION_BEHAVIOR.hrbEditorControlled)
            {
                return true; //the banner text is always a fixed string, which is "..." by default
            }
            string currBanner;
            region.GetBanner(out currBanner);
            //<STRIP>DevDiv185498: Regression from RTM: Collapsed portions of XAML do not stay collapsed</STRIP>
            return r.pszBanner == currBanner || (r.pszBanner == null && currBanner == "...");
        }
        

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.GetHiddenTextSession"]/*' />
        public IVsHiddenTextSession GetHiddenTextSession() {
            if (this.hiddenTextSession == null) {
                IVsHiddenTextManager htextmgr = service.Site.GetService(typeof(SVsTextManager)) as IVsHiddenTextManager;
                if (htextmgr != null) {
                    IVsHiddenTextSession session = null;
                    int hr = htextmgr.GetHiddenTextSession(textLines, out session);
                    if (hr == NativeMethods.E_FAIL) {
                        // Then there was no hidden text session.
                        NativeMethods.ThrowOnFailure(htextmgr.CreateHiddenTextSession(0, textLines, this, out session));
                    }
                    this.hiddenTextSession = session;
                }
            }
            return this.hiddenTextSession;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.OutliningEnabled"]/*' />
        public virtual bool OutliningEnabled {
            get {
                return this.doOutlining;
            }
            set {
                if (this.doOutlining != value) {
                    this.doOutlining = value;
                    if (value) {
                        this.IsDirty = true;
                        // force reparse as soon as possible.
                        this.dirtyTime = Math.Max(0, this.dirtyTime - this.service.Preferences.CodeSenseDelay);
                    }
                }
            }
        }

        #region IVsHiddenTextClient
        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.OnHiddenRegionChange"]/*' />
        public virtual void OnHiddenRegionChange(IVsHiddenRegion region, HIDDEN_REGION_EVENT evt, int fBufferModifiable) {
            if (evt == HIDDEN_REGION_EVENT.hreAfterRegionCollapsed) {
                collapsed++;
            } else if (evt == HIDDEN_REGION_EVENT.hreAfterRegionExpanded) {
                collapsed--;
            }
        }

        private const int lineCountLimitForGetTipText = 200;
        private const int lineLengthLimitForGetTipText = 600;

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.GetTipText"]/*' />
        public virtual int GetTipText(IVsHiddenRegion region, string[] result) {
            if (result != null && result.Length > 0) {
                TextSpan[] aspan = new TextSpan[1];
                NativeMethods.ThrowOnFailure(region.GetSpan(aspan));

                // Limit lines.
                TextSpan span = aspan[0];
                int spanLineCount = span.iEndLine - span.iStartLine + 1;
                bool truncated = spanLineCount > lineCountLimitForGetTipText;
                StringBuilder stringBuilder =
                    GetLineSpans(span)
                        .Take(lineCountLimitForGetTipText)
                        .Select(s => LimitLineSpan(s, lineLengthLimitForGetTipText))
                        .Select(lineSpan => this.GetText(lineSpan.span) + (lineSpan.truncated ? "..." : String.Empty))
                        .Aggregate(new StringBuilder(), (sb, lineText) => sb.AppendLine(lineText));

                result[0] = stringBuilder.ToString() + (truncated ? " ..." : String.Empty);
            }
            return NativeMethods.S_OK;
        }

        private struct LineSpan { internal TextSpan span; internal bool truncated; }

        private LineSpan LimitLineSpan(TextSpan span, int lineLengthLimit)
        {
            Debug.Assert(span.iStartLine == span.iEndLine);
            var length = span.iEndIndex - span.iStartIndex;
            if (length <= lineLengthLimit)
            {
                return new LineSpan { span = span, truncated = false };
            }
            else
            {
                return new LineSpan()
                {
                    span = new TextSpan()
                    {
                        iStartIndex = span.iStartIndex,
                        iStartLine = span.iStartLine,
                        iEndIndex = span.iStartIndex + lineLengthLimit,
                        iEndLine = span.iEndLine
                    },
                    truncated = true
                };
            }
        }

        private IEnumerable<TextSpan> GetLineSpans(TextSpan span)
        {
            yield return new TextSpan()
            {
                iStartLine = span.iStartLine,
                iStartIndex = span.iStartIndex,
                iEndLine = span.iStartLine,
                iEndIndex = (span.iStartLine == span.iEndLine) ? span.iEndIndex : this.GetLineLength(span.iStartLine)
            };

            for(var lineIndex = span.iStartLine + 1; lineIndex <= span.iEndLine - 1; lineIndex++)
                yield return new TextSpan()
                {
                    iStartLine = lineIndex,
                    iStartIndex = 0,
                    iEndLine = lineIndex,
                    iEndIndex = this.GetLineLength(lineIndex)
                };

            if (span.iStartLine != span.iEndLine)
            {
                yield return new TextSpan()
                {
                    iStartLine = span.iEndLine,
                    iStartIndex = 0,
                    iEndLine = span.iEndLine,
                    iEndIndex = span.iEndIndex
                };
            }
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.GetMarkerCommandInfo"]/*' />
        public virtual int GetMarkerCommandInfo(IVsHiddenRegion region, int item, string[] outText, uint[] flags) {
            if (flags != null && flags.Length > 0)
                flags[0] = 0;
            if (outText != null && outText.Length > 0)
                outText[0] = null;
            return NativeMethods.E_NOTIMPL;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.ExecMarkerCommand"]/*' />
        public virtual int ExecMarkerCommand(IVsHiddenRegion region, int cmd) {
            return NativeMethods.E_NOTIMPL;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.MakeBaseSpanVisible"]/*' />
        public virtual int MakeBaseSpanVisible(IVsHiddenRegion region, TextSpan[] span) {
            return NativeMethods.E_NOTIMPL;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.OnBeforeSessionEnd"]/*' />
        public virtual void OnBeforeSessionEnd() {
        }
        #endregion

        #region IVsUserDataEvents Members

        /// <include file='doc\Source.uex' path='docs/doc[@for="Source.OnUserDataChange"]/*' />
        public virtual void OnUserDataChange(ref Guid riidKey, object vtNewValue) {
        }

        #endregion

    }

    // This class gathers pseudo-keystrokes and applies the cumulative changes to the IVsTextLines buffer.
    // and also records them in case macro recording is on.  It also wraps the edits in 
    // an IVsCompoundAction.
    /// <include file='doc\Source.uex' path='docs/doc[@for="Completor"]/*' />
    [CLSCompliant(false)]
    public class Completor : IDisposable {
        internal LanguageService langsvc;
        internal IVsTextView view;
        internal Source src;
        internal StringBuilder sb;
        internal int caret;
        internal int lineLength;
        internal TextSpan span;
        internal IVsTextMacroHelper macro;
        internal string line;
        internal CompoundActionBase ca;

        /// <include file='doc\Source.uex' path='docs/doc[@for="Completor.Completor"]/*' />
        public Completor(LanguageService langsvc, IVsTextView view, string description) {
            this.langsvc = langsvc;
            this.view = view;
            this.src = langsvc.GetSource(view);
            this.sb = new StringBuilder();
            this.caret = 0; // current position within StringBuilder.
            this.ca = CompoundActionFactory.GetCompoundAction(null, this.src, description);
            this.ca.FlushEditActions(); // make sure we see a consistent coordinate system.
            // initialize span representing what we are removing from the buffer.
            NativeMethods.ThrowOnFailure(view.GetCaretPos(out span.iStartLine, out span.iStartIndex));
            this.span.iEndLine = span.iStartLine;
            this.span.iEndIndex = span.iStartIndex;
            RefreshLine();

            macro = this.langsvc.GetIVsTextMacroHelperIfRecordingOn();
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Completor.IsExpansionActive"]/*' />
        public bool IsExpansionActive {
            get {
                ExpansionProvider ep = src.GetExpansionProvider();
                return (ep != null && ep.InTemplateEditingMode);
            }
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Completor.RefreshLine"]/*' />
        public void RefreshLine() {
            this.line = this.src.GetLine(span.iStartLine);
            this.lineLength = src.GetLineLength(span.iStartLine);
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Completor.Dispose"]/*' />
        /// <summary>This method calls Apply() if you have not already done it.</summary>
        public void Dispose() {
            if (this.ca != null) {
                Apply();
            }
            // DO NOT DISPOSE THE LANGUAGE SERVICE HERE -- WE DON'T OWN IT!!!
            this.langsvc = null;
            this.macro = null;
            this.view = null;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Completor.Apply"]/*' />
        public void Apply() {
            string text = sb.ToString();
            NativeMethods.ThrowOnFailure(view.ReplaceTextOnLine(span.iStartLine, span.iStartIndex, span.iEndIndex - span.iStartIndex, text, text.Length));
            this.ca.Close(); // make sure we see a consistent coordinate system.
            this.ca = null;
            // move caret position
            // todo: what if a newline was typed (e.g. an attribute value enumeration contains a new line) ??
            NativeMethods.ThrowOnFailure(view.SetCaretPos(span.iStartLine, span.iStartIndex + caret));
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Completor.TypeChar"]/*' />
        public void TypeChar(char ch) {
            if (caret >= sb.Length) {
                sb.Append(ch);
            } else {
                sb.Insert(caret, ch);
            }
            caret++;

            // record caret movement for correct macro handling.
            if (macro != null) {
                ushort u = Convert.ToUInt16(ch);
                macro.RecordTypeChar(u, 0);
            }
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Completor.TypeChars"]/*' />
        public void TypeChars(string s) {
            if (caret >= sb.Length) {
                sb.Append(s);
            } else {
                sb.Insert(caret, s);
            }
            caret += s.Length;

            if (macro != null) {
                macro.RecordTypeChars(s, 0);
            }
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Completor.TypeLeft"]/*' />
        public void TypeLeft(int len) {
            int i = span.iStartIndex + caret - len;
            Debug.Assert(i >= 0 && i <= this.lineLength + sb.Length); // must still be on the current line.
            if (i < 0) len = span.iStartIndex + caret; // pin 

            if (this.caret < len) {
                if (sb.Length == 0) {
                    // In this case we can just move our span window to the left.
                    span.iStartIndex -= len;
                    span.iEndIndex -= len;
                } else {
                    // We need to expand our buffer to the left to include what is on the line
                    // so that our Apply() method can put that text back correctly (since this
                    // class currently only supports one overall edit on the line.
                    // todo: add support for the recording multiple discontiguous edits.
                    int diff = len - this.caret;
                    this.sb.Insert(0, line.Substring(span.iStartIndex - diff, diff));
                    span.iStartIndex -= diff;
                    this.caret = 0;
                }
            } else {
                this.caret -= len;
            }
            if (macro != null) {
                while (len-- > 0) {
                    macro.RecordMoveSelectionRel(MOVESELECTION_REL_TYPE.MOVESELECTION_REL_CHARACTER, 1, 0);
                }
            }
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Completor.AtEndOfLine"]/*' />
        public bool AtEndOfLine {
            get { return span.iStartIndex + caret == sb.Length + this.lineLength; }
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Completor.TypeRight"]/*' />
        public void TypeRight(int len) {
            int i = span.iStartIndex + caret + len;
            int length = sb.Length + this.lineLength;
            Debug.Assert(i <= length); // must still be on the current line.
            if (i > length) len = length - (span.iStartIndex + caret); // pin 
            if (len <= 0) return; // NOP

            if (this.caret + len > sb.Length) {
                if (sb.Length == 0) {
                    // In this case we can just move our span window to the right.
                    span.iStartIndex += len;
                    span.iEndIndex += len;
                } else {
                    // Need to expand out StringBuilder with text to the right of the current position.
                    int diff = (this.caret + len) - sb.Length;
                    sb.Append(line.Substring(span.iEndIndex, diff));
                    span.iEndIndex += diff;
                    this.caret = sb.Length;
                }
            } else {
                this.caret += len;
            }
            if (macro != null) {
                while (len-- > 0) {
                    macro.RecordMoveSelectionRel(MOVESELECTION_REL_TYPE.MOVESELECTION_REL_CHARACTER, 0, 0);
                }
            }
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Completor.TypeBackspace"]/*' />
        public void TypeBackspace(int len) {
            int i = span.iStartIndex + caret - len;
            Debug.Assert(i >= 0); // must still be on the current line.
            if (i < 0) len = span.iStartIndex + caret; // pin

            caret -= len;
            if (caret < 0) {
                // replace chars in the buffer 
                Debug.Assert(span.iStartIndex > -caret);
                span.iStartIndex += caret;
                caret = 0;
            }

            if (macro != null) {
                macro.RecordDelete(1, (uint)len);
            }
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="Completor.TypeDelete"]/*' />
        public void TypeDelete(int len) {
            if (caret < sb.Length) {
                int delta = sb.Length - caret;
                len -= delta;
                sb.Remove(caret, delta);
            }
            if (len > 0) {
                // replace chars in the buffer 
                Debug.Assert(span.iEndIndex + len <= this.lineLength);
                if (span.iEndIndex + len > this.lineLength) {
                    len = this.lineLength - span.iEndIndex; // pin.
                }
                span.iEndIndex += len;
            }

            if (macro != null) {
                macro.RecordDelete(0, (uint)len);
            }
        }
    }

    public class CompoundActionBase : IDisposable {
        [CLSCompliant(false)]
        protected IVsCompoundAction action;
        protected bool opened;

        public CompoundActionBase() {
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="CompoundActionBase.FlushEditActions"]/*' />
        public virtual void FlushEditActions() {
            // in case there is already a compound action under way, this enables the caller
            // to see a consistent view coordinate system.
            action.FlushEditActions(); // sometimes returns E_NOTIMPL and this is expected!            
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="CompoundActionBase.Dispose"]/*' />
        /// <summary>This method calls Close if you have not already called Close</summary>
        public void Dispose() {
            Close();
        }
        /// <include file='doc\Source.uex' path='docs/doc[@for="CompoundActionBase.Close"]/*' />
        public virtual void Close() {
            if (opened && action != null) {
                int hr = action.CloseCompoundAction();
                if (!VSErrorHandler.Succeeded(hr)) {
                    Trace.WriteLine("CloseCompoundAction failed!");
                }
                action = null;
                opened = false;
            }
        }
        /// <include file='doc\Source.uex' path='docs/doc[@for="CompoundActionBase.Abort"]/*' />
        public virtual void Abort() {
            if (opened && action != null) {
                int hr = action.AbortCompoundAction();
                if (!VSErrorHandler.Succeeded(hr)) {
                    Trace.WriteLine("AbortCompoundAction failed!");
                }
                action = null;
                opened = false;
            }
        }
    }

    /// <include file='doc\Source.uex' path='docs/doc[@for="CompoundAction"]/*' />
    /// <summary>
    /// This class can be used in a using statement to open and close a compound edit action
    /// via IVsCompoundAction interface.  Be sure to call Close() at the end of your using
    /// statement, otherwise Dispose will call Abort.
    /// </summary>
    [CLSCompliant(false)]
    public class CompoundAction : CompoundActionBase {
        Source src;
        Colorizer colorizer;

        /// <include file='doc\Source.uex' path='docs/doc[@for="CompoundAction.CompoundAction2"]/*' />
        public CompoundAction(Source src, string description):base() {
            this.opened = false;
            this.src = src;
            this.action = (IVsCompoundAction)src.GetTextLines();
            if (this.action == null) {
                throw new ArgumentNullException("(IVsCompoundAction)src.GetTextLines()");
            }
            NativeMethods.ThrowOnFailure(action.OpenCompoundAction(description));
            this.opened = true;
            this.colorizer = src.GetColorizer();
            if (colorizer != null) colorizer.Suspend(); // batch colorization            
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="CompoundAction.FlushEditActions"]/*' />
        public override void FlushEditActions() {
            // in case there is already a compound action under way, this enables the caller
            // to see a consistent buffer coordinate system.
            int hr = action.FlushEditActions(); 
            Debug.Assert(VSConstants.E_NOTIMPL == hr, "Use CompoundViewAction - this does nothing");
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="CompoundAction.Close"]/*' />
        public override void Close() {
            if (opened && action != null) {
                base.Close();
                ResumeColorization();
            }
        }
        /// <include file='doc\Source.uex' path='docs/doc[@for="CompoundAction.Abort"]/*' />
        public override void Abort() {
            if (opened && action != null) {
                base.Abort();
                ResumeColorization(); // batch colorization
            }
        }

        void ResumeColorization() {
            if (colorizer != null) {
                colorizer.Resume(); // batch colorization
                TextSpan span = src.DirtySpan;
                int start = span.iStartLine;
                int end = span.iEndLine;
                src.Recolorize(start, end);
                colorizer = null;
            }
        }
    }

    /// <include file='doc\Source.uex' path='docs/doc[@for="CompoundAction"]/*' />
    /// <summary>
    /// This class can be used in a using statement to open and close a compound edit action
    /// via IVsCompoundAction interface from an IVsTextView.  This allows the view to optimize 
    /// it's updates based on edits you are making on the buffer, so it's the preferred way of
    /// doing things if you have access to the IVsTextView.  If not, use CompoundAction.
    /// </summary>
    [CLSCompliant(false)]
    public class CompoundViewAction : CompoundActionBase {
        /// <include file='doc\Source.uex' path='docs/doc[@for="CompoundViewAction.CompoundViewAction"]/*' />
        public CompoundViewAction(IVsTextView view, string description):base() {
            opened = false;
            action = (IVsCompoundAction)view;
            if (this.action == null) {
                throw new ArgumentNullException("(IVsCompoundAction)view");
            }
            NativeMethods.ThrowOnFailure(action.OpenCompoundAction(description));
            opened = true;
           // action.FlushEditActions();
        }

    }


    //==================================================================================
    /// <include file='doc\Source.uex' path='docs/doc[@for="CompletionSet"]/*' />
    [CLSCompliant(false)]
    public class CompletionSet : IVsCompletionSet, IVsCompletionSetEx, IDisposable {
        ImageList imageList;
        bool displayed;
        bool completeWord;
        string committedWord;
        char commitChar;
        int commitIndex;
        IVsTextView textView;
        Declarations decls;
        Source source;
        TextSpan initialExtent;
        bool isCommitted;
        bool wasUnique;

        /// <include file='doc\Source.uex' path='docs/doc[@for="CompletionSet.CompletionSet"]/*' />
        public CompletionSet(ImageList imageList, Source source) {
            this.imageList = imageList;
            this.source = source;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="CompletionSet.IsDisplayed"]/*' />
        public bool IsDisplayed {
            get {
                return this.displayed;
            }
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="CompletionSet.IsCommitted"]/*' />
        public bool IsCommitted {
            get {
                return this.isCommitted;
            }
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="CompletionSet.OnCommitText"]/*' />
        public string OnCommitText {
            get {
                return this.committedWord;
            }
        }
        /// <include file='doc\Source.uex' path='docs/doc[@for="CompletionSet.Init"]/*' />
        public virtual void Init(IVsTextView textView, Declarations declarations, bool completeWord) {
            Close();
            this.textView = textView;
            this.Declarations = declarations;
            this.completeWord = completeWord;

            //check if we have members
            long count = decls.GetCount();
            if (count <= 0) return;

            //initialise and refresh      
            UpdateCompletionFlags flags = UpdateCompletionFlags.UCS_NAMESCHANGED;

            if (this.completeWord) flags |= UpdateCompletionFlags.UCS_COMPLETEWORD;

            this.wasUnique = false;

            int hr = textView.UpdateCompletionStatus(this, (uint)flags);
            NativeMethods.ThrowOnFailure(hr);

            this.displayed = (!this.wasUnique || !completeWord);
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="CompletionSet.Dispose"]/*' />
        public virtual void Dispose() {
            Close();
            if (imageList != null) imageList.Dispose();
            this.imageList = null;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="CompletionSet.Close"]/*' />
        public virtual void Close() {
            if (this.displayed && this.textView != null) {
                // Here we can't throw or exit because we need to call Dispose on
                // the disposable membres.
                try {
                    textView.UpdateCompletionStatus(null, 0);
                } catch (COMException) {
                }
            }
            this.displayed = false;
            this.textView = null;
            this.Declarations = null;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="CompletionSet.Declarations"]/*' />
        public Declarations Declarations {
            get { return this.decls; }
            set {
                if (this.decls != null && this.decls != value) {
                    this.decls.Dispose();
                }
                this.decls = value;
            }
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="CompletionSet.OnAutoComplete"]/*' />
        public virtual char OnAutoComplete() {
            this.isCommitted = false;
            if (this.decls != null) {
                return this.decls.OnAutoComplete(this.textView, this.committedWord, this.commitChar, this.commitIndex);
            }
            return '\0';
        }

        #region IVsCompletionSet
        //--------------------------------------------------------------------------
        //IVsCompletionSet methods
        //--------------------------------------------------------------------------
        /// <include file='doc\Source.uex' path='docs/doc[@for="CompletionSet.GetImageList"]/*' />
        public virtual int GetImageList(out IntPtr phImages) {
            phImages = this.imageList.Handle;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="CompletionSet.GetFlags"]/*' />
        public virtual uint GetFlags() {
            return (uint)UpdateCompletionFlags.CSF_HAVEDESCRIPTIONS | (uint)UpdateCompletionFlags.CSF_CUSTOMCOMMIT | (uint)UpdateCompletionFlags.CSF_INITIALEXTENTKNOWN | (uint)UpdateCompletionFlags.CSF_CUSTOMMATCHING;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="CompletionSet.GetCount"]/*' />
        public virtual int GetCount() {
            return this.decls.GetCount();
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="CompletionSet.GetDisplayText"]/*' />
        public int GetDisplayText(int index, out string text, int[] glyph) {
            if (glyph != null) {
                glyph[0] = this.decls.GetGlyph(index);
            }
            text = this.decls.GetDisplayText(index);
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="CompletionSet.GetDescriptionText"]/*' />
        public int GetDescriptionText(int index, out string description) {
            description = this.decls.GetDescription(index);
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="CompletionSet.GetInitialExtent"]/*' />
        public virtual int GetInitialExtent(out int line, out int startIdx, out int endIdx) {

            int hr = NativeMethods.S_OK;
            if (this.decls.GetInitialExtent(this.textView, out line, out startIdx, out endIdx)) {
                goto done;
            }

            int idx;
            this.initialExtent = new TextSpan();

            NativeMethods.ThrowOnFailure(this.textView.GetCaretPos(out line, out idx));
#if	TRACE_PARSING
            Trace.WriteLine("GetInitialExtent at " + line + "," + idx);
#endif
            hr = GetTokenExtent(line, idx, out startIdx, out endIdx);

        done:
            // Remember the initial extent so we can pass it along on the commit.
            this.initialExtent.iStartLine = this.initialExtent.iEndLine = line;
            this.initialExtent.iStartIndex = startIdx;
            this.initialExtent.iEndIndex = endIdx;

            Debug.Assert(TextSpanHelper.ValidCoord(this.source, line, startIdx) &&
                TextSpanHelper.ValidCoord(this.source, line, endIdx));
            return hr;
        }

        int GetTokenExtent(int line, int idx, out int startIdx, out int endIdx) {
            int hr = VSConstants.S_OK;
            bool rc = this.source.GetWordExtent(line, idx, Source.WholeToken, out startIdx, out endIdx);
            // make sure the span is positive.
            endIdx = Math.Max(startIdx, endIdx);

            if (!rc && idx > 0) {
                rc = this.source.GetWordExtent(line, idx - 1, Source.WholeToken, out startIdx, out endIdx);
                if (!rc) {
                    // Must stop core text editor from looking at startIdx and endIdx since they are likely
                    // invalid.  So we must return a real failure here, not just S_FALSE.
                    startIdx = endIdx = idx;
                    hr = VSConstants.E_NOTIMPL;
                } else {
                    endIdx = Math.Max(endIdx, idx);
                }
            }
            return hr;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="CompletionSet.GetBestMatch"]/*' />
        public virtual int GetBestMatch(string textSoFar, int length, out int index, out uint flags) {
            flags = 0;
            index = 0;
#if	TRACE_PARSING
            Trace.WriteLine("GetBestMatch '" + textSoFar + "'");
#endif

            bool uniqueMatch = false;
            if (textSoFar.Length != 0) {
                this.decls.GetBestMatch(textSoFar, out index, out uniqueMatch);
                if (index < 0 || index >= GetCount()) {
                    index = 0;
                    uniqueMatch = false;
                } else {
                    // Indicate that we want to select something in the list.
                    flags = (uint)UpdateCompletionFlags.GBM_SELECT;
                }
            } else if (GetCount() == 1 && this.completeWord) {
                // Only one entry, and user has invoked "word completion", then
                // simply select this item.
                index = 0;
                flags = (uint)UpdateCompletionFlags.GBM_SELECT;
                uniqueMatch = true;
            }
            if (uniqueMatch) {
                flags |= (uint)UpdateCompletionFlags.GBM_UNIQUE;
                this.wasUnique = true;
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="CompletionSet.OnCommit"]/*' />
        public virtual int OnCommit(string textSoFar, int index, int selected, ushort commitChar, out string completeWord) {
            char ch = (char)commitChar;
            bool isCommitChar = true;
#if	TRACE_PARSING
            Trace.WriteLine("OnCommit '" + textSoFar + "'," + index + "," + selected + "," + commitChar.ToString(CultureInfo.CurrentUICulture));
#endif
            if (commitChar != 0) {
                // if the char is in the list of given member names then obviously it
                // is not a commit char.
                int i = (textSoFar == null) ? 0 : textSoFar.Length;
                for (int j = 0, n = decls.GetCount(); j < n; j++) {
                    string name = decls.GetName(j);
                    if (name.Length > i && name[i] == commitChar) {
                        if (i == 0 || String.Compare(name.Substring(0, i), textSoFar, true, CultureInfo.CurrentUICulture) == 0) {
                            goto nocommit; // cannot be a commit char if it is an expected char in a matching name
                        }
                    }
                }
                isCommitChar = this.decls.IsCommitChar(textSoFar, (selected == 0) ? -1 : index, ch);
            }

            completeWord = textSoFar;
            if (isCommitChar) {
                if (selected == 0) index = -1;
                this.committedWord = completeWord = this.decls.OnCommit(this.textView, textSoFar, ch, index, ref this.initialExtent);
                this.commitChar = ch;
                this.commitIndex = index;
                this.isCommitted = true;
                return NativeMethods.S_OK;
            }
        nocommit:
            // S_FALSE return means the character is not a commit character.
            completeWord = textSoFar;
            return NativeMethods.S_FALSE;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="CompletionSet.Dismiss"]/*' />
        public virtual void Dismiss() {
            this.displayed = false;
        }
        #endregion

        #region IVsCompletionSetEx Members

        public virtual int CompareItems(string bstrSoFar, string bstrOther, int lCharactersToCompare, out int plResult) {
            plResult = 0;
            return NativeMethods.E_NOTIMPL;
        }

        public virtual int IncreaseFilterLevel(int iSelectedItem) {
            return NativeMethods.E_NOTIMPL;
        }

        public virtual int DecreaseFilterLevel(int iSelectedItem) {
            return NativeMethods.E_NOTIMPL;
        }

        public virtual int GetCompletionItemColor(int iIndex, out uint dwFGColor, out uint dwBGColor) {
            dwFGColor = dwBGColor = 0;
            return NativeMethods.E_NOTIMPL;
        }

        public virtual int GetFilterLevel(out int iFilterLevel) {
            iFilterLevel = 0;
            return NativeMethods.E_NOTIMPL;
        }

        public virtual int OnCommitComplete() {
            CodeWindowManager mgr = this.source.LanguageService.GetCodeWindowManagerForView(this.textView);
            if (mgr != null) {
                ViewFilter filter = mgr.GetFilter(this.textView);
                if (filter != null) {
                    filter.OnAutoComplete();
                }
            }
            return NativeMethods.S_OK;
        }

        #endregion
    }

    //-------------------------------------------------------------------------------------
    /// <include file='doc\Source.uex' path='docs/doc[@for="MethodData"]/*' />
    [CLSCompliant(false)]
    public class MethodData : IVsMethodData, IDisposable {
        IServiceProvider provider;
        IVsMethodTipWindow methodTipWindow;
        Methods methods;
        int currentParameter;
        int currentMethod;
        bool displayed;
        IVsTextView textView;
        TextSpan context;

        /// <include file='doc\Source.uex' path='docs/doc[@for="MethodData.MethodData"]/*' />
        public MethodData(IServiceProvider site) {
            this.provider = site;
            Microsoft.VisualStudio.Shell.Package pkg = (Microsoft.VisualStudio.Shell.Package)site.GetService(typeof(Microsoft.VisualStudio.Shell.Package));
            if (pkg == null) {
                throw new NullReferenceException(typeof(Microsoft.VisualStudio.Shell.Package).FullName);
            }
            Guid riid = typeof(IVsMethodTipWindow).GUID;
            Guid clsid = typeof(VsMethodTipWindowClass).GUID;
            this.methodTipWindow = (IVsMethodTipWindow)pkg.CreateInstance(ref clsid, ref riid, typeof(IVsMethodTipWindow));
            if (this.methodTipWindow != null) {
                NativeMethods.ThrowOnFailure(methodTipWindow.SetMethodData(this));
            }
        }
        /// <include file='doc\Source.uex' path='docs/doc[@for="MethodData.Provider;"]/*' />
        protected IServiceProvider Provider {
            get { return this.provider; }
            set { this.provider = value; }
        }
        /// <include file='doc\Source.uex' path='docs/doc[@for="MethodData.MethodTipWindow;"]/*' />
        protected IVsMethodTipWindow MethodTipWindow {
            get { return this.methodTipWindow; }
            set { this.methodTipWindow = value; }
        }
        /// <include file='doc\Source.uex' path='docs/doc[@for="MethodData.Methods;"]/*' />
        protected Methods Methods {
            get { return this.methods; }
            set { this.methods = value; }
        }
        /// <include file='doc\Source.uex' path='docs/doc[@for="MethodData.TextView;"]/*' />
        protected IVsTextView TextView {
            get { return this.textView; }
            set { this.textView = value; }
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="MethodData.IsDisplayed"]/*' />
        public bool IsDisplayed {
            get {
                return this.displayed;
            }
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="MethodData.Refresh"]/*' />
        public void Refresh(IVsTextView textView, Methods methods, int currentParameter, TextSpan context) {
            if (!this.displayed) {
                this.currentMethod = methods.DefaultMethod;
            }
            this.methods = methods;
            this.context = context;

            // Apparently this Refresh() method is called as a result of event notification
            // after the currentMethod is changed, so we do not want to Dismiss anything or
            // reset the currentMethod here. 
            //Dismiss();  
            this.textView = textView;
            this.methods = methods;

            this.currentParameter = currentParameter;
            this.AdjustCurrentParameter(0);
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="MethodData.AdjustCurrentParameter"]/*' />
        public void AdjustCurrentParameter(int increment) {
            this.currentParameter += increment;
            if (this.currentParameter < 0)
                this.currentParameter = -1;
            else if (this.currentParameter >= this.GetParameterCount(this.currentMethod))
                this.currentParameter = this.GetParameterCount(this.currentMethod);

            this.UpdateView();
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="MethodData.Close"]/*' />
        public void Close() {
            this.Dismiss();
            this.textView = null;
            this.methods = null;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="MethodData.Dismiss"]/*' />
        public void Dismiss() {
            if (this.displayed && this.textView != null) {
                NativeMethods.ThrowOnFailure(this.textView.UpdateTipWindow(this.methodTipWindow, (uint)TipWindowFlags.UTW_DISMISS));
            }

            this.OnDismiss();
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="MethodData.Dispose"]/*' />
        public virtual void Dispose() {
            Close();
            if (this.methodTipWindow != null)
                NativeMethods.ThrowOnFailure(this.methodTipWindow.SetMethodData(null));
            this.methodTipWindow = null;
            this.provider = null;
        }

        //========================================================================
        //IVsMethodData
        /// <include file='doc\Source.uex' path='docs/doc[@for="MethodData.GetOverloadCount"]/*' />
        public int GetOverloadCount() {
            if (this.textView == null || this.methods == null) return 0;
            return this.methods.GetCount();
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="MethodData.GetCurMethod"]/*' />
        public int GetCurMethod() {
            return this.currentMethod;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="MethodData.NextMethod"]/*' />
        public int NextMethod() {
            if (this.currentMethod < GetOverloadCount() - 1) this.currentMethod++;

            return this.currentMethod;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="MethodData.PrevMethod"]/*' />
        public int PrevMethod() {
            if (this.currentMethod > 0) this.currentMethod--;

            return this.currentMethod;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="MethodData.GetParameterCount"]/*' />
        public int GetParameterCount(int method) {
            if (this.methods == null) return 0;

            if (method < 0 || method >= GetOverloadCount()) return 0;

            return this.methods.GetParameterCount(method);
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="MethodData.GetCurrentParameter"]/*' />
        public int GetCurrentParameter(int method) {
            return this.currentParameter;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="MethodData.OnDismiss"]/*' />
        public void OnDismiss() {
            this.textView = null;
            this.methods = null;
            this.currentMethod = 0;
            this.currentParameter = 0;
            this.displayed = false;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="MethodData.UpdateView"]/*' />
        public void UpdateView() {
            if (this.textView != null) {
                NativeMethods.ThrowOnFailure(this.textView.UpdateTipWindow(this.methodTipWindow, (uint)TipWindowFlags.UTW_CONTENTCHANGED | (uint)TipWindowFlags.UTW_CONTEXTCHANGED));
                this.displayed = true;
            }
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="MethodData.GetContextStream"]/*' />
        public int GetContextStream(out int pos, out int length) {
            pos = 0;
            length = 0;
            int line, idx;
            NativeMethods.ThrowOnFailure(this.textView.GetCaretPos(out line, out idx));
            line = Math.Max(line, this.context.iStartLine);
            int vspace;
            NativeMethods.ThrowOnFailure(this.textView.GetNearestPosition(line, this.context.iStartIndex, out pos, out vspace));
            line = Math.Max(line, this.context.iEndLine);
            int endpos;
            NativeMethods.ThrowOnFailure(this.textView.GetNearestPosition(line, this.context.iEndIndex, out endpos, out vspace));
            length = endpos - pos;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="MethodData.GetMethodText"]/*' />
        public IntPtr GetMethodText(int method, MethodTextType type) {
            if (this.methods == null) return IntPtr.Zero;

            if (method < 0 || method >= GetOverloadCount()) return IntPtr.Zero;

            string result = null;

            //a type
            if ((type == MethodTextType.MTT_TYPEPREFIX && this.methods.TypePrefixed) ||
                (type == MethodTextType.MTT_TYPEPOSTFIX && !this.methods.TypePrefixed)) {
                string str = this.methods.GetType(method);

                if (str == null) return IntPtr.Zero;

                result = this.methods.TypePrefix + str + this.methods.TypePostfix;
            } else {
                //other
                switch (type) {
                case MethodTextType.MTT_OPENBRACKET:
                result = this.methods.OpenBracket;
                break;

                case MethodTextType.MTT_CLOSEBRACKET:
                result = this.methods.CloseBracket;
                break;

                case MethodTextType.MTT_DELIMITER:
                result = this.methods.Delimiter;
                break;

                case MethodTextType.MTT_NAME:
                result = this.methods.GetName(method);
                break;

                case MethodTextType.MTT_DESCRIPTION:
                result = this.methods.GetDescription(method);
                break;

                case MethodTextType.MTT_TYPEPREFIX:
                case MethodTextType.MTT_TYPEPOSTFIX:
                default:
                break;
                }
            }

            return result == null ? IntPtr.Zero : Marshal.StringToBSTR(result);
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="MethodData.GetParameterText"]/*' />
        public IntPtr GetParameterText(int method, int parameter, ParameterTextType type) {
            if (this.methods == null) return IntPtr.Zero;

            if (method < 0 || method >= GetOverloadCount()) return IntPtr.Zero;

            if (parameter < 0 || parameter >= GetParameterCount(method)) return IntPtr.Zero;

            string name;
            string description;
            string display;

            this.methods.GetParameterInfo(method, parameter, out name, out display, out description);

            string result = null;

            switch (type) {
            case ParameterTextType.PTT_NAME:
            result = name;
            break;

            case ParameterTextType.PTT_DESCRIPTION:
            result = description;
            break;

            case ParameterTextType.PTT_DECLARATION:
            result = display;
            break;

            default:
            break;
            }
            return result == null ? IntPtr.Zero : Marshal.StringToBSTR(result);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\LanguageService100\Tracing.cs ===
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace Microsoft.VisualStudio.Package {
    internal static class Tracing {

        [ConditionalAttribute("LANGTRACE")]
        public static void TraceRef(object obj, string msg) {
            if (obj == null) return;
            IntPtr pUnk = Marshal.GetIUnknownForObject(obj);
            obj = null;
            Marshal.Release(pUnk);
            TraceRef(pUnk, msg);
        }
        [ConditionalAttribute("LANGTRACE")]
        public static void TraceRef(IntPtr pUnk, string msg) {
            GC.Collect(); // collect any outstanding RCW or CCW's.
            if (pUnk == IntPtr.Zero) return;
            Marshal.AddRef(pUnk);
            int count = Marshal.Release(pUnk);
            Trace.WriteLine(msg + ": 0x" + pUnk.ToString("x") + "(ref=" + count + ")");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\LanguageService100\ViewFilter.cs ===
//#define TRACE_EXEC
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.TextManager.Interop;
using Microsoft.VisualStudio.Shell;
using Microsoft.VisualStudio;
using System;
using System.Globalization;
using System.Diagnostics;
using System.Runtime.InteropServices;
using Microsoft.VisualStudio.Shell.Interop;
using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
using IServiceProvider = System.IServiceProvider;
using ShellConstants = Microsoft.VisualStudio.Shell.Interop.Constants;
using OleConstants = Microsoft.VisualStudio.OLE.Interop.Constants;
using VsCommands = Microsoft.VisualStudio.VSConstants.VSStd97CmdID;
using VsCommands2K = Microsoft.VisualStudio.VSConstants.VSStd2KCmdID;
using VsShell = Microsoft.VisualStudio.Shell.VsShellUtilities;


namespace Microsoft.VisualStudio.Package {
    /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="ViewFilter"]/*' />
    /// <summary>
    /// ViewFilter provides a default implementation of IVsTextViewFilter providing a
    /// handling of the following VS commands:
    /// 
    /// VsCommands.GotoDefn
    /// VsCommands.GotoDecl
    /// VsCommands.GotoRef
    /// VsCommands2K.COMMENT_BLOCK
    /// VsCommands2K.UNCOMMENT_BLOCK
    /// VsCommands2K.SHOWMEMBERLIST
    /// VsCommands2K.COMPLETEWORD
    /// VsCommands2K.PARAMINFO
    /// VsCommands2K.QUICKINFO
    /// VsCommands2K.OUTLN_STOP_HIDING_ALL
    /// VsCommands2K.OUTLN_START_AUTOHIDING
    /// VsCommands2K.SHOWCONTEXTMENU
    /// 
    /// Most of the work is delegated to the Source object.
    /// </summary>
    [CLSCompliant(false)]
    [System.Runtime.InteropServices.ComVisible(true)]
    public class ViewFilter : IVsTextViewFilter, IVsTextViewEvents, IOleCommandTarget, IDisposable, IVsExpansionEvents {
        private CodeWindowManager mgr;
        private NativeMethods.ConnectionPointCookie textViewEvents;
        private LanguageService service;
        private IVsTextView textView;
        private IOleCommandTarget nextTarget;
        private TextTipData textTipData;
        private Source source;
        // the current dataTipText info...
        private int quickInfoLine;
        private int quickInfoIdx;
        private TextSpan quickInfoSpan;
        private string quickInfoText;
        private bool gotQuickInfo;
        private bool wasCompletionActive;
        private bool commentSupported;
        private bool autoCompleted;
        private bool autoCompletedNothing;
        private bool autoCompleteTypeChar;
        private IntPtr pvaChar;
        private bool gotEnterKey;
        private bool snippetBound;
        private VsCommands gotoCmd;
        private static int execDepth;

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="ViewFilter.SnippetBound"]/*' />
        protected bool SnippetBound {
            get { return snippetBound; }
            set { snippetBound = value; }
        }
        private NativeMethods.ConnectionPointCookie expansionEvents;

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="ViewFilter.ViewFilter"]/*' />
        public ViewFilter(CodeWindowManager mgr, IVsTextView view) {
            this.pvaChar = IntPtr.Zero;
            this.mgr = mgr;
            this.service = mgr.LanguageService;
            this.source = mgr.Source;
            this.commentSupported = this.service.Preferences.EnableCommenting;
            this.textView = view;
            NativeMethods.ThrowOnFailure(view.AddCommandFilter(this, out nextTarget));

            // Register text view event handlers
            // Delegate to virtual/overridable method
            RegisterTextViewEventHandlers(view);

            if ((this.service != null) && (this.service.Site != null)) {
                IVsExpansionManager emgr = this.service.Site.GetService(typeof(SVsExpansionManager)) as IVsExpansionManager;
                if (emgr != null) {
                    int fBound;
                    emgr.GetSnippetShortCutKeybindingState(out fBound);
                    this.snippetBound = fBound == 0 ? false : true;

                    // Register expansion manager event handlers
                    // Delegate to virtual/overridable method
                    RegisterExpansionManagerEventHandlers(emgr);
                }
            }
        }

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="TextTipData.Finalize"]/*' />
        ~ViewFilter() {
            Dispose();
#if LANGTRACE
            Trace.WriteLine("~ViewFilter");
#endif
        }

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="ViewFilter.Dispose"]/*' />
        public virtual void Dispose() {
            this.textView = null;
            this.service = null;
            this.nextTarget = null;
            this.textTipData = null;
            this.mgr = null;
            if (this.pvaChar != IntPtr.Zero) {
                Marshal.FreeCoTaskMem(pvaChar);
                pvaChar = IntPtr.Zero;
            }
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="ViewFilter.Close"]/*' />
        public virtual void Close() {
#if LANGTRACE
            Trace.WriteLine("ViewFilter::Close");
#endif
            if (this.expansionEvents != null) {
                expansionEvents.Dispose();
                expansionEvents = null;
            }
            if (textViewEvents != null) {
                textViewEvents.Dispose();
                textViewEvents = null;
            }

            if (textView == this.service.LastActiveTextView)
                this.service.OnActiveViewChanged(null);

            textView.RemoveCommandFilter(this); // do not care about HRESULT.
            if (textTipData != null) {
                textTipData.Close(textView);
                textTipData = null;
            }

            Dispose();
        }
        const int SizeOfVariant = 16;

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="ViewFilter.RegisterTextViewEventHandlers"]/*' />
        public virtual void RegisterTextViewEventHandlers(IVsTextView view)
        {
            this.textViewEvents = new NativeMethods.ConnectionPointCookie(view, this, typeof(IVsTextViewEvents));
        }

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="ViewFilter.RegisterTextViewEventHandlers"]/*' />
        public virtual void RegisterExpansionManagerEventHandlers(IVsExpansionManager emgr)
        {
            this.expansionEvents = new NativeMethods.ConnectionPointCookie(emgr, this, typeof(IVsExpansionEvents));
        }

        #region IVsExpansionEvents Members

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="ViewFilter.OnAfterSnippetsKeyBindingChange"]/*' />
        public virtual int OnAfterSnippetsKeyBindingChange(uint dwCmdGuid, uint dwCmdId, int fBound) {
            this.snippetBound = fBound == 0 ? false : true;
            return VSConstants.S_OK;
        }

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="ViewFilter.OnAfterSnippetsUpdate"]/*' />
        public virtual int OnAfterSnippetsUpdate() {
            return VSConstants.S_OK;
        }

        #endregion
        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="ViewFilter.CodeWindowManager;"]/*' />
        /// <summary>Returnt the CodeWindowManager that created this view filter.</summary>
        public CodeWindowManager CodeWindowManager {
            get { return this.mgr; }
        }

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="ViewFilter.Source;"]/*' />
        /// <summary>Return the Source object encapsulating the text buffer.</summary>
        public Source Source {
            get { return this.source; }
        }

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="ViewFilter.TextTipData;"]/*' />
        /// <summary>Get or set the TextTipData object used for displaying tool tips.</summary>
        public TextTipData TextTipData {
            get {
                if (this.textTipData == null) {
                    this.textTipData = this.CreateTextTipData();
                }
                return this.textTipData;
            }
            set { this.textTipData = value; }
        }

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="ViewFilter.TextView;"]/*' />
        /// <summary>Return the IVsTextView associated with this filter.</summary>
        public IVsTextView TextView {
            get { return this.textView; }
        }

		/// <include file='doc\ExpansionProvider.uex' path='docs/doc[@for="ViewFilter.IsExpansionUIActive"]/*' />
		public virtual bool IsExpansionUIActive {
			get {
				IVsTextViewEx tve = this.textView as IVsTextViewEx;
				if (tve != null && tve.IsExpansionUIActive() == VSConstants.S_OK) {
					return true;
				}
				return false;
			}
		}

        public static bool IsExecutingCommand {
            get { return execDepth > 0; }
        }

        #region IVsTextViewFilter methods
        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="ViewFilter.GetWordExtent"]/*' />
        /// <summary>Returns the result of Source.GetWordExtent.</summary>
        public virtual int GetWordExtent(int line, int index, uint flags, TextSpan[] span) {
            Debug.Assert(line >= 0 && index >= 0);
            if (span == null) NativeHelpers.RaiseComError(NativeMethods.E_INVALIDARG);
            else
                span[0] = new TextSpan();

            span[0].iStartLine = span[0].iEndLine = line;
            span[0].iStartIndex = span[0].iEndIndex = index;

            int start, end;

            if (!this.source.GetWordExtent(line, index, (WORDEXTFLAGS)flags, out start, out end)) {
                return NativeMethods.S_FALSE;
            }

            span[0].iStartIndex = start;
            span[0].iEndIndex = end;
            TextSpanHelper.MakePositive(ref span[0]);
            return NativeMethods.S_OK;
        }

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="ViewFilter.GetDataTipText"]/*' />
        /// <summary>
        /// If Preferences.EnableQuickInfo is true then this method kicks of a parse with the 
        /// reason ParseReason.QuickInfo to find information about the current token.  If the
        /// parse finds something (returned via the AuthoringScope.GetDataTipText) then it is
        /// displayed using the TextTipData object.  When the asynchronous parse is finished
        /// GetFullDataTipText is called to pop up the tip.
        /// </summary>
        public virtual int GetDataTipText(TextSpan[] aspan, out string textValue) {
            textValue = null;

            TextSpan span = aspan[0];

            if (!service.Preferences.EnableQuickInfo) {
                return NativeMethods.E_FAIL;
            }

            if (span.iEndLine == this.quickInfoLine && span.iEndIndex == this.quickInfoIdx) {
                if (!gotQuickInfo) {
                    // still parsing on the background thread, so return E_PENDING.
                    return (int)NativeMethods.E_PENDING;
                }

                this.quickInfoLine = -1;
                int hr = this.GetFullDataTipText(this.quickInfoText, quickInfoSpan, out textValue);
                aspan[0] = this.quickInfoSpan;
                if (hr != NativeMethods.S_OK)
                    return hr;
            } else {
                // kick off the background parse to get this information...
                this.quickInfoText = null;
                this.gotQuickInfo = false;
                this.quickInfoLine = span.iEndLine;
                this.quickInfoIdx = span.iEndIndex;
                this.source.BeginParse(span.iEndLine, span.iEndIndex, new TokenInfo(), ParseReason.QuickInfo, this.textView, new ParseResultHandler(GetDataTipResponse));
                return (int)NativeMethods.E_PENDING;
            }
            // This return code means that regardless of whether we found any tooltip or not
            // the error associated with a code marker takes precedence (see DocumentTask.cs).
            return (int)TipSuccesses.TIP_S_ONLYIFNOMARKER;
        }

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="ViewFilter.GetPairExtents"]/*' />
        public virtual int GetPairExtents(int line, int index, TextSpan[] span) {
            Debug.Assert(line >= 0 && index >= 0);
            // This call from VS does not support returning E_PENDING.
            if (span == null) return NativeMethods.E_INVALIDARG;

            this.source.GetPairExtents(this.textView, line, index, out span[0]);
            TextSpanHelper.MakePositive(ref span[0]);
            return NativeMethods.S_OK;
        }
        #endregion

        #region IVsTextViewEvents methods
        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="ViewFilter.OnChangeCaretLine"]/*' />
        public virtual void OnChangeCaretLine(IVsTextView view, int line, int col) {
        }

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="ViewFilter.OnChangeScrollInfo"]/*' />
        public virtual void OnChangeScrollInfo(IVsTextView view, int iBar, int iMinUnit, int iMaxUnits, int iVisibleUnits, int iFirstVisibleUnit) {
        }

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="ViewFilter.OnKillFocus"]/*' />
        public virtual void OnKillFocus(IVsTextView view) {
            this.mgr.OnKillFocus(view);
        }

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="ViewFilter.OnSetBuffer"]/*' />
        public virtual void OnSetBuffer(IVsTextView view, IVsTextLines buffer) {
            Debug.Assert(buffer == this.mgr.Source.GetTextLines());
        }

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="ViewFilter.OnSetFocus"]/*' />
        public virtual void OnSetFocus(IVsTextView view) {
            this.service.OnActiveViewChanged(view);
            if (this.mgr != null) this.mgr.OnSetFocus(view); // is null during shutdown.
        }
        #endregion

        internal void GetDataTipResponse(ParseRequest req) {
            if (req.Line == this.quickInfoLine && req.Col == this.quickInfoIdx) {
                if (req.Scope == null) {
                    this.quickInfoText = null;
                } else {
                    this.quickInfoText = req.Scope.GetDataTipText(req.Line, req.Col, out this.quickInfoSpan);
                }
                this.gotQuickInfo = true;
            }
        }

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="ViewFilter.QueryCommandStatus"]/*' />
        /// <summary>
        /// Override this method to intercept the IOleCommandTarget::QueryStatus call.
        /// </summary>
        /// <param name="guidCmdGroup"></param>
        /// <param name="nCmdId"></param>
        /// <returns>Usually returns a combination of OLECMDF flags, for example
        /// OLECMDF_ENABLED | OLECMDF_SUPPORTED.  
        /// Return E_FAIL if want to delegate to the next command target.
        /// </returns>
        protected virtual int QueryCommandStatus(ref Guid guidCmdGroup, uint nCmdId) {
            ExpansionProvider ep = GetExpansionProvider();
            if (ep != null && ep.InTemplateEditingMode) {
                int hr = 0;
                if (ep.HandleQueryStatus(ref guidCmdGroup, nCmdId, out hr))
                    return hr;
            }
            if (guidCmdGroup == Microsoft.VisualStudio.VSConstants.GUID_VSStandardCommandSet97) {
                VsCommands cmd = (VsCommands)nCmdId;

                switch (cmd) {
                    case VsCommands.GotoDefn:
                    case VsCommands.GotoDecl:
                    case VsCommands.GotoRef:
                        return (int)OLECMDF.OLECMDF_SUPPORTED | (int)OLECMDF.OLECMDF_ENABLED;
                }
            } else if (guidCmdGroup == Microsoft.VisualStudio.Shell.VsMenus.guidStandardCommandSet2K) {
                VsCommands2K cmd = (VsCommands2K)nCmdId;

                switch (cmd) {
                    case VsCommands2K.FORMATDOCUMENT:
                        if (this.CanReformat())
                            return (int)OLECMDF.OLECMDF_SUPPORTED | (int)OLECMDF.OLECMDF_ENABLED;
                        break;
                    case VsCommands2K.FORMATSELECTION:
                        if (this.CanReformat())
                            return (int)OLECMDF.OLECMDF_SUPPORTED | (int)OLECMDF.OLECMDF_ENABLED;
                        break;

                    case VsCommands2K.COMMENT_BLOCK:
                    case VsCommands2K.UNCOMMENT_BLOCK:
                        if (this.commentSupported)
                            return (int)OLECMDF.OLECMDF_SUPPORTED | (int)OLECMDF.OLECMDF_ENABLED;
                        break;

                    case VsCommands2K.SHOWMEMBERLIST:
                    case VsCommands2K.COMPLETEWORD:
                    case VsCommands2K.PARAMINFO:
                        return (int)OLECMDF.OLECMDF_SUPPORTED | (int)OLECMDF.OLECMDF_ENABLED;

                    case VsCommands2K.QUICKINFO:
                        if (this.service.Preferences.EnableQuickInfo) {
                            return (int)OLECMDF.OLECMDF_SUPPORTED | (int)OLECMDF.OLECMDF_ENABLED;
                        }
                        break;

                    case VsCommands2K.OUTLN_START_AUTOHIDING:
                        if (!this.source.OutliningEnabled)
                        {
                            return (int)OLECMDF.OLECMDF_SUPPORTED | (int)OLECMDF.OLECMDF_ENABLED;
                        }
                        break;

                    //                    case VsCommands2K.HANDLEIMEMESSAGE:
                    //                        return 0;

                    // Let the core editor handle this.  Stop outlining also removes user
                    // defined hidden sections so it is handy to keep this enabled.
                    //                    case VsCommands2K.OUTLN_STOP_HIDING_ALL: 
                    //                        int rc = (int)OLECMDF.OLECMDF_SUPPORTED;
                    //                        if (this.source.OutliningEnabled) {
                    //                            rc |= (int)OLECMDF.OLECMDF_ENABLED;
                    //                        }
                    //                        return rc;
                }
            }

            return (int)NativeMethods.E_FAIL; // delegate to next command target.
        }

        /// <include file='doc\EditorView.uex' path='docs/doc[@for="SimpleEditorView.QueryParameterList"]/*' />
        /// <summary>
        /// The parameter list of a command is queried by calling Exec with the LOWORD
        /// of nCmdexecopt set to OLECMDEXECOPT_SHOWHELP (instead of the more usual
        /// OLECMDEXECOPT_DODEFAULT), the HIWORD of nCmdexecopt set to
        /// VSCmdOptQueryParameterList, pvaIn set to NULL, and pvaOut pointing to an
        /// empty VARIANT ready to receive the result BSTR.  This should be done only
        /// for commands that are marked with the ALLOWPARAMS flags in the command
        /// table.        
        /// </summary>
        /// <returns>Usually returns 0 if ok, or OLECMDERR_E_NOTSUPPORTED</returns>
        protected virtual int QueryParameterList(ref Guid guidCmdGroup, uint nCmdId, uint nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut) {
#if LANGTRACE
            Trace.WriteLine(String.Format("QueryParameterList({0},{1})", guidCmdGroup.ToString(), nCmdId));
#endif
            return (int)OleConstants.OLECMDERR_E_NOTSUPPORTED;
        }

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="ViewFilter.HandlePreExec"]/*' />
        public virtual bool HandlePreExec(ref Guid guidCmdGroup, uint nCmdId, uint nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut) {
            
            this.wasCompletionActive = this.Source.IsCompletorActive;
            this.gotEnterKey = false;

            if (guidCmdGroup == typeof(VsCommands).GUID) {
                VsCommands cmd = (VsCommands)nCmdId;
#if TRACE_EXEC
                if (cmd != VsCommands.SolutionCfg && cmd != VsCommands.SearchCombo) {
                    Trace.WriteLine(String.Format("ExecCommand: {0}", cmd.ToString()));
                }
#endif
                switch (cmd) {
                    case VsCommands.GotoDefn:
                    case VsCommands.GotoDecl:
                    case VsCommands.GotoRef:
                        HandleGoto(cmd);
                        return true;
                }
            } else if (guidCmdGroup == typeof(VsCommands2K).GUID) {

                VsCommands2K cmd = (VsCommands2K)nCmdId;
                switch (cmd) {
                    case VsCommands2K.FORMATDOCUMENT:
                        this.ReformatDocument();
                        return true;

                    case VsCommands2K.FORMATSELECTION:
                        this.ReformatSelection();
                        return true;

                    case VsCommands2K.COMMENT_BLOCK:
                        this.CommentSelection();
                        return true;

                    case VsCommands2K.UNCOMMENT_BLOCK:
                        this.UncommentSelection();
                        return true;

                    case VsCommands2K.COMPLETEWORD: {
                            int line, col;
                            NativeMethods.ThrowOnFailure(this.textView.GetCaretPos(out line, out col));
                            this.source.Completion(this.textView, this.source.GetTokenInfo(line, col), ParseReason.CompleteWord);
                            return true;
                        }
                    case VsCommands2K.SHOWMEMBERLIST: {
                            int line, col;
                            NativeMethods.ThrowOnFailure(this.textView.GetCaretPos(out line, out col));
                            this.source.Completion(this.textView, this.source.GetTokenInfo(line, col), ParseReason.DisplayMemberList);
                            return true;
                        }
                    case VsCommands2K.PARAMINFO: {
                            int line;
                            int col;
                            NativeMethods.ThrowOnFailure(this.textView.GetCaretPos(out line, out col));
                            this.source.MethodTip(this.textView, line, col, this.source.GetTokenInfo(line, col));
                            return true;
                        }

                    case VsCommands2K.QUICKINFO: {
                            HandleQuickInfo();
                            return true;
                        }

                    case VsCommands2K.SHOWCONTEXTMENU: {
                        int vsize = Marshal.SizeOf(typeof(Variant));
                        Variant x = Variant.ToVariant(pvaIn);
                        Variant y = Variant.ToVariant(new IntPtr((long)pvaIn + vsize)); 

                        this.ShowContextMenu(VsMenus.IDM_VS_CTXT_CODEWIN, VsMenus.guidSHLMainMenu, TextView as IOleCommandTarget, (int)x.Value, (int)y.Value);
                        return true;
                    }

                    case VsCommands2K.OUTLN_STOP_HIDING_ALL:
                        this.source.DisableOutlining();
                        return true;

                    case VsCommands2K.OUTLN_START_AUTOHIDING:
                        this.source.OutliningEnabled = true;
                        // subtle way of calling this.source.ProcessHiddenRegions(..);
                        this.source.IsDirty = true;
                        return true;
                    case VsCommands2K.ECMD_LEFTCLICK:
                        // check general trigger characters for intellisense
                        Source.OnCommand(TextView, cmd, '\0');
                        break;
                }
            }
            return false;
        }

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="ViewFilter.HanelPostExec"]/*' />
        /// <summary>This method hooks up HandleSmartIndent and Source.OnCommand.  </summary>
        public virtual void HandlePostExec(ref Guid guidCmdGroup, uint nCmdId, uint nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut, bool bufferWasChanged) {

            if (guidCmdGroup == typeof(VsCommands2K).GUID) {
                VsCommands2K cmd = (VsCommands2K)nCmdId;
                char ch = '\0';
                if (cmd == VsCommands2K.TYPECHAR && pvaIn != IntPtr.Zero) {
                    Variant v = Variant.ToVariant(pvaIn);
                    ch = v.ToChar();

#if TRACE_EXEC
                    Trace.WriteLine(String.Format("ExecCommand: {0}, '{1}', {2}", cmd.ToString(), ch.ToString(), (int)ch));
#endif
                }

                switch (cmd) {
                    case VsCommands2K.RETURN:
                        gotEnterKey = true;
                        // Handle smart-indentation after core text editor has
                        // actually performed the newline operation.
                        if (bufferWasChanged && !this.wasCompletionActive && this.service.Preferences.IndentStyle == IndentingStyle.Smart) {
                            if (HandleSmartIndent())
                                break;
                        }
                        break;

                    case VsCommands2K.TYPECHAR:
                    case VsCommands2K.BACKSPACE:
                    case VsCommands2K.TAB:
                    case VsCommands2K.BACKTAB:
                    case VsCommands2K.DELETE:
                        // check general trigger characters for intellisense
                        if (bufferWasChanged) {
                            this.source.OnCommand(this.textView, cmd, ch);
                        }
                        break;
                    case VsCommands2K.UP:
                    case VsCommands2K.UP_EXT:
                    case VsCommands2K.UP_EXT_COL:
                    case VsCommands2K.DOWN:
                    case VsCommands2K.DOWN_EXT:
                    case VsCommands2K.DOWN_EXT_COL:
                    case VsCommands2K.HOME:
                    case VsCommands2K.HOME_EXT:
                    case VsCommands2K.END:
                    case VsCommands2K.END_EXT:
                    case VsCommands2K.BOL:
                    case VsCommands2K.BOL_EXT:
                    case VsCommands2K.BOL_EXT_COL:
                    case VsCommands2K.FIRSTCHAR:
                    case VsCommands2K.FIRSTCHAR_EXT:
                    case VsCommands2K.EOL:
                    case VsCommands2K.EOL_EXT:
                    case VsCommands2K.EOL_EXT_COL:
                    case VsCommands2K.LASTCHAR:
                    case VsCommands2K.LASTCHAR_EXT:
                    case VsCommands2K.PAGEUP:
                    case VsCommands2K.PAGEUP_EXT:
                    case VsCommands2K.PAGEDN:
                    case VsCommands2K.PAGEDN_EXT:
                    case VsCommands2K.LEFT:
                    case VsCommands2K.LEFT_EXT:
                    case VsCommands2K.LEFT_EXT_COL:
                    case VsCommands2K.RIGHT:
                    case VsCommands2K.RIGHT_EXT:
                    case VsCommands2K.RIGHT_EXT_COL:
                    case VsCommands2K.WORDNEXT:
                    case VsCommands2K.WORDNEXT_EXT:
                    case VsCommands2K.WORDNEXT_EXT_COL:
                    case VsCommands2K.WORDPREV:
                    case VsCommands2K.WORDPREV_EXT:
                    case VsCommands2K.WORDPREV_EXT_COL:
                    case VsCommands2K.BOTTOMLINE:
                    case VsCommands2K.BOTTOMLINE_EXT:
                    case VsCommands2K.TOPLINE:
                    case VsCommands2K.TOPLINE_EXT:
                        // check general trigger characters for intellisense
                        this.source.OnCommand(this.textView, cmd, ch);
                        break;
                }
            }
            return;
        }

        [DllImport("oleaut32", PreserveSig = false)]
        static extern void VariantInit(IntPtr pObject);
        [DllImport("oleaut32", PreserveSig = false)]
        static extern void VariantClear(IntPtr pObject);

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="ViewFilter.ExecCommand"]/*' />
        /// <summary>
        /// Override this method to intercept the IOleCommandTarget::Exec call.
        /// </summary>
        /// <returns>Usually returns 0 if ok, or OLECMDERR_E_NOTSUPPORTED</returns>
        protected virtual int ExecCommand(ref Guid guidCmdGroup, uint nCmdId, uint nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut) {
            int rc = 0;
            execDepth++; // only on UI thread, so this should be safe.
            try {
                this.autoCompleted = false;
                if (this.IsExpansionUIActive) {
                    // Pass it along to the expansion UI picker.
                    return this.InnerExec(ref guidCmdGroup, nCmdId, nCmdexecopt, pvaIn, pvaOut);
                }

                ExpansionProvider ep = GetExpansionProvider();
                if (ep != null && ep.InTemplateEditingMode) {
                    if (ep.HandlePreExec(ref guidCmdGroup, nCmdId, nCmdexecopt, pvaIn, pvaOut))
                        return rc;
                }

                if (!HandlePreExec(ref guidCmdGroup, nCmdId, nCmdexecopt, pvaIn, pvaOut) &&
                    this.nextTarget != null) {

                    // Pass it along the chain.
                    int count = this.source.ChangeCount;
                    rc = this.InnerExec(ref guidCmdGroup, nCmdId, nCmdexecopt, pvaIn, pvaOut);
                    if (!ErrorHandler.Succeeded(rc))
                        return rc;

                    bool bufferWasChanged = count != source.ChangeCount;

                    if (this.autoCompleted) {
                        this.autoCompleted = false;
                        // See if completion set just completed, so we can do auto-completion synchronously.
                        CompletionSet cset = this.source.CompletionSet;
                        if (cset != null) {
                            if (this.autoCompletedNothing &&
                                this.wasCompletionActive && guidCmdGroup == typeof(VsCommands2K).GUID &&
                                nCmdId == (uint)VsCommands2K.RETURN) {
                                // This happens if the user typed ENTER while the CompletionSet was active,
                                // but selected nothing from the list.  In this case the ENTER key was gobbled up
                                // by the CompletionSet, and we want the ENTER key inserted into the buffer instead.
                                this.wasCompletionActive = false;
                                this.InnerExec(ref guidCmdGroup, nCmdId, nCmdexecopt, pvaIn, pvaOut);
                            }
                        }
                        if (this.autoCompleteTypeChar) {
                            // Auto-complete typed a different char so we skip HandlePostExec in this case.
                            return rc;
                        }
                    }

                    if (ep != null && ep.InTemplateEditingMode) {
                        if (ep.HandlePostExec(ref guidCmdGroup, nCmdId, nCmdexecopt, gotEnterKey, pvaIn, pvaOut))
                            return rc;
                    }
                    HandlePostExec(ref guidCmdGroup, nCmdId, nCmdexecopt, pvaIn, pvaOut, bufferWasChanged);
                }
            } finally {
                execDepth--;
            }
            return rc;
        }

        protected virtual int InnerExec(ref Guid guidCmdGroup, uint nCmdId, uint nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut) {
            return this.nextTarget.Exec(ref guidCmdGroup, nCmdId, nCmdexecopt, pvaIn, pvaOut);
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="ViewFilter.OnAutoComplete"]/*' />
        public virtual void OnAutoComplete() {
            this.autoCompletedNothing = false;
            this.autoCompleteTypeChar = false;
            CompletionSet cset = this.source.CompletionSet;
            if (cset != null) {
                char ch = cset.OnAutoComplete();
                if (ch != '\0') {
                    if (ch <= 0x1f) {
                        Debug.Assert(false, cset.GetType().FullName + ".OnAutoComplete returned an illegal control character which will not be inserted into the buffer.");
                    } else {
                        this.autoCompleteTypeChar = true;
                        bool wca = this.wasCompletionActive;
                        TypeChar(ch);
                        this.wasCompletionActive = wca;
                    }
                } else {
                    this.autoCompletedNothing = string.IsNullOrEmpty(cset.OnCommitText);
                }
            }
            // This must be placed after the above TypeChar because TypeChar re-enters
            // ExecCommand and we do not want to do the autoCompleted block until after
            // this method returns.
            this.autoCompleted = true;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="ViewFilter.TypeChar"]/*' />
        // Executes a VsCommands2K.TYPECHAR command on the current command chain.
        public int TypeChar(char ch) {

            if (this.pvaChar == IntPtr.Zero) {
                this.pvaChar = Marshal.AllocCoTaskMem(SizeOfVariant);
            }
            if (pvaChar == IntPtr.Zero)
                return NativeMethods.E_OUTOFMEMORY;

            VariantInit(pvaChar);
            Marshal.GetNativeVariantForObject(ch, pvaChar);
            int rc = 0;
            try {
				Guid cmdGroup = typeof(VsCommands2K).GUID;
                rc = ExecCommand(ref cmdGroup, (uint)VsCommands2K.TYPECHAR, 0, pvaChar, IntPtr.Zero);
            } finally {
                VariantClear(pvaChar);
            }
            return rc;
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="ViewFilter.HandleSmartIndent"]/*' />
        /// Override this method if you want to support smart indenting.
        /// This will only be called if Preferences.Indenting == IndentingStyle.Smart which is
        /// only available if you set your language service registry key ShowSmartIndent to 1.
        public virtual bool HandleSmartIndent() {
            return false;
        }

        #region IOleCommandTarget methods
        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="ViewFilter.IOleCommandTarget.QueryStatus"]/*' />
        /// <internalonly/>
        int IOleCommandTarget.QueryStatus(ref Guid guidCmdGroup, uint cCmds, OLECMD[] prgCmds, IntPtr pCmdText) {
            for (uint i = 0; i < cCmds; i++) {
                int rc = QueryCommandStatus(ref guidCmdGroup, (uint)prgCmds[i].cmdID);

                if (rc == NativeMethods.E_FAIL) {
                    if (nextTarget != null) {
                        try {
                            return this.nextTarget.QueryStatus(ref guidCmdGroup, cCmds, prgCmds, pCmdText);
                        } catch (Exception) {
                            // We are going to return the failed return code below
                        }
                    }

                    return rc;
                }

                prgCmds[i].cmdf = (uint)rc;
            }

            return NativeMethods.S_OK;
        }

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="ViewFilter.IOleCommandTarget.Exec"]/*' />
        /// <internalonly/>
        int IOleCommandTarget.Exec(ref Guid guidCmdGroup, uint nCmdId, uint nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut) {

            ushort lo = (ushort)(nCmdexecopt & (uint)0xffff);
            ushort hi = (ushort)(nCmdexecopt >> 16);
            switch (lo) {
                case (ushort)OLECMDEXECOPT.OLECMDEXECOPT_SHOWHELP:
                    if ((nCmdexecopt >> 16) == VsMenus.VSCmdOptQueryParameterList) {
                        int hr = QueryParameterList(ref guidCmdGroup, nCmdId, nCmdexecopt, pvaIn, pvaOut);
                        if (hr != (int)OleConstants.OLECMDERR_E_NOTSUPPORTED)
                        {
                            return hr;
                        }
                        return this.InnerExec(ref guidCmdGroup, nCmdId, nCmdexecopt, pvaIn, pvaOut);
                    }
                    break;
                default:
                    // On every command, update the tip window if it's active.
                    if (this.textTipData != null && this.textTipData.IsActive())
                        textTipData.CheckCaretPosition(this.textView);

                    int rc = 0;
                    try {
                        rc = ExecCommand(ref guidCmdGroup, nCmdId, nCmdexecopt, pvaIn, pvaOut);
                    } catch (COMException e) {
                        int hr = e.ErrorCode;
                        // We silently fail on the following errors because the user has
                        // most likely already been prompted with things like source control checkout
                        // dialogs and so forth.
                        if (hr != (int)TextBufferErrors.BUFFER_E_LOCKED &&
                            hr != (int)TextBufferErrors.BUFFER_E_READONLY &&
                            hr != (int)TextBufferErrors.BUFFER_E_READONLY_REGION &&
                            hr != (int)TextBufferErrors.BUFFER_E_SCC_READONLY) {
                            throw;
                        }
                    }

                    return rc;
            }
            return (int)OleConstants.OLECMDERR_E_NOTSUPPORTED;
        }
        #endregion

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="ViewFilter.HandleQuickInfo"]/*' />
        /// <summary>This method is called to handle the VsCommands2K.QUICKINFO command.</summary>
        public virtual void HandleQuickInfo() {
            int line, col;

            // Get the caret position
            NativeMethods.ThrowOnFailure(this.textView.GetCaretPos(out line, out col));

            // Get the tip text at that location. 
            this.source.BeginParse(line, col, new TokenInfo(), ParseReason.Autos, this.textView, 
                new ParseResultHandler(HandleQuickInfoResponse));
        }

        void HandleQuickInfoResponse(ParseRequest req){

            int line;
            int col;
            // Get the caret position
            NativeMethods.ThrowOnFailure(this.textView.GetCaretPos(out line, out col));

            string text = null;
            AuthoringScope scope = req.Scope;
            if (scope != null) {
                TextSpan span;
                text = scope.GetDataTipText(req.Line, req.Col, out span);
                if (text == null || !TextSpanHelper.ContainsInclusive(span, line, col)) {
                    return; // caret has moved.
                }
            } else {
                return;
            }

            string fullText;
            TextSpan ts = new TextSpan();
            ts.iStartLine = ts.iEndLine = line;
            ts.iStartIndex = ts.iEndIndex = col;
            NativeMethods.ThrowOnFailure(GetFullDataTipText(text, ts, out fullText));

            if (fullText == null) {
                return;
            }

            int iPos, iPosEnd, iSpace, iLength;

            // Calculate the stream position
            NativeMethods.ThrowOnFailure(textView.GetNearestPosition(ts.iStartLine, ts.iStartIndex, out iPos, out iSpace));
            NativeMethods.ThrowOnFailure(textView.GetNearestPosition(ts.iEndLine, ts.iEndIndex, out iPosEnd, out iSpace));
            iLength = Math.Max(iPosEnd - iPos, 1);

            // Tear down the method tip window if it's there
            this.source.DismissCompletor();

            // Update the text tip window
            TextTipData textTipData = this.TextTipData;

            textTipData.Update(fullText, iPos, iLength, this.textView);
        }

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="ViewFilter.GetFullDataTipText"]/*' />
        /// <summary>This method checks to see if the IVsDebugger is running, and if so, 
        /// calls it to get additional information about the current token and returns a combined result.
        /// You can return an HRESULT here like TipSuccesses2.TIP_S_NODEFAULTTIP.</summary>
        public virtual int GetFullDataTipText(string textValue, TextSpan ts, out string fullTipText) {
            IVsTextLines textLines;
            fullTipText = textValue;

            NativeMethods.ThrowOnFailure(this.textView.GetBuffer(out textLines));

            // Now, check if the debugger is running and has anything to offer
            try {
                Microsoft.VisualStudio.Shell.Interop.IVsDebugger debugger = this.service.GetIVsDebugger();
                if (debugger != null && this.mgr.LanguageService.IsDebugging) {
                    TextSpan[] tsdeb = new TextSpan[1] { new TextSpan() };
                    if (!TextSpanHelper.IsEmpty(ts)) {
                        // While debugging we always want to evaluate the expression user is hovering over
                        if (NativeMethods.S_OK == textView.GetWordExtent(ts.iStartLine, ts.iStartIndex, (uint)WORDEXTFLAGS.WORDEXT_FINDEXPRESSION, tsdeb)) {
                            // If it failed to find something, then it means their is no expression so return S_FALSE
                            if (TextSpanHelper.IsEmpty(tsdeb[0])) {
                                return NativeMethods.S_FALSE;
                            }
                        }
                    }
                    string debugTextTip = null;
                    int hr = debugger.GetDataTipValue(textLines, tsdeb, null, out debugTextTip);
                    fullTipText = debugTextTip;
                    if (hr == (int)TipSuccesses2.TIP_S_NODEFAULTTIP) {
                        return hr;
                    }
                    if (!string.IsNullOrEmpty(debugTextTip) && debugTextTip != textValue) {
                        // The debugger in this case returns "=value [type]" which we can
                        // append to the variable name so we get "x=value[type]" as the full tip.
                        int i = debugTextTip.IndexOf('=');
                        if (i >= 0) {
                            string spacer = (i < debugTextTip.Length - 1 && debugTextTip[i + 1] == ' ') ? " " : "";
                            fullTipText = textValue + spacer + debugTextTip.Substring(i);
                        }
                    }
                }
#if LANGTRACE
            } catch (COMException e) {
                Trace.WriteLine("COMException: GetDataTipValue, errorcode=" + e.ErrorCode);
#else
            } catch (COMException) {
#endif
            }
            if (string.IsNullOrEmpty(fullTipText)) {
                fullTipText = textValue;
            }
            return NativeMethods.S_OK;

        }

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="ViewFilter.GetTextTipData"]/*' />
        /// <summary>Creates the TextTipData object and returns it</summary>
        public virtual TextTipData CreateTextTipData() {
            // create it 
            return new TextTipData(this.service.Site);

        }

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="ViewFilter.HandleGoto"]/*' />
        /// <summary>Handles VsCommands.GotoDefn, VsCommands.GotoDecl and VsCommands.GotoRef by
        /// calling OnSyncGoto on the Source object and opening the text editor on the resulting
        /// URL, then scrolling to the resulting span.</summary>
        public virtual void HandleGoto(VsCommands cmd) {
            int line, col;

            // Get the caret position
            NativeMethods.ThrowOnFailure(this.textView.GetCaretPos(out line, out col));

            // Get the tip text at that location. 
            this.gotoCmd = cmd;
            this.source.BeginParse(line, col, new TokenInfo(), ParseReason.Goto, this.textView, 
                new ParseResultHandler(HandleGotoResponse));
        }

        void HandleGotoResponse(ParseRequest req) {
            // Make sure caret hasn't moved since we kicked this off.
            TextSpan[] aSpan = new TextSpan[1];
            int line, col;
            NativeMethods.ThrowOnFailure(this.textView.GetCaretPos(out line, out col));
            if (req.Line != line || req.Col != col)
                return; // caret has moved.

            string url = null;
            TextSpan span;
            AuthoringScope scope = req.Scope;            
            if (scope != null) {
                url = scope.Goto(this.gotoCmd, textView, line, col, out span);
            } else {
                return;
            }
            if (url == null || url.Trim().Length == 0) { // nothing to show
                return;
            }

            // Open the referenced document, and scroll to the given location.
            IVsUIHierarchy hierarchy;
            uint itemID;
            IVsWindowFrame frame;
            IVsTextView view;

            VsShell.OpenDocument(this.service.Site, url, NativeMethods.LOGVIEWID_Code, out hierarchy, out itemID, out frame, out view);
            if (view != null) {
                TextSpanHelper.MakePositive(ref span);
                NativeMethods.ThrowOnFailure(view.EnsureSpanVisible(span));
                NativeMethods.ThrowOnFailure(view.SetSelection(span.iStartLine, span.iStartIndex, span.iEndLine, span.iEndIndex));
            }
        }
        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="ViewFilter.GetExpansionProvider"]/*' />
        public virtual ExpansionProvider GetExpansionProvider() {
            return this.source.GetExpansionProvider();
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="ViewFilter.ShowContextMenu"]/*' />
        public virtual void ShowContextMenu(int menuId, Guid groupGuid, IOleCommandTarget target, int x, int y) {
            IVsUIShell uiShell = this.service.GetService(typeof(SVsUIShell)) as IVsUIShell;
            if (uiShell != null && !this.service.IsMacroRecordingOn()) { // disable context menu while recording macros.
                POINTS[] pnts = new POINTS[1];
                pnts[0].x = (short)x;
                pnts[0].y = (short)y;
                int hr = uiShell.ShowContextMenu(0, ref groupGuid, menuId, pnts, target);
                if (!NativeMethods.Succeeded(hr)) {
                    Debug.Assert(false, "uiShell.ShowContextMenu returned " + hr);
                }
            }
            uiShell = null;
        }

        #region CommentSelection

        // Special View filter command handling.
        /// <include file='doc\Source.uex' path='docs/doc[@for="ViewFilter.CommentSelection"]/*' />
        public virtual void CommentSelection() {
            if (this.service == null) return;

            TextSpan span = GetSelection();
            span = this.source.CommentSpan(span);

            NativeMethods.ThrowOnFailure(this.textView.SetSelection(span.iStartLine, span.iStartIndex, span.iEndLine, span.iEndIndex));
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="ViewFilter.GetSelection"]/*' />
        /// <summary>Returns the current selection, adjusted to become a positive text span</summary>
        public TextSpan GetSelection() {
            //get text range
            TextSpan[] aspan = new TextSpan[1];
            NativeMethods.ThrowOnFailure(this.textView.GetSelectionSpan(aspan));
            if (!TextSpanHelper.IsPositive(aspan[0])) {
                TextSpanHelper.MakePositive(ref aspan[0]);
            }
            return aspan[0];
        }

        /// <include file='doc\Source.uex' path='docs/doc[@for="ViewFilter.UncommentSelection"]/*' />
        public virtual void UncommentSelection() {
            //get text range
            TextSpan span = GetSelection();
            
            TextSpan uncommentedSpan = this.source.UncommentSpan(span);
            span = TextSpanHelper.Merge(uncommentedSpan, span);
            //union the start position, trimmed position on the end
            NativeMethods.ThrowOnFailure(textView.SetSelection(span.iStartLine, span.iStartIndex, uncommentedSpan.iEndLine, uncommentedSpan.iEndIndex));

        }
        #endregion


        #region Reformat

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="ViewFilter.ReformatDocument;"]/*' />
        public virtual void ReformatDocument() {
            if (this.CanReformat()) {
                Debug.Assert(this.source != null);
                if (this.source != null) {
                    TextSpan span = this.source.GetDocumentSpan();
                    using (EditArray mgr = new EditArray(this.source, this.TextView, true, SR.GetString(SR.FormatSpan))) {
                        this.source.ReformatSpan(mgr, span);
                        mgr.ApplyEdits();
                    }
                }
            }
        }

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="ViewFilter.ReformatSelection;"]/*' />
        public virtual void ReformatSelection() {
            if (this.CanReformat()) {
                Debug.Assert(this.source != null);
                if (this.source != null) {
                    TextSpan ts = GetSelection();
                    if (TextSpanHelper.IsEmpty(ts)) {
                        // format just this current line.
                        ts.iStartIndex = 0;
                        ts.iEndLine = ts.iStartLine;
                        ts.iEndIndex = this.source.GetLineLength(ts.iStartLine);
                    }
                    using (EditArray mgr = new EditArray(this.source, this.TextView, true, SR.GetString(SR.FormatSpan))) {
                        this.source.ReformatSpan(mgr, ts);
                        mgr.ApplyEdits();
                    }
                }
            }
        }

        /// <include file='doc\LanguageService.uex' path='docs/doc[@for="ViewFilter.CanReformat"]/*' />
        /// <summary>This method returns true if the FormatDocument and FormatSelection commands
        /// are to be enabled.  Default returns false if debugging, otherwise it returns
        /// the result for Preferences.EnableFormatSelection.</summary>
        public virtual bool CanReformat() {
            if (this.service == null) return false;
            if (this.service.IsDebugging) return false;
            return this.service.Preferences.EnableFormatSelection;
        }

        #endregion

    }

    /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="TextTipData"]/*' />
    /// <summary>This class provides a default implementation of IVsTextTipData for
    /// use in the IVsTextTipWindow for displaying tool tips.</summary>
    [CLSCompliant(false)]
    [System.Runtime.InteropServices.ComVisible(true)]
    public class TextTipData : IVsTextTipData {
        IVsTextTipWindow textTipWindow;
        int pos;
        int len;
        string text;
        bool isWindowUp;

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="TextTipData.TextTipData"]/*' />
        public TextTipData(IServiceProvider site) {
            if (site == null)
                throw new System.ArgumentNullException("site");

            //this.textView = view;
            // Create our method tip window (through the local registry)
            Type t = typeof(IVsTextTipWindow);
            Guid riid = t.GUID;

            Guid clsid = typeof(VsTextTipWindowClass).GUID;
            Microsoft.VisualStudio.Shell.Package pkg = (Microsoft.VisualStudio.Shell.Package)site.GetService(typeof(Microsoft.VisualStudio.Shell.Package));
            if (pkg == null) {
                throw new NullReferenceException(typeof(Microsoft.VisualStudio.Shell.Package).FullName);
            }
            this.textTipWindow = (IVsTextTipWindow)pkg.CreateInstance(ref clsid, ref riid, t);
            if (this.textTipWindow == null)
                NativeHelpers.RaiseComError(NativeMethods.E_FAIL);

            NativeMethods.ThrowOnFailure(textTipWindow.SetTextTipData(this));
        }

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="TextTipData.Close"]/*' />
        public void Close(IVsTextView textView) {
            if (this.textTipWindow != null) {
                if (this.isWindowUp)
                    NativeMethods.ThrowOnFailure(textView.UpdateTipWindow(this.textTipWindow, (uint)TipWindowFlags.UTW_DISMISS));

                this.textTipWindow = null;
            }
        }

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="TextTipData.IsActive"]/*' />
        public bool IsActive() { return this.isWindowUp; }

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="TextTipData.Update"]/*' />
        public void Update(string textValue, int pos, int len, IVsTextView textView) {
            if (textView == null) return;

            this.pos = pos;
            this.len = len;
            this.text = textValue;
            if (textValue == null || textValue.Length == 0)
                NativeHelpers.RaiseComError(NativeMethods.E_FAIL);

            int hr = textView.UpdateTipWindow(textTipWindow, (uint)TipWindowFlags.UTW_CONTEXTCHANGED | (uint)TipWindowFlags.UTW_CONTENTCHANGED);
            Debug.Assert(NativeMethods.Succeeded(hr), "UpdateTipWindow");
            this.isWindowUp = true;
        }

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="TextTipData.CheckCaretPosition"]/*' />
        public void CheckCaretPosition(IVsTextView textView) {
            if (textView == null) return;

            int line, col, pos, space;

            NativeMethods.ThrowOnFailure(textView.GetCaretPos(out line, out col));
            NativeMethods.ThrowOnFailure(textView.GetNearestPosition(line, col, out pos, out space));
            if (pos < this.pos || pos > this.pos + this.len) {
                NativeMethods.ThrowOnFailure(textView.UpdateTipWindow(this.textTipWindow, (uint)TipWindowFlags.UTW_DISMISS));
            }
        }

        ////////////////////////////////////////////////////////////////////////////////
        #region IVsTextTipData
        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="TextTipData.GetTipText"]/*' />
        public virtual int GetTipText(string[] pbstrText, out int pfFontData) {
            pfFontData = 0; 
            if (pbstrText == null || pbstrText.Length == 0)
                return NativeMethods.E_INVALIDARG;

            pfFontData = 0; 
            pbstrText[0] = this.text;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="TextTipData.GetTipFontInfo"]/*' />
        public virtual int GetTipFontInfo(int iChars, uint[] pdwFontInfo) {
            return NativeMethods.E_NOTIMPL;
        }

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="TextTipData.GetContextStream"]/*' />
        public virtual int GetContextStream(out int piPos, out int piLen) {
            piPos = this.pos;
            piLen = this.len;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="TextTipData.OnDismiss"]/*' />
        public virtual void OnDismiss() {
            this.isWindowUp = false;
        }

        /// <include file='doc\ViewFilter.uex' path='docs/doc[@for="TextTipData.UpdateView"]/*' />
        public virtual void UpdateView() {
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\LanguageService100\Utilities.cs ===
//------------------------------------------------------------------------------
// <copyright file="LanguageService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <owner current="true" primary="true">clovett</owner>
// <owner current="true" primary="false">tejalj</owner>
//------------------------------------------------------------------------------
using System;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.TextManager.Interop;
using Microsoft.VisualStudio.Shell;
using System.Diagnostics;
using System.IO;
using System.Collections;
using System.Runtime.InteropServices;
using System.Windows.Forms;

namespace Microsoft.VisualStudio.Package {
    
    internal class NativeHelpers {
        private NativeHelpers() { }

        public static void RaiseComError(int hr) {
            throw new COMException("", (int)hr);
        }
        public static void RaiseComError(int hr, string message) {
            throw new COMException(message, (int)hr);
        }
        
    }

    /// <include file='doc\Utilities.uex' path='docs/doc[@for="CompoundActionHelpers"]/*' />
    public abstract class CompoundActionFactory {
        [CLSCompliant(false)]
        public static CompoundActionBase GetCompoundAction(IVsTextView view, Source src, string description) {
            if (view != null) {
                return new CompoundViewAction(view, description);
            } else if (src != null) {
                return new CompoundAction(src, description);
            } else {
                throw new ArgumentNullException("Either view or src is expected to be non null");
            }
        }
    }

    /// <include file='doc\Utilities.uex' path='docs/doc[@for="TextSpanHelper"]/*' />
    [CLSCompliant(false)]
    public sealed class TextSpanHelper {

    private TextSpanHelper(){}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="TextSpanHelper.StartsAfterStartOf"]/*' />
        /// <devdoc>Returns true if the first span starts after the start of the second span.</devdoc>
        public static bool StartsAfterStartOf(TextSpan span1, TextSpan span2) {
            return (span1.iStartLine > span2.iStartLine || (span1.iStartLine == span2.iStartLine && span1.iStartIndex >= span2.iStartIndex));
        }
        /// <include file='doc\Utilities.uex' path='docs/doc[@for="TextSpanHelper.StartsAfterEndOf"]/*' />
        /// <devdoc>Returns true if the first span starts after the end of the second span.</devdoc>
        public static bool StartsAfterEndOf(TextSpan span1, TextSpan span2) {
            return (span1.iStartLine > span2.iEndLine || (span1.iStartLine == span2.iEndLine && span1.iStartIndex >= span2.iEndIndex));
        }
        /// <include file='doc\Utilities.uex' path='docs/doc[@for="TextSpanHelper.StartsBeforeStartOf"]/*' />
        /// <devdoc>Returns true if the first span starts before the start of the second span.</devdoc>
        public static bool StartsBeforeStartOf(TextSpan span1, TextSpan span2) {
            return !StartsAfterStartOf(span1, span2);
        }
        /// <include file='doc\Utilities.uex' path='docs/doc[@for="TextSpanHelper.StartsBeforeEndOf"]/*' />
        /// <devdoc>Returns true if the first span starts before the end of the second span.</devdoc>
        public static bool StartsBeforeEndOf(TextSpan span1, TextSpan span2) {
            return (span1.iStartLine < span2.iEndLine ||
                (span1.iStartLine == span2.iEndLine && span1.iStartIndex < span2.iEndIndex));
        }

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="TextSpanHelper.EndsBeforeStartOf"]/*' />
        /// <devdoc>Returns true if the first span ends before the start of the second span.</devdoc>
        public static bool EndsBeforeStartOf(TextSpan span1, TextSpan span2) {
            return (span1.iEndLine < span2.iStartLine || (span1.iEndLine == span2.iStartLine && span1.iEndIndex <= span2.iStartIndex));
        }
        /// <include file='doc\Utilities.uex' path='docs/doc[@for="TextSpanHelper.EndsBeforeEndOf"]/*' />
        /// <devdoc>Returns true if the first span starts before the end of the second span.</devdoc>
        public static bool EndsBeforeEndOf(TextSpan span1, TextSpan span2) {
            return (span1.iEndLine < span2.iEndLine || (span1.iEndLine == span2.iEndLine && span1.iEndIndex <= span2.iEndIndex));
        }
        /// <include file='doc\Utilities.uex' path='docs/doc[@for="TextSpanHelper.EndsAfterStartOf"]/*' />
        /// <devdoc>Returns true if the first span ends after the start of the second span.</devdoc>
        public static bool EndsAfterStartOf(TextSpan span1, TextSpan span2) {
            return (span1.iEndLine > span2.iStartLine ||
                (span1.iEndLine == span2.iStartLine && span1.iEndIndex > span2.iStartIndex));
        }
        /// <include file='doc\Utilities.uex' path='docs/doc[@for="TextSpanHelper.EndsBeforeEndOf"]/*' />
        /// <devdoc>Returns true if the first span starts after the end of the second span.</devdoc>
        public static bool EndsAfterEndOf(TextSpan span1, TextSpan span2) {
            return !EndsBeforeEndOf(span1, span2);
        }

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="TextSpanHelper.Merge"]/*' />
        public static TextSpan Merge(TextSpan span1, TextSpan span2) {
            TextSpan span = new TextSpan();

            if (StartsAfterStartOf(span1, span2)) {
                span.iStartLine = span2.iStartLine;
                span.iStartIndex = span2.iStartIndex;
            } else {
                span.iStartLine = span1.iStartLine;
                span.iStartIndex = span1.iStartIndex;
            }

            if (EndsBeforeEndOf(span1, span2)) {
                span.iEndLine = span2.iEndLine;
                span.iEndIndex = span2.iEndIndex;
            } else {
                span.iEndLine = span1.iEndLine;
                span.iEndIndex = span1.iEndIndex;
            }

            return span;
        }
        /// <include file='doc\Utilities.uex' path='docs/doc[@for="TextSpanHelper.IsPositive"]/*' />
        public static bool IsPositive(TextSpan span) {
            return (span.iStartLine < span.iEndLine || (span.iStartLine == span.iEndLine && span.iStartIndex <= span.iEndIndex));
        }
        /// <include file='doc\Utilities.uex' path='docs/doc[@for="TextSpanHelper.ClearTextSpan"]/*' />
        public static void Clear(ref TextSpan span) {
            span.iStartLine = span.iEndLine = 0;
            span.iStartIndex = span.iEndIndex = 0;
        }
        /// <include file='doc\Utilities.uex' path='docs/doc[@for="TextSpanHelper.IsEmpty"]/*' />
        public static bool IsEmpty(TextSpan span) {
            return (span.iStartLine == span.iEndLine) && (span.iStartIndex == span.iEndIndex);
        }
        /// <include file='doc\Utilities.uex' path='docs/doc[@for="TextSpanHelper.MakePositive"]/*' />
        public static void MakePositive(ref TextSpan span) {
            if (!IsPositive(span)) {
                int line;
                int idx;

                line = span.iStartLine;
                idx = span.iStartIndex;
                span.iStartLine = span.iEndLine;
                span.iStartIndex = span.iEndIndex;
                span.iEndLine = line;
                span.iEndIndex = idx;
            }

            return;
        }
        /// <include file='doc\Utilities.uex' path='docs/doc[@for="TextSpanHelper.TextSpanNormalize"]/*' />
        /// <devdoc>Pins the text span to valid line bounds returned from IVsTextLines.</devdoc>
        public static void Normalize(ref  TextSpan span, IVsTextLines textLines) {
            MakePositive(ref span);
            if (textLines == null) return;
            //adjust max. lines
            int lineCount;
            if (NativeMethods.Failed(textLines.GetLineCount(out lineCount)) )
                return;
            span.iEndLine = Math.Min(span.iEndLine, lineCount - 1);
            //make sure the start is still before the end
            if (!IsPositive(span)) {
                span.iStartLine = span.iEndLine;
                span.iStartIndex = span.iEndIndex;
            }
            //adjust for line length
            int lineLength;
            if ( NativeMethods.Failed(textLines.GetLengthOfLine(span.iStartLine, out lineLength)) )
                return;
            span.iStartIndex = Math.Min(span.iStartIndex, lineLength);
            if ( NativeMethods.Failed( textLines.GetLengthOfLine(span.iEndLine, out lineLength)) )
                return;
            span.iEndIndex = Math.Min(span.iEndIndex, lineLength);
        }

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="TextSpanHelper.IsSameSpan"]/*' />
        public static bool IsSameSpan(TextSpan span1, TextSpan span2) {
            return span1.iStartLine == span2.iStartLine && span1.iStartIndex == span2.iStartIndex && span1.iEndLine == span2.iEndLine && span1.iEndIndex == span2.iEndIndex;
        }

        // Returns true if the given position is to left of textspan.
        /// <include file='doc\Utilities.uex' path='docs/doc[@for="TextSpanHelper.IsBeforeStartOf"]/*' />
        public static bool IsBeforeStartOf(TextSpan span, int line, int col) {
            if (line < span.iStartLine || (line == span.iStartLine && col < span.iStartIndex)) {
                return true;
            }
            return false;
        }

        // Returns true if the given position is to right of textspan.
        /// <include file='doc\Utilities.uex' path='docs/doc[@for="TextSpanHelper.IsAfterEndOf"]/*' />
        public static bool IsAfterEndOf(TextSpan span, int line, int col) {
            if (line > span.iEndLine || (line == span.iEndLine && col > span.iEndIndex)) {
                return true;
            }
            return false;
        }

        // Returns true if the given position is at the edge or inside the span.
        /// <include file='doc\Utilities.uex' path='docs/doc[@for="TextSpanHelper.ContainsInclusive"]/*' />
        public static bool ContainsInclusive(TextSpan span, int line, int col) {
            if (line > span.iStartLine && line < span.iEndLine)
                return true;

            if (line == span.iStartLine) {
                return (col >= span.iStartIndex && (line < span.iEndLine ||
                    (line == span.iEndLine && col <= span.iEndIndex )));
            }
            if (line == span.iEndLine) {
                return col <= span.iEndIndex;
            }
            return false;
        }
        
        // Returns true if the given position is purely inside the span.
        /// <include file='doc\Utilities.uex' path='docs/doc[@for="TextSpanHelper.ContainsExclusive"]/*' />
        public static bool ContainsExclusive(TextSpan span, int line, int col) {
            if (line > span.iStartLine && line < span.iEndLine)
                return true;

            if (line == span.iStartLine) {
                return (col > span.iStartIndex && (line < span.iEndLine ||
                    (line == span.iEndLine && col < span.iEndIndex)));
            }
            if (line == span.iEndLine) {
                return col < span.iEndIndex;
            }
            return false;
        }

        //returns true is span1 is Embedded in span2
        /// <include file='doc\Utilities.uex' path='docs/doc[@for="TextSpanHelper.IsEmbedded"]/*' />
        public static bool IsEmbedded(TextSpan span1, TextSpan span2) {
            return ( !TextSpanHelper.IsSameSpan(span1, span2) &&
                TextSpanHelper.StartsAfterStartOf(span1, span2) &&
                    TextSpanHelper.EndsBeforeEndOf(span1, span2));
        }

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="TextSpanHelper.Intersects"]/*' />
        public static bool Intersects(TextSpan span1, TextSpan span2) {
            return TextSpanHelper.StartsBeforeEndOf(span1, span2) &&
                TextSpanHelper.EndsAfterStartOf(span1, span2);
        }

        // This method simulates what VS does in debug mode so that we can catch the
        // errors in managed code before they go to the native debug assert.
        /// <include file='doc\Utilities.uex' path='docs/doc[@for="TextSpanHelper.ValidSpan"]/*' />
        public static bool ValidSpan(Source src, TextSpan span) {
            if (!ValidCoord(src, span.iStartLine, span.iStartIndex))
                return false;

            if (!ValidCoord(src, span.iEndLine, span.iEndIndex))
                return false;

            // end must be >= start
            if (!TextSpanHelper.IsPositive(span))
                return false;

            return true;
        }

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="TextSpanHelper.ValidCoord"]/*' />
        public static bool ValidCoord(Source src, int line, int pos) {
            // validate line
            if (line < 0) {
                Debug.Assert(false, "line < 0");
                return false;
            }

            // validate index
            if (pos < 0) {
                Debug.Assert(false, "pos < 0");
                return false;
            }

            if (src != null) {
                int lineCount = src.GetLineCount();
                if (line >= lineCount) {
                    Debug.Assert(false, "line > linecount");
                    return false;
                }

                int lineLength = src.GetLineLength(line);
                if (pos > lineLength) {
                    Debug.Assert(false, "pos > linelength");
                    return false;
                }

            }
            return true;
        }

    }

    /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant"]/*' />
    [CLSCompliant(false), StructLayout(LayoutKind.Sequential)]
    public struct Variant {

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType"]/*' />
        public enum VariantType {
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_EMPTY"]/*' />
            VT_EMPTY = 0,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_NULL"]/*' />
            VT_NULL = 1,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_I2"]/*' />
            VT_I2 = 2,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_I4"]/*' />
            VT_I4 = 3,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_R4"]/*' />
            VT_R4 = 4,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_R8"]/*' />
            VT_R8 = 5,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_CY"]/*' />
            VT_CY = 6,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_DATE"]/*' />
            VT_DATE = 7,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_BSTR"]/*' />
            VT_BSTR = 8,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_DISPATCH"]/*' />
            VT_DISPATCH = 9,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_ERROR"]/*' />
            VT_ERROR = 10,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_BOOL"]/*' />
            VT_BOOL = 11,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_VARIANT"]/*' />
            VT_VARIANT = 12,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_UNKNOWN"]/*' />
            VT_UNKNOWN = 13,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_DECIMAL"]/*' />
            VT_DECIMAL = 14,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_I1"]/*' />
            VT_I1 = 16,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_UI1"]/*' />
            VT_UI1 = 17,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_UI2"]/*' />
            VT_UI2 = 18,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_UI4"]/*' />
            VT_UI4 = 19,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_I8"]/*' />
            VT_I8 = 20,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_UI8"]/*' />
            VT_UI8 = 21,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_INT"]/*' />
            VT_INT = 22,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_UINT"]/*' />
            VT_UINT = 23,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_VOID"]/*' />
            VT_VOID = 24,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_HRESULT"]/*' />
            VT_HRESULT = 25,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_PTR"]/*' />
            VT_PTR = 26,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_SAFEARRAY"]/*' />
            VT_SAFEARRAY = 27,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_CARRAY"]/*' />
            VT_CARRAY = 28,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_USERDEFINED"]/*' />
            VT_USERDEFINED = 29,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_LPSTR"]/*' />
            VT_LPSTR = 30,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_LPWSTR"]/*' />
            VT_LPWSTR = 31,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_FILETIME"]/*' />
            VT_FILETIME = 64,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_BLOB"]/*' />
            VT_BLOB = 65,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_STREAM"]/*' />
            VT_STREAM = 66,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_STORAGE"]/*' />
            VT_STORAGE = 67,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_STREAMED_OBJECT"]/*' />
            VT_STREAMED_OBJECT = 68,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_STORED_OBJECT"]/*' />
            VT_STORED_OBJECT = 69,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_BLOB_OBJECT"]/*' />
            VT_BLOB_OBJECT = 70,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_CF"]/*' />
            VT_CF = 71,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_CLSID"]/*' />
            VT_CLSID = 72,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_VECTOR"]/*' />
            VT_VECTOR = 0x1000,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_ARRAY"]/*' />
            VT_ARRAY = 0x2000,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_BYREF"]/*' />
            VT_BYREF = 0x4000,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_RESERVED"]/*' />
            VT_RESERVED = 0x8000,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_ILLEGAL"]/*' />
            VT_ILLEGAL = 0xffff,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_ILLEGALMASKED"]/*' />
            VT_ILLEGALMASKED = 0xfff,
            /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.VariantType.VT_TYPEMASK"]/*' />
            VT_TYPEMASK = 0xfff
        };

        private ushort vt;

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.Vt"]/*' />
        public VariantType Vt {
            get {
                return (VariantType)vt;
            }
            set {
                vt = (ushort)value;
            }
        }
        short reserved1;
        short reserved2;
        short reserved3;

        private long value;

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.Value"]/*' />
        public long Value {
            get {
                return this.value;
            }
            set {
                this.value = value;
            }
        }

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.ToVariant"]/*' />
        public static Variant ToVariant(IntPtr ptr) {
            // Marshal.GetObjectForNativeVariant is doing way too much work.
            // it is safer and more efficient to map only those things we 
            // care about.

            try {
                Variant v = (Variant)Marshal.PtrToStructure(ptr, typeof(Variant));
                return v;
#if DEBUG
            } catch (ArgumentException e) {
                Debug.Assert(false, e.Message);
#else
                } catch (ArgumentException) {
#endif
            }
            return new Variant();
        }

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="Variant.ToChar"]/*' />
        public char ToChar() {
            if (this.Vt == VariantType.VT_UI2) {
                ushort cv = (ushort)(this.value & 0xffff);
                return Convert.ToChar(cv);
            }
            return '\0';
        }

    }
    /// <include file='doc\Utilities.uex' path='docs/doc[@for="TimeUtilities"]/*' />
    [CLSCompliant(false)]
    internal sealed class TimeUtilities {
        public static int TimeSince(int start) {
            int ticks = Environment.TickCount;
            long t = (long)ticks;
            long s = (long)start;
            // ticks wraps around every 29 days from int.MaxValue to int.MinValue, so we have to watch out 
            // for wrap around!
            if (ticks < start) {
                s = s - (long)int.MaxValue;
                t = t - (long)int.MinValue;
            }
            return (int)Math.Min((long)int.MaxValue, t - s);
        }
    }

    /// <include file='doc\Utilities.uex' path='docs/doc[@for="FilePathUtilities"]/*' />
    [CLSCompliant(false)]
    public sealed class FilePathUtilities    {
        /// <include file='doc\Utilities.uex' path='docs/doc[@for="FilePathUtilities.GetFilePath"]/*' />
        /// <summary>
        /// Get path for text buffer.
        /// </summary>
        /// <param name="textLines">The text buffer.</param>
        /// <returns>The path of the text buffer.</returns>
        [CLSCompliant(false)]
        public static string GetFilePath(IVsTextLines textLines){
            if (textLines == null){
                throw new ArgumentNullException("textLines");
            }

            return GetFilePathInternal(textLines);
        }

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="FilePathUtilities.GetFilePath"]/*' />
        /// <summary>
        /// Get file path for an object that is implementing IVsUserData.
        /// </summary>
        /// <param name="unknown">Reference to an IUnknown interface.</param>
        /// <returns>The file path</returns>
        public static string GetFilePath(IntPtr unknown){
            if (unknown == IntPtr.Zero){
                throw new ArgumentNullException("unknown");}
            object obj = Marshal.GetObjectForIUnknown(unknown);
            return GetFilePathInternal(obj);
        }

        internal static string GetFilePathInternal(object obj){
            string fname = null;
            int hr = 0;
            IVsUserData ud = obj as IVsUserData;
            if (ud != null){
                object oname;
                Guid GUID_VsBufferMoniker = typeof(IVsUserData).GUID;
                hr = ud.GetData(ref GUID_VsBufferMoniker, out oname);
                if (ErrorHandler.Succeeded(hr) && oname != null)
                    fname = oname.ToString();
            }
            if (string.IsNullOrEmpty(fname)){
                IPersistFileFormat fileFormat = obj as IPersistFileFormat;
                if (fileFormat != null)
                {
                    uint format;
                    hr = fileFormat.GetCurFile(out fname, out format);
                }
            }
            if (!string.IsNullOrEmpty(fname)){
                Url url = new Url(fname);
                if (!url.Uri.IsAbsoluteUri){
                    // make the file name absolute using app startup path...
                    Url baseUrl = new Url(Application.StartupPath + Path.DirectorySeparatorChar);
                    url = new Url(baseUrl, fname);
                    fname = url.AbsoluteUrl;
                }
            }
            return fname;
        }

        /// <include file='doc\HierarchyItem.uex' path='docs/doc[@for="VsShell.GetFilePath"]/*' />
        /// <summary>This method returns the file extension in lower case, including the "."
        /// and trims any blanks or null characters from the string.  Null's can creep in via
        /// interop if we get a badly formed BSTR</summary>
        public static string GetFileExtension(string moniker){
            string ext = Path.GetExtension(moniker);
            ext = ext.Trim();
            int i = 0;
            for (i = ext.Length - 1; i >= 0; i--){
                if (ext[i] != '\0') break;
            }
            i++;
            if (i >= 0 && i < ext.Length) ext = ext.Substring(0, i);
            return ext;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\PropertyPageBase\Constants.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

public static class Constants
{
	public const uint SW_SHOW = 5;
	public const uint SW_SHOWNORMAL = 1;
	public const uint SW_HIDE = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\PropertyPageBase\IPageViewSite.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Collections.Generic;
using System.Text;

namespace PropertyPageBase
{
	public interface IPageViewSite
	{
		void PropertyChanged(string propertyName, string propertyValue);

		string GetValueForProperty(string propertyName);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\PropertyPageBase\IPropertyPageUI.cs ===
/***************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Windows.Forms;

namespace PropertyPageBase
{
	public interface IPropertyPageUI
	{
		event UserEditCompleteHandler UserEditComplete;

		string GetControlValue(Control control);
		void SetControlValue(Control control, string value);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\PropertyPageBase\IPageView.cs ===
﻿/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Drawing;
namespace PropertyPageBase
{
	public interface IPageView : System.IDisposable
	{
		void Initialize(System.Windows.Forms.Control parentControl, System.Drawing.Rectangle rectangle);
		void MoveView(System.Drawing.Rectangle rectangle);
		void ShowView();
		void HideView();

		int ProcessAccelerator(ref System.Windows.Forms.Message message);

		void RefreshPropertyValues();
	
		Size ViewSize { get; }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\LanguageService100\Microsoft.VisualStudio.Package.LanguageService.cs ===
﻿/**************************************************************************************/
/* This file was generated by the ResXCodeGenerator. Do not edit or checkin this file */
/**************************************************************************************/

namespace Microsoft.VisualStudio.Package {
    using System;
    using System.Reflection;
    using System.Globalization;
    using System.Resources;
    using System.Text;
    using System.Threading;
    using System.ComponentModel;
    using System.Security.Permissions;

   [AttributeUsage(AttributeTargets.All)]
    internal sealed class SRDescriptionAttribute : DescriptionAttribute {

        private bool replaced = false;

        public SRDescriptionAttribute(string description) : base(description) {
        }

        public override string Description {
            get {
                if (!replaced) {
                    replaced = true;
                    DescriptionValue = SR.GetString(base.Description);
                }
                return base.Description;
            }
        }
    }

    [AttributeUsage(AttributeTargets.All)]
    internal sealed class SRCategoryAttribute : CategoryAttribute {

        public SRCategoryAttribute(string category) : base(category) {
        }

        protected override string GetLocalizedString(string value) {
            return SR.GetString(value);
        }
    }
    internal sealed class SR {
    internal const string BraceMatchStatus = "BraceMatchStatus";
    internal const string BufferChanged = "BufferChanged";
    internal const string ComboMembersTip = "ComboMembersTip";
    internal const string ComboTypesTip = "ComboTypesTip";
    internal const string CommentSelection = "CommentSelection";
    internal const string EditIntersects = "EditIntersects";
    internal const string FormatSpan = "FormatSpan";
    internal const string MaxErrorsReached = "MaxErrorsReached";
    internal const string NoExpansionSession = "NoExpansionSession";
    internal const string Truncated = "Truncated";
    internal const string UncommentSelection = "UncommentSelection";
    internal const string UnsupportedFormat = "UnsupportedFormat";
    internal const string TemplateNotPrepared = "TemplateNotPrepared";
    internal const string UnknownBuffer = "UnknownBuffer";
    internal const string UnrecognizedFilterFormat = "UnrecognizedFilterFormat";

        static SR loader = null;
        ResourceManager resources;

        private static Object s_InternalSyncObject;
        private static Object InternalSyncObject {
            get {
                if (s_InternalSyncObject == null) {
                    Object o = new Object();
                    Interlocked.CompareExchange(ref s_InternalSyncObject, o, null);
                }
                return s_InternalSyncObject;
            }
        }
        
        internal SR() {
            resources = new System.Resources.ResourceManager("Microsoft.VisualStudio.Package.LanguageService", this.GetType().Assembly);
        }
        
        private static SR GetLoader() {
            if (loader == null) {
                lock (InternalSyncObject) {
                   if (loader == null) {
                       loader = new SR();
                   }
               }
            }
            
            return loader;
        }

        private static CultureInfo Culture {
            get { return null/*use ResourceManager default, CultureInfo.CurrentUICulture*/; }
        }
        
        public static ResourceManager Resources {
            get {
                return GetLoader().resources;
            }
        }
        
        public static string GetString(string name, params object[] args) {
            SR sys = GetLoader();
            if (sys == null)
                return null;
            string res = sys.resources.GetString(name, SR.Culture);

            if (args != null && args.Length > 0) {
                return String.Format(CultureInfo.CurrentCulture, res, args);
            }
            else {
                return res;
            }
        }

        public static string GetString(string name) {
            SR sys = GetLoader();
            if (sys == null)
                return null;
            return sys.resources.GetString(name, SR.Culture);
        }
        
        public static object GetObject(string name) {
            SR sys = GetLoader();
            if (sys == null)
                return null;
            return sys.resources.GetObject(name, SR.Culture);
        }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\PropertyPageBase\IPropertyStore.cs ===
﻿/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
namespace PropertyPageBase
{
	public delegate void StoreChangedDelegate();

	public interface IPropertyStore
	{
		void Dispose();
		void Initialize(object[] dataObject);
		void Persist(string propertyName, string propertyValue);
		string PropertyValue(string propertyName);

		event StoreChangedDelegate StoreChanged;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\PropertyPageBase\UserEditCompleteHandler.cs ===
/***************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Windows.Forms;

namespace PropertyPageBase
{
	public delegate void UserEditCompleteHandler(Control control, string value);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\PropertyPageBase\PropertyControlMap.cs ===
/***************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Collections.Generic;
using System.Windows.Forms;

namespace PropertyPageBase
{
	public class PropertyControlMap
	{
		private IPageViewSite m_pageViewSite;
		private PropertyControlTable m_propertyControlTable;
		private IPropertyPageUI m_propertyPageUI;

		public PropertyControlMap(IPageViewSite pageViewSite, IPropertyPageUI propertyPageUI, PropertyControlTable propertyControlTable)
		{
			m_propertyControlTable = propertyControlTable;
			m_pageViewSite = pageViewSite;
			m_propertyPageUI = propertyPageUI;
		}

		void m_propertyPageUI_UserEditComplete(Control control, string value)
		{
			string propertyName = m_propertyControlTable.GetPropertyNameFromControl(control);
			m_pageViewSite.PropertyChanged(propertyName, value);
		}

		public void InitializeControls()
		{
			m_propertyPageUI.UserEditComplete -= new UserEditCompleteHandler(m_propertyPageUI_UserEditComplete);
			List<string> propertyNames = m_propertyControlTable.GetPropertyNames();
			foreach (string propertyName in propertyNames)
			{
				string propertyValue = m_pageViewSite.GetValueForProperty(propertyName);
				Control control = m_propertyControlTable.GetControlFromPropertyName(propertyName);
				m_propertyPageUI.SetControlValue(control, propertyValue);
			}
			m_propertyPageUI.UserEditComplete += new UserEditCompleteHandler(m_propertyPageUI_UserEditComplete);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\PropertyPageBase\PropertyPage.cs ===
/***************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Collections.Generic;
using System.Windows.Forms;
using System.Drawing;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio;
using System.Runtime.InteropServices;

namespace PropertyPageBase
{
	abstract public class PropertyPage : Microsoft.VisualStudio.OLE.Interop.IPropertyPage2, IPageViewSite
	{
		private KeyValuePair<string, string>? propertyToBePersisted;
		private IPropertyPageSite m_IPropertyPageSite;
		public Microsoft.VisualStudio.OLE.Interop.IPropertyPageSite IPropertyPageSite
		{
			get
			{
				return m_IPropertyPageSite;
			}
			set
			{
				m_IPropertyPageSite = value;
			}
		}

		private IPropertyStore m_IPropertyStore;
		public IPropertyStore IPropertyStore
		{
			get
			{
				return m_IPropertyStore;
			}
			set
			{
				m_IPropertyStore = value;
			}
		}

		abstract public string Title { get; }

		#region IPropertyPage2 Members

		public void Activate(IntPtr hWndParent, RECT[] pRect, int bModal)
		{
            if ((null == pRect) || (0 == pRect.Length))
            {
                throw new ArgumentNullException("pRect");
            }
			Control parentControl = Control.FromHandle(hWndParent);
			RECT pageRectangle = pRect[0];
			MyPageView.Initialize(parentControl, Rectangle.FromLTRB(pageRectangle.left, pageRectangle.top, pageRectangle.right, pageRectangle.bottom));
		}

		protected PropertyPageBase.IPageView myPageView;

		public PropertyPageBase.IPageView MyPageView
		{
			get 
			{
				if (myPageView == null)
				{
					IPageView concretePageView = GetNewPageView();
					this.MyPageView = concretePageView;
				}
				return myPageView; 
			}
			set { myPageView = value; }
		}


		abstract protected PropertyPageBase.IPageView GetNewPageView();

		abstract protected IPropertyStore GetNewPropertyStore();

		public void Apply()
		{
			if (propertyToBePersisted.HasValue)
			{
				IPropertyStore.Persist(propertyToBePersisted.Value.Key, propertyToBePersisted.Value.Value);
				propertyToBePersisted = null;
			}
		}

		public void Deactivate()
		{
            if (null != myPageView)
            {
                myPageView.Dispose();
                myPageView = null;
            }
		}

		public void EditProperty(int DISPID)
		{
			
		}

		public void GetPageInfo(Microsoft.VisualStudio.OLE.Interop.PROPPAGEINFO[] pPageInfo)
		{
            if ((null == pPageInfo) || (0 == pPageInfo.Length))
            {
                throw new ArgumentNullException("pPageInfo");
            }

			PROPPAGEINFO pageInfo;

			pageInfo.cb = (uint)Marshal.SizeOf(typeof(PROPPAGEINFO));
			pageInfo.dwHelpContext = 0;
			pageInfo.pszDocString = null;
			pageInfo.pszHelpFile = null;
			pageInfo.pszTitle = Title;
			pageInfo.SIZE.cx = MyPageView.ViewSize.Width;
			pageInfo.SIZE.cy = MyPageView.ViewSize.Height;

			pPageInfo[0] = pageInfo;
		}

		abstract protected string HelpKeyword { get; }

		public void Help(string pszHelpDir)
		{
			System.IServiceProvider serviceProvider = IPropertyPageSite as System.IServiceProvider;

            if (null != serviceProvider)
            {
                Microsoft.VisualStudio.VSHelp.Help helpService = serviceProvider.GetService(typeof(Microsoft.VisualStudio.VSHelp.Help)) as Microsoft.VisualStudio.VSHelp.Help;
                if (null != helpService)
                {
                    helpService.DisplayTopicFromF1Keyword(HelpKeyword);
                }
            }
		}

		public int IsPageDirty()
		{
			return propertyToBePersisted.HasValue ? VSConstants.S_OK : VSConstants.S_FALSE;
		}

		public void Move(Microsoft.VisualStudio.OLE.Interop.RECT[] pRect)
		{
			MyPageView.MoveView(Rectangle.FromLTRB(pRect[0].left, pRect[0].top, pRect[0].right, pRect[0].bottom));
		}

		public void SetObjects(uint cObjects, object[] ppunk)
		{
			if (ppunk == null || cObjects == 0)
			{
                if (null != IPropertyStore)
                {
                    IPropertyStore.Dispose();
                    IPropertyStore = null;
                }
			}
			else
			{
				bool needToRefresh = false;
				if (IPropertyStore != null)
					needToRefresh = true;
				IPropertyStore = GetNewPropertyStore();
				IPropertyStore.Initialize(ppunk);
				if (needToRefresh)
					MyPageView.RefreshPropertyValues();
			}
		}

		public void SetPageSite(Microsoft.VisualStudio.OLE.Interop.IPropertyPageSite pPageSite)
		{
			IPropertyPageSite = pPageSite;
		}

		public void Show(uint nCmdShow)
		{
			switch (nCmdShow)
			{
				case Constants.SW_HIDE:
					MyPageView.HideView();
					break;
				case Constants.SW_SHOW:
				case Constants.SW_SHOWNORMAL:
					MyPageView.ShowView();
					break;
				default:
					break;
			}
		}

		public int TranslateAccelerator(Microsoft.VisualStudio.OLE.Interop.MSG[] pMsg)
		{
			Message keyboardMessage = Message.Create(pMsg[0].hwnd, (int)pMsg[0].message, pMsg[0].wParam, pMsg[0].lParam);
			int hr = MyPageView.ProcessAccelerator(ref keyboardMessage);
			pMsg[0].lParam = keyboardMessage.LParam;
			pMsg[0].wParam = keyboardMessage.WParam;
			return hr;
		}

		#endregion

		#region IPropertyPage Members


		int IPropertyPage.Apply()
		{
			Apply();
			return VSConstants.S_OK;
		}

		#endregion

		#region IPageViewSite Members

		public void PropertyChanged(string propertyName, string propertyValue)
		{
            // If there is no store, then there is no point in changing the property value.
            if (null == IPropertyStore)
            {
                return;
            }
			propertyToBePersisted = new KeyValuePair<string, string>(propertyName, propertyValue);
            if (null != IPropertyPageSite)
            {
                IPropertyPageSite.OnStatusChange((uint)(PROPPAGESTATUS.PROPPAGESTATUS_DIRTY | PROPPAGESTATUS.PROPPAGESTATUS_VALIDATE));
            }
		}

		public string GetValueForProperty(string propertyName)
		{
            if (null != IPropertyStore)
            {
                return IPropertyStore.PropertyValue(propertyName);
            }
            return null;
		}

		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\PropertyPageBase\PropertyControlTable.cs ===
/***************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Collections.Generic;
using System.Windows.Forms;

namespace PropertyPageBase
{
	public class PropertyControlTable
	{
		private Dictionary<Control, string> m_controlNameIndex = new Dictionary<Control, string>();
		private Dictionary<string, Control> m_propertyNameIndex = new Dictionary<string, Control>();

		public void Add(string propertyName, Control control)
		{
			m_controlNameIndex.Add(control, propertyName);
			m_propertyNameIndex.Add(propertyName, control);
		}

		public Control GetControlFromPropertyName(string propertyName)
		{
            Control control;
            if (m_propertyNameIndex.TryGetValue(propertyName, out control))
            {
                return control;
            }
            return null;
		}

		public string GetPropertyNameFromControl(Control control)
		{
            string propertyName;
            if (m_controlNameIndex.TryGetValue(control, out propertyName))
            {
                return propertyName;
            }
			return null;
		}

		public void Remove(string propertyName, Control control)
		{
			m_controlNameIndex.Remove(control);
			m_propertyNameIndex.Remove(propertyName);
		}

		public List<string> GetPropertyNames()
		{
			string[] keys = new string[m_propertyNameIndex.Count];
			m_propertyNameIndex.Keys.CopyTo(keys, 0);
			return new List<string>(keys);
		}

		public List<Control> GetControls()
		{
			Control[] keys = new Control[m_controlNameIndex.Count];
			m_controlNameIndex.Keys.CopyTo(keys, 0);
			return new List<Control>(keys);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\PropertyPageBase\PageView.cs ===
/***************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Windows.Forms;
using Microsoft.VisualStudio;

namespace PropertyPageBase
{
	public class PageView : UserControl, IPageView, IPropertyPageUI
	{
		[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
		public PageView()
		{
		}

		public PageView(IPageViewSite pageViewSite)
		{
			m_propertyControlMap = new PropertyControlMap(pageViewSite, this, PropertyControlTable);
		}

		private PropertyControlMap m_propertyControlMap;

		virtual protected PropertyControlTable PropertyControlTable
		{
			get
			{
				throw new NotImplementedException();
			}
		}

        private void TextBox_TextChanged(object sender, EventArgs e)
        {
            TextBox senderTextBox = sender as TextBox;
            if (UserEditComplete != null)
                UserEditComplete(senderTextBox, senderTextBox.Text);
        }

		void CheckBox_CheckedChanged(object sender, EventArgs e)
		{
			CheckBox senderCheckBox = sender as CheckBox;
			if (UserEditComplete != null)
				UserEditComplete(senderCheckBox, senderCheckBox.Checked.ToString());
		}

		#region IPropertyPageUI Members

		public event UserEditCompleteHandler UserEditComplete;

		public virtual string GetControlValue(Control control)
		{
			CheckBox checkboxWithValue = control as CheckBox;
			if (null != checkboxWithValue)
			{
				return checkboxWithValue.Checked.ToString();
			}
			TextBox textboxWithValue = control as TextBox;
			if (null != textboxWithValue)
			{
				return textboxWithValue.Text;
			}
			throw new ArgumentOutOfRangeException();
		}

		public virtual void SetControlValue(Control control, string value)
		{
			CheckBox checkboxToChange = control as CheckBox;
			if (null != checkboxToChange)
			{
				bool boxIsChecked;
				if (!bool.TryParse(value, out boxIsChecked))
					boxIsChecked = false;
				checkboxToChange.Checked = boxIsChecked;
				return;
			}
			TextBox textboxToChange = control as TextBox;
			if (null != textboxToChange)
			{
				textboxToChange.Text = value;
				return;
			}
		}

		#endregion

		#region IPageView Members

		public virtual void Initialize(System.Windows.Forms.Control parentControl, System.Drawing.Rectangle rectangle)
		{
			this.SetBounds(rectangle.X, rectangle.Y, rectangle.Width, rectangle.Height);
			this.Parent = parentControl;
			m_propertyControlMap.InitializeControls();
			foreach (Control boundControl in PropertyControlTable.GetControls())
			{
				TextBox boundTextBox = boundControl as TextBox;
				if (null != boundTextBox)
				{
					boundTextBox.TextChanged += new EventHandler(TextBox_TextChanged);
					continue;
				}

				CheckBox boundCheckBox = boundControl as CheckBox;
				if (null != boundCheckBox)
				{
					boundCheckBox.CheckedChanged += new EventHandler(CheckBox_CheckedChanged);
					continue;
				}
			}

			// Once done, give the derived class the ability to perform some initialization.
			OnInitialize();
		}

		protected virtual void OnInitialize() { }

		public void MoveView(System.Drawing.Rectangle rectangle)
		{
			this.Location = new Point(rectangle.X, rectangle.Y);
			this.Size = new Size(rectangle.Width, rectangle.Height);
		}

		public void ShowView()
		{
			this.Show();
		}

		public void HideView()
		{
			this.Hide();
		}

		public new void Dispose()
		{
			base.Dispose();
		}

		public int ProcessAccelerator(ref Message keyboardMessage)
		{
			Control destinationControl = Control.FromHandle(keyboardMessage.HWnd);
			bool messageProccessed = destinationControl.PreProcessMessage(ref keyboardMessage);
			if (messageProccessed)
				return VSConstants.S_OK;
			else
				return VSConstants.S_FALSE;
		}

		public Size ViewSize
		{
			get { return Size; }
		}

		public void RefreshPropertyValues()
		{
			m_propertyControlMap.InitializeControls();
		}

		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\RegistrationAttributes\CodeGeneratorRegistrationAttribute.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Globalization;

namespace Microsoft.VisualStudio.Shell
{
	/// <summary>
	/// This attribute adds a custom file generator registry entry for specific file 
    /// type. 
	/// For Example:
	///   [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\9.0\Generators\
    ///		{fae04ec1-301f-11d3-bf4b-00c04f79efbc}\MyGenerator]
    ///			"CLSID"="{AAAA53CC-3D4F-40a2-BD4D-4F3419755476}"
    ///         "GeneratesDesignTimeSource" = d'1'
	/// 
	/// </summary>
	[AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
	public sealed class CodeGeneratorRegistrationAttribute : RegistrationAttribute
	{
		private string _contextGuid;
		private Type _generatorType;
        private Guid _generatorGuid;
		private string _generatorName;
        private string _generatorRegKeyName;
        private bool _generatesDesignTimeSource = false;
        private bool _generatesSharedDesignTimeSource = false;
		/// <summary>
        /// Creates a new CodeGeneratorRegistrationAttribute attribute to register a custom
		/// code generator for the provided context. 
		/// </summary>
        /// <param name="generatorType">The type of Code generator. Type that implements IVsSingleFileGenerator</param>
        /// <param name="generatorName">The generator name</param>
        /// <param name="contextGuid">The context GUID this code generator would appear under.</param>
        public CodeGeneratorRegistrationAttribute(Type generatorType, string generatorName, string contextGuid)
		{
            if (generatorType == null)
                throw new ArgumentNullException("generatorType");
            if (generatorName == null)
                throw new ArgumentNullException("generatorName");
            if (contextGuid == null)
                throw new ArgumentNullException("contextGuid");

            _contextGuid = contextGuid;
            _generatorType = generatorType;
            _generatorName = generatorName;
            _generatorRegKeyName = generatorType.Name;
            _generatorGuid = generatorType.GUID;
        }

		/// <summary>
		/// Get the generator Type
		/// </summary>
		public Type GeneratorType
		{
            get { return _generatorType; }
		}

		/// <summary>
		/// Get the Guid representing the project type
		/// </summary>
		public string ContextGuid
		{
            get { return _contextGuid; }
		}

        /// <summary>
        /// Get the Guid representing the generator type
        /// </summary>
        public Guid GeneratorGuid
        {
            get { return _generatorGuid; }
        }

		/// <summary>
        /// Get or Set the GeneratesDesignTimeSource value
		/// </summary>
        public bool GeneratesDesignTimeSource
		{
            get { return _generatesDesignTimeSource; }
            set { _generatesDesignTimeSource = value; }
		}

        /// <summary>
        /// Get or Set the GeneratesSharedDesignTimeSource value
        /// </summary>
        public bool GeneratesSharedDesignTimeSource
        {
            get { return _generatesSharedDesignTimeSource; }
            set { _generatesSharedDesignTimeSource = value; }
        }


        /// <summary>
        /// Gets the Generator name 
        /// </summary>
        public string GeneratorName
        {
            get { return _generatorName; }
        }

        /// <summary>
        /// Gets the Generator reg key name under 
        /// </summary>
        public string GeneratorRegKeyName
        {
            get { return _generatorRegKeyName; }
            set { _generatorRegKeyName = value; }
        }

        /// <summary>
        /// Property that gets the generator base key name
        /// </summary>
        private string GeneratorRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, @"Generators\{0}\{1}", ContextGuid, GeneratorRegKeyName); }
        }
		/// <summary>
		///     Called to register this attribute with the given context.  The context
		///     contains the location where the registration inforomation should be placed.
		///     It also contains other information such as the type being registered and path information.
		/// </summary>
		public override void Register(RegistrationContext context)
		{
            using (Key childKey = context.CreateKey(GeneratorRegKey))
            {
                childKey.SetValue(string.Empty, GeneratorName);
                childKey.SetValue("CLSID", GeneratorGuid.ToString("B"));

                if (GeneratesDesignTimeSource)
                    childKey.SetValue("GeneratesDesignTimeSource", 1);

                if (GeneratesSharedDesignTimeSource)
                    childKey.SetValue("GeneratesSharedDesignTimeSource", 1);

            }

        }

		/// <summary>
		/// Unregister this file extension.
		/// </summary>
		/// <param name="context"></param>
		public override void Unregister(RegistrationContext context)
		{
            context.RemoveKey(GeneratorRegKey);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\PropertyPageBase\Properties\AssemblyInfo.cs ===
﻿/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("PropertyPageBase")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("PropertyPageBase")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2006")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("4d3fe7e7-4333-4298-b044-58002d495aa8")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\RegistrationAttributes\ComponentPickerPropertyPageAttribute.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Globalization;

namespace Microsoft.VisualStudio.Shell
{
	/// <summary>
	/// This attribute adds the property page registration for Component picker 
	/// For Example:
    /// [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\9.0Exp\ComponentPickerPages\My Component Page]
    /// @="#13925"
    ///     "Package"="{B0002DC2-56EE-4931-93F7-70D6E9863940}"
    ///     "Page"="{0A9F3920-3881-4f50-8986-9EDEC7B33566}"
    ///     "Sort"=dword:00000014
    ///     "AddToMru"=dword:00000000
    ///     "ComponentType"=".Net Assembly"
	/// </summary>
	[AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
	public sealed class ComponentPickerPropertyPageAttribute : RegistrationAttribute
	{
		private string _packageGuid;
		private string _pageGuid;
        private string _pageRegKeyName;

		private string _componentType = null;
        private int _sortOrder = -1;
        private bool _addToMRU = false;
        private string _defaultPageNameValue = "";
        
		/// <summary>
        /// Creates a new ComponentPicker page registration attribute to register a custom
		/// component picker property page. 
		/// </summary>
        /// <param name="packageType">The type of pacakge that provides the page</param>
        /// <param name="pageType">The page type that needs to be registered</param>
        /// <param name="pageRegKeyName">Registry key name for the page.</param>
        public ComponentPickerPropertyPageAttribute(Type packageType, Type pageType, string pageRegKeyName)
		{
            if (packageType == null)
                throw new ArgumentNullException("packageType");
            if (pageType == null)
                throw new ArgumentNullException("pageType");
            if (pageRegKeyName == null)
                throw new ArgumentNullException("pageName");

            _packageGuid = packageType.GUID.ToString("B");
            _pageGuid = pageType.GUID.ToString("B");
            _pageRegKeyName = pageRegKeyName;
        }

		/// <summary>
		/// Get the pacakge Guid
		/// </summary>
		public string PacakgeGuid
		{
            get { return _packageGuid; }
		}

		/// <summary>
		/// Get the Guid representing the property page
		/// </summary>
		public string PageGuid
		{
            get { return _pageGuid; }
		}

        /// <summary>
        /// Get the property page reg key name.
        /// </summary>
        public string PageRegKeyName
        {
            get { return _pageRegKeyName; }
        }

		/// <summary>
        /// Get or Set the AddToMru value
		/// </summary>
        public bool AddToMru
		{
            get { return _addToMRU; }
            set { _addToMRU = value; }
		}

        /// <summary>
        /// Get or set the Component Type value.
        /// </summary>
        public string ComponentType
        {
            get{ return _componentType; }
            set{ _componentType = value; }
        }

        /// <summary>
        /// Get or Set the Sort reg value
        /// </summary>
        public int SortOrder
        {
            get { return _sortOrder; }
            set { _sortOrder = value; }
        }
        
        /// <summary>
        /// get / sets default page name value 
        /// </summary>
        public string DefaultPageNameValue
        {
            get { return _defaultPageNameValue; }
            set { _defaultPageNameValue = value; }
        }

        /// <summary>
        /// Property that gets the page reg key name
        /// </summary>
        private string PageRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, @"ComponentPickerPages\{0}", PageRegKeyName); }
        }
		/// <summary>
		///     Called to register this attribute with the given context.  The context
		///     contains the location where the registration inforomation should be placed.
		///     It also contains other information such as the type being registered and path information.
		/// </summary>
		public override void Register(RegistrationContext context)
		{
            using (Key childKey = context.CreateKey(PageRegKey))
            {
                childKey.SetValue(string.Empty, DefaultPageNameValue);
                childKey.SetValue("Package", PacakgeGuid);
                childKey.SetValue("Page", PageGuid);

                if (SortOrder != -1)
                    childKey.SetValue("Sort", SortOrder);
                if (AddToMru)
                    childKey.SetValue("AddToMru", Convert.ToInt32(AddToMru));
                if (ComponentType != null)
                    childKey.SetValue("ComponentType", ComponentType);

            }

        }

		/// <summary>
		/// Unregister property page
		/// </summary>
		/// <param name="context"></param>
		public override void Unregister(RegistrationContext context)
		{
            context.RemoveKey(PageRegKey);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\RegistrationAttributes\EditorFactoryNotifyForProjectAttribute.cs ===
//***************************************************************************
//
//    Copyright (c) Microsoft Corporation. All rights reserved.
//    This code is licensed under the Visual Studio SDK license terms.
//    THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
//    ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
//    IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
//    PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.
//
//***************************************************************************

using System;
using System.Globalization;

namespace Microsoft.VisualStudio.Shell
{
    /// <summary>
    /// This attribute adds a File Extension for a Project System so that the Project
    /// will call IVsEditorFactoryNotify methods when an item of this type is added 
    /// or renamed.
    /// </summary>
    /// <remarks>
    /// For example:
    ///   [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\9.0\Projects\
    ///		{F184B08F-C81C-45F6-A57F-5ABD9991F28F}\FileExtensions\.addin]
    ///			"EditorFactoryNotify"="{FA3CD31E-987B-443A-9B81-186104E8DAC1}"
    /// </remarks>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
    public sealed class EditorFactoryNotifyForProjectAttribute : RegistrationAttribute
    {
        #region Fields
		private Guid projectType;
		private Guid factoryType;
		private string fileExtension;
        #endregion

        #region Constructors
        /// <summary>
        /// Creates a new ProvideEditorFactoryNotifyForProject attribute to register a 
        /// file extension with a project. 
        /// </summary>
        /// <param name="projectType">The type of project; can be a Type, a GUID or a string representation of a GUID</param>
        /// <param name="factoryType">The type of factory; can be a Type, a GUID or a string representation of a GUID</param>
        /// <param name="fileExtension">The file extension the EditorFactoryNotify wants to handle</param>
        public EditorFactoryNotifyForProjectAttribute(object projectType, string fileExtension, object factoryType)
        {
            if (factoryType == null)
            {
                throw new ArgumentNullException("factoryType", "Factory type can not be null.");
            }
            if (projectType == null)
            {
                throw new ArgumentNullException("projectType", "Project type can not be null.");
            }

            this.fileExtension = fileExtension;

            // figure out what type of object they passed in and get the GUID from it
            if (factoryType is string)
            {
                this.factoryType = new Guid(factoryType.ToString());
            }
            else if (factoryType is Type)
            {
                this.factoryType = ((Type)factoryType).GUID;
            }
            else if (factoryType is Guid)
            {
                this.factoryType = (Guid)factoryType;
            }
            else
            {
                throw new ArgumentException( "Parameter is expected to be an instance of the type 'Type' or 'Guid'.", "factoryType");
            }

            // figure out what type of object they passed in and get the GUID from it
            if (projectType is string)
            {
                this.projectType = new Guid(projectType.ToString());
            }
			else if (projectType is Type)
			{
                this.projectType = ((Type)projectType).GUID;
			}
			else if (projectType is Guid)
            {
                this.projectType = (Guid)projectType;
            }
            else
            {
                throw new ArgumentException("Parameter is expected to be an instance of the type 'Type' or 'Guid'.", "projectType");
            }
        }
        #endregion

        #region Properties
        /// <summary>
        /// Get the Guid representing the type of the editor factory
        /// </summary>
        //public Guid FactoryType
        public object FactoryType
        {
            get { return factoryType; }
        }

        /// <summary>
        /// Get the Guid representing the project type
        /// </summary>
        public object ProjectType
        {
            get { return projectType; }
        }

        /// <summary>
        /// Get or Set the extension of the XML files that support this view
        /// </summary>
        public string FileExtension
        {
            get { return fileExtension; }
        }

        /// <summary>
        /// Extention path within the registration context
        /// </summary>
        private string ProjectFileExtensionPath
        {
            get 
            { 
                return string.Format(CultureInfo.InvariantCulture, "Projects\\{0}\\FileExtensions\\{1}", projectType.ToString("B"), fileExtension); 
            }
        }
        #endregion

        #region Methods
        /// <summary>
        /// Called to register this attribute with the given context.  The context
        /// contains the location where the registration information should be placed.
        /// It also contains other information such as the type being registered and path information.
        /// </summary>
        /// <param name="context">Given context to register in</param>
        public override void Register(RegistrationContext context)
        {
            if (context == null)
            {
            	throw new ArgumentNullException("context");
            }

            context.Log.WriteLine(String.Format(CultureInfo.CurrentCulture, "EditorFactoryNoftifyForProject: {0} Extension = {1}\n", projectType.ToString(), fileExtension));

            using (Key childKey = context.CreateKey(ProjectFileExtensionPath))
            {
                childKey.SetValue("EditorFactoryNotify", factoryType.ToString("B"));
            }
        }

        /// <summary>
        /// Unregister this file extension.
        /// </summary>
        /// <param name="context">Given context to unregister from</param>
        public override void Unregister(RegistrationContext context)
        {
            if (context != null)
            {
                context.RemoveKey(ProjectFileExtensionPath);
            }
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\RegistrationAttributes\ProvideAppCommandLineAttribute.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.ComponentModel.Design;
using System.Globalization;

namespace Microsoft.VisualStudio.Shell
{
    /// <summary>
    /// This attribute adds a commandline option to devenv for a specfic package 
    /// type. 
    /// For Example:
    ///   [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\9.0\AppCommandLine\MyAppCommand
    ///     "Arguments"="*"
    ///     "DemandLoad"=dword:1
    ///     "Package"="{5C48C732-5C7F-40f0-87A7-05C4F15BC8C3}"
    ///     "HelpString"="#200"
    /// 
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
    public sealed class ProvideAppCommandLineAttribute : RegistrationAttribute
    {
        #region fields
        private string _name = null;
        private string _args = null;
        private int _demandLoad = 0;
        private Guid _pkgGuid = Guid.Empty;
        private string _helpString = null; 
        #endregion

        #region ctors
        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="name">Name of new command line option</param>
        /// <param name="packageType">package type</param>
        public ProvideAppCommandLineAttribute(string name, Type packageType)
        {
            if (string.IsNullOrEmpty(name))
                throw new ArgumentNullException("Name is null");

            if (packageType == null)
                throw new ArgumentNullException("Package Type is null.");

            _name = name;
            _pkgGuid = packageType.GUID;
        } 
        #endregion

        #region Properties
        /// <summary>
        /// Name of the command line
        /// </summary>
        public string Name
        {
            get { return _name; }
            set { _name = value; }
        }

        /// <summary>
        /// Default arguments for the command line
        /// </summary>
        public string Arguments
        {
            get { return _args; }
            set { _args = value; }
        }

        /// <summary>
        /// Should the package be demand loaded.
        /// </summary>
        public int DemandLoad
        {
            get { return _demandLoad; }
            set { _demandLoad = value; }
        }

        /// <summary>
        /// Guid of the package providing the command line
        /// </summary>
        public string PackageGuid
        {
            get { return _pkgGuid.ToString("B"); }
            set { _pkgGuid = new Guid(value.ToString()); }
        }

        /// <summary>
        /// Help string to show for the command. Can be a resource id
        /// </summary>
        public string HelpString
        {
            get { return _helpString; }
            set { _helpString = value; }
        }

        #endregion

        #region overridden methods
        /// <summary>
        /// Called to register this attribute with the given context.  The context
        /// contains the location where the registration information should be placed.
        /// it also contains such as the type being registered, and path information.
        /// </summary>
        public override void Register(RegistrationContext context)
        {

            if (context == null)
            {
                throw new ArgumentNullException("context");
            }

            context.Log.WriteLine(String.Format(CultureInfo.CurrentCulture, "AppCommandLineKey: {0} \n", AppCommandLineRegKeyName));

            using (Key childKey = context.CreateKey(AppCommandLineRegKeyName))
            {
                childKey.SetValue("Arguments", Arguments);
                childKey.SetValue("DemandLoad", DemandLoad);
                childKey.SetValue("Package", PackageGuid);
                childKey.SetValue("HelpString", HelpString);
            }
        }

        /// <summary>
        /// Unregister this App command line
        /// </summary>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(AppCommandLineRegKeyName);
        } 
        #endregion

        #region helpers
        /// <summary>
        /// The reg key name of this AppCommandLine.
        /// </summary>
        private string AppCommandLineRegKeyName
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture, @"AppCommandLine\{0}", Name);
            }
        } 
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\RegistrationAttributes\ProvideBindingPathAttribute.cs ===
﻿/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Text;
using System.IO;

namespace Microsoft.VisualStudio.Shell
{
    /// <summary>
    /// This attribute registers a path that should be probed for candidate assemblies at assembly load time.
    /// 
    /// For example:
    ///   [...\VisualStudio\10.0\BindingPaths\{5C48C732-5C7F-40f0-87A7-05C4F15BC8C3}]
    ///     "$PackageFolder$"=""
    ///     
    /// This would register the "PackageFolder" (i.e. the location of the pkgdef file) as a directory to be probed
    /// for assemblies to load.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
    public sealed class ProvideBindingPathAttribute : RegistrationAttribute
    {
        /// <summary>
        /// An optional SubPath to set after $PackageFolder$. This should be used
        /// if the assemblies to be probed reside in a different directory than
        /// the pkgdef file.
        /// </summary>
        public string SubPath { get; set; }

        private static string GetPathToKey(RegistrationContext context)
        {
            return string.Concat(@"BindingPaths\", context.ComponentType.GUID.ToString("B").ToUpperInvariant());
        }

        public override void Register(RegistrationContext context)
        {
            if (context == null)
            {
                throw new ArgumentNullException("context");
            }

            using (Key childKey = context.CreateKey(GetPathToKey(context)))
            {
                StringBuilder keyName = new StringBuilder(context.ComponentPath); 
                if (!string.IsNullOrEmpty(SubPath))
                {
                    keyName.Append("\\");
                    keyName.Append(SubPath);
                }

                childKey.SetValue(keyName.ToString(), string.Empty);
            }
        }

        public override void Unregister(RegistrationContext context)
        {
            if (context == null)
            {
                throw new ArgumentNullException("context");
            }

            context.RemoveKey(GetPathToKey(context));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\RegistrationAttributes\ProvideMSBuildTargetAttribute.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;

namespace Microsoft.VisualStudio.Shell
{
    /// <summary>
    /// This attribute register a custom .targets files to the list of the
    /// targets known and trusted by MSBuild.
    /// 
    /// The registry entries created are:
    ///   [%RegistryRoot%\MSBuild\SafeImports]
    ///			"TargetsLabel"="PathToTheTargetsFile"
    /// 
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
    public sealed class ProvideMSBuildTargetsAttribute : RegistrationAttribute
    {
        private const string MSBuildSafeImportsPath = @"MSBuild\SafeImports";
        private string targetsLabel;
        private string targetsPath;

        /// <summary>
        /// Creates a new ProvideMSBuildTargets attribute to register a targets file
        /// to the list of the MSBuild safe imports.
        /// </summary>
        /// <param name="targetsLabel">Label to identify the targets.</param>
        /// <param name="targetsPath">Full path to the targets file.</param>
        public ProvideMSBuildTargetsAttribute(string targetsLabel, string targetsPath)
        {
            if (string.IsNullOrEmpty(targetsLabel))
            {
                throw new ArgumentNullException("targetsLabel");
            }
            if (string.IsNullOrEmpty(targetsPath))
            {
                throw new ArgumentNullException("targetsPath");
            }
            this.targetsLabel = targetsLabel;
            this.targetsPath = targetsPath;
        }

        /// <summary>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     It also contains other information such as the type being registered and path information.
        /// </summary>
        public override void Register(RegistrationContext context)
        {
            if (null == context) {
                new ArgumentNullException("context");
            }
            using (Key safeImportsKey = context.CreateKey(MSBuildSafeImportsPath))
            {
                safeImportsKey.SetValue(targetsLabel, targetsPath);
            }

        }

        /// <summary>
        /// Unregister this file extension.
        /// </summary>
        /// <param name="context"></param>
        public override void Unregister(RegistrationContext context)
        {
            if (null != context)
            {
                context.RemoveValue(MSBuildSafeImportsPath, targetsLabel);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\RegistrationAttributes\SingleFileGeneratorSupportRegistrationAttribute.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Globalization;

namespace Microsoft.VisualStudio.Shell
{
	/// <summary>
	/// This attribute adds a custom file generator registry entry for specific file 
    /// type. 
	/// For Example:
	///   [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\9.0\Generators\
    ///		[proj_fac_guid]
	/// 
	/// </summary>
	[AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = true)]
	public sealed class SingleFileGeneratorSupportRegistrationAttribute : RegistrationAttribute
	{
        private Guid _prjFacGuid;
		/// <summary>
        /// Creates a new SingleFileGeneratorSupportRegistrationAttribute attribute to register a custom
		/// code generator for the provided context. 
		/// </summary>
        /// <param name="generatorType">The type of Code generator. Type that implements IVsSingleFileGenerator</param>
        /// <param name="generatorName">The generator name</param>
        /// <param name="contextGuid">The context GUID this code generator would appear under.</param>
        public SingleFileGeneratorSupportRegistrationAttribute(Type prjFactoryType)
		{
            if (prjFactoryType == null)
                throw new ArgumentNullException("prjFactoryType");

            _prjFacGuid = prjFactoryType.GUID;
        }

		
        /// <summary>
        /// Get the Guid representing the generator type
        /// </summary>
        public Guid ProjectFactoryGuid
        {
            get { return _prjFacGuid; }
        }

        /// <summary>
        /// Property that gets the generator base key name
        /// </summary>
        private string GeneratorRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, @"Generators\{0}", ProjectFactoryGuid.ToString("B")); }
        }
		/// <summary>
		///     Called to register this attribute with the given context.  The context
		///     contains the location where the registration inforomation should be placed.
		///     It also contains other information such as the type being registered and path information.
		/// </summary>
		public override void Register(RegistrationContext context)
		{
            using (Key childKey = context.CreateKey(GeneratorRegKey))
            {
                childKey.SetValue(string.Empty, string.Empty);
            }

        }

		/// <summary>
		/// Unregister this file extension.
		/// </summary>
		/// <param name="context"></param>
		public override void Unregister(RegistrationContext context)
		{
            context.RemoveKey(GeneratorRegKey);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\RegistrationAttributes\ProvideXmlEditorChooserBlockSxSWithXmlEditorAttribute.cs ===
﻿/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Text;
using System.IO;

namespace Microsoft.VisualStudio.Shell
{
    /// <summary>
    /// Used to indicate that a custom XML designer should not allow SxS editing
    /// with the standard text-based XML editor.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
    public sealed class ProvideXmlEditorChooserBlockSxSWithXmlEditorAttribute : RegistrationAttribute
    {
        const string XmlChooserFactory = "XmlChooserFactory";

        private string name;
        private Guid editorFactory;

        /// <summary>
        /// Constructor for ProvideXmlEditorChooserBlockSxSWithXmlEditorAttribute.
        /// </summary>
        /// <param name="name">The registry key name for your XML editor. For example "RESX", "Silverlight", "Workflow", etc...</param>
        /// <param name="editorFactory">A Type, Guid, or String object representing the editor factory.</param>
        public ProvideXmlEditorChooserBlockSxSWithXmlEditorAttribute(string name, object editorFactory)
        {
            if (string.IsNullOrWhiteSpace(name))
            {
                throw new ArgumentException("Editor description cannot be null or empty.", "editorDescription");
            }

            this.name = name;
            this.editorFactory = TryGetGuidFromObject(editorFactory);
        }

        public override void Register(RegistrationContext context)
        {
            if (context == null)
            {
                throw new ArgumentNullException("context");
            }

            using (Key key = context.CreateKey(GetKeyName()))
            {
                key.SetValue("XmlEditorBlockSxS", editorFactory.ToString("B").ToUpperInvariant());
            }
        }

        private Guid TryGetGuidFromObject(object guidObject)
        {
            // figure out what type of object they passed in and get the GUID from it
            if (guidObject is string)
                return new Guid((string)guidObject);
            else if (guidObject is Type)
                return ((Type)guidObject).GUID;
            else if (guidObject is Guid)
                return (Guid)guidObject;
            else
                throw new ArgumentException("Could not determine Guid from supplied object.", "guidObject");
        }

        public override void Unregister(RegistrationContext context)
        {
            if (context == null)
            {
                throw new ArgumentNullException("context");
            }

            context.RemoveKey(GetKeyName());
        }

        private string GetKeyName()
        {
            return Path.Combine(XmlChooserFactory, name);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\RegistrationAttributes\ProvideXmlEditorChooserDesignerViewAttribute.cs ===
﻿/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Text;
using System.IO;

namespace Microsoft.VisualStudio.Shell
{
    /// <summary>
    /// Used to provide registration information to the XML Chooser
    /// for a custom XML designer.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
    public sealed class ProvideXmlEditorChooserDesignerViewAttribute : RegistrationAttribute
    {
        const string XmlChooserFactory = "XmlChooserFactory";
        const string XmlChooserEditorExtensionsKeyPath = @"Editors\{32CC8DFA-2D70-49b2-94CD-22D57349B778}\Extensions";
        const string XmlEditorFactoryGuid = "{FA3CD31E-987B-443A-9B81-186104E8DAC1}";


        private string name;
        private string extension;
        private Guid defaultLogicalView;
        private int xmlChooserPriority;

        /// <summary>
        /// Constructor for ProvideXmlEditorChooserDesignerViewAttribute.
        /// </summary>
        /// <param name="name">The registry keyName for your XML editor. For example "RESX", "Silverlight", "Workflow", etc...</param>
        /// <param name="extension">The file extension for your custom XML type (e.g. "xaml", "resx", "xsd").</param>
        /// <param name="defaultLogicalViewEditorFactory">A Type, Guid, or String object representing the editor factory for the default logical view.</param>
        /// <param name="xmlChooserPriority">The priority of the extension in the XML Chooser. This value must be greater than the extension's priority value for the XML designer's EditorFactory.</param>
        public ProvideXmlEditorChooserDesignerViewAttribute(string name, string extension, object defaultLogicalViewEditorFactory, int xmlChooserPriority)
        {
            if (string.IsNullOrWhiteSpace(name))
            {
                throw new ArgumentException("Editor description cannot be null or empty.", "editorDescription");
            }
            if (string.IsNullOrWhiteSpace(extension))
            {
                throw new ArgumentException("Extension cannot be null or empty.", "extension");
            }
            if (defaultLogicalViewEditorFactory == null)
            {
                throw new ArgumentNullException("defaultLogicalViewEditorFactory");
            }

            this.name = name;
            this.extension = extension;
            this.defaultLogicalView = TryGetGuidFromObject(defaultLogicalViewEditorFactory);
            this.xmlChooserPriority = xmlChooserPriority;

            this.CodeLogicalViewEditor = XmlEditorFactoryGuid;
            this.DebuggingLogicalViewEditor = XmlEditorFactoryGuid;
            this.DesignerLogicalViewEditor = XmlEditorFactoryGuid;
            this.TextLogicalViewEditor = XmlEditorFactoryGuid;
        }

        public override void Register(RegistrationContext context)
        {
            if (context == null)
            {
                throw new ArgumentNullException("context");
            }

            using (Key xmlChooserExtensions = context.CreateKey(XmlChooserEditorExtensionsKeyPath))
            {
                xmlChooserExtensions.SetValue(extension, xmlChooserPriority);
            }

            using (Key key = context.CreateKey(GetKeyName()))
            {
                key.SetValue("DefaultLogicalView", defaultLogicalView.ToString("B").ToUpperInvariant());
                key.SetValue("Extension", extension);
                
                if (!string.IsNullOrWhiteSpace(Namespace))
                {
                    key.SetValue("Namespace", Namespace);
                }

                if (MatchExtensionAndNamespace)
                {
                    key.SetValue("Match", "both");
                }

                if (IsDataSet.HasValue)
                {
                    key.SetValue("IsDataSet", Convert.ToInt32(IsDataSet.Value));
                }

                SetLogicalViewMapping(key, VSConstants.LOGVIEWID_Debugging, DebuggingLogicalViewEditor);
                SetLogicalViewMapping(key, VSConstants.LOGVIEWID_Code, CodeLogicalViewEditor);
                SetLogicalViewMapping(key, VSConstants.LOGVIEWID_Designer, DesignerLogicalViewEditor);
                SetLogicalViewMapping(key, VSConstants.LOGVIEWID_TextView, TextLogicalViewEditor);
            }
        }

        private void SetLogicalViewMapping(Key key, Guid logicalView, object editorFactory)
        {
            if (editorFactory != null)
            {
                key.SetValue(logicalView.ToString("B").ToUpperInvariant(), TryGetGuidFromObject(editorFactory).ToString("B").ToUpperInvariant());
            }
        }

        private Guid TryGetGuidFromObject(object guidObject)
        {
            // figure out what type of object they passed in and get the GUID from it
            if (guidObject is string)
                return new Guid((string)guidObject);
            else if (guidObject is Type)
                return ((Type)guidObject).GUID;
            else if (guidObject is Guid)
                return (Guid)guidObject;
            else
                throw new ArgumentException("Could not determine Guid from supplied object.", "guidObject");
        }

        public override void Unregister(RegistrationContext context)
        {
            if (context == null)
            {
                throw new ArgumentNullException("context");
            }

            context.RemoveKey(GetKeyName());

            context.RemoveValue(XmlChooserEditorExtensionsKeyPath, extension);
            context.RemoveKeyIfEmpty(XmlChooserEditorExtensionsKeyPath);
        }

        private string GetKeyName()
        {
            return Path.Combine(XmlChooserFactory, name);
        }

        /// <summary>
        /// The XML Namespace used in documents that this editor supports.
        /// </summary>
        public string Namespace { get; set; }

        /// <summary>
        /// Boolean value indicating whether the XML chooser should match on both the file extension
        /// and the Namespace. If false, the XML chooser will match on either the extension or the 
        /// Namespace.
        /// </summary>
        public bool MatchExtensionAndNamespace { get; set; }

        /// <summary>
        /// Special value used only by the DataSet designer.
        /// </summary>
        public bool? IsDataSet { get; set; }

        /// <summary>
        /// The editor factory to associate with the debugging logical view
        /// </summary>
        public object DebuggingLogicalViewEditor { get; set; }

        /// <summary>
        /// The editor factory to associate with the code logical view
        /// </summary>
        public object CodeLogicalViewEditor { get; set; }

        /// <summary>
        /// The editor factory to associate with the designer logical view
        /// </summary>
        public object DesignerLogicalViewEditor { get; set; }

        /// <summary>
        /// The editor factory to associate with the text logical view
        /// </summary>
        public object TextLogicalViewEditor { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\RegistrationAttributes\WAProvideLanguagePropertyAttribute.cs ===
//***************************************************************************
//
//    Copyright (c) Microsoft Corporation. All rights reserved.
//    This code is licensed under the Visual Studio SDK license terms.
//    THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
//    ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
//    IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
//    PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.
//
//***************************************************************************

using System;
using System.IO;
using System.ComponentModel;
using System.Globalization;
using Microsoft.Win32;

namespace Microsoft.VisualStudio.Shell
{
    /// <summary>
    /// This class can be used for registering a Web Application Property for a project
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
    public sealed class WAProvideLanguagePropertyAttribute : RegistrationAttribute
    {
        private Type _languageTemplateFactoryType;
        private string _propertyName;
        private string _propertyValueString;
        private int _propertyValueInt;


        public WAProvideLanguagePropertyAttribute(Type languageTemplateFactoryType, string propertyName, string propertyValue)
        {
            _languageTemplateFactoryType = languageTemplateFactoryType;
            _propertyName = propertyName;
            _propertyValueString = propertyValue;
            _propertyValueInt = 0;
        }

        public WAProvideLanguagePropertyAttribute(Type languageTemplateFactoryType, string propertyName, int propertyValue)
        {
            _languageTemplateFactoryType = languageTemplateFactoryType;
            _propertyName = propertyName;
            _propertyValueString = null;
            _propertyValueInt = propertyValue;
        }

        public WAProvideLanguagePropertyAttribute(Type languageTemplateFactoryType, string propertyName, bool propertyValue)
        {
            _languageTemplateFactoryType = languageTemplateFactoryType;
            _propertyName = propertyName;
            _propertyValueString = null;
            _propertyValueInt = propertyValue ? 1 : 0;
        }

        public WAProvideLanguagePropertyAttribute(Type languageTemplateFactoryType, string propertyName, Type propertyValue)
        {
            _languageTemplateFactoryType = languageTemplateFactoryType;
            _propertyName = propertyName;
            _propertyValueString = propertyValue.GUID.ToString("B");
            _propertyValueInt = 0;
        }

        public Type LanguageTemplateFactoryType
        {
            get
            {
                return _languageTemplateFactoryType;
            }
        }

        public string PropertyName
        {
            get
            {
                return _propertyName;
            }
        }

        public string PropertyValueString
        {
            get
            {
                return _propertyValueString;
            }
        }

        public int PropertyValueInt
        {
            get
            {
                return _propertyValueInt;
            }
        }

        private string LanguagePropertyKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, "Projects\\{0}\\WebApplicationProperties", LanguageTemplateFactoryType.GUID.ToString("B")); }
        }


        public override void Register(RegistrationContext context)
        {
            using (Key propertyKey = context.CreateKey(LanguagePropertyKey))
            {
                if (PropertyValueString != null)
                {
                    propertyKey.SetValue(PropertyName, PropertyValueString);
                }
                else
                {
                    propertyKey.SetValue(PropertyName, PropertyValueInt);
                }
            }
        }

        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(LanguagePropertyKey);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\RegistrationAttributes\SolutionPersistenceRegistrationAttribute.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Globalization;

namespace Microsoft.VisualStudio.Shell
{
	/// <summary>
	/// This attribute adds a solution persistence property name and related Guid
    /// type. 
	/// For Example:
    ///   [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\9.0Exp\SolutionPersistence\MyProperty]
    ///			"Default"="{AAAA53CC-3D4F-40a2-BD4D-4F3419755476}"
    /// </summary>
	[AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
    internal sealed class SolutionPersistenceRegistrationAttribute : RegistrationAttribute
	{
        /// <summary>
        /// Property name
        /// </summary>
        private string _propName;

		/// <summary>
        /// Creates a new SolutionPersistenceRegistrationAttribute attribute to register a solution persistence attribute
		/// for the provided context. 
		/// </summary>
        /// <param name="propName">Name of the property</param>
        public SolutionPersistenceRegistrationAttribute(string propName)
		{
            _propName = propName;
        }

		/// <summary>
		/// Get the property name
		/// </summary>
		public string PropName
		{
            get { return _propName; }
		}

        /// <summary>
        /// Property that gets the SolutionPersistence base key name
        /// </summary>
        private string SolutionPersistenceRegKey
        {
            get { return "SolutionPersistence"; }
        }

		/// <summary>
		///     Called to register this attribute with the given context.  The context
		///     contains the location where the registration inforomation should be placed.
		///     It also contains other information such as the type being registered and path information.
		/// </summary>
		public override void Register(RegistrationContext context)
		{
            context.Log.WriteLine(string.Format(CultureInfo.InvariantCulture, "ProvideSolutionProps: ({0} = {1})", context.ComponentType.GUID.ToString("B"), PropName));
            Key childKey = null;
            
            try
            {
                childKey = context.CreateKey(string.Format(CultureInfo.InvariantCulture, "{0}\\{1}", SolutionPersistenceRegKey, PropName));
                childKey.SetValue(string.Empty, context.ComponentType.GUID.ToString("B"));
            }
            finally
            {
                if (childKey != null) childKey.Close();
            }
        }

		/// <summary>
		/// Unregister this property.
		/// </summary>
		/// <param name="context"></param>
		public override void Unregister(RegistrationContext context)
		{
            context.RemoveKey(string.Format(CultureInfo.InvariantCulture, "{0}\\{1}", SolutionPersistenceRegKey, PropName));
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\RegistrationAttributes\WAProvideProjectFactoryAttribute.cs ===
//***************************************************************************
//
//    Copyright (c) Microsoft Corporation. All rights reserved.
//    This code is licensed under the Visual Studio SDK license terms.
//    THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
//    ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
//    IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
//    PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.
//
//***************************************************************************

using System;
using System.IO;
using System.ComponentModel;
using System.Globalization;
using Microsoft.Win32;

namespace Microsoft.VisualStudio.Shell
{
    /// <summary>
    /// This attribute can be used to register information about a project system that supports
    /// the WAP flavor/sub-type.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
    public class WAProvideProjectFactoryAttribute : RegistrationAttribute
    {
        private Type _factoryType;
        private string _displayProjectFileExtensions = null;
        private string _name;
        private string _displayName = null;
        private string _defaultProjectExtension = null;
        private string _possibleProjectExtensions = null;
        private string _projectTemplatesDirectory;
        private int _sortPriority = 100;
        private Guid _folderGuid = Guid.Empty;
        private string _languageVsTemplate;
        private string _templateGroupIDsVsTemplate;
        private string _templateIDsVsTemplate;
        private string _displayProjectTypeVsTemplate;
        private string _projectSubTypeVsTemplate;
        private bool _newProjectRequireNewFolderVsTemplate = false;
        private bool _showOnlySpecifiedTemplatesVsTemplate = false;

        public WAProvideProjectFactoryAttribute(Type factoryType, string name)
        {
            if (factoryType == null)
            {
                throw new ArgumentNullException("factoryType");
            }

            _factoryType = factoryType;
            _name = name;
        }

        public WAProvideProjectFactoryAttribute(Type factoryType, string name, string languageVsTemplate, bool showOnlySpecifiedTemplatesVsTemplate, string templateGroupIDsVsTemplate, string templateIDsVsTemplate)
        {
            if (factoryType == null)
            {
                throw new ArgumentNullException("factoryType");
            }

            _factoryType = factoryType;
            _name = name;
            _languageVsTemplate = languageVsTemplate;
            _templateGroupIDsVsTemplate = templateGroupIDsVsTemplate;
            _templateIDsVsTemplate = templateIDsVsTemplate;
            _showOnlySpecifiedTemplatesVsTemplate = showOnlySpecifiedTemplatesVsTemplate;
        }

        public string Name
        {
            get { return _name; }
        }

        public string DisplayName
        {
            get { return _displayName; }
        }

        public int SortPriority
        {
            get { return _sortPriority; }
            set { _sortPriority = value; }
        }

        public Type FactoryType
        {
            get
            {
                return _factoryType;
            }
        }

        public string DisplayProjectFileExtensions
        {
            get
            {
                return _displayProjectFileExtensions;
            }
        }

        public string DefaultProjectExtension
        {
            get
            {
                return _defaultProjectExtension;
            }
        }

        public string PossibleProjectExtensions
        {
            get
            {
                return _possibleProjectExtensions;
            }
        }

        public string ProjectTemplatesDirectory
        {
            get
            {
                return _projectTemplatesDirectory;
            }
        }

        public string FolderGuid
        {
            get { return _folderGuid.ToString("B"); }
            set { _folderGuid = new Guid(value); }
        }

        public string LanguageVsTemplate
        {
            get { return _languageVsTemplate; }
            set { _languageVsTemplate = value; }
        }

        public string DisplayProjectTypeVsTemplate
        {
            get { return _displayProjectTypeVsTemplate; }
            set { _displayProjectTypeVsTemplate = value; }
        }

        public string ProjectSubTypeVsTemplate
        {
            get { return _projectSubTypeVsTemplate; }
            set { _projectSubTypeVsTemplate = value; }
        }

        public bool NewProjectRequireNewFolderVsTemplate
        {
            get { return _newProjectRequireNewFolderVsTemplate; }
            set { _newProjectRequireNewFolderVsTemplate = value; }
        }

        public bool ShowOnlySpecifiedTemplatesVsTemplate
        {
            get { return _showOnlySpecifiedTemplatesVsTemplate; }
            set { _showOnlySpecifiedTemplatesVsTemplate = value; }
        }

        public string TemplateGroupIDsVsTemplate
        {
            get { return _templateGroupIDsVsTemplate; }
            set { _templateGroupIDsVsTemplate = value; }
        }

        public string TemplateIDsVsTemplate
        {
            get { return _templateIDsVsTemplate; }
            set { _templateIDsVsTemplate = value; }
        }

        private string ProjectRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, "Projects\\{0}", FactoryType.GUID.ToString("B")); }
        }

        private string NewPrjTemplateRegKey(RegistrationContext context)
        {
            return string.Format(CultureInfo.InvariantCulture, "NewProjectTemplates\\TemplateDirs\\{0}\\/1", context.ComponentType.GUID.ToString("B"));
        }

        public override void Register(RegistrationContext context)
        {
            //context.Log.WriteLine(SR.GetString(SR.Reg_NotifyProjectFactory, FactoryType.Name));

            using (Key projectKey = context.CreateKey(ProjectRegKey))
            {
                projectKey.SetValue(string.Empty, Name);
                if (_displayName != null)
                    projectKey.SetValue("DisplayName", _displayName);
                if (_displayProjectFileExtensions != null)
                    projectKey.SetValue("DisplayProjectFileExtensions", _displayProjectFileExtensions);
                projectKey.SetValue("Package", context.ComponentType.GUID.ToString("B"));
                if (_defaultProjectExtension != null)
                    projectKey.SetValue("DefaultProjectExtension", _defaultProjectExtension);
                if (_possibleProjectExtensions != null)
                    projectKey.SetValue("PossibleProjectExtensions", _possibleProjectExtensions);
                if (_projectTemplatesDirectory != null)
                {
                    if (!System.IO.Path.IsPathRooted(_projectTemplatesDirectory))
                    {
                        // If path is not rooted, make it relative to package path
                        _projectTemplatesDirectory = System.IO.Path.Combine(context.ComponentPath, _projectTemplatesDirectory);
                    }
                    projectKey.SetValue("ProjectTemplatesDir", context.EscapePath(_projectTemplatesDirectory));
                }

                // VsTemplate Specific Keys
                //
                if (_languageVsTemplate != null)
                    projectKey.SetValue("Language(VsTemplate)", _languageVsTemplate);

                if (_showOnlySpecifiedTemplatesVsTemplate || _templateGroupIDsVsTemplate != null || _templateIDsVsTemplate != null)
                {
                    int showOnlySpecifiedTemplatesVsTemplate = _showOnlySpecifiedTemplatesVsTemplate ? 1 : 0;
                    projectKey.SetValue("ShowOnlySpecifiedTemplates(VsTemplate)", showOnlySpecifiedTemplatesVsTemplate);
                }

                if (_templateGroupIDsVsTemplate != null)
                    projectKey.SetValue("TemplateGroupIDs(VsTemplate)", _templateGroupIDsVsTemplate);

                if (_templateIDsVsTemplate != null)
                    projectKey.SetValue("TemplateIDs(VsTemplate)", _templateIDsVsTemplate);

                if (_displayProjectTypeVsTemplate != null)
                    projectKey.SetValue("DisplayProjectType(VsTemplate)", _displayProjectTypeVsTemplate);

                if (_projectSubTypeVsTemplate != null)
                    projectKey.SetValue("ProjectSubType(VsTemplate)", _projectSubTypeVsTemplate);

                if (_newProjectRequireNewFolderVsTemplate)
                    projectKey.SetValue("NewProjectRequireNewFolder(VsTemplate)", (int)1);
            }
        }

        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(ProjectRegKey);
            context.RemoveKey(NewPrjTemplateRegKey(context));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\RegistrationAttributes\WebSiteProjectRelatedFilesAttribute.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.IO;
using System.ComponentModel;
using System.Globalization;
using Microsoft.Win32;

namespace Microsoft.VisualStudio.Shell
{
    /// <summary>
    /// This attribute allows the Web Site Project to nest one file type (related) under another file type (primary) in the solution explorer
    /// </summary>
    /// <remarks>
    /// As an example the following Attribute definition 
    /// [WebSiteProjectRelatedFiles("aspx","py")]
    /// 
    /// would add the following registry key:
    ///   [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\(*version*)\Projects\
    ///		{E24C65DC-7377-472B-9ABA-BC803B73C61A}\RelatedFiles\.aspx\.py
    ///			"Default"=""
    
    /// </remarks>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
    public sealed class WebSiteProjectRelatedFilesAttribute : RegistrationAttribute
    {
        #region Constants
        private const string webSiteProjectGuid = "{E24C65DC-7377-472B-9ABA-BC803B73C61A}";
        #endregion

        #region Fields
        //private Type packageType;
        private string primaryFileExtension;
        private string relatedFileExtension;
        #endregion
        
        #region Constructors

        /// <summary>
        /// Creates a new WebSiteProjectAttribute attribute to register a 
        /// language with the web site project 
        /// </summary>
        /// <param name="primaryFileExtension">The primary file extension which will nest files.</param>
        /// <param name="relatedFileExtension">The related file extion which willl nest under the primary file extension</param>
        public WebSiteProjectRelatedFilesAttribute(string primaryFileExtension, string relatedFileExtension)
        {
            if (string.IsNullOrEmpty(primaryFileExtension))
            {
                throw new ArgumentNullException("primaryFileExtension", "primaryFileExtension can not be null.");
            }
            if (primaryFileExtension.Contains("."))
            {
                throw new ArgumentNullException("primaryFileExtension", "primaryFileExtension must not contain '.'");
            }
            if (string.IsNullOrEmpty(relatedFileExtension))
            {
                throw new ArgumentNullException("relatedFileExtension", "relatedFileExtension can not be null.");
            }
            if (relatedFileExtension.Contains("."))
            {
                throw new ArgumentNullException("relatedFileExtension", "relatedFileExtension must not contain '.'");
            }

            this.primaryFileExtension = primaryFileExtension;
            this.relatedFileExtension = relatedFileExtension;

        }
        #endregion

        #region Properties
        /// <summary>
        /// Gets the primary file extension which will nest files
        /// </summary>
        public string PrimaryFileExtension
        {
            get { return primaryFileExtension; }
        }

        /// <summary>
        /// Gets the related file extion which willl nest under the primary file extension
        /// </summary>
        public object RelatedFileExtension
        {
            get { return relatedFileExtension; }
        }

        /// <summary>
        /// Returns the Web Site Project RelatedFiles Path
        /// </summary>
        private string RelatedFilePath
        {
            get
            {
                string relatedFiles = string.Format(CultureInfo.InvariantCulture, @"Projects\{0}\RelatedFiles", webSiteProjectGuid);
                return string.Format(CultureInfo.InvariantCulture, "{0}\\.{1}\\.{2}", relatedFiles, primaryFileExtension, relatedFileExtension);
            }
        }

        #endregion

        #region Methods
        /// <summary>
        /// Called to register this attribute with the given context.  The context
        /// contains the location where the registration information should be placed.
        /// It also contains other information such as the type being registered and path information.
        /// </summary>
        /// <param name="context">Given context to register in</param>
        public override void Register(RegistrationContext context)
        {
            if (context == null)
            {
                throw new ArgumentNullException("context");
            }
            context.Log.WriteLine(String.Format(CultureInfo.CurrentCulture, "WebSiteProjectRelatedFiles: Primary File Ext = {0} Related File Ext = {1}\n", primaryFileExtension, relatedFileExtension));

            //Register Related File
            context.CreateKey(RelatedFilePath);
        }

        /// <summary>
        /// Unregister this related file extension
        /// </summary>
        /// <param name="context">Given context to unregister from</param>
        public override void Unregister(RegistrationContext context)
        {
            if (context != null)
            {
                //UnRegister related file extextion
                context.RemoveKey(RelatedFilePath);
            }

        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\RegistrationAttributes\UnitTests\Properties\AssemblyInfo.cs ===
﻿/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System;

[assembly: CLSCompliant(false)]
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Microsoft.Samples.VisualStudio.Hierarchies.SolutionHierarchyTraversal.UnitTests")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("Microsoft.Samples.VisualStudio.Hierarchies.SolutionHierarchyTraversal.UnitTests")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2005")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM componenets.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("f680d21b-4248-48ca-8e47-325610aac6cc")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\RegistrationAttributes\WAProvideProjectFactoryTemplateMappingAttribute.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using Microsoft.VisualStudio.Shell;
using System;
using System.ComponentModel;
using System.Globalization;

namespace Microsoft.VisualStudio.Shell
{
    /// <summary>
    /// This attribute is used to declare a new project system that supports Web Application Projects
    /// and define a mapping between the real project system and the 'fake' one that is defined only
    /// to store some WAP specific properties in the registry.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
    public sealed class WAProvideProjectFactoryTemplateMappingAttribute : RegistrationAttribute
    {
        private const string WAPFactoryGuid = "{349c5851-65df-11da-9384-00065b846f21}";
        private string _flavoredFactoryGuid;
        private Type _languageTemplateFactoryType;

        public WAProvideProjectFactoryTemplateMappingAttribute(string flavoredFactoryGuid, Type languageTemplateFactoryType)
        {
            _flavoredFactoryGuid = flavoredFactoryGuid;
            _languageTemplateFactoryType = languageTemplateFactoryType;
        }

        public string FlavoredFactoryGuid
        {
            get
            {
                return _flavoredFactoryGuid;
            }
        }

        public Type LanguageTemplateFactoryType
        {
            get
            {
                return _languageTemplateFactoryType;
            }
        }

        private string LanguageTemplatesKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, "Projects\\{0}\\LanguageTemplates", WAPFactoryGuid); }
        }


        public override void Register(RegistrationContext context)
        {
            using (Key languageTemplatesKey = context.CreateKey(LanguageTemplatesKey))
            {
                languageTemplatesKey.SetValue(FlavoredFactoryGuid, LanguageTemplateFactoryType.GUID.ToString("B"));
            }
        }

        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(LanguageTemplatesKey);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\RegistrationAttributes\WebSiteProjectAttribute.cs ===
//***************************************************************************
//
//    Copyright (c) Microsoft Corporation. All rights reserved.
//    This code is licensed under the Visual Studio SDK license terms.
//    THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
//    ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
//    IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
//    PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.
//
//***************************************************************************

using System;
using System.IO;
using System.ComponentModel;
using System.Globalization;
using Microsoft.Win32;

namespace Microsoft.VisualStudio.Shell
{
    /// <summary>
    /// This attribute adds a ProjectSubType to the exisiting list defined of ProjectSubTypes
    /// for the Web Site Project
    /// </summary>
    /// <remarks>
    /// For example:
    ///   [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\(*version*)\Projects\
    ///		{E24C65DC-7377-472B-9ABA-BC803B73C61A}\ProjectSubType(VsTemplate)\IronPython
    ///			"Default"="Iron Python"
    ///   [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\9.0Exp\NewProjectTemplates\TemplateDirs\{39c9c826-8ef8-4079-8c95-428f5b1c323f}\IronPython]
    ///     @="Iron Python"
    ///     "NewProjectDialogExOnly"=dword:00000001
    ///     "SortPriority"=dword:0000012c
    ///     "TemplatesDir"="D:\\Program Files\\Microsoft Visual Studio 8\\Web\\.\\WebProjects\\IronPython"
    ///     "DeveloperActivity"="IronPython"

    /// </remarks>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
    [System.Runtime.InteropServices.ComVisibleAttribute(false)]
    public sealed class WebSiteProjectAttribute : RegistrationAttribute
    {
        #region Constants
        private const string webSiteProjectGuid = "{E24C65DC-7377-472B-9ABA-BC803B73C61A}";
        private const string websitePackageGuid = "{39c9c826-8ef8-4079-8c95-428f5b1c323f}";
        #endregion

        #region Fields
        private Type packageType;
        private string languageID;
        private string languageName;
        #endregion

        #region Constructors
        /// <summary>
        /// Creates a new WebSiteProjectAttribute attribute to register a 
        /// language with the web site project 
        /// </summary>
        /// <param name="languageID">Language ID which is being referenced from the vstemplate</param>
        /// <param name="languageName">Language Name which shows up in the add new Web Site dialog under the list of languages</param>
        public WebSiteProjectAttribute(string languageID, string languageName)
        {
            if (languageID == null)
            {
                throw new ArgumentNullException("languageID", "languageID can not be null.");
            }
            if (languageName == null)
            {
                throw new ArgumentNullException("languageName", "languageName can not be null.");
            }

            this.languageID = languageID;
            this.languageName = languageName;

        }
        #endregion

        #region Properties
        /// <summary>
        /// Gets the Language ID which is being referenced from the vstemplate
        /// </summary>
        public string LanguageID
        {
            get { return languageID; }
        }

        /// <summary>
        /// Gets the Language Name which shows up in the add new Web Site dialog under the list of languages
        /// </summary>
        public object LanguageName
        {
            get { return languageName; }
        }

        /// <summary>
        /// ProjectSubTypePath for Web Site Project
        /// </summary>
        private string ProjectSubTypePath
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture, @"Projects\{0}\ProjectSubType(VsTemplate)", webSiteProjectGuid);
            }
        }

        private string ProjectTemplatesDir
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture, @"NewProjectTemplates\TemplateDirs\{0}", websitePackageGuid);
            }
        }
        /// <summary>
        /// Gets the Location of devenv.exe based on the RegistryRoot for the current package type
        /// </summary>
        private string getVSInstallDir(RegistrationContext context)
        {
            DefaultRegistryRootAttribute regRootAttr = (DefaultRegistryRootAttribute)TypeDescriptor.GetAttributes(context.ComponentType)[typeof(DefaultRegistryRootAttribute)];
            if (regRootAttr == null)
            {
                throw new NotSupportedException("could not find DefaultRegitryRootAttribute on " + context.ComponentType.ToString());
            }

            Win32.RegistryKey key = Win32.Registry.LocalMachine.OpenSubKey(regRootAttr.Root);
            //We are using HKCU in the case that the HKLM Experimental hive doesn't exist
            if (key == null || key.GetValue("InstallDir") == null)
            {
                key = Win32.Registry.CurrentUser.OpenSubKey(regRootAttr.Root + @"\Configuration");
            }
            string vsInstallDir = (string)key.GetValue("InstallDir");
            key.Close();
            return vsInstallDir;
        }
        #endregion

        #region Methods
        /// <summary>
        /// Called to register this attribute with the given context.  The context
        /// contains the location where the registration information should be placed.
        /// It also contains other information such as the type being registered and path information.
        /// </summary>
        /// <param name="context">Given context to register in</param>
        public override void Register(RegistrationContext context)
        {
            if (context == null)
            {
                throw new ArgumentNullException("context");
            }
            packageType = context.ComponentType;
            context.Log.WriteLine(String.Format(CultureInfo.CurrentCulture, "WebSiteProject: LanguageID = {0} Language Name = {1}\n", languageID, languageName));

            //Register ProjectSubType(VsTemplates)
            using (Key childKey = context.CreateKey(string.Format(CultureInfo.InvariantCulture, "{0}\\{1}", ProjectSubTypePath, languageID)))
            {
                childKey.SetValue("", languageName);
            }

            //Register NewProjectTemplates
            using (Key childKey = context.CreateKey(string.Format(CultureInfo.InvariantCulture, "{0}\\{1}", ProjectTemplatesDir, languageID)))
            {
                childKey.SetValue("", languageName);
                childKey.SetValue("NewProjectDialogExOnly", 1);
                childKey.SetValue("SortPriority", 300);
                string templateDir = context.RootFolder.TrimEnd('\\') + string.Format(CultureInfo.InvariantCulture, "\\Web\\.\\WebProjects\\{0}", languageID);
                childKey.SetValue("TemplatesDir", context.EscapePath(templateDir));
                childKey.SetValue("DeveloperActivity", languageID);
            }
        }

        /// <summary>
        /// Unregister this languageID
        /// </summary>
        /// <param name="context">Given context to unregister from</param>
        public override void Unregister(RegistrationContext context)
        {
            if (context != null)
            {
                //UnRegister ProjectSubType(VsTemplates)
                context.RemoveKey(string.Format(CultureInfo.InvariantCulture, "{0}\\{1}", ProjectSubTypePath, languageID));

                //Register NewProjectTemplates
                context.RemoveKey(string.Format(CultureInfo.InvariantCulture, "{0}\\{1}", ProjectTemplatesDir, languageID));
            }
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\RegistrationAttributes\UnitTests\Tests\AttributeCommonTest.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Text;
using System.Collections.Generic;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VsSDK.UnitTestLibrary;
using System.Collections;
using System.Runtime.InteropServices;

namespace Microsoft.VisualStudio.Shell.RegistrationAttributes.UnitTests
{
    /// <summary>
    /// This class is created just to get a type that can be used for the test.
    /// </summary>
    [Guid("EEAB0D91-86F3-4f3a-959A-9548C5642203")]
    public class DummyTypeWithGuid
    {
    }

    /// <summary>
    /// This class tests the common methods and all the properties of the attribute
    /// </summary>
    [CLSCompliant(false)]
    public abstract class AttributeCommonTest
    {
        #region fields
        /// <summary>
        /// Top level reg key to add
        /// </summary>
        protected string RegKeyToAdd = "";

        /// <summary>
        /// Attribute instance
        /// </summary>
        [CLSCompliant(false)]
        protected RegistrationAttribute _instance = null;

        /// <summary>
        /// Data to hold the expected values
        /// </summary>
        protected Hashtable _data = new Hashtable();

        /// <summary>
        /// The registration context mock that has the values set by the registration method
        /// </summary>
        private BaseRegistrationContextMock _mock = null;
        #endregion

        #region properties
        /// <summary>
        /// Returns the registration context mock object.
        /// </summary>
        protected BaseRegistrationContextMock ContextMock
        {
            get
            {
                if (_mock == null)
                    _mock = new BaseRegistrationContextMock();
                return _mock;
            }
        } 
        #endregion

        #region abstract properties
        /// <summary>
        /// This property is implemented by the derived tests to set up the expected values
        /// hash table. The table is keyed on reg key name and value is a hash table of value 
        /// name data pairs for e.g:
        /// KEY:(String)
        /// Packages\{019971D6-4685-11D2-B48A-0000F87572EB}
        /// VALUES:(HashTable)        
        ///     ""              "Visual Basic Compiler Package"
        ///     InprocServer32  "E:\binaries.x86ret.rtm\bin\i386\vspkgs\msvb7.dll"
        /// Packages\{019971D6-4685-11D2-B48A-0000F87572EB}\Automation
        ///     "My Automation Object"              "AutomationObject"
        /// </summary>
        protected abstract Hashtable ExpectedValues
        {
            get;
        }

        /// <summary>
        /// Gets an appropiately populated attribute instance
        /// </summary>
        [CLSCompliant(false)]
        protected abstract RegistrationAttribute AttributeInstance
        {
            get;
        }
        #endregion

        #region virtual methods (test helpers)
        /// <summary>
        /// This scenario tests if an instance of the attribute can be constructed
        /// </summary>
        /// 
        public virtual void CreateInstance()
        {
            Assert.IsNotNull(this.AttributeInstance);
        }

        public static void RegistrationTest(RegistrationAttribute attributeUnderTest, Hashtable expectedValues, BaseRegistrationContextMock contextMock)
        {
            attributeUnderTest.Register(contextMock);

            //Verify if the number of the registry entries is the same
            Assert.IsTrue(contextMock.RegistryEntries.Count == expectedValues.Count);

            //Verify each entry
            foreach (object regKeyName in contextMock.RegistryEntries.Keys)
            {
                Hashtable valDataActual, valDataExpected;
                Assert.IsNotNull(valDataActual = (Hashtable)(((RegistrationKeyMock)contextMock.RegistryEntries[regKeyName])).Keys);
                Assert.IsNotNull(valDataExpected = (Hashtable)expectedValues[regKeyName]);
                Assert.AreEqual(valDataExpected.Count, valDataActual.Count);
                foreach (object valueName in valDataActual.Keys)
                    Assert.IsTrue(string.Compare(valDataActual[valueName.ToString()].ToString(), valDataExpected[valueName.ToString()].ToString(), true) == 0);
            }
        }

        /// <summary>
        /// This scenario verifies Register method
        /// </summary>
        public virtual void RegistrationTest()
        {
            RegistrationTest(this.AttributeInstance, this.ExpectedValues, this.ContextMock);
        }

        /// <summary>
        /// This scenario verifies the Unregister method
        /// </summary>
        public virtual void UnRegistrationTest()
        {
            UnRegistrationTest(this.AttributeInstance, this.ContextMock);
        }

        /// <summary>
        /// This scenario verifies the Unregister method
        /// </summary>
        public static void UnRegistrationTest(RegistrationAttribute attributeUnderTest, BaseRegistrationContextMock contextMock)
        {
            attributeUnderTest.Unregister(contextMock);
            Assert.IsTrue(contextMock.RegistryEntries.Count == 0);
        }
        #endregion
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\RegistrationAttributes\UnitTests\Tests\AppCommandLineAttributeTest.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Text;
using System.Collections.Generic;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VsSDK.UnitTestLibrary;
using Microsoft.VisualStudio.Shell;
using System.Collections;
using System.Runtime.InteropServices;
using System.Globalization;

namespace Microsoft.VisualStudio.Shell.RegistrationAttributes.UnitTests
{

    /// <summary>
    /// This class tests the ProvideAppCommandLineAttribute class
    /// </summary>
    [CLSCompliant(false)]
    [TestClass]
    public class AppCommandLineAttributeTest : AttributeCommonTest
    {
        #region fields
        private Type packageType = typeof(DummyTypeWithGuid);
        private string appCmdLineName = "MyAppCommandLine".ToUpperInvariant(); 
        #endregion

        #region overridden properties
        /// <summary>
        /// Gets an appropiately populated attribute instance
        /// </summary>
        [CLSCompliant(false)]
        protected override RegistrationAttribute AttributeInstance
        {
            get
            {
                if (_instance == null)
                {
                    ProvideAppCommandLineAttribute appCmdAttrib =
                        new ProvideAppCommandLineAttribute(appCmdLineName, packageType);
                    appCmdAttrib.Arguments = "*";
                    appCmdAttrib.DemandLoad = 1;
                    appCmdAttrib.HelpString = "#200";
                    _instance = appCmdAttrib;
                }
                return _instance;
            }
        }

        /// <summary>
        /// Returns the hash table of the expected registry key and values.
        /// </summary>
        protected override Hashtable ExpectedValues
        {
            get
            {
                _data.Clear();
                //Build the reg key name
                RegKeyToAdd = @"AppCommandLine\MyAppCommandLine".ToUpperInvariant();

                //Build the data for each reg key entry in the hash table.
                Hashtable valData = new Hashtable();
                valData.Add("Arguments".ToUpperInvariant(), "*");
                valData.Add("DemandLoad".ToUpperInvariant(), "1".ToUpperInvariant());
                valData.Add("Package".ToUpperInvariant(), packageType.GUID.ToString("B").ToUpperInvariant());
                valData.Add("HelpString".ToUpperInvariant(), "#200".ToUpperInvariant());

                //Add the reg entry
                _data.Add(RegKeyToAdd, valData);

                return _data;
            }
        } 
        #endregion

        #region overridden methods
        /// <summary>
        /// This scenario tests if an instance of the attribute can be constructed
        /// </summary>
        [TestMethod()]
        public override void CreateInstance()
        {
            base.CreateInstance();
        }

        /// <summary>
        /// This scenario verifies Register method
        /// </summary>
        [TestMethod()]
        public override void RegistrationTest()
        {
            base.RegistrationTest();
        }

        /// <summary>
        /// This scenario verifies the UnRegistermehtod
        /// </summary>
        [TestMethod()]
        public override void UnRegistrationTest()
        {
            base.UnRegistrationTest();
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\RegistrationAttributes\UnitTests\Tests\ComponentPickerPropertyPageAttributeTest.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Text;
using System.Collections.Generic;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VsSDK.UnitTestLibrary;
using Microsoft.VisualStudio.Shell;
using System.Collections;
using System.Runtime.InteropServices;

namespace Microsoft.VisualStudio.Shell.RegistrationAttributes.UnitTests.Tests
{
    /// <summary>
    /// This class tests the ComponentPickerPropertyPageAttribute class
    /// </summary>
    [CLSCompliant(false)]
    [TestClass]
    public class ComponentPickerPropertyPageAttributeTest : AttributeCommonTest
    {
        //Reg Key Name
        private string ComponentPickerRegKeyName = "ComponentPickerPages";
        private string PageRegKeyName = "TestPage";

        //Reg Key Value Names
        private string ComponentTypeValueName = "componenttype".ToUpperInvariant();
        private string AddToMruValueName = "addtomru".ToUpperInvariant();
        private string PacakgeValueName = "package".ToUpperInvariant();
        private string PageValueName = "page".ToUpperInvariant();
        private string SortValueName = "sort".ToUpperInvariant();

        //Reg data to build the key name
        private Type PageType = typeof(DummyTypeWithGuid);
        private Type PackageType = typeof(DummyTypeWithGuid);
        private string PageDefaultValueData = typeof(DummyTypeWithGuid).Name.ToLower();
        private string ComponentTypeValueData = "MyComponent";
        private bool AddToMruValueData = true;
        private int SortOrderData = 10;

        /// <summary>
        /// Gets an appropiately populated attribute instance
        /// </summary>
        [CLSCompliant(false)]
        protected override RegistrationAttribute AttributeInstance
        {
            get
            {
                if (_instance == null)
                {
                    ComponentPickerPropertyPageAttribute cmpPickerPageAttrib = new ComponentPickerPropertyPageAttribute(PackageType, PageType, PageRegKeyName);
                    cmpPickerPageAttrib.AddToMru = AddToMruValueData;
                    cmpPickerPageAttrib.ComponentType = ComponentTypeValueData;
                    cmpPickerPageAttrib.DefaultPageNameValue = PageDefaultValueData;
                    cmpPickerPageAttrib.SortOrder = SortOrderData;

                    _instance = cmpPickerPageAttrib;

                }
                return _instance;
            }
        }

        /// <summary>
        /// Returns the hash table of the expected registry key and values.
        /// </summary>
        protected override Hashtable ExpectedValues
        {
            get
            {
                _data.Clear();
                //Build the reg key name
                RegKeyToAdd = string.Join(@"\", new string[] { ComponentPickerRegKeyName, PageRegKeyName });
                RegKeyToAdd = RegKeyToAdd.ToUpperInvariant();

                //Build the data for each reg key entry in the hah table.
                Hashtable valData = new Hashtable();
                valData.Add(string.Empty, PageDefaultValueData.ToUpperInvariant());
                valData.Add(PacakgeValueName, PackageType.GUID.ToString("B").ToUpperInvariant());
                valData.Add(PageValueName, PageType.GUID.ToString("B").ToUpperInvariant());
                valData.Add(ComponentTypeValueName, ComponentTypeValueData.ToUpperInvariant());

                valData.Add(AddToMruValueName, Convert.ToInt32(AddToMruValueData).ToString());
                valData.Add(SortValueName, SortOrderData.ToString());

                //Add the reg entry
                _data.Add(RegKeyToAdd, valData);

                return _data;

            }
        }

        /// <summary>
        /// This scenario tests if an instance of the attribute can be constructed
        /// </summary>
        [TestMethod()]
        public override void CreateInstance()
        {
            base.CreateInstance();
        }

        /// <summary>
        /// This scenario verifies Register method
        /// </summary>
        [TestMethod()]
        public override void RegistrationTest()
        {
            base.RegistrationTest();
        }

        /// <summary>
        /// This scenario verifies the UnRegistermehtod
        /// </summary>
        [TestMethod()]
        public override void UnRegistrationTest()
        {
            base.UnRegistrationTest();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\RegistrationAttributes\UnitTests\Tests\CodeGeneratorRegistrationAttributeTest.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Text;
using System.Collections.Generic;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VsSDK.UnitTestLibrary;
using Microsoft.VisualStudio.Shell;
using System.Collections;
using System.Runtime.InteropServices;

namespace Microsoft.VisualStudio.Shell.RegistrationAttributes.UnitTests
{

    /// <summary>
    /// This class tests the CodeGeneratorRegistrationAttribute class
    /// </summary>
    [CLSCompliant(false)]
    [TestClass]
    public class CodeGeneratorRegistrationAttributeTest : AttributeCommonTest
    {
        //Reg Key Name
        private string GeneratorsRegKeyName = "generators".ToUpperInvariant();

        //Reg Key Value names
        private string ClsidValueName = "clsid".ToUpperInvariant();
        private string GeneratesDesignTimeSourceValueName = "generatesdesigntimesource".ToUpperInvariant();
        private string GeneratesSharedDesignTimeSourceValueName = "generatesshareddesigntimesource".ToUpperInvariant();

        //Reg data to build the key name
        private string GeneratorGuid = Guid.NewGuid().ToString("B").ToLower();
        private Type GeneratorType = typeof(DummyTypeWithGuid);
        private string GeneratorName = typeof(DummyTypeWithGuid).Name.ToLower();

        /// <summary>
        /// Gets an appropiately populated attribute instance
        /// </summary>
        [CLSCompliant(false)]
        protected override RegistrationAttribute AttributeInstance
        {
            get
            {
                if (_instance == null)
                {
                    CodeGeneratorRegistrationAttribute codeGenRegAttrib = new CodeGeneratorRegistrationAttribute(GeneratorType, GeneratorName, GeneratorGuid);
                    codeGenRegAttrib.GeneratesDesignTimeSource = true;
                    codeGenRegAttrib.GeneratesSharedDesignTimeSource = true;
                    _instance = codeGenRegAttrib;

                }
                return _instance;
            }
        }

        /// <summary>
        /// Returns the hash table of the expected registry key and values.
        /// </summary>
        protected override Hashtable ExpectedValues
        {
            get
            {
                _data.Clear();
                //Build the reg key name
                RegKeyToAdd = string.Join(@"\", new string[] { GeneratorsRegKeyName, GeneratorGuid, GeneratorName });
                RegKeyToAdd = RegKeyToAdd.ToUpperInvariant();

                //Build the data for each reg key entry in the hah table.
                Hashtable valData = new Hashtable();
                valData.Add(string.Empty, GeneratorName.ToUpperInvariant());
                valData.Add(ClsidValueName, GeneratorType.GUID.ToString("B").ToUpperInvariant());
                valData.Add(GeneratesDesignTimeSourceValueName, "1");
                valData.Add(GeneratesSharedDesignTimeSourceValueName, "1");

                //Add the reg entry
                _data.Add(RegKeyToAdd, valData);

                return _data;

            }
        }

        /// <summary>
        /// This scenario tests if an instance of the attribute can be constructed
        /// </summary>
        [TestMethod()]
        public override void CreateInstance()
        {
            base.CreateInstance();
        }

        /// <summary>
        /// This scenario verifies Register method
        /// </summary>
        [TestMethod()]
        public override void RegistrationTest()
        {
            base.RegistrationTest();
        }

        /// <summary>
        /// This scenario verifies the UnRegistermehtod
        /// </summary>
        [TestMethod()]
        public override void UnRegistrationTest()
        {
            base.UnRegistrationTest();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\RegistrationAttributes\UnitTests\Tests\ProvideBindingPathAttributeTests.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Collections;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Microsoft.VsSDK.UnitTestLibrary;
using System.Reflection;
using System.IO;

namespace Microsoft.VisualStudio.Shell.RegistrationAttributes.UnitTests
{
    /// <summary>
    /// Unit tests for the ProvideBindingPathAttribute class
    /// </summary>
    [CLSCompliant(false)]
    [TestClass]
    public class ProvideBindingPathAttributeTests : AttributeCommonTest
    {
        [TestMethod]
        public void Register_WithDefaultProperties_UsesComponentPathAndPackageGuidValue()
        {
            var attribute = new ProvideBindingPathAttribute();
            var expectedKeys = new Hashtable()
            {
                //Build the data for each reg key entry in the hash table.
                { 
                    @"BindingPaths\".ToUpperInvariant() + ContextMock.GetType().GUID.ToString("B").ToUpperInvariant(), 
                    new Hashtable()
                    {
                        { Path.GetDirectoryName(Assembly.GetExecutingAssembly().EscapedCodeBase).ToUpperInvariant(), "" }
                    }
                }
            };

            AttributeCommonTest.RegistrationTest(attribute, expectedKeys, new BaseRegistrationContextMock());
        }

        [TestMethod]
        public void Register_WithSubFolderSpecified_UsesPackageFolderTokenWithSubTokenAndPackageGuidValue()
        {
            var attribute = new ProvideBindingPathAttribute()
            {
                SubPath = "subFolder",
            };

            var expectedKeys = new Hashtable()
            {
                //Build the data for each reg key entry in the hash table.
                { 
                    @"BindingPaths\".ToUpperInvariant() + ContextMock.GetType().GUID.ToString("B").ToUpperInvariant(), 
                    new Hashtable()
                    {   
                        {Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().EscapedCodeBase),"subFolder").ToUpperInvariant(), ""}
                    }
                }
            };

            AttributeCommonTest.RegistrationTest(attribute, expectedKeys, new BaseRegistrationContextMock());
        }

        [TestMethod]
        public void Register_NullContext_ExceptionThrown()
        {
            NullContextTestHelper(true);
        }

        [TestMethod]
        public void Unregister_NullContext_ExceptionThrown()
        {
            NullContextTestHelper(false);
        }

        private static void NullContextTestHelper(bool useRegisterMethod)
        {
            bool exceptionThrown = false;
            var attribute = new ProvideBindingPathAttribute();
            try
            {
                if (useRegisterMethod)
                {
                    attribute.Register(null);
                }
                else
                {
                    attribute.Unregister(null);
                }
            }
            catch (ArgumentNullException)
            {
                exceptionThrown = true;
            }
            Assert.IsTrue(exceptionThrown);
        }

        protected override Hashtable ExpectedValues
        {
            get { throw new NotImplementedException(); }
        }

        protected override RegistrationAttribute AttributeInstance
        {
            get { throw new NotImplementedException(); }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\RegistrationAttributes\UnitTests\Tests\MockRegistrationContext.cs ===
//***************************************************************************
//
//    Copyright (c) Microsoft Corporation. All rights reserved.
//    This code is licensed under the Visual Studio SDK license terms.
//    THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
//    ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
//    IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
//    PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.
//
//***************************************************************************

using System;
using System.IO;
using Microsoft.VisualStudio.Shell;

namespace Microsoft.VisualStudio.Shell.RegistrationAttributes.UnitTests
{
    /// <summary>
    /// Helper code to create RegistrationContext mock
    /// </summary>
    public class MockRegistrationContext : RegistrationAttribute.RegistrationContext, IDisposable
    {
        StreamWriter streamWriter;
        public override string ComponentPath
        {
            get { return "tt"; }

        }
        public override string CodeBase
        {
            get { return "tt"; }

        }
        public override Type ComponentType
        {
            get { return (new Int32()).GetType(); }

        }
        public override string InprocServerPath
        {
            get { return "tt"; }

        }
        public override string RootFolder
        {
            get { throw new NotImplementedException("The method or operation is not implemented."); }
        }
        public override RegistrationMethod RegistrationMethod
        {
            get { return new RegistrationMethod(); }
        }
        public override TextWriter Log
        {

            get { String writer = "C:\\21.txt"; streamWriter = new StreamWriter(writer); return streamWriter; }

        }
        public override RegistrationAttribute.Key CreateKey(string name)
        {
            MockKey key = new MockKey();
            return key;
        }
        public override string EscapePath(string str)
        {
            return "EscapePath";
        }
        public override void RemoveKey(string name)
        {

        }
        public override void RemoveKeyIfEmpty(string name)
        {

        }
        public override void RemoveValue(string keyname, string valuename)
        {

        }

        #region IDisposable Members
        /// <summary>
        /// IDisposable interface implementation to dispose StreamWriter member that it owns
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
        #endregion

        /// <summary>
        /// IDisposable pattern Implementation
        /// </summary>
        /// <param name="disposing"></param>
        private void Dispose(bool disposing)
        {
            if (disposing)
            {
                if (streamWriter != null)
                {
                    streamWriter.Dispose();
                    streamWriter = null;
                }
            }
        }
    }

    internal class MockKey : RegistrationAttribute.Key
    {
        public override RegistrationAttribute.Key CreateSubkey(String value) { return null; }
        public override void SetValue(String value, Object objectValue) { ; }
        public override void Close() { ; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\RegistrationAttributes\UnitTests\Tests\SingleFileGeneratorAttributeTest.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Text;
using System.Collections.Generic;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VsSDK.UnitTestLibrary;
using Microsoft.VisualStudio.Shell;
using System.Collections;
using System.Runtime.InteropServices;
using System.Globalization;

namespace Microsoft.VisualStudio.Shell.RegistrationAttributes.UnitTests
{

    /// <summary>
    /// This class tests the CodeGeneratorRegistrationAttribute class
    /// </summary>
    [CLSCompliant(false)]
    [TestClass]
    public class SingleFileGeneratorAttributeTest : AttributeCommonTest  
    {
        private Type ProjectFactType = typeof(DummyTypeWithGuid);

        /// <summary>
        /// Gets an appropiately populated attribute instance
        /// </summary>
        [CLSCompliant(false)]
        protected override RegistrationAttribute AttributeInstance
        {
            get
            {
                if (_instance == null)
                {
                    SingleFileGeneratorSupportRegistrationAttribute sfgRegAttrib =
                        new SingleFileGeneratorSupportRegistrationAttribute(ProjectFactType);
                    _instance = sfgRegAttrib;
                }
                return _instance;
            }
        }

        /// <summary>
        /// Returns the hash table of the expected registry key and values.
        /// </summary>
        protected override Hashtable ExpectedValues
        {
            get 
            {
                _data.Clear();
                //Build the reg key name
                RegKeyToAdd = string.Format(CultureInfo.InvariantCulture, @"Generators\{0}", ProjectFactType.GUID.ToString("B"));
                RegKeyToAdd = RegKeyToAdd.ToUpperInvariant();

                //Build the data for each reg key entry in the hah table.
                Hashtable valData = new Hashtable();
                valData.Add(string.Empty, string.Empty);

                //Add the reg entry
                _data.Add(RegKeyToAdd, valData);

                return _data;
            }
        }

        /// <summary>
        /// This scenario tests if an instance of the attribute can be constructed
        /// </summary>
        [TestMethod()]
        public override void CreateInstance()
        {
            base.CreateInstance();
        }

        /// <summary>
        /// This scenario verifies Register method
        /// </summary>
        [TestMethod()]
        public override void RegistrationTest()
        {
            base.RegistrationTest();
        }

        /// <summary>
        /// This scenario verifies the UnRegistermehtod
        /// </summary>
        [TestMethod()]
        public override void UnRegistrationTest()
        {
            base.UnRegistrationTest();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\RegistrationAttributes\UnitTests\Tests\SolutionPersistenceRegistrationAttributeTest.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Text;
using System.Collections.Generic;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VsSDK.UnitTestLibrary;
using Microsoft.VisualStudio.Shell;
using System.Collections;
using System.Runtime.InteropServices;

namespace Microsoft.VisualStudio.Shell.RegistrationAttributes.UnitTests
{

    /// <summary>
    /// This class tests the SolutionPersistenceRegistrationAttributeTest class
    /// </summary>
    [CLSCompliant(false)]
    [TestClass]
    public class SolutionPersistenceRegistrationAttributeTest : AttributeCommonTest
    {
        //Reg Key Name
        private string SolutionPersistenceKeyName = "solutionpersistence".ToUpperInvariant();

        //Reg data to build the key name
        private string PropProviderGuidVal = Guid.NewGuid().ToString("B").ToLower();
        private string PropertyName = "dummyprop";

        /// <summary>
        /// Gets an appropiately populated attribute instance
        /// </summary>
        [CLSCompliant(false)]
        protected override RegistrationAttribute AttributeInstance
        {
            get
            {
                if (_instance == null)
                {
                    SolutionPersistenceRegistrationAttribute codeGenRegAttrib = new SolutionPersistenceRegistrationAttribute(PropertyName);
                    _instance = codeGenRegAttrib;

                }
                return _instance;
            }
        }

        /// <summary>
        /// Returns the hash table of the expected registry key and values.
        /// </summary>
        protected override Hashtable ExpectedValues
        {
            get
            {
                _data.Clear();

                //Build the reg key name
                RegKeyToAdd = string.Join(@"\", new string[] { SolutionPersistenceKeyName, PropertyName });
                RegKeyToAdd = RegKeyToAdd.ToUpperInvariant();

                //Build the data for each reg key entry in the hah table.
                Hashtable valData = new Hashtable();
                valData.Add(string.Empty, ContextMock.ComponentType.GUID.ToString("B").ToUpperInvariant());

                //Add the reg entry
                _data.Add(RegKeyToAdd, valData);

                return _data;

            }
        }

        /// <summary>
        /// This scenario tests if an instance of the attribute can be constructed
        /// </summary>
        [TestMethod()]
        public override void CreateInstance()
        {
            base.CreateInstance();
        }

        /// <summary>
        /// This scenario verifies Register method
        /// </summary>
        [TestMethod()]
        public override void RegistrationTest()
        {
            base.RegistrationTest();
        }

        /// <summary>
        /// This scenario verifies the UnRegistermehtod
        /// </summary>
        [TestMethod()]
        public override void UnRegistrationTest()
        {
            base.UnRegistrationTest();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\RegistrationAttributes\UnitTests\Tests\EditorFactoryNotifyForProjectAttributeTest.cs ===
﻿/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace Microsoft.VisualStudio.Shell.RegistrationAttributes.UnitTests
{
    /// <summary>
    ///EditorFactoryNotifyForProjectAttribute class unit tests 
    ///</summary>
    [TestClass()]
    public class EditorFactoryNotifyForProjectAttributeTest
    {
        private object projectType;
        private string fileExtension;
        private object factoryType;

        #region Initialization
        /// <summary>
        /// Creates XmlDocument with one node = rootNodeName
        /// </summary>
        [TestInitialize()]
        public void InitializeParameters()
        {
            projectType = "{8a333fe3-2e11-42d9-8f6b-ae761e3b0588}";
            fileExtension = "TXT";
            factoryType = new Guid("{3e8702a1-d26f-4b91-bdc2-7ea0022b696c}");
        }
        #endregion Initialization

        /// <summary>
        /// Verify that the constructor throws a ArgumentNullException if the
        /// projectType is not set.
        /// </summary>
        [TestMethod()]
        [ExpectedException(typeof(ArgumentNullException))]
        public void ConstructorWithProjectTypeNullArgTest()
        {
            projectType = null;
            EditorFactoryNotifyForProjectAttribute target = new EditorFactoryNotifyForProjectAttribute(projectType, fileExtension, factoryType);
            Assert.IsNotNull(target, "Failed to initialize new instance of type EditorFactoryNotifyForProjectAttribute");
        }

        /// <summary>
        /// Verify that the constructor throws a ArgumentNullException if the
        /// projectType is not set.
        /// </summary>
        [TestMethod()]
        [ExpectedException(typeof(ArgumentNullException))]
        public void ConstructorWithFactoryTypeNullArgTest()
        {
            factoryType = null;
            EditorFactoryNotifyForProjectAttribute target = new EditorFactoryNotifyForProjectAttribute(projectType, fileExtension, factoryType);
            Assert.IsNotNull(target, "Failed to initialize new instance of type EditorFactoryNotifyForProjectAttribute");
        }

        /// <summary>
        ///A test for EditorFactoryNotifyForProjectAttribute (object, string, object)
        ///</summary>
        [TestMethod()]
        public void ConstructorTest()
        {
            EditorFactoryNotifyForProjectAttribute target = new EditorFactoryNotifyForProjectAttribute(projectType, fileExtension, factoryType);
            Assert.IsNotNull(target, "Failed to initialize new instance of type EditorFactoryNotifyForProjectAttribute");

            String factoryTypeString = "{3e8702a1-d26f-4b91-bdc2-7ea0022b696c}";
            projectType = new Guid("{3e8702a1-d26f-4b91-bdc2-7ea0022b696c}");
            EditorFactoryNotifyForProjectAttribute targetFromString = new EditorFactoryNotifyForProjectAttribute(projectType, fileExtension, factoryTypeString);
            Assert.IsNotNull(targetFromString, "Failed to initialize new instance of type EditorFactoryNotifyForProjectAttribute from String");

            Int32 integ = new Int32();
            factoryType = integ.GetType();
            projectType = integ.GetType();

            EditorFactoryNotifyForProjectAttribute targetFromType = new EditorFactoryNotifyForProjectAttribute(projectType, fileExtension, factoryType);
            Assert.IsNotNull(targetFromType, "Failed to initialize new instance of type EditorFactoryNotifyForProjectAttribute from Type");
        }

        /// <summary>
        /// A test for EditorFactoryNotifyForProjectAttribute (object, string, object)
        /// </summary>
        [TestMethod()]
        public void ConstructorTest1()
        {
            EditorFactoryNotifyForProjectAttribute target = new EditorFactoryNotifyForProjectAttribute(projectType, fileExtension, factoryType);
            Assert.IsNotNull(target, "Failed to initialize new instance of type EditorFactoryNotifyForProjectAttribute");

            String factoryTypeString = "{3e8702a1-d26f-4b91-bdc2-7ea0022b696c}";
            projectType = new Guid("{3e8702a1-d26f-4b91-bdc2-7ea0022b696c}");
            EditorFactoryNotifyForProjectAttribute targetFromString = new EditorFactoryNotifyForProjectAttribute(projectType, fileExtension, factoryTypeString);
            Assert.IsNotNull(targetFromString, "Failed to initialize new instance of type EditorFactoryNotifyForProjectAttribute from String");

            factoryType = typeof(int);
            projectType = typeof(int);

            EditorFactoryNotifyForProjectAttribute targetFromType = new EditorFactoryNotifyForProjectAttribute(projectType, fileExtension, factoryType);
            Assert.IsNotNull(targetFromType, "Failed to initialize new instance of type EditorFactoryNotifyForProjectAttribute from Type");
        }

        /// <summary>
        ///A test for EditorFactoryNotifyForProjectAttribute (object, string, object)
        /// Wrong cunxtructor parameter type test.
        ///</summary>
        [TestMethod()]
        [ExpectedException(typeof(ArgumentException))]
        public void ConstructorTestArgumentException()
        {
            object projectType = typeof(int); // TODO: Initialize to an appropriate value
            string fileExtension = null; // TODO: Initialize to an appropriate value
            object factoryType = (int)0; // TODO: Initialize to an appropriate value

            EditorFactoryNotifyForProjectAttribute target = new EditorFactoryNotifyForProjectAttribute(projectType, fileExtension, factoryType);
            Assert.IsNotNull(target, "Failed to initialize new instance of type EditorFactoryNotifyForProjectAttribute");
        }

        /// <summary>
        ///A test for EditorFactoryNotifyForProjectAttribute (object, string, object)
        /// Wrong cunxtructor parameter type test.
        ///</summary>
        [TestMethod()]
        [ExpectedException(typeof(ArgumentException))]
        public void ConstructorTestArgumentException1()
        {
            object projectType = (int)0; // TODO: Initialize to an appropriate value
            string fileExtension = null; // TODO: Initialize to an appropriate value
            object factoryType = typeof(int); // TODO: Initialize to an appropriate value

            EditorFactoryNotifyForProjectAttribute target = new EditorFactoryNotifyForProjectAttribute(projectType, fileExtension, factoryType);
            Assert.IsNotNull(target, "Failed to initialize new instance of type EditorFactoryNotifyForProjectAttribute");
        }


        /// <summary>
        ///A test for FactoryType
        ///</summary>
        [TestMethod()]
        public void FactoryTypeTest()
        {
            EditorFactoryNotifyForProjectAttribute target = new EditorFactoryNotifyForProjectAttribute(projectType,
            fileExtension, factoryType);
            Guid val = new Guid("{3e8702a1-d26f-4b91-bdc2-7ea0022b696c}");

            Assert.AreEqual(val, target.FactoryType, "Microsoft.Samples.VisualStudio.SynchronousXmlDesigner.Attributes.EditorFactoryNotify" +
            "ForProjectAttribute.FactoryType was not set correctly.");
        }

        /// <summary>
        ///A test for FileExtension
        ///</summary>
        [TestMethod()]
        public void FileExtensionTest()
        {
            EditorFactoryNotifyForProjectAttribute target = new EditorFactoryNotifyForProjectAttribute(projectType, fileExtension, factoryType);
            string val = "TXT";

            Assert.AreEqual(val, target.FileExtension, "Microsoft.Samples.VisualStudio.SynchronousXmlDesigner.Attributes.EditorFactoryNotify" +
                    "ForProjectAttribute.FileExtension was not set correctly.");
        }

        /// <summary>
        ///A test for ProjectFileExtensionPath
        ///</summary>        
        [TestMethod()]
        public void ProjectFileExtensionPathTest()
        {
            EditorFactoryNotifyForProjectAttribute target = new EditorFactoryNotifyForProjectAttribute(projectType, fileExtension, factoryType);
            string extension = "TXT";

            Assert.AreEqual(extension, target.FileExtension,
            "Microsoft.Samples.VisualStudio.SynchronousXmlDesigner.Attributes.EditorFactoryNotify" +
                    "ForProjectAttribute.ProjectFileExtensionPath was not set correctly.");
        }

        /// <summary>
        /// A test for ProjectType
        /// </summary>
        [TestMethod()]
        public void ProjectTypeTest()
        {
            EditorFactoryNotifyForProjectAttribute target = new EditorFactoryNotifyForProjectAttribute(projectType, fileExtension, factoryType);
            Guid val = new Guid("{8a333fe3-2e11-42d9-8f6b-ae761e3b0588}");

            Assert.AreEqual(val, target.ProjectType, "Microsoft.Samples.VisualStudio.SynchronousXmlDesigner.Attributes.EditorFactoryNotify" +
                    "ForProjectAttribute.ProjectType was not set correctly.");
        }

        /// <summary>
        /// A test for Register (RegistrationContext)
        /// </summary>
        [TestMethod()]
        [ExpectedException(typeof(ArgumentNullException))]
        public void RegisterWithNullArgTest()
        {
            EditorFactoryNotifyForProjectAttribute target = new EditorFactoryNotifyForProjectAttribute(projectType, fileExtension, factoryType);
            MockRegistrationContext context = null;
            target.Register(context);
        }

        /// <summary>
        /// A test for Register (RegistrationContext)
        /// </summary>
        [TestMethod()]
        public void RegisterTest()
        {
            EditorFactoryNotifyForProjectAttribute target = new EditorFactoryNotifyForProjectAttribute(projectType, fileExtension, factoryType);
            using (MockRegistrationContext context = new MockRegistrationContext())
            {
                target.Register(context);
            }
        }

        /// <summary>
        /// A test for Unregister (RegistrationContext)
        /// </summary>
        [TestMethod()]
        public void UnregisterWithNullArgTest()
        {
            EditorFactoryNotifyForProjectAttribute target = new EditorFactoryNotifyForProjectAttribute(projectType, fileExtension, factoryType);
            MockRegistrationContext context = null;
            target.Unregister(context);
        }

        /// <summary>
        /// A test for Unregister (RegistrationContext)
        /// </summary>
        [TestMethod()]
        public void UnregisterTest()
        {
            EditorFactoryNotifyForProjectAttribute target = new EditorFactoryNotifyForProjectAttribute(projectType, fileExtension, factoryType);
            using (MockRegistrationContext context = new MockRegistrationContext())
            {
                target.Unregister(context);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\Attributes.cs ===
//--------------------------------------------------------------------------
//  <copyright file="Attributes.cs" company="Microsoft">
//      Copyright (c) Microsoft Corporation.  All rights reserved.
//  </copyright>
//  <summary>
//  </summary>
//--------------------------------------------------------------------------
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.Designer.Interfaces;
using System;
using System.Collections;
using System.ComponentModel;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using System.Xml;
using System.Diagnostics;
using SR=Microsoft.VisualStudio.Shell.SR;

namespace Microsoft.VisualStudio.Shell
{ 
    /// <include file='doc\Attributes.uex' path='docs/doc[@for="PropertyPageTypeConverterAttribute"]' />
	/// <summary>
	/// Defines our type converter.
	/// </summary>
	/// <remarks>This is needed to get rid of the type TypeConverter type that could not give back the Type we were passing to him.
	/// We do not want to use reflection to get the type back from the  ConverterTypeName. Also the GetType mthos does not spwan converters from other assemblies.</remarks>
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Enum | AttributeTargets.Property | AttributeTargets.Field)]
	public sealed class PropertyPageTypeConverterAttribute : Attribute
	{
		Type converterType;
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="PropertyPageTypeConverterAttribute.PropertyPageTypeConverterAttribute"]' />
        public PropertyPageTypeConverterAttribute(Type t)
		{
			this.converterType = t;
		}

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="PropertyPageTypeConverterAttribute.ConverterType"]' />
        public Type ConverterType
		{
			get
			{
				return this.converterType;
			}
		}
	}

    /// <include file='doc\Attributes.uex' path='docs/doc[@for="LocDisplayNameAttribute"]' />
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Property | AttributeTargets.Field, Inherited = false, AllowMultiple = false)]
	public sealed class LocDisplayNameAttribute : DisplayNameAttribute
	{
		string name;

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="LocDisplayNameAttribute.LocDisplayNameAttribute"]' />
        public LocDisplayNameAttribute(string name)
		{
			this.name = name;
		}

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="LocDisplayNameAttribute.DisplayName"]' />
        public override string DisplayName
		{
			get
			{
				string result = SR.GetString(this.name);
				if (result == null)
				{
					Debug.Assert(false, "String resource '" + this.name + "' is missing");
					result = this.name;
				}
				return result;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\IProfileManager.cs ===
//------------------------------------------------------------------------------
// <copyright file="IProfileManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {
    
    using System;
    using Microsoft.VisualStudio.Shell.Interop;

    /// <include file='doc\IProfileManager.uex' path='docs/doc[@for="IProfileManager"]' />
    /// <devdoc>
    /// Interface used to provide import/export capabilities of properties
    /// usually stored in the registry.
    /// </devdoc>
    [CLSCompliant(false)]
    public interface IProfileManager {
        /// <include file='doc\IProfileManager.uex' path='docs/doc[@for=IProfileManager.SaveSettingsToXml]/*' />
        /// <devdoc>
        /// Summary of SaveSettingsToXml.
        /// </devdoc>
        /// <param name='writer'></param>
        void SaveSettingsToXml(IVsSettingsWriter writer);

        /// <include file='doc\IProfileManager.uex' path='docs/doc[@for=IProfileManager.LoadSettingsFromXml]/*' />
        /// <devdoc>
        /// Summary of LoadSettingsFromXml.
        /// </devdoc>
        /// <param name='reader'></param>
        void LoadSettingsFromXml(IVsSettingsReader reader);

        /// <include file='doc\IProfileManager.uex' path='docs/doc[@for=IProfileManager.SaveSettingsToStorage]/*' />
        /// <devdoc>
        /// Summary of SaveSettingsToStorage.
        /// </devdoc>
        void SaveSettingsToStorage();

        /// <include file='doc\IProfileManager.uex' path='docs/doc[@for=IProfileManager.LoadSettingsFromStorage]/*' />
        /// <devdoc>
        /// Summary of LoadSettingsFromStorage.
        /// </devdoc>
        void LoadSettingsFromStorage();

        /// <include file='doc\IProfileManager.uex' path='docs/doc[@for=IProfileManager.ResetSettings]/*' />
        /// <devdoc>
        /// Reset your settings (__UserSettingsFlags.USF_ResetOnImport was set).
        /// </devdoc>
        void ResetSettings();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\DesignPropertyDescriptor.cs ===
//--------------------------------------------------------------------------
//  <copyright file="DesignPropertyDescriptor.cs" company="Microsoft">
//      Copyright (c) Microsoft Corporation.  All rights reserved.
//  </copyright>
//  <summary>
//  </summary>
//--------------------------------------------------------------------------
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.Designer.Interfaces;
using Microsoft.VisualStudio.Shell;
using System;
using System.Collections;
using System.ComponentModel;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using System.Xml;
using System.Diagnostics;

namespace Microsoft.VisualStudio.Shell
{
	/// <summary>
	/// The purpose of DesignPropertyDescriptor is to allow us to customize the
	/// display name of the property in the property grid.  None of the CLR
	/// implementations of PropertyDescriptor allow you to change the DisplayName.
	/// </summary>
	public class DesignPropertyDescriptor : PropertyDescriptor
	{
		private string displayName; // Custom display name
		private PropertyDescriptor property;	// Base property descriptor
		private Hashtable editors = new Hashtable(); // Type -> editor instance
		private TypeConverter converter;


		/// <summary>
		/// Delegates to base.
		/// </summary>
		public override string DisplayName
		{
			get
			{
				return this.displayName;
			}
		}

		/// <summary>
		/// Delegates to base.
		/// </summary>
		public override Type ComponentType
		{
			get
			{
				return this.property.ComponentType;
			}
		}

		/// <summary>
		/// Delegates to base.
		/// </summary>
		public override bool IsReadOnly
		{
			get
			{
				return this.property.IsReadOnly;
			}
		}

		/// <summary>
		/// Delegates to base.
		/// </summary>
		public override Type PropertyType
		{
			get
			{
				return this.property.PropertyType;
			}
		}


		/// <summary>
		/// Delegates to base.
		/// </summary>
		public override object GetEditor(Type editorBaseType)
		{
			object editor = this.editors[editorBaseType];
			if (editor == null)
			{
				for (int i = 0; i < this.Attributes.Count; i++)
				{
					EditorAttribute attr = Attributes[i] as EditorAttribute;
					if (attr == null)
					{
						continue;
					}
					Type editorType = Type.GetType(attr.EditorBaseTypeName);
					if (editorBaseType == editorType)
					{
						Type type = GetTypeFromNameProperty(attr.EditorTypeName);
						if (type != null)
						{
							editor = CreateInstance(type);
							this.editors[type] = editor; // cache it
							break;
						}
					}
				}
			}
			return editor;
		}


		/// <summary>
		/// Return type converter for property
		/// </summary>
		public override TypeConverter Converter
		{
			get
			{
				if (converter == null)
				{
					PropertyPageTypeConverterAttribute attr = (PropertyPageTypeConverterAttribute)Attributes[typeof(PropertyPageTypeConverterAttribute)];
					if (attr != null && attr.ConverterType != null)
					{
						converter = (TypeConverter)CreateInstance(attr.ConverterType);
					}

					if (converter == null)
					{
						converter = TypeDescriptor.GetConverter(this.PropertyType);
					}
				}
				return converter;
			}
		}



		/// <summary>
		/// Convert name to a Type object.
		/// </summary>
		public virtual Type GetTypeFromNameProperty(string typeName)
		{
			return Type.GetType(typeName);
		}


		/// <summary>
		/// Delegates to base.
		/// </summary>
		public override bool CanResetValue(object component)
		{
			bool result = this.property.CanResetValue(component);
			return result;
		}

		/// <summary>
		/// Delegates to base.
		/// </summary>
		public override object GetValue(object component)
		{
			object value = this.property.GetValue(component);
			return value;
		}

		/// <summary>
		/// Delegates to base.
		/// </summary>
		public override void ResetValue(object component)
		{
			this.property.ResetValue(component);
		}

		/// <summary>
		/// Delegates to base.
		/// </summary>
		public override void SetValue(object component, object value)
		{
			this.property.SetValue(component, value);
		}

		/// <summary>
		/// Delegates to base.
		/// </summary>
		public override bool ShouldSerializeValue(object component)
		{
			bool result = this.property.ShouldSerializeValue(component);
			return result;
		}

		/// <summary>
		/// Constructor.  Copy the base property descriptor and also hold a pointer
		/// to it for calling its overridden abstract methods.
		/// </summary>
		public DesignPropertyDescriptor(PropertyDescriptor prop) : base(prop)
		{
			this.property = prop;

			Attribute attr = prop.Attributes[typeof(DisplayNameAttribute)];

			if (attr is DisplayNameAttribute)
			{
				this.displayName = ((DisplayNameAttribute)attr).DisplayName;
			}
			else
			{
				this.displayName = prop.Name;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\IConfigureToolboxItem.cs ===
//------------------------------------------------------------------------------
// <copyright file="IConfigureToolboxItem.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {
    
    using System;
    using System.Drawing.Design;
    using Microsoft.VisualStudio.Shell.Interop;

    /// <include file='doc\IConfigureToolboxItem.uex' path='docs/doc[@for="IConfigureToolboxItem"]' />
    /// <devdoc>
    ///    This interface can be implemented on a creatable object.  The toolbox service will call
    ///    ConfigureToolboxItem on this interface when a new toolbox item is first added to the
    ///    toolbox.  This gives an external party a chance to add additional data to the toolbox item's
    ///    Properties dictionary.  This data then gets serialized as a permanent part of the toolbox item.
    /// 
    ///    Objects that implement this interface should be declared through a 
    ///    ProvideToolboxItemConfigurationAttribute attached to the package.  This attribute will register 
    ///    the object under the local CLSID hive in the VS registry and also add a reference to the GUID in
    ///    VSREGROOT\ToolboxItemConfiguration.  The data contained in this registry entry
    ///    is as follows:
    /// 
    ///    VSREGROOT\ToolboxItemConfiguration
    ///        AssemblyName
    ///             ConfigurationTypeName={guid}
    /// 
    ///    As an example:
    /// 
    ///    VSREGROOT\ToolboxItemConfiguration
    ///        System, Version=2.0.3500
    ///            CompactFrameworkProvider = {GUID}
    /// 
    /// 
    ///    The assembly name is parsed and the various keys are matched.  Keys can have a
    ///    "*" in them to be taken as wildcards.  So, for example, to cover all versions
    ///    of System.WindowsForms you would specify:
    /// 
    ///    System.Windows.Forms, Version=*, PublicKeyToken=969...
    /// 
    ///    The assembly name may also be a wildcard to load the configuration object
    ///    for all toolbox items (not recommended).
    /// </devdoc>
    public interface IConfigureToolboxItem {

        /// <include file='doc\IConfigureToolboxItem.uex' path='docs/doc[@for="IConfigureToolboxItem.ConfigureToolboxItem"]' />
        /// <devdoc>
        ///     Adds extra configuration information to thish toolbox item.
        /// </devdoc>
        void ConfigureToolboxItem(ToolboxItem item);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\EventSinkCollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="LogicalView.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Collections;
    using System.Diagnostics;

    /// <include file='doc\EventSinkCollection.uex' path='docs/doc[@for="EventSinkCollection"]/*' />
    /// <summary>
    /// Maps objects to and from integer "cookies".  This helps in the implementation
    /// of VS interfaces that have Advise/Unadvise methods, for example, IVsHierarchy,
    /// IVsCfgProvider2, IVsBuildableProjectCfg and so on.
    /// </summary>
    [CLSCompliant(false)]
    public class EventSinkCollection : IEnumerable {
        ArrayList map;

        /// <include file='doc\EventSinkCollection.uex' path='docs/doc[@for="EventSinkCollection.EventSinkCollection"]/*' />
        public EventSinkCollection() {
        }

        ArrayList GetMap() {
            if (this.map == null) this.map = new ArrayList();
            return this.map;
        }

        /// <include file='doc\EventSinkCollection.uex' path='docs/doc[@for="EventSinkCollection.Count"]/*' />
        /// <devdov>
        /// Returns the total number of sinks in the collection.  Some of these might be null though.
        /// </devdov>
        public int Count {
            get { return (this.map == null) ? 0 : this.map.Count; }
        }

        /// <include file='doc\EventSinkCollection.uex' path='docs/doc[@for="EventSinkCollection.Add"]/*' />
        /// <devdov>
        /// Add an event sink and return it's cookie which can be used in the RemoveAt method.
        /// </devdov>
        public uint Add(Object o) {
            if (o == null)
                throw new ArgumentNullException("o");

            // re-use empty slots so the ArrayList doesn't grow infinitely.
            for (int i = 0, n = this.GetMap().Count; i < n; i++) {
                if (map[i] == null) {
                    map[i] = o;
                    return (uint)i+1; // cookie must be one based else VS doesn't call Unadvise
                }
            }
            this.map.Add(o);
            return (uint)this.map.Count;
        }
        /// <include file='doc\EventSinkCollection.uex' path='docs/doc[@for="EventSinkCollection.Remove"]/*' />
        /// <devdov>
        /// Remove the specified event sink from the collection
        /// </devdov>
        public void Remove(Object obj) {
            if (obj == null)
                throw new ArgumentNullException("obj");

            if (this.map != null)
            {
                for (int i = 0, n = map.Count; i < n; i++)
                {
                    if (this.map[i] == obj)
                    {
                        this.map[i] = null; // these gap will be reused.
                        if (i == n - 1)
                        {
                            // compact the array list whenever possible.
                            while (i > 0 && this.map[i - 1] == null)
                            {
                                i--;
                            }
                            this.map.RemoveRange(i, n - i);
                        }
                        return;
                    }
                }
            }
            throw new ArgumentOutOfRangeException("obj");
        }
        /// <include file='doc\EventSinkCollection.uex' path='docs/doc[@for="EventSinkCollection.RemoveAt"]/*' />
        /// <devdov>
        /// Remove the specified event sink by the cookie integer returned from the Add method.
        /// </devdov>
        public void RemoveAt(uint cookie) {
            if (this.map != null){
                this.map[(int)cookie - 1] = null;  // cookie is 1-based
            }
        }
        /// <include file='doc\EventSinkCollection.uex' path='docs/doc[@for="EventSinkCollection.SetAt"]/*' />
        /// <devdov>
        /// Update the event sink associated with the given cookie.
        /// </devdov>
        public void SetAt(uint cookie, object value) {
            this.GetMap()[(int)cookie - 1] = value;
        }
        
        /// <include file='doc\EventSinkCollection.uex' path='docs/doc[@for="EventSinkCollection.this"]/*' />
        /// <devdov>
        /// Indexor access to the event sink.  Cookie is 1-based.
        /// </devdov>
        public object this[uint cookie] {
            get {
                return (this.map != null && cookie > 0 && cookie <= this.map.Count) ? this.map[(int)cookie-1] : null;
            }
            set {
                this.GetMap()[(int)cookie-1] = value;
            }
        }
        /// <include file='doc\EventSinkCollection.uex' path='docs/doc[@for="EventSinkCollection.Clear"]/*' />
        /// <devdov>
        /// Remove all event sinks.
        /// </devdov>
        public void Clear() {
            if (this.map != null) this.map.Clear();
        }

        /// <include file='doc\EventSinkCollection.uex' path='docs/doc[@for="EventSinkCollection.IEnumerable.GetEnumerator"]/*' />
        /// <internalonly/>
        IEnumerator IEnumerable.GetEnumerator() {
            return new EventSinkEnumerator(map);
        }
        internal class EventSinkEnumerator : IEnumerator {
            ArrayList map;            
            int pos;

            public EventSinkEnumerator(ArrayList map) {
                this.map = map; 
                this.pos = -1;
            }
            object IEnumerator.Current {
                get { return (this.map != null && this.pos >= 0 && this.pos < this.map.Count) ? this.map[this.pos] : null; }
            }
            bool IEnumerator.MoveNext() {
                if (this.map == null) return false;
                int n = this.map.Count;
                if (this.pos < n) {
                    this.pos++;
                    while (this.pos < n && this.map[this.pos] == null) // skip nulls
                        this.pos++;

                    if (this.pos < n) {
                        return true;
                    }
                    return false;
                }
                return false;
            }
            void IEnumerator.Reset() {
                this.pos = -1;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\DefaultRegistryRootAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="DefaultRegistryRootAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;

    /// <include file='doc\DefaultRegistryRootAttribute.uex' path='docs/doc[@for="DefaultRegistryRootAttribute"]' />
    /// <devdoc>
    ///     This attribute defines the default registry root this package was designed to work with.  
    ///     This attribute exists on the Package base class and contains the root for the version of 
    ///     Visual Studio the package was copiled for.  The various path and registry methods on 
    ///     Package make use of this attribute, as does default registration code that setup will 
    ///     use to register packages. 
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=false, Inherited=true)]
    public sealed class DefaultRegistryRootAttribute : Attribute {

        private string _root;
    
        /// <include file='doc\DefaultRegistryRootAttribute.uex' path='docs/doc[@for="DefaultRegistryRootAttribute.DefaultRegistryRootAttribute"]' />
        /// <devdoc>
        ///     Creates a new DefaultRegistryRootAttribute.
        /// </devdoc>
        public DefaultRegistryRootAttribute (string root) {
            if (root == null) {
                throw new ArgumentNullException("root");
            }
            _root = root;
        }
        
        /// <include file='doc\DefaultRegistryRootAttribute.uex' path='docs/doc[@for="DefaultRegistryRootAttribute.Root"]' />
        /// <devdoc>
        ///     Returns the default registry root.
        /// </devdoc>
        public string Root {
            get {
                return _root;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\InstalledProductRegistrationAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright from='2003' to='2004' company='Microsoft Corporation'>           
//  Copyright (c) Microsoft Corporation, All rights reserved.             
//  This code sample is provided "AS IS" without warranty of any kind, 
//  it is not recommended for use in a production environment.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Globalization;

namespace Microsoft.VisualStudio.Shell 
{

    /// <summary>
    ///     This attribute registers an 'installed product' for your package.  
    ///     This enables your package to present information on the VS
    ///     Splash Screen or Help About.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, Inherited=false)]
    public sealed class InstalledProductRegistrationAttribute : RegistrationAttribute 
    {

        private string _productName;
        private string _name;
        private string _productId;
        private string _productDetails;
        private string _iconResourceId;
        private bool _useInterface = false;
        private bool _usePackage = false;
    
        /// <summary>
        /// Creates a new InstalledProductRegistrationAttribute to register your package with  
        /// Help/About and enables it to present informations on the VS Splash Screen.
        /// </summary>
        public InstalledProductRegistrationAttribute (bool useInterface, string productName, string productDetails, string productId) 
        {
            _usePackage = false;
            _useInterface = useInterface;
            if (_useInterface)
            {
                // If the object uses the interface in order to expose its informations to the
                // Help/About page, then the registration must use the package, otherwise there
                // is no way to know where to find such interface.
                _usePackage = true;
            }
            else
            {
                // We are not using the interface, so we need the other parameters.
                // Let's check that they are not null or empty.
                if ((null == productName) || (productName.Trim().Length == 0))
                    throw new ArgumentNullException("productName");
                productName = productName.Trim();

                if ((null == productDetails) || (productDetails.Trim().Length == 0))
                    throw new ArgumentNullException("productDetails");
                productDetails = productDetails.Trim();

                if ((null == productId) || (productId.Trim().Length == 0))
                    throw new ArgumentNullException("productId");
                productId = productId.Trim();

                // Assign the values to the member variables
                _productName = productName;
                _productDetails = productDetails;
                _productId = productId;

                // Now that we know that the parameters are not empty, let's do a final
                // validation: the Help/About code assumes that if a registration is made
                // using a package, then both the product name and the product details are
                // id of resources (so they are supposed to be in the form "#nnn"), but if 
                // they are strings, then they both must be string.
                if (((ProductNameResourceID != 0) && (ProductDetailsResourceID == 0)) ||
                    ((ProductNameResourceID == 0) && (ProductDetailsResourceID != 0)))
                {
                    // If we are here we have the resource id for only one entry and,
                    // according with the Help/About code, this is bad, so we have to
                    // throw an exception.
                    string errorMessage = SR.GetString(SR.Reg_ErrorIncompatibleParametersTypes, "productName", "productDetails");
                    throw new ArgumentException(errorMessage);
                }

                // Now check if the name and details are resource id because in this case
                // we have to use the package to register. Actually we check only the name
                // because of the previous test.
                _usePackage = (ProductNameResourceID != 0) ;
            }
        }

        #region Properties
        /// <summary>
        /// Resource ID corresponding to the product name.
        /// </summary>
        public int ProductNameResourceID
        {
            get
            {
                if (_productName == null || _productName.Length < 2 || _productName[0]!='#' || !char.IsDigit(_productName[1]))
                    return 0;
                return int.Parse( _productName.Substring(1), CultureInfo.InvariantCulture);
            }
        }
        /// <summary>
        /// Resource ID for the details.
        /// </summary>
        public int ProductDetailsResourceID
        {
            get
            {
                if (_productDetails == null || _productDetails.Length < 2 || _productDetails[0]!='#' || !char.IsDigit(_productDetails[1]))
                    return 0;
                return int.Parse( _productDetails.Substring(1), CultureInfo.InvariantCulture);
            }
        }
        /// <summary>
        /// Resource ID of the icon.
        /// </summary>
        public int IconResourceID
        {
            get
            {
                if (String.IsNullOrEmpty(_iconResourceId) || _iconResourceId.Length < 2)
                    return 0;
                return int.Parse( _iconResourceId.Substring(1), CultureInfo.InvariantCulture);
            }
            set
            {
                _iconResourceId = @"#" + value.ToString(CultureInfo.InvariantCulture);
            }
        }
        /// <summary>
        /// Your product ID.
        /// </summary>
        public string ProductId
        {
            get {return _productId;}
        }
        /// <summary>
        /// The name of your product.
        /// </summary>
        public string ProductName
        {
            get { return _productName; }
        }

        /// <summary>
        /// The name of your product.
        /// </summary>
        public string LanguageIndependentName
        {
            get { return _name; }
            set { _name = value; }
        }

        private string GetNonEmptyName(RegistrationContext context)
        {
            string product = LanguageIndependentName;
            if (product != null)
                product = product.Trim();
            if (String.IsNullOrEmpty(product))
                product = context.ComponentType.Name;
            return product;
        }
        /// <summary>
        /// Detailed description of your product.
        /// </summary>
        public string ProductDetails
        {
            get {return _productDetails;}
        }
        /// <summary>
        /// Use IVsInstalledProduct to fill in the Help about dialog.
        /// The package must implement IVsInstalledProduct.
        /// </summary>
        public bool UseInterface
        {
            get {return _useInterface;}
        }
        /// <summary>
        /// True is the product installation will use the package ID
        /// </summary>
        public bool UsePackage {
            get 
            {
                return _usePackage;
            }
        }
        #endregion

        private string RegKeyName (RegistrationContext context)
        {
            return string.Format(CultureInfo.InvariantCulture, "InstalledProducts\\{0}", GetNonEmptyName(context));
        }



        /// <summary>
        ///     Called to register this attribute with the given context.
        /// </summary>
        /// <param name="context">
        ///     Contains the location where the registration information should be placed.
        ///     It also contains other information such as the type being registered and path information.
        /// </param>
        public override void Register(RegistrationContext context) 
        {
            if (UseInterface)
            {
                context.Log.WriteLine(SR.GetString(SR.Reg_NotifyInstalledProductInterface));
            }
            else
            {
                context.Log.WriteLine(SR.GetString(SR.Reg_NotifyInstalledProduct, GetNonEmptyName(context), ProductId));
            }

            using (Key packageKey = context.CreateKey(RegKeyName(context)))
            {

                // Set the 'Package' value if necessary
                if (UsePackage)
                {
                    packageKey.SetValue("Package", context.ComponentType.GUID.ToString("B"));
                }

                // Set the 'UseRegNameAsSplashName' flag if the user provided a short name that should be used on the splash screen
                if (!String.IsNullOrEmpty(_name))
                {
                    packageKey.SetValue("UseRegNameAsSplashName", 1);
                }

                // Set the 'UseInterface' value if necessary
                if (UseInterface)
                {
                    packageKey.SetValue("UseInterface", 1);
                }
                else
                {
                    // If UseInterface is 0, then the following are required for HelpAbout
                    packageKey.SetValue("", ProductName);
                    packageKey.SetValue("ProductDetails", ProductDetails);
                    packageKey.SetValue("PID", ProductId);

                    // The icon resource id reg entry is only valid if there 
                    // is a package satellite and not using the interface
                    if (UsePackage && !String.IsNullOrEmpty(_iconResourceId))
                    {
                        packageKey.SetValue("LogoID", _iconResourceId);
                    }
                }
            }
        }

        /// <summary>
        /// Unregister this InstalledProducts entry.
        /// </summary>
        /// <param name="context"></param>
        public override void Unregister(RegistrationContext context) 
        {
            context.RemoveKey(RegKeyName(context));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\DialogContainerWithToolbar.cs ===
//------------------------------------------------------------------------------
// <copyright file="WindowPane.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell.Interop;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Windows.Forms;
using System.Security.Permissions;

using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
using IServiceProvider = System.IServiceProvider;
using IMessageFilter = System.Windows.Forms.IMessageFilter;

namespace Microsoft.VisualStudio.Shell {

    /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar"]/*' />
    /// <devdoc>
    /// This class is the base class for forms that need to be displayed as modal dialogs inside VisualStudio.
    /// </devdoc>
    [CLSCompliant(false)]
    public class DialogContainerWithToolbar : Form,
        IVsToolWindowToolbar,
        IServiceProvider,
        IMessageFilter
    {
        /// <devdoc>
        /// This class is used to change the control contained by the form to a
        /// IVsWindowPane. This is expecially needed if the control is a form,
        /// because WinForms will not allow us to make it child of another form.
        /// </devdoc>
        private class WindowPaneAdapter : WindowPane
        {
            private Control control;
            private DialogContainerWithToolbar container;
            private IntPtr paneHwnd;

            private int left;
            private int top;
            private int height;
            private int width;

            public WindowPaneAdapter(DialogContainerWithToolbar container, Control control) :
                base ((IServiceProvider)container)
            {
                this.container = container;
                this.paneHwnd = IntPtr.Zero;
                this.control = control;
            }

            protected override void Dispose(bool disposing)
            {
                if (disposing)
                {
                    if (null != control)
                    {
                        control.Dispose();
                        control = null;
                    }
                    paneHwnd = IntPtr.Zero;
                }
                base.Dispose(disposing);
            }

            public IntPtr Handle
            {
                get { return paneHwnd; }
            }

            public void Focus()
            {
                control.Focus();
            }

            // Create the pane at the specific coordinates.
            public void Create(int left, int top, int height, int width)
            {
                // Check if the pane was created before.
                if (IntPtr.Zero != paneHwnd)
                    throw new InvalidOperationException();

                // Create the object.
                NativeMethods.ThrowOnFailure(
                    ((IVsWindowPane)this).CreatePaneWindow(container.Handle, left, top, width, height, out paneHwnd));

                // Store the coordinates
                this.left = left;
                this.top = top;
                this.height = height;
                this.width = width;
            }

            // Returns the IWin32Window interface (used to access the handle of the control)
            public override IWin32Window Window
            {
                get { return (IWin32Window)control;  }
            }

            // Move the the pane to the specific coordinates.
            public void Move(int left, int top, int height, int width)
            {
                if (IntPtr.Zero == Handle)
                    return;

                bool result = UnsafeNativeMethods.SetWindowPos(
                                Handle, 
                                IntPtr.Zero, 
                                left, 
                                top,
                                width,
                                height,
                                NativeMethods.SWP_NOZORDER | NativeMethods.SWP_NOACTIVATE);

                if ( !result)
                    throw new Exception();

                this.left = left;
                this.top = top;
                this.height = height;
                this.width = width;
            }

            public int Left
            {
                get { return left; }
            }

            public int Top
            {
                get { return top; }
            }

            public int Height
            {
                get { return height; }
            }

            public int Width
            {
                get { return width; }
            }
        }

        private class ShowDialogContainer : Container
        {
            private IServiceProvider provider;
            public ShowDialogContainer(IServiceProvider sp)
            {
                provider = sp;
            }

            protected override object GetService(Type serviceType)
            {
                if (provider != null)
                {
                    object service = provider.GetService(serviceType);
                    if (null != service)
                        return service;
                }
                return base.GetService(serviceType);
            }
        }

        // Variables to handle the contained control
        private WindowPaneAdapter containedForm;
        private System.Drawing.Size controlSize;

        // Toolbar handling
        private IVsToolWindowToolbarHost toolbarHost;
        private RECT toolbarRect;
        private CommandID toolbarCommandId;
        private VSTWT_LOCATION toolbarLocation;

        // Services
        private IServiceProvider provider;
        private OleMenuCommandService commandService;
        private uint commandTargetCookie;

        /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar.DialogContainerWithToolbar"]/*' />
        /// <devdoc>
        /// Constructor of the DialogContainerWithToolbar. This constructor allow the caller to set a IServiceProvider,
        /// the conatined control and an additional IOleCommandTarget implementation that will be chained to the one
        /// implemented by OleMenuCommandTarget.
        /// </devdoc>
        public DialogContainerWithToolbar(IServiceProvider sp, Control contained, IOleCommandTarget parentCommandTarget)
        {
            if (null == contained)
                throw new ArgumentNullException("contained");

            if (null == sp)
                throw new ArgumentNullException("sp");

            PrivateInit(sp, contained, parentCommandTarget);
        }

        /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar.DialogContainerWithToolbar1"]/*' />
        /// <devdoc>
        /// Constructor of the DialogContainerWithToolbar. This constructor allow the caller to set a IServiceProvider and
        /// the conatined control.
        /// </devdoc>
        public DialogContainerWithToolbar(IServiceProvider sp, Control contained)
        {
            if (null == contained)
                throw new ArgumentNullException("contained");

            if (null == sp)
                throw new ArgumentNullException("sp");

            IOleCommandTarget parentTarget = contained as IOleCommandTarget;
            PrivateInit(sp, contained, parentTarget);
        }

        /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar.DialogContainerWithToolbar2"]/*' />
        /// <devdoc>
        /// Constructor of the DialogContainerWithToolbar. This constructor allow the caller to set a IServiceProvider.
        /// </devdoc>
        public DialogContainerWithToolbar(IServiceProvider sp)
        {
            if (null == sp)
                throw new ArgumentNullException("sp");

            PrivateInit(sp, null, null);
        }

        /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar.DialogContainerWithToolbar3"]/*' />
        /// <devdoc>
        /// Constructor of the DialogContainerWithToolbar.
        /// </devdoc>
        public DialogContainerWithToolbar()
        {
            PrivateInit(null, null, null);
        }

        private void RegisterCommandTarget()
        {
            if (null == provider)
                throw new InvalidOperationException();

            IVsRegisterPriorityCommandTarget registerCommandTarget = (IVsRegisterPriorityCommandTarget)provider.GetService(typeof(SVsRegisterPriorityCommandTarget));
            if (null != registerCommandTarget)
                NativeMethods.ThrowOnFailure(
                    registerCommandTarget.RegisterPriorityCommandTarget(
                        0,
                        (IOleCommandTarget)commandService,
                        out commandTargetCookie));
        }

        private void PrivateInit(IServiceProvider sp, Control contained, IOleCommandTarget parentTarget)
        {
            provider = sp;

            commandTargetCookie = 0;
            if (null == parentTarget)
            {
                commandService = new OleMenuCommandService(sp);
            }
            else
            {
                commandService = new OleMenuCommandService(sp, parentTarget);
            }
            if (null != sp)
            {
                // Now we have to register the IOleCommandTarget implemented by the OleCommandService
                // as a priority command target, so it will be called by the shell.
                RegisterCommandTarget();
            }

            // Set the defaults for the toolbar (empty toolbar placed at the top)
            toolbarRect.left = 0;
            toolbarRect.top = 0;
            toolbarRect.right = 0;
            toolbarRect.bottom = 0;
            toolbarCommandId = null;
            toolbarLocation = VSTWT_LOCATION.VSTWT_TOP;

            if (null == contained)
            {
                containedForm = null;
            }
            else
            {
                controlSize = contained.ClientSize;
                containedForm = new WindowPaneAdapter(this, contained);
                this.Site = contained.Site;
                Form innerForm = contained as Form;
                if (null != innerForm)
                {
                    // If the contained control is a form, then copy some
                    // of its property to this one.
                    this.AcceptButton = innerForm.AcceptButton;
                    this.AccessibleDefaultActionDescription = innerForm.AccessibleDefaultActionDescription;
                    this.AccessibleDescription = innerForm.AccessibleDescription;
                    this.AccessibleName = innerForm.AccessibleName;
                    this.AccessibleRole = innerForm.AccessibleRole;
                    this.AllowDrop = innerForm.AllowDrop;
                    this.AllowTransparency = innerForm.AllowTransparency;
                    this.AutoScaleDimensions = innerForm.AutoScaleDimensions;
                    this.AutoScaleMode = innerForm.AutoScaleMode;
                    this.AutoScroll = innerForm.AutoScroll;
                    this.AutoScrollMargin = innerForm.AutoScrollMargin;
                    this.AutoScrollMinSize = innerForm.AutoScrollMinSize;
                    this.AutoScrollPosition = innerForm.AutoScrollPosition;
                    this.BindingContext = innerForm.BindingContext;
                    this.Bounds = innerForm.Bounds;
                    this.CancelButton = innerForm.CancelButton;
                    this.ContextMenu = innerForm.ContextMenu;
                    this.ControlBox = innerForm.ControlBox;
                    this.Cursor = innerForm.Cursor;
                    this.DesktopBounds = innerForm.DesktopBounds;
                    this.DesktopLocation = innerForm.DesktopLocation;
                    this.Font = innerForm.Font;
                    this.FormBorderStyle = innerForm.FormBorderStyle;
                    this.Icon = innerForm.Icon;
                    this.IsAccessible = innerForm.IsAccessible;
                    this.MaximizeBox = innerForm.MaximizeBox;
                    this.MaximumSize = innerForm.MaximumSize;
                    this.Menu = innerForm.Menu;
                    this.MinimizeBox = innerForm.MinimizeBox;
                    this.MinimumSize = innerForm.MinimumSize;
                    this.Opacity = innerForm.Opacity;
                    this.Region = innerForm.Region;
                    this.RightToLeft = innerForm.RightToLeft;
                    this.ShowInTaskbar = innerForm.ShowInTaskbar;
                    this.SizeGripStyle = innerForm.SizeGripStyle;
                    this.StartPosition = innerForm.StartPosition;
                    this.Text = innerForm.Text;
                    this.TopLevel = innerForm.TopLevel;
                    this.TopMost = innerForm.TopMost;
                    this.TransparencyKey = innerForm.TransparencyKey;
                }
            }
            // At the end of the copy we have to set the properties that we want
            // to enforse (right now only the HelpButton on the command bar).
            this.HelpButton = true;

            // Set the callbacks for the events that this default implementation will handle.
            this.Load += new EventHandler(FormLoad);
            this.Closing += new System.ComponentModel.CancelEventHandler(OnClosing);
        }

        /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar.SetSite"]/*' />
        /// <devdoc>
        /// Set the site for this window.
        /// </devdoc>
        public void SetSite(IServiceProvider sp)
        {
            if (null != provider)
                throw new InvalidOperationException();

            provider = sp;
            RegisterCommandTarget();
        }

        /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar.Dispose"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                // Make sure that all the resources are closed.
                OnClosing(this, new System.ComponentModel.CancelEventArgs());
            }
            base.Dispose(disposing);
        }

        private void OnClosing(object sender, System.ComponentModel.CancelEventArgs e)
        {
            // Close the toolbar host.
            if (null != toolbarHost)
            {
                toolbarHost.Close(0);
                toolbarHost = null;
            }
            // Close and dispose the main pane.
            if (null != containedForm)
            {
                ((IVsWindowPane)containedForm).ClosePane();
                containedForm = null;
            }
            // Check if we are still registered as priority command target
            if ( (0 != commandTargetCookie) && (null != provider) )
            {
                IVsRegisterPriorityCommandTarget registerCommandTarget = GetService(typeof(SVsRegisterPriorityCommandTarget)) as IVsRegisterPriorityCommandTarget;
                if (null != registerCommandTarget)
                    registerCommandTarget.UnregisterPriorityCommandTarget(commandTargetCookie);
                commandTargetCookie = 0;
            }
            if (null != e)
                e.Cancel = false;
        }

        object IServiceProvider.GetService(System.Type serviceType)
        {
            if ( serviceType == typeof(IVsToolWindowToolbar) )
                return this;

            if ( serviceType == typeof(IOleCommandTarget) )
                return commandService;

            if ( (serviceType == typeof(IVsToolWindowToolbarHost)) && (null != ToolbarHost) )
                return ToolbarHost;

            return provider.GetService(serviceType);
        }

        /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar.ToolbarID"]/*' />
        /// <devdoc>
        /// Gets or Sets the CommandID of the toolbar contained in this dialog.
        /// </devdoc>
        public CommandID ToolbarID
        {
            get { return toolbarCommandId; }
            set { toolbarCommandId = value; }
        }

        /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar.ToolbarLocation"]/*' />
        /// <devdoc>
        /// Location of the toolbar (Top, left, right ot bottom).
        /// </devdoc>
        public VSTWT_LOCATION ToolbarLocation
        {
            get { return toolbarLocation; }
            set { toolbarLocation = value; }
        }

        /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar.ToolbarHost"]/*' />
        /// <devdoc>
        /// Gets the IVsToolWindowToolbarHost interface for this window.
        /// </devdoc>
        public IVsToolWindowToolbarHost ToolbarHost
        {
            get
            {
                // Check if there is a cached pointer to the interface.
                if (null != toolbarHost)
                    return toolbarHost;

                // If no cached version exist, we have to get a new one
                // from the UIShell service.
                IVsUIShell uiShell = (IVsUIShell)provider.GetService(typeof(SVsUIShell));
                NativeMethods.ThrowOnFailure(
                    uiShell.SetupToolbar(Handle, (IVsToolWindowToolbar)this, out toolbarHost));
                return toolbarHost;
            }
        }

        /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar.CommandService"]/*' />
        /// <devdoc>
        /// Returns the command service used to check the status or execute
        /// the toolbar's commands.
        /// </devdoc>
        public IMenuCommandService CommandService
        {
            get { return commandService as IMenuCommandService; }
        }

        int IVsToolWindowToolbar.GetBorder(RECT[] rect)
        {
            // Check that the parameter is correct.
            if ((null == rect) || (rect.Length != 1))
                throw new ArgumentException("rect");

            // Return the client area of this form.
            rect[0].left = 0;
            rect[0].top = 0;
            rect[0].right = this.ClientSize.Width;
            rect[0].bottom = this.ClientSize.Height;

            return NativeMethods.S_OK;
        }

        int IVsToolWindowToolbar.SetBorderSpace(RECT[] rect)
        {
            // Check input parameter.
            if ((null == rect) || (rect.Length != 1))
                throw new ArgumentException("rect");

            // Store the toolbar informations and resize the main pane to leave room
            // for the commandbar.
            toolbarRect = rect[0];
            ResizePane();

            return NativeMethods.S_OK;
        }

        [EnvironmentPermission(SecurityAction.LinkDemand)]
        bool IMessageFilter.PreFilterMessage(ref Message m)
        {
            if (null != ToolbarHost)
            {
                int lResult;
                int hr = ToolbarHost.ProcessMouseActivationModal(m.HWnd,(uint)m.Msg, (uint)m.WParam, (int)m.LParam, out lResult);
                // Check for errors.
                if ( NativeMethods.Failed(hr) )
                    return false;
                // ProcessMouseActivationModal returns S_FALSE to stop the message processing, but this
                // function have to return true in this case.
                return (hr==NativeMethods.S_FALSE);
            }

            return false;
        }

        /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar.ShowDialog"]/*' />
        /// <devdoc>
        /// Show this window as modal dialog.
        /// </devdoc>
        public new DialogResult ShowDialog()
        {
            // if we don't have a service provider we can not show the dialog correctly
            if (null == provider)
                throw new InvalidOperationException();

            DialogResult result;
            IMessageFilter filter = this as IMessageFilter;

            // Make sure that there is non visual containment for this form
            ShowDialogContainer dialogContainer = null;
            if (this.Site == null)
            {
                dialogContainer = new ShowDialogContainer((IServiceProvider)this);
                dialogContainer.Add(this);
            }

            try
            {
                // This form needs to install its message filter in order to
                // let the toolbar process the mouse events.
                Application.AddMessageFilter(filter);

                // Show the modal dialog
                result = base.ShowDialog();
            }
            finally
            {
                if (dialogContainer != null)
                    dialogContainer.Remove(this);
                Application.RemoveMessageFilter(filter);
            }

            return result;
        }

        private void ResizePane()
        {
            // Get the size of the window.
            System.Drawing.Size mySize = this.ClientSize;

            // toolbarRect is not a real rectangle, it store the space that we have
            // to free at the left, top, right and bottom of this form for the toolbar.
            // So we have to move the main pane out of the way.
            int x = toolbarRect.left;
            int y = toolbarRect.top;
            int width = mySize.Width - toolbarRect.left - toolbarRect.right;
            int height = mySize.Height - toolbarRect.top - toolbarRect.bottom;

            containedForm.Move(x, y, height, width);
        }

        private void ResizeForm(object sender, EventArgs e)
        {
            ResizePane();
            if (ToolbarHost != null)
                ToolbarHost.BorderChanged();
        }

        private void FormLoad(object sender, EventArgs e)
        {
            if (this.DesignMode)
                return;

            if (null == containedForm)
            {
                // Handle the case that the class was constructed with the parameterless
                // constructor, so no container control is created.
                // In this case we have to create a new control that will contain all the
                // controls contained by this form and use it to create the window pane.
                Control paneControl = new UserControl();
                while (this.Controls.Count > 0)
                {
                    Control ctl = this.Controls[0];
                    ctl.Parent = paneControl;
                }
                containedForm = new WindowPaneAdapter(this, paneControl);
                controlSize = this.ClientSize;
            }

            System.Drawing.Size mySize = this.ClientSize;

            // Check if this window has a toolbar.
            if (null != toolbarCommandId)
            {
                Guid toolbarCommandSet = toolbarCommandId.Guid;
                NativeMethods.ThrowOnFailure(
                    ToolbarHost.AddToolbar(toolbarLocation, ref toolbarCommandSet, (uint)toolbarCommandId.ID));
                NativeMethods.ThrowOnFailure(ToolbarHost.Show(0));
                NativeMethods.ThrowOnFailure(ToolbarHost.ForceUpdateUI());
            }

            // Now we have to resize the form to make room for the toolbar.
            mySize.Width = controlSize.Width + toolbarRect.left + toolbarRect.right;
            mySize.Height = controlSize.Height + toolbarRect.top + toolbarRect.bottom;
            this.ClientSize = mySize;

            // Find the coordinate of the main pane.
            int x = toolbarRect.left;
            int y = toolbarRect.top;
            int width = mySize.Width - toolbarRect.left - toolbarRect.right;
            int height = mySize.Height - toolbarRect.top - toolbarRect.bottom;

            // Make sure that the pane is created.
            containedForm.Create(x, y, height, width);
            // Set the focus to the control
            containedForm.Focus();

            // Install the handler for the resize.
            this.Resize += new EventHandler(ResizeForm);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\DialogPage.cs ===
//------------------------------------------------------------------------------
// <copyright file="DialogPage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell.Interop;
    using System.Windows.Forms.Design;
    using Microsoft.Win32;
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing;
    using System.Runtime.InteropServices;
    using System.Windows.Forms;

    using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
    using IServiceProvider = System.IServiceProvider;

    /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage"]' />
    /// <devdoc>
    ///     DialogPage encompasses a tools dialog page.  The default dialog page 
    ///     examines itself for public properties, and offers these properties 
    ///     to the user in a property grid.  You can customize this behavior, 
    ///     however by overriding various methods on the page.  The dialog 
    ///     page will automatically persist any changes made to it to the user's 
    ///     section of the registry, provided that those properties provide 
    ///     support for to/from string conversions on their type converter.
    /// </devdoc>
    [CLSCompliant(false),ComVisible(true)]
    public class DialogPage : Component,
        IWin32Window,
        IProfileManager {

        private IWin32Window     _window;
        private DialogSubclass   _subclass;
        private DialogContainer _container;
        private string           _settingsPath;
        private bool             _initializing = false;
        private bool             _uiActive = false;
        private bool             _propertyChangedHooked = false;
        private EventHandler     _onPropertyChanged;

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.DialogPage"]' />
        /// <devdoc>
        /// Constructs the Dialog Page.
        /// </devdoc>
        public DialogPage() {
            HookProperties(true);
        }

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.AutomationObject"]' />
        /// <devdoc>
        ///     The object the dialog page is going to browse.  The
        ///     default returns "this", but you can change it to
        ///     browse any object you want.
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public virtual object AutomationObject {
            get {
                return this;
            }
        }
        
        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage".Site]' />
        /// <devdoc>
        ///     Override for the site property.  This override is used so we can
        ///     load and save our settings at the appropriate time.
        /// </devdoc>
        public override ISite Site {
            get {
                return base.Site;
                
            }
            set {
                if (value == null && base.Site != null) {
                    // This is dangerous at shut down time and is causing
                    // bad ExecutionEngineExceptions. It's also entirely redundant.
                    //SaveSettingsToStorage();
                }

                base.Site = value;

                if (value != null) {
                    LoadSettingsFromStorage();
                }
            }
        }
        
        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage".Window]' />
        /// <devdoc>
        ///     The window this dialog page will use for its UI.
        ///     This window handle must be constant, so if you are
        ///     returning a Windows Forms control you must make sure
        ///     it does not recreate its handle.  If the window object
        ///     implements IComponent it will be sited by the 
        ///     dialog page so it can get access to global services.
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        protected virtual IWin32Window Window {
            get {
                PropertyGrid grid = new PropertyGrid();
                grid.Location = new Point(0,0);
                grid.ToolbarVisible = false;
                grid.CommandsVisibleIfAvailable = false;
                grid.SelectedObject = AutomationObject;
                return grid;
            }
        }
        
        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.Dispose"]' />
        /// <devdoc>
        ///     Disposes this object.
        /// </devdoc>
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {

                if (_container != null)
                {
                    try
                    {
                        _container.Dispose();
                    }
                    catch (Exception)
                    {
                        Debug.Fail("Failed to dispose container");
                    }
                    _container = null;
                }

                if (_window != null && _window is IDisposable)
                {
                    try
                    {
                    ((IDisposable)_window).Dispose();
                    }
                    catch (Exception)
                    {
                        Debug.Fail("Failed to dispose window");
                    }
                    _window = null;
                }

                if (_subclass != null)
                {
                    _subclass = null;
                }

                HookProperties(false);
            }
            base.Dispose(disposing);
        }
        
        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.LoadSettingsFromStorage"]' />
        /// <devdoc>
        ///     This method is called when the dialog page should load
        ///     its default settings from the registry.  The default
        ///     implementation gets the Package service, gets the
        ///     user registry key, and reads in all properties for this
        ///     page that could be converted from strings.
        /// </devdoc>
        public virtual void LoadSettingsFromStorage() {
            _initializing = true;
            try {
                Package package = (Package)GetService(typeof(Package));
                Debug.Assert(package != null, "No package service; we cannot load settings");
                if (package != null) {
                    using (RegistryKey rootKey = package.UserRegistryRoot) {

                        string path = this.SettingsRegistryPath;
                        object automationObject = this.AutomationObject;

                        RegistryKey key = rootKey.OpenSubKey(path, false /* writable */);
                        if (key != null) {
                            using (key) {

                                string[] valueNames = key.GetValueNames();
                                PropertyDescriptorCollection properties = TypeDescriptor.GetProperties(automationObject);

                                foreach(string valueName in valueNames) {
                                    string value = key.GetValue(valueName).ToString();

                                    PropertyDescriptor prop = properties[valueName];
                                    if (prop != null && prop.Converter.CanConvertFrom(typeof(string))) {
                                        prop.SetValue(automationObject, prop.Converter.ConvertFromInvariantString(value));
                                    }
                                }
                            }
                        }
                    }
                }
            }
            finally {
                _initializing = false;
            }
            HookProperties(true); //hook if this failed during construction.
        }

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.LoadSettingsFromXml"]' />
        /// <devdoc>
        ///     This method is called when the dialog page should load
        ///     its default settings from the profile XML file.  
        /// </devdoc>
        public virtual void LoadSettingsFromXml(IVsSettingsReader reader) {
            _initializing = true;
            try {
                object automationObject = this.AutomationObject;
                PropertyDescriptorCollection properties = TypeDescriptor.GetProperties(automationObject, new Attribute[] {DesignerSerializationVisibilityAttribute.Visible});

                foreach(PropertyDescriptor property in properties) {
                    TypeConverter converter = property.Converter;
                    if (converter.CanConvertTo(typeof(string)) && converter.CanConvertFrom(typeof(string))) {
                        // read from the xml feed
                        string value = null;
                        object cv = null;
                        try {
                            if ( NativeMethods.Succeeded(reader.ReadSettingString(property.Name, out value)) && (value != null) )
                            {
                                cv = property.Converter.ConvertFromInvariantString(value);
                            }
                        } catch (Exception) {
                            // ReadSettingString throws an exception if the property 
                            // is not found and we also catch ConvertFromInvariantString
                            // exceptions so that we gracefully handle bad vssettings.
                        }
                        //not all values have to be present
                        if (cv != null) { 
                            property.SetValue(automationObject, cv);
                        }
                    }
                }
            }
            finally {
                _initializing = false;    //we have loaded from storage
            }
            HookProperties(true); //hook if this failed during construction.
        }

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.ResetSettings"]' />
        /// <devdoc>Override this method in order to reset your settings to your default values.</devdoc>
        public virtual void ResetSettings() {
        }

        /// <devdoc>
        /// This function hooks property change events so that we automatically serialize
        /// if the value changes outside of UI and loading
        /// </devdoc>
        private void HookProperties(bool hook) {
            if (_propertyChangedHooked != hook)  {
                
                if (_onPropertyChanged == null)
                    _onPropertyChanged = new EventHandler(OnPropertyChanged);

                object automationObject = null;
                try
                {
                    automationObject = this.AutomationObject;
                }
                catch (Exception e)
                {
                    Debug.Fail(e.ToString());  //assert this so we don't ship bad code.
                }
                catch
                {
                    Debug.Fail("Non-CLSCompliant exception");  //assert this so we don't ship bad code.
                }

                if (automationObject!= null)  {
                    PropertyDescriptorCollection properties = TypeDescriptor.GetProperties(automationObject, new Attribute[] {DesignerSerializationVisibilityAttribute.Visible});

                    foreach(PropertyDescriptor property in properties) {
                        if (hook) 
                            property.AddValueChanged(automationObject, _onPropertyChanged);
                        else
                            property.RemoveValueChanged(automationObject, _onPropertyChanged);
                    }
                    _propertyChangedHooked = hook;
                }
            }
        }

        // Convert an item property value changed event into a list changed event
        private void OnPropertyChanged(object sender, EventArgs e)  {
            if (!_initializing && !_uiActive)
                SaveSettingsToStorage();
        }

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.OnActivate"]' />
        /// <devdoc>
        ///     This method is called when VS wants to activate this
        ///     page.  If true is returned, the page is activated.
        /// </devdoc>
        protected virtual void OnActivate(CancelEventArgs e) {
            _uiActive = true;
        }
        
        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.OnClosed"]' />
        /// <devdoc>
        ///     This event is raised when the page is closed.   
        /// </devdoc>
        protected virtual void OnClosed(EventArgs e) {
            _uiActive = false;
            LoadSettingsFromStorage(); //reload whatever is saved in storage so if someone is accessing this object, it will have the correct values.
        }

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.OnDeactivate"]' />
        /// <devdoc>
        ///     This method is called when VS wants to deatviate this
        ///     page.  If true is returned, the page is deactivated.
        /// </devdoc>
        protected virtual void OnDeactivate(CancelEventArgs e) {
        }

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.OnApply"]' />
        /// <devdoc>
        ///     This method is called when VS wants to save the user's 
        ///     changes then the dialog is dismissed.
        /// </devdoc>
        protected virtual void OnApply(PageApplyEventArgs e) {
            SaveSettingsToStorage();
        }

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.SaveSettingsToStorage"]' />
        /// <devdoc>
        ///     This method does the reverse of LoadSettingsFromStorage.
        /// </devdoc>
        public virtual void SaveSettingsToStorage() {
            Package package = (Package)GetService(typeof(Package));
            Debug.Assert(package != null, "No package service; we cannot load settings");
            if (package != null) {
                using (RegistryKey rootKey = package.UserRegistryRoot) {

                    string path = SettingsRegistryPath;
                    object automationObject = this.AutomationObject;
                    RegistryKey key = rootKey.OpenSubKey(path, true /* writable */);
                    if (key == null) {
                        key = rootKey.CreateSubKey(path);
                    }

                    using (key) {

                        PropertyDescriptorCollection properties = TypeDescriptor.GetProperties(automationObject, new Attribute[] { DesignerSerializationVisibilityAttribute.Visible });

                        foreach(PropertyDescriptor property in properties) {
                            TypeConverter converter = property.Converter;
                            if (converter.CanConvertTo(typeof(string)) && converter.CanConvertFrom(typeof(string))) {
                                key.SetValue(property.Name, converter.ConvertToInvariantString(property.GetValue(automationObject)));
                            }
                        }
                    }
                }
            }
        }

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.SaveSettingsToXml"]' />
        /// <devdoc>
        ///     This method does the reverse of LoadSettingsFromXml.
        /// </devdoc>
        public virtual void SaveSettingsToXml(IVsSettingsWriter writer) {
            object automationObject = this.AutomationObject;
            PropertyDescriptorCollection properties = TypeDescriptor.GetProperties(automationObject, new Attribute[] {DesignerSerializationVisibilityAttribute.Visible});
            // [clovett] Sort the names so that tests can depend on the order returned, otherwise the order changes
            // randomly based on some internal hashtable seed.  Besides it makes it easier for the user to
            // read the .vssettings files.
            ArrayList sortedNames = new ArrayList();
            foreach (PropertyDescriptor property in properties) {
                sortedNames.Add(property.Name);
            }
            sortedNames.Sort();
            foreach(string name in sortedNames) {
                PropertyDescriptor property = properties[name];
                TypeConverter converter = property.Converter;
                if (converter.CanConvertTo(typeof(string)) && converter.CanConvertFrom(typeof(string))) {
                    NativeMethods.ThrowOnFailure(
                        writer.WriteSettingString(property.Name, converter.ConvertToInvariantString(property.GetValue(automationObject)))
                    );
                }
            }
        }

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.SettingsRegistryPath"]' />
        /// <devdoc>
        /// This is where the settings are stored under [UserRegistryRoot]\DialogPage, the default
        /// is the full type name of your AutomationObject.
        /// </devdoc>
        protected string SettingsRegistryPath {
            get {
                if (this._settingsPath == null) {
                    this._settingsPath = "DialogPage\\" + this.AutomationObject.GetType().FullName;
                }
                return this._settingsPath;
            }
            set {
                this._settingsPath = value;
            }
        }

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.IWin32Window.Handle"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IWin32Window implementation.  This just delegates to the Window property.
        /// </devdoc>
        IntPtr IWin32Window.Handle {
            get {

                if (_window == null) {
                    _window = Window;
                    if (_window is IComponent) {
                        if (_container == null) {
                            _container = new DialogContainer(Site);
                        }
                        _container.Add((IComponent)_window);
                    }
                    if (_subclass == null) {
                        _subclass = new DialogSubclass(this);
                    }
                }

                if (_subclass.Handle != _window.Handle) {
                    _subclass.AssignHandle(_window.Handle);
                }

                return _window.Handle;
            }
        }

        internal void ResetContainer() {
            if (_container != null && _window is IComponent) {
                // This resets the AmbientProperties.
                _container._ambientProperties = null;
                _container.Remove((IComponent)_window);                
                _container.Add((IComponent)_window);
            }
        }

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.ApplyKind"]/*' />
        /// <devdoc>
        /// Apply behavior.  Allows the OnApply event to be canceled with optional navigation instructions.
        /// </devdoc>
        public enum ApplyKind { 
            /// <summary>
            /// Apply - Allows the changes to be applied
            /// </summary>
            Apply = 0, 

            /// <summary>
            /// CancelNavigate - Cancels the apply event and navigates to the page cancelling the event.
            /// </summary>
            Cancel = 1, 
            
            /// <summary>
            /// CancelNoNavigate - Cancels the apply event and returns the active page, not the page cancelling the event.
            /// </summary>
            CancelNoNavigate = 2 
        };

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.PageApplyEventArgs"]/*' />
        /// <devdoc>
        /// Event arguments to allow the OnApply method to indicate how to handle the apply event.
        /// </devdoc>
        protected class PageApplyEventArgs : EventArgs
        {
            private ApplyKind _apply = ApplyKind.Apply;

            /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.AutomationObject.ApplyBehavior"]' />
            public ApplyKind ApplyBehavior
            {
                get
                {
                    return _apply;
                }
                set
                {
                    _apply = value;
                }
            }
        }

        /// <devdoc>
        ///     This class derives from container to provide a service provider
        ///     connection to the dialog page.
        /// </devdoc>
        private sealed class DialogContainer : Container {

            private IServiceProvider _provider;
            internal AmbientProperties _ambientProperties;

            /// <devdoc>
            ///     Creates a new container using the given service provider.
            /// </devdoc>
            public DialogContainer(IServiceProvider provider) {
                _provider = provider;
            }

            /// <devdoc>
            ///     Override to GetService so we can route requests
            ///     to the package's service provider.
            /// </devdoc>
            protected override object GetService(Type serviceType) {
                if (serviceType == null) {
                    throw new ArgumentNullException("serviceType");
                }
                if (serviceType == typeof(AmbientProperties)) {
                    if (_ambientProperties == null) {
                        IUIService uis = GetService(typeof(IUIService)) as IUIService;
                        _ambientProperties = new AmbientProperties();
                        _ambientProperties.Font = (Font)uis.Styles["DialogFont"];
                    }
                    return _ambientProperties;
                }
                if (_provider != null) {
                    object service = _provider.GetService(serviceType);
                    if (service != null) {
                        return service;
                    }
                }
                return base.GetService(serviceType);
            }
        }

        /// <devdoc>
        ///     This class derives from NativeWindow to provide a hook
        ///     into the window handle.  We use this hook so we can
        ///     respond to property sheet window messages that VS
        ///     will send us.
        /// </devdoc>
        private sealed class DialogSubclass : NativeWindow {

            private DialogPage _page;
            private bool       _closeCalled;

            /// <devdoc>
            ///     Create a new DialogSubclass
            /// </devdoc>
            internal DialogSubclass(DialogPage page) {
                _page = page;
                _closeCalled = false;
            }

            /// <devdoc>
            ///     Override for WndProc to handle our PSP messages
            /// </devdoc>
            protected override void WndProc(ref Message m) {

                CancelEventArgs ce;

                switch (m.Msg) { 
                    case NativeMethods.WM_NOTIFY:
                        NativeMethods.NMHDR nmhdr = (NativeMethods.NMHDR)Marshal.PtrToStructure(m.LParam, typeof(NativeMethods.NMHDR));
                        switch (nmhdr.code) {
                            case NativeMethods.PSN_RESET:
                                _closeCalled = true;
                                _page.OnClosed(EventArgs.Empty);
                                return;
                            case NativeMethods.PSN_APPLY:
                                PageApplyEventArgs pae = new PageApplyEventArgs(); 
                                _page.OnApply(pae);
                                switch (pae.ApplyBehavior)
                                {    
                                    case ApplyKind.Cancel:
                                        m.Result = (IntPtr)NativeMethods.PSNRET_INVALID;
                                        break;

                                    case ApplyKind.CancelNoNavigate:
                                        m.Result = (IntPtr)NativeMethods.PSNRET_INVALID_NOCHANGEPAGE;
                                        break;

                                    case ApplyKind.Apply:
                                    default:
                                        m.Result = IntPtr.Zero;
                                        break;
                                }
                                UnsafeNativeMethods.SetWindowLong(m.HWnd, NativeMethods.DWL_MSGRESULT, m.Result);
                                return;
                            case NativeMethods.PSN_KILLACTIVE:
                                ce = new CancelEventArgs();
                                _page.OnDeactivate(ce);
                                m.Result = (IntPtr)(ce.Cancel ? 1 : 0);
                                UnsafeNativeMethods.SetWindowLong(m.HWnd, NativeMethods.DWL_MSGRESULT, m.Result);
                                return;
                            case NativeMethods.PSN_SETACTIVE:
                                _closeCalled = false;
                                ce = new CancelEventArgs();
                                _page.OnActivate(ce);
                                m.Result = (IntPtr)(ce.Cancel ? -1 : 0);
                                UnsafeNativeMethods.SetWindowLong(m.HWnd, NativeMethods.DWL_MSGRESULT, m.Result);
                                return;
                        }
                        break;
                    case NativeMethods.WM_DESTROY:

                        // we can't tell the difference between OK and Apply (see above), so
                        // if we get a destroy and close hasn't been called, make sure we call it
                        //
                        if (!_closeCalled && _page != null) {
                            _page.OnClosed(EventArgs.Empty);
                        }
                        break;
                }

                base.WndProc(ref m);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\LogicalView.cs ===
//------------------------------------------------------------------------------
// <copyright file="LogicalView.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Globalization;

    /// <include file='doc\LogicalView.uex' path='docs/doc[@for="LogicalView"]' />
    /// <devdoc>
    ///     This enum lists the supported logical views.
    /// </devdoc>
    [TypeConverter(typeof(LogicalViewConverter))]
    public enum LogicalView {

    	/// <include file='doc\LogicalView.uex' path='docs/doc[@for="LogicalView.Primary"]/*' />
    	Primary,
    	/// <include file='doc\LogicalView.uex' path='docs/doc[@for="LogicalView.Any"]/*' />
    	Any,
        /// <include file='doc\LogicalView.uex' path='docs/doc[@for="LogicalView.Debugging"]/*' />
        Debugging,
        /// <include file='doc\LogicalView.uex' path='docs/doc[@for="LogicalView.Code"]/*' />
        Code,
        /// <include file='doc\LogicalView.uex' path='docs/doc[@for="LogicalView.Designer"]/*' />
        Designer,
        /// <include file='doc\LogicalView.uex' path='docs/doc[@for="LogicalView.Text"]/*' />
        Text,
        /// <include file='doc\LogicalView.uex' path='docs/doc[@for="LogicalView.UserChoose"]/*' />
        UserChoose,
        /// <include file='doc\LogicalView.uex' path='docs/doc[@for="LogicalView.ProjectSpecific"]/*' />
        ProjectSpecific
    }

    /// <devdoc>
    ///     This type converter inherits from the normal enum
    ///     converter.  It adds the ability to convert to/from
    ///     GUID types.
    /// </devdoc>
    internal class LogicalViewConverter : EnumConverter {

        private Guid[] _guids = new Guid[] {
            new Guid("00000000-0000-0000-0000-000000000000"),
            new Guid("FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF"),
            new Guid("7651A700-06E5-11D1-8EBD-00A0C90F26EA"),
            new Guid("7651A701-06E5-11D1-8EBD-00A0C90F26EA"),
            new Guid("7651A702-06E5-11D1-8EBD-00A0C90F26EA"),
            new Guid("7651A703-06E5-11D1-8EBD-00A0C90F26EA"),
            new Guid("7651A704-06E5-11D1-8EBD-00A0C90F26EA"),
            new Guid("80A3471A-6B87-433E-A75A-9D461DE0645F")
        };

        private LogicalView[] _views = new LogicalView[] {
            LogicalView.Primary,
            LogicalView.Any,
            LogicalView.Debugging,
            LogicalView.Code,
            LogicalView.Designer,
            LogicalView.Text,
            LogicalView.UserChoose,
            LogicalView.ProjectSpecific
        };

        public LogicalViewConverter(Type enumType) : base(enumType) {
            Debug.Assert(_views.Length == _guids.Length, "Mismatch in view / guid relationship");
        }

        /// <devdoc>
        ///     Gets a value indicating whether this converter
        ///     can convert an object in the given source type to an enumeration object using
        ///     the specified context.
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(Guid)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }
        
        /// <devdoc>
        ///     Gets a value indicating whether this converter can
        ///     convert an object to the given destination type using the context.
        /// </devdoc>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(Guid)) {
                return true;
            }
            return base.CanConvertTo(context, destinationType);
        }

        /// <devdoc>
        ///     Converts the specified value object to an enumeration object.
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value is Guid) {
                for (int i = 0; i < _guids.Length; i++) {
                    if (value.Equals(_guids[i])) {
                        return _views[i];
                    }
                }
            }
            return base.ConvertFrom(context, culture, value);
        }
    
        /// <devdoc>
        ///     Converts the given value object to the specified destination type.
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(Guid) && value != null) {
                for (int i = 0; i < _views.Length; i++) {
                    if (value.Equals(_views[i])) {
                        return _guids[i];
                    }
                }
            }
            
            return base.ConvertTo(context, culture, value, destinationType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\MsiComponentIdAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright from='2003' to='2004' company='Microsoft Corporation'>           
//  Copyright (c) Microsoft Corporation, All rights reserved.             
//  This code sample is provided "AS IS" without warranty of any kind, 
//  it is not recommended for use in a production environment.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;

    /// <summary>
    ///     This attribute defines the MSI component ID that is used by the 
    ///     MSI installer. This component ID is used to indicate the install
    ///     path to this component.  This must be placed on a package class
    ///     if the package is to be installed by MSI.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=false, Inherited=false)]
    public sealed class MsiComponentIdAttribute : Attribute {

        private string _id;
    
        /// <summary>
        ///     Creates a new MsiComponentIdAttribute.
        /// </summary>
        public MsiComponentIdAttribute (string id) {
            if (id == null) {
                throw new ArgumentNullException("id");
            }
            _id = id;
        }
        
        /// <summary>
        ///     Returns the component registration ID.
        /// </summary>
        public string Id {
            get {
                return _id;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\IResxResourceService.cs ===
//------------------------------------------------------------------------------
// <copyright file="ResourcePicker.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    using System.IO;
    using System.Security.Permissions;
    using Microsoft.Win32;
    using System.Collections;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Drawing.Design;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;
    using System.Windows.Forms.ComponentModel;
    using System.Windows.Forms.Design;
    using System.Resources;
    using System.Resources.Tools;
    using System.Globalization;


    /// <include file='doc\IResXResourceService.uex' path='docs/doc[@for="IResXResourceService"]/*' />
    /// <devdoc>
    ///    <para>
    ///         This interface is an abstraction layer that allows various clients to control resxreaders and writers
    ///         that get used within Visual Studio.
    ///    </para>
    /// </devdoc>
    public interface IResXResourceService {

        /// <include file='doc\IResXResourceService.uex' path='docs/doc[@for="GetResXResourceReader"]/*' />
        /// <devdoc>
        ///    <para>
        ///         Returns a resx resource reader given a basepath and name
        ///    </para>
        /// </devdoc>
        IResourceReader GetResXResourceReader(string resXFullName, bool useResXDataNodes);

        /// <include file='doc\IResXResourceService.uex' path='docs/doc[@for="GetResXResourceReader"]/*' />
        /// <devdoc>
        ///    <para>
        ///         Returns a resx resource reader given a basepath and name
        ///    </para>
        /// </devdoc>
        IResourceReader GetResXResourceReader(TextReader textReader, bool useResXDataNodes, string basePath);

        /// <include file='doc\IResXResourceService.uex' path='docs/doc[@for="GetResXResourceWriter"]/*' />
        /// <devdoc>
        ///    <para>
        ///         Returns a resx resource writer given a basepath and name
        ///    </para>
        /// </devdoc>
        IResourceWriter GetResXResourceWriter(string resXFullName);

        /// <include file='doc\IResXResourceService.uex' path='docs/doc[@for="GetResXResourceWriter"]/*' />
        /// <devdoc>
        ///    <para>
        ///         Returns a resx resource writer given a basepath and name
        ///    </para>
        /// </devdoc>
        IResourceWriter GetResXResourceWriter(TextWriter textWriter, string basePath);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\LocalizableProperties.cs ===
//--------------------------------------------------------------------------
//  <copyright file="LocalizableProperties.cs" company="Microsoft">
//      Copyright (c) Microsoft Corporation.  All rights reserved.
//  </copyright>
//  <summary>
//  </summary>
//--------------------------------------------------------------------------
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.Designer.Interfaces;
using System;
using System.Collections;
using System.ComponentModel;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using System.Xml;
using System.Diagnostics;

namespace Microsoft.VisualStudio.Shell
{
    /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties]/*' />
    [ComVisible(true)]
    public class LocalizableProperties : ICustomTypeDescriptor
	{
        #region ICustomTypeDescriptor
        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.GetAttributes]/*' />
        public AttributeCollection GetAttributes() 
		{
            AttributeCollection col = TypeDescriptor.GetAttributes(this, true);
            return col;
        }

        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.GetDefaultEvent]/*' />
        public EventDescriptor GetDefaultEvent() 
		{
            EventDescriptor ed = TypeDescriptor.GetDefaultEvent(this, true);
            return ed;
        }

        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.GetDefaultProperty]/*' />
        public PropertyDescriptor GetDefaultProperty() 
		{
            PropertyDescriptor pd = TypeDescriptor.GetDefaultProperty(this, true);
            return pd;
        }

        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.GetEditor]/*' />
        public object GetEditor(Type editorBaseType) 
		{
            object o = TypeDescriptor.GetEditor(this, editorBaseType, true);
            return o;
        }

        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.GetEvents]/*' />
        public EventDescriptorCollection GetEvents() 
		{
            EventDescriptorCollection edc = TypeDescriptor.GetEvents(this, true);
            return edc;
        }

        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.GetEvents1]/*' />
        public EventDescriptorCollection GetEvents(System.Attribute[] attributes) 
		{
            EventDescriptorCollection edc = TypeDescriptor.GetEvents(this, attributes, true);
            return edc;
        }

        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.GetPropertyOwner]/*' />
        public object GetPropertyOwner(PropertyDescriptor pd) 
		{
            return this;
        }

        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.GetProperties]/*' />
        public PropertyDescriptorCollection GetProperties() 
		{
            PropertyDescriptorCollection pcol = GetProperties(null);
            return pcol;
        }

        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.GetProperties1]/*' />
        public PropertyDescriptorCollection GetProperties(System.Attribute[] attributes) 
		{
            ArrayList newList = new ArrayList();
            PropertyDescriptorCollection props = TypeDescriptor.GetProperties(this, attributes, true);

            for (int i = 0; i < props.Count; i++)
                newList.Add(CreateDesignPropertyDescriptor(props[i]));

            return new PropertyDescriptorCollection((PropertyDescriptor[])newList.ToArray(typeof(PropertyDescriptor)));;
        }

        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.CreateDesignPropertyDescriptor]/*' />
        public virtual DesignPropertyDescriptor CreateDesignPropertyDescriptor(PropertyDescriptor p) 
		{
            return new DesignPropertyDescriptor(p);
        }

        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.GetComponentName]/*' />
        public string GetComponentName() 
		{
            string name = TypeDescriptor.GetComponentName(this, true);
            return name;
        }

        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.GetConverter]/*' />
        public virtual TypeConverter GetConverter() 
		{
            TypeConverter tc = TypeDescriptor.GetConverter(this, true);
            return tc;
        }

        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.GetClassName]/*' />
        public virtual string GetClassName() 
		{
			return this.GetType().FullName;
		}

        #endregion ICustomTypeDescriptor
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\MsiTokenAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="MsiTokenAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;

    /// <include file='doc\MsiTokenAttribute.uex' path='docs/doc[@for="MsiTokenAttribute"]' />
    /// <devdoc>
    ///     This attribute defines a token string for the MSI installer.  RegPkg
    ///     will search for these attributes on a package class to identify custom
    ///     replacement tokens when generating registry scripts for the Microsoft
    ///     Installer.  Possible token names vary, but RegPkg may query for the 
    ///     following tokens:
    ///
    ///     $ComponentPath  : the path to the component.
    ///     SystemFolder    : the path to the OS system folder (%systemroot%\system32)
    ///
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=false)]
    public sealed class MsiTokenAttribute : Attribute {

        private string _name;
        private string _value;
    
        /// <include file='doc\MsiTokenAttribute.uex' path='docs/doc[@for="MsiTokenAttribute.MsiTokenAttribute"]' />
        /// <devdoc>
        ///     Creates a new MsiTokenAttribute.
        /// </devdoc>
        public MsiTokenAttribute (string name, string value) {
            if (name == null) {
                throw new ArgumentNullException("name");
            }

            if (value == null) {
                throw new ArgumentNullException("value");
            }

            _name = name;
            _value = value;
        }
        
        /// <include file='doc\MsiTokenAttribute.uex' path='docs/doc[@for="MsiTokenAttribute.Name"]' />
        /// <devdoc>
        ///     Returns the MSI token name.
        /// </devdoc>
        public string Name {
            get {
                return _name;
            }
        }
        
        /// <include file='doc\MsiTokenAttribute.uex' path='docs/doc[@for="MsiTokenAttribute.Value"]' />
        /// <devdoc>
        ///     Returns the MSI token value.
        /// </devdoc>
        public string Value {
            get {
                return _value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\OleDataObject.cs ===
﻿//------------------------------------------------------------------------------
// <copyright file="VsToolboxService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using Microsoft.VisualStudio.Shell.Ole2Bcl;
using System;
using WinForms = System.Windows.Forms;

using IOleDataObject = Microsoft.VisualStudio.OLE.Interop.IDataObject;
using IComDataObject = System.Runtime.InteropServices.ComTypes.IDataObject;
using IDataObject = System.Windows.Forms.IDataObject;

namespace Microsoft.VisualStudio.Shell
{
    /// <include file='doc\OleDataObject.uex' path='docs/doc[@for=OleDataObject]/*' />
    [CLSCompliant(false)]
    public class OleDataObject : WinForms.DataObject, IOleDataObject
    {
        private IOleDataObject oleData;

        /// <include file='doc\OleDataObject.uex' path='docs/doc[@for=OleDataObject.OleDataObject]/*' />
        public OleDataObject() 
        {
            oleData = (IOleDataObject)(new Ole2BclDataObject(this as IComDataObject));
        }

        /// <include file='doc\OleDataObject.uex' path='docs/doc[@for=OleDataObject.OleDataObject1]/*' />
        public OleDataObject(IDataObject winData) :
            base (winData)
        {
            this.oleData = winData as IOleDataObject;
            if (null == this.oleData)
                oleData = (IOleDataObject)(new Ole2BclDataObject(this as IComDataObject));
        }

        /// <include file='doc\OleDataObject.uex' path='docs/doc[@for=OleDataObject.OleDataObject2]/*' />
        public OleDataObject(IComDataObject comData) :
            base(comData)
        {
            oleData = comData as IOleDataObject;
            if (null == oleData)
                this.oleData = (IOleDataObject)(new Ole2BclDataObject(comData));
        }

        /// <include file='doc\OleDataObject.uex' path='docs/doc[@for=OleDataObject.OleDataObject3]/*' />
        public OleDataObject(IOleDataObject oleData) :
            base( (oleData is IComDataObject) ? (IComDataObject)oleData : (IComDataObject)(new Ole2BclDataObject(oleData)) )
        {
            this.oleData = oleData;
        }

        #region IOleDataObject Members

        int IOleDataObject.DAdvise(Microsoft.VisualStudio.OLE.Interop.FORMATETC[] pFormatetc, uint ADVF, Microsoft.VisualStudio.OLE.Interop.IAdviseSink pAdvSink, out uint pdwConnection)
        {
            return oleData.DAdvise(pFormatetc, ADVF, pAdvSink, out pdwConnection);
        }

        void IOleDataObject.DUnadvise(uint dwConnection)
        {
            oleData.DUnadvise(dwConnection);
        }

        int IOleDataObject.EnumDAdvise(out Microsoft.VisualStudio.OLE.Interop.IEnumSTATDATA ppenumAdvise)
        {
            return oleData.EnumDAdvise(out ppenumAdvise);
        }

        int IOleDataObject.EnumFormatEtc(uint dwDirection, out Microsoft.VisualStudio.OLE.Interop.IEnumFORMATETC ppenumFormatEtc)
        {
            return oleData.EnumFormatEtc(dwDirection, out ppenumFormatEtc);
        }

        int IOleDataObject.GetCanonicalFormatEtc(Microsoft.VisualStudio.OLE.Interop.FORMATETC[] pformatectIn, Microsoft.VisualStudio.OLE.Interop.FORMATETC[] pformatetcOut)
        {
            return oleData.GetCanonicalFormatEtc(pformatectIn, pformatetcOut);
        }

        void IOleDataObject.GetData(Microsoft.VisualStudio.OLE.Interop.FORMATETC[] pformatetcIn, Microsoft.VisualStudio.OLE.Interop.STGMEDIUM[] pRemoteMedium)
        {
            oleData.GetData(pformatetcIn, pRemoteMedium);
        }

        void IOleDataObject.GetDataHere(Microsoft.VisualStudio.OLE.Interop.FORMATETC[] pFormatetc, Microsoft.VisualStudio.OLE.Interop.STGMEDIUM[] pRemoteMedium)
        {
            oleData.GetDataHere(pFormatetc, pRemoteMedium);
        }

        int IOleDataObject.QueryGetData(Microsoft.VisualStudio.OLE.Interop.FORMATETC[] pFormatetc)
        {
            return oleData.QueryGetData(pFormatetc);
        }

        void IOleDataObject.SetData(Microsoft.VisualStudio.OLE.Interop.FORMATETC[] pFormatetc, Microsoft.VisualStudio.OLE.Interop.STGMEDIUM[] pmedium, int fRelease)
        {
            oleData.SetData(pFormatetc, pmedium, fRelease);
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\OleMenuCommandService.cs ===
//------------------------------------------------------------------------------
// <copyright file="OleMenuCommandService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Shell {
    
    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell.Interop;
    using Microsoft.Win32;
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Runtime.InteropServices;

    using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
    using IServiceProvider = System.IServiceProvider;

    /// <include file='doc\OleMenuCommandService.uex' path='docs/doc[@for="OleMenuCommandService"]/*' />
    /// <devdoc>
    ///    
    /// </devdoc>
    [CLSCompliant(false)]
    [System.Runtime.InteropServices.ComVisible(true)]
    public class OleMenuCommandService : System.ComponentModel.Design.MenuCommandService, IOleCommandTarget {

        internal static TraceSwitch MENUSERVICE = new TraceSwitch("MENUSERVICE", "MenuCommandService: Track menu command routing");

        private IOleCommandTarget _parentTarget;
        private IServiceProvider _provider;

        private static uint _queryStatusCount = 0;

        /// <include file='doc\OleMenuCommandService.uex' path='docs/doc[@for="OleMenuCommandService.OleMenuCommandService"]/*' />
        /// <devdoc>
        ///     Creates a new menu command service.
        /// </devdoc>
        public OleMenuCommandService(IServiceProvider serviceProvider) : base(serviceProvider){   
            _provider = serviceProvider;
        }


        /// <include file='doc\OleMenuCommandService.uex' path='docs/doc[@for="OleMenuCommandService.OleMenuCommandService1"]/*' />
        /// <devdoc>
        ///     Creates a new menu command service.
        /// </devdoc>
        public OleMenuCommandService(IServiceProvider serviceProvider, IOleCommandTarget parentCommandTarget) : base(serviceProvider) {
            if (parentCommandTarget == null) {
                throw new ArgumentNullException("parentCommandTarget");
            }
            _parentTarget = parentCommandTarget;
            _provider = serviceProvider;
        }

        /// <include file='doc\OleMenuCommandService.uex' path='docs/doc[@for="OleMenuCommandService.ServiceProvider"]/*' />
        /// <devdoc>
        ///     Returns the service provider.
        /// </devdoc>
        [Obsolete("This method is obsolete and will be removed before the end of M3.2.  Use the proected GetService method instead.")]
        protected IServiceProvider ServiceProvider {
            get {
                return _provider;
            }
        }

        private MenuCommand FindCommand(Guid guid, int id, ref int hrReturn) {
            hrReturn = (int)Microsoft.VisualStudio.OLE.Interop.Constants.OLECMDERR_E_UNKNOWNGROUP;

            MenuCommand result = null;

            //first query the IMenuCommandService and ask it to FindCommand
            IMenuCommandService menuCommandService = GetService(typeof(IMenuCommandService)) as IMenuCommandService;
            if (menuCommandService != null)
            {
            	result = menuCommandService.FindCommand(new CommandID(guid, (int)id));	
            }
            //if the IMenuCommandService cames back w/o a command, then ask ourselves
            if (result == null && this != menuCommandService)
            {
            	result = FindCommand(guid, (int)id);
            }

            if(result == null) {
                ICollection commands = GetCommandList(guid);
                if(commands != null) {                
                    // The default error now must be "Not Supported" because the command group is known
                    hrReturn = (int)Microsoft.VisualStudio.OLE.Interop.Constants.OLECMDERR_E_NOTSUPPORTED;
                    Debug.WriteLineIf(MENUSERVICE.TraceVerbose, "\t...VSMCS Found group");
                    // Get the list of command inside this group
                    foreach (MenuCommand command in commands) {
                        // we are looping again on the list of commands to check the DynamicItemMatch
                        // but this is unavoidable in this context....
                        // If the command is a OleMenuCommand, then we can try to do a dynamic match
                        OleMenuCommand vsCommand = command as OleMenuCommand;
                        if ( (null != vsCommand) && (vsCommand.DynamicItemMatch(id)) )
                        {
                            Debug.WriteLineIf(MENUSERVICE.TraceVerbose, "\t...VSMCS Found command2");
                            hrReturn = NativeMethods.S_OK;
                            result = command;
                        }
                    }            
                }
            }else {
                Debug.WriteLineIf(MENUSERVICE.TraceVerbose, "\t... VSMCS Found command");
                hrReturn = NativeMethods.S_OK;
            }
            return result;
        }


        /// <include file='doc\OleMenuCommandService.uex' path='docs/doc[@for="OleMenuCommandService.GlobalInvoke"]/*' />
        /// <devdoc>
        ///     Invokes a command on the local form or in the global environment.
        ///     The local form is first searched for the given command ID.  If it is
        ///     found, it is invoked.  Otherwise the the command ID is passed to the
        ///     global environment command handler, if one is available.
        /// </devdoc>
        public override bool GlobalInvoke(CommandID commandID) {

            // is it local?
            if(base.GlobalInvoke(commandID)) {
                return true;
            }
            
            // pass it to the global handler
            IVsUIShell uiShellSvc = GetService(typeof(SVsUIShell)) as IVsUIShell;
            if (uiShellSvc != null) {
                Object dummy = null;
                Guid tmpGuid = commandID.Guid;
                if ( NativeMethods.Failed(uiShellSvc.PostExecCommand(ref tmpGuid, (uint)commandID.ID, 0, ref dummy)) )
                    return false;
                return true;
            }
            return false;
        }

        /// <include file='doc\OleMenuCommandService.uex' path='docs/doc[@for="OleMenuCommandService.GlobalInvoke1"]/*' />
        /// <devdoc>
        ///     Invokes a command on the local form or in the global environment.
        ///     The local form is first searched for the given command ID.  If it is
        ///     found, it is invoked.  Otherwise the the command ID is passed to the
        ///     global environment command handler, if one is available.
        /// </devdoc>
        public override bool GlobalInvoke(CommandID commandID, object arg) {

            // is it local?
            if(base.GlobalInvoke(commandID, arg)) {
                return true;
            }

            // pass it to the global handler
            IVsUIShell uiShellSvc = GetService(typeof(SVsUIShell)) as IVsUIShell;
            if (uiShellSvc == null)
                return false;

            Object dummy = arg;
            Guid tmpGuid = commandID.Guid;
            if ( NativeMethods.Failed(uiShellSvc.PostExecCommand(ref tmpGuid, (uint)commandID.ID, 0, ref dummy)) )
                return false;
            return true;
        }

        /// <include file='doc\OleMenuCommandService.uex' path='docs/doc[@for="OleMenuCommandService.OnCommandChanged"]/*' />
        /// <devdoc>
        ///     This is called by a menu command when it's status has changed.
        /// </devdoc>
        protected override void OnCommandsChanged(MenuCommandsChangedEventArgs e) {

            base.OnCommandsChanged(e);

            if (0 == _queryStatusCount) {
                // UpdateCommandUI(0) can not be called inside QueryStatus because this will cause an infinite
                // sequence of calls to QueryStatus during idle time.
                IVsUIShell uiShellSvc = GetService(typeof(SVsUIShell)) as IVsUIShell;
                if (uiShellSvc != null) {
                    NativeMethods.ThrowOnFailure(uiShellSvc.UpdateCommandUI(0));
                }
            }
        }

        /// <include file='doc\OleMenuCommandService.uex' path='docs/doc[@for="OleMenuCommandService.ShowContextMenu"]/*' />
        /// <devdoc>
        ///     Shows the context menu with the given command ID at the given
        ///     location.
        /// </devdoc>
        public override void ShowContextMenu(CommandID menuID, int x, int y) {
            
            IOleComponentUIManager cui = GetService(typeof(NativeMethods.OleComponentUIManager)) as IOleComponentUIManager;
            Debug.Assert(cui != null, "no component UI manager, so we can't display a context menu");
            if (cui != null) {
                POINTS[] pt = new POINTS[] { new POINTS() };
                pt[0].x = (short)x;
                pt[0].y = (short)y;

                Guid tmpGuid = menuID.Guid;
                NativeMethods.ThrowOnFailure( cui.ShowContextMenu(0, ref tmpGuid, menuID.ID, pt, this) );
            }
        }

        private uint HiWord(uint val) {
            return ((val >> 16) & 0xFFFF);
        }
        private uint LoWord(uint val) {
            return (val & 0xFFFF);
        }

        /// <include file='doc\OleMenuCommandService.uex' path='docs/doc[@for="OleMenuCommandService.IOleCommandTarget.Exec"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Executes the given command.
        /// </devdoc>
        int IOleCommandTarget.Exec(ref Guid guidGroup, uint nCmdId, uint nCmdExcept, IntPtr pIn, IntPtr vOut) {
            const uint vsCmdOptQueryParameterList = 1;
            int hr = NativeMethods.S_OK;

            MenuCommand cmd = FindCommand(guidGroup, (int)nCmdId, ref hr);
            // If the command is not supported check if it can be handled by the parent command service
            if ( (cmd== null || !cmd.Supported) && _parentTarget != null) 
            {
                return _parentTarget.Exec(ref guidGroup, nCmdId, nCmdExcept, pIn, vOut);
            }
            else if (cmd != null) {
                // Try to see if the command is a OleMenuCommand.
                OleMenuCommand vsCmd = cmd as OleMenuCommand;
                // Check the execution flags;
                uint loWord = LoWord(nCmdExcept);
                // If the command is not an OleMenuCommand, it can handle only the default
                // execution.
                if (((uint)OLECMDEXECOPT.OLECMDEXECOPT_DODEFAULT != loWord) && (null == vsCmd))
                {
                    return NativeMethods.S_OK;
                }
                object o = null;
                if (pIn != IntPtr.Zero)
                {
                    o = Marshal.GetObjectForNativeVariant(pIn);
                }
                if (null == vsCmd)
                {
                    cmd.Invoke(o);
                }
                else
                {
                    switch (loWord)
                    {
                        // Default execution of the command: call the Invoke method
                        case (uint)OLECMDEXECOPT.OLECMDEXECOPT_DODEFAULT:
                            vsCmd.Invoke(o, vOut);
                            break;

                        case (uint)OLECMDEXECOPT.OLECMDEXECOPT_SHOWHELP:
                            // Check the hi word of the flags to see what kind of help
                            // is needed. We handle only the request for the parameters list.
                            if (vsCmdOptQueryParameterList == HiWord(nCmdExcept) && IntPtr.Zero != vOut)
                            {
                                // In this case vOut is a pointer to a VARIANT that will receive
                                // the parameters description.
                                if (!string.IsNullOrEmpty(vsCmd.ParametersDescription))
                                {
                                    Marshal.GetNativeVariantForObject(vsCmd.ParametersDescription, vOut);
                                }
                            }
                            break;

                        default:
                            break;
                    }
                }
            }

            return hr;

        }

        /// <include file='doc\OleMenuCommandService.uex' path='docs/doc[@for="OleMenuCommandService.IOleCommandTarget.QueryStatus"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Inquires about the status of a command.  A command's status indicates
        /// it's availability on the menu, it's visibility, and it's checked state.
        /// The exception thrown by this method indicates the current command status.
        /// </devdoc>
        int IOleCommandTarget.QueryStatus(ref Guid guidGroup, uint nCmdId, OLECMD[] oleCmd, IntPtr oleText) {
            _queryStatusCount += 1;
            int hr = NativeMethods.S_OK;
            try {
                for (uint i = 0; i < oleCmd.Length && NativeMethods.Succeeded(hr); i++)
                {
                    MenuCommand cmd = FindCommand(guidGroup, (int)oleCmd[i].cmdID, ref hr);

                    oleCmd[i].cmdf = 0;
                    if ((cmd != null) && NativeMethods.Succeeded(hr))
                    {
                        oleCmd[i].cmdf = (uint)cmd.OleStatus;
                    }

                    if ((oleCmd[i].cmdf & (int)NativeMethods.tagOLECMDF.OLECMDF_SUPPORTED) != 0)
                    {
                        // Find if the caller needs the text of the command
                        if (NativeMethods.OLECMDTEXT.GetFlags(oleText) == NativeMethods.OLECMDTEXT.OLECMDTEXTF.OLECMDTEXTF_NAME)
                        {
                            string textToSet = null;
                            if (cmd is DesignerVerb)
                            {
                                textToSet = ((DesignerVerb)cmd).Text;
                            }
                            else if (cmd is OleMenuCommand)
                            {
                                textToSet = ((OleMenuCommand)cmd).Text;
                            }
                            if (null != textToSet)
                            {
                                NativeMethods.OLECMDTEXT.SetText(oleText, textToSet);
                            }
                        }
                    }
                    else if (_parentTarget != null)
                    {
                        // If the command is not supported and this command service has a parent,
                        // ask the parent about the command.
                        OLECMD[] newOleArray = { oleCmd[i] };
                        hr = _parentTarget.QueryStatus(ref guidGroup, 1, newOleArray, oleText);
                        oleCmd[i] = newOleArray[0];
                    }
                    // SBurke, if the flags are zero, the shell prefers
                    // that we return not supported, or else no one else will
                    // get asked
                    //
                    if (oleCmd[i].cmdf == 0) {
                        hr = NativeMethods.OLECMDERR_E_NOTSUPPORTED;
                    }
                }
            }
            finally {
                if (0 < _queryStatusCount)
                    _queryStatusCount -= 1;
            }
            return hr;

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\OleToBCL.cs ===
//------------------------------------------------------------------------------
// <copyright file="VsToolboxService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;

using OleInterop = Microsoft.VisualStudio.OLE.Interop;
using BclComTypes = System.Runtime.InteropServices.ComTypes;

using IOleAdviseSink = Microsoft.VisualStudio.OLE.Interop.IAdviseSink;
using IBclAdviseSink = System.Runtime.InteropServices.ComTypes.IAdviseSink;

namespace Microsoft.VisualStudio.Shell.Ole2Bcl
{
    internal sealed class StructConverter
    {
        // Private constructor to avoid creation of instances of this class
        private StructConverter() { }

        ///////////////////////////////////////////////////////////////////////////////////
        // FORMATETC
        static internal OleInterop.FORMATETC BclFormatETC2Ole(ref BclComTypes.FORMATETC bclFormat)
        {
            OleInterop.FORMATETC oleFormat;
            oleFormat.cfFormat = (ushort)bclFormat.cfFormat;
            oleFormat.dwAspect = (uint)bclFormat.dwAspect;
            oleFormat.lindex = bclFormat.lindex;
            oleFormat.ptd = bclFormat.ptd;
            oleFormat.tymed = (uint)bclFormat.tymed;
            return oleFormat;
        }
        static internal BclComTypes.FORMATETC OleFormatETC2Bcl(ref OleInterop.FORMATETC oleFormat)
        {
            BclComTypes.FORMATETC bclFormat;
            bclFormat.cfFormat = (short)oleFormat.cfFormat;
            bclFormat.dwAspect = (BclComTypes.DVASPECT)oleFormat.dwAspect;
            bclFormat.lindex = oleFormat.lindex;
            bclFormat.ptd = oleFormat.ptd;
            bclFormat.tymed = (BclComTypes.TYMED)oleFormat.tymed;
            return bclFormat;
        }
        //                                                                       FORMATETC
        ///////////////////////////////////////////////////////////////////////////////////

        ///////////////////////////////////////////////////////////////////////////////////
        // STGMEDIUM
        static internal OleInterop.STGMEDIUM BclSTGMEDIUM2Ole(ref BclComTypes.STGMEDIUM bclMedium)
        {
            OleInterop.STGMEDIUM oleMedium;
            oleMedium.pUnkForRelease = bclMedium.pUnkForRelease;
            oleMedium.tymed = (uint)bclMedium.tymed;
            oleMedium.unionmember = bclMedium.unionmember;
            return oleMedium;
        }
        static internal BclComTypes.STGMEDIUM OleSTGMEDIUM2Bcl(ref OleInterop.STGMEDIUM oleMedium)
        {
            BclComTypes.STGMEDIUM bclMedium;
            bclMedium.pUnkForRelease = oleMedium.pUnkForRelease;
            bclMedium.tymed = (BclComTypes.TYMED)oleMedium.tymed;
            bclMedium.unionmember = oleMedium.unionmember;
            return bclMedium;
        }
        //                                                                      STGMEDIUM
        ///////////////////////////////////////////////////////////////////////////////////

        ///////////////////////////////////////////////////////////////////////////////////
        // STATDATA
        static internal OleInterop.STATDATA BclSTATDATA2Ole(ref BclComTypes.STATDATA bclData)
        {
            OleInterop.STATDATA oleData;
            if (null == bclData.advSink)
            {
                oleData.pAdvSink = null;
            }
            else
            {
                oleData.pAdvSink = bclData.advSink as OleInterop.IAdviseSink;
                if (null == oleData.pAdvSink)
                    oleData.pAdvSink = (new AdviseSink(bclData.advSink));
            }
            oleData.ADVF = (uint)bclData.advf;
            oleData.dwConnection = (uint)bclData.connection;
            oleData.FORMATETC = BclFormatETC2Ole(ref bclData.formatetc);
            return oleData;
        }
        static internal BclComTypes.STATDATA OleSTATDATA2Bcl(ref OleInterop.STATDATA oleData)
        {
            BclComTypes.STATDATA bclData;
            if (null == oleData.pAdvSink)
            {
                bclData.advSink = null;
            }
            else
            {
                bclData.advSink = oleData.pAdvSink as BclComTypes.IAdviseSink;
                if (null == bclData.advSink)
                    bclData.advSink = (BclComTypes.IAdviseSink)(new AdviseSink(oleData.pAdvSink));
            }
            bclData.advf = (BclComTypes.ADVF)oleData.ADVF;
            bclData.connection = (int)oleData.dwConnection;
            bclData.formatetc = OleFormatETC2Bcl(ref oleData.FORMATETC);
            return bclData;
        }
        //                                                                        STATDATA
        ///////////////////////////////////////////////////////////////////////////////////
    }

    internal sealed class AdviseSink : IOleAdviseSink, IBclAdviseSink
    {
        private IOleAdviseSink oleSink;
        private IBclAdviseSink bclSink;

        // This class in a converter and it doesn't make sense to build it
        // without an interface to convert, so we make the default constructor
        // private to avoid that the compiler build a public one for us.
        private AdviseSink()
        {
        }

        internal AdviseSink(IOleAdviseSink oleSink)
        {
            if (null == oleSink)
                throw new ArgumentNullException("Microsoft.VisualStudio.OLE.Interop.IAdviseSink");
            this.oleSink = oleSink;
            this.bclSink = oleSink as IBclAdviseSink;
        }

        internal AdviseSink(IBclAdviseSink bclSink)
        {
            if (null == bclSink)
                throw new ArgumentNullException("System.Runtime.InteropServices.ComTypes.IAdviseSink");
            this.oleSink = bclSink as IOleAdviseSink;
            this.bclSink = bclSink;
        }

        //////////////////////////////////////////////////////////////
        // OnClose
        //
        void IOleAdviseSink.OnClose()
        {
            if (null != oleSink)
            {
                oleSink.OnClose();
            }
            else
            {
                bclSink.OnClose();
            }
        }
        void IBclAdviseSink.OnClose()
        {
            ((IOleAdviseSink)this).OnClose();
        }
        //
        //////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////
        // OnDataChange
        //
        void IOleAdviseSink.OnDataChange(OleInterop.FORMATETC[] pFormatetc, OleInterop.STGMEDIUM[] pStgmed)
        {
            if (null != oleSink)
            {
                oleSink.OnDataChange(pFormatetc, pStgmed);
            }
            else
            {
                // In order to call the version of this interface defined in the BCL
                // each array must contain exactly one object.
                if ((null == pFormatetc) || (null == pStgmed))
                    throw new ArgumentNullException("");
                if ((1 != pFormatetc.Length) || (1 != pStgmed.Length))
                    throw new InvalidOperationException();

                // Convert the parameters
                BclComTypes.FORMATETC bclFormat = StructConverter.OleFormatETC2Bcl(ref pFormatetc[0]);
                BclComTypes.STGMEDIUM bclMedium = StructConverter.OleSTGMEDIUM2Bcl(ref pStgmed[0]);

                // Now we can call the method on the BCL interface
                bclSink.OnDataChange(ref bclFormat, ref bclMedium);

                // Now we have to copy the parameters back into the original structures.
                pFormatetc[0] = StructConverter.BclFormatETC2Ole(ref bclFormat);
                pStgmed[0] = StructConverter.BclSTGMEDIUM2Ole(ref bclMedium);
            }
        }
        void IBclAdviseSink.OnDataChange(ref BclComTypes.FORMATETC format, ref BclComTypes.STGMEDIUM stgmedium)
        {
            if (null != bclSink)
            {
                bclSink.OnDataChange(ref format, ref stgmedium);
            }
            else
            {
                // As in the previous case we have to copy the parameters.
                OleInterop.FORMATETC[] pFormatetc = new OleInterop.FORMATETC[1];
                pFormatetc[0] = StructConverter.BclFormatETC2Ole(ref format);

                OleInterop.STGMEDIUM[] pStgmed = new OleInterop.STGMEDIUM[1];
                pStgmed[0] = StructConverter.BclSTGMEDIUM2Ole(ref stgmedium);

                // Call the original interface.
                oleSink.OnDataChange(pFormatetc, pStgmed);
            }
        }
        //
        //////////////////////////////////////////////////////////////

        void IOleAdviseSink.OnRename(OleInterop.IMoniker pmk)
        {
            if (null != oleSink)
            {
                oleSink.OnRename(pmk);
            }
            else
            {
                // TODO: Use the IMoniker converter when ready.
                bclSink.OnRename(null);
            }
        }
        void IBclAdviseSink.OnRename(BclComTypes.IMoniker moniker)
        {
            if (null != bclSink)
            {
                bclSink.OnRename(moniker);
            }
            else
            {
                // TODO: Use the IMoniker converter when ready.
                oleSink.OnRename(null);
            }
        }
        //
        //////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////
        // OnSave
        //
        void IOleAdviseSink.OnSave()
        {
            if (null != oleSink)
            {
                oleSink.OnSave();
            }
            else
            {
                bclSink.OnSave();
            }
        }
        void IBclAdviseSink.OnSave()
        {
            ((IOleAdviseSink)this).OnSave();
        }
        //
        //////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////
        // OnViewChange
        //
        void IOleAdviseSink.OnViewChange(uint aspect, int index)
        {
            if (null != oleSink)
            {
                oleSink.OnViewChange(aspect, index);
            }
            else
            {
                bclSink.OnViewChange((int)aspect, index);
            }
        }
        void IBclAdviseSink.OnViewChange(int aspect, int index)
        {
            ((IOleAdviseSink)this).OnViewChange((uint)aspect, index);
        }
        //
        //////////////////////////////////////////////////////////////

    }

    internal sealed class EnumSTATDATA : OleInterop.IEnumSTATDATA, BclComTypes.IEnumSTATDATA
    {
        private OleInterop.IEnumSTATDATA oleEnum;
        private BclComTypes.IEnumSTATDATA bclEnum;

        private EnumSTATDATA() { }

        internal EnumSTATDATA(OleInterop.IEnumSTATDATA oleEnum)
        {
            if (null == oleEnum)
                throw new ArgumentNullException("Microsoft.VisualStudio.OLE.Interop.IEnumSTATDATA");
            this.oleEnum = oleEnum;
            this.bclEnum = oleEnum as BclComTypes.IEnumSTATDATA;
        }

        internal EnumSTATDATA(BclComTypes.IEnumSTATDATA bclEnum)
        {
            if (null == bclEnum)
                throw new ArgumentNullException("System.Runtime.InteropServices.ComTypes.IEnumSTATDATA");
            this.oleEnum = bclEnum as OleInterop.IEnumSTATDATA;
            this.bclEnum = bclEnum;
        }

        //////////////////////////////////////////////////////////////
        // Clone
        void OleInterop.IEnumSTATDATA.Clone(out OleInterop.IEnumSTATDATA ppEnum)
        {
            ppEnum = null;
            if (null != oleEnum)
            {
                oleEnum.Clone(out ppEnum);
            }
            else
            {
                BclComTypes.IEnumSTATDATA bclCloned;
                bclEnum.Clone(out bclCloned);
                ppEnum = bclCloned as OleInterop.IEnumSTATDATA;
                if (null == ppEnum)
                    ppEnum = (OleInterop.IEnumSTATDATA)(new EnumSTATDATA(bclCloned));
            }
        }
        void BclComTypes.IEnumSTATDATA.Clone(out BclComTypes.IEnumSTATDATA newEnum)
        {
            newEnum = null;
            if (null != bclEnum)
            {
                bclEnum.Clone(out newEnum);
            }
            else
            {
                OleInterop.IEnumSTATDATA oleCloned;
                oleEnum.Clone(out oleCloned);
                newEnum = oleCloned as BclComTypes.IEnumSTATDATA;
                if (null == newEnum)
                    newEnum = (BclComTypes.IEnumSTATDATA)(new EnumSTATDATA(oleCloned));
            }
        }
        //
        //////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////
        // Next
        int OleInterop.IEnumSTATDATA.Next(uint celt, OleInterop.STATDATA[] rgelt, out uint pceltFetched)
        {
            pceltFetched = 0;
            if (null != oleEnum)
            {
                return oleEnum.Next(celt, rgelt, out pceltFetched);
            }

            BclComTypes.STATDATA[] bclStat = new BclComTypes.STATDATA[celt];
            int[] fetched = { (int)pceltFetched };
            int hr = bclEnum.Next((int)celt, bclStat, fetched);
            if (NativeMethods.Failed(hr))
                return hr;
            pceltFetched = (uint)fetched[0];
            for (int i = 0; i < pceltFetched; i++)
            {
                rgelt[i] = StructConverter.BclSTATDATA2Ole(ref bclStat[i]);
            }
            return hr;
        }
        int BclComTypes.IEnumSTATDATA.Next(int celt, BclComTypes.STATDATA[] rgelt, int[] pceltFetched)
        {
            if (null != bclEnum)
            {
                return bclEnum.Next(celt, rgelt, pceltFetched);
            }

            OleInterop.STATDATA[] oleStat = new OleInterop.STATDATA[celt];
            uint fetched;
            int hr = oleEnum.Next((uint)celt, oleStat, out fetched);
            if (NativeMethods.Failed(hr))
                return hr;
            if (null != pceltFetched)
                pceltFetched[0] = (int)fetched;
            for (int i = 0; i < fetched; i++)
            {
                rgelt[i] = StructConverter.OleSTATDATA2Bcl(ref oleStat[i]);
            }
            return hr;
        }
        //
        //////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////
        // Reset
        int OleInterop.IEnumSTATDATA.Reset()
        {
            if (null != oleEnum)
                return oleEnum.Reset();
            return bclEnum.Reset();
        }
        int BclComTypes.IEnumSTATDATA.Reset()
        {
            if (null != bclEnum)
                return bclEnum.Reset();
            return oleEnum.Reset();
        }
        //
        //////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////
        // Skip
        int OleInterop.IEnumSTATDATA.Skip(uint celt)
        {
            if (null != oleEnum)
                return oleEnum.Skip(celt);
            return bclEnum.Skip((int)celt);
        }
        int BclComTypes.IEnumSTATDATA.Skip(int celt)
        {
            if (null != bclEnum)
                return bclEnum.Skip(celt);
            return oleEnum.Skip((uint)celt);
        }
        //
        //////////////////////////////////////////////////////////////
    }

    internal sealed class EnumFORMATETC : OleInterop.IEnumFORMATETC, BclComTypes.IEnumFORMATETC
    {
        private OleInterop.IEnumFORMATETC oleEnum;
        private BclComTypes.IEnumFORMATETC bclEnum;

        private EnumFORMATETC() { }

        internal EnumFORMATETC(OleInterop.IEnumFORMATETC oleEnum)
        {
            if (null == oleEnum)
                throw new ArgumentNullException("Microsoft.VisualStudio.OLE.Interop.IEnumFORMATETC");
            this.oleEnum = oleEnum;
            this.bclEnum = oleEnum as BclComTypes.IEnumFORMATETC;
        }

        internal EnumFORMATETC(BclComTypes.IEnumFORMATETC bclEnum)
        {
            if (null == bclEnum)
                throw new ArgumentNullException("System.Runtime.InteropServices.ComTypes.IEnumFORMATETC");
            this.oleEnum = bclEnum as OleInterop.IEnumFORMATETC;
            this.bclEnum = bclEnum;
        }

        //////////////////////////////////////////////////////////////
        // Clone
        void OleInterop.IEnumFORMATETC.Clone(out OleInterop.IEnumFORMATETC ppEnum)
        {
            ppEnum = null;
            if (null != oleEnum)
            {
                oleEnum.Clone(out ppEnum);
            }
            else
            {
                BclComTypes.IEnumFORMATETC bclCloned;
                bclEnum.Clone(out bclCloned);
                ppEnum = bclCloned as OleInterop.IEnumFORMATETC;
                if (null == ppEnum)
                    ppEnum = (OleInterop.IEnumFORMATETC)(new EnumFORMATETC(bclCloned));
            }
        }
        void BclComTypes.IEnumFORMATETC.Clone(out BclComTypes.IEnumFORMATETC newEnum)
        {
            newEnum = null;
            if (null != bclEnum)
            {
                bclEnum.Clone(out newEnum);
            }
            else
            {
                OleInterop.IEnumFORMATETC oleCloned;
                oleEnum.Clone(out oleCloned);
                newEnum = oleCloned as BclComTypes.IEnumFORMATETC;
                if (null == newEnum)
                    newEnum = (BclComTypes.IEnumFORMATETC)(new EnumFORMATETC(oleCloned));
            }
        }
        //
        //////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////
        // Next
        int OleInterop.IEnumFORMATETC.Next(uint celt, OleInterop.FORMATETC[] rgelt, uint[] pceltFetched)
        {
            if (null != oleEnum)
            {
                return oleEnum.Next(celt, rgelt, pceltFetched);
            }

            BclComTypes.FORMATETC[] bclStat = new BclComTypes.FORMATETC[celt];
            int[] fetched = new int[1];
            int hr = bclEnum.Next((int)celt, bclStat, fetched);
            if (NativeMethods.Failed(hr))
                return hr;
            if (null != pceltFetched)
                pceltFetched[0] = (uint)fetched[0];
            for (int i = 0; i < fetched[0]; i++)
            {
                rgelt[i] = StructConverter.BclFormatETC2Ole(ref bclStat[i]);
            }
            return hr;
        }
        int BclComTypes.IEnumFORMATETC.Next(int celt, BclComTypes.FORMATETC[] rgelt, int[] pceltFetched)
        {
            if (null != bclEnum)
            {
                return bclEnum.Next(celt, rgelt, pceltFetched);
            }

            OleInterop.FORMATETC[] oleStat = new OleInterop.FORMATETC[celt];
            uint[] fetched = new uint[1];
            int hr = oleEnum.Next((uint)celt, oleStat, fetched);
            if (NativeMethods.Failed(hr))
                return hr;
            if (null != pceltFetched)
                pceltFetched[0] = (int)fetched[0];
            for (uint i = 0; i < fetched[0]; i++)
            {
                rgelt[i] = StructConverter.OleFormatETC2Bcl(ref oleStat[i]);
            }
            return hr;
        }
        //
        //////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////
        // Reset
        int OleInterop.IEnumFORMATETC.Reset()
        {
            if (null != oleEnum)
                return oleEnum.Reset();
            return bclEnum.Reset();
        }
        int BclComTypes.IEnumFORMATETC.Reset()
        {
            if (null != bclEnum)
                return bclEnum.Reset();
            return oleEnum.Reset();
        }
        //
        //////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////
        // Skip
        int OleInterop.IEnumFORMATETC.Skip(uint celt)
        {
            if (null != oleEnum)
                return oleEnum.Skip(celt);
            return bclEnum.Skip((int)celt);
        }
        int BclComTypes.IEnumFORMATETC.Skip(int celt)
        {
            if (null != bclEnum)
                return bclEnum.Skip(celt);
            return oleEnum.Skip((uint)celt);
        }
        //
        //////////////////////////////////////////////////////////////
    }

    internal sealed class Ole2BclDataObject : OleInterop.IDataObject, BclComTypes.IDataObject
    {
        private OleInterop.IDataObject oleData;
        private BclComTypes.IDataObject bclData;

        // Private default constructor: it is not allow to build instances of this class without
        // providing an interface to convert.
        private Ole2BclDataObject() { }

        internal Ole2BclDataObject(OleInterop.IDataObject oleData)
        {
            if (null == oleData)
                throw new ArgumentNullException("Microsoft.VisualStudio.OLE.Interop.IDataObject");
            this.oleData = oleData;
            //this.bclData = oleData as BclComTypes.IDataObject;
            this.bclData = null;
        }

        internal Ole2BclDataObject(BclComTypes.IDataObject bclData)
        {
            if (null == bclData)
                throw new ArgumentNullException("System.Runtime.InteropServices.ComTypes.IDataObject");
            //this.oleData = bclData as OleInterop.IDataObject;
            this.oleData = null;
            this.bclData = bclData;
        }

        #region OleInterop.IDataObject Members

        int OleInterop.IDataObject.DAdvise(OleInterop.FORMATETC[] pFormatetc, uint ADVF, OleInterop.IAdviseSink pAdvSink, out uint pdwConnection)
        {
            if (null != oleData)
                return oleData.DAdvise(pFormatetc, ADVF, pAdvSink, out pdwConnection);

            // We have to call the method in the BCL version of the interface, so we need to
            // convert the parameters to the other type of structure.

            // As first make sure that the array contains exactly one element.
            if ((null == pFormatetc) || (pFormatetc.Length != 1))
                throw new ArgumentException();

            // Now convert the patameters
            BclComTypes.FORMATETC bclFormat = StructConverter.OleFormatETC2Bcl(ref pFormatetc[0]);
            BclComTypes.IAdviseSink bclSink = pAdvSink as BclComTypes.IAdviseSink;
            if (null == bclSink)
                bclSink = new AdviseSink(pAdvSink);

            int connection;
            int hr = bclData.DAdvise(ref bclFormat, (BclComTypes.ADVF)(ADVF), bclSink, out connection);
            pdwConnection = (uint)connection;
            return hr;
        }

        void OleInterop.IDataObject.DUnadvise(uint dwConnection)
        {
            if (null != oleData)
                oleData.DUnadvise(dwConnection);
            else
                bclData.DUnadvise((int)dwConnection);
        }

        int OleInterop.IDataObject.EnumDAdvise(out OleInterop.IEnumSTATDATA ppenumAdvise)
        {
            if (null != oleData)
                return oleData.EnumDAdvise(out ppenumAdvise);

            // Call the BCL version of the method
            BclComTypes.IEnumSTATDATA bclEnum;
            int hr = bclData.EnumDAdvise(out bclEnum);
            NativeMethods.ThrowOnFailure(hr);
            if (null == bclEnum)
            {
                ppenumAdvise = null;
            }
            else
            {
                ppenumAdvise = bclEnum as OleInterop.IEnumSTATDATA;
                if (null == ppenumAdvise)
                    ppenumAdvise = (OleInterop.IEnumSTATDATA)(new EnumSTATDATA(bclEnum));
            }
            return hr;
        }

        int OleInterop.IDataObject.EnumFormatEtc(uint dwDirection, out OleInterop.IEnumFORMATETC ppenumFormatEtc)
        {
            if (null != oleData)
                return oleData.EnumFormatEtc(dwDirection, out ppenumFormatEtc);

            BclComTypes.IEnumFORMATETC bclEnum = bclData.EnumFormatEtc((BclComTypes.DATADIR)dwDirection);
            if (null == bclEnum)
            {
                ppenumFormatEtc = null;
            }
            else
            {
                ppenumFormatEtc = bclEnum as OleInterop.IEnumFORMATETC;
                if (null == ppenumFormatEtc)
                    ppenumFormatEtc = (OleInterop.IEnumFORMATETC)(new EnumFORMATETC(bclEnum));
            }
            return NativeMethods.S_OK;
        }

        int OleInterop.IDataObject.GetCanonicalFormatEtc(OleInterop.FORMATETC[] pformatectIn, OleInterop.FORMATETC[] pformatetcOut)
        {
            if (null != oleData)
                return oleData.GetCanonicalFormatEtc(pformatectIn, pformatetcOut);

            // Check that the arrays are not null and with only one element.
            if ((null == pformatectIn) || (pformatectIn.Length != 1) ||
                 (null == pformatetcOut) || (pformatetcOut.Length != 1))
                throw new ArgumentException();

            BclComTypes.FORMATETC bclFormatIn = StructConverter.OleFormatETC2Bcl(ref pformatectIn[0]);
            BclComTypes.FORMATETC bclFormatOut;
            int hr = bclData.GetCanonicalFormatEtc(ref bclFormatIn, out bclFormatOut);
            NativeMethods.ThrowOnFailure(hr);
            pformatetcOut[0] = StructConverter.BclFormatETC2Ole(ref bclFormatOut);
            return hr;
        }

        void OleInterop.IDataObject.GetData(OleInterop.FORMATETC[] pformatetcIn, OleInterop.STGMEDIUM[] pRemoteMedium)
        {
            if (null != oleData)
            {
                oleData.GetData(pformatetcIn, pRemoteMedium);
                return;
            }

            // Check that the arrays are not null and with only one element.
            if ((null == pformatetcIn) || (pformatetcIn.Length != 1) ||
                 (null == pRemoteMedium) || (pRemoteMedium.Length != 1))
                throw new ArgumentException();

            // Call the method on the BCL interface
            BclComTypes.FORMATETC bclFormat = StructConverter.OleFormatETC2Bcl(ref pformatetcIn[0]);
            BclComTypes.STGMEDIUM bclMedium;
            bclData.GetData(ref bclFormat, out bclMedium);
            pRemoteMedium[0] = StructConverter.BclSTGMEDIUM2Ole(ref bclMedium);
        }

        void OleInterop.IDataObject.GetDataHere(OleInterop.FORMATETC[] pFormatetc, OleInterop.STGMEDIUM[] pRemoteMedium)
        {
            if (null != oleData)
            {
                oleData.GetDataHere(pFormatetc, pRemoteMedium);
                return;
            }

            // Check that the arrays are not null and with only one element.
            if ((null == pFormatetc) || (pFormatetc.Length != 1) ||
                 (null == pRemoteMedium) || (pRemoteMedium.Length != 1))
                throw new ArgumentException();

            // Call the method on the BCL interface
            BclComTypes.FORMATETC bclFormat = StructConverter.OleFormatETC2Bcl(ref pFormatetc[0]);
            BclComTypes.STGMEDIUM bclMedium = StructConverter.OleSTGMEDIUM2Bcl(ref pRemoteMedium[0]);
            bclData.GetDataHere(ref bclFormat, ref bclMedium);
            pRemoteMedium[0] = StructConverter.BclSTGMEDIUM2Ole(ref bclMedium);
        }

        int OleInterop.IDataObject.QueryGetData(OleInterop.FORMATETC[] pFormatetc)
        {
            if (null != oleData)
                return oleData.QueryGetData(pFormatetc);

            if ((null == pFormatetc) || (1 != pFormatetc.Length))
                throw new ArgumentException();

            BclComTypes.FORMATETC bclFormat = StructConverter.OleFormatETC2Bcl(ref pFormatetc[0]);
            return bclData.QueryGetData(ref bclFormat);
        }

        void OleInterop.IDataObject.SetData(OleInterop.FORMATETC[] pFormatetc, OleInterop.STGMEDIUM[] pmedium, int fRelease)
        {
            if (null != oleData)
            {
                oleData.SetData(pFormatetc, pmedium, fRelease);
                return;
            }

            if ((null == pFormatetc) || (1 != pFormatetc.Length) ||
                (null == pmedium) || (1 != pmedium.Length))
                throw new ArgumentException();

            BclComTypes.FORMATETC bclFormat = StructConverter.OleFormatETC2Bcl(ref pFormatetc[0]);
            BclComTypes.STGMEDIUM bclMedium = StructConverter.OleSTGMEDIUM2Bcl(ref pmedium[0]);
            bclData.SetData(ref bclFormat, ref bclMedium, (fRelease == 0) ? false : true);
        }

        #endregion

        #region IDataObject Members

        int BclComTypes.IDataObject.DAdvise(ref BclComTypes.FORMATETC pFormatetc, BclComTypes.ADVF advf, BclComTypes.IAdviseSink adviseSink, out int connection)
        {
            if (null != bclData)
                return bclData.DAdvise(ref pFormatetc, advf, adviseSink, out connection);

            OleInterop.FORMATETC[] oleFormat = new OleInterop.FORMATETC[1];
            oleFormat[0] = StructConverter.BclFormatETC2Ole(ref pFormatetc);
            uint result;
            OleInterop.IAdviseSink oleSink = adviseSink as OleInterop.IAdviseSink;
            if (null == oleSink)
                oleSink = (OleInterop.IAdviseSink)(new AdviseSink(adviseSink));
            int hr = oleData.DAdvise(oleFormat, (uint)advf, oleSink, out result);
            NativeMethods.ThrowOnFailure(hr);
            connection = (int)result;
            return hr;
        }

        void BclComTypes.IDataObject.DUnadvise(int connection)
        {
            if (bclData != null)
                bclData.DUnadvise(connection);
            else
                oleData.DUnadvise((uint)connection);
        }

        int BclComTypes.IDataObject.EnumDAdvise(out BclComTypes.IEnumSTATDATA enumAdvise)
        {
            if (null != bclData)
                return bclData.EnumDAdvise(out enumAdvise);

            OleInterop.IEnumSTATDATA oleEnum;
            int hr = oleData.EnumDAdvise(out oleEnum);
            NativeMethods.ThrowOnFailure(hr);
            if (null == oleEnum)
            {
                enumAdvise = null;
            }
            else
            {
                enumAdvise = oleEnum as BclComTypes.IEnumSTATDATA;
                if (null == enumAdvise)
                    enumAdvise = (BclComTypes.IEnumSTATDATA)(new EnumSTATDATA(oleEnum));
            }
            return hr;
        }

        BclComTypes.IEnumFORMATETC BclComTypes.IDataObject.EnumFormatEtc(BclComTypes.DATADIR direction)
        {
            if (bclData != null)
                return bclData.EnumFormatEtc(direction);

            OleInterop.IEnumFORMATETC oleEnum;
            NativeMethods.ThrowOnFailure(oleData.EnumFormatEtc((uint)direction, out oleEnum));
            if (null == oleEnum)
                return null;
            BclComTypes.IEnumFORMATETC bclEnum = oleEnum as BclComTypes.IEnumFORMATETC;
            if (null == bclEnum)
                bclEnum = (BclComTypes.IEnumFORMATETC)(new EnumFORMATETC(oleEnum));
            return bclEnum;
        }

        int BclComTypes.IDataObject.GetCanonicalFormatEtc(ref BclComTypes.FORMATETC formatIn, out BclComTypes.FORMATETC formatOut)
        {
            if (null != bclData)
                return bclData.GetCanonicalFormatEtc(ref formatIn, out formatOut);

            OleInterop.FORMATETC[] oleFormatIn = new OleInterop.FORMATETC[1];
            OleInterop.FORMATETC[] oleFormatOut = new OleInterop.FORMATETC[1];
            oleFormatIn[0] = StructConverter.BclFormatETC2Ole(ref formatIn);
            int hr = oleData.GetCanonicalFormatEtc(oleFormatIn, oleFormatOut);
            NativeMethods.ThrowOnFailure(hr);
            formatOut = StructConverter.OleFormatETC2Bcl(ref oleFormatOut[0]);
            return hr;
        }

        void BclComTypes.IDataObject.GetData(ref BclComTypes.FORMATETC format, out BclComTypes.STGMEDIUM medium)
        {
            if (null != bclData)
            {
                bclData.GetData(ref format, out medium);
                return;
            }

            OleInterop.FORMATETC[] oleFormat = new OleInterop.FORMATETC[1];
            oleFormat[0] = StructConverter.BclFormatETC2Ole(ref format);
            OleInterop.STGMEDIUM[] oleMedium = new OleInterop.STGMEDIUM[1];
            oleData.GetData(oleFormat, oleMedium);
            medium = StructConverter.OleSTGMEDIUM2Bcl(ref oleMedium[0]);
        }

        void BclComTypes.IDataObject.GetDataHere(ref BclComTypes.FORMATETC format, ref BclComTypes.STGMEDIUM medium)
        {
            if (null != bclData)
            {
                bclData.GetDataHere(ref format, ref medium);
                return;
            }

            OleInterop.FORMATETC[] oleFormat = new OleInterop.FORMATETC[1];
            oleFormat[0] = StructConverter.BclFormatETC2Ole(ref format);
            OleInterop.STGMEDIUM[] oleMedium = new OleInterop.STGMEDIUM[1];
            oleMedium[0] = StructConverter.BclSTGMEDIUM2Ole(ref medium);
            oleData.GetDataHere(oleFormat, oleMedium);
            medium = StructConverter.OleSTGMEDIUM2Bcl(ref oleMedium[0]);
        }

        int BclComTypes.IDataObject.QueryGetData(ref BclComTypes.FORMATETC format)
        {
            if (null != bclData)
                return bclData.QueryGetData(ref format);

            OleInterop.FORMATETC[] oleFormat = new OleInterop.FORMATETC[1];
            oleFormat[0] = StructConverter.BclFormatETC2Ole(ref format);
            return oleData.QueryGetData(oleFormat);
        }

        void BclComTypes.IDataObject.SetData(ref BclComTypes.FORMATETC formatIn, ref BclComTypes.STGMEDIUM medium, bool release)
        {
            if (null != bclData)
            {
                bclData.SetData(ref formatIn, ref medium, release);
                return;
            }

            OleInterop.FORMATETC[] oleFormat = new OleInterop.FORMATETC[1];
            oleFormat[0] = StructConverter.BclFormatETC2Ole(ref formatIn);
            OleInterop.STGMEDIUM[] oleMedium = new OleInterop.STGMEDIUM[1];
            oleMedium[0] = StructConverter.BclSTGMEDIUM2Ole(ref medium);
            oleData.SetData(oleFormat, oleMedium, release ? 1 : 0);
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\OleMenuCommand.cs ===
using System;
using System.Runtime.InteropServices;
using System.Security.Permissions;

namespace Microsoft.VisualStudio.Shell
{
    using System.ComponentModel;
    using System.ComponentModel.Design;


    /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCmdEventArgs"]/*' />
    /// <summary>
    /// This is the set of arguments passed to a OleMenuCommand object when the
    /// Invoke function is called
    /// </summary>
    public class OleMenuCmdEventArgs : System.EventArgs
    {
        private object inParam;
        private IntPtr outParam;

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCmdEventArgs.OleMenuCmdEventArgs"]/*' />
        /// <summary>
        /// Builds the OleMenuCmdEventArgs
        /// </summary>
        /// <param name="inParam">The input parameter to the command function.</param>
        /// <param name="outParam">A pointer to the parameter returned by the function</param>
        public OleMenuCmdEventArgs(object inParam, IntPtr outParam) :
            base()
        {
            this.inParam = inParam;
            this.outParam = outParam;
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCmdEventArgs.InValue"]/*' />
        /// <summary>
        /// Gets the parameter passed as input to the command function
        /// </summary>
        public object InValue
        {
            get { return inParam; }
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCmdEventArgs.OutValue"]/*' />
        /// <summary>
        /// Gets a pointer to the parameter used as output by the command function
        /// </summary>
        public IntPtr OutValue
        {
            get { return outParam; }
        }
    }

    /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand"]/*' />
    /// <summary>
    /// This class is an exspansion of the MenuCommand.
    /// </summary>
    [System.Runtime.InteropServices.ComVisible(true)]
    public class OleMenuCommand : MenuCommand
    {
        /// <summary>The event handler called to execute the command.</summary>
        private EventHandler execHandler;
        /// <summary>
        /// The event handler caller before getting the command status; it can be used to
        /// implement a command with a dynamic status.
        /// </summary>
        private EventHandler beforeQueryStatusHandler;
        private string text;
        // Used in the case of dynamic menu (created with the DYNAMICITEMSTART option)
        private int matchedCommandId;
        // If the command supports parameters, then this string will contain the description
        // of the parameters
        private string parametersDescription;

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.OleMenuCommand"]/*' />
        /// <summary>
        /// Builds a new OleMenuCommand.
        /// </summary>
        /// <param name="invokeHandler">The event handler called to execute the command.</param>
        /// <param name="id">ID of the command.</param>
        public OleMenuCommand(EventHandler invokeHandler, CommandID id) :
            base(invokeHandler, id)
        {
            PrivateInit(invokeHandler, null, null, String.Empty);
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.OleMenuCommand1"]/*' />
        /// <summary>
        /// Builds a new OleMenuCommand.
        /// </summary>
        /// <param name="invokeHandler">The event handler called to execute the command.</param>
        /// <param name="id">ID of the command.</param>
        /// <param name="Text">The text of the command.</param>
        public OleMenuCommand(EventHandler invokeHandler, CommandID id, string Text) :
            base(invokeHandler, id)
        {
            PrivateInit(invokeHandler, null, null, Text);
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.OleMenuCommand2"]/*' />
        /// <devdoc>
        /// Builds a new OleMenuCommand.
        /// </devdoc>
        /// <param name="invokeHandler">The event handler called to execute the command.</param>
        /// <param name="changeHandler">The event handler called when the command's status changes.</param>
        /// <param name="id">ID of the command.</param>
        public OleMenuCommand(EventHandler invokeHandler, EventHandler changeHandler, CommandID id) :
            base(invokeHandler, id)
        {
            PrivateInit(invokeHandler, changeHandler, null, String.Empty);
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.OleMenuCommand3"]/*' />
        /// <devdoc>
        /// Builds a new OleMenuCommand.
        /// </devdoc>
        /// <param name="invokeHandler">The event handler called to execute the command.</param>
        /// <param name="changeHandler">The event handler called when the command's status changes.</param>
        /// <param name="id">ID of the command.</param>
        /// <param name="Text">The text of the command.</param>
        public OleMenuCommand(EventHandler invokeHandler, EventHandler changeHandler, CommandID id, string Text) :
            base(invokeHandler, id)
        {
            PrivateInit(invokeHandler, changeHandler, null, Text);
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.OleMenuCommand4"]/*' />
        /// <devdoc>
        /// Builds a new OleMenuCommand.
        /// </devdoc>
        /// <param name="invokeHandler">The event handler called to execute the command.</param>
        /// <param name="changeHandler">The event handler called when the command's status changes.</param>
        /// <param name="beforeQueryStatus">Event handler called when a lient asks for the command status.</param>
        /// <param name="id">ID of the command.</param>
        public OleMenuCommand(EventHandler invokeHandler, EventHandler changeHandler, EventHandler beforeQueryStatus, CommandID id) :
            base(invokeHandler, id)
        {
            PrivateInit(invokeHandler, changeHandler, beforeQueryStatus, String.Empty);
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.OleMenuCommand5"]/*' />
        /// <devdoc>
        /// Builds a new OleMenuCommand.
        /// </devdoc>
        /// <param name="invokeHandler">The event handler called to execute the command.</param>
        /// <param name="changeHandler">The event handler called when the command's status changes.</param>
        /// <param name="beforeQueryStatus">Event handler called when a lient asks for the command status.</param>
        /// <param name="id">ID of the command.</param>
        /// <param name="Text">The text of the command.</param>
        public OleMenuCommand(EventHandler invokeHandler, EventHandler changeHandler, EventHandler beforeQueryStatus, CommandID id, string Text) :
            base(invokeHandler, id)
        {
            PrivateInit(invokeHandler, changeHandler, beforeQueryStatus, Text);
        }

        private void PrivateInit(EventHandler handler, EventHandler changeHandler, EventHandler beforeQS, string Text)
        {
            execHandler = handler;
            if (changeHandler != null)
            {
                this.CommandChanged += changeHandler;
            }
            beforeQueryStatusHandler = beforeQS;
            text = Text;
            parametersDescription = null;
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.BeforeQueryStatus"]/*' />
        /// <devdoc>
        /// Event fired when a client asks for the status of the command.
        /// </devdoc>
        /// <value></value>
        public event EventHandler BeforeQueryStatus
        {
            add { beforeQueryStatusHandler += value; }
            remove { beforeQueryStatusHandler -= value; }
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.OleStatus"]/*' />
        public override int OleStatus
        {
            get
            {
                if (null != beforeQueryStatusHandler)
                {
                    beforeQueryStatusHandler(this, EventArgs.Empty);
                }
                return base.OleStatus;
            }
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.ParametersDescription"]/*' />
        /// <devdoc>
        /// Get or set the string that describes the paraeters accepted by the command.
        /// </devdoc>
        public string ParametersDescription
        {
            get { return parametersDescription; }
            set { parametersDescription = value; }
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.Invoke"]/*' />
        /// <devdoc>
        /// Executes the command.
        /// </devdoc>
        /// <param name="inArg">The parameter passed to the command.</param>
        [EnvironmentPermission(SecurityAction.LinkDemand, Unrestricted = true)]
        public override void Invoke(object inArg)
        {
            try
            {
                OleMenuCmdEventArgs args = new OleMenuCmdEventArgs(inArg, NativeMethods.InvalidIntPtr);
                execHandler(this, args);
            }
            catch (CheckoutException ex)
            {
                if (CheckoutException.Canceled != ex)
                    throw;
            }
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.Invoke1"]/*' />
        /// <devdoc>
        /// Executes the command.
        /// </devdoc>
        /// <param name="inArg">The parameter passed to the command.</param>
        /// <param name="outArg">The parameter returned by the command.</param>
        [EnvironmentPermission(SecurityAction.LinkDemand, Unrestricted = true)]
        public virtual void Invoke(object inArg, IntPtr outArg)
        {
            try
            {
                OleMenuCmdEventArgs args = new OleMenuCmdEventArgs(inArg, outArg);
                execHandler(this, args);
            }
            catch (CheckoutException ex)
            {
                if (CheckoutException.Canceled != ex)
                    throw;
            }
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.Text"]/*' />
        /// <devdoc>
        /// Gets or sets the text for the command.
        /// </devdoc>
        /// <value></value>
        public virtual string Text
        {
            get { return text; }
            set { if (text != value) { text = value; OnCommandChanged(EventArgs.Empty); } }
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.DynamicItemMatch"]/*' />
        /// <devdoc>
        /// Allows a dynamic item command to match the subsequent items in its list.  This must be overriden
        /// when implementing a menu via DYNAMICITEMSTART.
        /// </devdoc>
        /// <param name="cmdId"></param>
        /// <returns></returns>
        public virtual bool DynamicItemMatch(int cmdId)
        {
            return false;
        }

        /// <include file='doc\OleMenuCommand.uex' path='docs/doc[@for="OleMenuCommand.MatchedCommandId"]/*' />
        /// <devdoc>
        /// The command id that was most recently used to match this command.  This must be set by the sub-class
        /// when a match occurs and can be used to identify the actual command being invoked.
        /// </devdoc>
        /// <value></value>
        public int MatchedCommandId
        {
            get { return matchedCommandId; }
            set { matchedCommandId = value; }
        }
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\ProvideAssemblyFilterAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideAssemblyFilterAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {
    
    using System;
    using Microsoft.VisualStudio.Shell.Interop;

    /// <include file='doc\ProvideAssemblyFilterAttribute.uex' path='docs/doc[@for="ProvideAssemblyFilterAttribute"]' />
    /// <devdoc>
    ///    Provides an assembly filter for a toolbox item configuration object.  Place this attribute on an object
    ///    that implements IConfigureToolboxItem to describe the assemblies the object wishes to filter.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, Inherited = true, AllowMultiple = true)]
    public sealed class ProvideAssemblyFilterAttribute : Attribute {
        private string _assemblyFilter;

        /// <include file='doc\ProvideAssemblyFilterAttribute.uex' path='docs/doc[@for="ProvideAssemblyFilterAttribute.ProvideAssemblyFilterAttribute"]' />
        /// <devdoc>
        ///    Constructor
        /// </devdoc>
        public ProvideAssemblyFilterAttribute(string assemblyFilter) {
            if (assemblyFilter == null) {
                throw new ArgumentNullException("assemblyFilter");
            }

            if (assemblyFilter.Length == 0) {
                throw new ArgumentException(SR.GetString(SR.General_ExpectedNonEmptyString), "assemblyFilter");
            }

            _assemblyFilter = assemblyFilter;
        }

        /// <include file='doc\ProvideAssemblyFilterAttribute.uex' path='docs/doc[@for="ProvideAssemblyFilterAttribute.AssemblyFilter"]' />
        /// <devdoc>
        ///    The filter for the toolbox item configuration object.  Filters are used to optimize which toolbox item configuration objects
        ///    are invoked when a new toolbox item is added.  Filters allow you to specify as much as as little of an assembly as you 
        ///    like.  Here are some examples:
        /// 
        ///    All Assemblies:  *
        ///    Any version of System.Windows.Forms: System.Windows.Forms
        ///    
        /// </devdoc>
        public string AssemblyFilter {
            get {
                return _assemblyFilter;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\ProvideEditorFactoryAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideEditorFactoryAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.ComponentModel;
    using System.Globalization;
    using Microsoft.VisualStudio.Shell.Interop;

    /// <include file='doc\ProvideEditorFactoryAttribute.uex' path='docs/doc[@for="ProvideEditorFactoryAttribute"]' />
    /// <devdoc>
    ///     This attribute declares that a package offers an editor factory.  A single 
    ///     package can provide multiple editor factories.  If a package declares that 
    ///     it provides an editor factory, it should create the factory and offer it 
    ///     to Visual Studio in the Initialize method of Package.
    /// </devdoc>
    [CLSCompliant(false)]
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideEditorFactoryAttribute : RegistrationAttribute {

        private Type    _factoryType;
        private short   _nameResourceID;
        private __VSEDITORTRUSTLEVEL _trustLevel;

        /// <include file='doc\ProvideEditorFactoryAttribute.uex' path='docs/doc[@for="ProvideEditorFactoryAttribute.ProvideEditorFactoryAttribute"]' />
        /// <devdoc>
        ///     Creates a new ProvideEditorFactoryAttribute.
        /// </devdoc>
        public ProvideEditorFactoryAttribute (Type factoryType, short nameResourceID) {
            if (factoryType == null) {
                throw new ArgumentNullException("factoryType");
            }

            _factoryType = factoryType;
            _nameResourceID = nameResourceID;
            _trustLevel = __VSEDITORTRUSTLEVEL.ETL_NeverTrusted;
        }
        
        /// <include file='doc\ProvideEditorFactoryAttribute.uex' path='docs/doc[@for="ProvideEditorFactoryAttribute.FactoryType"]' />
        /// <devdoc>
        ///     Returns the editor factory type this attribute declares.
        /// </devdoc>
        public Type FactoryType {
            get {
                return _factoryType;
            }
        }

        /// <include file='doc\ProvideEditorFactoryAttribute.uex' path='docs/doc[@for="ProvideEditorFactoryAttribute.TrustLevel"]' />
        /// <devdoc>
        ///     Gets or Sets the trust level for the editor.
        /// </devdoc>
        public __VSEDITORTRUSTLEVEL TrustLevel
        {
            get { return _trustLevel; }
            set { _trustLevel = value; }
        }
        
        /// <include file='doc\ProvideEditorFactoryAttribute.uex' path='docs/doc[@for="ProvideEditorFactoryAttribute.NameResourceID"]' />
        /// <devdoc>
        ///     Returns the native resource ID for the factory name.
        /// </devdoc>
        public short NameResourceID {
            get {
                return _nameResourceID;
            }
        }

        private string EditorRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, "Editors\\{0}", FactoryType.GUID.ToString("B")); }
        }

        /// <include file='doc\ProvideEditorFactoryAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(SR.GetString(SR.Reg_NotifyEditorFactory, FactoryType.Name));

            using (Key childKey = context.CreateKey(EditorRegKey))
            {
                childKey.SetValue(string.Empty, FactoryType.Name);
                childKey.SetValue("DisplayName", string.Format(CultureInfo.InvariantCulture, "#{0}", NameResourceID));
                childKey.SetValue("Package", context.ComponentType.GUID.ToString("B"));
                childKey.SetValue("EditorTrustLevel", (int)_trustLevel);

                // Now report logical views for the editor factory.
                //
                using (Key viewKey = childKey.CreateSubkey("LogicalViews"))
                {
                    TypeConverter converter = TypeDescriptor.GetConverter(typeof(LogicalView));
                    foreach(ProvideViewAttribute pva in FactoryType.GetCustomAttributes(typeof(ProvideViewAttribute), true)) {
                        if (pva.LogicalView != LogicalView.Primary) {
                            context.Log.WriteLine(SR.GetString(SR.Reg_NotifyEditorView, converter.ConvertToString(pva.LogicalView)));
                            Guid logicalView = (Guid)converter.ConvertTo(pva.LogicalView, typeof(Guid));
                            string physicalView = pva.PhysicalView;
                            if (physicalView == null) {
                                physicalView = string.Empty;
                            }
                            viewKey.SetValue(logicalView.ToString("B"), physicalView);
                        }
                    }
                }
            }
        }

        /// <include file='doc\ProvideEditorFactoryAttribute.uex' path='docs/doc[@for="Unregister"]' />
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(EditorRegKey);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\ProvideEditorExtensionAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideEditorExtensionAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.IO;
    using System.Globalization;


    /// <include file='doc\ProvideEditorExtensionAttribute.uex' path='docs/doc[@for="ProvideEditorExtensionAttribute"]' />
    /// <devdoc>
    ///     This attribute associates a file extension to a given editor factory.  
    ///     The editor factory may be specified as either a GUID or a type and 
    ///     is placed on a package.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideEditorExtensionAttribute : RegistrationAttribute {

        private Guid factory;
        private string extension;
        private int priority;
        private Guid project;
        private string templateDir;
        private int resId;
        private bool editorFactoryNotify;
        private string editorName;
        
        /// <include file='doc\ProvideEditorExtensionAttribute.uex' path='docs/doc[@for="ProvideEditorExtensionAttribute.ProvideEditorExtensionAttribute"]' />
        /// <devdoc>
        ///     Creates a new attribute.
        /// </devdoc>
        public ProvideEditorExtensionAttribute (object factoryType, string extension, int priority) {

            if (!extension.StartsWith(".", StringComparison.OrdinalIgnoreCase)) {
                throw new ArgumentException(SR.GetString(SR.Attributes_ExtensionNeedsDot, extension));
            }

            // figure out what type of object they passed in and get the GUID from it
            if (factoryType is string)
                this.factory = new Guid((string)factoryType);
            else if (factoryType is Type)
                this.factory = ((Type)factoryType).GUID;
            else if (factoryType is Guid)
                this.factory = (Guid)factoryType;
            else
                throw new ArgumentException(SR.GetString(SR.Attributes_InvalidFactoryType, factoryType));

            this.extension = extension;
            this.priority = priority;
            this.project = Guid.Empty;
            this.templateDir = "";
            this.resId = 0;
            this.editorFactoryNotify = false;
        }
        
        /// <include file='doc\ProvideEditorExtensionAttribute.uex' path='docs/doc[@for="ProvideEditorExtensionAttribute.Extension"]' />
        /// <devdoc>
        ///     The file extension of the file.
        /// </devdoc>
        public string Extension {
            get {
                return extension;
            }
        }
        
        /// <include file='doc\ProvideEditorExtensionAttribute.uex' path='docs/doc[@for="ProvideEditorExtensionAttribute.Factory"]' />
        /// <devdoc>
        ///     The editor factory guid.
        /// </devdoc>
        public Guid Factory {
            get {
                return factory;
            }
        }
        
        /// <include file='doc\ProvideEditorExtensionAttribute.uex' path='docs/doc[@for="ProvideEditorExtensionAttribute.Priority"]' />
        /// <devdoc>
        ///     The priority of this extension registration.
        /// </devdoc>
        public int Priority {
            get {
                return priority;
            }
        }

        /// <include file='doc\ProvideEditorExtensionAttribute.uex' path='docs/doc[@for="ProvideEditorExtensionAttribute.ProjectGuid"]/*' />
        public string ProjectGuid {
            set { project = new System.Guid(value); }
            get { return project.ToString(); }
        }

        /// <include file='doc\ProvideEditorExtensionAttribute.uex' path='docs/doc[@for="ProvideEditorExtensionAttribute.EditorFactoryNotify"]/*' />
        public bool EditorFactoryNotify {
            get { return this.editorFactoryNotify; }
            set { this.editorFactoryNotify = value; }
        }

        /// <include file='doc\ProvideEditorExtensionAttribute.uex' path='docs/doc[@for="ProvideEditorExtensionAttribute.TemplateDir"]/*' />
        public string TemplateDir {
            get { return templateDir; }
            set { templateDir = value; }
        }

        /// <include file='doc\ProvideEditorExtensionAttribute.uex' path='docs/doc[@for="ProvideEditorExtensionAttribute.NameResourceID"]/*' />
        public int NameResourceID {
            get { return resId; }
            set { resId = value; }
        }

        /// <include file='doc\ProvideEditorExtensionAttribute.uex' path='docs/doc[@for="ProvideEditorExtensionAttribute.DefaultName"]/*' />
        public string DefaultName {
            get { return editorName; }
            set { editorName = value; }
        }

        /// <summary>
        ///        The reg key name of this extension.
        /// </summary>
        private string RegKeyName 
        {
            get 
            {
                return string.Format(CultureInfo.InvariantCulture, "Editors\\{0}", Factory.ToString("B"));
            }
        }

        /// <summary>
        ///        The reg key name of the project.
        /// </summary>
        private string ProjectRegKeyName(RegistrationContext context) 
        {
            return string.Format(CultureInfo.InvariantCulture,
                                 "Projects\\{0}\\AddItemTemplates\\TemplateDirs\\{1}",
                                 project.ToString("B"),
                                 context.ComponentType.GUID.ToString("B"));
        }

        private string EditorFactoryNotifyKey {
            get { return string.Format(CultureInfo.InvariantCulture, "Projects\\{0}\\FileExtensions\\{1}",
                                       project.ToString("B"),
                                       Extension);
            }
        }

        /// <include file='doc\ProvideEditorExtensionAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(SR.GetString(SR.Reg_NotifyEditorExtension, Extension, Factory.ToString("B")));

            using (Key editorKey = context.CreateKey(RegKeyName))
            {
                if (!string.IsNullOrEmpty(DefaultName))
                {
                    editorKey.SetValue(null, DefaultName);
                }
                if (0 != resId)
                    editorKey.SetValue("DisplayName", "#" + resId.ToString(CultureInfo.InvariantCulture));
                editorKey.SetValue("Package", context.ComponentType.GUID.ToString("B"));
            }

            using (Key extensionKey = context.CreateKey(RegKeyName + "\\Extensions"))
            {
                extensionKey.SetValue(Extension.Substring(1), Priority);
            }

            // Build the path of the registry key for the "Add file to project" entry
            if (project != Guid.Empty)
            {
                string prjRegKey = ProjectRegKeyName(context) + "\\/1";
                using (Key projectKey = context.CreateKey( prjRegKey ))
                {
                    if (0 != resId)
                        projectKey.SetValue("", "#" + resId.ToString(CultureInfo.InvariantCulture));
                    if (templateDir.Length != 0)
                    {
                        Uri url = new Uri(context.ComponentType.Assembly.CodeBase, true);
                        string templates = url.LocalPath;
                        templates = System.IO.Path.Combine(System.IO.Path.GetDirectoryName(templates), templateDir);
                        templates = context.EscapePath( System.IO.Path.GetFullPath(templates) );
                        projectKey.SetValue("TemplatesDir", templates);
                    }
                    projectKey.SetValue("SortPriority", Priority);
                }
            }

            // Register the EditorFactoryNotify
            if ( EditorFactoryNotify )
            {
                // The IVsEditorFactoryNotify interface is called by the project system, so it doesn't make sense to
                // register it if there is no project associated to this editor.
                if (project == Guid.Empty)
                    throw new ArgumentException(SR.GetString(SR.Attributes_NoPrjForEditorFactoryNotify));

                // Create the registry key
                using (Key edtFactoryNotifyKey = context.CreateKey(EditorFactoryNotifyKey))
                {
                    edtFactoryNotifyKey.SetValue("EditorFactoryNotify", Factory.ToString("B"));
                }
            }
        }

        /// <include file='doc\ProvideEditorExtensionAttribute.uex' path='docs/doc[@for="Unregister"]' />
        /// <devdoc>
        /// Unregister this editor.
        /// </devdoc>
        /// <param name="context"></param>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(RegKeyName);
            if (project != Guid.Empty)
            {
                context.RemoveKey(ProjectRegKeyName(context));
                if (EditorFactoryNotify)
                    context.RemoveKey(EditorFactoryNotifyKey);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\ProvideAutoLoadAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright from='2003' to='2004' company='Microsoft Corporation'>           
//  Copyright (c) Microsoft Corporation, All rights reserved.             
//  This code sample is provided "AS IS" without warranty of any kind, 
//  it is not recommended for use in a production environment.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <summary>
    ///     This attribute registers the package as an extender.  The GUID passed in determines
    ///     what is being extended. The attributes on a package do not control the behavior of
    ///     the package, but they can be used by registration tools to register the proper
    ///     information with Visual Studio.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideAutoLoadAttribute : RegistrationAttribute {

		private Guid loadGuid = Guid.Empty;

		/// <summary>
		///     Specify that the package should get loaded when this context is active.
		/// </summary>
		/// <param name="cmdUiContextGuid">Context which should trigger the loading of your package.</param>
		public ProvideAutoLoadAttribute(string cmdUiContextGuid) 
		{
			loadGuid = new Guid(cmdUiContextGuid);
		}

		/// <summary>
		/// Context Guid which triggers the loading of the package.
		/// </summary>
		public Guid LoadGuid
		{
			get
			{
				return loadGuid;
			}
		}

		/// <summary>
		///		The reg key name of this AutoLoad.
		/// </summary>
		private string RegKeyName 
		{
			get 
			{
				return string.Format(CultureInfo.InvariantCulture, "AutoLoadPackages\\{0}", loadGuid.ToString("B"));
			}
		}

		/// <summary>
		///     Called to register this attribute with the given context.  The context
		///     contains the location where the registration information should be placed.
		///     it also contains such as the type being registered, and path information.
		/// </summary>
		public override void Register(RegistrationContext context) 
		{
			context.Log.WriteLine(SR.GetString(SR.Reg_NotifyAutoLoad, loadGuid.ToString("B")));

			using (Key childKey = context.CreateKey(RegKeyName))
                        {
			    childKey.SetValue(context.ComponentType.GUID.ToString("B"), 0);
			}
		}

		/// <summary>
		/// Unregister this AutoLoad specification.
		/// </summary>
		public override void Unregister(RegistrationContext context)
		{
			context.RemoveValue(RegKeyName, context.ComponentType.GUID.ToString("B"));
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\ProvideAutomationAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideAutomationObjectAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;
    using System.Runtime.InteropServices;
    using Microsoft.Win32;
    
    /// <include file='doc\ProvideAutomationObjectAttribute.uex' path='docs/doc[@for="ProvideAutomationObjectAttribute"]' />
    /// <devdoc>
    ///     This attribute declares that a package provides a particular automation object.  The attributes on a 
    ///     package do not control the behavior of the package, but they can be used by registration 
    ///     tools to register the proper information with Visual Studio.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideAutomationObjectAttribute : RegistrationAttribute {

        private string name;
        private string description;

        /// <include file='doc\ProvideAutomationObjectAttribute.uex' path='docs/doc[@for="ProvideAutomationAttribute.ProvideAutomationObjectAttribute"]' />
        /// <devdoc>
        ///     Creates a new ProvideAutomationObjectAttribute.
        /// </devdoc>
        public ProvideAutomationObjectAttribute(string objectName)
        {
            if (objectName == null) {
                throw new ArgumentNullException("ObjectName");
            }

            name = objectName;
        }

        /// <include file='doc\ProvideAutomationAttribute.uex' path='docs/doc[@for="ProvideAutomationObjectAttribute.Name"]' />
        /// <devdoc>
        ///     Returns the name of the automation object declared in this attribute.
        /// </devdoc>
        public string Name {
            get {
                return name;
            }
        }

        /// <include file='doc\ProvideAutomationObjectAttribute.uex' path='docs/doc[@for="ProvideAutomationObjectAttribute.Description"]' />
        /// <devdoc>
        ///     The description of the automation object declared in this attribute.
        /// </devdoc>
        public string Description 
        {
            get {
                return description;
            }
            set {
                description = value;
            }
         }

        private string GetAutomationRegKey(Guid packageGuid)
        {
            return string.Format(CultureInfo.InvariantCulture, "Packages\\{0}\\Automation", packageGuid.ToString("B"));
        }

        /// <include file='doc\ProvideAutomationObjectAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains information such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) 
        {
            using (Key childKey = context.CreateKey(GetAutomationRegKey(context.ComponentType.GUID)))
            {
                string descValue = (Description == null) ? "" : Description;
                childKey.SetValue(Name, descValue);
            }
        }

        /// <include file='doc\ProvideAutomationObjectAttribute.uex' path='docs/doc[@for="ProvideAutomationObjectAttribute.Unregister"]' />
        /// <devdoc>
        /// Removes the registration information from the registration context.
        /// </devdoc>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(GetAutomationRegKey(context.ComponentType.GUID));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\ProvideEditorLogicalViewAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright from='2003' to='2004' company='Microsoft Corporation'>           
//  Copyright (c) Microsoft Corporation, All rights reserved.             
//  This code sample is provided "AS IS" without warranty of any kind, 
//  it is not recommended for use in a production environment.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Globalization;

namespace Microsoft.VisualStudio.Shell
{
    /// <summary>
    /// This attribute adds a logical view to the editor created by an editor factory.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideEditorLogicalViewAttribute : RegistrationAttribute
    {
        private Guid factory;
        private Guid logicalView;
        private bool isTrusted;

        /// <summary>
        /// Creates a new RegisterEditorLogicalView attribute to register a logical
        /// view provided by your editor.
        /// </summary>
        /// <param name="factoryType">The type of factory; can be a Type, a GUID or a string representation of a GUID</param>
        /// <param name="logicalViewGuid">The guid of the logical view to register.</param>
        public ProvideEditorLogicalViewAttribute(object factoryType, string logicalViewGuid)
        {
            this.isTrusted = true;
            this.logicalView = new Guid(logicalViewGuid);
			
            // figure out what type of object they passed in and get the GUID from it
            if (factoryType is string)
                this.factory = new Guid((string)factoryType);
            else if (factoryType is Type)
                this.factory = ((Type)factoryType).GUID;
            else if (factoryType is Guid)
                this.factory = (Guid)factoryType;
            else
                throw new ArgumentException(SR.GetString(SR.Attributes_InvalidFactoryType, factoryType));

        }

        /// <summary>
        /// Get the Guid representing the type of the editor factory
        /// </summary>
        public Guid FactoryType
        {
            get {return factory;}
        }

        /// <summary>
        /// Get the Guid representing the logical view
        /// </summary>
        public Guid LogicalView
        {
            get {return logicalView;}
        }

        /// <summary>
        /// Get or set the trust flag for this logical view. If a view is not trusted, it can not be opened
        /// from a wizard or automation code.
        /// </summary>
        public bool IsTrusted
        {
            get { return isTrusted; }
            set { isTrusted = value; }
        }

        private string EditorPath
        {
            get { return string.Format(CultureInfo.InvariantCulture, "Editors\\{0}", factory.ToString("B")); }
        }

        private string LogicalViewPath
        {
            get { return string.Format(CultureInfo.InvariantCulture, "{0}\\LogicalViews", EditorPath); }
        }

        private string UntrustedViewsPath
        {
            get { return string.Format(CultureInfo.InvariantCulture, "{0}\\UntrustedLogicalViews", EditorPath); }
        }

        /// <summary>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     It also contains other information such as the type being registered and path information.
        /// </summary>
        public override void Register(RegistrationContext context)
        {
            context.Log.WriteLine(SR.GetString(SR.Reg_NotifyEditorView, logicalView.ToString("B")));

            using (Key childKey = context.CreateKey( LogicalViewPath ))
            {
                childKey.SetValue(logicalView.ToString("B"), "");
            }

            // Check if this view can be trusted for automation code.
            if (!IsTrusted)
            {
                // This logical view is not trusted, so we have to add it to the list of the untrusted ones.
                using (Key untrustedViewsKey = context.CreateKey(UntrustedViewsPath))
                {
                    untrustedViewsKey.SetValue(logicalView.ToString("B"), "");
                }

                // Now we should to check the trust level of the editor: if it has an untrusted view its tust
                // level can not be full trust. The problem is that the Key object provided by the context has
                // no GetValue method, so we can not do any check on the previous value of the trust level and
                // all we can do is overwrite it with ETL_HasUntrustedLogicalViews.
                using (Key editorKey = context.CreateKey(EditorPath))
                {
                    editorKey.SetValue("EditorTrustLevel", (int)Microsoft.VisualStudio.Shell.Interop.__VSEDITORTRUSTLEVEL.ETL_HasUntrustedLogicalViews);
                }
            }
        }

        /// <summary>
        /// Unregister this logical view.
        /// </summary>
        /// <param name="context"></param>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveValue(LogicalViewPath, logicalView.ToString("B"));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\Package.cs ===
//------------------------------------------------------------------------------
// <copyright file="Package.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell.Interop;
    using Microsoft.Win32;
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Drawing.Design;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.Globalization;
    using System.IO;
    using System.Reflection;
    using System.Resources;
    using System.Runtime.InteropServices;
    using System.Threading;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using System.Drawing;

    using AssemblyEnumerationService = Microsoft.VisualStudio.AssemblyEnumerationService;
    using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
    using IServiceProvider = System.IServiceProvider;

    /// <include file='doc\Package.uex' path='docs/doc[@for="Package"]' />
    /// <devdoc>
    ///     This class implements IVsPackage.  It provides a 
    ///     framework-friendly way to define a package and its associated 
    ///     services.
    /// </devdoc>
    [PackageRegistrationAttribute()]
    [CLSCompliant(false)]
    [System.Runtime.InteropServices.ComVisible(true)]
    public abstract class Package : 

        IVsPackage, 
        IOleServiceProvider,
        IOleCommandTarget,
        IVsPersistSolutionOpts, 
        IServiceContainer,
        IVsUserSettings,
        IVsToolWindowFactory
    {

        static private int          _sitedPackageCount = 0;
        static private ServiceProvider _globalProvider = null;
        private ServiceProvider     _provider;
        private Hashtable           _services;
        private Hashtable           _editorFactories;
        private Hashtable           _projectFactories;
        private Hashtable           _toolWindows;          // this is the list of all toolwindows
        private Container           _componentToolWindows; // this is the toolwindows that implement IComponent
        private Container           _pagesAndProfiles;
        private ArrayList           _optionKeys;

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.Package"]' />
        /// <devdoc>
        ///     Simple constructor.
        /// </devdoc>
        protected Package() {
            ServiceCreatorCallback callback = new ServiceCreatorCallback(OnCreateService);
            ((IServiceContainer)this).AddService(typeof(IMenuCommandService), callback);
            ((IServiceContainer)this).AddService(typeof(IOleCommandTarget), callback);
        }
    
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.ToolboxInitialized"]' />
        /// <devdoc>
        ///     This event is raised when the toolbox is freshly initialized.
        ///     If you provide tools for the toolbox you should add them when
        ///     this event is raised.
        /// </devdoc>
        protected event EventHandler ToolboxInitialized;
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.ToolboxUpgraded"]' />
        /// <devdoc>
        ///     This event is raised when the toolbox is upgraded to a
        ///     new version.  You should perform any work needed to
        ///     upgrade the toolbox here.
        /// </devdoc>
        protected event EventHandler ToolboxUpgraded;
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.ApplicationRegistryRoot"]' />
        /// <devdoc>
        ///     This property returns the registry root for the application.
        ///     Typically this is HKLM\Software\Microsoft\VisualStudio\[ver]
        ///     but this can change based on any alternate root that the
        ///     shell was initialized with.  This key is read-only.
        /// </devdoc>
        public RegistryKey ApplicationRegistryRoot {
            get {
                return Registry.LocalMachine.OpenSubKey(GetRegistryRoot());
            }
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.UserDataPath"]' />
        /// <devdoc>
        ///     This property returns the path to user data storage for
        ///     Visual Studio.  Typically this is %USERPROFILE%\Application Data\
        ///     Visual Studio\[ver] but this can change based on any
        ///     alternate root that the shell was initialized with.
        /// </devdoc>
        public string UserDataPath {
            get {
                // Get the registry root and remove the SOFTWARE\ part
                string registryRoot = GetRegistryRoot();
                registryRoot = registryRoot.Substring("SOFTWARE\\".Length);
    
                string appData = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
    
                return Path.Combine(appData, registryRoot);
            }
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.UserDataPath"]' />
        /// <devdoc>
        ///     This property returns the path to user data storage for
        ///     Visual Studio.  Typically this is %USERPROFILE%\Local Settings\Application Data\
        ///     Visual Studio\[ver] but this can change based on any
        ///     alternate root that the shell was initialized with.
        /// </devdoc>
        public string UserLocalDataPath {
            get {
                // Get the registry root and remove the SOFTWARE\ part
                string registryRoot = GetRegistryRoot();
                registryRoot = registryRoot.Substring("SOFTWARE\\".Length);
    
                string appData = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
    
                return Path.Combine(appData, registryRoot);
            }
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.UserRegistryRoot"]' />
        /// <devdoc>
        ///     This property returns the registry root for the current
        ///     user.  Typically this is HKCU\Software\Microsoft\VisualStudio\[ver]
        ///     but this can change based on any alternate root that the shell
        ///     is initialized with.  This key is read-write.
        /// </devdoc>
        public RegistryKey UserRegistryRoot {
            get {
                return Registry.CurrentUser.OpenSubKey(GetRegistryRoot(), true /* writable */);
            }
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.AddOptionKey"]' />
        /// <devdoc>
        ///     This method adds a user option key name into the list of
        ///     option keys that we will load and save from the solution
        ///     file.  You should call this early in your constructor.
        ///     Calling this will cause the OnLoadOptions and
        ///     OnSaveOptions methods to be invoked for each key you
        ///     add.
        /// </devdoc>
        protected void AddOptionKey(string name) {
            if (zombie)
                Marshal.ThrowExceptionForHR(NativeMethods.E_UNEXPECTED);

            if (name == null) {
                throw new ArgumentNullException("name");
            }

            // the key is the class name of the service interface.  Note that
            // while it would be a lot more correct to use the fully-qualified class
            // name, IStorage won't have it and returns STG_E_INVALIDNAME.  The
            // doc's don't have any information here; I can only assume it is because
            // of the '.'.

            // clovett: According to the docs for IStorage::CreateStream, the name
            // cannot be longer than 31 characters.
            if (name.IndexOf('.') != -1 || name.Length > 31) {
                throw new ArgumentException(SR.GetString(SR.Package_BadOptionName, name));
            }

            if (_optionKeys == null) {
                _optionKeys = new ArrayList();
            }
            else {
                if (_optionKeys.Contains(name)) {
                    throw new ArgumentException(SR.GetString(SR.Package_OptionNameUsed, name));
                }
            }
            _optionKeys.Add(name);
        }



        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.ExportSettings"]' />
        /// <devdoc>
        ///     This method implements the IVsUserSettings Interface
        ///     used to manage profiles and import/export settings
        ///     to XML files.
        /// </devdoc>
        int IVsUserSettings.ExportSettings(string strPageGuid, IVsSettingsWriter writer) {
            Debug.Assert(strPageGuid != null && strPageGuid.Length > 0, "Passed page guid cannot be null");
            Debug.Assert(writer != null, "IVsSettingsWriter cannot be null");

            Guid requestPageGuid = new Guid(strPageGuid);
            IProfileManager profileManager = GetProfileManager(requestPageGuid, true);
            if(profileManager != null) {
                profileManager.SaveSettingsToXml(writer);
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.ImportSettings"]' />
        /// <devdoc>
        ///     This method implements the IVsUserSettings Interface
        ///     used to manage profiles and import/export settings
        ///     to XML files.
        /// </devdoc>
        int IVsUserSettings.ImportSettings(string strPageGuid, IVsSettingsReader reader, uint flags, ref int restartRequired) {
            
            // nobody should require a restart...
            if(restartRequired > 0)
                restartRequired = 0;

            Debug.Assert(strPageGuid != null && strPageGuid.Length > 0, "Passed page guid cannot be null");
            Debug.Assert(reader != null, "IVsSettingsReader cannot be null");

            bool loadPropsFromRegistry = (flags & (uint)__UserSettingsFlags.USF_ResetOnImport) == 0;

            Guid requestPageGuid = new Guid(strPageGuid);
            IProfileManager profileManager = GetProfileManager(requestPageGuid, loadPropsFromRegistry);
            if(profileManager != null) {
                // we get the live instance (if any) when we load
                profileManager.LoadSettingsFromXml(reader);
                // update the store
                profileManager.SaveSettingsToStorage();
            }
            return NativeMethods.S_OK;
        }


        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.Dispose"]' />
        /// <devdoc>
        ///     This method will be called by Visual Studio in reponse
        ///     to a package close (disposing will be true in this
        ///     case).  The default implementation revokes all
        ///     services and calls Dispose() on any created services
        ///     that implement IDisposable.
        /// </devdoc>
        [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        protected virtual void Dispose(bool disposing) {
            if (disposing) {

                // Unregister any registered editor factories.
                //
                if (_editorFactories != null)
                {
                    Hashtable editorFactories = _editorFactories;
                    _editorFactories = null;

                    try {
                        IVsRegisterEditors registerEditors = GetService(typeof(SVsRegisterEditors)) as IVsRegisterEditors;
                        foreach (DictionaryEntry de in editorFactories) {
                            try {
                                if (registerEditors != null) {
                                    // Don't check for the return value because, even if this unregister fails,
                                    // we have anyway to try to unregister the others.
                                    registerEditors.UnregisterEditor((uint)de.Value);
                                }
                            }
                            catch (Exception) { /* do nothing */ }
                            finally {
                                IDisposable disposable = de.Key as IDisposable;
                                if (disposable != null) {
                                    disposable.Dispose();
                                }
                            }
                        }
                    }
                    catch (Exception e) {
                        Debug.Fail(String.Format("Failed to dispose editor factories for package {0}\n{1}", this.GetType().FullName, e.Message));
                    }
                }
                // Unregister any registered project factories.
                //
                if (_projectFactories != null)
                {
                    Hashtable projectFactories = _projectFactories;
                    _projectFactories = null;
                    try
                    {
                        IVsRegisterProjectTypes registerProjects = GetService(typeof(SVsRegisterProjectTypes)) as IVsRegisterProjectTypes;

                        foreach (DictionaryEntry de in projectFactories)
                        {
                            try
                            {
                                if (registerProjects != null)
                                {
                                    // As above, don't check for the return value.
                                    registerProjects.UnregisterProjectType((uint)de.Value);
                                }
                            }
                            finally
                            {
                                IDisposable disposable = de.Key as IDisposable;
                                if (disposable != null)
                                {
                                    disposable.Dispose();
                                }
                            }
                        }
                    }
                    catch (Exception e)
                    {
                        Debug.Fail(String.Format("Failed to dispose project factories for package {0}\n{1}", this.GetType().FullName, e.Message));
                    }
                }

                // Dispose all IComponent ToolWindows
                //
                if (_componentToolWindows != null)
                {
                    Container componentToolWindows = _componentToolWindows;
                    _componentToolWindows = null;
                    try
                    {
                        componentToolWindows.Dispose();
                    }
                    catch (Exception e)
                    {
                        Debug.Fail(String.Format("Failed to dispose component toolwindows for package {0}\n{1}", this.GetType().FullName, e.Message));
                    }
                }

                // Dispose all pages.
                //
                if (_pagesAndProfiles != null)
                {
                    Container pagesAndProfiles = _pagesAndProfiles;
                    _pagesAndProfiles = null;
                    try
                    {
                        pagesAndProfiles.Dispose();
                    }
                    catch (Exception e)
                    {
                        Debug.Fail(String.Format("Failed to dispose component toolwindows for package {0}\n{1}", this.GetType().FullName, e.Message));
                    }
                }

                // Enumerate the service list and destroy all services.  This should
                // always be done last.
                //
                if (_services != null)
                {
                    try
                    {
                        IProfferService ps = (IProfferService)GetService(typeof(SProfferService));
                        Hashtable services = _services;
                        _services = null;

                        foreach (object value in services.Values)
                        {

                            object service = value;
                            ProfferedService proffer = service as ProfferedService;
                            try
                            {
                                if (null != proffer)
                                {
                                    service = proffer.Instance;
                                    if (proffer.Cookie != 0 && ps != null)
                                    {
                                        int hr = ps.RevokeService(proffer.Cookie);
                                        if (NativeMethods.Failed(hr))
                                        {
                                            Debug.Fail(String.Format(CultureInfo.CurrentUICulture, "Failed to unregister service {0}", service.GetType().FullName));
                                            Trace.WriteLine(String.Format(CultureInfo.CurrentUICulture, "Failed to unregister service {0}", service.GetType().FullName));
                                        }
                                    }
                                }
                            }
                            finally
                            {
                                if (service is IDisposable)
                                {
                                    ((IDisposable)service).Dispose();
                                }
                            }
                        }
                    }
                    catch (Exception e)
                    {
                        Debug.Fail(String.Format("Failed to dispose proffered service for package {0}\n{1}", this.GetType().FullName, e.Message));
                    }
                }

                // Disallow any service requests after this.
                //
                if (_provider != null)
                {
                    // If the service provider for the current package is the service provider that we use globally
                    // do not dispose yet. Once all packages deriving from Package are disposed we will dispose it.
                    if (_provider != _globalProvider)
                    {
                        try
                        {
                            _provider.Dispose();
                        }
                        catch (Exception e)
                        {
                            Debug.Fail(String.Format("Failed to dispose the global service provider for package {0}\n{1}", this.GetType().FullName, e.Message));
                        }
                    }
                    _provider = null;
                }

                if (_toolWindows != null)
                {
                    _toolWindows = null;
                }

                if (_optionKeys != null)
                {
                    _optionKeys = null;
                }

                // Disconnect user preference change events
                //
                SystemEvents.UserPreferenceChanged -= new UserPreferenceChangedEventHandler(OnUserPreferenceChanged);
            }
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.GetAutomationObject"]' />
        /// <devdoc>
        ///     This method returns the automation object for this package.
        ///     The default implementation will return null if name is null, indicating there
        ///     is no default automation object.  If name is non null, this will walk metadata
        ///     attributes searching for an option page that has a name of the format
        ///     &lt;Category&gt;.&lt;Name&gt;.  If the option page has this format and indicates that it
        ///     supports automation, its automation object will be returned.
        /// </devdoc>
        protected virtual object GetAutomationObject(string name) {
            if (zombie)
                Marshal.ThrowExceptionForHR(NativeMethods.E_UNEXPECTED);

            if (name == null) {
                return null;
            }

            string[] nameParts = name.Split(new char[] {'.'});
            if (nameParts.Length != 2) {
                return null;
            }

            nameParts[0] = nameParts[0].Trim();
            nameParts[1] = nameParts[1].Trim();

            AttributeCollection attributes = TypeDescriptor.GetAttributes(this);
            foreach(Attribute attr in attributes) {
                ProvideOptionPageAttribute pa = attr as ProvideOptionPageAttribute;
                if (pa != null && pa.SupportsAutomation) {

                    // Check to see if the name matches.
                    //
                    if (string.Compare(pa.CategoryName, nameParts[0], StringComparison.OrdinalIgnoreCase) != 0) {
                        continue;
                    }

                    if (string.Compare(pa.PageName, nameParts[1], StringComparison.OrdinalIgnoreCase) != 0) {
                        continue;
                    }

                    // Ok, the name matches.  Return this page's automation object.
                    //
                    DialogPage page = GetDialogPage(pa.PageType);
                    return page.AutomationObject;
                }
            }

            // Failed.
            //
            return null;
        }

        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.GetDialogPage"]' />
        /// <devdoc>
        ///     This method returns the requested dialog page.  Dialog
        ///     pages are cached so they can keep a single instance
        ///     of their state.  This method allows a deriving class
        ///     to get a cached dialog page.  The object will be 
        ///     dynamically created if it is not in the cache.
        /// </devdoc>
        protected DialogPage GetDialogPage(Type dialogPageType) {
            if (zombie)
                Marshal.ThrowExceptionForHR(NativeMethods.E_UNEXPECTED);

            if (dialogPageType == null) {
                throw new ArgumentNullException("dialogPageType");
            }

            if (!typeof(DialogPage).IsAssignableFrom(dialogPageType)) {
                throw new ArgumentException(SR.GetString(SR.Package_BadDialogPageType, dialogPageType.FullName));
            }

            if (_pagesAndProfiles != null) {
                foreach(object page in _pagesAndProfiles.Components) {
                    if (page.GetType() == dialogPageType) {
                        return (DialogPage)page;
                    }
                }
            }

            // Create a new instance of this option page.
            //
            ConstructorInfo ctor = dialogPageType.GetConstructor(new Type[] {});
            if (ctor == null) {
                throw new ArgumentException(SR.GetString(SR.Package_PageCtorMissing, dialogPageType.FullName));
            }

            DialogPage p = (DialogPage)ctor.Invoke(new object[] {});
            
                        
            if (_pagesAndProfiles == null) {
                _pagesAndProfiles = new PackageContainer(this);
            }
            _pagesAndProfiles.Add(p);

            return p;
        }


        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.GetProfileManager"]' />
        /// <devdoc>
        ///     This method returns the requested profile manager based on its guid.
        ///     Profile managers are cached so they can keep a single instance
        ///     of their state.  This method allows a deriving class
        ///     to get a cached profile manager.  The object will be 
        ///     dynamically created if it is not in the cache.
        /// </devdoc>
        private IProfileManager GetProfileManager(Guid objectGuid, bool loadPropsFromRegistry) {
            
            IProfileManager result = null;

            if(objectGuid == Guid.Empty) {
                throw new ArgumentNullException("objectGuid");
            }
            if (_pagesAndProfiles != null) {
                foreach(object profileManager in _pagesAndProfiles.Components) {
                    if (profileManager.GetType().GUID.Equals(objectGuid)) {
                        if (profileManager is IProfileManager)
                        {
                            result = profileManager as IProfileManager;
                            if (result != null)
                            {
                                if (loadPropsFromRegistry) {
                                    result.LoadSettingsFromStorage();
                                } else {
                                    result.ResetSettings();
                                }
                            }
                        }

                        // No need to keep on looking in the attributes since
                        // we've found the one we were looking for.

                        break;
                    }
                }
            }

            if (result == null) {

                // Didn't find it in our cache.  Now look in the metadata attributes
                // for the class.  Look at all types at the same time.
                //
                AttributeCollection attributes = TypeDescriptor.GetAttributes(this);
                foreach(Attribute attr in attributes) {
                    if (attr is ProvideProfileAttribute) {
                        Type objectType = ((ProvideProfileAttribute)attr).ObjectType;
                        if (objectType.GUID.Equals(objectGuid)) {

                            // found it... now instanciate since it was not in the cache
                            // if not build a constructor for it

                            ConstructorInfo ctor = objectType.GetConstructor(new Type[] {});
                            if (ctor == null) {
                                throw new ArgumentException(SR.GetString(SR.Package_PageCtorMissing, objectType.FullName));
                            }
                            result = (IProfileManager)ctor.Invoke(new object[] {});

                            // if it's a DialogPage cache it
                            if(result != null) {
                                if(_pagesAndProfiles == null) {
                                    _pagesAndProfiles = new PackageContainer(this);
                                }
                                _pagesAndProfiles.Add((IComponent)result);
                            }

                            // No need to load settings from storage on first creation
                            // since that happens because of the Add above.

                            break;
                        }
                    }
                }
            }
            return result;
        }

        
        /// <devdoc>
        ///     Retrieves the shell's root key for VS options, or uses the value of
        ///     the DefaultRegistryRootAttribute if we coundn't get the shell service.
        /// </devdoc>
        private string GetRegistryRoot() {
            string regisrtyRoot;
    
            IVsShell vsh = (IVsShell)GetService(typeof(SVsShell));
            if (vsh == null) {
                // Search our custom attributes for an instance of DefaultRegistryRoot
                //
                DefaultRegistryRootAttribute regRootAttr = (DefaultRegistryRootAttribute)TypeDescriptor.GetAttributes(this.GetType())[typeof(DefaultRegistryRootAttribute)];
                if (regRootAttr == null) {
                    Debug.Fail("Package should have a registry root attribute");
                    throw new NotSupportedException();
                }
    
                regisrtyRoot = @"SOFTWARE\Microsoft\VisualStudio\" + regRootAttr.Root;
            }
            else {
                object obj;
                NativeMethods.ThrowOnFailure( vsh.GetProperty((int)__VSSPROPID.VSSPROPID_VirtualRegistryRoot, out obj) );
                regisrtyRoot = obj.ToString();
            }
    
            return regisrtyRoot;
        }
    
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.GetService"]' />
        /// <devdoc>
        ///     IServiceProvider implementation.
        /// </devdoc>
        protected object GetService(Type serviceType) {
            if (zombie)
                return null;

            if (serviceType == null) {
                throw new ArgumentNullException("serviceType");
            }

            // Check for the sepecial services we provide.
            //
            if (serviceType == typeof(IServiceContainer) || serviceType == typeof(Package) || serviceType == this.GetType()) {
                return this;
            }

            object value = null;

            // Check our service list
            //
            if (_services != null) {
                lock (serviceType) {
                    value = _services[serviceType];

                    if (value is ProfferedService) {
                        value = ((ProfferedService)value).Instance;
                    }

                    if (value is ServiceCreatorCallback) {

                        // In case someone recursively requests the same service, 
                        // null out the service type here.  That way they'll just
                        // fail instead of stack fault.
                        //
                        _services[serviceType] = null;

                        value = ((ServiceCreatorCallback)value)(this, serviceType);
                        if (value != null && !value.GetType().IsCOMObject && !serviceType.IsAssignableFrom(value.GetType())) {
                            // Callback passed us a bad service.  NULL it, rather than throwing an exception.
                            // Callers here do not need to be prepared to handle bad callback implemetations.
                            Debug.Fail("Object " + value.GetType().Name + " was returned from a service creator callback but it does not implement the registered type of " + serviceType.Name);
                            value = null;
                        }
                        _services[serviceType] = value;
                    }
                }
            }

            // Delegate to the parent provider, but only if we have verified that _services doesn't actually contain our key
            // if it does, that means that we're in the middle of trying to resolve this service, and the service resolution
            // has recursed.
            //
            Debug.Assert(value != null || _services == null || !_services.ContainsKey(serviceType), "GetService is recursing on itself while trying to resolve the service " + serviceType.Name + ". This means that someone is asking for this service while the service is trying to create itself.  Breaking the recursion now and aborting this GetService call.");
            if (value == null && _provider != null && (_services == null || !_services.ContainsKey(serviceType))) {
                value = _provider.GetService(serviceType);
            }

            return value;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.Initialize"]/*' />
        /// <devdoc>
        /// This method is called when the package is first 
        /// initialized.  Override it if you need to do work
        /// that happens as part of package initialization.
        /// </devdoc>
        protected virtual void Initialize() {
            // If we have services to proffer, do that now.
            //
            if (_services != null)
            {

                IProfferService ps = (IProfferService)GetService(typeof(SProfferService));

                Debug.Assert(ps != null, "We have services to proffer but IProfferService is not available.");
                if (ps != null) {

                    foreach(DictionaryEntry de in _services) {
                        ProfferedService service = de.Value as ProfferedService;

                        if (service != null) {
                            Type serviceType = (Type)de.Key;
                            uint cookie;
                            Guid serviceGuid = (Guid)serviceType.GUID;
                            NativeMethods.ThrowOnFailure(
                                ps.ProfferService(ref serviceGuid, this, out cookie)
                            );
                            service.Cookie= cookie;
                        }
                    }
                }
            }

            // Initialize this thread's culture info with that of the shell's LCID
            //
            int locale = GetProviderLocale();
            Thread.CurrentThread.CurrentUICulture = new CultureInfo(locale);

            // Begin listening to user preference change events
            //
            SystemEvents.UserPreferenceChanged += new UserPreferenceChangedEventHandler(OnUserPreferenceChanged);
            
            // Be sure to load the package user options from the solution in case
            // the package was not already loaded when the solution was opened.
            if (null != _optionKeys)
            {
                try {
                    IVsSolutionPersistence pPersistance = (IVsSolutionPersistence)this.GetService(typeof(SVsSolutionPersistence));
                    if (pPersistance != null) {
                        foreach (string key in _optionKeys) {
                            // NOTE: don't check for the error code because a failure here is
                            // expected and not a problem.
                            pPersistance.LoadPackageUserOpts(this, key);
                        }
                    }
                } catch (Exception) {
                    // no settings found, no problem.
                }
            }
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.QueryClose"]/*' />
        /// <devdoc>
        /// Called to ask the package if the shell can be closed.
        /// </devdoc>
        /// <param name="canClose">Set canClose to false if you want to prevent the shell from closing</param>
        /// <returns>HRESULT</returns>
        protected virtual int QueryClose(out bool canClose)
        {
            canClose = true;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.GetProviderLocale"]' />
        /// <devdoc>
        /// Return the locale associated with this IServiceProvider.
        /// </devdoc>
        public int GetProviderLocale() {
            CultureInfo ci = CultureInfo.CurrentCulture;
            int lcid = ci.LCID;
            IUIHostLocale loc = (IUIHostLocale)GetService(typeof(IUIHostLocale));
            Debug.Assert(loc != null, "Unable to get IUIHostLocale, defaulting CLR designer to current thread LCID");
            if (loc != null) {
                uint locale;
                NativeMethods.ThrowOnFailure(loc.GetUILocale(out locale));
                lcid = (int)locale;
            }
            return lcid;
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.CreateInstance"]/*' />
        /// <devdoc>
        /// Create the specified COM object using Visual Studio's ILocalRegistry
        /// and cast it to the given managed type.  If VS cannot create it, then
        /// fall back to Activator.CreateInstance.  This allows managed classes
        /// to be registered in local to the particular VS version in 
        /// HKLM\Software\Microsoft\VisualStudio\9.0\clsid.
        /// </devdoc>
        public object CreateInstance(ref Guid clsid, ref Guid iid, Type type) {
            object result = null;
            IntPtr pUnk = this.CreateInstance(ref clsid, ref iid);
            if (pUnk != IntPtr.Zero) {
                try {
                    result = Marshal.GetTypedObjectForIUnknown(pUnk, type);
                } finally {
                    Marshal.Release(pUnk);
                }
            } else {
                result = Activator.CreateInstance(type);
            }
            return result;
        }

        private IntPtr CreateInstance(ref Guid clsid, ref Guid iid) {
            ILocalRegistry3 localRegistry = this.GetService(typeof(SLocalRegistry)) as ILocalRegistry3;
            IntPtr pUnk;
            NativeMethods.ThrowOnFailure(localRegistry.CreateInstance(clsid, null, ref iid, NativeMethods.CLSCTX_INPROC_SERVER, out pUnk));
            localRegistry = null;
            return pUnk;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.GetOutputPane"]/*' />
        /// <devdoc>
        /// Return the specified output window pane.  If the pane is not found, 
        /// create it with the given caption.
        /// </devdoc>
        public IVsOutputWindowPane GetOutputPane(Guid page, string caption) {
            IVsOutputWindow outputWindow = this.GetService(typeof(SVsOutputWindow)) as IVsOutputWindow;
            Debug.Assert(outputWindow != null, "Cannot find IVsOutputWindow");
            IVsOutputWindowPane pane = null;
            int hr = outputWindow.GetPane(ref page, out pane);
            if ( NativeMethods.Failed(hr) )
            {
                if (caption != null) {
                    hr = outputWindow.CreatePane(ref page, caption, 1, 1);
                    if ( NativeMethods.Succeeded(hr) ) {
                        // Don't throw or fail here: a null pane is an expected value.
                        outputWindow.GetPane(ref page, out pane);
                    }
                }
            }
            if (pane != null) 
                NativeMethods.ThrowOnFailure( pane.Activate() );
            return pane;
        }

        /// <devdoc>
        ///     ServiceCreatorCallback implementation for the services we offer on demand.
        /// </devdoc>
        private object OnCreateService(IServiceContainer container, Type serviceType) {

            // Menu commands.  IOleCommandTarget is implemented on IMenuCommandService,
            // so we offer both as services and delegate the creation of IOleCommandTarget
            // to IMenuCommandService.
            //
            if (serviceType == typeof(IOleCommandTarget)) {
                object commandService = GetService(typeof(IMenuCommandService));
                if (commandService is IOleCommandTarget) {
                    return commandService;
                }
                Debug.Fail("IMenuCommandService is either unavailable or does not implement IOleCommandTarget");
            }
            else if (serviceType == typeof(IMenuCommandService)) {
                return new OleMenuCommandService(this);
            }

            Debug.Fail("OnCreateService invoked for a service we didn't add");
            return null;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.OnLoadOptions"]/*' />
        /// <devdoc>
        /// This method can be overridden by the deriving
        /// class to load solution options.
        /// </devdoc>
        protected virtual void OnLoadOptions(string key, Stream stream) {
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.OnSaveOptions"]/*' />
        /// <devdoc>
        /// This method can be overridden by the deriving
        /// class to save solution options.
        /// </devdoc>
        protected virtual void OnSaveOptions(string key, Stream stream) {
        }

        /// <devdoc>
        ///     Invoked when a user setting has changed.  Here we invalidate
        ///     the cached locale data so we can obtain updated culture information.
        /// </devdoc>
        private void OnUserPreferenceChanged(object sender, UserPreferenceChangedEventArgs e) {
            if (e.Category == UserPreferenceCategory.Locale) {
                CultureInfo.CurrentCulture.ClearCachedData();
            }
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.ParseToolboxResource"]/*' />
        /// <devdoc>
        /// Parses a toolbox resource format and adds the toolbox items to the toolbox.  This
        /// method can be used to automatically add items to the toolbox.  The resource data
        /// is passed in through the resourceData parameter and consists of a text file with
        /// the following format:
        /// ; Comment
        /// [CategoryName]
        /// &lt;class name&gt;, &lt;assembly name&gt;
        /// The category name can be localized through the localizedCategorized resource
        /// manager that is passed into this method.  The localizedCategories parameter
        /// may be null, in which case the category names will not be localized.
        /// The assembly name may either be a fully qualified name, or a partial name.
        /// If a partial name is passed, the latest assembly of that partial name will
        /// be loaded.
        /// </devdoc>
        protected void ParseToolboxResource(TextReader resourceData, ResourceManager localizedCategories) {
            ParseToolboxResource(resourceData, localizedCategories, Guid.Empty);
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.ParseToolboxResource"]/*' />
        /// <devdoc>
        /// Parses a toolbox resource format and adds the toolbox items to the toolbox.  This
        /// method can be used to automatically add items to the toolbox.  The resource data
        /// is passed in through the resourceData parameter and consists of a text file with
        /// the following format:
        /// ; Comment
        /// [CategoryName]
        /// &lt;class name&gt;, &lt;assembly name&gt;
        /// The category name can be localized through the localizedCategorized resource
        /// manager that is passed into this method.  The localizedCategories parameter
        /// may be null, in which case the category names will not be localized.
        /// The assembly name may either be a fully qualified name, or a partial name.
        /// If a partial name is passed, the latest assembly of that partial name will
        /// be loaded.
        /// </devdoc>
        protected void ParseToolboxResource(TextReader resourceData, Guid packageGuid) {
            ParseToolboxResource(resourceData, null, packageGuid);
        }


        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.ParseToolboxResource"]/*' />
        /// <devdoc>
        /// Parses a toolbox resource format and adds the toolbox items to the toolbox.  This
        /// method can be used to automatically add items to the toolbox.  The resource data
        /// is passed in through the resourceData parameter and consists of a text file with
        /// the following format:
        /// ; Comment
        /// [CategoryName]
        /// &lt;class name&gt;, &lt;assembly name&gt;
        /// The category name can be localized through the localizedCategorized resource
        /// manager that is passed into this method.  The localizedCategories parameter
        /// may be null, in which case the category names will not be localized.
        /// The assembly name may either be a fully qualified name, or a partial name.
        /// If a partial name is passed, the latest assembly of that partial name will
        /// be loaded.
        /// </devdoc>
        private void ParseToolboxResource(TextReader resourceData, ResourceManager localizedCategories, Guid packageGuid) {

            if (resourceData == null) {
                throw new ArgumentNullException("resourceData");
            }

            IToolboxService tbx = GetService(typeof(IToolboxService)) as IToolboxService;
            if (tbx == null) {
                Debug.Fail("Missing toolbox service");
                throw new InvalidOperationException(SR.GetString(SR.General_MissingService, typeof(IToolboxService).FullName));
            }

            IVsToolbox vstbx = GetService(typeof(SVsToolbox)) as IVsToolbox;
            IVsToolbox2 vsToolbox2 = vstbx as IVsToolbox2;
            IVsToolbox3 vsToolbox = vstbx as IVsToolbox3;
            if (vsToolbox == null) {
                Debug.Fail("Missing VS toolbox service");
                throw new InvalidOperationException(SR.GetString(SR.General_MissingService, typeof(SVsToolbox).FullName));
            }

            string line = resourceData.ReadLine();
            string currentCategory = null;
            string rawCategory = null;

            while(line != null) {

                try
                {
                    line = line.Trim();

                    if (line.Length != 0)
                    {
                        if (line.StartsWith(";", StringComparison.OrdinalIgnoreCase))
                        {
                            // Ignore this comment
                        }
                        else if (line.StartsWith("[", StringComparison.OrdinalIgnoreCase) && line.EndsWith("]", StringComparison.OrdinalIgnoreCase))
                        {

                            // This line is a toolbox category name.  Create a new category.
                            //
                            currentCategory = line.Trim(new char[] { '[', ']' }).Trim();
                            rawCategory = currentCategory;

                            if (localizedCategories != null) {
                                string locCategory = localizedCategories.GetString(currentCategory);
                                if (locCategory == null) {
                                    Debug.Fail("Category name " + currentCategory + " has not been localized");
                                }
                                else {
                                    currentCategory = locCategory;
                                }
                            }

                            bool categoryAdded = false;
                            if (!String.IsNullOrEmpty(currentCategory)) {
                                if (packageGuid != Guid.Empty && vsToolbox2 != null) {
                                    vsToolbox2.AddTab2(currentCategory, ref packageGuid);   //represents a native resource when package is sent in.
                                    if (!String.IsNullOrEmpty(rawCategory) && vsToolbox != null)
                                    {
                                        vsToolbox.SetIDOfTab(currentCategory, packageGuid.ToString("B") + "-" + rawCategory);
                                        rawCategory = null;
                                    }
                                    categoryAdded = true;
                                }
                                else if (vstbx != null) {
                                    //add the tab -- even if there are no items...
                                    vstbx.AddTab(currentCategory);
                                    categoryAdded = true;
                                }
                                if (categoryAdded && !String.IsNullOrEmpty(rawCategory) && vsToolbox != null)
                                {
                                    vsToolbox.SetIDOfTab(currentCategory, rawCategory);
                                    rawCategory = null;
                                }
                            }
                        }
                        else {

                            // The line is a toolbox item class.  Discover the type.  The
                            // type name is an assembly qualified name.  If it is fully 
                            // qualified we can load it directly.  If it isn't, then we must use the
                            // sdk enumeration service to find the assembly with the matching name.
                            // This allows toolbox item providers to list simple names in their toolbox item
                            // definition files, but do a strong bind.
                            //
                            int idx = line.IndexOf(",");
                            if (idx == -1)
                            {
                                Debug.Fail("Bad line: " + line);
                            }
                            else
                            {
                                string typeName = line.Substring(0, idx).Trim();
                                string assemblyName = line.Substring(idx + 1).Trim();

                                if (assemblyName.IndexOf(",") == -1)
                                {
                                    // Must use the assembly enumeration service to locate the
                                    // assembly.
                                    AssemblyEnumerationService enumSvc = new AssemblyEnumerationService(this);
                                    foreach (AssemblyName an in enumSvc.GetAssemblyNames(assemblyName))
                                    {
                                        assemblyName = an.FullName;
                                        break;
                                    }
                                }

                                Assembly a = Assembly.Load(assemblyName);
                                Debug.Assert(a != null, "Assembly " + assemblyName + " not found on machine");

                                if (a != null)
                                {
                                    Type t = a.GetType(typeName);
                                    Debug.Assert(t != null, "Type " + typeName + " not found on machine");
                                    if (t != null)
                                    {
                                        ToolboxItem item = ToolboxService.GetToolboxItem(t);
                                        Debug.Assert(item != null, "Tool " + line + " does not offer a toolbox item");
                                        if (item != null)
                                        {

                                            if (currentCategory == null)
                                            {
                                                tbx.AddToolboxItem(item);
                                            }
                                            else
                                            {
                                                tbx.AddToolboxItem(item, currentCategory);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    Debug.Fail("Exception during toolbox processing: " + ex.ToString());
                }
                catch
                {
                    Debug.Fail("Exception during toolbox processing");
                }

                line = resourceData.ReadLine();
            }
        }


        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.RegisterEditorFactory"]/*' />
        /// <devdoc>
        /// Registers this editor factory with Visual Studio.
        /// If you are providing an editor factory, you should register
        /// it by overriding the Initialize method. Call 
        /// base.Initialize first, and then call RegisterEditorFactory
        /// for each editor factory.  There is no need to unregister
        /// an editor factory as Package will handle this for you.
        /// Also, if your editor factory is IDisposable, it will be
        /// disposed when it is unregistered.
        /// </devdoc>
        protected void RegisterEditorFactory(IVsEditorFactory factory) {
            IVsRegisterEditors registerEditors = GetService(typeof(SVsRegisterEditors)) as IVsRegisterEditors;
            if (registerEditors == null) {
                throw new InvalidOperationException(SR.GetString(SR.Package_MissingService, typeof(SVsRegisterEditors).FullName));
            }

            uint cookie;
            Guid riid = factory.GetType().GUID;

            NativeMethods.ThrowOnFailure( registerEditors.RegisterEditor(ref riid, factory, out cookie) );

            if (_editorFactories == null) {
                _editorFactories = new Hashtable();
            }

            _editorFactories[factory] = cookie;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.RegisterEditorFactory"]/*' />
        /// <devdoc>
        /// Registers this project factory with Visual Studio.
        /// If you are providing an project factory, you should register
        /// it by overriding the Initialize method. Call 
        /// base.Initialize first, and then call RegisterProjectFactory
        /// for each project factory.  There is no need to unregister
        /// an project factory as the Package base class will handle this for you.
        /// Also, if your project factory is IDisposable, it will be
        /// disposed when it is unregistered.
        /// </devdoc>
        protected void RegisterProjectFactory(IVsProjectFactory factory) {
            IVsRegisterProjectTypes registerProjects = GetService(typeof(SVsRegisterProjectTypes)) as IVsRegisterProjectTypes;
            if (registerProjects == null) {
                throw new InvalidOperationException(SR.GetString(SR.Package_MissingService, typeof(SVsRegisterProjectTypes).FullName));
            }

            uint cookie;
            Guid riid = factory.GetType().GUID;

            NativeMethods.ThrowOnFailure( registerProjects.RegisterProjectType(ref riid, factory, out cookie) );

            if (_projectFactories == null) {
                _projectFactories = new Hashtable();
            }

            _projectFactories[factory] = cookie;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.ShowOptionPage"]/*' />
        /// <devdoc>
        /// Displays the Tools->Options dialog with the given
        /// options page selected.
        /// </devdoc>
        public void ShowOptionPage(Type optionsPageType) {

            if (optionsPageType == null) {
                throw new ArgumentNullException("optionsPageType");
            }

            System.ComponentModel.Design.MenuCommandService mcs = GetService(typeof(IMenuCommandService)) as System.ComponentModel.Design.MenuCommandService;
            if (mcs != null) {
                CommandID cmd = new CommandID(NativeMethods.GUID_VSStandardCommandSet97, NativeMethods.cmdidToolsOptions);
                mcs.GlobalInvoke(cmd, optionsPageType.GUID.ToString());
            }
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IOleCommandTarget.Exec"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IOleCommandTarget implementation.
        /// </devdoc>
        int IOleCommandTarget.Exec(ref Guid guidGroup, uint nCmdId, uint nCmdExcept, IntPtr pIn, IntPtr vOut) {
            IOleCommandTarget tgt = (IOleCommandTarget)GetService(typeof(IOleCommandTarget));
            if (tgt != null) {
                return tgt.Exec(ref guidGroup, nCmdId, nCmdExcept, pIn, vOut);
            }
            else {
                return NativeMethods.OLECMDERR_E_NOTSUPPORTED;
            }
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IOleCommandTarget.QueryStatus"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IOleCommandTarget implementation.
        /// </devdoc>
        int IOleCommandTarget.QueryStatus(ref Guid guidGroup, uint nCmdId, OLECMD[] oleCmd, IntPtr oleText) {
            IOleCommandTarget tgt = (IOleCommandTarget)GetService(typeof(IOleCommandTarget));
            if (tgt != null) {
                return tgt.QueryStatus(ref guidGroup, nCmdId, oleCmd, oleText);
            }
            return(NativeMethods.OLECMDERR_E_NOTSUPPORTED);
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IOleServiceProvider.QueryService"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IOleServiceProvider implementation.
        /// </devdoc>
        int IOleServiceProvider.QueryService(ref Guid sid, ref Guid iid, out IntPtr ppvObj) {
            
            ppvObj = (IntPtr)0;
            int hr = NativeMethods.S_OK;

            object service = null;

            if (_services != null) {
                foreach(Type serviceType in _services.Keys) {
                    if (serviceType.GUID.Equals(sid)) {
                        service = GetService(serviceType);
                        break;
                    }
                }
            }

            if (service == null) {
                hr = NativeMethods.E_NOINTERFACE;
            }
            else {
                // Now check to see if the user asked for an IID other than
                // IUnknown.  If so, we must do another QI.
                //
                if (iid.Equals(NativeMethods.IID_IUnknown)) {
                    ppvObj = Marshal.GetIUnknownForObject(service);
                }
                else {
                    IntPtr pUnk = Marshal.GetIUnknownForObject(service);
                    hr = Marshal.QueryInterface(pUnk, ref iid, out ppvObj);
                    Marshal.Release(pUnk);
                }
            }

            return hr;
        }
    
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IServiceContainer.AddService"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Adds the given service to the service container.
        /// </devdoc>
        void IServiceContainer.AddService(Type serviceType, object serviceInstance) {
            ((IServiceContainer)this).AddService(serviceType, serviceInstance, false);
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IServiceContainer.AddService1"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Adds the given service to the service container.
        /// </devdoc>
        void IServiceContainer.AddService(Type serviceType, object serviceInstance, bool promote) {

            if (serviceType == null) {
                throw new ArgumentNullException("serviceType");
            }

            if (serviceInstance == null) {
                throw new ArgumentNullException("serviceInstance");
            }

            if (_services == null) {
                _services = new Hashtable();
            }

            // Disallow the addition of duplicate services.
            //
            if (_services.ContainsKey(serviceType)) {
                throw new InvalidOperationException(SR.GetString(SR.Package_DuplicateService, serviceType.FullName));
            }

            if (promote) {

                // If we're promoting, we need to store this guy in a promoted service
                // object because we need to manage additional state.  We attempt
                // to proffer at this time if we have a service provider.  If we don't,
                // we will proffer when we get one.
                //
                ProfferedService service = new ProfferedService();
                service.Instance = serviceInstance;
                
                if (_provider != null) {
                    IProfferService ps = (IProfferService)GetService(typeof(SProfferService));
                    if (ps != null) {
                        uint cookie;
                        Guid serviceGuid = (Guid)serviceType.GUID;
                        NativeMethods.ThrowOnFailure( ps.ProfferService(ref serviceGuid, this, out cookie) );
                        service.Cookie= cookie;
                        _services[serviceType] = service;
                    }
                }
            }
            else {
                _services[serviceType] = serviceInstance;
            }
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IServiceContainer.AddService2"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Adds the given service to the service container.
        /// </devdoc>
        void IServiceContainer.AddService(Type serviceType, ServiceCreatorCallback callback) {
            ((IServiceContainer)this).AddService(serviceType, callback, false);
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IServiceContainer.AddService3"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Adds the given service to the service container.
        /// </devdoc>
        void IServiceContainer.AddService(Type serviceType, ServiceCreatorCallback callback, bool promote) {

            if (serviceType == null) {
                throw new ArgumentNullException("serviceType");
            }

            if (callback == null) {
                throw new ArgumentNullException("callback");
            }

            if (_services == null) {
                _services = new Hashtable();
            }

            // Disallow the addition of duplicate services.
            //
            if (_services.ContainsKey(serviceType)) {
                throw new InvalidOperationException(SR.GetString(SR.Package_DuplicateService, serviceType.FullName));
            }

            if (promote) {

                // If we're promoting, we need to store this guy in a promoted service
                // object because we need to manage additional state.  We attempt
                // to proffer at this time if we have a service provider.  If we don't,
                // we will proffer when we get one.
                //
                ProfferedService service = new ProfferedService();
                _services[serviceType] = service;
                service.Instance = callback;
                
                if (_provider != null) {
                    IProfferService ps = (IProfferService)GetService(typeof(SProfferService));
                    if (ps != null) {
                        uint cookie;
                        Guid serviceGuid = (Guid)serviceType.GUID;
                        NativeMethods.ThrowOnFailure( ps.ProfferService(ref serviceGuid, this, out cookie) );
                        service.Cookie= cookie;
                    }
                }
            }
            else {
                _services[serviceType] = callback;
            }
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IServiceContainer.RemoveService"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Removes the given service type from the service container.
        /// </devdoc>
        void IServiceContainer.RemoveService(Type serviceType) {
            ((IServiceContainer)this).RemoveService(serviceType, false);
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IServiceContainer.RemoveService1"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Removes the given service type from the service container.
        /// </devdoc>
        void IServiceContainer.RemoveService(Type serviceType, bool promote) {
            if (serviceType == null) {
                throw new ArgumentNullException("serviceType");
            }

            if (_services != null) {
                object value = _services[serviceType];
                if (value != null) {
                    _services.Remove(serviceType);

                    try {
                        ProfferedService service = value as ProfferedService;
                        if (null != service) {
                            value = service.Instance;
                            if (service.Cookie != 0) {
                                IProfferService ps = (IProfferService)GetService(typeof(SProfferService));
                                if (ps != null) {
                                    NativeMethods.ThrowOnFailure(ps.RevokeService(service.Cookie));
                                }
                                service.Cookie = 0;
                            }
                        }
                    } 
                    finally {
                        if (value is IDisposable) {
                            ((IDisposable)value).Dispose();
                        }
                    }
                }
            }
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IServiceProvider.GetService"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IServiceProvider implementation.  We just delegate to
        /// the Package implementation for this.
        /// </devdoc>
        object IServiceProvider.GetService(Type serviceType) {
            return GetService(serviceType);
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsPackage.Close"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsPackage implementation.
        /// </devdoc>
        int IVsPackage.Close() {
            if (!zombie)
            {
                Dispose(true);
            }

            zombie = true;

            return NativeMethods.S_OK;
        }
        
        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsPackage.CreateTool"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsPackage implementation.
        /// graysonm : temporarily remove explicit implementation syntax in order to allow hiding of this method
        /// in a derived class until tool window support is implemented.
        /// </devdoc>
        public int CreateTool(ref Guid persistenceSlot)
        {
            if (zombie)
                Marshal.ThrowExceptionForHR(NativeMethods.E_UNEXPECTED);

            // Let the factory do the work
            int hr = ((IVsToolWindowFactory)this).CreateToolWindow(ref persistenceSlot, 0);
            return hr;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsToolWindowFactory.CreateToolWindow"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Create a tool window of the specified type with the specified ID.
        /// </devdoc>
        /// <param name="toolWindowType">Type of the window to be created</param>
        /// <param name="id">Instance ID</param>
        int IVsToolWindowFactory.CreateToolWindow(ref Guid toolWindowType, uint id)
        {
            if (id > int.MaxValue)
                throw new ArgumentOutOfRangeException(String.Format(CultureInfo.CurrentUICulture, "Instance ID cannot be more then {0}", int.MaxValue));
            int instanceID = (int)id;

            // Find the Type for this GUID
            Attribute[] attributes = Attribute.GetCustomAttributes(this.GetType());
            foreach (Attribute attribute in attributes)
            {
                if (attribute is ProvideToolWindowAttribute)
                {
                    ProvideToolWindowAttribute tool = (ProvideToolWindowAttribute)attribute;
                    if (tool.ToolType.GUID == toolWindowType)
                    {
                        // We found the corresponding type
                        // If a window get created this way, FindToolWindow should be used to get a reference to it
                        FindToolWindow(tool.ToolType, instanceID, true, tool);
                        break;
                    }
                }
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.CreateToolWindow"]/*' />
        /// <devdoc>
        /// Create a tool window of the specified type with the specified ID.
        /// </devdoc>
        /// <param name="toolWindowType">Type of the window to be created</param>
        /// <param name="id">Instance ID</param>
        /// <returns>An instance of a class derived from ToolWindowPane</returns>
        protected ToolWindowPane CreateToolWindow(Type toolWindowType, int id)
        {
            if (toolWindowType == null)
                throw new ArgumentNullException("toolWindowType");
            if (id < 0)
                throw new ArgumentOutOfRangeException(SR.GetString(SR.Package_InvalidInstanceID, id));
            if (!toolWindowType.IsSubclassOf(typeof(ToolWindowPane)))
                throw new ArgumentException(SR.GetString(SR.Package_InvalidToolWindowClass));

            // Look in the Attributes of this package and see if this package
            // support this type of ToolWindow
            Attribute[] attributes = Attribute.GetCustomAttributes(this.GetType());
            foreach (Attribute attribute in attributes)
            {
                if (attribute is ProvideToolWindowAttribute)
                {
                    ProvideToolWindowAttribute tool = (ProvideToolWindowAttribute)attribute;
                    if (tool.ToolType == toolWindowType)
                    {
                        // We found the corresponding attribute on the package,
                        // so create the toolwindow
                        return CreateToolWindow(toolWindowType, id, tool);
                    }
                }
            }

            return null;
        }

        /// <devdoc>
        /// This is the only method that should be calling IVsUiShell.CreateToolWindow()
        /// </devdoc>
        private ToolWindowPane CreateToolWindow(Type toolWindowType, int id, ProvideToolWindowAttribute tool)
        {
            if (toolWindowType == null)
                throw new ArgumentNullException("toolWindowType");
            if (id < 0)
                throw new ArgumentOutOfRangeException(SR.GetString(SR.Package_InvalidInstanceID, id));
            if (!toolWindowType.IsSubclassOf(typeof(ToolWindowPane)))
                throw new ArgumentException(SR.GetString(SR.Package_InvalidToolWindowClass));
            if (tool == null)
                throw new ArgumentNullException("tool");

            // First create an instance of the ToolWindowPane
            ToolWindowPane window = (ToolWindowPane)Activator.CreateInstance(toolWindowType);

            // Check if this window has a ToolBar
            bool hasToolBar = (window.ToolBar != null);

            uint flags = (uint)__VSCREATETOOLWIN.CTW_fInitNew;
            if (!tool.Transient)
                flags |= (uint)__VSCREATETOOLWIN.CTW_fForceCreate;
            if (hasToolBar)
                flags |= (uint)__VSCREATETOOLWIN.CTW_fToolbarHost;
            if (tool.MultiInstances)
                flags |= (uint)__VSCREATETOOLWIN.CTW_fMultiInstance;
            Guid emptyGuid = Guid.Empty;
            Guid toolClsid = window.ToolClsid;
            IVsWindowPane windowPane = null;
            if (toolClsid.CompareTo(Guid.Empty) == 0)
            {
                // If a tool CLSID is not specified, then host the IVsWindowPane
                windowPane = window.GetIVsWindowPane() as IVsWindowPane;
            }
            Guid persistenceGuid = toolWindowType.GUID;
            IVsWindowFrame windowFrame;
            // Use IVsUIShell to create frame.
            IVsUIShell vsUiShell = (IVsUIShell)GetService(typeof(SVsUIShell));
            if (vsUiShell == null)
                throw new Exception(SR.GetString(SR.General_MissingService, typeof(SVsUIShell).FullName));

            int hr = vsUiShell.CreateToolWindow(flags,         // flags
                (uint)id,               // instance ID
                windowPane,             // IVsWindowPane to host in the toolwindow (null if toolClsid is specified)
                ref toolClsid,          // toolClsid to host in the toolwindow (Guid.Empty if windowPane is not null)
                ref persistenceGuid,    // persistence Guid
                ref emptyGuid,          // auto activate Guid
                null,                   // service provider
                window.Caption,         // Window title
                null,
                out windowFrame);
            NativeMethods.ThrowOnFailure(hr);

            window.Package = this;

            // If the toolwindow is a component, site it.
            IComponent component = null;
            if (window.Window is IComponent)
                component = (IComponent)window.Window;
            else if (windowPane is IComponent)
                component = (IComponent)windowPane;
            if (component != null)
            {
                if (_componentToolWindows == null)
                    _componentToolWindows = new PackageContainer(this);
                _componentToolWindows.Add((IComponent)component);
            }

            // This generates the OnToolWindowCreated event on the ToolWindowPane
            window.Frame = windowFrame;

            if (hasToolBar && windowFrame != null)
            {
                // Set the toolbar
                IVsToolWindowToolbarHost toolBarHost;
                object obj;
                NativeMethods.ThrowOnFailure(windowFrame.GetProperty((int)__VSFPROPID.VSFPROPID_ToolbarHost, out obj));
                toolBarHost = (IVsToolWindowToolbarHost)obj;
                if (toolBarHost != null)
                {
                    Guid toolBarCommandSet = window.ToolBar.Guid;
                    NativeMethods.ThrowOnFailure(toolBarHost.AddToolbar((VSTWT_LOCATION)window.ToolBarLocation, ref toolBarCommandSet, (uint)window.ToolBar.ID));
                }
            }

            window.OnToolBarAdded();

            // If the ToolWindow was created successfully, keep track of it
            if (window != null)
            {
                if (_toolWindows == null)
                    _toolWindows = new Hashtable();
                _toolWindows.Add(GetHash(toolWindowType.GUID, id), window);
            }
            return window;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.0lWindow"]/*' />
        /// <devdoc>
        /// Return the tool window corresponding to the specified type and ID.
        /// If it does not exist, it returns creates one if create is true,
        /// or null if create is false.
        /// </devdoc>
        /// <param name="toolWindowType">Type of the window to be created</param>
        /// <param name="id">Instance ID</param>
        /// <param name="create">Create if none exist?</param>
        /// <returns>An instance of a class derived from ToolWindowPane</returns>
        public ToolWindowPane FindToolWindow(Type toolWindowType, int id, bool create)
        {
            return FindToolWindow(toolWindowType, id, create, null);
        }

        private ToolWindowPane FindToolWindow(Type toolWindowType, int id, bool create, ProvideToolWindowAttribute tool)
        {
            if (toolWindowType == null)
                throw new ArgumentNullException("toolWindowType");

            ToolWindowPane window = null;

            int hash = GetHash(toolWindowType.GUID, id);
            if (_toolWindows != null && _toolWindows.ContainsKey(hash))
                window = (ToolWindowPane)_toolWindows[hash];
            else if (create)
            {
                if (tool != null)
                    window = CreateToolWindow(toolWindowType, id, tool);
                else
                    window = CreateToolWindow(toolWindowType, id);
            }

            return window;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsPackage.GetAutomationObject"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsPackage implementation.
        /// </devdoc>
        int IVsPackage.GetAutomationObject(string propName, out object auto) {
            if (zombie)
                Marshal.ThrowExceptionForHR(NativeMethods.E_UNEXPECTED);

            auto = GetAutomationObject(propName);
            if (auto == null) {
                Marshal.ThrowExceptionForHR(NativeMethods.E_NOTIMPL);
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsPackage.GetPropertyPage"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsPackage implementation.
        /// </devdoc>
        int IVsPackage.GetPropertyPage(ref Guid rguidPage, VSPROPSHEETPAGE[] ppage) {
            if (ppage == null || ppage.Length < 1)
                throw new ArgumentException(SR.GetString(SR.General_ArraySizeShouldBeAtLeast1), "ppage");

            if (zombie)
                Marshal.ThrowExceptionForHR(NativeMethods.E_UNEXPECTED);

            IWin32Window pageWindow = null;

            // First, check out the active pages.
            //
            if (_pagesAndProfiles != null) {
                foreach(object page in _pagesAndProfiles.Components) {
                    if (page.GetType().GUID.Equals(rguidPage)) {

                        // Found a match.
                        //
                        IWin32Window w = page as IWin32Window;
                        if (w != null) {
                            if (w is DialogPage) {
                                ((DialogPage)w).ResetContainer();
                            }
                            pageWindow = w;
                            break;
                        }
                    }
                }
            }

            if (pageWindow == null) {

                DialogPage page = null;

                // Didn't find it in our cache.  Now look in the metadata attributes
                // for the class.  Look at all types at the same time.
                //
                AttributeCollection attributes = TypeDescriptor.GetAttributes(this);
                foreach(Attribute attr in attributes) {
                    if (attr is ProvideOptionDialogPageAttribute) {
                        Type pageType = ((ProvideOptionDialogPageAttribute)attr).PageType;
                        if (pageType.GUID.Equals(rguidPage)) {

                            // Found a matching attribute.  Now go get the DialogPage with GetDialogPage.
                            // This has a side-effect of storing the page in
                            // _pagesAndProfiles for us.
                            //
                            page = GetDialogPage(pageType);
                            pageWindow = page;
                            break;
                        }
                    }

                    if (page != null)
                    {
                        if (_pagesAndProfiles == null)       
                        {
                            _pagesAndProfiles = new PackageContainer(this);
                        }
                        _pagesAndProfiles.Add(page);

                        // No need to continue looking in the attributes, 
                        // we've already found the one we're looking for
                        break;
                    }
                }
            }

            // We should now have a page window. If we don't then the requested page
            // doesn't exist.
            //
            if (pageWindow == null) {
                Marshal.ThrowExceptionForHR(NativeMethods.E_NOTIMPL);
            }

            ppage[0].dwSize = (uint)Marshal.SizeOf(typeof(VSPROPSHEETPAGE));
            ppage[0].hwndDlg = pageWindow.Handle;
            // zero-out all the fields we aren't using.
            ppage[0].dwFlags = 0;
            ppage[0].HINSTANCE = 0;
            ppage[0].dwTemplateSize = 0;
            ppage[0].pTemplate = IntPtr.Zero;
            ppage[0].pfnDlgProc = IntPtr.Zero;
            ppage[0].lParam = IntPtr.Zero;
            ppage[0].pfnCallback = IntPtr.Zero;
            ppage[0].pcRefParent = IntPtr.Zero;
            ppage[0].dwReserved = 0;
            ppage[0].wTemplateId = (ushort)0;

            return NativeMethods.S_OK;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsPackage.QueryClose"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsPackage implementation.
        /// </devdoc>
        int IVsPackage.QueryClose(out int close)
        {
            // Default to true as we don't want an error to prevent the shell from closing
            close = 1;
            bool canClose = true;
            int hr = this.QueryClose(out canClose);
            if (!canClose)
                close = 0;
            return hr;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsPackage.ResetDefaults"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsPackage implementation.
        /// </devdoc>
        int IVsPackage.ResetDefaults(uint grfFlags) {

            if (zombie)
                Marshal.ThrowExceptionForHR(NativeMethods.E_UNEXPECTED);

            if (grfFlags == (uint)__VSPKGRESETFLAGS.PKGRF_TOOLBOXITEMS) {
                if (ToolboxInitialized != null) {
                    ToolboxInitialized(this, EventArgs.Empty);
                }
            }
            else if (grfFlags == (uint)__VSPKGRESETFLAGS.PKGRF_TOOLBOXSETUP) {
                if (ToolboxUpgraded != null) {
                    ToolboxUpgraded(this, EventArgs.Empty);
                }
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsPackage.SetSite"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsPackage implementation.
        /// </devdoc>
        int IVsPackage.SetSite(IOleServiceProvider sp) {

            if (zombie)
                Marshal.ThrowExceptionForHR(NativeMethods.E_UNEXPECTED);

            if (sp != null) {
                if (_provider != null) {
                    throw new InvalidOperationException(SR.GetString(SR.Package_SiteAlreadySet, GetType().FullName));
                }
                _provider = new ServiceProvider(sp);
                // Initialize the static service provider
                if (_globalProvider == null)
                    _globalProvider = _provider;
                // Increment the number of package that have been sited.
                // This allows us to know when to let go of our _globalProvider
                ++_sitedPackageCount;
                Initialize();
            }
            else if (_provider != null)
            {
                // No SP, dispose us.
                //
                Dispose(true);

                // Decrement the number of package that have been sited.
                --_sitedPackageCount;
                // Dispose of our  _globalProvider once all packages have been unsited
                if (_sitedPackageCount <= 0 && _globalProvider != null)
                {
                    Debug.Assert(_sitedPackageCount == 0, "We should not have unsited more package then we sited");
                    _globalProvider.Dispose();
                    _globalProvider = null;
                }
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsPersistSolutionOpts.LoadUserOptions"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsPersistSolutionOpts implementation.
        /// Called when a solution is opened, and allows us to inspect our options.
        /// </devdoc>
        int IVsPersistSolutionOpts.LoadUserOptions(IVsSolutionPersistence pPersistance, uint options) {

            int hr = NativeMethods.S_OK;
            if ((options & (uint)__VSLOADUSEROPTS.LUO_OPENEDDSW) != 0) {
                return hr;
            }

            if (_optionKeys != null) {
                foreach(string key in _optionKeys) {
                    hr = pPersistance.LoadPackageUserOpts(this, key);
                    if (NativeMethods.Failed(hr))
                        break;
                }
            }

            // Shell relies on this being released when we're done with it.  If you see strange
            // faults in the shell when saving the solution, suspect this!
            //
            Marshal.ReleaseComObject(pPersistance);

            NativeMethods.ThrowOnFailure(hr);
            return hr;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsPersistSolutionOpts.ReadUserOptions"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsPersistSolutionOpts implementation.
        /// Called by the shell to load our solution options.
        /// </devdoc>
        int IVsPersistSolutionOpts.ReadUserOptions(IStream pStream, string pszKey) {

            try {
                NativeMethods.DataStreamFromComStream stream = new NativeMethods.DataStreamFromComStream(pStream);
                using (stream) {
                    OnLoadOptions(pszKey, stream);
                }
            }
            finally {
                // Release the pointer because VS expects it to be released upon
                // function return.
                //
                Marshal.ReleaseComObject(pStream);
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsPersistSolutionOpts.SaveUserOptions"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsPersistSolutionOpts implementation.
        /// Called by the shell when we are to persist our service options
        /// </devdoc>
        int IVsPersistSolutionOpts.SaveUserOptions(IVsSolutionPersistence pPersistance) {

            if (_optionKeys != null) {
                foreach(string key in _optionKeys) {
                    NativeMethods.ThrowOnFailure( pPersistance.SavePackageUserOpts(this, key) );
                }
            }

            // Shell relies on this being released when we're done with it.  If you see strange
            // faults in the shell when saving the solution, suspect this!
            //
            Marshal.ReleaseComObject(pPersistance);

            return NativeMethods.S_OK;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.IVsPersistSolutionOpts.WriteUserOptions"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsPersistSolutionOpts implementation.
        /// Called by the shell to persist our solution options.  Here is where the service
        /// can persist any goo that it cares about.
        /// </devdoc>
        int IVsPersistSolutionOpts.WriteUserOptions(IStream pStream, string pszKey) {

            try {
                NativeMethods.DataStreamFromComStream stream = new NativeMethods.DataStreamFromComStream(pStream);
                using (stream) {
                    OnSaveOptions(pszKey, stream);
                }
            }
            finally {
                // Release the pointer because VS expects it to be released upon
                // function return.
                //
                Marshal.ReleaseComObject(pStream);
            }
            return NativeMethods.S_OK;
        }

        /// <devdoc>
        ///     This class derives from container to provide a service provider
        ///     connection to the package.
        /// </devdoc>
        private sealed class PackageContainer : Container {
            private IUIService _uis;
            private AmbientProperties _ambientProperties;

            private IServiceProvider _provider;

            /// <devdoc>
            ///     Creates a new container using the given service provider.
            /// </devdoc>
            internal PackageContainer(IServiceProvider provider) {
                _provider = provider;
            }

            /// <devdoc>
            ///     Override to GetService so we can route requests
            ///     to the package's service provider.
            /// </devdoc>
            protected override object GetService(Type serviceType) {
                if (serviceType == null) {
                    throw new ArgumentNullException("serviceType");
                }
                if (_provider != null) {
                    if (serviceType == typeof(AmbientProperties)) {
                        if (_uis == null) {
                            _uis = (IUIService)_provider.GetService(typeof(IUIService));
                        }
                        if (_ambientProperties == null) {
                            _ambientProperties = new AmbientProperties();
                        }
                        if (_uis != null) {
                            // update the _ambientProperties in case the styles have changed
                            // since last time.
                            _ambientProperties.Font = (Font)_uis.Styles["DialogFont"];
                        }
                        return _ambientProperties;
                    }
                    object service = _provider.GetService(serviceType);

                    if (service != null) {
                        return service;
                    }
                }
                return base.GetService(serviceType);
            }
        }
        static private int GetHash(Guid guid, int id)
        {
            return guid.ToString("N").GetHashCode() ^ id;
        }

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.GetGlobalService"]' />
        /// <devdoc>
        /// Get a service proffered globally by VisualStudio or one of its package.
        /// This is equivalent to calling GetService() on an instance of a package 
        /// that proffer no service itself.
        /// </devdoc>
        /// <param name="serviceType">Type corresponding to the Service being requested</param>
        /// <returns>The service being requested if available, otherwise null</returns>
        static public object GetGlobalService(Type serviceType)
        {
            object service = null;
            Debug.Assert(_globalProvider != null, "You are calling GetGlobalService before any package derived from the managed package framework has been sited. This is not supported");

            if (_globalProvider != null)
            {
                service = _globalProvider.GetService(serviceType);
            }
            return service;
        }

        /// <devdoc>
        ///     This class contains a service that is being promoted to vS.  
        /// </devdoc>
        private sealed class ProfferedService {
            public object Instance;
            public uint   Cookie;
        }

        /// <devdoc>
        /// Internal zombie flag indicates that VS is shutting us down.
        /// </devdoc>
        private bool zombie = false;

        /// <include file='doc\Package.uex' path='docs/doc[@for="Package.Zombied"]/*' />
        /// <devdoc>
        /// Zombie flag indicates that the package is being closed.
        /// </devdoc>
        public bool Zombied {
            get {
                return zombie;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\ProvideExtenderAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright from='2003' to='2004' company='Microsoft Corporation'>           
//  Copyright (c) Microsoft Corporation, All rights reserved.             
//  This code sample is provided "AS IS" without warranty of any kind, 
//  it is not recommended for use in a production environment.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <summary>
    ///     This attribute registers the package as an extender.  The GUID passed in determines
    ///     what is being extended. The attributes on a package do not control the behavior of
    ///     the package, but they can be used by registration tools to register the proper
    ///     information with Visual Studio.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideExtenderAttribute : RegistrationAttribute {

		private Guid CATID = Guid.Empty;
		private Guid extender = Guid.Empty;
		private string name;

		/// <summary>
		///     Creates a new ProvideExtenderAttribute.
		/// </summary>
		/// <param name="extendeeCatId">CatId of the element you want to extend.</param>
		/// <param name="extenderGuid">GUID of the extender.</param>
		/// <param name="extenderName">Name of the element you want to extend.</param>
		public ProvideExtenderAttribute(string extendeeCatId, string extenderGuid, string extenderName) 
		{
			CATID = new Guid(extendeeCatId);
			extender = new Guid(extenderGuid);
			name = extenderName;
		}

		/// <summary>
		/// The CatID of the element being extended.
		/// </summary>
		public Guid ExtendeeCatId {
			get {
				return CATID;
			}
		}

		/// <summary>
		/// The Guid of the extender.
		/// </summary>
		public Guid Extender {
			get {
				return extender;
			}
		}

		/// <summary>
		/// The name of the extender.
		/// </summary>
		public string ExtenderName {
			get {
				return name ;
			}
		}

		/// <summary>
		///		The reg key name of this Extender.
		/// </summary>
		private string RegKeyName 
		{
			get 
			{
				return string.Format(CultureInfo.InvariantCulture, "Extenders\\{0}\\{1}", CATID.ToString("B"), name);
			}
		}

		/// <summary>
		///     Called to register this attribute with the given context.  The context
		///     contains the location where the registration information should be placed.
		///     it also contains such as the type being registered, and path information.
		/// </summary>
		public override void Register(RegistrationContext context) 
		{
			context.Log.WriteLine(SR.GetString(SR.Reg_NotifyExtender, name, CATID.ToString("B")));

			using (Key childKey = context.CreateKey(RegKeyName))
			{
				// Set default value for the Key = Extender GUID
				childKey.SetValue(string.Empty, extender.ToString("B"));
			}
		}

		/// <summary>
		/// Unregister this Extender specification.
		/// </summary>
		public override void Unregister(RegistrationContext context)
		{
			context.RemoveKey(RegKeyName);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\ProvideKeyBindingTableAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideKeyBindingTableAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\ProvideKeyBindingTableAttribute.uex' path='docs/doc[@for="ProvideKeyBindingTableAttribute"]' />
    /// <devdoc>
    ///     This attribute declares that a package has a key binding table declared within its 
    ///     CTO file.  This attribute is only used for registration purposes.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideKeyBindingTableAttribute : RegistrationAttribute {
        
        private short   _nameResourceID;
        private Guid    _tableGuid;
        private bool    _allowNavKeys = false;
    
        /// <include file='doc\ProvideKeyBindingTableAttribute.uex' path='docs/doc[@for="ProvideKeyBindingTableAttribute.ProvideKeyBindingTableAttribute"]' />
        /// <devdoc>
        ///     Creates a new ProvideKeyBindingTableAttribute.
        /// </devdoc>
        public ProvideKeyBindingTableAttribute (string tableGuid, short nameResourceID) {
            if (tableGuid == null) {
                throw new ArgumentNullException("tableGuid");
            }
            _tableGuid = new Guid(tableGuid);
            _nameResourceID = nameResourceID;
        }
        
        /// <include file='doc\ProvideKeyBindingTableAttribute.uex' path='docs/doc[@for="ProvideKeyBindingTableAttribute.NameResourceID"]' />
        /// <devdoc>
        ///     Returns the key binding table's name resource ID.
        /// </devdoc>
        public short NameResourceID {
            get {
                return _nameResourceID;
            }
        }

        /// <include file='doc\ProvideKeyBindingTableAttribute.uex' path='docs/doc[@for="ProvideKeyBindingTableAttribute.TableGuid"]' />
        /// <devdoc>
        ///     Returns the key binding table guid.
        /// </devdoc>
        public Guid TableGuid {
            get {
                return _tableGuid;
            }
        }

        /// <include file='doc\ProvideKeyBindingTableAttribute.uex' path='docs/doc[@for="ProvideKeyBindingTableAttribute.AllowNavKeyBinding"]/*' />
        /// <summary>
        /// Set to true if the user can bind new commands of the nagivation keys
        /// </summary>
        public bool AllowNavKeyBinding
        {
            get { return _allowNavKeys; }
            set { _allowNavKeys = value; }
        }

        private string KeyBindingRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, "KeyBindingTables\\{0}", TableGuid.ToString("B")); }
        }

        /// <include file='doc\ProvideKeyBindingTableAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(SR.GetString(SR.Reg_NotifyKeyBinding, TableGuid.ToString("B"), NameResourceID));

            using (Key childKey = context.CreateKey(KeyBindingRegKey))
            {
                childKey.SetValue(string.Empty, string.Format(CultureInfo.InvariantCulture, "#{0}", NameResourceID));
                childKey.SetValue("Package", context.ComponentType.GUID.ToString("B"));
                childKey.SetValue("AllowNavKeyBinding", _allowNavKeys ? 1 : 0);
            }
        }

        /// <include file='doc\ProvideKeyBindingTableAttribute.uex' path='docs/doc[@for="ProvideKeyBindingTableAttribute.Unregister"]/*' />
        public override void Unregister(RegistrationContext context) {
            context.RemoveKey(KeyBindingRegKey);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\ProvideLanguageExtensionAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideLanguageExtensionAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\ProvideLanguageExtensionAttribute.uex' path='docs/doc[@for="ProvideLanguageExtensionAttribute"]' />
    /// <devdoc>
    ///     This attribute associates a file extension to a given editor factory.  
    ///     The editor factory may be specified as either a GUID or a type and 
    ///     is placed on a package.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideLanguageExtensionAttribute : RegistrationAttribute {

        private Guid languageService;
        private string extension;
        
        /// <include file='doc\ProvideLanguageExtensionAttribute.uex' path='docs/doc[@for="ProvideLanguageExtensionAttribute.ProvideLanguageExtensionAttribute"]' />
        /// <devdoc>
        ///     Creates a new attribute.
        /// </devdoc>
        public ProvideLanguageExtensionAttribute (string languageServiceGuid, string extension) {

            if (!extension.StartsWith(".", StringComparison.OrdinalIgnoreCase)) {
                throw new ArgumentException(SR.GetString(SR.Attributes_ExtensionNeedsDot, extension));
            }

            this.languageService = new Guid(languageServiceGuid);
            this.extension = extension;
        }
        
        /// <include file='doc\ProvideLanguageExtensionAttribute.uex' path='docs/doc[@for="ProvideLanguageExtensionAttribute.ProvideLanguageExtensionAttribute1"]' />
        /// <devdoc>
        ///     Creates a new attribute.
        /// </devdoc>
        public ProvideLanguageExtensionAttribute (Type languageService, string extension) {

            if (!extension.StartsWith(".", StringComparison.OrdinalIgnoreCase)) {
                throw new ArgumentException(SR.GetString(SR.Attributes_ExtensionNeedsDot, extension));
            }

            this.languageService = languageService.GUID;
            this.extension = extension;
        }
        
        /// <include file='doc\ProvideLanguageExtensionAttribute.uex' path='docs/doc[@for="ProvideLanguageExtensionAttribute.Extension"]' />
        /// <devdoc>
        ///     The file extension of the file.
        /// </devdoc>
        public string Extension {
            get {
                return extension;
            }
        }
        
        /// <include file='doc\ProvideLanguageExtensionAttribute.uex' path='docs/doc[@for="ProvideLanguageExtensionAttribute.LanguageService"]' />
        /// <devdoc>
        ///     The language service SID.
        /// </devdoc>
        public Guid LanguageService {
            get {
                return languageService;
            }
        }

        private string ExtensionsRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, "Languages\\File Extensions\\{0}", Extension); }
        }

        /// <include file='doc\ProvideLanguageExtensionAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(SR.GetString(SR.Reg_NotifyLanguageExtension, Extension, LanguageService.ToString("B")));

            using (Key childKey = context.CreateKey(ExtensionsRegKey))
            {
                childKey.SetValue(string.Empty, LanguageService.ToString("B"));
            }
        }

        /// <include file='doc\ProvideLanguageExtensionAttribute.uex' path='docs/doc[@for="Unregister"]' />
        public override void Unregister(RegistrationContext context) {
            context.RemoveKey(ExtensionsRegKey);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\providelanguageServiceAttribute.cs ===
﻿//////////////////////////////////////////////////////////////////////////////
// ProvideLanguageServiceAttribute
//
// This attribute class will ease the pain of registering a language service
// written in managed code.
//
// To add editor Tool Options Pages, use ProvideLanguageEditorOptionPageAttribute.
// To add code expansion support, use ProvideLanguageCodeExpansionAttribute.
//
// Usage:
// [ProvideLanguageServiceAttribute(<type>,<language name>,<language name id>,
//    DebuggerLanguageExpressionEvaluator = "{guid}"
//    ShowCompetion = true | false
//    ShowSmartIndent = true | false
//    RequestStockColors = true | false
//    ShowHotURLs = true | false
//    DefaultToNonHotURLs = true | false
//    DefaultToInsertSpaces = true | false
//    ShowDropDownOptions = true | false
//    SingleCodeWindowOnly = true | false
//    EnableAdvancedMembersOption = true | false
//    SupportCopyPasteOfHTML = true | false
//    EnableLineNumbers = true | false
//    HideAdvancedMembersByDefault = true | false
//    CodeSense = true | false
//    MatchBraces = true | false
//    QuickInfo = true | false
//    ShowMatchingBrace = true | false
//    MatchBracesAtCaret = true | false
//    MaxErrorMessages = <number>
//    CodeSenseDelay = <number>
//    EnableAsyncCompletion = true | false
//    EnableCommenting = true | false
//    EnableFormatSelection = true | false
//    AutoOutlining = true | false
// )]
//
// Notes:
// * All named options are optional.
// 
//
// <type>             is the type of the class implementing the language
//                    service.  The language GUID is obtained from this.
// <language name>    Name of the language to be used as a registry key name.
// <language name id> resource id of localized language name which Visual
//                    Studio will show to the user.
//
// LocalizedName      literal text or #ddd (resource id of localized name)
//                    This name is used for the string put into the tree list
//                    of options in Visual Studio's Tools Options dialog.
//                    This value appears as the default value for the
//                    GroupName and ItemName registry keys.  If not specified,
//                    the GroupName or ItemName is substituted.
// GroupName          Registry key name.  This acts as a node in the tree list
//                    of options.
// ItemName           Registry key name which has a registry entry that
//                    specifies the guid of an option page to show.
//
// Note: All GroupName and ItemName keys contain an additional registry entry
//       for the package guid (which is derived internally and does not have
//       to be specified in the attribute).
//////////////////////////////////////////////////////////////////////////////

#region Using directives

using System;
using System.Diagnostics;
using System.Collections;
using System.Globalization;
using System.Runtime.InteropServices;
using System.ComponentModel.Design;
using Microsoft.Win32;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell;

#endregion

namespace Microsoft.VisualStudio.Shell
{
    /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute"]' />
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
    public sealed class ProvideLanguageServiceAttribute : RegistrationAttribute
    {
        // ProvideLanguageServiceAttribute Private fields.
        //
        private Guid                languageServiceGuid;
        private string              strLanguageName;
        private int                 languageResourceID;
        private Hashtable           optionsTable;
        private DebuggerLanguages   debuggerLanguages;


        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.ProvideLanguageServiceAttribute"]' />
        /// <devdoc>
        /// Registers a language service.
        /// </devdoc>
        /// <param name="languageService"></param>
        /// <param name="strLanguageName"></param>
        /// <param name="languageResourceID"></param>
        public ProvideLanguageServiceAttribute(
            object languageService,
            string strLanguageName,
            int languageResourceID)
        {
            if (languageService is Type)
                this.languageServiceGuid = ((Type)languageService).GUID;
            else if (languageService is string)
                this.languageServiceGuid = new Guid((string)languageService);
            else
                throw new ArgumentException();
            this.strLanguageName     = strLanguageName;
            this.languageResourceID  = languageResourceID;

            debuggerLanguages   = new DebuggerLanguages(strLanguageName);
            optionsTable = new Hashtable();
        }

        // ProvideLanguageServiceAttribute Properties.

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.LanguageServiceSid"]' />
        public Guid LanguageServiceSid
        {
            get { return languageServiceGuid; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.LanguageName"]' />
        public string LanguageName
        {
            get { return strLanguageName; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.LanguageResourceID"]' />
        public int LanguageResourceID
        {
            get { return languageResourceID; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.DebuggerLanguageExpressionEvaluator"]' />
        /// <devdoc>
        /// Establish an expression evaluator for debugging languages.
        /// </devdoc>
        public string DebuggerLanguageExpressionEvaluator
        {
            get { return debuggerLanguages.ExpressionEvaluator.ToString("B"); }
            set { debuggerLanguages.ExpressionEvaluator = new Guid(value); }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.ShowCompletion"]' />
        public bool ShowCompletion
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.showCompletion];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.showCompletion] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.ShowSmartIndent"]' />
        public bool ShowSmartIndent
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.showIndentOptions];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.showIndentOptions] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.RequestStockColors"]' />
        public bool RequestStockColors
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.useStockColors];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.useStockColors] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.ShowHotURLs"]' />
        public bool ShowHotURLs
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.showHotURLs];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.showHotURLs] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.DefaultToNonHotURLs"]' />
        public bool DefaultToNonHotURLs
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.nonHotURLs];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.nonHotURLs] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.DefaultToInsertSpaces"]' />
        public bool DefaultToInsertSpaces
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.insertSpaces];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.insertSpaces] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.ShowDropDownOptions"]' />
        public bool ShowDropDownOptions
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.showDropDownBar];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.showDropDownBar] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.SingleCodeWindowOnly"]' />
        public bool SingleCodeWindowOnly
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.disableWindowNewWindow];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.disableWindowNewWindow] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.EnableAdvancedMembersOption"]' />
        public bool EnableAdvancedMembersOption
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.enableAdvMembersOption];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.enableAdvMembersOption] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.SupportCopyPasteOfHTML"]' />
        public bool SupportCopyPasteOfHTML
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.supportCF_HTML];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.supportCF_HTML] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.EnableLineNumbers"]' />
        public bool EnableLineNumbers
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.enableLineNumbersOption];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.enableLineNumbersOption] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.HideAdvancedMembersByDefault"]' />
        public bool HideAdvancedMembersByDefault
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.hideAdvancedMembersByDefault];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.hideAdvancedMembersByDefault] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.CodeSense"]' />
        public bool CodeSense
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.codeSense];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.codeSense] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.MatchBraces"]' />
        public bool MatchBraces
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.matchBraces];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.matchBraces] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.QuickInfo"]' />
        public bool QuickInfo
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.quickInfo];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.quickInfo] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.ShowMatchingBrace"]' />
        public bool ShowMatchingBrace
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.showMatchingBrace];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.showMatchingBrace] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.MatchBracesAtCaret"]' />
        public bool MatchBracesAtCaret
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.matchBracesAtCaret];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.matchBracesAtCaret] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.MaxErrorMessages"]' />
        public int MaxErrorMessages
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.maxErrorMessages];
                return (null == val) ? 0 : (int)val;
            }
            set { optionsTable[LanguageOptionKeys.maxErrorMessages] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.CodeSenseDelay"]' />
        public int CodeSenseDelay
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.codeSenseDelay];
                return (null == val) ? 0 : (int)val;
            }
            set { optionsTable[LanguageOptionKeys.codeSenseDelay] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.EnableAsyncCompletion"]' />
        public bool EnableAsyncCompletion
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.enableAsyncCompletion];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.enableAsyncCompletion] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.EnableCommenting"]' />
        public bool EnableCommenting
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.enableCommenting];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.enableCommenting] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.EnableFormatSelection"]' />
        public bool EnableFormatSelection
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.enableFormatSelection];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.enableFormatSelection] = value; }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.AutoOutlining"]' />
        public bool AutoOutlining
        {
            get { 
                object val = optionsTable[LanguageOptionKeys.autoOutlining];
                return (null == val) ? false : (bool)val;
            }
            set { optionsTable[LanguageOptionKeys.autoOutlining] = value; }
        }


        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.LanguageServicesKeyName"]' />
        private string LanguageServicesKeyName
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture,
                                     "{0}\\{1}",
                                     RegistryPaths.languageServices,
                                     LanguageName);
            }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.Register"]' />
        public override void Register(RegistrationAttribute.RegistrationContext context)
        {
            context.Log.WriteLine(SR.GetString(SR.Reg_NotifyLanguageService, LanguageName, LanguageServiceSid.ToString("B")));

            // Create our top-most language key
            using (Key serviceKey = context.CreateKey(LanguageServicesKeyName))
            {
                // Add specific entries corresponding to arguments to
                // ProvideLanguageServiceAttribute constructor.
                serviceKey.SetValue(string.Empty, LanguageServiceSid.ToString("B"));
                serviceKey.SetValue(RegistryPaths.package, context.ComponentType.GUID.ToString("B"));
                serviceKey.SetValue(RegistryPaths.languageResourceId, languageResourceID);

                // Now add any explicitly specified options.
                string name;
                string value;
                foreach(object item in optionsTable.Keys)
                {
                    name = item.ToString();
                    if (optionsTable[item] is bool)
                    {
                        // Bool values are special-cased as they need to
                        // be written as 0 or 1 instead of false or true.
                        int nValue = 0;
                        if ((bool)optionsTable[item])
                        {
                            nValue = 1;
                        }
                        serviceKey.SetValue(name, nValue);
                    }
                    else if (optionsTable[item] is int)
                    {
                        serviceKey.SetValue(name, (int)optionsTable[item]);
                    }
                    else
                    {
                        // If not bool type, always write the value as a
                        // string.
                        value = optionsTable[item].ToString();
                        serviceKey.SetValue(name, value);
                    }
                }
                if (debuggerLanguages.IsValid())
                {
                    // If any debugger language options have been specified then...
                    // Note: we are assuming there can be only one of these entries
                    // for each language service.
                    using (Key dbgLangKey = serviceKey.CreateSubkey(RegistryPaths.debuggerLanguages))
                    {
                        dbgLangKey.SetValue(debuggerLanguages.ExpressionEvaluator.ToString("B"), debuggerLanguages.LanguageName);
                    }
                }
            }
        }

        /// <include file='doc\ProvideLanguageServiceAttribute.uex' path='docs/doc[@for="ProvideLanguageServiceAttribute.Unregister"]' />
        public override void Unregister(RegistrationAttribute.RegistrationContext context)
        {
            context.RemoveKey(LanguageServicesKeyName);
        }

        // Local classes.

        // DebuggerLanguages encapsulates all elements under the
        // "Debugger Languages" registry key.  There are only two entries
        // ever under this key and that's a language name and a guid of an
        // expression evaluator.
        private class DebuggerLanguages
        {
            //////////////////////////////////////////////////////////////////
            // DebuggerLanguages Private fields.
            private Guid   guidEE;    // Expression Evaluator Guid
            private string languageName;

            //////////////////////////////////////////////////////////////////
            // DebuggerLanguages Public methods.
            public DebuggerLanguages(string languageName)
            {
                this.languageName = languageName;
                guidEE = Guid.Empty;
            }
            /// <summary>
            /// Guid of the expression evaluator.
            /// </summary>
            /// <value>Guid</value>
            public Guid ExpressionEvaluator
            {
                get { return guidEE; }
                set { guidEE = value; }
            }

            public string LanguageName
            {
                get { return languageName; }
            }

            /// <summary>
            /// Determine whether the debugger language options have been set.
            /// </summary>
            /// <returns>bool</returns>
            public bool IsValid()
            {
                return guidEE != Guid.Empty;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\ProvideLanguageEditorOptionPageAttribute.cs ===
﻿//////////////////////////////////////////////////////////////////////////////
// RegisterLanguageServiceAttribute
//
// Provide a general method for setting a language service's editor tool
// option page.
//
// This information is stored in the registry key
// <RegistrationRoot>\Languages\Language Services\[language]\EditorToolsOptions
// where [language] is the name of the language.
//
// Under EditorToolsOptions is a tree of pages and sub-pages that can
// nest any number of levels.  These pages correspond to options pages
// displayed in the Visual Studio Tools Options for editors (where the
// language name is displayed under which is a tree of option pages, each
// page containing appropriate options).
//
// Each key in this option page list contains a resoure id or literal
// string containing the localized name of the page (this is what is
// actually shown in the Tools Options dialog).  In addition, it also
// contains a package GUID and optionally a GUID of an option page.
//
// If there is no option page GUID then the key is considered a node in the
// tree of options and has no associated page.  Otherwise, the key is
// a leaf in the tree and its option page will be shown.
//
// Example:
// root base key: HKLM\Software\Microsoft\VisualStudio\9.0
//   Languages\
//     Language Services\
//       CSharp\
//         EditorToolsOptions\
//           Formatting\ = sz:#242
//             General\ = sz:#255
//               Package = sz:{GUID}
//               Page = sz:{GUID}
//             Indentation\ = sz:#250
//               Package = sz:{GUID}
//               Page = sz:{GUID}
//
// Goal:
// LanguageEditorOptionPage("CSharp","Formatting","#242");
// LanguageEditorOptionPage("CSharp","Formatting\General","#255","{PAGE GUID}");
// LanguageEditorOptionPage("CSharp","Formatting\Indentation","#250","{PAGE GUID}");
//
//////////////////////////////////////////////////////////////////////////////

#region Using directives

using System;
using System.Diagnostics;
using System.Collections;
using System.Globalization;
using System.Runtime.InteropServices;
using System.ComponentModel.Design;
using Microsoft.Win32;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell;
using MSVSIP = Microsoft.VisualStudio.Shell;

#endregion

namespace Microsoft.VisualStudio.Shell
{
    internal class LanguageToolsOptionCreator {
        // This class is used only to expose some static member, so we declare a private constructor
        // to avoid the creation of any instance of it.
        private LanguageToolsOptionCreator() { }

        private static string FormatRegKey(string languageName, string categoryName) {

            string strRegKey =
                string.Format(CultureInfo.InvariantCulture,
                              "{0}\\{1}\\{2}\\{3}",
                              RegistryPaths.languageServices,
                              languageName,
                              RegistryPaths.editorToolsOptions,
                              categoryName);
            return strRegKey;
        }

        internal static void CreateRegistryEntries(RegistrationAttribute.RegistrationContext context, string languageName, string categoryName, string categoryResourceId, Guid pageGuid)
        {

            using (RegistrationAttribute.Key serviceKey = context.CreateKey(FormatRegKey(languageName, categoryName))) {
                // Add specific entries corresponding to arguments to
                // constructor.
                serviceKey.SetValue(string.Empty, categoryResourceId);
                serviceKey.SetValue(RegistryPaths.package, context.ComponentType.GUID.ToString("B"));
                if (pageGuid != Guid.Empty) {
                    serviceKey.SetValue(RegistryPaths.page, pageGuid.ToString("B"));
                }
            }
        }

        internal static void RemoveRegistryEntries(RegistrationAttribute.RegistrationContext context, string languageName, string categoryName) {

            context.RemoveKey(FormatRegKey(languageName, categoryName));
        }
    }

    /// <include file='doc\ProvideLanguageEditorOptionPageAttribute.uex' path='docs/doc[@for="ProvideLanguageEditorToolsOptionCategoryAttribute"]' />
    /// <devdoc>
    /// This attribute is used to declare a ToolsOption category for a language.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
    public sealed class ProvideLanguageEditorToolsOptionCategoryAttribute : RegistrationAttribute {
        private string languageName;
        private string categoryName;
        private string categoryResourceId;

        /// <include file='doc\ProvideLanguageEditorOptionPageAttribute.uex' path='docs/doc[@for="ProvideLanguageEditorToolsOptionCategoryAttribute.ProvideLanguageEditorToolsOptionCategoryAttribute"]' />
        /// <devdoc>
        /// Creates a new ProvideLanguageEditorToolsOptionCategory attribute for a given language and category.
        /// </devdoc>
        /// <param name="languageName">The name of the language.</param>
        /// <param name="categoryName">The name of the category.</param>
        /// <param name="categoryResourceId">The id of the resource with the localized name for the category.</param>
        public ProvideLanguageEditorToolsOptionCategoryAttribute(string languageName, string categoryName, string categoryResourceId) {
            this.languageName = languageName;
            this.categoryName = categoryName;
            this.categoryResourceId = categoryResourceId;
        }

        /// <include file='doc\ProvideLanguageEditorOptionPageAttribute.uex' path='docs/doc[@for="ProvideLanguageEditorToolsOptionCategoryAttribute.Register"]' />
        public override void Register(RegistrationAttribute.RegistrationContext context) {
            context.Log.WriteLine(SR.GetString(SR.Reg_NotifyLanguageOptionCategory, languageName, categoryName));

            // Create the registry entries using the creator object.
            LanguageToolsOptionCreator.CreateRegistryEntries(context, languageName, categoryName, categoryResourceId, Guid.Empty);
        }

        /// <include file='doc\ProvideLanguageEditorOptionPageAttribute.uex' path='docs/doc[@for="ProvideLanguageEditorToolsOptionCategoryAttribute.Unregister"]' />
        public override void Unregister(RegistrationAttribute.RegistrationContext context) {
            // Remove the entries using the creator object.
            LanguageToolsOptionCreator.RemoveRegistryEntries(context, languageName, categoryName);
        }
    }

    /// <include file='doc\ProvideLanguageEditorOptionPageAttribute.uex' path='docs/doc[@for="ProvideLanguageEditorOptionPageAttribute"]' />
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
    public sealed class ProvideLanguageEditorOptionPageAttribute : ProvideOptionDialogPageAttribute
    {
        private string languageName;
        private string pageName;
        private string category;

        /// <include file='doc\ProvideLanguageEditorOptionPageAttribute.uex' path='docs/doc[@for="ProvideLanguageEditorOptionPageAttribute.ProvideLanguageEditorOptionPageAttribute"]' />
        /// <devdoc>
        /// Constructor for node with child option pages (to be added with
        /// additional ProvideLanguageEditorOptionPageAttribute).
        /// </devdoc>
        public ProvideLanguageEditorOptionPageAttribute(
            Type pageType,
            string languageName,
            string category,
            string pageName,
            string pageNameResourceId
            ) : base(pageType, pageNameResourceId)
        {
            this.languageName = languageName;
            this.pageName = pageName;
            this.category = category;
        }

        //////////////////////////////////////////////////////////////////////
        // Properties.

        /// <include file='doc\ProvideLanguageEditorOptionPageAttribute.uex' path='docs/doc[@for="ProvideLanguageEditorOptionPageAttribute.LanguageName"]' />
        public string LanguageName
        {
            get { return languageName; }
        }

        /// <include file='doc\ProvideLanguageEditorOptionPageAttribute.uex' path='docs/doc[@for="ProvideLanguageEditorOptionPageAttribute.PageGuid"]' />
        public Guid PageGuid
        {
            get { return PageType.GUID; }
        }

        private string FullPathToPage {
            get {
                if (string.IsNullOrEmpty(category))
                    return pageName;
                return string.Format("{0}\\{1}", category, pageName);
            }
        }
        //////////////////////////////////////////////////////////////////////
        // Public methods.

        /// <include file='doc\ProvideLanguageEditorOptionPageAttribute.uex' path='docs/doc[@for="ProvideLanguageEditorOptionPageAttribute.Register"]' />
        public override void Register(RegistrationAttribute.RegistrationContext context)
        {
            context.Log.WriteLine(SR.GetString(SR.Reg_NotifyLanguageOptionPage, LanguageName, PageNameResourceId));

            // Create the registry entries using the creator object.
            LanguageToolsOptionCreator.CreateRegistryEntries(context, LanguageName, FullPathToPage, PageNameResourceId, PageGuid);
        }

        /// <include file='doc\ProvideLanguageEditorOptionPageAttribute.uex' path='docs/doc[@for="ProvideLanguageEditorOptionPageAttribute.Unregister"]' />
        public override void Unregister(RegistrationAttribute.RegistrationContext context)
        {
            // Remove the registry entries for this page.
            LanguageToolsOptionCreator.RemoveRegistryEntries(context, LanguageName, FullPathToPage);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\ProvideMenuResourceAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideMenuResourceAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\ProvideMenuResourceAttribute.uex' path='docs/doc[@for="ProvideMenuResourceAttribute"]' />
    /// <devdoc>
    ///     This attribute declares that a package offers menu resources.  When Visual Studio encounters 
    ///     such a package it will merge the menu resource information in its menus.  The attributes on a 
    ///     package do not control the behavior of the package, but they can be used by registration 
    ///     tools to register the proper information with Visual Studio.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideMenuResourceAttribute : RegistrationAttribute {

        private short _resourceID;
        private int   _version;
    
        /// <include file='doc\ProvideMenuResourceAttribute.uex' path='docs/doc[@for="ProvideMenuResourceAttribute.ProvideMenuResourceAttribute"]' />
        /// <devdoc>
        ///     Creates a new ProvideMenuResourceAttribute.
        /// </devdoc>
        public ProvideMenuResourceAttribute (short resourceID, int version) {
            _resourceID = resourceID;
            _version = version;
        }
        
        /// <include file='doc\ProvideMenuResourceAttribute.uex' path='docs/doc[@for="ProvideMenuResourceAttribute.ResourceID"]' />
        /// <devdoc>
        ///     Returns the native resource ID for the menu resource.
        /// </devdoc>
        public short ResourceID {
            get {
                return _resourceID;
            }
        }
        
        /// <include file='doc\ProvideMenuResourceAttribute.uex' path='docs/doc[@for="ProvideMenuResourceAttribute.Version"]' />
        /// <devdoc>
        ///     Returns the version of this menu resource.
        /// </devdoc>
        public int Version {
            get {
                return _version;
            }
        }

        /// <include file='doc\ProvideMenuResourceAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(SR.GetString(SR.Reg_NotifyMenuResource, ResourceID, Version));

            using (Key childKey = context.CreateKey("Menus"))
            {
                childKey.SetValue(context.ComponentType.GUID.ToString("B"), string.Format(CultureInfo.InvariantCulture, ", {0}, {1}", ResourceID, Version));
            }
        }

        /// <summary>
        ///     Called to unregister this attribute with the given context.
        /// </summary>
        /// <param name="context">
        ///     Contains the location where the registration inforomation should be placed.
        ///     It also contains other informations as the type being registered and path information.
        /// </param>
        public override void Unregister(RegistrationContext context) {
            context.RemoveValue("Menus", context.ComponentType.GUID.ToString("B"));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\ProvideLanguageCodeExpansionAttribute.cs ===
﻿//////////////////////////////////////////////////////////////////////////////
// ProvideLanguageCodeExpansionAttribute
//
// This attribute class will ease the pain of registering a language
// service's support for code snippets written with the managed
// package framework.
//
// Usage:
// [ProvideLanguageCodeExpansionAttribute(<type> or "<GUID>",
//                                        <language name>,
//                                        <language name id>,
//                                        "<language identifier>",
//                                        "<Path to snippet index file>",
//   ShowRoots = true | false
//   SearchPaths = "<semi-colon-delimited path list to snippet index
//                  files>"
//   ForceCreateDirs = "<semi-colon-delimited list of dirs that the
//                  expansion manager will create>
// )]
//
//////////////////////////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.Text;
using System.Globalization;
using System.Runtime.InteropServices;
using System.ComponentModel.Design;
using Microsoft.Win32;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell;

//namespace Vsip.TestPackage
namespace Microsoft.VisualStudio.Shell
{
    /// <include file='doc\ProvideLanguageCodeExpansionAttribute.uex' path='docs/doc[@for="ProvideLanguageCodeExpansionAttribute"]' />
    [ComVisible(false)]
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)]
    public sealed class ProvideLanguageCodeExpansionAttribute : RegistrationAttribute
    {
        //////////////////////////////////////////////////////////////////////
        // ProvideLanguageServiceAttribute Private fields.
        //
        private Guid   languageServiceGuid;
        private string languageName;
        private string snippetIndexPath;
        private string searchPaths;
        private string forceCreateDirs;
        private string languageIdString;
        private string displayName;
        private bool   showRoots = false;


        //////////////////////////////////////////////////////////////////////
        // ProvideLanguageServiceAttribute Public Methods

        /// <include file='doc\ProvideLanguageCodeExpansionAttribute.uex' path='docs/doc[@for="ProvideLanguageCodeExpansionAttribute.ProvideLanguageCodeExpansionAttribute"]' />
        /// <devdoc>
        /// Registers a language service's support for code snippets.
        /// </devdoc>
        /// <param name="languageService">Language Service class. This can be a string with the value of the Guid or the Type of the language service.</param>
        /// <param name="languageName">Name of the language service.  Used in the registry so cannot be localized.</param>
        /// <param name="languageResourceId">Resource ID of the localized name of the language service.</param>
        /// <param name="languageIdentifier">String used to identify snippets and the snippets index file.</param>
        /// <param name="pathToSnippetIndexFile">Full path to a snippets index file.</param>
        public ProvideLanguageCodeExpansionAttribute(
            object languageService,
            string languageName,
            int languageResourceId,
            string languageIdentifier,
            string pathToSnippetIndexFile)
        {
            // Get the guid of the language service.
            if (languageService is Type)
            {
                this.languageServiceGuid = ((Type)languageService).GUID;
            }
            else if (languageService is string)
            {
                this.languageServiceGuid = new Guid((string)languageService);
            }
            else
                throw new ArgumentException();

            this.languageName     = languageName;
            this.snippetIndexPath = pathToSnippetIndexFile;
            this.displayName      = languageResourceId.ToString(CultureInfo.InvariantCulture);
            this.languageIdString = languageIdentifier;
        }

        // ProvideLanguageCodeExpansionAttribute Properties.

        /// <include file='doc\ProvideLanguageCodeExpansionAttribute.uex' path='docs/doc[@for="ProvideLanguageCodeExpansionAttribute.LanguageServiceSid"]' />
        public Guid LanguageServiceSid
        {
            get { return languageServiceGuid; }
        }

        /// <include file='doc\ProvideLanguageCodeExpansionAttribute.uex' path='docs/doc[@for="ProvideLanguageCodeExpansionAttribute.LanguageName"]' />
        public string LanguageName
        {
            get { return languageName; }
        }


        //////////////////////////////////////////////////////////////////////
        // The following properties are entries in the language key.  These
        // are all optional (however, if they are specified by the user, they
        // will be created in the registry, regardless if they have a value or
        // not).

        /// <include file='doc\ProvideLanguageCodeExpansionAttribute.uex' path='docs/doc[@for="ProvideLanguageCodeExpansionAttribute.ShowRoots"]' />
        public bool ShowRoots
        {
            get { return showRoots; }
            set { showRoots = value; }
        }

        /// <include file='doc\ProvideLanguageCodeExpansionAttribute.uex' path='docs/doc[@for="ProvideLanguageCodeExpansionAttribute.SearchPaths"]' />
        public string SearchPaths
        {
            get { return searchPaths; }
            set { searchPaths = value; }
        }

        /// <include file='doc\ProvideLanguageCodeExpansionAttribute.uex' path='docs/doc[@for="ProvideLanguageCodeExpansionAttribute.ForceCreateDirs"]' />
        public string ForceCreateDirs
        {
            get { return forceCreateDirs; }
            set { forceCreateDirs = value; }
        }
        //////////////////////////////////////////////////////////////////////
        // Helper property
        private string LanguageRegistryKey
        {
            get
            {
                return string.Format(CultureInfo.InvariantCulture,
                                     "{0}\\{1}",
                                     RegistryPaths.codeExpansion,
                                     LanguageName);
            }
        }

        
        //////////////////////////////////////////////////////////////////////
        // ProvideLanguageCodeExpansionAttribute Public Methods.

        /// <include file='doc\ProvideLanguageCodeExpansionAttribute.uex' path='docs/doc[@for="ProvideLanguageCodeExpansionAttribute.Register"]' />
        public override void Register(RegistrationAttribute.RegistrationContext context)
        {
            context.Log.WriteLine(SR.GetString(SR.Reg_NotifyLanguageCodeExpansion, LanguageServiceSid.ToString("B")));

            string packageGuid = context.ComponentType.GUID.ToString("B");
            // Create our top-most language key
            using (Key serviceKey = context.CreateKey(LanguageRegistryKey))
            {
                // Add specific entries corresponding to arguments to
                // ProvideLanguageCodeExpansionAttribute constructor.
                serviceKey.SetValue(string.Empty, LanguageServiceSid.ToString("B"));
                serviceKey.SetValue(RegistryPaths.package, packageGuid);
                serviceKey.SetValue(RegistryPaths.displayName, displayName);
                serviceKey.SetValue(RegistryPaths.languageStringId, languageIdString);
                serviceKey.SetValue(RegistryPaths.indexPath, snippetIndexPath);
                serviceKey.SetValue(RegistryPaths.showRoots, showRoots ? 1 : 0);
                if (!string.IsNullOrEmpty(SearchPaths))
                {
                    using (Key pathsKey = serviceKey.CreateSubkey(RegistryPaths.paths))
                    {
                        pathsKey.SetValue(LanguageName, SearchPaths);
                    }
                }
                if (!string.IsNullOrEmpty(ForceCreateDirs))
                {
                    using (Key forceCreateKey = serviceKey.CreateSubkey(RegistryPaths.forceCreateDirs))
                    {
                        forceCreateKey.SetValue(LanguageName, ForceCreateDirs);
                    }
                }
            }
        }

        /// <include file='doc\ProvideLanguageCodeExpansionAttribute.uex' path='docs/doc[@for="ProvideLanguageCodeExpansionAttribute.Unregister"]' />
        public override void Unregister(RegistrationAttribute.RegistrationContext context)
        {
            context.RemoveKey(LanguageRegistryKey);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\ProvideObjectAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideObjectAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\ProvideObjectAttribute.uex' path='docs/doc[@for="ProvideObjectAttribute"]' />
    /// <devdoc>
    ///     This attribute declares a class as creatable through Visual Studio.  
    ///     A creatable class will be given an entry in Visual Studio's local 
    ///     registry at install time.  The objectType parameter specifies the
    ///     data type of the object that will be created.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideObjectAttribute : RegistrationAttribute {

        private Type _objectType;
        private RegistrationMethod registrationMethod = RegistrationMethod.Default;
    
        /// <include file='doc\ProvideObjectAttribute.uex' path='docs/doc[@for="ProvideObjectAttribute.ProvideObjectAttribute"]' />
        /// <devdoc>
        ///     Creates a new ProvideObjectAttribute.
        /// </devdoc>
        public ProvideObjectAttribute (Type objectType) {
            if (objectType == null) {
                throw new ArgumentNullException("objectType");
            }
            _objectType = objectType;
        }
        
        /// <include file='doc\ProvideObjectAttribute.uex' path='docs/doc[@for="ProvideObjectAttribute.ObjectType"]' />
        /// <devdoc>
        ///     The type of object that can be created from this package.
        /// </devdoc>
        public Type ObjectType {
            get {
                return _objectType;
            }
        }

        /// <summary>
        /// Select between specifying the Codebase entry or the Assembly entry in the registry.
        /// This can be overriden during registration
        /// </summary>
        public RegistrationMethod RegisterUsing
        {
            get
            {
                return registrationMethod;
            }
            set
            {
                registrationMethod = value;
            }
        }

        private string CLSIDRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, "CLSID\\{0}", ObjectType.GUID.ToString("B")); }
        }

        /// <include file='doc\ProvideObjectAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(SR.GetString(SR.Reg_NotifyCreateObject, ObjectType.Name));

            using (Key childKey = context.CreateKey(CLSIDRegKey))
            {
                childKey.SetValue(string.Empty, ObjectType.FullName);
                childKey.SetValue("InprocServer32", context.InprocServerPath);
                childKey.SetValue("Class", ObjectType.FullName);

                // If specified on the command line, let the command line option override
                if (context.RegistrationMethod != RegistrationMethod.Default) {
                    registrationMethod = context.RegistrationMethod;
                }

            switch(registrationMethod) {
                case RegistrationMethod.Default:
                case RegistrationMethod.Assembly:
                    childKey.SetValue("Assembly", ObjectType.Assembly.FullName);
                    break;
                
                    case RegistrationMethod.CodeBase:
                        childKey.SetValue("CodeBase", context.CodeBase);
                        break;
                }

                childKey.SetValue("ThreadingModel", "Both");
            }
        }
        /// <summary>
        /// Unregisters this attribute.
        /// </summary>
        /// <param name="context">
        ///     Contains the location from where the registration inforomation should be removed.
        ///     It also contains other informations as the type being unregistered and path information.
        /// </param>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(CLSIDRegKey);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\ProvideLoadKeyAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideLoadKeyAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\ProvideLoadKeyAttribute.uex' path='docs/doc[@for="ProvideLoadKeyAttribute"]' />
    /// <devdoc>
    ///     This attribute registers a package load key for your package.  
    ///     Package load keys are used by Visual Studio to validate that 
    ///     a package can be loaded.    
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, Inherited=false, AllowMultiple=false)]
    public sealed class ProvideLoadKeyAttribute : RegistrationAttribute {

        private string _minimumEdition;
        private string _productVersion;
        private string _productName;
        private string _companyName;
        private short  _resourceId;
    
        /// <include file='doc\ProvideLoadKeyAttribute.uex' path='docs/doc[@for="ProvideLoadKeyAttribute.ProvideLoadKeyAttribute"]/*' />
        public ProvideLoadKeyAttribute (string minimumEdition, string productVersion, string productName, string companyName, short resourceId) {
            if (minimumEdition == null) {
                throw new ArgumentNullException("minimumEdition");
            }
            if (productVersion == null) {
                throw new ArgumentNullException("productVersion");
            }
            if (productName == null) {
                throw new ArgumentNullException("productName");
            }
            if (companyName == null) {
                throw new ArgumentNullException("companyName");
            }
            
            _minimumEdition = minimumEdition;
            _productVersion = productVersion;
            _productName = productName;
            _companyName = companyName;
            _resourceId = resourceId;
        }
        
        /// <include file='doc\ProvideLoadKeyAttribute.uex' path='docs/doc[@for="ProvideLoadKeyAttribute.MinEdition"]' />
        /// <devdoc>
        ///     Minimum edition of Visual Studio on which
        ///     VSPackage is loaded. This must be the literal 
        ///     edition value provided by Microsoft when 
        ///     obtaining your PLK.
        /// </devdoc>
        public string MinimumEdition {
            get {
                return _minimumEdition;
            }
        }

        /// <include file='doc\ProvideLoadKeyAttribute.uex' path='docs/doc[@for="ProvideLoadKeyAttribute.ProductVersion"]' />
        /// <devdoc>
        ///     Version of the product that this VSPackage
        ///     implements.
        /// </devdoc>
        public string ProductVersion {
            get {
                return _productVersion;
            }
        }
        
        /// <include file='doc\ProvideLoadKeyAttribute.uex' path='docs/doc[@for="ProvideLoadKeyAttribute.ProductName"]' />
        /// <devdoc>
        ///     Name of the product that this VSPackage 
        ///     delivers. Note that one product might be
        ///     comprised of multiple VSPackages, in which 
        ///     case each will need its own PLK.
        /// </devdoc>
        public string ProductName {
            get {
                return _productName;
            }
        }

        /// <include file='doc\ProvideLoadKeyAttribute.uex' path='docs/doc[@for="ProvideLoadKeyAttribute.CompanyName"]' />
        /// <devdoc>
        ///     VSIP Partner/creator of the VSPackage. 
        ///     The literal name (case-sensitive) provided 
        ///     to Microsoft when registering for a PLK.
        /// </devdoc>
        public string CompanyName {
            get {
                return _companyName;
            }
        }
        
        /// <include file='doc\ProvideLoadKeyAttribute.uex' path='docs/doc[@for="ProvideLoadKeyAttribute.ResourceId"]' />
        /// <devdoc>
        ///     Resource ID for VSPackage load key.
        /// </devdoc>
        public short ResourceId {
            get {
                return _resourceId;
            }
        }

        /// <summary>
        /// Registry Key name for this package's load key information.
        /// </summary>
        /// <param name="context"></param>
        /// <returns></returns>
        public string RegKeyName (RegistrationContext context)
        {
            return string.Format(CultureInfo.InvariantCulture, "Packages\\{0}", context.ComponentType.GUID.ToString("B"));
        }

        /// <include file='doc\ProvideLoadKeyAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(SR.GetString(SR.Reg_NotifyLoadKey, CompanyName, ProductName, ProductVersion, MinimumEdition));

            using (Key packageKey = context.CreateKey(RegKeyName(context)))
            {
                packageKey.SetValue("ID", ResourceId);
                packageKey.SetValue("MinEdition", MinimumEdition);
                packageKey.SetValue("ProductVersion", ProductVersion);
                packageKey.SetValue("ProductName", ProductName);
                packageKey.SetValue("CompanyName", CompanyName);
            }
        }

        /// <summary>
        /// Unregisters this package's load key information
        /// </summary>
        /// <param name="context"></param>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(RegKeyName(context));
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\ProvideOptionPageAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideOptionPageAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\ProvideOptionPageAttribute.uex' path='docs/doc[@for="ProvideOptionPageAttribute"]' />
    /// <devdoc>
    ///     This attribute declares that a package offers one or more option pages.  
    ///     Option pages are exposed to the user through Visual Studio's Tools->Options 
    ///     dialog.  The first parameter to this attribute is the type of option page, 
    ///     which is a type that must derive from DialogPage.  Option page attributes 
    ///     are read by the package class when Visual Studio requests a particular option 
    ///     page GUID.  Package will walk the attributes and try to match the requested 
    ///     GUID to a GUID on a type in the package. 
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideOptionPageAttribute : ProvideOptionDialogPageAttribute {

        private string  _categoryName;
        private string  _pageName;
        private short   _categoryResourceID;
        private bool    _supportsAutomation;
        private bool    _noShowAllView;
        private bool    _supportsProfiles = false;
        
        /// <include file='doc\ProvideOptionPageAttribute.uex' path='docs/doc[@for="ProvideOptionPageAttribute.ProvideOptionPageAttribute"]' />
        /// <devdoc>
        ///     The page type is a type that derives from
        ///     DialogPage.  The nameResourceID
        ///     parameter specifies a Win32 resource ID in the 
        ///     stored in the native UI resource satellite
        ///     that describes the name of this page.
        ///     The categoryResourceID specifies the page
        ///     category name.
        /// </devdoc>        
        public ProvideOptionPageAttribute(Type pageType, string categoryName, string pageName, short categoryResourceID, short pageNameResourceID, bool supportsAutomation) 
            : base (pageType, "#"+pageNameResourceID.ToString()) {
            if (categoryName == null) {
                throw new ArgumentNullException("categoryName");
            }
            if (pageName == null) {
                throw new ArgumentNullException("pageName");
            }

            _categoryName = categoryName;
            _pageName = pageName;
            _categoryResourceID = categoryResourceID;
            _supportsAutomation = supportsAutomation;
        }

        /// <devdoc>
        /// The VB Simplified option page is visible only for "simply" pages, that is a page that sets this
        /// parameter to true.
        /// </devdoc>
        public bool NoShowAllView {
            get { return _noShowAllView;  }
            set { _noShowAllView = value; }
        }

        
        /// <include file='doc\ProvideOptionPageAttribute.uex' path='docs/doc[@for="ProvideOptionPageAttribute.TypeId"]' />
        /// <devdoc>
        /// Identity of this instance of the attribute.
        /// </devdoc>
        public override object TypeId {
            get {
                return this;
            }
        }

        /// <include file='doc\ProvideOptionPageAttribute.uex' path='docs/doc[@for="ProvideOptionPageAttribute.CategoryName"]' />
        /// <devdoc>
        ///     The programmatic name for this category (non localized).
        /// </devdoc>
        public string CategoryName {
            get {
                return _categoryName;
            }
        }

        /// <include file='doc\ProvideOptionPageAttribute.uex' path='docs/doc[@for="ProvideOptionPageAttribute.CategoryResourceID"]' />
        /// <devdoc>
        ///     The native resourceID of the category name for this page.
        /// </devdoc>
        public short CategoryResourceID {
            get {
                return _categoryResourceID;
            }
        }

        /// <include file='doc\ProvideOptionPageAttribute.uex' path='docs/doc[@for="ProvideOptionPageAttribute.PageName"]' />
        /// <devdoc>
        ///     The programmatic name for this page (non localized).
        /// </devdoc>
        public string PageName {
            get {
                return _pageName;
            }
        }

        /// <include file='doc\ProvideOptionPageAttribute.uex' path='docs/doc[@for="ProvideOptionPageAttribute.SupportsAutomation"]' />
        /// <devdoc>
        ///     True if this page should be registered as supporting automation.
        /// </devdoc>
        public bool SupportsAutomation {
            get {
                return _supportsAutomation;
            }
        }

        /// <include file='doc\ProvideOptionPageAttribute.uex' path='docs/doc[@for="ProvideOptionPageAttribute.SupportsProfiles"]' />
        /// <devdoc>
        ///     True if this page should be registered as supporting profiles.  
        ///     Note: Only works if SupportsAutomation is true.  The ProvideProfile attribute 
        ///     can also be used to specify profile support for Tools/Options pages.
        /// </devdoc>
        public bool SupportsProfiles {
            get {
                return _supportsProfiles;
            }
            set {
                _supportsProfiles = value;
            }
        }

        private string ToolsOptionsPagesRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, "ToolsOptionsPages\\{0}", CategoryName); }
        }

        private string AutomationCategoryRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, "AutomationProperties\\{0}", CategoryName); }
        }
        private string AutomationRegKey
        {
            get { return String.Format(CultureInfo.InvariantCulture, "{0}\\{1}", AutomationCategoryRegKey, PageName); }
        }

        /// <include file='doc\ProvideOptionPageAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(SR.GetString(SR.Reg_NotifyOptionPage, CategoryName, PageName));

            using (Key toolsOptionsKey = context.CreateKey(ToolsOptionsPagesRegKey))
            {
                toolsOptionsKey.SetValue(string.Empty, string.Format(CultureInfo.InvariantCulture, "#{0}", CategoryResourceID));
                toolsOptionsKey.SetValue("Package", context.ComponentType.GUID.ToString("B"));

                using (Key pageKey = toolsOptionsKey.CreateSubkey(PageName))
                {
                    pageKey.SetValue(string.Empty, PageNameResourceId);
                    pageKey.SetValue("Package", context.ComponentType.GUID.ToString("B"));
                    pageKey.SetValue("Page", PageType.GUID.ToString("B"));
                    if ( NoShowAllView )
                        pageKey.SetValue("NoShowAllView", 1);
                }
            }

            if (SupportsAutomation) {
                using (Key automationKey = context.CreateKey(AutomationRegKey))
                {
                    automationKey.SetValue("Name", string.Format(CultureInfo.InvariantCulture, "{0}.{1}", CategoryName, PageName));
                    automationKey.SetValue("Package", context.ComponentType.GUID.ToString("B"));
                    if ( SupportsProfiles ) {
                        automationKey.SetValue("ProfileSave", 1);
                    }
                }
            }

        }

        /// <include file='doc\ProvideOptionPageAttribute.uex' path='docs/doc[@for="Unregister"]' />
        /// <devdoc>
        /// Called to remove this attribute from the given context.
        /// </devdoc>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(ToolsOptionsPagesRegKey);

            if (SupportsAutomation)
            {
                context.RemoveKey(AutomationRegKey);
                context.RemoveKeyIfEmpty(AutomationCategoryRegKey);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\ProvideOptionDialogPageAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideOptionPageAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\ProvideOptionDialogPageAttribute.uex' path='docs/doc[@for="ProvideOptionDialogPageAttribute"]' />
    /// <devdoc>
    /// This is the base class for all the attributes that are used to register an option page.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public abstract class ProvideOptionDialogPageAttribute : RegistrationAttribute {

        // The type of the option page provided with this attribute. This type must derive from DialogPage.
        private Type _pageType;
        // The id of the resource storing the localized name of the option page.
        private string _pageNameResourceId;

        /// <include file='doc\ProvideOptionDialogPageAttribute.uex' path='docs/doc[@for="ProvideOptionDialogPageAttribute.ProvideOptionDialogPageAttribute"]' />
        /// <devdoc>
        /// This is the constructor of this attribute; it will set the type of the proferred option page.
        /// </devdoc>
        /// <param name="pageType"></param>
        /// <param name="pageNameResourceId"></param>
        public ProvideOptionDialogPageAttribute(Type pageType, string pageNameResourceId)
        {
            // Check the input type: as first make sure this is not null...
            if (pageType == null) {
                throw new ArgumentNullException("pageType");
            }
            // .. then make sure that it derives from DialogPage.
            if (!typeof(DialogPage).IsAssignableFrom(pageType)) {
                throw new ArgumentException(SR.GetString(SR.Package_PageNotDialogPage, pageType.FullName));
            }
            _pageType = pageType;
            _pageNameResourceId = pageNameResourceId;
        }

        /// <include file='doc\ProvideOptionDialogPageAttribute.uex' path='docs/doc[@for="ProvideOptionDialogPageAttribute.PageType"]' />
        /// <devdoc>
        /// Gets the type of the option page provided with this attribute.
        /// </devdoc>
        public Type PageType {
            get { return _pageType; }
        }

        /// <include file='doc\ProvideOptionDialogPageAttribute.uex' path='docs/doc[@for="ProvideOptionDialogPageAttribute.PageNameResourceId"]' />
        /// <devdoc>
        /// Gets the id of the resource storing the localized name of the option page.
        /// </devdoc>
        public string PageNameResourceId {
            get { return _pageNameResourceId; }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\ProvideToolboxFormatAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideToolboxFormatAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;

    /// <include file='doc\ProvideToolboxFormatAttribute.uex' path='docs/doc[@for="ProvideToolboxFormatAttribute"]' />
    /// <devdoc>
    ///     This attribute declares a single toolbox clipboard format that
    ///     the package supports.  Multiple attributes can be added to
    ///     a package to allow more than one clipboard format.  By
    ///     providing this attribute on your package, you enable
    ///     users to drag data objects containing this format onto the
    ///     toolbox. You must still handle the drop notifications 
    ///     yourself.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, Inherited=true, AllowMultiple=true)]
    public sealed class ProvideToolboxFormatAttribute : Attribute {

        private string _format;
    
        /// <include file='doc\ProvideToolboxFormatAttribute.uex' path='docs/doc[@for="ProvideToolboxFormatAttribute.ProvideToolboxFormatAttribute"]' />
        /// <devdoc>
        ///     Creates a new ProvideToolboxFormatAttribute.
        /// </devdoc>
        public ProvideToolboxFormatAttribute(string format) {

            if (format == null) {
                throw new ArgumentNullException("format");
            }

            _format = format;
        }
    
        /// <include file='doc\ProvideToolboxFormatAttribute.uex' path='docs/doc[@for="ProvideToolboxFormatAttribute.Format"]' />
        /// <devdoc>
        ///     Returns the clipboard format to enable for this package.
        /// </devdoc>
        public string Format {
            get {
                return _format;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\ProvideProjectItemAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideProjectItemAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell
{
    using System;
    using System.IO;
    using System.Diagnostics;
    using System.Globalization;


    /// <include file='doc\ProvideProjectItemAttribute.uex' path='docs/doc[@for="ProvideProjectItemAttribute"]' />
    /// <devdoc>
    ///     This attribute associates register items to be included in the Add New Item.  
    ///     dialog for the specified project type. It is placed on a package.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideProjectItemAttribute : RegistrationAttribute
    {
        private int priority;
        private Guid factory;
        private string templateDir;
        private string itemType;

        /// <include file='doc\ProvideProjectItemAttribute.uex' path='docs/doc[@for="ProvideProjectItemAttribute.ProvideProjectItemAttribute"]' />
        /// <devdoc>
        ///     Creates a new attribute.
        /// </devdoc>
        public ProvideProjectItemAttribute(object projectFactoryType, string itemCategoryName, string templatesDir, int priority)
        {
            if (templatesDir == null || templatesDir.Length == 0)
                throw new ArgumentNullException("templatesDir");

            if (itemCategoryName == null || itemCategoryName.Length == 0)
                throw new ArgumentNullException("itemCategoryName");

            // figure out what type of object they passed in and get the GUID from it
            if (projectFactoryType is string)
                this.factory = new Guid((string)projectFactoryType);
            else if (projectFactoryType is Type)
                this.factory = ((Type)projectFactoryType).GUID;
            else if (projectFactoryType is Guid)
                this.factory = (Guid)projectFactoryType;
            else
                throw new ArgumentException(SR.GetString(SR.Attributes_InvalidFactoryType, projectFactoryType));

            this.priority = priority;
            this.templateDir = templatesDir;
            this.itemType = itemCategoryName;
        }

        /// <include file='doc\ProvideProjectItemAttribute.uex' path='docs/doc[@for="ProvideProjectItemAttribute.ProjectFactoryType"]' />
        /// <devdoc>
        ///     The Project factory guid.
        /// </devdoc>
        public Guid ProjectFactoryType
        {
            get {return factory;}
        }

        /// <include file='doc\ProvideProjectItemAttribute.uex' path='docs/doc[@for="ProvideProjectItemAttribute.Priority"]' />
        /// <devdoc>
        ///     The priority of this item.
        /// </devdoc>
        public int Priority
        {
            get {return priority;}
        }

        /// <include file='doc\ProvideProjectItemAttribute.uex' path='docs/doc[@for="ProvideProjectItemAttribute.TemplateDir"]/*' />
        public string TemplateDir
        {
            get { return templateDir; }
        }

        /// <include file='doc\ProvideProjectItemAttribute.uex' path='docs/doc[@for="ProvideProjectItemAttribute.ItemType"]/*' />
        /// <summary>
        /// String describing the item type. This string is used as the folder in the
        /// left side of the "Add New Items" dialog.
        /// </summary>
        public string ItemType
        {
            get { return itemType; }
        }


        /// <summary>
        ///        The reg key name of the project.
        /// </summary>
        private string ProjectRegKeyName(RegistrationContext context) 
        {
            return string.Format(CultureInfo.InvariantCulture, "Projects\\{0}\\AddItemTemplates\\TemplateDirs\\{1}\\/1",
                                factory.ToString("B"),
                                context.ComponentType.GUID.ToString("B"));
        }

        /// <include file='doc\ProvideProjectItemAttribute.uex' path='docs/doc[@for="ProvideProjectItemAttribute.Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context)
        {
            context.Log.WriteLine(SR.GetString(SR.Reg_NotifyProjectItems, factory.ToString("B")));

            using (Key childKey = context.CreateKey(ProjectRegKeyName(context)))
            {
                childKey.SetValue("", itemType);

                Uri url = new Uri(context.ComponentType.Assembly.CodeBase, true);
                string templates = url.LocalPath;
                templates = System.IO.Path.Combine(System.IO.Path.GetDirectoryName(templates), templateDir);
                templates = context.EscapePath(System.IO.Path.GetFullPath(templates));
                childKey.SetValue("TemplatesDir", templates);

                childKey.SetValue("SortPriority", Priority);
            }
        }

        /// <include file='doc\ProvideProjectItemAttributeProjectItem.uex' path='docs/doc[@for="ProvideProjectItemAttribute.Unregister"]/*' />
        /// <summary>
        /// Unregister this editor.
        /// </summary>
        /// <param name="context"></param>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(ProjectRegKeyName(context));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\ProvideServiceAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideServiceAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\ProvideServiceAttribute.uex' path='docs/doc[@for="ProvideServiceAttribute"]' />
    /// <devdoc>
    ///     This attribute declares that a package provides a particular service.  The attributes on a 
    ///     package do not control the behavior of the package, but they can be used by registration 
    ///     tools to register the proper information with Visual Studio.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideServiceAttribute : RegistrationAttribute {

        private string _name;
        private Guid _serviceGuid;
        private Type _serviceType;

        /// <param name="serviceType"></param>
        public ProvideServiceAttribute(object serviceType)
        {
            _serviceType = null;
            // figure out what type of object they passed in and get the GUID from it
			if (serviceType is string)
                _serviceGuid = new Guid((string)serviceType);
            else if (serviceType is Type)
			{
                _serviceType = (Type)serviceType;
                _serviceGuid = _serviceType.GUID;
                _name = _serviceType.Name;
            }
			else if (serviceType is Guid)
                _serviceGuid = (Guid)serviceType;
            else
				throw new ArgumentException(SR.GetString(SR.Attributes_InvalidFactoryType, serviceType));
        }

        /// <summary>
        /// Name of the service
        /// </summary>
        public string ServiceName
        {
            get {return _name;}
            set {_name = value;}
        }

        /// <summary>
        /// Type of the service.
        /// </summary>
        public Type Service
        {
            get { return _serviceType; }
        }

        /// <include file='doc\ProvideServiceAttribute.uex' path='docs/doc[@for="ProvideServiceAttribute.ServiceType"]' />
        /// <devdoc>
        ///     Returns the service's Guid declared in this attribute.
        /// </devdoc>
        public Guid ServiceType {
            get {
                return _serviceGuid;
            }
        }

        private string ServiceRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, "Services\\{0}", ServiceType.ToString("B")); }
        }

        /// <include file='doc\ProvideServiceAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(SR.GetString(SR.Reg_NotifyService, ServiceName));

            using (Key serviceKey = context.CreateKey(ServiceRegKey))
            {
                serviceKey.SetValue(string.Empty, context.ComponentType.GUID.ToString("B"));
                serviceKey.SetValue("Name", ServiceName);
            }
        }

        /// <summary>
        /// Unregisters this attribute.
        /// </summary>
        /// <param name="context">
        ///     Contains the location from where the registration inforomation should be removed.
        ///     It also contains other informations as the type being unregistered and path information.
        /// </param>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(ServiceRegKey);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\ProvideToolboxItemConfigurationAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideToolboxItemConfigurationAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {
    
    using System;
    using System.Globalization;
    using Microsoft.VisualStudio.Shell.Interop;

    /// <include file='doc\ProvideToolboxItemConfigurationAttribute.uex' path='docs/doc[@for="ProvideToolboxItemConfigurationAttribute"]' />
    /// <devdoc>
    ///    Registers a confugration object for toolbox items.
    ///    ProvideToolboxItemConfigurationAttribute attached to the package.  This attribute will register 
    ///    the object under the local CLSID hive in the VS registry and also add a reference to the GUID in
    ///    VSREGROOT\ToolboxItemConfiguration.  The data contained in this registry entry
    ///    is as follows:
    /// 
    ///    VSREGROOT\ToolboxItemConfiguration
    ///        AssemblyName
    ///             ConfigurationTypeName={guid}
    /// 
    ///    As an example:
    /// 
    ///    VSREGROOT\ToolboxItemConfiguration
    ///        System, Version=2.0.3500
    ///            CompactFrameworkProvider = {GUID}
    /// 
    /// 
    ///    The assembly name is parsed and the various keys are matched.  Keys can have a
    ///    "*" in them to be taken as wildcards.  So, for example, to cover all versions
    ///    of System.WindowsForms you would specify:
    /// 
    ///    System.Windows.Forms, Version=*, PublicKeyToken=969...
    /// 
    ///    The assembly name may also be a wildcard to load the configuration object
    ///    for all toolbox items (not recommended).  
    /// 
    ///    Place this attribute on your package, and then place one or more ProvideAssemblyFilter attributes
    ///    on the class that implements IConfigureToolboxItem.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, Inherited = true, AllowMultiple = true)]
    public sealed class ProvideToolboxItemConfigurationAttribute : RegistrationAttribute {
        private Type _objectType;

        /// <include file='doc\ProvideToolboxItemConfigurationAttribute.uex' path='docs/doc[@for="ProvideToolboxItemConfigurationAttribute.ProvideToolboxItemConfigurationAttribute"]' />
        /// <devdoc>
        ///    Constructor
        /// </devdoc>
        public ProvideToolboxItemConfigurationAttribute(Type objectType) {
            if (objectType == null) {
                throw new ArgumentNullException("objectType");
            }

            _objectType = objectType;
        }

        /// <include file='doc\ProvideToolboxItemConfigurationAttribute.uex' path='docs/doc[@for="ProvideToolboxItemConfigurationAttribute.ConfigurationType"]' />
        /// <devdoc>
        ///    The configuration type to use.
        /// </devdoc>
        public Type ObjectType {
            get {
                return _objectType;
            }
        }

        private string CLSIDRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, "CLSID\\{0}", ObjectType.GUID.ToString("B")); }
        }

        private string GetItemCfgFilterKey(string filter)
        {
            return string.Format(CultureInfo.InvariantCulture, "ToolboxItemConfiguration\\{0}", filter);
        }

        /// <include file='doc\ProvideToolboxItemConfigurationAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(SR.GetString(SR.Reg_NotifyToolboxItemConfiguration, ObjectType.Name));

            using (Key childKey = context.CreateKey(CLSIDRegKey))
            {
                childKey.SetValue(string.Empty, ObjectType.FullName);
                childKey.SetValue("InprocServer32", context.InprocServerPath);
                childKey.SetValue("Class", ObjectType.FullName);
                if (context.RegistrationMethod == RegistrationMethod.CodeBase)
                {
                    childKey.SetValue("Codebase", context.CodeBase);
                }
                else
                {
                    childKey.SetValue("Assembly", ObjectType.Assembly.FullName);
                }
                childKey.SetValue("ThreadingModel", "Both");
            }
            
            string guid = ObjectType.GUID.ToString("B");
            // Now, look up the object type and look for assembly filters.
            foreach (object attr in ObjectType.GetCustomAttributes(typeof(ProvideAssemblyFilterAttribute), true)) {
                ProvideAssemblyFilterAttribute filter = (ProvideAssemblyFilterAttribute)attr;
                context.Log.WriteLine(SR.GetString(SR.Reg_NotifyToolboxItemFilter, filter.AssemblyFilter)); 
                using (Key itemCfgKey = context.CreateKey(GetItemCfgFilterKey(filter.AssemblyFilter)))
                {
                    itemCfgKey.SetValue(ObjectType.FullName, guid);
                }
            }
        }

        /// <include file='doc\ProvideToolboxItemConfigurationAttribute.uex' path='docs/doc[@for="Unregister"]' />
        /// <devdoc>
        /// Called to remove this attribute from the given context.
        /// </devdoc>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(CLSIDRegKey);

            // Now, look up the object type and remove assembly filters.
            foreach (object attr in ObjectType.GetCustomAttributes(typeof(ProvideAssemblyFilterAttribute), true)) {
                ProvideAssemblyFilterAttribute filter = (ProvideAssemblyFilterAttribute)attr;
                context.RemoveKey(GetItemCfgFilterKey(filter.AssemblyFilter));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\ProvideProjectFactoryAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideProjectFactoryAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.ComponentModel;
    using System.Globalization;

    /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute"]' />
    /// <devdoc>
    ///     This attribute declares that a package offers an project factory.  A single 
    ///     package can provide multiple project factories.  If a package declares that 
    ///     it provides an project factory, it should create the factory and offer it 
    ///     to Visual Studio in the Initialize method of Package.
    /// 
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideProjectFactoryAttribute : RegistrationAttribute {

        private Type    _factoryType;
        private string   _displayProjectFileExtensions;
        private string  _name;
        private string  _defaultProjectExtension;
        private string  _possibleProjectExtensions;
        private string  _projectTemplatesDirectory;
        private int     _sortPriority = 100;
        private Guid    _folderGuid = Guid.Empty;

        private string languageVsTemplate;
        private string templateGroupIDsVsTemplate;
        private string templateIDsVsTemplate;
        private string displayProjectTypeVsTemplate;
        private string projectSubTypeVsTemplate;
        private bool newProjectRequireNewFolderVsTemplate = false;
        private bool showOnlySpecifiedTemplatesVsTemplate = false;

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.ProvideProjectFactoryAttribute"]' />
        /// <devdoc>
        ///     Creates a new ProvideProjectFactoryAttribute.
        /// </devdoc>
        public ProvideProjectFactoryAttribute(Type factoryType, string name, string displayProjectFileExtensionsResourceID, string defaultProjectExtension, string possibleProjectExtensions, string projectTemplatesDirectory) {
            if (factoryType == null) {
                throw new ArgumentNullException("factoryType");
            }

            _factoryType = factoryType;
            _name = name;
            _displayProjectFileExtensions = displayProjectFileExtensionsResourceID;
            _defaultProjectExtension = defaultProjectExtension;
            _possibleProjectExtensions = possibleProjectExtensions;
            _projectTemplatesDirectory = projectTemplatesDirectory;
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.Name"]/*' />
        /// <summary>
        /// The tree node name in the create new project and add new item dialogs.
        /// Take precendence over the nameResourceID value
        /// </summary>
        /// <value>Name to be used</value>
        public string Name
        {
            get { return _name; }
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.SortPriority"]/*' />
        /// <summary>
        /// Affect the order in which project are displayed in the new project dialog
        /// </summary>
        /// <value>Default is 100</value>
        public int SortPriority
        {
            get { return _sortPriority; }
            set { _sortPriority = value; }
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.FactoryType"]' />
        /// <devdoc>
        ///     Returns the project factory type this attribute declares.
        /// </devdoc>
        public Type FactoryType {
            get {
                return _factoryType;
            }            
        }
        
        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.DisplayProjectFileExtensionsResourceID"]' />
        /// <devdoc>
        ///     Returns the display project files extensions string.
        /// </devdoc>
        public string DisplayProjectFileExtensions {
            get {
                return _displayProjectFileExtensions;
            }
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.DefaultProjectExtension"]' />
        /// <devdoc>
        ///     Returns the default project extension.
        /// </devdoc>
        public string DefaultProjectExtension {
            get {
                return _defaultProjectExtension;
            }
        }


        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.PossibleProjectExtensions"]' />
        /// <devdoc>
        ///     Returns the default project extension.
        /// </devdoc>
        public string PossibleProjectExtensions {
            get {
                return _possibleProjectExtensions;
            }
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.ProjectTemplatesDirectory"]' />
        /// <devdoc>
        ///     Returns the default project extension.
        /// </devdoc>
        public string ProjectTemplatesDirectory {
            get {
                return _projectTemplatesDirectory;
            }
        }

        /// <summary>
        /// Get or Set the Folder guid.
        /// This can be used to control where the project node appear in the New Project dialog
        /// </summary>
        public string FolderGuid
        {
            get { return _folderGuid.ToString("B"); }
            set { _folderGuid = new Guid(value); }
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.LanguageVsTemplate"]/*' />
        public string LanguageVsTemplate
        {
            get { return languageVsTemplate; }
            set { languageVsTemplate = value; }
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.DisplayProjectTypeVsTemplate"]/*' />
        public string DisplayProjectTypeVsTemplate
        {
            get { return displayProjectTypeVsTemplate; }
            set { displayProjectTypeVsTemplate = value; }
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.ProjectSubTypeVsTemplate"]/*' />
        public string ProjectSubTypeVsTemplate
        {
            get { return projectSubTypeVsTemplate; }
            set { projectSubTypeVsTemplate = value; }
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.NewProjectRequireNewFolderVsTemplate"]/*' />
        public bool NewProjectRequireNewFolderVsTemplate
        {
            get { return newProjectRequireNewFolderVsTemplate; }
            set { newProjectRequireNewFolderVsTemplate = value; }
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.ShowOnlySpecifiedTemplatesVsTemplate"]/*' />
        public bool ShowOnlySpecifiedTemplatesVsTemplate
        {
            get { return showOnlySpecifiedTemplatesVsTemplate; }
            set { showOnlySpecifiedTemplatesVsTemplate = value; }
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.TemplateGroupIDsVsTemplate"]/*' />
        public string TemplateGroupIDsVsTemplate
        {
            get { return templateGroupIDsVsTemplate; }
            set { templateGroupIDsVsTemplate = value; }
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.TemplateIDsVsTemplate"]/*' />
        public string TemplateIDsVsTemplate
        {
            get { return templateIDsVsTemplate; }
            set { templateIDsVsTemplate = value; }
        }


        private string ProjectRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, "Projects\\{0}", FactoryType.GUID.ToString("B")); }
        }

        private string NewPrjTemplateRegKey(RegistrationContext context)
        {
            return string.Format(CultureInfo.InvariantCulture, "NewProjectTemplates\\TemplateDirs\\{0}\\/1", context.ComponentType.GUID.ToString("B"));
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context)
        {
            context.Log.WriteLine(SR.GetString(SR.Reg_NotifyProjectFactory, FactoryType.Name));

            using (Key projectKey = context.CreateKey(ProjectRegKey))
            {
                projectKey.SetValue(string.Empty, FactoryType.Name);
                if (_name != null)
                    projectKey.SetValue("DisplayName", _name);
                if (_displayProjectFileExtensions != null)
                    projectKey.SetValue("DisplayProjectFileExtensions", _displayProjectFileExtensions);
                projectKey.SetValue("Package", context.ComponentType.GUID.ToString("B"));
                if (_defaultProjectExtension != null)
                    projectKey.SetValue("DefaultProjectExtension", _defaultProjectExtension);
                if (_possibleProjectExtensions != null)
                    projectKey.SetValue("PossibleProjectExtensions", _possibleProjectExtensions);
                if (_projectTemplatesDirectory != null)
                {
                    if (!System.IO.Path.IsPathRooted(_projectTemplatesDirectory))
                    {
                        // If path is not rooted, make it relative to package path
                        _projectTemplatesDirectory = System.IO.Path.Combine(context.ComponentPath, _projectTemplatesDirectory);
                    }
                    projectKey.SetValue("ProjectTemplatesDir", _projectTemplatesDirectory);
                }

                // VsTemplate Specific Keys
                if (languageVsTemplate != null)
                    projectKey.SetValue("Language(VsTemplate)", languageVsTemplate);
                if (showOnlySpecifiedTemplatesVsTemplate)
                    projectKey.SetValue("ShowOnlySpecifiedTemplates(VsTemplate)", (int)1);
                if (templateGroupIDsVsTemplate != null)
                    projectKey.SetValue("TemplateGroupIDs(VsTemplate)", templateGroupIDsVsTemplate);
                if (templateIDsVsTemplate != null)
                    projectKey.SetValue("TemplateIDs(VsTemplate)", templateIDsVsTemplate);
                if (displayProjectTypeVsTemplate != null)
                    projectKey.SetValue("DisplayProjectType(VsTemplate)", displayProjectTypeVsTemplate);
                if (projectSubTypeVsTemplate != null)
                    projectKey.SetValue("ProjectSubType(VsTemplate)", projectSubTypeVsTemplate);
                if (newProjectRequireNewFolderVsTemplate)
                    projectKey.SetValue("NewProjectRequireNewFolder(VsTemplate)", (int)1);
            }

            using (Key prjTemplateKey = context.CreateKey(NewPrjTemplateRegKey(context)))
            {

                string keyName = String.Empty;
                if (_name != null)
                    prjTemplateKey.SetValue(keyName, _name);
                prjTemplateKey.SetValue("SortPriority", _sortPriority);
                if (_projectTemplatesDirectory != null)
                {
                    prjTemplateKey.SetValue("TemplatesDir", _projectTemplatesDirectory);
                }
                if (_folderGuid != Guid.Empty)
                {
                    prjTemplateKey.SetValue("Folder", FolderGuid);
                }
            }
        }

        /// <include file='doc\ProvideProjectFactoryAttribute.uex' path='docs/doc[@for="ProvideProjectFactoryAttribute.Unregister"]/*' />
        public override void Unregister(RegistrationContext context) {
            context.RemoveKey(ProjectRegKey);
            context.RemoveKey(NewPrjTemplateRegKey(context));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\ProvideProfileAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideProfileAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProvideProfileAttribute"]' />
    /// <devdoc>
    ///     This attribute declares a class as a Visual Studio Profile item and
    ///     places items in the VS registry for the User Settings.
    ///     This may optionally specify a Tools Options page.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideProfileAttribute : RegistrationAttribute {
        
        private Type    _objectType;
        private string  _groupName;
        private string  _categoryName;
        private string  _objectName;
        private string  _alternateParent;
        private string  _resourcePackageGuid;
        private short   _groupResourceID = 0;
        private short   _categoryResourceID = 0;
        private short   _objectNameResourceID = 0;
        private short   _descriptionResourceID = 0;
        private bool    _isToolsOptionPage;

        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProvideProfileAttribute.ProvideProfileAttribute1"]' />
        /// <devdoc>
        /// </devdoc>        
        public ProvideProfileAttribute(Type objectType, string categoryName, string objectName, short categoryResourceID, short objectNameResourceID, bool isToolsOptionPage) {
            if (objectType == null) {
                throw new ArgumentNullException("objectType");
            }
            if (categoryName == null) {
                throw new ArgumentNullException("categoryName");
            }
            if (objectName == null) {
                throw new ArgumentNullException("objectName");
            }
            if (!typeof(IProfileManager).IsAssignableFrom(objectType)) {
                throw new ArgumentException(SR.GetString(SR.General_InvalidType, typeof(IProfileManager).FullName), objectType.FullName);
            }

            _objectType = objectType;
            _categoryName = categoryName;
            _objectName = objectName;
            _categoryResourceID = categoryResourceID;
            _objectNameResourceID = objectNameResourceID;
            _isToolsOptionPage = isToolsOptionPage;
        }


        /// <devdoc>
        ///     The programmatic name for this Group (non localized).
        /// </devdoc>
        public string GroupName
        {
            get { return _groupName; }
            set { _groupName = value; }
        }

        /// <devdoc>
        ///     The native resourceID of the group name for this page in the Profile.
        /// </devdoc>
        public short GroupResourceID
        {
            get { return _groupResourceID; }
            set { _groupResourceID = value; }
        }

        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProvideProfileAttribute.CategoryName"]' />
        /// <devdoc>
        ///     The programmatic name for this category (non localized).
        /// </devdoc>
        public string CategoryName {
            get {
                return _categoryName;
            }
        }

        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProvideProfileAttribute.CategoryResourceID"]' />
        /// <devdoc>
        ///     The native resourceID of the category name for this page.
        /// </devdoc>
        public short CategoryResourceID {
            get {
                return _categoryResourceID;
            }
        }

        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProvideProfileAttribute.PageName"]' />
        /// <devdoc>
        ///     The programmatic name for this page (non localized).
        /// </devdoc>
        public string ObjectName {
            get {
                return _objectName;
            }
        }

        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProvideProfileAttribute.PageNameResourceID"]' />
        /// <devdoc>
        ///     The native resourceID of the name for this page in the Profile.
        /// </devdoc>
        public short ObjectNameResourceID {
            get {
                return _objectNameResourceID;
            }
        }
        
        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProvideProfileAttribute.PageType"]' />
        /// <devdoc>
        ///     The type of this object.
        /// </devdoc>
        public Type ObjectType {
            get {
                return _objectType;
            }
        }
    
        /// <devdoc>
        ///     The Guid of a package providing the resource strings (only need to specify if this a different package).
        /// </devdoc>
        public string ResourcePackageGuid
        {
            get { return _resourcePackageGuid; }
            set { _resourcePackageGuid = value; }
        }

        /// <devdoc>
        ///     The native resourceID of the description for this page in the Profile.
        /// </devdoc>
        public short DescriptionResourceID
        {
            get { return _descriptionResourceID; }
            set { _descriptionResourceID = value; }
        }

        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProvideProfileAttribute.AlternateParent"]' />
        /// <devdoc>
        ///     Allows the data to be parented under a different category in profile data.
        /// </devdoc>
        public string AlternateParent
        {
            get { return _alternateParent; }
            set { _alternateParent = value; }
        }

        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="ProvideProfileAttribute.IsToolsOptionPage"]' />
        /// <devdoc>
        ///     Is this a Tools->Option page.
        /// </devdoc>

        public bool IsToolsOptionPage {
            get {
                return _isToolsOptionPage;
            }
        }

        private string SettingsRegKey
        {
            get
            {
                if (String.IsNullOrEmpty(GroupName))
                    return string.Format(CultureInfo.InvariantCulture, "UserSettings\\{0}_{1}", CategoryName, ObjectName);
                else
                    return string.Format(CultureInfo.InvariantCulture, "UserSettings\\{0}\\{1}_{2}", GroupName, CategoryName, ObjectName);
            }
        }
     
        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(SR.GetString(SR.Reg_NotifyCreateObject, ObjectType.Name));

            if (!String.IsNullOrEmpty(GroupName) && GroupResourceID>0)
            {
                using (Key groupKey = context.CreateKey(String.Format(CultureInfo.InvariantCulture, "UserSettings\\{0}", GroupName)))
                {
                    groupKey.SetValue(string.Empty, string.Format(CultureInfo.InvariantCulture, "#{0}", GroupResourceID));
                }
            }

            using (Key childKey = context.CreateKey(SettingsRegKey))
            {
                childKey.SetValue(string.Empty, string.Format(CultureInfo.InvariantCulture, "#{0}", ObjectNameResourceID));
                childKey.SetValue("Package", context.ComponentType.GUID.ToString("B"));
                childKey.SetValue("Category", ObjectType.GUID.ToString("B"));
                if(IsToolsOptionPage) {
                    childKey.SetValue("ToolsOptionsPath", CategoryName);
                }
                if (!String.IsNullOrEmpty(AlternateParent))
                    childKey.SetValue("AlternateParent", AlternateParent);
                if (!String.IsNullOrEmpty(ResourcePackageGuid))
                    childKey.SetValue("ResourcePackage", ResourcePackageGuid);
                if (DescriptionResourceID > 0)
                    childKey.SetValue("Description", string.Format(CultureInfo.InvariantCulture, "#{0}", DescriptionResourceID));
            }
        }

        /// <include file='doc\ProvideProfileAttribute.uex' path='docs/doc[@for="Unregister"]' />
        /// <devdoc>
        /// Called to remove this attribute from the given context.
        /// </devdoc>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(SettingsRegKey);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\ProvideViewAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideViewAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;

    /// <include file='doc\ProvideViewAttribute.uex' path='docs/doc[@for="ProvideViewAttribute"]' />
    /// <devdoc>
    ///     This attribute declares that an editor factory offers a particular logical view.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideViewAttribute : Attribute {

        private LogicalView _logicalView;
        private string      _physicalView;

        /// <include file='doc\ProvideViewAttribute.uex' path='docs/doc[@for="ProvideViewAttribute.ProvideViewAttribute"]' />
        /// <devdoc>
        ///     Creates a new ProvideViewAttribute.
        /// </devdoc>
	    public ProvideViewAttribute (LogicalView logicalView, string physicalView) {
            _logicalView = logicalView;
            _physicalView = physicalView;   // NULL is valid here.
        }

        /// <include file='doc\ProvideViewAttribute.uex' path='docs/doc[@for="ProvideViewAttribute.LogicalView"]' />
        /// <devdoc>
        ///     Returns the logical view in this attribute.
        /// </devdoc>
	    public LogicalView LogicalView {
            get {
                return _logicalView;
            }
        }

        /// <include file='doc\ProvideViewAttribute.uex' path='docs/doc[@for="ProvideViewAttribute.PhysicalView"]' />
        /// <devdoc>
        ///     Returns the physical view that is mapped to the logical view.
        /// </devdoc>
	    public string PhysicalView {
            get {
                return _physicalView;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\ProvideToolWindowAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegisterToolWindowResourceAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell
{

    using System;
    using System.Drawing;
    using System.ComponentModel.Design;
    using System.Globalization;

    /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="VsDockStyle"]/*' />
    public enum VsDockStyle {
        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="VsDockStyle.none"]/*' />
        none,
        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="VsDockStyle.MDI"]/*' />
        MDI,
        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="VsDockStyle.Float"]/*' />
        Float,
        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="VsDockStyle.Linked"]/*' />
        Linked,
        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="VsDockStyle.Tabbed"]/*' />
        Tabbed,
        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="VsDockStyle.AlwaysFloat"]/*' />
        AlwaysFloat
    };
    /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ToolWindowOrientation"]/*' />
    public enum ToolWindowOrientation {
        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ToolWindowOrientation.none"]/*' />
        none,
        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ToolWindowOrientation.Top"]/*' />
        Top,
        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ToolWindowOrientation.Left"]/*' />
        Left,
        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ToolWindowOrientation.Right"]/*' />
        Right,
        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ToolWindowOrientation.Bottom"]/*' />
        Bottom
    };

    /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute"]/*' />
    /// <devdoc>
    /// This attribute declares that a package own a tool window.  Visual Studio uses this 
    /// information to handle the positioning and persistance of your window. The attributes on a 
    /// package do not control the behavior of the package, but they can be used by registration 
    /// tools to register the proper information with Visual Studio.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideToolWindowAttribute: RegistrationAttribute {

        private Type tool;
        private string name = null;
        private ToolWindowOrientation orientation = ToolWindowOrientation.none;
        private VsDockStyle style = VsDockStyle.none;
        private Guid dockedWith = Guid.Empty;
        private Rectangle position = Rectangle.Empty;
        private bool multiInstances = false;
        private bool transient = false;

        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.ProvideToolWindowAttribute"]/*' />
        /// <devdoc>
        /// Constructor
        /// Creates a new RegisterToolWindowResourceAttribute.
        /// </devdoc>
        /// <param name="toolType">Type of the tool window</param>
        public ProvideToolWindowAttribute(Type toolType) 
        {
            tool = toolType;
            name = tool.FullName;
        }

        #region Properties
        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.Style"]/*' />
        /// <devdoc>
        /// Default DockStyle for the ToolWindow
        /// </devdoc>
        public VsDockStyle Style
        {
            get { return style; }
            set { style = value; }
        }

        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.PositionX"]/*' />
        /// <devdoc>
        /// Default horizontal component of the position for the to top left corner of the ToolWindow
        /// </devdoc>
        public int PositionX
        {
            get { return position.X; }
            set { position.X = value; }
        }

        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.PositionY"]/*' />
        /// <devdoc>
        /// Default vertical component of the position for the to top left corner of the ToolWindow
        /// </devdoc>
        public int PositionY
        {
            get { return position.Y; }
            set { position.Y = value; }
        }

        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.Width"]/*' />
        /// <devdoc>
        /// Default width of the ToolWindow
        /// </devdoc>
        public int Width
        {
            get { return position.Width; }
            set { position.Width = value; }
        }

        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.Height"]/*' />
        /// <devdoc>
        /// Default height of the ToolWindow
        /// </devdoc>
        public int Height
        {
            get { return position.Height; }
            set { position.Height = value; }
        }

        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.Orientation"]/*' />
        /// <devdoc>
        /// Default Orientation for the ToolWindow, relative to the window specified by the Window Property
        /// </devdoc>
        public ToolWindowOrientation Orientation
        {
            get { return orientation; }
            set { orientation = value; }
        }

        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.ToolType"]/*' />
        /// <devdoc>
        /// Type of the ToolWindow
        /// </devdoc>
        public Type ToolType
        {
            get { return tool; }
        }

        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.Window"]/*' />
        /// <devdoc>
        /// Default Window that the ToolWindow will be docked with
        /// </devdoc>
        public string Window
        {
            get { return dockedWith.ToString(); }
            set { dockedWith = new Guid(value); }
        }

        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.MultiInstances"]/*' />
        /// <devdoc>
        /// Default Window that the ToolWindow will be docked with
        /// </devdoc>
        public bool MultiInstances
        {
            get { return multiInstances; }
            set { multiInstances = value; }
        }

        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.Transient"]/*' />
        /// <devdoc>
        /// Set to true if you want to prevent window from loading on IDE start up
        /// Default is false which makes the toolwindow persistent (if the IDE is closed
        /// while the window is showing, the window will show up the next time the IDE
        /// starts).
        /// </devdoc>
        public bool Transient
        {
            get { return transient; }
            set { transient = value; }
        }

        #endregion


        /// <devdoc>
        ///        The reg key name of this Tool Window.
        /// </devdoc>
        private string RegKeyName 
        {
            get 
            {
                return string.Format(CultureInfo.InvariantCulture, "ToolWindows\\{0}", tool.GUID.ToString("B"));
            }
        }

        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.Register"]/*' />
        /// <devdoc>
        /// Called to register this attribute with the given context.  The context
        /// contains the location where the registration information should be placed.
        /// it also contains such as the type being registered, and path information.
        /// </devdoc>
        public override void Register(RegistrationContext context) 
        {
            context.Log.WriteLine(SR.GetString(SR.Reg_NotifyToolResource, name, tool.GUID.ToString("B")));

            using (Key childKey = context.CreateKey(RegKeyName))
            {
                // Package owning this tool window
                childKey.SetValue(string.Empty, context.ComponentType.GUID.ToString("B"));
                if (name != null)
                    childKey.SetValue("Name", name);
                if (orientation != ToolWindowOrientation.none)
                    childKey.SetValue("Orientation", OrientationToString(orientation));
                if (style != VsDockStyle.none)
                    childKey.SetValue("Style", StyleToString(style));
                if (dockedWith != Guid.Empty)
                    childKey.SetValue("Window", dockedWith.ToString("B"));
                if (position.Width != 0 && position.Height != 0)
                {
                    string positionString = string.Format(CultureInfo.InvariantCulture, "{0}, {1}, {2}, {3}",
                                position.Left,
                                position.Top,
                                position.Right,
                                position.Bottom);
                    childKey.SetValue("Float", positionString);
                }
                if (transient)
                    childKey.SetValue("DontForceCreate", 1);
            }
        }

        /// <include file='doc\ProvideToolWindowAttribute.uex' path='docs/doc[@for="ProvideToolWindowAttribute.Unregister"]/*' />
        /// <devdoc>
        /// Unregister this Tool Window.
        /// </devdoc>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(RegKeyName);
        }

        /// <devdoc>
        /// Convert enum to string
        /// </devdoc>
        private string StyleToString(VsDockStyle style)
        {
            switch (style)
            {
                case VsDockStyle.MDI:
                {
                    return "MDI";
                }
                case VsDockStyle.Float:
                {
                    return "Float";
                }
                case VsDockStyle.Linked:
                {
                    return "Linked";
                }
                case VsDockStyle.Tabbed:
                {
                    return "Tabbed";
                }
                case VsDockStyle.AlwaysFloat:
                {
                    return "AlwaysFloat";
                }
                case VsDockStyle.none:
                {
                    return string.Empty;
                }
                default:
                    throw new ArgumentException(SR.GetString(SR.Attributes_UnknownDockingStyle, style));
            }
        }

        /// <devdoc>
        /// Convert enum to string
        /// </devdoc>
        private string OrientationToString(ToolWindowOrientation position)
        {
            switch (position)
            {
                case ToolWindowOrientation.Top:
                {
                    return "Top";
                }
                case ToolWindowOrientation.Left:
                {
                    return "Left";
                }
                case ToolWindowOrientation.Right:
                {
                    return "Right";
                }
                case ToolWindowOrientation.Bottom:
                {
                    return "Bottom";
                }
                case ToolWindowOrientation.none:
                {
                    return string.Empty;
                }
                default:
                    throw new ArgumentException(SR.GetString(SR.Attributes_UnknownPosition, position));
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\ProvideToolWindowVisibilityAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegisterToolWindowVisibilityAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Globalization;

namespace Microsoft.VisualStudio.Shell
{
    /// <summary>
    /// Declares that a tool window is should be visible when a certain command
    /// UI guid becomes active.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideToolWindowVisibilityAttribute : RegistrationAttribute {

        private string _name;
        private Guid _toolwindow;
        private Guid _commandUIGuid;

        /// <summary>
        /// Creates a new attribute for a specific tool window and a command UI guid.
        /// </summary>
        /// <param name="toolWindow">The tool window Type or Guid (as string).</param>
        /// <param name="commandUIGuid">The command UI guid that controls the tool window's visibility.</param>
        public ProvideToolWindowVisibilityAttribute(object toolWindow, string commandUIGuid)
        {
            if (toolWindow is Type)
            {
                Type t = (Type)toolWindow;
                _toolwindow = t.GUID;
                _name = t.Name;
            }
            else if (toolWindow is string)
                _toolwindow = new Guid(toolWindow as string);
            else
                throw new ArgumentException(SR.GetString(SR.General_InvalidType, typeof(System.Type).FullName), "toolWindow");
            _commandUIGuid = new Guid(commandUIGuid);
        }

        /// <summary>
        /// Get the command UI guid controlling the visibility of the tool window.
        /// </summary>
        public Guid CommandUIGuid
        {
            get { return _commandUIGuid; }
        }

        /// <summary>
        /// Get or Set name of the toolwindow.
        /// This does not impact the runtime behavior.
        /// </summary>
        public string Name
        {
            get { return _name; }
            set { _name = value; }
        }

        private string RegistryPath
        {
            get { return string.Format(CultureInfo.InvariantCulture, "ToolWindows\\{0}\\Visibility", _toolwindow.ToString("B")); }
        }

        /// <summary>
        /// Called to register this attribute with the given context.  The context
        /// contains the location where the registration information should be placed.
        /// it also contains such as the type being registered, and path information.
        /// </summary>
        public override void Register(RegistrationContext context)
        {
            // Write to the context's log what we are about to do
            context.Log.WriteLine(SR.GetString(SR.Reg_NotifyToolVisibility, _name, CommandUIGuid.ToString("B")));

            // Create the visibility key.
            using (Key childKey = context.CreateKey(RegistryPath))
            {
                // Set the value for the command UI guid.
                childKey.SetValue(CommandUIGuid.ToString("B"), 0);
            }
        }

        /// <summary>
        /// Unregister this visibility entry.
        /// </summary>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveValue(RegistryPath, CommandUIGuid.ToString("B"));
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\ProvideToolboxPageAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideToolboxPageAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\ProvideToolboxPageAttribute.uex' path='docs/doc[@for="ProvideToolboxPageAttribute"]' />
    /// <devdoc>
    ///     This attribute declares that a package offers one or more toolbox pages.  Toolbox pages are 
    ///     exposed to the user through Visual Studio's customize toolbox dialog.  A toolbox page must 
    ///     derive from DialogPage. Toolbox page 
    ///     attributes are read by the package class when Visual Studio requests a particular property 
    ///     page GUID.  Package will walk the attributes and try to match the requested GUID to a 
    ///     GUID on a type in the package. 
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideToolboxPageAttribute : ProvideOptionDialogPageAttribute {

        private short   _pageOrder;
        private string  _helpKeyword;

        /// <include file='doc\ProvideToolboxPageAttribute.uex' path='docs/doc[@for="ProvideToolboxPageAttribute.ProvideToolboxPageAttribute"]' />
        /// <devdoc>
        ///     The page type is a type that implements
        ///     IWin32Window.  The nameResourceID
        ///     parameter specifies a Win32 resource ID in the 
        ///     stored in the native UI resource satellite
        ///     that describes the name of this page.
        /// </devdoc>
        public ProvideToolboxPageAttribute(Type pageType, short nameResourceID) : this(pageType, nameResourceID, 0) {
        }
        
        /// <include file='doc\ProvideToolboxPageAttribute.uex' path='docs/doc[@for="ProvideToolboxPageAttribute.TypeId"]' />
        /// <devdoc>
        /// Identity of this instance of the attribute.
        /// </devdoc>
        public override object TypeId {
            get {
                return this;
            }
        }

        /// <include file='doc\ProvideToolboxPageAttribute.uex' path='docs/doc[@for="ProvideToolboxPageAttribute.ProvideToolboxPageAttribute1"]' />
        /// <devdoc>
        ///     The page type is a type that implements
        ///     IWin32Window.  The nameResourceID
        ///     parameter specifies a Win32 resource ID in the 
        ///     stored in the native UI resource satellite
        ///     that describes the name of this page.  Page order is 
        ///     optional and defaults to zero.  If non-zero, a registry entry will be
        ///     created named DefaultTbx, which specifies the sort order of the
        ///     toolbox pages.
        /// </devdoc>
        public ProvideToolboxPageAttribute(Type pageType, short nameResourceID, short pageOrder) : this(pageType, nameResourceID, pageOrder, null) {
        }

        /// <include file='doc\ProvideToolboxPageAttribute.uex' path='docs/doc[@for="ProvideToolboxPageAttribute.ProvideToolboxPageAttribute1"]' />
        /// <devdoc>
        ///     The page type is a type that implements
        ///     IWin32Window.  The nameResourceID
        ///     parameter specifies a Win32 resource ID in the 
        ///     stored in the native UI resource satellite
        ///     that describes the name of this page.  Page order is 
        ///     optional and defaults to zero.  If non-zero, a registry entry will be
        ///     created named DefaultTbx, which specifies the sort order of the
        ///     toolbox pages.
        ///     Helpkeyword is a keyword exposed to F1 help (support for this was added by joshs -- reference VS Whidbey#262176)
        /// </devdoc>
        public ProvideToolboxPageAttribute(Type pageType, short nameResourceID, short pageOrder, string helpKeyword) 
            : base(pageType, "#"+nameResourceID.ToString()) {

            _pageOrder = pageOrder;
            _helpKeyword = helpKeyword;
        }

        /// <include file='doc\ProvideToolboxPageAttribute.uex' path='docs/doc[@for="ProvideToolboxPageAttribute.HelpKeyword"]' />
        /// <devdoc>
        /// Returns the help keyword associated with this toolbox page.
        /// </devdoc>
        public string HelpKeyword {
            get {
                return _helpKeyword;
            }
        }

        /// <include file='doc\ProvideToolboxPageAttribute.uex' path='docs/doc[@for="ProvideToolboxPageAttribute.PageOrder"]' />
        /// <devdoc>
        ///     The sort order of the page or zero if this page should be left unsorted.
        /// </devdoc>
        public short PageOrder {
            get {
                return _pageOrder;
            }
        }
        
        private string ToolboxPageRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, "ToolboxPages\\{0}", PageType.FullName); }
        }

        /// <include file='doc\ProvideToolboxPageAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(SR.GetString(SR.Reg_NotifyToolboxPage, PageType.Name));

            using (Key childKey = context.CreateKey(ToolboxPageRegKey))
            {
                childKey.SetValue(string.Empty, PageNameResourceId);
                childKey.SetValue("Package", context.ComponentType.GUID.ToString("B"));
                childKey.SetValue("Page", PageType.GUID.ToString("B"));
                if (PageOrder != 0) {
                    childKey.SetValue("DefaultTbx", PageOrder);
                }
                if (_helpKeyword != null && _helpKeyword.Length > 0) {
                    childKey.SetValue("HelpKeyword", _helpKeyword);
                }
            }
        }

        /// <include file='doc\ProvideToolboxPageAttribute.uex' path='docs/doc[@for="Unregister"]' />
        /// <devdoc>
        /// Called to remove this attribute from the given context.
        /// </devdoc>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(ToolboxPageRegKey);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\ProvideToolboxItemsAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideToolboxItemsAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\ProvideToolboxItemsAttribute.uex' path='docs/doc[@for="ProvideToolboxItemsAttribute"]' />
    /// <devdoc>
    ///     This attribute declares that a package offers toolbox items and should be provided time 
    ///     during setup to install these items.  The attributes on a package do not control the 
    ///     behavior of the package, but they can be used by registration tools to register the 
    ///     proper information with Visual Studio.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, Inherited=true)]
    public class ProvideToolboxItemsAttribute : RegistrationAttribute {

        private int   _version;
        private bool  _needsCallbackAfterReset = false;
    
        /// <include file='doc\ProvideToolboxItemsAttribute.uex' path='docs/doc[@for="ProvideToolboxItemsAttribute.ProvideToolboxItemsAttribute"]' />
        /// <devdoc>
        ///     Creates a new ProvideToolboxItemsAttribute.
        /// </devdoc>
        public ProvideToolboxItemsAttribute(int version) {
            _version = version;
            _needsCallbackAfterReset = false;
        }

        /// <include file='doc\ProvideToolboxItemsAttribute.uex' path='docs/doc[@for="ProvideToolboxItemsAttribute.ProvideToolboxItemsAttribute"]' />
        /// <devdoc>
        ///     Creates a new ProvideToolboxItemsAttribute.
        ///     If needsCallbackAfterReset is true, then it will write out the "needsCallbackAfterReset" regkey which
        ///     tells the shell we have transient items to add and need to be called after resetdefaults is complete.
        /// </devdoc>
        public ProvideToolboxItemsAttribute(int version, bool needsCallbackAfterReset) {
            _version = version;
            _needsCallbackAfterReset = needsCallbackAfterReset;
        }

        /// <include file='doc\ProvideToolboxItemsAttribute.uex' path='docs/doc[@for="ProvideToolboxItemsAttribute.Version"]' />
        /// <devdoc>
        ///     Returns the version of items on the toolbox.
        ///     The first time a package get loaded after this version change,
        ///     the ToolboxInitialized event will be generated.
        /// </devdoc>
        public int Version {
            get {
                return _version;
            }
        }

        /// <summary>
        /// Setting this to true will force a ToolboxInitialized event after each
        /// toolbox reset.
        /// This can be used when developing your package to force the toolbox to
        /// ask the list of items to the package everytime (in case it has changed).
        /// For shipped products, it is best to leave it to false so that the cache can
        /// be used for better performances. Some scenario (such as item list that cannot
        /// cannot be persisted to the cache) may need to have this flag set to true
        /// </summary>
        public bool NeedsCallBackAfterReset
        {
            get { return _needsCallbackAfterReset; }
            set { _needsCallbackAfterReset = value; }
        }

        private string GetPackageRegKey(Guid packageGuid)
        {
            return string.Format(CultureInfo.InvariantCulture, "Packages\\{0}", packageGuid.ToString("B"));
        }

        /// <include file='doc\ProvideToolboxItemsAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        /// </devdoc>
        public override void Register(RegistrationContext context) {

            using (Key packageKey = context.CreateKey(GetPackageRegKey(context.ComponentType.GUID)))
            {
                using (Key childKey = packageKey.CreateSubkey("Toolbox"))
                {
                    childKey.SetValue("Default Items", Version);

                    // Search the package for the AllowToolboxFormat attribute.
                    //
                    string format = string.Empty;
                    foreach(ProvideToolboxFormatAttribute pfa in context.ComponentType.GetCustomAttributes(typeof(ProvideToolboxFormatAttribute), true)) {
                        if (format.Length == 0) {
                            format = pfa.Format;
                        }
                        else {
                            format = string.Format(CultureInfo.InvariantCulture, "{0}, {1}", format, pfa.Format);
                        }
                    }

                    if (format.Length > 0) {
                        childKey.SetValue("Formats", format);
                    }

                    if (_needsCallbackAfterReset) {
                        childKey.SetValue("NeedsCallbackAfterReset", (int)1);
                    }

                    context.Log.WriteLine(SR.GetString(SR.Reg_NotifyToolboxItem, Version, format));
                }
            }
        }

        /// <include file='doc\ProvideToolboxItemsAttribute.uex' path='docs/doc[@for="Unregister"]' />
        /// <devdoc>
        /// Removes the registration data.
        /// </devdoc>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(GetPackageRegKey(context.ComponentType.GUID));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\RegisterEditorLogicalViewAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright from='2003' to='2004' company='Microsoft Corporation'>           
//  Copyright (c) Microsoft Corporation, All rights reserved.             
//  This code sample is provided "AS IS" without warranty of any kind, 
//  it is not recommended for use in a production environment.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Globalization;

namespace Microsoft.VisualStudio.Shell
{
    /// <summary>
    /// This attribute adds a logical view to the editor created by an editor factory.
    /// </summary>
    [Obsolete("RegisterEditorLogicalViewAttribute has been deprecated. Please use ProvideEditorLogicalViewAttribute instead.")]
	[AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class RegisterEditorLogicalViewAttribute : RegistrationAttribute
    {
        private Guid factory;
        private Guid logicalView;

        /// <summary>
        /// Creates a new RegisterEditorLogicalView attribute to register a logical
        /// view provided by your editor.
        /// </summary>
        /// <param name="factoryType">The type of factory; can be a Type, a GUID or a string representation of a GUID</param>
        /// <param name="logicalViewGuid">The guid of the logical view to register.</param>
        public RegisterEditorLogicalViewAttribute(object factoryType, string logicalViewGuid)
        {
            this.logicalView = new Guid(logicalViewGuid);
			
            // figure out what type of object they passed in and get the GUID from it
            if (factoryType is string)
                this.factory = new Guid((string)factoryType);
            else if (factoryType is Type)
                this.factory = ((Type)factoryType).GUID;
            else if (factoryType is Guid)
                this.factory = (Guid)factoryType;
            else
                throw new ArgumentException(SR.GetString(SR.Attributes_InvalidFactoryType, factoryType));

        }

        /// <summary>
        /// Get the Guid representing the type of the editor factory
        /// </summary>
        public Guid FactoryType
        {
            get {return factory;}
        }

        /// <summary>
        /// Get the Guid representing the logical view
        /// </summary>
        public Guid LogicalView
        {
            get {return logicalView;}
        }

        private string LogicalViewPath
        {
            get { return string.Format(CultureInfo.InvariantCulture, "Editors\\{0}\\LogicalViews", factory.ToString("B")); }
        }


        /// <summary>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     It also contains other information such as the type being registered and path information.
        /// </summary>
        public override void Register(RegistrationContext context)
        {
            context.Log.WriteLine(SR.GetString(SR.Reg_NotifyEditorView, logicalView.ToString("B")));

            using (Key childKey = context.CreateKey( LogicalViewPath ))
            {
                childKey.SetValue(logicalView.ToString("B"), "");
            }
        }

        /// <summary>
        /// Unregister this logical view.
        /// </summary>
        /// <param name="context"></param>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveValue(LogicalViewPath, logicalView.ToString("B"));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\RegisterAutoLoadAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright from='2003' to='2004' company='Microsoft Corporation'>           
//  Copyright (c) Microsoft Corporation, All rights reserved.             
//  This code sample is provided "AS IS" without warranty of any kind, 
//  it is not recommended for use in a production environment.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <summary>
    ///     This attribute registers the package as an extender.  The GUID passed in determines
    ///     what is being extended. The attributes on a package do not control the behavior of
    ///     the package, but they can be used by registration tools to register the proper
    ///     information with Visual Studio.
    /// </summary>
    [Obsolete("RegisterAutoLoadAttribute has been deprecated. Please use ProvideAutoLoadAttribute instead.")]
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class RegisterAutoLoadAttribute : RegistrationAttribute {

		private Guid loadGuid = Guid.Empty;

		/// <summary>
		///     Specify that the package should get loaded when this context is active.
		/// </summary>
		/// <param name="cmdUiContextGuid">Context which should trigger the loading of your package.</param>
		public RegisterAutoLoadAttribute(string cmdUiContextGuid) 
		{
			loadGuid = new Guid(cmdUiContextGuid);
		}

		/// <summary>
		/// Context Guid which triggers the loading of the package.
		/// </summary>
		public Guid LoadGuid
		{
			get
			{
				return loadGuid;
			}
		}

		/// <summary>
		///		The reg key name of this AutoLoad.
		/// </summary>
		private string RegKeyName 
		{
			get 
			{
				return string.Format(CultureInfo.InvariantCulture, "AutoLoadPackages\\{0}", loadGuid.ToString("B"));
			}
		}

		/// <summary>
		///     Called to register this attribute with the given context.  The context
		///     contains the location where the registration information should be placed.
		///     it also contains such as the type being registered, and path information.
		/// </summary>
		public override void Register(RegistrationContext context) 
		{
			context.Log.WriteLine(SR.GetString(SR.Reg_NotifyAutoLoad, loadGuid.ToString("B")));

			using (Key childKey = context.CreateKey(RegKeyName))
                        {
			    childKey.SetValue(context.ComponentType.GUID.ToString("B"), 0);
			}
		}

		/// <summary>
		/// Unregister this AutoLoad specification.
		/// </summary>
		public override void Unregister(RegistrationContext context)
		{
			context.RemoveValue(RegKeyName, context.ComponentType.GUID.ToString("B"));
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\RegisterEditorExtensionAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegisterEditorExtensionAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.IO;
    using System.Globalization;


    /// <include file='doc\RegisterEditorExtensionAttribute.uex' path='docs/doc[@for="RegisterEditorExtensionAttribute"]' />
    /// <devdoc>
    ///     This attribute associates a file extension to a given editor factory.  
    ///     The editor factory may be specified as either a GUID or a type and 
    ///     is placed on a package.
    /// </devdoc>
    [Obsolete("RegisterEditorExtensionAttribute has been deprecated. Please use ProvideEditorExtensionAttribute instead.")]
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class RegisterEditorExtensionAttribute : RegistrationAttribute {

        private Guid factory;
        private string extension;
        private int priority;
        private Guid project;
        private string templateDir;
        private int resId;
        private bool editorFactoryNotify;
        
        /// <include file='doc\RegisterEditorExtensionAttribute.uex' path='docs/doc[@for="RegisterEditorExtensionAttribute.RegisterEditorExtensionAttribute"]' />
        /// <devdoc>
        ///     Creates a new attribute.
        /// </devdoc>
        public RegisterEditorExtensionAttribute (object factoryType, string extension, int priority) {

            if (!extension.StartsWith(".", StringComparison.OrdinalIgnoreCase)) {
                throw new ArgumentException(SR.GetString(SR.Attributes_ExtensionNeedsDot, extension));
            }

            // figure out what type of object they passed in and get the GUID from it
            if (factoryType is string)
                this.factory = new Guid((string)factoryType);
            else if (factoryType is Type)
                this.factory = ((Type)factoryType).GUID;
            else if (factoryType is Guid)
                this.factory = (Guid)factoryType;
            else
                throw new ArgumentException(SR.GetString(SR.Attributes_InvalidFactoryType, factoryType));

            this.extension = extension;
            this.priority = priority;
            this.project = Guid.Empty;
            this.templateDir = "";
            this.resId = 0;
            this.editorFactoryNotify = false;
        }
        
        /// <include file='doc\RegisterEditorExtensionAttribute.uex' path='docs/doc[@for="RegisterEditorExtensionAttribute.Extension"]' />
        /// <devdoc>
        ///     The file extension of the file.
        /// </devdoc>
        public string Extension {
            get {
                return extension;
            }
        }
        
        /// <include file='doc\RegisterEditorExtensionAttribute.uex' path='docs/doc[@for="RegisterEditorExtensionAttribute.Factory"]' />
        /// <devdoc>
        ///     The editor factory guid.
        /// </devdoc>
        public Guid Factory {
            get {
                return factory;
            }
        }
        
        /// <include file='doc\RegisterEditorExtensionAttribute.uex' path='docs/doc[@for="RegisterEditorExtensionAttribute.Priority"]' />
        /// <devdoc>
        ///     The priority of this extension registration.
        /// </devdoc>
        public int Priority {
            get {
                return priority;
            }
        }

        /// <include file='doc\RegisterEditorExtensionAttribute.uex' path='docs/doc[@for="RegisterEditorExtensionAttribute.ProjectGuid"]/*' />
        public string ProjectGuid {
            set { project = new System.Guid(value); }
            get { return project.ToString(); }
        }

        /// <include file='doc\RegisterEditorExtensionAttribute.uex' path='docs/doc[@for="RegisterEditorExtensionAttribute.EditorFactoryNotify"]/*' />
        public bool EditorFactoryNotify {
            get { return this.editorFactoryNotify; }
            set { this.editorFactoryNotify = value; }
        }

        /// <include file='doc\RegisterEditorExtensionAttribute.uex' path='docs/doc[@for="RegisterEditorExtensionAttribute.TemplateDir"]/*' />
        public string TemplateDir {
            get { return templateDir; }
            set { templateDir = value; }
        }

        /// <include file='doc\RegisterEditorExtensionAttribute.uex' path='docs/doc[@for="RegisterEditorExtensionAttribute.NameResourceID"]/*' />
        public int NameResourceID {
            get { return resId; }
            set { resId = value; }
        }

        /// <devdoc>
        ///        The reg key name of this extension.
        /// </devdoc>
        private string RegKeyName 
        {
            get 
            {
                return string.Format(CultureInfo.InvariantCulture, "Editors\\{0}", Factory.ToString("B"));
            }
        }

        /// <devdoc>
        ///        The reg key name of the project.
        /// </devdoc>
        private string ProjectRegKeyName(RegistrationContext context) 
        {
            return string.Format(CultureInfo.InvariantCulture,
                                 "Projects\\{0}\\AddItemTemplates\\TemplateDirs\\{1}",
                                 project.ToString("B"),
                                 context.ComponentType.GUID.ToString("B"));
        }

        private string EditorFactoryNotifyKey {
            get { return string.Format(CultureInfo.InvariantCulture, "Projects\\{0}\\FileExtensions\\{1}",
                                       project.ToString("B"),
                                       Extension);
            }
        }

        /// <include file='doc\RegisterEditorExtensionAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(SR.GetString(SR.Reg_NotifyEditorExtension, Extension, Factory.ToString("B")));

            using (Key editorKey = context.CreateKey(RegKeyName))
            {
                if (0 != resId)
                    editorKey.SetValue("DisplayName", "#" + resId.ToString(CultureInfo.InvariantCulture));
                editorKey.SetValue("Package", context.ComponentType.GUID.ToString("B"));
            }

            using (Key extensionKey = context.CreateKey(RegKeyName + "\\Extensions"))
            {
                extensionKey.SetValue(Extension.Substring(1), Priority);
            }

            // Build the path of the registry key for the "Add file to project" entry
            if (project != Guid.Empty)
            {
                string prjRegKey = ProjectRegKeyName(context) + "\\/1";
                using (Key projectKey = context.CreateKey( prjRegKey ))
                {
                    if (0 != resId)
                        projectKey.SetValue("", "#" + resId.ToString(CultureInfo.InvariantCulture));
                    if (templateDir.Length != 0)
                    {
                        Uri url = new Uri(context.ComponentType.Assembly.CodeBase, true);
                        string templates = url.LocalPath;
                        templates = System.IO.Path.Combine(System.IO.Path.GetDirectoryName(templates), templateDir);
                        templates = context.EscapePath( System.IO.Path.GetFullPath(templates) );
                        projectKey.SetValue("TemplatesDir", templates);
                    }
                    projectKey.SetValue("SortPriority", Priority);
                }
            }

            // Register the EditorFactoryNotify
            if ( EditorFactoryNotify )
            {
                // The IVsEditorFactoryNotify interface is called by the project system, so it doesn't make sense to
                // register it if there is no project associated to this editor.
                if (project == Guid.Empty)
                    throw new ArgumentException(SR.GetString(SR.Attributes_NoPrjForEditorFactoryNotify));

                // Create the registry key
                using (Key edtFactoryNotifyKey = context.CreateKey(EditorFactoryNotifyKey))
                {
                    edtFactoryNotifyKey.SetValue("EditorFactoryNotify", context.ComponentType.GUID.ToString("B"));
                }
            }
        }

        /// <include file='doc\RegisterEditorExtensionAttribute.uex' path='docs/doc[@for="Unregister"]' />
        /// <devdoc>
        /// Unregister this editor.
        /// </devdoc>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(RegKeyName);
            if (project != Guid.Empty)
            {
                context.RemoveKey(ProjectRegKeyName(context));
                if (EditorFactoryNotify)
                    context.RemoveKey(EditorFactoryNotifyKey);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\RegistrationAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegistrationAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.IO;

    /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationMethod"]/*' />
    /// <summary>
    /// How should the assembly be registered/located
    /// </summary>
    public enum RegistrationMethod {
        /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationMethod.Default"]/*' />
        /// <summary>
        /// Default should only be used by tools
        /// </summary>
        Default = 0, 
        /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationMethod.CodeBase"]/*' />
        /// <summary>
        /// The path to the assembly should be stored in the registry and used to locate the assembly at runtime
        /// </summary>
        CodeBase,
        /// <summary>
        /// The assembly should be in the GAC or in PrivateAssemblies
        /// </summary>
        Assembly};

    /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationAttribute"]' />
    /// <devdoc>
    ///     This attribute is the basis for all other attributes that can be registered by RegPkg.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class)]
    public abstract class RegistrationAttribute : Attribute {

        /// <summary>
        /// Override the TypeID property in order to let the RegistrationAttribute derived
        /// classes to work with System.ComponentModel.TypeDescriptor.GetAttributes(...).
        /// An attribute derived from this one will have to override this property only if
        /// it needs a better control on the instances that can be applied to a class.
        /// </summary>
        public override object TypeId
        {
            get
            {
                Type t = this.GetType();
                // Only one AttributeUsage attribute can be applyed to an attribute and the default
                // value is AllowMultiple = false. If both a base and derived attribute have an
                // AttributeUsage, only the one of the derived one will be returned by GetCustomAttributes.
                // We use a foreach because it will protect us from an empty collection
                // (it should never happen, but it is better to be safe) and because it will do
                // all the casts.
                bool isMultiple = false;
                foreach (AttributeUsageAttribute au in t.GetCustomAttributes(typeof(AttributeUsageAttribute), true))
                {
                    isMultiple = au.AllowMultiple;
                    // It should not be possible to have more than one AttributeUsageAttribute, but just in case...
                    break;
                }
                if (isMultiple)
                    return this;
                return t;
            }
        }

        /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration information should be placed.
        ///     It also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public abstract void Register(RegistrationContext context);

        /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="Unregister"]' />
        /// <devdoc>
        ///     Called to unregister this attribute with the given context.  The context
        ///     contains the location where the registration information should be removed.
        ///     It also contains things such as the type being unregistered, and path information.
        /// </devdoc>
        public abstract void Unregister(RegistrationContext context);
        
        /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="Key"]' />
        /// <devdoc>
        ///     Abstraction around a registry key.  This may or may not actually
        ///     point to a real registry key.  It could point to a file.
        /// </devdoc>
        public abstract class Key : IDisposable {
            
            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="Key.Close"]' />
            /// <devdoc>
            ///     Called to close this key.  Alternately, you may use the C# "using"
            ///     syntax on keys, since they are IDisposable. Always close keys when you
            ///     are done with them.
            /// </devdoc>
            public abstract void Close();

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="Key.CreateSubkey"]' />
            /// <devdoc>
            ///     Creates a subkey of the given name.
            /// </devdoc>
            public abstract Key CreateSubkey(string name);

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="Key.SetValue"]' />
            /// <devdoc>
            ///     Sets the name to the given value. Pass an empty string or null into this to
            ///     set the default value for a key.
            /// </devdoc>
            public abstract void SetValue(string valueName, object value);

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="Key.IDisposable.Dispose"]/*' />
            /// <internalonly/>
            /// <devdoc>
            /// Closes the key.
            /// </devdoc>
            void IDisposable.Dispose() {
                Close();
            }
        }

        /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext"]' />
        /// <devdoc>
        ///     Abstraction around the registry itself.
        /// </devdoc>
        public abstract class RegistrationContext {
            
            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext.ComponentPath"]' />
            /// <devdoc>
            ///     The path to the compnent that is being registered.  You should always use this rather than the 
            ///     codebase of the component type, and you should never assume that this is a physical path on
            ///     disk.  It may be a token that identifies the path at install time.  The "component"
            ///     is the type that the registration attribute was found on.
            /// </devdoc>
            public abstract string ComponentPath { get; }

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext.RegisteringType"]' />
            /// <devdoc>
            ///     The type of the component that is being registered.
            /// </devdoc>
            public abstract Type ComponentType { get; }

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext.InprocServerPath"]' />
            /// <devdoc>
            ///     The path to the COM object supplying the class factory.
            /// </devdoc>
            public abstract string InprocServerPath { get;}

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext.CodeBase"]' />
            /// <devdoc>
            ///     The path to the object being registered (including filename).
            /// </devdoc>
            public abstract string CodeBase { get;}

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext.RegistrationMethod"]' />
            /// <devdoc>
            /// Specify if the assembly should be located using CodeBase or Assembly
            /// </devdoc>
            public abstract RegistrationMethod RegistrationMethod{get;}

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext.Log"]' />
            /// <devdoc>
            ///     Returns a text writer that can be used to log registration information.  This should 
            ///     be a human readable (and ideally localized) bit of text that describes the
            ///     current registration process.
            /// </devdoc>
            public abstract TextWriter Log { get; }

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext.CreateKey"]' />
            /// <devdoc>
            ///     Creates a new key of the given name.  The key is created at the appropriate registration
            ///     point in the registry.  Always close or dispose this key when finished with it.
            /// </devdoc>
            public abstract Key CreateKey(string name);

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext.RemoveKey"]' />
            /// <devdoc>
            /// Removes the key of the given name.
            /// </devdoc>
            public abstract void RemoveKey(string name);

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext.RemoveValue"]' />
            /// <devdoc>
            /// Removes the value of the given name under the key of the given keyname
            /// </devdoc>
            public abstract void RemoveValue(string keyname, string valuename);

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext.RemoveKey"]' />
            /// <devdoc>
            /// Removes the key of the given name if it has no child key and
            /// no value.
            /// </devdoc>
            public abstract void RemoveKeyIfEmpty(string name);

            /// <include file='doc\RegistrationAttribute.uex' path='docs/doc[@for="RegistrationContext.EscapePath"]' />
            /// <devdoc>
            /// Escape the string if needed
            /// This is used by the implementation of the Register method on attributes so that paths be escaped when
            /// needed. The attribute itself does not know if we are writting to a .reg file or directly to the registry.
            /// </devdoc>
            public abstract string EscapePath(string str);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\RegisterLoadKeyAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegisterLoadKeyAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\RegisterLoadKeyAttribute.uex' path='docs/doc[@for="RegisterLoadKeyAttribute"]' />
    /// <devdoc>
    ///     This attribute registers a package load key for your package.  
    ///     Package load keys are used by Visual Studio to validate that 
    ///     a package can be loaded.    
    /// </devdoc>
    [Obsolete("RegisterLoadKeyAttribute has been deprecated. Please use ProvideLoadKeyAttribute instead.")]
    [AttributeUsage(AttributeTargets.Class, Inherited=false, AllowMultiple=false)]
    public sealed class RegisterLoadKeyAttribute : RegistrationAttribute {

        private string _minimumEdition;
        private string _productVersion;
        private string _productName;
        private string _companyName;
        private short  _resourceId;
    
        /// <include file='doc\RegisterLoadKeyAttribute.uex' path='docs/doc[@for="RegisterLoadKeyAttribute.RegisterLoadKeyAttribute"]/*' />
        public RegisterLoadKeyAttribute (string minimumEdition, string productVersion, string productName, string companyName, short resourceId) {
            if (minimumEdition == null) {
                throw new ArgumentNullException("minimumEdition");
            }
            if (productVersion == null) {
                throw new ArgumentNullException("productVersion");
            }
            if (productName == null) {
                throw new ArgumentNullException("productName");
            }
            if (companyName == null) {
                throw new ArgumentNullException("companyName");
            }
            
            _minimumEdition = minimumEdition;
            _productVersion = productVersion;
            _productName = productName;
            _companyName = companyName;
            _resourceId = resourceId;
        }
        
        /// <include file='doc\RegisterLoadKeyAttribute.uex' path='docs/doc[@for="RegisterLoadKeyAttribute.MinEdition"]' />
        /// <devdoc>
        ///     Minimum edition of Visual Studio on which
        ///     VSPackage is loaded. This must be the literal 
        ///     edition value provided by Microsoft when 
        ///     obtaining your PLK.
        /// </devdoc>
        public string MinimumEdition {
            get {
                return _minimumEdition;
            }
        }

        /// <include file='doc\RegisterLoadKeyAttribute.uex' path='docs/doc[@for="RegisterLoadKeyAttribute.ProductVersion"]' />
        /// <devdoc>
        ///     Version of the product that this VSPackage
        ///     implements.
        /// </devdoc>
        public string ProductVersion {
            get {
                return _productVersion;
            }
        }
        
        /// <include file='doc\RegisterLoadKeyAttribute.uex' path='docs/doc[@for="RegisterLoadKeyAttribute.ProductName"]' />
        /// <devdoc>
        ///     Name of the product that this VSPackage 
        ///     delivers. Note that one product might be
        ///     comprised of multiple VSPackages, in which 
        ///     case each will need its own PLK.
        /// </devdoc>
        public string ProductName {
            get {
                return _productName;
            }
        }

        /// <include file='doc\RegisterLoadKeyAttribute.uex' path='docs/doc[@for="RegisterLoadKeyAttribute.CompanyName"]' />
        /// <devdoc>
        ///     VSIP Partner/creator of the VSPackage. 
        ///     The literal name (case-sensitive) provided 
        ///     to Microsoft when registering for a PLK.
        /// </devdoc>
        public string CompanyName {
            get {
                return _companyName;
            }
        }
        
        /// <include file='doc\RegisterLoadKeyAttribute.uex' path='docs/doc[@for="RegisterLoadKeyAttribute.ResourceId"]' />
        /// <devdoc>
        ///     Resource ID for VSPackage load key.
        /// </devdoc>
        public short ResourceId {
            get {
                return _resourceId;
            }
        }

        /// <summary>
        /// Registry Key name for this package's load key information.
        /// </summary>
        /// <param name="context"></param>
        /// <returns></returns>
        public string RegKeyName (RegistrationContext context)
        {
            return string.Format(CultureInfo.InvariantCulture, "Packages\\{0}", context.ComponentType.GUID.ToString("B"));
        }

        /// <include file='doc\RegisterLoadKeyAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(SR.GetString(SR.Reg_NotifyLoadKey, CompanyName, ProductName, ProductVersion, MinimumEdition));

            using (Key packageKey = context.CreateKey(RegKeyName(context)))
            {
                packageKey.SetValue("ID", ResourceId);
                packageKey.SetValue("MinEdition", MinimumEdition);
                packageKey.SetValue("ProductVersion", ProductVersion);
                packageKey.SetValue("ProductName", ProductName);
                packageKey.SetValue("CompanyName", CompanyName);
            }
        }

        /// <summary>
        /// Unregisters this package's load key information
        /// </summary>
        /// <param name="context"></param>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(RegKeyName(context));
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\RegisterExtenderAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright from='2003' to='2004' company='Microsoft Corporation'>           
//  Copyright (c) Microsoft Corporation, All rights reserved.             
//  This code sample is provided "AS IS" without warranty of any kind, 
//  it is not recommended for use in a production environment.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <summary>
    ///     This attribute registers the package as an extender.  The GUID passed in determines
    ///     what is being extended. The attributes on a package do not control the behavior of
    ///     the package, but they can be used by registration tools to register the proper
    ///     information with Visual Studio.
    /// </summary>
    [Obsolete("RegisterExtenderAttribute has been deprecated. Please use ProvideExtenderAttribute instead.")]
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class RegisterExtenderAttribute : RegistrationAttribute {

		private Guid CATID = Guid.Empty;
		private Guid extender = Guid.Empty;
		private string name;

		/// <summary>
		///     Creates a new RegisterExtenderAttribute.
		/// </summary>
		/// <param name="extendeeCatId">CatId of the element you want to extend.</param>
		/// <param name="extenderGuid">GUID of the extender.</param>
		/// <param name="extenderName">Name of the element you want to extend.</param>
		public RegisterExtenderAttribute(string extendeeCatId, string extenderGuid, string extenderName) 
		{
			CATID = new Guid(extendeeCatId);
			extender = new Guid(extenderGuid);
			name = extenderName;
		}

		/// <summary>
		/// The CatID of the element being extended.
		/// </summary>
		public Guid ExtendeeCatId {
			get {
				return CATID;
			}
		}

		/// <summary>
		/// The Guid of the extender.
		/// </summary>
		public Guid Extender {
			get {
				return extender;
			}
		}

		/// <summary>
		/// The name of the extender.
		/// </summary>
		public string ExtenderName {
			get {
				return name ;
			}
		}

		/// <summary>
		///		The reg key name of this Extender.
		/// </summary>
		private string RegKeyName 
		{
			get 
			{
				return string.Format(CultureInfo.InvariantCulture, "Extenders\\{0}\\{1}", CATID.ToString("B"), name);
			}
		}

		/// <summary>
		///     Called to register this attribute with the given context.  The context
		///     contains the location where the registration information should be placed.
		///     it also contains such as the type being registered, and path information.
		/// </summary>
		public override void Register(RegistrationContext context) 
		{
			context.Log.WriteLine(SR.GetString(SR.Reg_NotifyExtender, name, CATID.ToString("B")));

			using (Key childKey = context.CreateKey(RegKeyName))
			{
				// Set default value for the Key = Extender GUID
				childKey.SetValue(string.Empty, extender.ToString("B"));
			}
		}

		/// <summary>
		/// Unregister this Extender specification.
		/// </summary>
		public override void Unregister(RegistrationContext context)
		{
			context.RemoveKey(RegKeyName);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\RegisterLanguageExtensionAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegisterLanguageExtensionAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <include file='doc\RegisterLanguageExtensionAttribute.uex' path='docs/doc[@for="RegisterLanguageExtensionAttribute"]' />
    /// <devdoc>
    ///     This attribute associates a file extension to a given editor factory.  
    ///     The editor factory may be specified as either a GUID or a type and 
    ///     is placed on a package.
    /// </devdoc>
    [Obsolete("RegisterLanguageExtensionAttribute has been deprecated. Please use ProvideLanguageExtensionAttribute instead.")]
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class RegisterLanguageExtensionAttribute : RegistrationAttribute {

        private Guid languageService;
        private string extension;
        
        /// <include file='doc\RegisterLanguageExtensionAttribute.uex' path='docs/doc[@for="RegisterLanguageExtensionAttribute.RegisterLanguageExtensionAttribute"]' />
        /// <devdoc>
        ///     Creates a new attribute.
        /// </devdoc>
        public RegisterLanguageExtensionAttribute (string languageServiceGuid, string extension) {

            if (!extension.StartsWith(".", StringComparison.OrdinalIgnoreCase)) {
                throw new ArgumentException(SR.GetString(SR.Attributes_ExtensionNeedsDot, extension));
            }

            this.languageService = new Guid(languageServiceGuid);
            this.extension = extension;
        }
        
        /// <include file='doc\RegisterLanguageExtensionAttribute.uex' path='docs/doc[@for="RegisterLanguageExtensionAttribute.RegisterLanguageExtensionAttribute1"]' />
        /// <devdoc>
        ///     Creates a new attribute.
        /// </devdoc>
        public RegisterLanguageExtensionAttribute (Type languageService, string extension) {

            if (!extension.StartsWith(".", StringComparison.OrdinalIgnoreCase)) {
                throw new ArgumentException(SR.GetString(SR.Attributes_ExtensionNeedsDot, extension));
            }

            this.languageService = languageService.GUID;
            this.extension = extension;
        }
        
        /// <include file='doc\RegisterLanguageExtensionAttribute.uex' path='docs/doc[@for="RegisterLanguageExtensionAttribute.Extension"]' />
        /// <devdoc>
        ///     The file extension of the file.
        /// </devdoc>
        public string Extension {
            get {
                return extension;
            }
        }
        
        /// <include file='doc\RegisterLanguageExtensionAttribute.uex' path='docs/doc[@for="RegisterLanguageExtensionAttribute.LanguageService"]' />
        /// <devdoc>
        ///     The language service SID.
        /// </devdoc>
        public Guid LanguageService {
            get {
                return languageService;
            }
        }

        private string ExtensionsRegKey
        {
            get { return string.Format(CultureInfo.InvariantCulture, "Languages\\File Extensions\\{0}", Extension); }
        }

        /// <include file='doc\RegisterLanguageExtensionAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(SR.GetString(SR.Reg_NotifyLanguageExtension, Extension, LanguageService.ToString("B")));

            using (Key childKey = context.CreateKey(ExtensionsRegKey))
            {
                childKey.SetValue(string.Empty, LanguageService.ToString("B"));
            }
        }

        /// <include file='doc\RegisterLanguageExtensionAttribute.uex' path='docs/doc[@for="Unregister"]' />
        /// <devdoc>
        /// Called to remove this attribute from the given context.
        /// </devdoc>
        public override void Unregister(RegistrationContext context) {
            context.RemoveKey(ExtensionsRegKey);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\RegistryPaths.cs ===
namespace Microsoft.VisualStudio.Shell
{
    // These string names and definitions are from vscommon\inc\vsregkeynames.h
    internal class RegistryPaths
    {
        private RegistryPaths() { }

        internal static string package            = "Package";
        internal static string displayName        = "DisplayName";
        internal static string languageStringId   = "LangStringID";
        internal static string languageResourceId = "LangResID";
        internal static string showRoots          = "ShowRoots";
        internal static string indexPath          = "IndexPath";
        internal static string paths              = "Paths";
        internal static string languages          = "Languages";
        internal static string languageServices   = languages + "\\Language Services";
        internal static string codeExpansion      = languages + "\\CodeExpansions";
        internal static string forceCreateDirs    = "ForceCreateDirs";
        internal static string debuggerLanguages  = "Debugger Languages";
        internal static string editorToolsOptions = "EditorToolsOptions";
        internal static string page               = "Page";
    }

    internal class LanguageOptionKeys
    {
        private LanguageOptionKeys() { }

        internal static string showCompletion               = "ShowCompletion";
        internal static string showIndentOptions            = "ShowSmartIndent";
        internal static string useStockColors               = "RequestStockColors";
        internal static string showHotURLs                  = "ShowHotURLs";
        internal static string nonHotURLs                   = "Default to Non Hot URLs";
        internal static string insertSpaces                 = "DefaultToInsertSpaces";
        internal static string showDropDownBar              = "ShowDropdownBarOption";
        internal static string disableWindowNewWindow       = "Single Code Window Only";
        internal static string enableAdvMembersOption       = "EnableAdvancedMembersOption";
        internal static string supportCF_HTML               = "Support CF_HTML";
        internal static string enableLineNumbersOption      = "EnableLineNumbersOption";
        internal static string hideAdvancedMembersByDefault = "HideAdvancedMembersByDefault";
        internal static string codeSense                    = "CodeSense";
        internal static string matchBraces                  = "MatchBraces";
        internal static string quickInfo                    = "QuickInfo";
        internal static string showMatchingBrace            = "ShowMatchingBrace";
        internal static string matchBracesAtCaret           = "MatchBracesAtCaret";
        internal static string maxErrorMessages             = "MaxErrorMessages";
        internal static string codeSenseDelay               = "CodeSenseDelay";
        internal static string enableAsyncCompletion        = "EnableAsyncCompletion";
        internal static string enableCommenting             = "EnableCommenting";
        internal static string enableFormatSelection        = "EnableFormatSelection";
        internal static string autoOutlining                = "AutoOutlining";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\RegisterProjectItem.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegisterProjectItemAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell
{
    using System;
    using System.IO;
    using System.Diagnostics;
    using System.Globalization;


    /// <include file='doc\RegisterProjectItemAttribute.uex' path='docs/doc[@for="RegisterProjectItemAttribute"]' />
    /// <devdoc>
    ///     This attribute associates register items to be included in the Add New Item.  
    ///     dialog for the specified project type. It is placed on a package.
    /// </devdoc>
	[Obsolete("RegisterProjectItemAttribute has been deprecated. Please use ProvideProjectItemAttribute instead.")]    
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class RegisterProjectItemAttribute : RegistrationAttribute
    {
        private int priority;
        private Guid factory;
        private string templateDir;
        private string itemType;

        /// <include file='doc\RegisterProjectItemAttribute.uex' path='docs/doc[@for="RegisterProjectItemAttribute.RegisterProjectItemAttribute"]' />
        /// <devdoc>
        ///     Creates a new attribute.
        /// </devdoc>
        public RegisterProjectItemAttribute(object projectFactoryType, string itemCategoryName, string templatesDir, int priority)
        {
            if (templatesDir == null || templatesDir.Length == 0)
                throw new ArgumentNullException("templatesDir");

            if (itemCategoryName == null || itemCategoryName.Length == 0)
                throw new ArgumentNullException("itemCategoryName");

            // figure out what type of object they passed in and get the GUID from it
            if (projectFactoryType is string)
                this.factory = new Guid((string)projectFactoryType);
            else if (projectFactoryType is Type)
                this.factory = ((Type)projectFactoryType).GUID;
            else if (projectFactoryType is Guid)
                this.factory = (Guid)projectFactoryType;
            else
                throw new ArgumentException(SR.GetString(SR.Attributes_InvalidFactoryType, projectFactoryType));

            this.priority = priority;
            this.templateDir = templatesDir;
            this.itemType = itemCategoryName;
        }

        /// <include file='doc\RegisterProjectItemAttribute.uex' path='docs/doc[@for="RegisterProjectItemAttribute.ProjectFactoryType"]' />
        /// <devdoc>
        ///     The Project factory guid.
        /// </devdoc>
        public Guid ProjectFactoryType
        {
            get {return factory;}
        }

        /// <include file='doc\RegisterProjectItemAttribute.uex' path='docs/doc[@for="RegisterProjectItemAttribute.Priority"]' />
        /// <devdoc>
        ///     The priority of this item.
        /// </devdoc>
        public int Priority
        {
            get {return priority;}
        }

        /// <include file='doc\RegisterProjectItemAttribute.uex' path='docs/doc[@for="RegisterProjectItemAttribute.TemplateDir"]/*' />
        public string TemplateDir
        {
            get { return templateDir; }
        }

        /// <include file='doc\RegisterProjectItemAttribute.uex' path='docs/doc[@for="RegisterProjectItemAttribute.ItemType"]/*' />
        /// <summary>
        /// String describing the item type. This string is used as the folder in the
        /// left side of the "Add New Items" dialog.
        /// </summary>
        public string ItemType
        {
            get { return itemType; }
        }


        /// <summary>
        ///        The reg key name of the project.
        /// </summary>
        private string ProjectRegKeyName(RegistrationContext context) 
        {
            return string.Format(CultureInfo.InvariantCulture, "Projects\\{0}\\AddItemTemplates\\TemplateDirs\\{1}\\/1",
                                factory.ToString("B"),
                                context.ComponentType.GUID.ToString("B"));
        }

        /// <include file='doc\RegisterProjectItemAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context)
        {
            context.Log.WriteLine(SR.GetString(SR.Reg_NotifyProjectItems, factory.ToString("B")));

            using (Key childKey = context.CreateKey(ProjectRegKeyName(context)))
            {
                childKey.SetValue("", itemType);

                Uri url = new Uri(context.ComponentType.Assembly.CodeBase, true);
                string templates = url.LocalPath;
                templates = System.IO.Path.Combine(System.IO.Path.GetDirectoryName(templates), templateDir);
                templates = context.EscapePath(System.IO.Path.GetFullPath(templates));
                childKey.SetValue("TemplatesDir", templates);

                childKey.SetValue("SortPriority", Priority);
            }
        }

        /// <include file='doc\RegisterProjectItem.uex' path='docs/doc[@for="RegisterProjectItemAttribute.Unregister"]/*' />
        /// <summary>
        /// Unregister this editor.
        /// </summary>
        /// <param name="context"></param>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(ProjectRegKeyName(context));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\RunningDocumentTable.cs ===
//--------------------------------------------------------------------------
//  <copyright file="RunningDocumentTable.cs" company="Microsoft">
//      Copyright (c) Microsoft Corporation.  All rights reserved.
//  </copyright>
//  <summary>
//  </summary>
//--------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Diagnostics;
using System.ComponentModel;
using System.Globalization;
using System.IO;
using System.Collections;
using System.Xml;
using System.Text;
using System.Text.RegularExpressions;
using System.Net;
using System.Collections.Generic;
using System.Reflection;
using Microsoft.VisualStudio.TextManager.Interop;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.Designer.Interfaces;
using Microsoft.VisualStudio.Shell;
using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
using IServiceProvider = System.IServiceProvider;
using ShellConstants = Microsoft.VisualStudio.Shell.Interop.Constants;
using OleConstants = Microsoft.VisualStudio.OLE.Interop.Constants;

namespace Microsoft.VisualStudio.Shell {

    public class RunningDocumentTable : IEnumerable<RunningDocumentInfo> {
        IServiceProvider site;
        IVsRunningDocumentTable rdt;

        /// <include file='doc\RunningDocumentTable.uex' path='docs/doc[@for="RunningDocumentTable.RunningDocumentTable"]/*' />
        public RunningDocumentTable(IServiceProvider site) {
            this.site = site;
            this.rdt = site.GetService(typeof(SVsRunningDocumentTable)) as IVsRunningDocumentTable;
            if (this.rdt == null){
                throw new System.NotSupportedException(typeof(SVsRunningDocumentTable).FullName);
            }
        }

        /// <include file='doc\RunningDocumentTable.uex' path='docs/doc[@for="RunningDocumentTable.FindDocument"]/*' />
        public object FindDocument(string moniker) {
            IVsHierarchy hierarchy;
            uint itemid;
            uint docCookie;
            return FindDocument(moniker, out hierarchy, out itemid, out docCookie);
        }

        /// <include file='doc\RunningDocumentTable.uex' path='docs/doc[@for="RunningDocumentTable.FindDocument1"]/*' />
        public object FindDocument(string moniker, out uint docCookie) {
            IVsHierarchy hierarchy;
            uint itemid;
            return FindDocument(moniker, out hierarchy, out itemid, out docCookie);
        }

        /// <include file='doc\RunningDocumentTable.uex' path='docs/doc[@for="RunningDocumentTable.FindDocument2"]/*' />
        public object FindDocument(string moniker, out IVsHierarchy hierarchy, out uint itemid, out uint docCookie){
            itemid = 0;
            hierarchy = null;
            docCookie = 0;
            if (this.rdt == null) return null;
            IntPtr docData = IntPtr.Zero;
            NativeMethods.ThrowOnFailure(rdt.FindAndLockDocument((uint)_VSRDTFLAGS.RDT_NoLock, moniker, out hierarchy, out itemid, out docData, out docCookie));
            if (docData == IntPtr.Zero) return null;
            try {
                return Marshal.GetObjectForIUnknown(docData);
            } finally {
                Marshal.Release(docData);
            }
        }

        /// <include file='doc\RunningDocumentTable.uex' path='docs/doc[@for="RunningDocumentTable.GetHierarchyItem"]/*' />
        public IVsHierarchy GetHierarchyItem(string moniker) {                      
            uint docCookie;
            uint itemid;
            IVsHierarchy hierarchy;
            object docData = this.FindDocument(moniker, out hierarchy, out itemid, out docCookie);
            return hierarchy;
        }

        /// <include file='doc\RunningDocumentTable.uex' path='docs/doc[@for="RunningDocumentTable.GetRunningDocumentContents"]/*' />
        /// Return the document contents if it is loaded, otherwise return null.
        public string GetRunningDocumentContents(string path) {
            object docDataObj = this.FindDocument(path);
            if (docDataObj != null) {
                return GetBufferContents(docDataObj);
            }
            return null;
        }

        private static string GetBufferContents(object docDataObj) {
            string text = null;
            IVsTextLines buffer = null;
            if (docDataObj is IVsTextLines) {
                buffer = (IVsTextLines)docDataObj;
            } else if (docDataObj is IVsTextBufferProvider) {
                IVsTextBufferProvider tp = (IVsTextBufferProvider)docDataObj;
                if (tp.GetTextBuffer(out buffer) != NativeMethods.S_OK)
                    buffer = null;
            }
            if (buffer != null) {
                int endLine, endIndex;
                NativeMethods.ThrowOnFailure(buffer.GetLastLineIndex(out endLine, out endIndex));
                NativeMethods.ThrowOnFailure(buffer.GetLineText(0, 0, endLine, endIndex, out text));
                buffer = null;
            }
            return text;
        }

        public string GetRunningDocumentContents(uint docCookie) {
            uint flags, readLocks, editLocks, itemid;
            string moniker;
            IVsHierarchy hierarchy;
            IntPtr docData;
            int hr = this.rdt.GetDocumentInfo(docCookie, out flags, out readLocks, out editLocks, out moniker, out hierarchy, out itemid, out docData);
            if (hr == VSConstants.S_OK && docData != IntPtr.Zero) {
                try {
                    object data = Marshal.GetObjectForIUnknown(docData);
                    return GetBufferContents(data);
                } finally {
                    Marshal.Release(docData);
                }
            }
            return "";
        }

        public RunningDocumentInfo GetDocumentInfo(uint docCookie) {
            RunningDocumentInfo info = new RunningDocumentInfo();
            IntPtr docData;
            int hr = this.rdt.GetDocumentInfo(docCookie, out info.Flags,
                out info.ReadLocks, out info.EditLocks, out info.Moniker,
                out info.Hierarchy, out info.ItemId, out docData);
            if (hr == VSConstants.S_OK) {
                try {
                    if (docData != IntPtr.Zero)
                        info.DocData = Marshal.GetObjectForIUnknown(docData);
                    return info;
                } finally {
                    Marshal.Release(docData);
                }
            }
            return info;
        }

        /// <include file='doc\RunningDocumentTable.uex' path='docs/doc[@for="VsShell.SaveFileIfDirty"]/*' />
        public string SaveFileIfDirty(string fullPath) {
            object docData = this.FindDocument(fullPath);
            if (docData is IVsPersistDocData2) {
                IVsPersistDocData2 pdd = (IVsPersistDocData2)docData;
                int dirty = 0;
                int hr = pdd.IsDocDataDirty(out dirty);
                if (NativeMethods.Succeeded(hr) && dirty != 0) {
                    string newdoc;
                    int cancelled;
                    NativeMethods.ThrowOnFailure(pdd.SaveDocData(VSSAVEFLAGS.VSSAVE_Save, out newdoc, out cancelled));
                    return newdoc;
                }
            }
            return fullPath;
        }

        public void RenameDocument(string oldName, string newName, IVsHierarchy pIVsHierarchy, uint itemId){
            IntPtr pUnk = Marshal.GetIUnknownForObject(pIVsHierarchy);
            if (pUnk != IntPtr.Zero) {
                try {
                    IntPtr pHier = IntPtr.Zero;
                    Guid guid = typeof(IVsHierarchy).GUID;
                    NativeMethods.ThrowOnFailure(Marshal.QueryInterface(pUnk, ref guid, out pHier));
                    try {
                        NativeMethods.ThrowOnFailure(this.rdt.RenameDocument(oldName, newName, pHier, itemId));
                    } finally {
                        Marshal.Release(pHier);
                    }
                } finally {
                    Marshal.Release(pUnk);
                }
            }
        }

        public uint Advise(IVsRunningDocTableEvents sink) {
            uint cookie;
            NativeMethods.ThrowOnFailure(this.rdt.AdviseRunningDocTableEvents(sink, out cookie));
            return cookie;
        }

        public void Unadvise(uint cookie) {
            NativeMethods.ThrowOnFailure(this.rdt.UnadviseRunningDocTableEvents(cookie));
        }

        public uint RegisterAndLockDocument(_VSRDTFLAGS lockType, string mkDocument, IVsHierarchy hierarchy, uint itemid, IntPtr docData) {
            uint cookie;
            NativeMethods.ThrowOnFailure(rdt.RegisterAndLockDocument((uint)lockType, mkDocument, hierarchy, itemid, docData, out cookie));
            return cookie;           
        }

        public void LockDocument(_VSRDTFLAGS lockType, uint cookie) {
            NativeMethods.ThrowOnFailure(rdt.LockDocument((uint)lockType, cookie));
        }

        public void UnlockDocument(_VSRDTFLAGS lockType, uint cookie) {
            NativeMethods.ThrowOnFailure(rdt.UnlockDocument((uint)lockType, cookie));
        }

        // Enumerate the running documents
        public IEnumerator<RunningDocumentInfo> GetEnumerator() {
            IList<RunningDocumentInfo> list = new List<RunningDocumentInfo>();
            IEnumRunningDocuments ppenum;
            if (NativeMethods.Succeeded(rdt.GetRunningDocumentsEnum(out ppenum))) {
                uint[] rgelt = new uint[1];
                uint fetched = 0;
                while (true) {
                    if (NativeMethods.Succeeded(ppenum.Next(1, rgelt, out fetched)) && fetched == 1) {
                        list.Add(GetDocumentInfo(rgelt[0]));
                    } else {
                        break;
                    }
                }
            }
            return list.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator() {
            return GetEnumerator();
        }
    }

    [CLSCompliant(false)]
    public struct RunningDocumentInfo {
        public uint Flags;
        public uint ReadLocks;
        public uint EditLocks;
        public IVsHierarchy Hierarchy;
        public uint ItemId;
        public string Moniker;
        public object DocData;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\ServiceProvider.cs ===
//------------------------------------------------------------------------------
// <copyright file="ServiceProvider.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell.Interop;
    using System;
    using System.Diagnostics;
    using System.Runtime.InteropServices;

    using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
    using IServiceProvider = System.IServiceProvider;

    /// <include file='doc\ServiceProvider.uex' path='docs/doc[@for="ServiceProvider"]' />
    /// <devdoc>
    ///     This class acts as a bridge between Microsoft.VisualStudio.OLE.Interop.IServiceProvider 
    ///     and System.IServiceProvider.  It implements System.IServiceProvider and takes 
    ///     as a constructor argument an instance of Microsoft.VisualStudio.OLE.Interop.IServiceProvider.  
    ///     It supports both GUID and type based lookups and also has debug code to assert 
    ///     for common native implementation pitfalls, like not implementing IUnknown on 
    ///     an object or requiring a specific IID along with a matching SID.
    /// </devdoc>
    [CLSCompliant(false)]
	[System.Runtime.InteropServices.ComVisible(true)]
    public sealed class ServiceProvider : IServiceProvider, IDisposable, IObjectWithSite {
        
        private static TraceSwitch TRACESERVICE = new TraceSwitch("TRACESERVICE", "ServiceProvider: Trace service provider requests.");

        private IOleServiceProvider    serviceProvider;
        private bool                   defaultServices;

        /// <include file='doc\ServiceProvider.uex' path='docs/doc[@for="ServiceProvider.ServiceProvider"]' />
        /// <devdoc>
        ///     Creates a new ServiceProvider object and uses the given interface to resolve
        ///     services.
        /// </devdoc>
        public ServiceProvider(IOleServiceProvider sp) : this(sp, true){
        }
        
        /// <include file='doc\ServiceProvider.uex' path='docs/doc[@for="ServiceProvider.ServiceProvider1"]' />
        /// <devdoc>
        ///     Creates a new ServiceProvider object and uses the given interface to resolve
        ///     services.  If defaultServices is true (the default) this service  provider will
        ///     respond to Microsoft.VisualStudio.OLE.Interop.IServiceProvider and IObjectWithSite
        ///     as services.  A query for Microsoft.VisualStudio.OLE.Interop.IServiceProvider will
        ///     return the underlying COM service provider and a query for IObjectWithSite will
        ///     return this object.  If false is passed into defaultServices these two services
        ///     will not be provided and the service provider will be "transparent".
        /// </devdoc>
        public ServiceProvider(IOleServiceProvider sp, bool defaultServices) {
            if (sp == null) {
                throw new ArgumentNullException("sp");
            }
            this.serviceProvider = sp;
            this.defaultServices = defaultServices;
        }
        
        /// <include file='doc\ServiceProvider.uex' path='docs/doc[@for="ServiceProvider.Dispose"]' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Dispose() {
            if (serviceProvider != null) {
                serviceProvider = null;
            }
        }

        /// <include file='doc\ServiceProvider.uex' path='docs/doc[@for="ServiceProvider.GetService"]' />
        /// <devdoc>
        ///     Retrieves the requested service.
        /// </devdoc>
        public object GetService(Type serviceType) {

            if (serviceType == null) {
                throw new ArgumentNullException("serviceType");
            }

            // If we have already been disposed, disallow all service
            // requests.
            //
            if (serviceProvider == null) {
                return null;
            }
            
            // First, can we resolve this service class into a GUID?  If not, then
            // we have nothing to pass.
            //
            Debug.WriteLineIf(TRACESERVICE.TraceVerbose, "Resolving service '" + serviceType.FullName + " through the service provider " + serviceProvider.ToString() + ".");
            return GetService(serviceType.GUID, serviceType);
        }

        /// <include file='doc\ServiceProvider.uex' path='docs/doc[@for="ServiceProvider.GetService1"]' />
        /// <devdoc>
        ///     Retrieves the requested service.
        /// </devdoc>
        public object GetService(Guid guid) {
            return GetService(guid, null);
        }

        /// <devdoc>
        ///     Retrieves the requested service.  The guid must be specified; the class is only
        ///     used when debugging and it may be null.
        /// </devdoc>
        private object GetService(Guid guid, Type serviceType) {
            object service = null;

            // No valid guid on the passed in class, so there is no service for it.
            //
            if (guid.Equals(Guid.Empty)) {
                Debug.WriteLineIf(TRACESERVICE.TraceVerbose, "\tNo SID -- Guid is empty");
                return null;
            }

            // We provide a couple of services of our own.
            //
            if (defaultServices) {
                if (guid.Equals(NativeMethods.IID_IServiceProvider)) {
                    return serviceProvider;
                }
                if (guid.Equals(NativeMethods.IID_IObjectWithSite)) {
                    return (IObjectWithSite)this;
                }
            }

            IntPtr pUnk = IntPtr.Zero;
            Guid guidUnk = NativeMethods.IID_IUnknown;
            int hr = serviceProvider.QueryService(ref guid, ref guidUnk, out pUnk);

            if ( (NativeMethods.Succeeded(hr)) && (IntPtr.Zero != pUnk) ) {
                try {
                    service = Marshal.GetObjectForIUnknown(pUnk);
                }
                finally {
                    Marshal.Release(pUnk);
                }
            }
            else {
                service = null;

                // These may be interesting to log.
                //
                Debug.WriteLineIf(TRACESERVICE.TraceVerbose, "\tQueryService failed");

                #if DEBUG
                // Ensure that this service failure was not the result of a bad QI implementation.
                // In C++, 99% of a service query uses SID == IID, but for us, we always use IID = IUnknown
                // first.  If the service didn't implement IUnknown correctly, we'll fail the service request
                // and it's very difficult to track this down. 
                //
                pUnk = IntPtr.Zero;
                hr = serviceProvider.QueryService(ref guid, ref guid, out pUnk);

                if ( (NativeMethods.Succeeded(hr)) && (IntPtr.Zero != pUnk) ) {
                    object obj = null;
                    try {
                        obj = Marshal.GetObjectForIUnknown(pUnk);
                    }
                    finally {
                        Marshal.Release(pUnk);
                    }

                    // Note that I do not return this service if we succeed -- I don't
                    // want to make debug work correctly when retail doesn't!
                    Debug.Assert(!System.Runtime.InteropServices.Marshal.IsComObject(obj),
                                 "The service " + (serviceType != null ? serviceType.Name : guid.ToString()) +
                                 " implements it's own interface, but does not implement IUnknown!\r\n" +
                                 "This is a bad service implementation, not a problem in the CLR service provider mechanism." + obj.ToString());
                }

                #endif
            }

            return service;
        }

        /// <include file='doc\ServiceProvider.uex' path='docs/doc[@for="ServiceProvider.IObjectWithSite.GetSite"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Retrieves the current site object we're using to
        /// resolve services.
        /// </devdoc>
        void IObjectWithSite.GetSite(ref Guid riid, out IntPtr ppv) {
            object o = GetService(riid);
            if (o == null) {
                Marshal.ThrowExceptionForHR(NativeMethods.E_NOINTERFACE);
            }

            IntPtr punk = Marshal.GetIUnknownForObject(o);
            int hr = Marshal.QueryInterface(punk, ref riid, out ppv);
            Marshal.Release(punk);
            if (NativeMethods.Failed(hr)) {
                Marshal.ThrowExceptionForHR(hr);
            }
        }

        /// <include file='doc\ServiceProvider.uex' path='docs/doc[@for="ServiceProvider.IObjectWithSite.SetSite"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Sets the site object we will be using to resolve services.
        /// </devdoc>
        void IObjectWithSite.SetSite(object pUnkSite) {
            if (pUnkSite is IOleServiceProvider) {
                serviceProvider = (IOleServiceProvider)pUnkSite;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\SelectionContainer.cs ===
namespace Microsoft.VisualStudio.Shell
{
    using System;
    using System.Collections;
    using System.Runtime.InteropServices;
    using ISelectionContainer = Microsoft.VisualStudio.Shell.Interop.ISelectionContainer;

    /// <include file='doc\SelectionContainer.uex' path='docs/doc[@for="SelectionContainer"]/*' />
    /// <devdoc>
    /// This class implements the ISelectionContainer interface. It can be used to show
    /// informations on the property window.
    /// </devdoc>
    [CLSCompliant(false)]
    public class SelectionContainer : 
        ISelectionContainer
    {
        private ICollection     _selectableObjects;
        private ICollection     _selectedObjects;
        private readonly bool   _selectableReadOnly;
        private readonly bool   _selectedReadOnly;

        private static ICollection _emptyCollection = new Object[0];

        // Constants for selection container flags.
        /// <include file='doc\SelectionContainer.uex' path='docs/doc[@for="SelectionContainer.ALL"]/*' />
        public const uint ALL = 0x1;
        /// <include file='doc\SelectionContainer.uex' path='docs/doc[@for="SelectionContainer.SELECTED"]/*' />
        public const uint SELECTED = 0x2;

        private const int SELOBJ_ACTIVATE_WINDOW = 0x1;


        /// <include file='doc\SelectionContainer.uex' path='docs/doc[@for="SelectionContainer.SelectionContainer"]/*' />
        /// <devdoc>
        /// Creates a container with empty collections of selected and selectable objects.
        /// </devdoc>
        public SelectionContainer()
        {
            _selectableObjects = _emptyCollection;
            _selectedObjects = _emptyCollection;
        }

        /// <include file='doc\SelectionContainer.uex' path='docs/doc[@for="SelectionContainer.SelectionContainer1"]/*' />
        /// <devdoc>
        /// Creates a selection container with empty collections of selected and selectable objects.
        /// </devdoc>
        /// <param name="selectableReadOnly">Specifies if the collection of the selectable objects is read only.</param>
        /// <param name="selectedReadOnly">Specifies if the selection is read only.</param>
        public SelectionContainer(bool selectableReadOnly, bool selectedReadOnly) : this()
        {
            _selectableReadOnly = selectableReadOnly;
            _selectedReadOnly = selectedReadOnly;
        }

        /// <include file='doc\SelectionContainer.uex' path='docs/doc[@for="SelectionContainer.SelectableObjects"]/*' />
        /// <devdoc>
        /// Get or set the collection of the selectable objects
        /// </devdoc>
        public ICollection SelectableObjects
        {
            get
            {
                return _selectableObjects;
            }
            set
            {
                if (value == null)
                {
                    value = _emptyCollection;
                }
                _selectableObjects = value;
            }
        }

        /// <include file='doc\SelectionContainer.uex' path='docs/doc[@for="SelectionContainer.SelectedObjects"]/*' />
        /// <devdoc>
        /// Get or set the collection of the selected objects.
        /// </devdoc>
        public ICollection SelectedObjects
        {
            get
            {
                return _selectedObjects;
            }
            set
            {
                if (value == null)
                {
                    value = _emptyCollection;
                }
                _selectedObjects = value;
            }
        }

        /// <include file='doc\SelectionContainer.uex' path='docs/doc[@for="SelectionContainer.SelectedObjectsChanged"]/*' />
        /// <devdoc>
        /// This event is fired when the selection changes.
        /// </devdoc>
        public event EventHandler SelectedObjectsChanged;

        /// <include file='doc\SelectionContainer.uex' path='docs/doc[@for="SelectionContainer.ActivateObjects"]/*' />
        /// <devdoc>
        /// Activates the selected objects. Its default implementation is empty.
        /// </devdoc>
        protected virtual void ActivateObjects()
        {
            // This default implementation of this function is empty.
        }

        // Helper function to change the selected objects
        private void ChangeSelection(object[] prgUnkObjects, int dwFlags)
        {
            // Check if it is possible to change the selection.
            if (_selectedReadOnly) throw new InvalidOperationException();
            // Store the array of selected object in the internal array
            SelectedObjects = prgUnkObjects;
            // Raise the "Selected objects changed" event.
            if (SelectedObjectsChanged != null) SelectedObjectsChanged(this, EventArgs.Empty);
            // Check if the objects need to be activated
            if ( (dwFlags & SELOBJ_ACTIVATE_WINDOW) != 0 )
            {
                ActivateObjects();
            }
        }

   
    
#region ISelectionContainer Members

        /// <include file='doc\SelectionContainer.uex' path='docs/doc[@for="SelectionContainer.ISelectionContainer.CountObjects"]/*' />
        /// <internalonly/>
        int ISelectionContainer.CountObjects(uint dwFlags, out uint pc)
        {
            switch (dwFlags)
            {
                case ALL:
                    pc = (uint)SelectableObjects.Count;
                    break;

                case SELECTED:
                    pc = (uint)SelectedObjects.Count;
                    break;

                default:
                    throw new ArgumentException(SR.GetString(SR.General_UnsupportedValue, dwFlags), "dwFlags");
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\SelectionContainer.uex' path='docs/doc[@for="SelectionContainer.ISelectionContainer.GetObjects"]/*' />
        /// <internalonly/>
        int ISelectionContainer.GetObjects(uint dwFlags, uint cObjects, object[] apUnkObjects)
        {
            ICollection objects = null;

            switch (dwFlags)
            {
                case ALL:
                    objects = SelectableObjects;
                    break;

                case SELECTED:
                    objects = SelectedObjects;
                    break;

                default:
                    throw new ArgumentException(SR.GetString(SR.General_UnsupportedValue, dwFlags), "dwFlags");
            }

            int idx = 0;
            foreach (object obj in objects)
            {
                if (idx >= cObjects || idx >= apUnkObjects.Length)
                {
                    break;
                }
                apUnkObjects[idx++] = obj;
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\SelectionContainer.uex' path='docs/doc[@for="SelectionContainer.ISelectionContainer.SelectObjects"]/*' />
        /// <internalonly/>
        int ISelectionContainer.SelectObjects(uint cSelect, object[] apUnkSelect, uint dwFlags)
        {
            ChangeSelection(apUnkSelect, (int)dwFlags);
            return NativeMethods.S_OK;
        }

#endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\TaskCategory.cs ===
//------------------------------------------------------------------------------
// <copyright file="TaskCategory.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell.Interop;
    using Microsoft.Win32;
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.IO;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Windows.Forms;

    using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
    using IServiceProvider = System.IServiceProvider;

    /// <include file='doc\TaskCategory.uex' path='docs/doc[@for="TaskCategory"]' />
    /// <devdoc>
    ///     This class implements IVsTask.  It provides a 
    ///     framework-friendly way to define a package and its associated 
    ///     services.
    /// </devdoc>
    public enum TaskCategory {
        /// <include file='doc\TaskCategory.uex' path='docs/doc[@for="TaskCategory.All"]/*' />
        All = VSTASKCATEGORY.CAT_ALL,
        /// <include file='doc\TaskCategory.uex' path='docs/doc[@for="TaskCategory.BuildCompile"]/*' />
        BuildCompile = VSTASKCATEGORY.CAT_BUILDCOMPILE,
        /// <include file='doc\TaskCategory.uex' path='docs/doc[@for="TaskCategory.Comments"]/*' />
        Comments = VSTASKCATEGORY.CAT_COMMENTS,
        /// <include file='doc\TaskCategory.uex' path='docs/doc[@for="TaskCategory.CodeSense"]/*' />
        CodeSense = VSTASKCATEGORY.CAT_CODESENSE,
        /// <include file='doc\TaskCategory.uex' path='docs/doc[@for="TaskCategory.ShortCuts"]/*' />
        ShortCuts = VSTASKCATEGORY.CAT_SHORTCUTS,
        /// <include file='doc\TaskCategory.uex' path='docs/doc[@for="TaskCategory.User"]/*' />
        User = VSTASKCATEGORY.CAT_USER,
        /// <include file='doc\TaskCategory.uex' path='docs/doc[@for="TaskCategory.Misc"]/*' />
        Misc = VSTASKCATEGORY.CAT_MISC,
        /// <include file='doc\TaskCategory.uex' path='docs/doc[@for="TaskCategory.Html"]/*' />
        Html = VSTASKCATEGORY.CAT_HTML
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\TaskPriority.cs ===
//------------------------------------------------------------------------------
// <copyright file="TaskPriority.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell.Interop;
    using Microsoft.Win32;
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.IO;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Windows.Forms;

    using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
    using IServiceProvider = System.IServiceProvider;

    /// <include file='doc\TaskPriority.uex' path='docs/doc[@for="TaskPriority"]' />
    /// <devdoc>
    ///     This class implements IVsTask.  It provides a 
    ///     framework-friendly way to define a package and its associated 
    ///     services.
    /// </devdoc>
    public enum TaskPriority {
    	/// <include file='doc\TaskPriority.uex' path='docs/doc[@for="TaskPriority.High"]/*' />
    	High = VSTASKPRIORITY.TP_HIGH,
    	/// <include file='doc\TaskPriority.uex' path='docs/doc[@for="TaskPriority.Normal"]/*' />
    	Normal = VSTASKPRIORITY.TP_NORMAL,
    	/// <include file='doc\TaskPriority.uex' path='docs/doc[@for="TaskPriority.Low"]/*' />
    	Low = VSTASKPRIORITY.TP_LOW
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\TaskErrorCategory.cs ===
//------------------------------------------------------------------------------
// <copyright file="TaskErrorCategory.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell.Interop;
    using Microsoft.Win32;
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.IO;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Windows.Forms;

    using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
    using IServiceProvider = System.IServiceProvider;

    /// <include file='doc\TaskErrorCategory.uex' path='docs/doc[@for="TaskErrorCategory"]' />
    /// <devdoc>
    /// </devdoc>
    public enum TaskErrorCategory {
        /// <include file='doc\TaskErrorCategory.uex' path='docs/doc[@for="TaskErrorCategory.Error"]' />
        Error = __VSERRORCATEGORY.EC_ERROR,
        /// <include file='doc\TaskErrorCategory.uex' path='docs/doc[@for="TaskErrorCategory.Warning"]' />
        Warning = __VSERRORCATEGORY.EC_WARNING,
        /// <include file='doc\TaskErrorCategory.uex' path='docs/doc[@for="TaskErrorCategory.Message"]' />
        Message = __VSERRORCATEGORY.EC_MESSAGE
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\ToolWindowPane.cs ===
//------------------------------------------------------------------------------
// <copyright file="ToolWindowPane.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Diagnostics;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell.Interop;

using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
using IServiceProvider = System.IServiceProvider;

namespace Microsoft.VisualStudio.Shell
{
    /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane"]/*' />
    /// <summary>
    /// Summary description for ToolWindowPane.
    /// </summary>
    [System.Runtime.InteropServices.ComVisible(true)]
    public abstract class ToolWindowPane : WindowPane
    {
        private string caption;
        private IVsWindowFrame frame = null;
        private Microsoft.VisualStudio.Shell.Package package = null;
        private CommandID toolBarCommandID = null;
        private VSTWT_LOCATION toolBarLocation;
        private int bitmapResourceID;
        private int bitmapIndex;
        private Guid toolClsid;

        /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane.ToolWindowPane"]/*' />
        /// <summary>
        /// Constructor
        /// </summary>
        protected ToolWindowPane(IServiceProvider provider)
        :
        base(provider)
        {
            toolClsid = Guid.Empty;
            bitmapIndex = -1;
            bitmapResourceID = -1;
            toolBarLocation = VSTWT_LOCATION.VSTWT_TOP;
        }
    
        /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane.Caption"]/*' />
        /// <summary>
        /// Get or Set the text on the title bar of the ToolWindow
        /// </summary>
        /// <value></value>
        public string Caption
        {
            get { return caption; }
            set
            {
                caption = value;
                if (frame != null && caption != null)
                {
                    // Since the window is already created, set the coresponding property
                    int hr = NativeMethods.S_OK;
                    try {
                        hr = frame.SetProperty((int)__VSFPROPID.VSFPROPID_Caption, caption);
                    } catch (COMException e) {
                        hr = e.ErrorCode;
                    }
                    Debug.Assert(hr >= 0, "Failed to set caption on toolwindow");
                }
            }
        }

        /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane.Frame"]/*' />
        /// <summary>
        /// Get or Set the Frame (IvsWindowFrame) hosting the ToolWindow
        /// </summary>
        public object Frame
        {
            get { return frame; }
            set
            {
                frame = (IVsWindowFrame)value;
                // Fire the event to let any custom creation code run
                OnToolWindowCreated();
            }
        }

        /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane.Package"]/*' />
        /// <summary>
        /// Get or Set the Package (Microsoft.VisualStudio.Shell.Package) owning the ToolWindow.
        /// This should only be set by the base Package class when it creates the toolwindow.
        /// </summary>
        public object Package
        {
            get { return package; }
            set
            {
                if (frame != null || package != null)
                    throw new NotSupportedException(SR.GetString(SR.ToolWindow_PackageOnlySetByCreator));
                package = (Microsoft.VisualStudio.Shell.Package)value;
            }
        }

        /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane.ToolBar"]/*' />
        /// <summary>
        /// If the toolwindow has a ToolBar, it is described by this parameter.
        /// Otherwise this is null
        /// </summary>
        public CommandID ToolBar
        {
            get { return toolBarCommandID; }
            set
            {
                if (frame != null)
                    throw new Exception(SR.GetString(SR.ToolWindow_TooLateToAddToolbar));
                toolBarCommandID = value;
            }
        }

        /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane.ToolBarLocation"]/*' />
        /// <summary>
        /// Get or Set where the toolbar should be in the tool window (Up, down, left, right).
        /// This parameter is based on VSTWT_LOCATION
        /// </summary>
        public int ToolBarLocation
        {
            get { return (int)toolBarLocation; }
            set
            {
                if (frame != null)
                    throw new Exception(SR.GetString(SR.ToolWindow_TooLateToAddToolbar));
                toolBarLocation = (VSTWT_LOCATION)value;
            }
        }

        /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane.ToolClsid"]/*' />
        /// <summary>
        /// This is used to specify the CLSID of a tool that should be used for this toolwindow
        /// </summary>
        public Guid ToolClsid
        {
            get { return toolClsid; }
            set
            {
                if (frame != null)
                    throw new Exception(SR.GetString(SR.ToolWindow_TooLateToAddTool));
                toolClsid = value;
            }
        }

        /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane.BitmapResourceID"]/*' />
        /// <summary>
        /// Get or Set the resource ID for the bitmap strip from which to take the window frame icon
        /// </summary>
        public int BitmapResourceID
        {
            get { return bitmapResourceID; }
            set
            {
                bitmapResourceID = value;
                if (frame != null && bitmapResourceID != -1)
                {
                    int hr = NativeMethods.S_OK;
                    // Since the window is already created, set the coresponding property
                    try {
                        hr = frame.SetProperty((int)__VSFPROPID.VSFPROPID_BitmapResource, bitmapResourceID);
                    } catch (COMException e) {
                        hr = e.ErrorCode;
                    }
                    Debug.Assert(hr >= 0, "Failed to set bitmap resource on toolwindow");
                }
            }
        }

        /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane.BitmapIndex"]/*' />
        /// <summary>
        /// Get or Set the index of the image to use in the bitmap strip for the window frame icon
        /// </summary>
        public int BitmapIndex
        {
            get { return bitmapIndex; }
            set
            {
                bitmapIndex = value;
                if (frame != null && bitmapIndex != -1)
                {
                    int hr = NativeMethods.S_OK;
                    // Since the window is already created, set the coresponding property
                    try {
                        hr = frame.SetProperty((int)__VSFPROPID.VSFPROPID_BitmapIndex, bitmapIndex);
                    } catch (COMException e) {
                        hr = e.ErrorCode;
                    }
                    Debug.Assert(hr >= 0, "Failed to set bitmap index on toolwindow");
                }
            }
        }

        /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane.GetIVsWindowPane"]/*' />
        /// <summary>
        /// This method make it possible to provide an IVsWindowPane not derived from ToolWindowPane
        /// To support that scenario one would override this method and create their IVsWindowPane and
        /// return it.
        /// </summary>
        /// <returns>IVsWindowPane to be hosted in the toolwindow frame</returns>
        public virtual object GetIVsWindowPane()
        {
            return (IVsWindowPane)this;
        }

        /// <include file='doc\ToolWindowPane.uex' path='docs/doc[@for="ToolWindowPane.OnToolWindowCreated"]/*' />
        /// <summary>
        /// This method can be overriden by the derived class to execute
        /// any code that needs to run after the IVsWindowFrame is created.
        /// If the toolwindow has a toolbar with a combobox, it should make
        /// sure its command handler are set by the time they return from
        /// this method.
        /// This is called when someone set the Frame property.
        /// </summary>
        public virtual void OnToolWindowCreated()
        {
            Debug.Assert(frame != null, "Frame should be set before this method is called");

            // If any property were set, set them on the frame (setting our properties will take care of it)
            Caption = caption;
            BitmapResourceID = bitmapResourceID;
            BitmapIndex = bitmapIndex;
        }

        /// <summary>
        /// This should be overriden if you want to run code before the window is shown
        /// but after its toolbar is added.
        /// </summary>
        public virtual void OnToolBarAdded()
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\Task.cs ===
//------------------------------------------------------------------------------
// <copyright file="Task.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell.Interop;
    using Microsoft.Win32;
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.IO;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Windows.Forms;

    using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
    using IServiceProvider = System.IServiceProvider;

    /// <include file='doc\Task.uex' path='docs/doc[@for="Task"]' />
    /// <devdoc>
    ///     This class implements IVsTaskItem.  
    /// </devdoc>
    [ComVisible(true)]
    [CLSCompliant(false)]
    public class Task :

        IVsTaskItem,
        IVsProvideUserContext
    {
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.contextNameKeyword"]/*' />
        public const string contextNameKeyword = "Keyword";

        private TaskProvider owner;
        private bool canDelete;
        private bool checkedEditable;
        private bool priorityEditable;
        private bool textEditable;
        private TaskPriority priority;
        private TaskCategory category;
        private int          subCategoryIndex;
        private string       text; 
        private string       document;
        private string       caption;
        private string       helpKeyword;
        private int          line;
        private int          imageIndex;
        private int          column;
        private bool         isChecked;
        private IVsUserContext context = null;

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Task"]/*' />
        public Task() {
            priority = TaskPriority.Normal;
            subCategoryIndex = -1;
            // Initializing the imageIndex to -1 tells VS to not expect to get
            // an imageList from us either, and instead use the default images.
            // This fixes bug 172354.
            imageIndex = -1;
            line = -1;
            column = -1;
            text = string.Empty;
            helpKeyword = string.Empty;
            document = string.Empty;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Task1"]/*' />
        public Task(Exception error) : this() {
    
            // Now use the exception to fill in the 
            // task data.
            if (error == null) {
                throw new ArgumentNullException("error");
            }

            Text = error.Message;
            HelpKeyword = error.HelpLink;

            if (Text.Length == 0) {
                Text = error.ToString();
            }

            // UNDONE: How do we generate this info for non-code thingies?  This must be
            // generic, or at least extensible.

            while(error != null) {
                System.ComponentModel.Design.Serialization.CodeDomSerializerException cdex;
                System.Xml.XmlException xmlex;
                 
                if ((cdex = error as System.ComponentModel.Design.Serialization.CodeDomSerializerException) != null) {
                    System.CodeDom.CodeLinePragma lp = cdex.LinePragma;
                    if (lp != null) {
                        Document = lp.FileName;
                        Line = lp.LineNumber;
                    }
                    break;
                }
                else if ((xmlex = error as System.Xml.XmlException) != null) {
                    Line = xmlex.LineNumber - 1;
                    break;
                }
                error = error.InnerException;
            }
        }


        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.CanDelete"]/*' />
        public bool CanDelete {
            get {
                return canDelete;
            }
            set {
                if (canDelete != value) {
                    canDelete = value;
                    UpdateOwner();
                }
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Category"]/*' />
        public TaskCategory Category {
            get {
                return category; 
            }
            set {
                if (category != value) {
                    category = value;
                    UpdateOwner();
                }
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Checked"]/*' />
        public bool Checked {
            get {
                return isChecked;
            }
            set {
                if (isChecked != value) {
                    isChecked = value;
                    UpdateOwner();
                }
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Column"]/*' />
        public int Column {
            get {
                return column;
            }
            set {
                if (column != value) {
                    column = value;
                    UpdateOwner();
                }
            }
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Document"]/*' />
        public string Document { 
            get {
                return document;
            }
            set {
                if (value == null) {
                    value = string.Empty;
                }
                if (document != value) {
                    document = value;
                    UpdateOwner();
                }
            }
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.HelpKeyword"]/*' />
        public string HelpKeyword {
            get {
                return helpKeyword;
            }
            set {
                if (value == null) {
                    value = string.Empty;
                }

                if (helpKeyword != value) {
                    helpKeyword = value;
                    UpdateOwner();
                }
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.ImageIndex"]/*' />
        public int ImageIndex {
            get {
                return imageIndex;
            }
            set {
                if (imageIndex != value) {
                    imageIndex = value;
                    UpdateOwner();
                }
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IsCheckedEditable"]/*' />
        public bool IsCheckedEditable {
            get {
                return checkedEditable;
            }
            set {
                if (checkedEditable != value) {
                    checkedEditable = value;
                    UpdateOwner();
                }
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IsPriorityEditable"]/*' />
        public bool IsPriorityEditable {
            get {
                return priorityEditable;
            }
            set {
                if (priorityEditable != value) {
                    priorityEditable = value;
                    UpdateOwner();
                }
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IsTextEditable"]/*' />
        public bool IsTextEditable {
            get {
                return textEditable;
            }
            set {
                if (textEditable != value) {
                    textEditable = value;
                    UpdateOwner();
                }
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Line"]/*' />
        public int Line {
            get {
                return line;
            }
            set {
                if (line != value) {
                    line = value;
                    UpdateOwner();
                }
            }
        }

        internal TaskProvider Owner {
            get {
                return owner;
            }
            set {
                if (owner != null && value == null) {
                    OnRemoved(EventArgs.Empty);
                }
                owner = value;
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Priority"]/*' />
        public TaskPriority Priority {
            get {
                return priority;
            }
            set {
                if (priority != value) {
                    priority = value;
                    UpdateOwner();
                }
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.SubcategoryIndex"]/*' />
        public int SubcategoryIndex {
            get {
                return subCategoryIndex;
            }
            set {
                if (subCategoryIndex != value) {
                    subCategoryIndex = value;
                    UpdateOwner();
                }
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Text"]/*' />
        public string Text {
            get {
                return text;
            }
            set {
                if (value == null) {
                    value = string.Empty;
                }
                if (text != value) {
                    text = value;
                    UpdateOwner();
                }
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Deleted"]/*' />
        public event EventHandler Deleted;

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Removed"]/*' />
        public event EventHandler Removed;
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Help"]/*' />
        public event EventHandler Help;
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.Navigate"]/*' />
        public event EventHandler Navigate;
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.OnDeleted"]/*' />
        protected virtual void OnDeleted(EventArgs e) {
            if (Deleted != null) {
                Deleted(this, e);
            }
        }
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.OnRemoved"]/*' />
        protected virtual void OnRemoved(EventArgs e) {
            if (Removed != null) {
                Removed(this, e);
            }
        }        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.OnHelp"]/*' />
        protected virtual void OnHelp(EventArgs e) {

            if (HelpKeyword.Length > 0 && owner != null) {
                IHelpService help = owner.GetService(typeof(IHelpService)) as IHelpService;
                Debug.Assert(help != null, "We can't find a help service in the service provider");
                if (help != null) {
                    help.ShowHelpFromKeyword(HelpKeyword);
                }
            }

            if (Help != null) {
                Help(this, e);
            }
        }
        
        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.OnNavigate"]/*' />
        protected virtual void OnNavigate(EventArgs e) {
            if (Navigate != null) {
                Navigate(this, e);
            }
        }

        private void UpdateOwner() {
            if (owner != null) {
                owner.Refresh();
            }
        }

        private string GetDisplayName(string fileName) {
            if (owner != null) {
            IVsRunningDocumentTable pRDT = (IVsRunningDocumentTable)owner.GetService(typeof(SVsRunningDocumentTable));
            if (pRDT != null) {
                IntPtr punkDocData;
                uint docCookie;
                uint[] pitemid = new uint[1];
                IVsHierarchy ppIVsHierarchy;
                int hr = pRDT.FindAndLockDocument((uint)_VSRDTFLAGS.RDT_NoLock, fileName, out ppIVsHierarchy, out pitemid[0], out punkDocData, out docCookie);
                if (NativeMethods.Succeeded(hr) && punkDocData != IntPtr.Zero && ppIVsHierarchy != null)
                {
                    Marshal.Release(punkDocData);
                    object isNew;
                    hr = ppIVsHierarchy.GetProperty(pitemid[0], (int)__VSHPROPID.VSHPROPID_IsNewUnsavedItem, out isNew);
                    if (NativeMethods.Succeeded(hr) && (bool)isNew) {
                        object fileCaption;
                        hr = ppIVsHierarchy.GetProperty(pitemid[0], (int)__VSHPROPID.VSHPROPID_Caption, out fileCaption);
                        string caption = fileCaption as string;
                        if (NativeMethods.Succeeded(hr) && !String.IsNullOrEmpty(caption))
                        {
                            return caption;
                        }
                    }
                }
            }
            }
            return fileName;
        }

        private string GetCaption() {
            if (caption == null) {
                caption = GetDisplayName(document);
            }
            return caption;
        }

        #region IVsTaskItem

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.CanDelete"]/*' />
        /// <internalonly/>
        int IVsTaskItem.CanDelete(out int fdelete) {
            fdelete = (CanDelete) ? 1 : 0;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.Category"]/*' />
        /// <internalonly/>
        int IVsTaskItem.Category(VSTASKCATEGORY[] cat) {
            if (cat != null) {
                cat[0] = (VSTASKCATEGORY)(uint)Category;
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.Column"]/*' />
        /// <internalonly/>
        int IVsTaskItem.Column(out int col) {
            col = Column;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.Document"]/*' />
        /// <internalonly/>
        int IVsTaskItem.Document(out string doc) {
            doc = GetCaption();
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.HasHelp"]/*' />
        /// <internalonly/>
        int IVsTaskItem.HasHelp(out int fHelp) {
            fHelp = (Help != null || (HelpKeyword != null && owner!=null)) ? 1 : 0;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.ImageListIndex"]/*' />
        /// <internalonly/>
        int IVsTaskItem.ImageListIndex(out int index) {
            index = ImageIndex;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.IsReadOnly"]/*' />
        /// <internalonly/>
        int IVsTaskItem.IsReadOnly(VSTASKFIELD field, out int fReadOnly) {

            bool readOnly = true;

            switch(field) {
                case VSTASKFIELD.FLD_CHECKED:
                    readOnly = !IsCheckedEditable;
                    break;
                case VSTASKFIELD.FLD_PRIORITY:
                    readOnly = !IsPriorityEditable;
                    break;
                case VSTASKFIELD.FLD_DESCRIPTION:
                    readOnly = !IsTextEditable;
                    break;
            }

            fReadOnly = (readOnly) ? 1 : 0;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.Line"]/*' />
        /// <internalonly/>
        int IVsTaskItem.Line(out int line) {
            line = Line;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.NavigateTo"]/*' />
        /// <internalonly/>
        int IVsTaskItem.NavigateTo() {
            OnNavigate(EventArgs.Empty);
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.NavigateToHelp"]/*' />
        /// <internalonly/>
        int IVsTaskItem.NavigateToHelp() {
            OnHelp(EventArgs.Empty);
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.OnDeleteTask"]/*' />
        /// <internalonly/>
        int IVsTaskItem.OnDeleteTask() {
            OnDeleted(EventArgs.Empty);
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.OnFilterTask"]/*' />
        /// <internalonly/>
        int IVsTaskItem.OnFilterTask(int f) {
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.SubcategoryIndex"]/*' />
        /// <internalonly/>
        int IVsTaskItem.SubcategoryIndex(out int index) {
            index = SubcategoryIndex;
            if ( index < 0 )
            {
                return NativeMethods.E_FAIL;
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.get_Checked"]/*' />
        /// <internalonly/>
        int IVsTaskItem.get_Checked(out int f) {
            f = Checked ? 1 : 0;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.get_Priority"]/*' />
        /// <internalonly/>
        int IVsTaskItem.get_Priority(VSTASKPRIORITY[] pri) {
            if (pri != null) {
                pri[0] = (VSTASKPRIORITY)(uint)Priority;
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.get_Text"]/*' />
        /// <internalonly/>
        int IVsTaskItem.get_Text(out string text) {
            text = Text;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.put_Checked"]/*' />
        /// <internalonly/>
        int IVsTaskItem.put_Checked(int f) {
            isChecked = f != 0;  // don't call property, as it will call back to the task list
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.put_Priority"]/*' />
        /// <internalonly/>
        int IVsTaskItem.put_Priority(VSTASKPRIORITY pri) {
            priority = (TaskPriority)(uint)pri;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsTaskItem.put_Text"]/*' />
        /// <internalonly/>
        int IVsTaskItem.put_Text(string t) {
            text = t;
            return NativeMethods.S_OK;
        }
        #endregion

        #region IVsProvideUserContext Members

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.GetUserContext"]/*' />
        public int GetUserContext(out IVsUserContext ppctx)
        {
            int hr = NativeMethods.S_OK;
            if (context == null)
            {
                // Create an empty context
                IVsMonitorUserContext monitorContext = owner.GetService(typeof(SVsMonitorUserContext)) as IVsMonitorUserContext;
                NativeMethods.ThrowOnFailure(monitorContext.CreateEmptyContext(out context));

                // Add the required information to the context
                hr = context.AddAttribute(VSUSERCONTEXTATTRIBUTEUSAGE.VSUC_Usage_LookupF1, contextNameKeyword, this.HelpKeyword);
            }
            ppctx = context;

            return hr;
        }

        #endregion
    }


    /// <include file='doc\Task.uex' path='docs/doc[@for="ErrorTask"]' />
    /// <devdoc>
    ///     This class implements IVsErrorItem.  
    /// </devdoc>
    [CLSCompliant(false)]
    [System.Runtime.InteropServices.ComVisible(true)]
    public class ErrorTask : Task, IVsErrorItem {

        IVsHierarchy        item;
        TaskErrorCategory   category;

        /// <include file='doc\Task.uex' path='docs/doc[@for="ErrorTask.ErrorTask"]/*' />
        public ErrorTask() {
            category = TaskErrorCategory.Error;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="ErrorTask.ErrorTask1"]/*' />
        public ErrorTask(Exception error) : base(error) {
        }

        /// Get/Set the error category associated with this task.
        public TaskErrorCategory ErrorCategory {
            get {
                return category;
            }
            set {
                category = value;
            }
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="ErrorTask.Project"]/*' />
        /// Get/Set the hierarchy item associated with this task.
        public IVsHierarchy HierarchyItem {
            get { return this.item; }
            set { this.item = value; }
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsErrorItem.GetProject"]/*' />
        /// todo: This method will soon switch to out IVsHierarchy ppProject
        int IVsErrorItem.GetHierarchy(out IVsHierarchy ppHier) {
            ppHier = this.item;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\Task.uex' path='docs/doc[@for="Task.IVsErrorItem.GetCategory"]/*' />
        int IVsErrorItem.GetCategory(out uint pCategory) {
            pCategory = (uint)ErrorCategory;
            return NativeMethods.S_OK;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\ServiceProviderHierarchy.cs ===
//------------------------------------------------------------------------------
// <copyright file="ServiceProviderHierarchy.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Collections.Generic;

    /// <include file='doc\ServiceProviderHierarchy.uex' path='docs/doc[@for="ServiceProviderHierarchy"]' />
    /// <devdoc>
    ///     This class acts as a hierarchical service provider.  It stores IServiceProviders in a sorted dictionary
    ///     for an ordered retrieval.  When GetService is called to retrieve a service, the service providers are queried
    ///     in a specific order.  This is useful when multiple service providers are combined such as in 
    ///     the WindowPane implementation
    /// </devdoc>
    [CLSCompliant(false)]
    public sealed class ServiceProviderHierarchy : SortedList<int, IServiceProvider>, IServiceProvider {
        
        /// <include file='doc\ServiceProviderHierarchy.uex' path='docs/doc[@for="ServiceProviderHierarchy.GetService"]' />
        /// <devdoc>
        ///     Retrieves the requested service by walking the hierarchy of service providers.
        /// </devdoc>
        public object GetService(Type serviceType) {
            
            if (serviceType == null) {
                throw new ArgumentNullException("serviceType");
            }

            object service = null;

            if (serviceType == typeof(ServiceProviderHierarchy)) {
                service = this;
            }
            else {
                foreach(IServiceProvider provider in Values) {
                    service = provider.GetService(serviceType);
                    if (service != null) {
                        break;
                    }
                }
            }

            return service;
        }
    }

    /// <include file='doc\ServiceProviderHierarchyOrder.uex' path='docs/doc[@for="ServiceProviderHierarchyOrder"]' />
    /// <devdoc>
    ///     When multiple service providers are combined in a service provider hierarchy they 
    ///     are ordered according to a numeric ordering.  This class provides recommended service
    ///     resolution order for common service providers.
    /// </devdoc>
    public sealed class ServiceProviderHierarchyOrder {
        /// <include file='doc\ServiceProviderHierarchy.uex' path='docs/doc[@for="ServiceProviderHierarchyOrder.PackageSite"]/*' />
        public const int PackageSite = 100;
        /// <include file='doc\ServiceProviderHierarchy.uex' path='docs/doc[@for="ServiceProviderHierarchyOrder.WindowPaneSite"]/*' />
        public const int WindowPaneSite = 50;
        /// <include file='doc\ServiceProviderHierarchy.uex' path='docs/doc[@for="ServiceProviderHierarchyOrder.ProjectItemContext"]/*' />
        public const int ProjectItemContext = 25;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\Url.cs ===
//--------------------------------------------------------------------------
//  <copyright file="Url.cs" company="Microsoft">
//      Copyright (c) Microsoft Corporation.  All rights reserved.
//  </copyright>
//  <summary>
//  </summary>
//--------------------------------------------------------------------------
using System;
using System.Windows.Forms;
using System.Diagnostics;
using Microsoft.Win32;
using System.Globalization;
using System.IO;
using System.Collections;
using System.Xml;
using System.Text;
using System.Net;
using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
using IServiceProvider = System.IServiceProvider;
using ShellConstants = Microsoft.VisualStudio.Shell.Interop.Constants;
using OleConstants = Microsoft.VisualStudio.OLE.Interop.Constants;

namespace Microsoft.VisualStudio.Shell
{	
	/// <summary>
	/// This class wraps the Uri class and provides an unescaped "LocalPath" for file URL's
	/// and an unescaped AbsoluteUri for other schemes, plus it also returned an un-hex-escaped
	/// result from MakeRelative so it can be presented to the user.
	/// </summary>
	public class Url
	{
		private Uri uri = null;
		private bool isFile;
		private string cachedAbsUrl;

		
		public Url(string path)
		{
			Init(path);
		}
		
		void Init(string path)
		{
			// Must try absolute first, then fall back on relative, otherwise it
			// makes some absolute UNC paths like (\\lingw11\Web_test\) relative!
			if (path != null)
			{

				if (!Uri.TryCreate(path, UriKind.Absolute, out this.uri))
				{
					Uri.TryCreate(path, UriKind.Relative, out this.uri);
				} 
				
				this.CheckIsFile();
			}
		}

		void CheckIsFile()
		{
			this.isFile = false;
			if (this.uri != null)
			{
				if (this.uri.IsAbsoluteUri)
				{
					this.isFile = this.uri.IsFile;
				}
				else
				{
					string[] test1 = this.uri.OriginalString.Split('/');
					string[] test2 = this.uri.OriginalString.Split('\\');
					if (test1.Length < test2.Length)
					{
						this.isFile = true;
					}
				}
			}
		}

		// allows relpath to be null, in which case it just returns the baseUrl.
		
		public Url(Url baseUrl, string relpath)
		{
			if (baseUrl.uri == null || !baseUrl.uri.IsAbsoluteUri)
			{
				Init(relpath);
			}
			else if (string.IsNullOrEmpty(relpath))
			{
				this.uri = baseUrl.uri;
			}
			else
			{
				this.uri = new Uri(baseUrl.uri, relpath);
			}
			CheckIsFile();
		}
		
		
		public string AbsoluteUrl
		{
			get
			{
				if (this.uri == null) return null;
				if (cachedAbsUrl != null) return cachedAbsUrl;
				if (this.uri.IsAbsoluteUri)
				{
					if (this.isFile)
					{
						// Fix for build break. UriComponents.LocalPath is no longer available.
						// return uri.GetComponents(UriComponents.LocalPath, UriFormat.SafeUnescaped);
						cachedAbsUrl = uri.LocalPath;
					}
					else
					{
						cachedAbsUrl = uri.GetComponents(UriComponents.AbsoluteUri, UriFormat.SafeUnescaped);
					}
				}
				else
				{
					cachedAbsUrl = uri.OriginalString;
				}
			return cachedAbsUrl;
			}
		}

		
		/// <summary>Returns the AbsoluteUrl for the parent directory containing the file 
		/// referenced by this URL object, where the Directory string is also unescaped.</summary>
		public string Directory
		{
            get 
            {
                string path = this.AbsoluteUrl;
                if (path == null) return null;
                if (this.isFile) {
                    return Path.GetDirectoryName(path);
                }

                int i = path.LastIndexOf('/');
                int len = (i > 0) ? i : path.Length;
                return path.Substring(0, len);
            }
		}

		
		public bool IsFile
		{
			get { return this.isFile; }
		}

		
		public Url Move(Url oldBase, Url newBase)
		{
			if (this.uri == null || oldBase.uri == null) return null;
			string rel = oldBase.uri.MakeRelativeUri(this.uri).ToString();
			return new Url(newBase, rel);
		}

		// return an un-escaped relative path
		
		public string MakeRelative(Url url)
		{
			if (this.uri == null || url.uri == null) return null;
			if (this.uri.Scheme != url.uri.Scheme || this.uri.Host != url.uri.Host)
			{
				// Then it cannot be relatavized (e.g from file:// to http://).
				return url.AbsoluteUrl;
			}
			// This will return a hex-escaped string.
			string rel = this.uri.MakeRelativeUri(url.uri).ToString();

			// So unescape it.
			return Unescape(rel, this.isFile);
		}

		const char c_DummyChar = (char)0xFFFF;

		private static char EscapedAscii(char digit, char next)
		{
			// Only accept hexadecimal characters
			if (!(((digit >= '0') && (digit <= '9'))
				|| ((digit >= 'A') && (digit <= 'F'))
				|| ((digit >= 'a') && (digit <= 'f'))))
			{
				return c_DummyChar;
			}

			int res = 0;
			if (digit <= '9')
				res = (int)digit - (int)'0';
			else if (digit <= 'F')
				res = ((int)digit - (int)'A') + 10;
			else
				res = ((int)digit - (int)'a') + 10;

			// Only accept hexadecimal characters
			if (!(((next >= '0') && (next <= '9'))
				|| ((next >= 'A') && (next <= 'F'))
			   || ((next >= 'a') && (next <= 'f'))))
			{
				return c_DummyChar;
			}

			res = res << 4;
			if (next <= '9')
				res += (int)next - (int)'0';
			else if (digit <= 'F')
				res += ((int)next - (int)'A') + 10;
			else
				res += ((int)next - (int)'a') + 10;

			return (char)(res);
		}

		
		public static string Unescape(string escaped, bool isFile)
		{
			if (String.IsNullOrEmpty(escaped))
			{
				return String.Empty;
			}

			byte[] bytes = null;
			char[] dest = new char[escaped.Length];
			int j = 0;

			for (int i = 0, end = escaped.Length; i < end; i++)
			{
				char ch = escaped[i];
				if (ch != '%')
				{
					if (ch == '/' && isFile)
					{
						ch = Path.DirectorySeparatorChar;
					}
					dest[j++] = ch;
				}
				else
				{
					int byteCount = 0;
					// lazy initialization of max size, will reuse the array for next sequences
					if (bytes == null)
					{
						bytes = new byte[end - i];
					}

					do
					{
						// Check on exit criterion
						if ((ch = escaped[i]) != '%' || (end - i) < 3)
						{
							break;
						}
						// already made sure we have 3 characters in str
						ch = EscapedAscii(escaped[i + 1], escaped[i + 2]);
						if (ch == c_DummyChar)
						{
							//invalid hex sequence, we will out '%' character
							ch = '%';
							break;
						}
						else if (ch < '\x80')
						{
							// character is not part of a UTF-8 sequence
							i += 2;
							break;
						}
						else
						{
							//a UTF-8 sequence
							bytes[byteCount++] = (byte)ch;
							i += 3;
						}
					} while (i < end);

					if (byteCount != 0)
					{

						int charCount = Encoding.UTF8.GetCharCount(bytes, 0, byteCount);
						if (charCount != 0)
						{
							Encoding.UTF8.GetChars(bytes, 0, byteCount, dest, j);
							j += charCount;
						}
						else
						{
							// the encoded, high-ANSI characters are not UTF-8 encoded
							for (int k = 0; k < byteCount; ++k)
							{
								dest[j++] = (char)bytes[k];
							}
						}
					}
					if (i < end)
					{
						dest[j++] = ch;
					}
				}
			}
			return new string(dest, 0, j);
		}

		
		public Uri Uri
		{
			get { return this.uri; }
		}

		/// Return unescaped path up to (but not including) segment i.
		public string GetPartial(int i)
		{
            return GetPartial(0, i);
		}

        public string GetPartial(int i, int j) {
            string path = JoinSegments(i, j);
            if (i == 0)
                if (!this.isFile) {
                    // prepend "http://host/"
                    path = this.uri.Scheme + "://" + this.uri.Host + '/' + path;
                } else if (this.uri.IsAbsoluteUri && this.uri.IsUnc && this.AbsoluteUrl.StartsWith(@"\\", StringComparison.OrdinalIgnoreCase)) {
                    path = @"\\" + path;
                }
            return path;
        }

		
		/// Return unescaped relative path starting segment i.
		public string GetRemainder(int i)
		{
			return JoinSegments(i, -1);
		}
		
		// Unlike the Uri class, this ALWAYS succeeds, even on relative paths, and it
		// strips out the path separator characters
		public string[] Segments
		{
			get
			{
				if (this.uri == null)
					return null;
				string path = this.AbsoluteUrl;
				if (this.isFile)
				{
					if (path.EndsWith(@"\", StringComparison.OrdinalIgnoreCase))
					{
						path = path.Substring(0, path.Length - 1);
					}
					if (this.uri.IsAbsoluteUri && this.uri.IsUnc && path.StartsWith(@"\\", StringComparison.OrdinalIgnoreCase))
					{
						path = path.Substring(2);
					}
					return path.Split(Path.DirectorySeparatorChar);
				}
				else
				{
					// strip off "http://" and host name, since those are not part of the path.
					path = path.Substring(this.uri.Scheme.Length + 3 + this.uri.Host.Length + 1);
					if (path.EndsWith("/", StringComparison.OrdinalIgnoreCase))
						path = path.Substring(0, path.Length - 1);
					return path.Split('/');
				}
			}
		}

		public string JoinSegments(int i, int j)
		{
			if (i < 0)
				throw new ArgumentOutOfRangeException("i");

			StringBuilder sb = new StringBuilder();
			string[] segments = this.Segments;
			if (segments == null)
				return null;
			if (j < 0)
				j = segments.Length;
			int len = segments.Length;
			for (; i < j && i < len; i++)
			{
				if (sb.Length > 0)
					sb.Append(this.isFile ? Path.DirectorySeparatorChar : '/');
				string s = segments[i];
				sb.Append(s);
			}
			return Unescape(sb.ToString(), isFile);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\Flavor\Project.cs ===
/***************************************************************************
         Copyright (c) Microsoft Corporation, All rights reserved.             
    This code sample is provided "AS IS" without warranty of any kind, 
    it is not recommended for use in a production environment.
***************************************************************************/

namespace Microsoft.VisualStudio.Shell.Flavor
{
    using System;
    using System.Diagnostics;
    using System.Globalization;
    using System.Runtime.InteropServices;
    using Microsoft.VisualStudio.Shell.Interop;
    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell;

    /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject"]/*' />
    /// <devdoc>
    /// A project that is a subtype/flavor of an inner project.
    /// The default behavior of all methods is to delegate to the
    /// inner project. For any behavior you want to change, simply
    /// handle the request yourself.
    /// </devdoc>
    [CLSCompliant(false)]
    public abstract class FlavoredProject : 
        Microsoft.VisualStudio.ProjectAggregator.CProjectAggregatorClass, // Provide aggregation support
        IVsAggregatableProject,
        System.IServiceProvider,
        IVsHierarchy,
        IVsUIHierarchy,
        IOleCommandTarget,
        IVsTrackProjectDocumentsEvents2
    {
        // Keep interface reference for all interface we override

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.innerVsAggregatableProject"]/*' />
        protected IVsAggregatableProject innerVsAggregatableProject;
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.innerVsHierarchy"]/*' />
        protected IVsHierarchy innerVsHierarchy;
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.innerVsUIHierarchy"]/*' />
        protected IVsUIHierarchy innerVsUIHierarchy;
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.innerOleCommandTarget"]/*' />
        protected IOleCommandTarget innerOleCommandTarget;

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.serviceProvider"]/*' />
        protected System.IServiceProvider serviceProvider;

        private OleMenuCommandService menuService;

        uint cookie = 0;

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.FlavoredProject"]/*' />
        public FlavoredProject()
        {
        }

        #region IVsAggregatableProject

        /// <devdoc>
        /// This is were all QI for interface on the inner object should happen
        /// Then set the inner project
        /// wait for InitializeForOuter to be called to do the real initialization
        /// </devdoc>
        int IVsAggregatableProject.SetInnerProject(object inner)
        {
            // delegate to the protected method
            this.SetInnerProject(inner);

            return NativeMethods.S_OK;
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.SetInnerProject"]/*' />
        /// <devdoc>
        /// This is were all QI for interface on the inner object should happen
        /// Then set the inner project
        /// wait for InitializeForOuter to be called to do the real initialization
        /// </devdoc>
        protected virtual void SetInnerProject(object inner)
        {
            // Keep a reference to each interface we want to call on the inner project
            // we must do it now as once we call SetInner the AddRef would be forwarded to ourselves
            innerVsAggregatableProject = (IVsAggregatableProject)inner;
            innerVsHierarchy = (IVsHierarchy)inner;
            innerVsUIHierarchy = (IVsUIHierarchy)inner;
            // As should return null without throwing in the event the base project does not implement the interface
            innerOleCommandTarget = inner as IOleCommandTarget;

            // Setup our menu command service
            if (this.serviceProvider == null)
                throw new NotSupportedException("serviceProvider should have been set before SetInnerProject gets called.");
            menuService = new OleMenuCommandService(this, innerOleCommandTarget);

            // Aggregate the project
            this.SetInner(inner);
        }

        /// <devdoc>
        /// Do the initialization here (such as loading flavor specific
        /// information from the project)
        /// </devdoc>
        int IVsAggregatableProject.InitializeForOuter(string fileName, string location, string name,
            uint flags, ref Guid guidProject, out IntPtr project, out int canceled)
        {
            if (innerVsAggregatableProject == null || guidProject != NativeMethods.IID_IUnknown)
                throw new NotSupportedException();

            Marshal.QueryInterface(Marshal.GetIUnknownForObject(this), ref guidProject, out project);

            canceled = 0;
            bool cancel;
            this.InitializeForOuter(fileName, location, name, flags, ref guidProject, out cancel);
            if (cancel)
                canceled = 1;

            return NativeMethods.S_OK;
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.InitializeForOuter"]/*' />
        /// <devdoc>
        /// Allow the project to initialize itself.
        /// At this point it possible to call the inner project
        /// Also allow canceling the project creation
        /// </devdoc>
        /// <returns>Return true to cancel the project creation</returns>
        protected virtual void InitializeForOuter(string fileName, string location, string name, uint flags, ref Guid guidProject, out bool cancel)
        {
            cancel = false;
        }
        /// <devdoc>
        /// This is called when all object in aggregation have received InitializeForOuter calls.
        /// At this point the aggregation is complete and fully functional.
        /// </devdoc>
        int IVsAggregatableProject.OnAggregationComplete()
        {
            this.OnAggregationComplete();
            if (innerVsAggregatableProject != null)
                return innerVsAggregatableProject.OnAggregationComplete();
            return NativeMethods.S_OK;
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.OnAggregationComplete"]/*' />
        /// <devdoc>
        /// This is called when all object in aggregation have received InitializeForOuter calls.
        /// At this point the aggregation is complete and fully functional.
        /// </devdoc>
        protected virtual void OnAggregationComplete()
        {
            // This will subscribe to the IVsTrackProjectDocumentsEvents.
            // This is not required to flavor a project but makes it easier for derived class
            // to subscribe to these events.
            IVsTrackProjectDocuments2 trackDocuments = GetTrackProjectDocuments();
            ErrorHandler.ThrowOnFailure(trackDocuments.AdviseTrackProjectDocumentsEvents(this, out cookie));
        }

        /// <devdoc>
        /// This must be delegetated to the inner most project
        /// </devdoc>
        int IVsAggregatableProject.SetAggregateProjectTypeGuids(string projectTypeGuids)
        {
            if (innerVsAggregatableProject == null)
                throw new NotSupportedException();

            return innerVsAggregatableProject.SetAggregateProjectTypeGuids(projectTypeGuids);
        }

        /// <devdoc>
        /// This must be delegetated to the inner most project
        /// </devdoc>
        int IVsAggregatableProject.GetAggregateProjectTypeGuids(out string projectTypeGuids)
        {
            if (innerVsAggregatableProject == null)
                throw new NotSupportedException();

            return innerVsAggregatableProject.GetAggregateProjectTypeGuids(out projectTypeGuids);
        }

        #endregion

        #region IVsHierarchy
        //
        // Most methods call protected virtual methods which delegate to the inner project.
        // Derived classes should override those protected method if they want to change the
        // behavior.
        //

        int IVsHierarchy.AdviseHierarchyEvents(Microsoft.VisualStudio.Shell.Interop.IVsHierarchyEvents eventSink, out uint cookie)
        {
            cookie = this.AdviseHierarchyEvents(eventSink);
            return NativeMethods.S_OK;
        }

        int IVsHierarchy.Close()
        {
            if (cookie != 0)
            {
                // Unsubscribe to events
                IVsTrackProjectDocuments2 trackDocuments = GetTrackProjectDocuments();
                Debug.Assert(ErrorHandler.Succeeded(trackDocuments.UnadviseTrackProjectDocumentsEvents(cookie)), "Failed to UnadviseTrackProjectDocumentsEvents");
                cookie = 0;
            }
            this.Close();
            return NativeMethods.S_OK;
        }

        int IVsHierarchy.GetCanonicalName(uint itemId, out string name)
        {
            return this.GetCanonicalName(itemId, out name);
        }

        int IVsHierarchy.GetGuidProperty(uint itemId, int propId, out System.Guid guid)
        {
            guid = this.GetGuidProperty(itemId, propId);
            return NativeMethods.S_OK;
        }

        int IVsHierarchy.GetNestedHierarchy(uint itemId, ref System.Guid guidHierarchyNested, out System.IntPtr hierarchyNested, out uint itemIdNested)
        {
            return this.GetNestedHierarchy(itemId, ref guidHierarchyNested, out hierarchyNested, out itemIdNested);
        }

        int IVsHierarchy.GetProperty(uint itemId, int propId, out System.Object property)
        {
            // While other methods expect the protected method to throw, for GetProperty
            // we break this pattern as it is called much more often and it is legitimate to
            // return not implemented. Therefore it can help perf and debugging experience
            return this.GetProperty(itemId, propId, out property);
        }

        int IVsHierarchy.GetSite(out Microsoft.VisualStudio.OLE.Interop.IServiceProvider serviceProvider)
        {
            serviceProvider = this.GetSite();
            return NativeMethods.S_OK;
        }

        int IVsHierarchy.ParseCanonicalName(string name, out uint itemId)
        {
            return this.ParseCanonicalName(name, out itemId);
        }

        int IVsHierarchy.QueryClose(out int canClose)
        {
            canClose = 0;
            if (this.QueryClose())
                canClose = 1;
            return NativeMethods.S_OK;
        }

        int IVsHierarchy.SetGuidProperty(uint itemId, int propId, ref System.Guid guid)
        {
            this.SetGuidProperty(itemId, propId, ref guid);
            return NativeMethods.S_OK;
        }

        int IVsHierarchy.SetSite(Microsoft.VisualStudio.OLE.Interop.IServiceProvider serviceProvider)
        {
            this.serviceProvider = (System.IServiceProvider)new ServiceProvider(serviceProvider);
            NativeMethods.ThrowOnFailure(innerVsHierarchy.SetSite(serviceProvider));
            return NativeMethods.S_OK;
        }

        int IVsHierarchy.UnadviseHierarchyEvents(uint cookie)
        {
            this.UnadviseHierarchyEvents(cookie);
            return NativeMethods.S_OK;
        }

        int IVsHierarchy.SetProperty(uint itemId, int propId, System.Object property)
        {
            return this.SetProperty(itemId, propId, property);
        }

        int IVsHierarchy.Unused0()
        {
            this.Unused0();
            return NativeMethods.S_OK;
        }

        int IVsHierarchy.Unused1()
        {
            this.Unused1();
            return NativeMethods.S_OK;
        }

        int IVsHierarchy.Unused2()
        {
            this.Unused2();
            return NativeMethods.S_OK;
        }

        int IVsHierarchy.Unused3()
        {
            this.Unused3();
            return NativeMethods.S_OK;
        }

        int IVsHierarchy.Unused4()
        {
            this.Unused4();
            return NativeMethods.S_OK;
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.AdviseHierarchyEvents"]/*' />
        protected virtual uint AdviseHierarchyEvents(Microsoft.VisualStudio.Shell.Interop.IVsHierarchyEvents eventSink)
        {
            uint cookie=0;
            NativeMethods.ThrowOnFailure(innerVsHierarchy.AdviseHierarchyEvents(eventSink, out cookie));
            return cookie;
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.Close"]/*' />
        protected virtual void Close()
        {
            NativeMethods.ThrowOnFailure(innerVsHierarchy.Close());
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.GetCanonicalName"]/*' />
        protected virtual int GetCanonicalName(uint itemId, out string name)
        {
            return innerVsHierarchy.GetCanonicalName(itemId, out name);
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.GetGuidProperty"]/*' />
        protected virtual Guid GetGuidProperty(uint itemId, int propId)
        {
            Guid property;
            NativeMethods.ThrowOnFailure(innerVsHierarchy.GetGuidProperty(itemId, propId, out property));
            return property;
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.GetNestedHierarchy"]/*' />
        protected virtual int GetNestedHierarchy(uint itemId, ref System.Guid guidHierarchyNested, out System.IntPtr hierarchyNested, out uint itemIdNested)
        {
            return innerVsHierarchy.GetNestedHierarchy(itemId, ref guidHierarchyNested, out hierarchyNested, out itemIdNested);
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.GetProperty"]/*' />
        protected virtual int GetProperty(uint itemId, int propId, out Object property)
        {
            return innerVsHierarchy.GetProperty(itemId, propId, out property);
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.GetSite"]/*' />
        protected virtual Microsoft.VisualStudio.OLE.Interop.IServiceProvider GetSite()
        {
            Microsoft.VisualStudio.OLE.Interop.IServiceProvider serviceProvider;
            NativeMethods.ThrowOnFailure(innerVsHierarchy.GetSite(out serviceProvider));
            return serviceProvider;
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.ParseCanonicalName"]/*' />
        protected virtual int ParseCanonicalName(string name, out uint itemId)
        {
            return innerVsHierarchy.ParseCanonicalName(name, out itemId);
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.QueryClose"]/*' />
        protected virtual bool QueryClose()
        {
            int canClose;
            NativeMethods.ThrowOnFailure(innerVsHierarchy.QueryClose(out canClose));
            return (canClose != 0);
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.SetGuidProperty"]/*' />
        protected virtual void SetGuidProperty(uint itemId, int propId, ref System.Guid guid)
        {
            NativeMethods.ThrowOnFailure(innerVsHierarchy.SetGuidProperty(itemId, propId, ref guid));
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.UnadviseHierarchyEvents"]/*' />
        protected virtual void UnadviseHierarchyEvents(uint cookie)
        {
            NativeMethods.ThrowOnFailure(innerVsHierarchy.UnadviseHierarchyEvents(cookie));
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.SetProperty"]/*' />
        protected virtual int SetProperty(uint itemId, int propId, System.Object property)
        {
            return innerVsHierarchy.SetProperty(itemId, propId, property);
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.Unused0"]/*' />
        protected virtual void Unused0()
        {
            NativeMethods.ThrowOnFailure(innerVsHierarchy.Unused0());
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.Unused1"]/*' />
        protected virtual void Unused1()
        {
            NativeMethods.ThrowOnFailure(innerVsHierarchy.Unused1());
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.Unused2"]/*' />
        protected virtual void Unused2()
        {
            NativeMethods.ThrowOnFailure(innerVsHierarchy.Unused2());
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.Unused3"]/*' />
        protected virtual void Unused3()
        {
            NativeMethods.ThrowOnFailure(innerVsHierarchy.Unused3());
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.Unused4"]/*' />
        protected virtual void Unused4()
        {
            NativeMethods.ThrowOnFailure(innerVsHierarchy.Unused4());
        }
        #endregion

        #region IVsUIHierarchy Members
        //
        // All methods (except for QueryStatusCommand and ExecCommand) call the IVsHierarchy implementation.
        // QueryStatusCommand and ExecCommand call a protected virtual method that the base class can override.
        // Note that we QI for IVsUIHierarchy on this so that if we are flavored we call the outer IVsHierarchy.
        //

        int IVsUIHierarchy.QueryStatusCommand(uint itemid, ref Guid pguidCmdGroup, uint cCmds, OLECMD[] prgCmds, IntPtr pCmdText)
        {
            return this.QueryStatusCommand(itemid, ref pguidCmdGroup, cCmds, prgCmds, pCmdText);
        }
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.QueryStatusCommand"]/*' />
        protected virtual int QueryStatusCommand(uint itemid, ref Guid pguidCmdGroup, uint cCmds, OLECMD[] prgCmds, IntPtr pCmdText)
        {
            return innerVsUIHierarchy.QueryStatusCommand(itemid, ref pguidCmdGroup, cCmds, prgCmds, pCmdText);
        }

        int IVsUIHierarchy.ExecCommand(uint itemid, ref Guid pguidCmdGroup, uint nCmdID, uint nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
        {
            return this.ExecCommand(itemid, ref pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut);
        }
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.ExecCommand"]/*' />
        protected virtual int ExecCommand(uint itemid, ref Guid pguidCmdGroup, uint nCmdID, uint nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
        {
            return innerVsUIHierarchy.ExecCommand(itemid, ref pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut);
        }



        int IVsUIHierarchy.AdviseHierarchyEvents(IVsHierarchyEvents pEventSink, out uint pdwCookie)
        {
            return ((IVsHierarchy)this).AdviseHierarchyEvents(pEventSink, out pdwCookie);
        }

        int IVsUIHierarchy.Close()
        {
            return ((IVsHierarchy)this).Close();
        }

        int IVsUIHierarchy.GetCanonicalName(uint itemid, out string pbstrName)
        {
            return ((IVsHierarchy)this).GetCanonicalName(itemid, out pbstrName);
        }

        int IVsUIHierarchy.GetGuidProperty(uint itemid, int propid, out Guid pguid)
        {
            return ((IVsHierarchy)this).GetGuidProperty(itemid, propid, out pguid);
        }

        int IVsUIHierarchy.GetNestedHierarchy(uint itemid, ref Guid iidHierarchyNested, out IntPtr ppHierarchyNested, out uint pitemidNested)
        {
            return ((IVsHierarchy)this).GetNestedHierarchy(itemid, ref iidHierarchyNested, out ppHierarchyNested, out pitemidNested);
        }

        int IVsUIHierarchy.GetProperty(uint itemid, int propid, out object pvar)
        {
            return ((IVsHierarchy)this).GetProperty(itemid, propid, out pvar);
        }

        int IVsUIHierarchy.GetSite(out Microsoft.VisualStudio.OLE.Interop.IServiceProvider ppSP)
        {
            return ((IVsHierarchy)this).GetSite(out ppSP);
        }

        int IVsUIHierarchy.ParseCanonicalName(string pszName, out uint pitemid)
        {
            return ((IVsHierarchy)this).ParseCanonicalName(pszName, out pitemid);
        }

        int IVsUIHierarchy.QueryClose(out int pfCanClose)
        {
            return ((IVsHierarchy)this).QueryClose(out pfCanClose);
        }

        int IVsUIHierarchy.SetGuidProperty(uint itemid, int propid, ref Guid rguid)
        {
            return ((IVsHierarchy)this).SetGuidProperty(itemid, propid, ref rguid);
        }

        int IVsUIHierarchy.SetProperty(uint itemid, int propid, object var)
        {
            return ((IVsHierarchy)this).SetProperty(itemid, propid, var);
        }

        int IVsUIHierarchy.SetSite(Microsoft.VisualStudio.OLE.Interop.IServiceProvider psp)
        {
            return ((IVsHierarchy)this).SetSite(psp);
        }

        int IVsUIHierarchy.UnadviseHierarchyEvents(uint dwCookie)
        {
            return ((IVsHierarchy)this).UnadviseHierarchyEvents(dwCookie);
        }

        int IVsUIHierarchy.Unused0()
        {
            return ((IVsHierarchy)this).Unused0();
        }

        int IVsUIHierarchy.Unused1()
        {
            return ((IVsHierarchy)this).Unused1();
        }

        int IVsUIHierarchy.Unused2()
        {
            return ((IVsHierarchy)this).Unused2();
        }

        int IVsUIHierarchy.Unused3()
        {
            return ((IVsHierarchy)this).Unused3();
        }

        int IVsUIHierarchy.Unused4()
        {
            return ((IVsHierarchy)this).Unused4();
        }

        #endregion


        #region IOleCommandTarget Members

        int IOleCommandTarget.Exec(ref Guid pguidCmdGroup, uint nCmdID, uint nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
        {
            int hr = ((IOleCommandTarget)menuService).Exec(ref pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut);
            return hr;
        }

        int IOleCommandTarget.QueryStatus(ref Guid pguidCmdGroup, uint cCmds, OLECMD[] prgCmds, IntPtr pCmdText)
        {
            int hr = ((IOleCommandTarget)menuService).QueryStatus(ref pguidCmdGroup, cCmds, prgCmds, pCmdText);
            return hr;
        }

        #endregion

        #region IServiceProvider Members

        object System.IServiceProvider.GetService(Type serviceType)
        {
            if (serviceType == typeof(IOleCommandTarget))
                return ((IOleCommandTarget)menuService);
            else if (serviceType == typeof(System.ComponentModel.Design.IMenuCommandService))
                return ((System.ComponentModel.Design.IMenuCommandService)menuService);
            else 
                return this.serviceProvider.GetService(serviceType);

        }

        #endregion

        #region Events (subset of IVsTrackProjectDocumentsEvents)
        // This makes it easier for the derived class to subscribe to only the events it
        // is really interested in and get one event per file. This also filter events
        // and only send events that have to do with this project

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.EventHandler"]/*' />
        public delegate void EventHandler<ProjectDocumentsChangeEventArgs>(object sender, ProjectDocumentsChangeEventArgs e);

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.FileAdded"]/*' />
        /// <devdoc>
        /// Called after a file was added to this project.
        /// </devdoc>
        public event EventHandler<ProjectDocumentsChangeEventArgs> FileAdded;
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.FileRemoved"]/*' />
        /// <devdoc>
        /// Called after a file was remove from this project.
        /// </devdoc>
        public event EventHandler<ProjectDocumentsChangeEventArgs> FileRemoved;
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.FileRenamed"]/*' />
        /// <devdoc>
        /// Called after a file was renamed in this project.
        /// </devdoc>
        public event EventHandler<ProjectDocumentsChangeEventArgs> FileRenamed;

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.DirectoryAdded"]/*' />
        /// <devdoc>
        /// Called after a directory was added to this project.
        /// </devdoc>
        public event EventHandler<ProjectDocumentsChangeEventArgs> DirectoryAdded;
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.DirectoryRemoved"]/*' />
        /// <devdoc>
        /// Called after a directory was remove from this project.
        /// </devdoc>
        public event EventHandler<ProjectDocumentsChangeEventArgs> DirectoryRemoved;
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.DirectoryRenamed"]/*' />
        /// <devdoc>
        /// Called after a directory was renamed in this project.
        /// </devdoc>
        public event EventHandler<ProjectDocumentsChangeEventArgs> DirectoryRenamed;

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.SccStatusChanged"]/*' />
        /// <devdoc>
        /// Called after the source code control status of a file in this project changed.
        /// </devdoc>
        public event EventHandler<ProjectDocumentsChangeEventArgs> SccStatusChanged;
        #endregion

        #region IVsTrackProjectDocumentsEvents2 Members
        /// We subscribes to IVsTrackProjectDocumentsEvents and trigger the
        /// corresponding event once per file per event.
        /// We filters the events to only reports those related to our project.
        /// This is NOT required for flavoring, but simplify the work the
        /// derived classes have to do when subscribing to these events

        int IVsTrackProjectDocumentsEvents2.OnAfterAddDirectoriesEx(int cProjects, int cDirectories, IVsProject[] rgpProjects, int[] rgFirstIndices, string[] rgpszMkDocuments, VSADDDIRECTORYFLAGS[] rgFlags)
        {
            GenerateEvents(rgpProjects, rgFirstIndices, rgpszMkDocuments, DirectoryAdded, new ProjectDocumentsChangeEventArgs());
            return NativeMethods.S_OK;
        }

        int IVsTrackProjectDocumentsEvents2.OnAfterAddFilesEx(int cProjects, int cFiles, IVsProject[] rgpProjects, int[] rgFirstIndices, string[] rgpszMkDocuments, VSADDFILEFLAGS[] rgFlags)
        {
            GenerateEvents(rgpProjects, rgFirstIndices, rgpszMkDocuments, FileAdded, new ProjectDocumentsChangeEventArgs());
            return NativeMethods.S_OK;
        }

        int IVsTrackProjectDocumentsEvents2.OnAfterRemoveDirectories(int cProjects, int cDirectories, IVsProject[] rgpProjects, int[] rgFirstIndices, string[] rgpszMkDocuments, VSREMOVEDIRECTORYFLAGS[] rgFlags)
        {
            GenerateEvents(rgpProjects, rgFirstIndices, rgpszMkDocuments, DirectoryRemoved, new ProjectDocumentsChangeEventArgs());
            return NativeMethods.S_OK;
        }

        int IVsTrackProjectDocumentsEvents2.OnAfterRemoveFiles(int cProjects, int cFiles, IVsProject[] rgpProjects, int[] rgFirstIndices, string[] rgpszMkDocuments, VSREMOVEFILEFLAGS[] rgFlags)
        {
            GenerateEvents(rgpProjects, rgFirstIndices, rgpszMkDocuments, FileRemoved, new ProjectDocumentsChangeEventArgs());
            return NativeMethods.S_OK;
        }

        int IVsTrackProjectDocumentsEvents2.OnAfterRenameDirectories(int cProjects, int cDirs, IVsProject[] rgpProjects, int[] rgFirstIndices, string[] rgszMkOldNames, string[] rgszMkNewNames, VSRENAMEDIRECTORYFLAGS[] rgFlags)
        {
            GenerateEvents(rgpProjects, rgFirstIndices, rgszMkNewNames, DirectoryRenamed, new ProjectDocumentsChangeEventArgs());
            return NativeMethods.S_OK;
        }

        int IVsTrackProjectDocumentsEvents2.OnAfterRenameFiles(int cProjects, int cFiles, IVsProject[] rgpProjects, int[] rgFirstIndices, string[] rgszMkOldNames, string[] rgszMkNewNames, VSRENAMEFILEFLAGS[] rgFlags)
        {
            GenerateEvents(rgpProjects, rgFirstIndices, rgszMkNewNames, FileRenamed, new ProjectDocumentsChangeEventArgs());
            return NativeMethods.S_OK;
        }

        int IVsTrackProjectDocumentsEvents2.OnAfterSccStatusChanged(int cProjects, int cFiles, IVsProject[] rgpProjects, int[] rgFirstIndices, string[] rgpszMkDocuments, uint[] rgdwSccStatus)
        {
            GenerateEvents(rgpProjects, rgFirstIndices, rgpszMkDocuments, SccStatusChanged, new ProjectDocumentsChangeEventArgs());
            return NativeMethods.S_OK;
        }

        int IVsTrackProjectDocumentsEvents2.OnQueryAddDirectories(IVsProject pProject, int cDirectories, string[] rgpszMkDocuments, VSQUERYADDDIRECTORYFLAGS[] rgFlags, VSQUERYADDDIRECTORYRESULTS[] pSummaryResult, VSQUERYADDDIRECTORYRESULTS[] rgResults)
        {
            return NativeMethods.S_OK; // We are not interested in this one
        }

        int IVsTrackProjectDocumentsEvents2.OnQueryAddFiles(IVsProject pProject, int cFiles, string[] rgpszMkDocuments, VSQUERYADDFILEFLAGS[] rgFlags, VSQUERYADDFILERESULTS[] pSummaryResult, VSQUERYADDFILERESULTS[] rgResults)
        {
            return NativeMethods.S_OK; // We are not interested in this one
        }

        int IVsTrackProjectDocumentsEvents2.OnQueryRemoveDirectories(IVsProject pProject, int cDirectories, string[] rgpszMkDocuments, VSQUERYREMOVEDIRECTORYFLAGS[] rgFlags, VSQUERYREMOVEDIRECTORYRESULTS[] pSummaryResult, VSQUERYREMOVEDIRECTORYRESULTS[] rgResults)
        {
            return NativeMethods.S_OK; // We are not interested in this one
        }

        int IVsTrackProjectDocumentsEvents2.OnQueryRemoveFiles(IVsProject pProject, int cFiles, string[] rgpszMkDocuments, VSQUERYREMOVEFILEFLAGS[] rgFlags, VSQUERYREMOVEFILERESULTS[] pSummaryResult, VSQUERYREMOVEFILERESULTS[] rgResults)
        {
            return NativeMethods.S_OK; // We are not interested in this one
        }

        int IVsTrackProjectDocumentsEvents2.OnQueryRenameDirectories(IVsProject pProject, int cDirs, string[] rgszMkOldNames, string[] rgszMkNewNames, VSQUERYRENAMEDIRECTORYFLAGS[] rgFlags, VSQUERYRENAMEDIRECTORYRESULTS[] pSummaryResult, VSQUERYRENAMEDIRECTORYRESULTS[] rgResults)
        {
            return NativeMethods.S_OK; // We are not interested in this one
        }

        int IVsTrackProjectDocumentsEvents2.OnQueryRenameFiles(IVsProject pProject, int cFiles, string[] rgszMkOldNames, string[] rgszMkNewNames, VSQUERYRENAMEFILEFLAGS[] rgFlags, VSQUERYRENAMEFILERESULTS[] pSummaryResult, VSQUERYRENAMEFILERESULTS[] rgResults)
        {
            return NativeMethods.S_OK; // We are not interested in this one
        }

        #endregion

        #region Helpers for IVsTrackProjectDocumentsEvents2

        /// <devdoc>
        /// Used to subscribe/unsubscribe to those events
        /// </devdoc>
        private IVsTrackProjectDocuments2 GetTrackProjectDocuments()
        {
            IVsTrackProjectDocuments2 trackDocuments = ((System.IServiceProvider)this).GetService(typeof(SVsTrackProjectDocuments)) as IVsTrackProjectDocuments2;
            if (trackDocuments == null)
            {
                throw new ApplicationException(SR.GetString(SR.Flavor_FailedToGetService, "SVsTrackProjectDocuments"));
            }
            return trackDocuments;
        }

        /// <devdoc>
        /// Look at the list of projects and files and for each file that is part of this
        /// project, set the MkDocument on the event argument and trigger the event.
        /// </devdoc>
        private void GenerateEvents(
            IVsProject[] projects,
            int[] firstFiles,
            string[] mkDocuments,
            EventHandler<ProjectDocumentsChangeEventArgs> eventToGenerate,
            ProjectDocumentsChangeEventArgs e)
        {
            if (eventToGenerate == null)
                return; // no event = nothing to do

            if (projects == null || firstFiles == null || mkDocuments == null)
                throw new ArgumentNullException();
            if (projects.Length != firstFiles.Length)
                throw new ArgumentException();

            // First find out which range of the array (if any) include the files that belong to this project
            int first = -1;
            int last = mkDocuments.Length - 1; // default to the last document
            for (int i = 0; i < projects.Length; ++i)
            {
                if (first > -1)
                {
                    // We get here if there is 1 or more project(s) after ours in the list
                    last = firstFiles[i] - 1;
                    break;
                }
                if (Object.ReferenceEquals(projects[i], this))
                    first = firstFiles[i];
            }
            if (last >= mkDocuments.Length)
                throw new ArgumentException();
            // See if we have any documents
            if (first < 0)
                return; // Nothing that belongs to this project

            // For each file, generate the event
            for (int i = first; i <= last; ++i)
            {
                try
                {
                    e.MkDocument = mkDocuments[i];
                    eventToGenerate(this, e);
                }
                catch(Exception error)
                {
                    Debug.Fail(error.Message);
                }
            }
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\Utilities.cs ===
//--------------------------------------------------------------------------
//  <copyright file="utilities.cs" company="Microsoft">
//      Copyright (c) Microsoft Corporation.  All rights reserved.
//  </copyright>
//  <summary>
//  </summary>
//--------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using System.Diagnostics;
using System.ComponentModel;
using System.Globalization;
using System.IO;
using System.Collections;
using System.Xml;
using System.Text;
using System.Text.RegularExpressions;
using System.Net;
using System.Reflection;
using Microsoft.VisualStudio.TextManager.Interop;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.Designer.Interfaces;
using Microsoft.VisualStudio.Shell;
using Microsoft.Win32;
using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
using IServiceProvider = System.IServiceProvider;
using ShellConstants = Microsoft.VisualStudio.Shell.Interop.Constants;
using OleConstants = Microsoft.VisualStudio.OLE.Interop.Constants;

namespace Microsoft.VisualStudio.Shell
{


    /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities"]' />
    public static class PackageUtilities
	{

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.GetSystemAssemblyPath"]' />
        public static string GetSystemAssemblyPath()
		{
			return Path.GetDirectoryName(typeof(object).Assembly.Location);
#if SYSTEM_COMPILER 
      // To support true cross-platform compilation we really need to use
      // the System.Compiler.dll SystemTypes class which statically loads
      // mscorlib type information from "TargetPlatform" location.
      return Path.GetDirectoryName(SystemTypes.SystemAssembly.Location);
#endif

		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.EnsureOutputPath"]' />
        public static void EnsureOutputPath(string path)
		{
			if (!String.IsNullOrEmpty(path) && !Directory.Exists(path))
			{
				try
				{
					Directory.CreateDirectory(path);
				}
				catch (IOException e)
				{
					Trace.WriteLine("Exception : " + e.Message);
				}
				catch (UnauthorizedAccessException e)
				{
					Trace.WriteLine("Exception : " + e.Message);
				}
				catch (ArgumentException e)
				{
					Trace.WriteLine("Exception : " + e.Message);
				}
				catch (NotSupportedException e)
				{
					Trace.WriteLine("Exception : " + e.Message);
				}

			}
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.ContainsInvalidFileNameChars"]' />
        /// <devdoc>
		/// Returns true if thename that can represent a path, absolut or relative, or a file name contains invalid filename characters.
		/// </devdoc>
		/// <param name="name">File name</param>
		/// <returns>true if file name is invalid</returns>
		public static bool ContainsInvalidFileNameChars(string name)
		{
			if (String.IsNullOrEmpty(name))
			{
				return true;
			}

			if (Path.IsPathRooted(name))
			{
				string root = Path.GetPathRoot(name);
				name = name.Substring(root.Length);
			}

			Url uri = new Url(name);

			string[] segments = uri.Segments;
			if (segments != null)
			{
				foreach (string segment in segments)
				{
					if (IsFilePartInValid(segment))
					{
						return true;
					}
				}
			}
			else
			{
				return IsFilePartInValid(name);
			}

			return false;
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.IsFileNameInvalid"]' />
        /// <devdoc>
		/// Cehcks if a file name is valid.
		/// </devdoc>
		/// <param name="fileName">The name of the file</param>
		/// <returns>True if the file is valid.</returns>
		public static bool IsFileNameInvalid(string fileName)
		{
			if (String.IsNullOrEmpty(fileName))
			{
				return true;
			}

			if (IsFileNameAllGivenCharacter('.', fileName) || IsFileNameAllGivenCharacter(' ', fileName))
			{
				return true;
			}


			return IsFilePartInValid(fileName);

		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.CopyUrlToLocal"]' />
        ///<devdoc>
        /// Copy the specified file to the local project directory.  Also supports downloading
		/// of HTTP resources (so be prepared for a delay in that case!).
		/// </devdoc>
		public static  void CopyUrlToLocal(Uri uri, string local)
		{
			if (uri.IsFile)
			{
				// now copy file
				FileInfo fiOrg = new FileInfo(uri.LocalPath);
				FileInfo fiNew = fiOrg.CopyTo(local, true);
			}
			else
			{
				FileStream localFile = new FileStream(local, FileMode.OpenOrCreate, FileAccess.Write, FileShare.None);
				try
				{
					WebRequest wr = WebRequest.Create(uri);
					wr.Timeout = 10000;
					wr.Credentials = CredentialCache.DefaultCredentials;
					WebResponse resp = wr.GetResponse();
					Stream s = resp.GetResponseStream();
					byte[] buffer = new byte[10 * 1024];
					int len;
					while ((len = s.Read(buffer, 0, buffer.Length)) != 0)
					{
						localFile.Write(buffer, 0, len);
					}
				}
				finally
				{
					localFile.Close();
				}
			}
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.MakeRelativeIfRooted"]' />
        /// <devdoc>
		/// If this file is in the same folder the Url or below make it relative to the current Url
		/// </devdoc>
        /// <param name="fileName">filename (is rooted) to be transformed</param>
		/// <param name="url">the location to make the filename relative to</param>
		/// <returns>the relative path to the url or returns filename if not rooted</returns>
		public static string MakeRelativeIfRooted(string fileName, Url url)
		{
			string relativePath = fileName;
			if (Path.IsPathRooted(relativePath))
			{
				string path = new Url(relativePath).AbsoluteUrl;
				string basePath = url.AbsoluteUrl;
				if (path.StartsWith(basePath, StringComparison.OrdinalIgnoreCase))
				{
					relativePath = path.Substring(basePath.Length);
				}
			}
			return relativePath;
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.GetPathDistance"]' />
        /// <devdoc>
		/// Given two uris calculates the distance from the second path top the first one.
		/// </devdoc>
		/// <returns>The distance in path, if it can make it or the fullpath of the second uri if there if relative path does not make sense.</returns>
		public static string GetPathDistance(Uri uriBase, Uri uriRelativeTo)
		{
			string diff = String.Empty;

			if (uriRelativeTo != null && uriBase != null)
			{
				// MakeRelative only really works if on the same drive.
				if (uriRelativeTo.Segments.Length > 0 && uriBase.Segments.Length > 0 && String.Compare(uriRelativeTo.Segments[1], uriBase.Segments[1], StringComparison.OrdinalIgnoreCase) == 0)
				{
					Uri uriRelative = uriBase.MakeRelativeUri(uriRelativeTo);
					if (uriRelative != null)
					{
						diff = Url.Unescape(uriRelative.ToString(), true);
					}
				}
				else
				{
					diff = uriRelativeTo.LocalPath;
				}
			}

			return diff;
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.MakeRelative"]' />
        public static string MakeRelative(string filename, string filename2)
		{
			string[] parts = filename.Split(Path.DirectorySeparatorChar);
			string[] parts2 = filename2.Split(Path.DirectorySeparatorChar);

			if (parts.Length == 0 || parts2.Length == 0 || parts[0] != parts2[0])
			{
				return filename2; // completely different paths.
			}

			int i;

			for (i = 1; i < parts.Length && i < parts2.Length; i++)
			{
				if (parts[i] != parts2[i]) break;
			}

			StringBuilder sb = new StringBuilder();

			for (int j = i; j < parts.Length - 1; j++)
			{
				sb.Append("..");
				sb.Append(Path.DirectorySeparatorChar);
			}

			for (int j = i; j < parts2.Length; j++)
			{
				sb.Append(parts2[j]);
				if (j < parts2.Length - 1)
					sb.Append(Path.DirectorySeparatorChar);
			}

			return sb.ToString();
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.CreateCAUUIDFromGuidArray"]' />
        /// <devdoc>
		/// Creates a CAUUID from a guid array. Memory is allocated for the elems. 
		/// It is the responsability of the caller to release this memory.
		/// </devdoc>
		/// <param name="guids"></param>
		/// <returns></returns>
		[CLSCompliant(false)]
		public static CAUUID CreateCAUUIDFromGuidArray(Guid[] guids)
		{
			CAUUID cauuid = new CAUUID();

			if (guids != null)
			{
				cauuid.cElems = (uint)guids.Length;

				int size = Marshal.SizeOf(typeof(Guid));

				cauuid.pElems = Marshal.AllocCoTaskMem(guids.Length * size);

				IntPtr ptr = cauuid.pElems;

				for (int i = 0; i < guids.Length; i++)
				{
					Marshal.StructureToPtr(guids[i], ptr, false);
					ptr = new IntPtr(ptr.ToInt64() + size);
				}
			}

			return cauuid;
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.GetIntPointerFromImage"]' />
        public static int GetIntPointerFromImage(Image image)
		{
			Debug.Assert(image is Bitmap);
			Bitmap bitmap = image as Bitmap;
			if (bitmap != null)
			{
				IntPtr ptr = bitmap.GetHicon();
				// todo: this is not 64bit safe, but is a work around until whidbey bug 172595 is fixed.
				return ptr.ToInt32();
			}
			return 0;
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.GetImageList"]' />
        /// <devdoc>
		/// Creates an imagelist from resourcenames that are assumed to be icons.
		/// </devdoc>
		/// <param name="assembly"></param>
		/// <param name="resourceNames"></param>
		/// <returns></returns>
		public static ImageList GetImageList(Assembly assembly, string[] resourceNames)
		{
			if (resourceNames == null || resourceNames.Length == 0 || assembly == null)
			{
				return null;
			}

			ImageList ilist = new ImageList();
			ilist.ImageSize = new Size(16, 16);

			foreach (string imageName in resourceNames)
			{
				Stream stream = assembly.GetManifestResourceStream(imageName);
				if (stream != null)
				{
					Icon icon = new Icon(stream);
					ilist.Images.Add(icon.ToBitmap());
				}
			}

			return ilist;
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.GetImageList"]' />
        public static ImageList GetImageList(Stream imageStream)
		{
			ImageList ilist = new ImageList();

			if (imageStream == null)
			{
				return ilist;
			}
			ilist.ImageSize = new Size(16, 16);
			Bitmap bitmap = new Bitmap(imageStream);
			ilist.Images.AddStrip(bitmap);
			ilist.TransparentColor = Color.Magenta;
			return ilist;
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.GetImageList"]' />
        public static ImageList GetImageList(object imageListAsPointer)
		{
			ImageList images = null;

			IntPtr intPtr = new IntPtr((int)imageListAsPointer);
			HandleRef hImageList = new HandleRef(null, intPtr);
			int count = UnsafeNativeMethods.ImageList_GetImageCount(hImageList);

			if (count > 0)
			{
				// Create a bitmap big enough to hold all the images
				Bitmap b = new Bitmap(16 * count, 16);
				Graphics g = Graphics.FromImage(b);

				// Loop through and extract each image from the imagelist into our own bitmap
				IntPtr hDC = IntPtr.Zero;
				try
				{
					hDC = g.GetHdc();
					HandleRef handleRefDC = new HandleRef(null, hDC);
					for (int i = 0; i < count; i++)
					{
						UnsafeNativeMethods.ImageList_Draw(hImageList, i, handleRefDC, i * 16, 0, NativeMethods.ILD_NORMAL);
					}
				}
				finally
				{
					if (g != null && hDC != IntPtr.Zero)
					{
						g.ReleaseHdc(hDC);
					}
				}

				// Create a new imagelist based on our stolen images
				images = new ImageList();
				images.ImageSize = new Size(16, 16);
				images.Images.AddStrip(b);
			}
			return images;
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.ConvertToType"]' />
        /// <devdoc>
		/// Helper method to call a converter explicitely to convert to an enum type
		/// </devdoc>
		/// <typeparam name="T">The enum to convert to</typeparam>
		/// <param name="value">The enum value to be converted to</param>
		/// <param name="typeToConvert">The type to convert</param>
		/// <param name="culture">The culture to use to read the localized strings</param>
		/// <returns></returns>
		[CLSCompliant(false)]
		public static object ConvertToType<T>(T value, Type typeToConvert, CultureInfo culture)
			where T : struct
		{
			EnumConverter converter = GetEnumConverter<T>();
			if (converter == null)
			{
				return null;
			}
			if (converter.CanConvertTo(typeToConvert))
			{
				return converter.ConvertTo(null, culture, value, typeToConvert);
			}
			
			return null;
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.ConvertFromType"]' />
        /// <devdoc>
		/// Helper method for converting from a string to an enum using a converter.
		/// </devdoc>
		/// <typeparam name="T"></typeparam>
		/// <param name="value"></param>
		/// <param name="culture">The culture to use to read the localized strings</param>
		/// <returns></returns>
		[CLSCompliant(false)]
		public static Nullable<T> ConvertFromType<T>(string value, CultureInfo culture)
			where T : struct
		{
			Nullable<T> returnValue = new Nullable<T>();

			returnValue = returnValue.GetValueOrDefault();

			if (value == null)
			{
				return returnValue;
			}

			EnumConverter converter = GetEnumConverter<T>();
			if (converter == null)
			{
				return returnValue;
			}
			
			if (converter.CanConvertFrom(value.GetType()))
			{
				object converted = converter.ConvertFrom(null, culture, value);

				if (converted != null && (converted is T))
				{
					returnValue = (T)converted;
				}
			}

			return returnValue;
		}


        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.SetStringValueFromConvertedEnum"]' />
        /// <devdoc>
		/// Sets a string value from an enum
		/// </devdoc>
		/// <typeparam name="T">The enum type</typeparam>
		/// <param name="enumValue">The value of the enum.</param>
        /// <param name="culture"></param>
        /// <returns></returns>
		[CLSCompliant(false)]
		public static string SetStringValueFromConvertedEnum<T>(T enumValue, CultureInfo culture)
			where T : struct
		{
			object convertToType = PackageUtilities.ConvertToType<T>(enumValue, typeof(string), culture);
			if (convertToType == null || !(convertToType is string))
			{
				return String.Empty;
			}
			
			return (string)convertToType;
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.GetEnumConverter"]' />
        /// <devdoc>
		/// Gets an instance 
		/// </devdoc>
		/// <typeparam name="T"></typeparam>
		/// <returns></returns>
		private static EnumConverter GetEnumConverter<T>()
			where T : struct
		{
			object[] attributes = typeof(T).GetCustomAttributes(typeof(PropertyPageTypeConverterAttribute), true);

			// There should be only one PropertyPageTypeConverterAttribute defined on T
			if (attributes != null && attributes.Length == 1)
			{
				
				Debug.Assert(attributes[0] is PropertyPageTypeConverterAttribute, "The returned attribute must be an attribute is PropertyPageTypeConverterAttribute");
				PropertyPageTypeConverterAttribute converterAttribute = (PropertyPageTypeConverterAttribute)attributes[0];

				if (converterAttribute.ConverterType.IsSubclassOf(typeof(EnumConverter)))
				{
					return Activator.CreateInstance(converterAttribute.ConverterType) as EnumConverter;
				}
			}

			return null;
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.IsFilePartInValid"]' />
        /// <devdoc>
		/// Checks whether a file part contains valid characters. The file part can be any part of a non rooted path.
		/// </devdoc>
		/// <param name="filePart"></param>
		/// <returns></returns>
		private static bool IsFilePartInValid(string filePart)
		{
			if (String.IsNullOrEmpty(filePart))
			{
				return true;
			}

			// Define a regular expression that covers all characters that are not in the safe character sets.
			// It is compiled for performance.
			Regex unsafeCharactersRegex = new Regex(@"[/?:&\\*<>|#%" + '\"' + "]", RegexOptions.Compiled);
			return unsafeCharactersRegex.IsMatch(filePart);
		}

        /// <include file='doc\Utilities.uex' path='docs/doc[@for="PackageUtilities.IsFileNameAllGivenCharacter"]' />
        /// <devdoc>
		/// Checks if the file name is all the given character.
		/// </devdoc>
		private static bool IsFileNameAllGivenCharacter(char c, string fileName)
		{
			// A valid file name cannot be all "c" .
			int charFound = 0;
			for (charFound = 0; charFound < fileName.Length && fileName[charFound] == c; ++charFound) ;
			if (charFound >= fileName.Length)
			{
				return true;
			}

			return false;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\WindowPane.cs ===
//------------------------------------------------------------------------------
// <copyright file="WindowPane.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell.Interop;
    using Microsoft.Win32;
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.Drawing;
    using System.Runtime.InteropServices;
    using System.Windows.Forms;

    using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
    using IServiceProvider = System.IServiceProvider;

    /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane"]' />
    /// <devdoc>
    ///     This is a quick way to implement a tool window pane.  This class 
    ///     implements IVsWindowPane; you must provide an implementation of an 
    ///     object that returns an IWin32Window, however.  In addition to 
    ///     IVsWindowPane this object implements IOleCommandTarget, mapping 
    ///     it to IMenuCommandService and IObjectWithSite, mapping the site 
    ///     to services that can be querried through its protected GetService 
    ///     method.
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public abstract class WindowPane : 

        IVsWindowPane,
        IOleCommandTarget,
        IVsBroadcastMessageEvents,
        IServiceProvider,
        IDisposable {

        private IServiceProvider        _parentProvider;
        private ServiceProvider         _provider;
        private IVsShell                _vsShell;
        private uint                    _broadcastEventCookie;

        private IMenuCommandService     _commandService;
        private HelpService             _helpService;

        private bool                    _zombie = false;

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.WindowPane"]' />
        /// <devdoc>
        ///     Creates a new window pane.  The window pane can accept a service provider
        ///     to use when resolving services.  This provider can be null.
        /// </devdoc>
        protected WindowPane(IServiceProvider provider) {
            _parentProvider = provider;
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.Window"]' />
        /// <devdoc>
        ///     Retrieves the window associated with this window pane.
        /// </devdoc>
        public abstract IWin32Window Window { get; }
        
        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.Dispose"]' />
        /// <devdoc>
        ///     Can be called to dispose this editing window.
        /// </devdoc>
        public void Dispose() {
            Dispose(true);
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.Dispose1"]' />
        /// <devdoc>
        ///     Called when this window pane is being disposed.
        /// </devdoc>
        [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        protected virtual void Dispose(bool disposing) {

            if (disposing) {

                if (_vsShell != null) {
                    try {
                        // Don't check for return code because here we can't do anything in case of failure.
                        _vsShell.UnadviseBroadcastMessages(_broadcastEventCookie);
                    } catch (Exception) { /* do nothing */ }
                    _vsShell = null;
                    _broadcastEventCookie = 0;
                }

                IWin32Window window = Window;
                if (window is IDisposable) {
                    try {
                    ((IDisposable)window).Dispose();
                    } catch (Exception) {
                        Debug.Fail("Failed to dispose window");
                    }
                }
                window = null;

                if (_commandService != null && _commandService is IDisposable) {
                    try {
                    ((IDisposable)_commandService).Dispose();
                    } catch (Exception) {
                        Debug.Fail("Failed to dispose command service");
                    }
                }
                _commandService = null;

                if (_parentProvider != null)
                    _parentProvider = null;

                if (_helpService != null)
                    _helpService = null;

                // Do not clear _provider.  SetSite will do it for us.

                _zombie = true;
            }
        }

        /// <devdoc>
        /// This is a separate method so the jitter doesn't see MenuCommandService (from system.design.dll) in
        /// the GetService call and load the assembly.
        /// </devdoc> 
        private void EnsureCommandService() {
            if (_commandService == null) {
                _commandService = new OleMenuCommandService(this);
            }
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.GetService"]' />
        /// <devdoc>
        ///     Maps to IServiceProvider for service routing.
        /// </devdoc>
        protected virtual object GetService(Type serviceType) {

            if (_zombie)
            {
                Debug.Fail("GetService called after WindowPane was zombied");
                return null;
            }

            if (serviceType == null) {
                throw new ArgumentNullException("serviceType");
            }

            // We provide IMenuCommandService, so we will
            // demand create it.  MenuCommandService also
            // implements IOleCommandTarget, but unless
            // someone requested IMenuCommandService no commands
            // will exist, so we don't demand create for
            // IOleCommandTarget
            //
            if (serviceType == typeof(IMenuCommandService)) {
                EnsureCommandService();
                return _commandService;
            }
            else if (serviceType == typeof(IOleCommandTarget)) {
                return _commandService;
            }
            else if (serviceType == typeof(IHelpService)) {
                if (_helpService == null) {
                    _helpService = new HelpService(this);
                }
                return _helpService;
            }

            if (_provider != null) {
                object service = _provider.GetService(serviceType);
                if (service != null) {
                    return service;
                }
            }

            if (_parentProvider != null) {
                return _parentProvider.GetService(serviceType);
            }

            return null;
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.Initialize"]' />
        /// <devdoc>
        ///     This method is called after the window pane has been sited.  Any initialization
        ///     that requires window frame services from VS can be done by overriding this
        ///     method.
        /// </devdoc>
        protected virtual void Initialize() {
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.OnClose"]/*' />
        /// <devdoc>
        ///     The OnClose method is called in response to the ClosePane method on
        ///     IVsWindowPane.  The default implementation calls Dispose();
        /// </devdoc>
        protected virtual void OnClose() {
            Dispose();
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.OnCreate"]/*' />
        /// <devdoc>
        ///     The OnCreate method is called during the CreatePaneWindow method of
        ///     IVsWindowPane.  This provides a handy hook for knowing when VS wants
        ///     the window.  The default implementation does nothing.
        /// </devdoc>
        protected virtual void OnCreate() {
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.PreProcessMessage"]' />
        /// <devdoc>
        ///     This method will be called to pre-process keyboard
        ///     messages before VS handles them.  It is directly
        ///     attached to IVsWindowPane::TranslateAccellerator.
        ///     The default implementation calls the PreProcessMessage
        ///     method on a Windows Forms control.  You may override this if your
        ///     window pane is not based on Windows Forms.
        ///     Arguments and return values are the
        ///     same as for Windows Forms:  return true if you handled
        ///     the message, false if you want the default processing
        ///     to occur.
        /// </devdoc>
        protected virtual bool PreProcessMessage(ref Message m) {
            Control c = Control.FromChildHandle(m.HWnd);
            if (c != null) {
                return c.PreProcessControlMessage(ref m) == PreProcessControlState.MessageProcessed;
            }
            else {
                return false;
            }
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.IOleCommandTarget.Exec"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// This is called by Visual Studio when the user has requested to execute a particular
        /// command.  There is no need to override this method.  If you need access to menu
        /// commands use IMenuCommandService.
        /// </devdoc>
        int IOleCommandTarget.Exec(ref Guid guidGroup, uint nCmdId, uint nCmdExcept, IntPtr pIn, IntPtr vOut) {

            // Always redirect through GetService for this.  That way outside users can replace
            // it.
            //
            IOleCommandTarget cmdTarget = GetService(typeof(IOleCommandTarget)) as IOleCommandTarget;
            if (cmdTarget != null) {
                return cmdTarget.Exec(ref guidGroup, nCmdId, nCmdExcept, pIn, vOut);
            }
            else {
                return NativeMethods.OLECMDERR_E_NOTSUPPORTED;
            }
        }
        
        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.IOleCommandTarget.QueryStatus"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// This is called by Visual Studio when it needs the status of our menu commands.  There
        /// is no need to override this method.  If you need access to menu commands use
        /// IMenuCommandService.
        /// </devdoc>
        int IOleCommandTarget.QueryStatus(ref Guid guidGroup, uint nCmdId, OLECMD[] oleCmd, IntPtr oleText) {

            // Always redirect through GetService for this.  That way outside users can replace
            // it.
            //
            IOleCommandTarget cmdTarget = GetService(typeof(IOleCommandTarget)) as IOleCommandTarget;
            if (cmdTarget != null) {
                return cmdTarget.QueryStatus(ref guidGroup, nCmdId, oleCmd, oleText);
            }
            else {
                return NativeMethods.OLECMDERR_E_NOTSUPPORTED;
            }
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.IServiceProvider.GetService"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IServiceProvider implementation.
        /// </devdoc>
        object IServiceProvider.GetService(Type serviceType) {
            return GetService(serviceType);
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.IVsBroadcastMessageEvents.OnBroadcastMessage"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Receives broadcast messages from the shell
        /// </devdoc>
        int IVsBroadcastMessageEvents.OnBroadcastMessage(uint msg, IntPtr wParam, IntPtr lParam) {
            int hr = NativeMethods.S_OK;
            IntPtr hwnd = Window.Handle;
            bool result = UnsafeNativeMethods.PostMessage(hwnd, (int)msg, wParam, wParam);
            if ( !result )
                hr = NativeMethods.E_FAIL;
            return hr;
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.IVsWindowPane.ClosePane"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsWindowPane implementation.
        /// </devdoc>
        int IVsWindowPane.ClosePane() {

            if (_vsShell != null) {
                NativeMethods.ThrowOnFailure(_vsShell.UnadviseBroadcastMessages(_broadcastEventCookie));
                _vsShell = null;
                _broadcastEventCookie = 0;
            }

            OnClose();
            return NativeMethods.S_OK;
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.IVsWindowPane.CreatePaneWindow"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsWindowPane implementation.
        /// </devdoc>
        int IVsWindowPane.CreatePaneWindow(IntPtr hwndParent, int   x, int   y, int   cx, int   cy, out IntPtr pane) {
            
            OnCreate();
            IntPtr hwnd = Window.Handle;
            int style = (int)UnsafeNativeMethods.GetWindowLong(hwnd, NativeMethods.GWL_STYLE);

            // set up the required styles of an IVsWindowPane
            style |= (NativeMethods.WS_CLIPSIBLINGS | NativeMethods.WS_CHILD | NativeMethods.WS_VISIBLE);
            style &= ~(NativeMethods.WS_POPUP |
                       NativeMethods.WS_MINIMIZE |
                       NativeMethods.WS_MAXIMIZE |
                       NativeMethods.WS_DLGFRAME |
                       NativeMethods.WS_SYSMENU |
                       NativeMethods.WS_THICKFRAME |
                       NativeMethods.WS_MINIMIZEBOX |
                       NativeMethods.WS_MAXIMIZEBOX);

            UnsafeNativeMethods.SetWindowLong(hwnd, NativeMethods.GWL_STYLE, (IntPtr)style);

            style = (int)UnsafeNativeMethods.GetWindowLong(hwnd, NativeMethods.GWL_EXSTYLE);

            style &= ~(NativeMethods.WS_EX_DLGMODALFRAME  |
                       NativeMethods.WS_EX_NOPARENTNOTIFY |
                       NativeMethods.WS_EX_TOPMOST        |
                       NativeMethods.WS_EX_MDICHILD       |
                       NativeMethods.WS_EX_TOOLWINDOW     |
                       NativeMethods.WS_EX_CONTEXTHELP    |
                       NativeMethods.WS_EX_APPWINDOW);

            UnsafeNativeMethods.SetWindowLong(hwnd, NativeMethods.GWL_EXSTYLE, (IntPtr)style);
            UnsafeNativeMethods.SetParent(hwnd, (IntPtr)hwndParent);
            UnsafeNativeMethods.SetWindowPos(hwnd, IntPtr.Zero, x, y, cx, cy, NativeMethods.SWP_NOZORDER | NativeMethods.SWP_NOACTIVATE);
            UnsafeNativeMethods.ShowWindow(hwnd, NativeMethods.SW_SHOWNORMAL);
            
            // Sync broadcast events so we update our UI when colors/fonts change.
            //
            if (_vsShell == null) {
                _vsShell = (IVsShell)GetService(typeof(SVsShell));
                if (_vsShell != null) {
                    NativeMethods.ThrowOnFailure(_vsShell.AdviseBroadcastMessages(this, out _broadcastEventCookie));
                }
            }
            
            pane = hwnd;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.IVsWindowPane.GetDefaultSize"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsWindowPane implementation.
        /// </devdoc>
        int IVsWindowPane.GetDefaultSize(SIZE[] size) {
            return NativeMethods.E_NOTIMPL;
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.IVsWindowPane.LoadViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsWindowPane implementation.
        /// </devdoc>
        int IVsWindowPane.LoadViewState(IStream pstream) {
            Marshal.ReleaseComObject(pstream);
            return NativeMethods.E_NOTIMPL;
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.IVsWindowPane.SaveViewState"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsWindowPane implementation.
        /// </devdoc>
        int IVsWindowPane.SaveViewState(IStream pstream) {
            Marshal.ReleaseComObject(pstream);
            return NativeMethods.E_NOTIMPL;
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.IVsWindowPane.SetSite"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsWindowPane implementation.
        /// </devdoc>
        int IVsWindowPane.SetSite(IOleServiceProvider p) {

            // The siting mechanism works as follows:  If the
            // parent provider provides ServiceProviderHierarchy
            // as a service we will insert our service provider in
            // the WindowPaneSite slot of the hierarchy.
            // If, however, it does not provide
            // this service, we will create a new 
            // ServiceProvider that will be used to resolve
            // services through this site.  
            //
            if (_provider != null) {
                _provider.Dispose();
                _provider = null;
            }

            IObjectWithSite ows = GetService(typeof(IObjectWithSite)) as IObjectWithSite;
            ServiceProviderHierarchy serviceHierarchy = GetService(typeof(ServiceProviderHierarchy)) as ServiceProviderHierarchy;
            if (serviceHierarchy != null) {
                ServiceProvider sp = (p == null ? null : new ServiceProvider(p));
                serviceHierarchy[ServiceProviderHierarchyOrder.WindowPaneSite] = sp;             
            }
            else if (ows != null) {
               ows.SetSite(p);
            }
            else {
                if (p != null) {
                    _provider = new ServiceProvider(p);
                }
            }

            if (p != null) {
                Initialize();
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\WindowPane.uex' path='docs/doc[@for="WindowPane.IVsWindowPane.TranslateAccelerator"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IVsWindowPane implementation.
        /// </devdoc>
        int IVsWindowPane.TranslateAccelerator(Microsoft.VisualStudio.OLE.Interop.MSG[] msg) {
            Message m = Message.Create(msg[0].hwnd, (int)msg[0].message, msg[0].wParam, msg[0].lParam);
            bool eat = PreProcessMessage(ref m);

            msg[0].message = (uint)m.Msg;
            msg[0].wParam = m.WParam;
            msg[0].lParam = m.LParam;

            if (eat) {
                return NativeMethods.S_OK;
            }
            else {
                return NativeMethods.E_FAIL;
            }
        }
    } 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\VsShellUtilities.cs ===
//--------------------------------------------------------------------------
//  <copyright file="VSShellUtilities.cs" company="Microsoft">
//      Copyright (c) Microsoft Corporation.  All rights reserved.
//  </copyright>
//  <devdoc>
//  </devdoc>
//--------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using Microsoft.VisualStudio.TextManager.Interop;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.Designer.Interfaces;
using Microsoft.VisualStudio.Shell;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using System.Diagnostics;
using Microsoft.Win32;
using System.Globalization;
using System.IO;
using System.Collections;
using System.Xml;
using System.Text;
using System.Net;
using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
using IServiceProvider = System.IServiceProvider;
using ShellConstants = Microsoft.VisualStudio.Shell.Interop.Constants;
using OleConstants = Microsoft.VisualStudio.OLE.Interop.Constants;
using EnvDTE;

namespace Microsoft.VisualStudio.Shell
{

    /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities"]/*' />
    /// <devdoc>
    ///This class provides some useful static shell based methods. 
    /// </devdoc>
    [CLSCompliant(false)]
    public static class VsShellUtilities
    {

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.RenameDocument"]/*' />
        /// <devdoc>
        /// Rename document in the running document table from oldName to newName.
        /// </devdoc>
        /// <param name="site">The service provider.</param>
        /// <param name="oldName">Full path to the old name of the document.</param>        
        /// <param name="newName">Full path to the new name of the document.</param>        
        public static void RenameDocument(IServiceProvider site, string oldName, string newName)
        {
            if (site == null)
            {
                throw new ArgumentException("site");
            }

            if (String.IsNullOrEmpty(oldName))
            { 
                throw new ArgumentException("oldName");
            }

            if (String.IsNullOrEmpty(newName))
            {
                throw new ArgumentException("newName");
            }

            IVsRunningDocumentTable pRDT = site.GetService(typeof(SVsRunningDocumentTable)) as IVsRunningDocumentTable;
            IVsUIShellOpenDocument doc = site.GetService(typeof(SVsUIShellOpenDocument)) as IVsUIShellOpenDocument;
            IVsUIShell uiShell = site.GetService(typeof(SVsUIShell)) as IVsUIShell;

            if (pRDT == null || doc == null) return;

            IVsHierarchy pIVsHierarchy;
            uint itemId;
            IntPtr docData;
            uint uiVsDocCookie;
            ErrorHandler.ThrowOnFailure(pRDT.FindAndLockDocument((uint)_VSRDTFLAGS.RDT_NoLock, oldName, out pIVsHierarchy, out itemId, out docData, out uiVsDocCookie));

            if (docData != IntPtr.Zero)
            {
                try
                {
                    IntPtr pUnk = Marshal.GetIUnknownForObject(pIVsHierarchy);
                    Guid iid = typeof(IVsHierarchy).GUID;
                    IntPtr pHier;
                    Marshal.QueryInterface(pUnk, ref iid, out pHier);
                    try
                    {
                        ErrorHandler.ThrowOnFailure(pRDT.RenameDocument(oldName, newName, pHier, itemId));
                    }
                    finally
                    {
                        Marshal.Release(pHier);
                        Marshal.Release(pUnk);
                    }

                    string newCaption = Path.GetFileName(newName);
                    // now we need to tell the windows to update their captions. 
                    IEnumWindowFrames ppenum;
                    ErrorHandler.ThrowOnFailure(uiShell.GetDocumentWindowEnum(out ppenum));
                    IVsWindowFrame[] rgelt = new IVsWindowFrame[1];
                    uint fetched;
                    while (ppenum.Next(1, rgelt, out fetched) == VSConstants.S_OK && fetched == 1)
                    {
                        IVsWindowFrame windowFrame = rgelt[0];
                        object data;
                        ErrorHandler.ThrowOnFailure(windowFrame.GetProperty((int)__VSFPROPID.VSFPROPID_DocData, out data));
                        IntPtr ptr = Marshal.GetIUnknownForObject(data);
                        try
                        {
                            if (ptr == docData)
                            {
                                ErrorHandler.ThrowOnFailure(windowFrame.SetProperty((int)__VSFPROPID.VSFPROPID_OwnerCaption, newCaption));
                            }
                        }
                        finally
                        {
                            if (ptr != IntPtr.Zero)
                            {
                                Marshal.Release(ptr);
                            }
                        }
                    }
                }
                finally
                {
                    Marshal.Release(docData);
                }
            }
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.OpenDocument"]/*' />
        /// <devdoc>
        /// Open document using the appropriate project. 
        /// </devdoc>
        /// <param name="provider">The service provider.</param>
        /// <param name="fullPath">Full path to the document.</param>
        /// <param name="logicalView">In MultiView case determines view to be activated by IVsMultiViewDocumentView. For a list of logical view GUIDS, see constants starting with LOGVIEWID_ defined in NativeMethods class</param>
        /// <param name="hierarchy">Reference to the IVsUIHierarchy interface of the project that can open the document.</param>
        /// <param name="itemID"> Reference to the hierarchy item identifier of the document in the project.</param>
        /// <param name="windowFrame">A reference to the window frame that is mapped to the document.</param>
        /// <param name="view">A reference to the primary view of the document.</param>
        public static void OpenDocument(IServiceProvider provider, string fullPath, Guid logicalView, out IVsUIHierarchy hierarchy, out uint itemID, out IVsWindowFrame windowFrame, out IVsTextView view)
        {
            itemID = VSConstants.VSITEMID_NIL;
            windowFrame = null;
            hierarchy = null;
            view = null;

            if (provider == null)
            {
                throw new ArgumentException("provider");
            }

            if (String.IsNullOrEmpty(fullPath))
            {
                throw new ArgumentException("fullPath");
            }

            OpenDocument(provider, fullPath, logicalView, out hierarchy, out itemID, out windowFrame);
            view = GetTextView(windowFrame);
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.OpenDocument"]/*' />
        /// <devdoc>
        /// Open document using the appropriate project. 
        /// </devdoc>
        /// <param name="provider">The service provider.</param>
        /// <param name="fullPath">Full path to the document.</param>
        /// <param name="logicalView">GUID identifying the logical view.</param>
        /// <param name="hierarchy">Reference to the IVsUIHierarchy interface of the project that contains the Open document.</param>
        /// <param name="itemID"> Reference to the hierarchy item identifier of the document in the project.</param>
        /// <param name="windowFrame">A reference to the window frame that is mapped to the document.</param>
        public static void OpenDocument(IServiceProvider provider, string fullPath, Guid logicalView, out IVsUIHierarchy hierarchy, out uint itemID, out IVsWindowFrame windowFrame)
        {
            windowFrame = null;
            itemID = VSConstants.VSITEMID_NIL;
            hierarchy = null;

            if (provider == null)
            {
                throw new ArgumentException("provider");
            }

            if (String.IsNullOrEmpty(fullPath))
            {
                throw new ArgumentException("fullPath");
            }

            //open document
            if (!IsDocumentOpen(provider, fullPath, Guid.Empty, out hierarchy, out itemID, out windowFrame))
            {
                IVsUIShellOpenDocument shellOpenDoc = provider.GetService(typeof(IVsUIShellOpenDocument)) as IVsUIShellOpenDocument;
                if (shellOpenDoc != null)
                {
                    IOleServiceProvider psp;
                    uint itemid;
                    ErrorHandler.ThrowOnFailure(shellOpenDoc.OpenDocumentViaProject(fullPath, ref logicalView, out psp, out hierarchy, out itemid, out windowFrame));
                    if (windowFrame != null)
                        ErrorHandler.ThrowOnFailure(windowFrame.Show());
                    psp = null;
                }
            }
            else if (windowFrame != null)
            {
                ErrorHandler.ThrowOnFailure(windowFrame.Show());
            }
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetTextView"]/*' />
        /// <devdoc>
        /// Get primary view for a window frame.
        /// </devdoc>
        /// <param name="windowFrame">The window frame</param>
        /// <returns>A refererence to an IVsTextView if successfull. Otherwise null.</returns>
        public static IVsTextView GetTextView(IVsWindowFrame windowFrame)
        {
            if (windowFrame == null)
            {
                throw new ArgumentException("windowFrame");
            }

            IVsTextView textView = null;
            object pvar;
            ErrorHandler.ThrowOnFailure(windowFrame.GetProperty((int)__VSFPROPID.VSFPROPID_DocView, out pvar));
            if (pvar is IVsTextView)
            {
                textView = (IVsTextView)pvar;
            }
            else if (pvar is IVsCodeWindow)
            {
                IVsCodeWindow codeWin = (IVsCodeWindow)pvar;
                try
                {
                    ErrorHandler.ThrowOnFailure(codeWin.GetPrimaryView(out textView));
                }
                catch (COMException e)
                {
                    // perhaps the code window doesn't use IVsTextWindow?
                    Trace.WriteLine("Exception : " + e.Message);
                    textView = null;
                }
            }
            return textView;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetWindowObject"]/*' />
        /// <devdoc>
        /// Get Window interface for the window frame.
        /// </devdoc>
        /// <param name="windowFrame">The window frame.</param>
        /// <returns>A reference to the Window interaface if succesfull. Otherwise null.</returns>
        public static EnvDTE.Window GetWindowObject(IVsWindowFrame windowFrame)
        {
            if (windowFrame == null)
            {
                throw new ArgumentException("windowFrame");
            }

            EnvDTE.Window window = null;
            object pvar;
            ErrorHandler.ThrowOnFailure(windowFrame.GetProperty((int)__VSFPROPID.VSFPROPID_ExtWindowObject, out pvar));
            if (pvar is EnvDTE.Window)
            {
                window = (EnvDTE.Window)pvar;
            }
            return window;

        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.IsDocumentOpen"]/*' />
        /// <devdoc>
        /// Determine if a document is opened with a given logical view.  
        /// </devdoc>
        /// <param name="provider">The service provider.</param>
        /// <param name="fullPath">Full path to the document</param>
        /// <param name="logicalView">GUID identifying the logical view. If logicalView is set to Guid.Empty, it will return true if any view is open.</param>
        /// <param name="hierarchy">Reference to the IVsUIHierarchy interface of the project that contains the Open document</param>
        /// <param name="itemID"> Reference to the hierarchy item identifier of the document in the project</param>
        /// <param name="windowFrame">A reference to the window frame that is mapped to the document</param>
        /// <returns>true if the document is open with the given logical view</returns>
        public static bool IsDocumentOpen(IServiceProvider provider, string fullPath, Guid logicalView, out IVsUIHierarchy hierarchy, out uint itemID, out IVsWindowFrame windowFrame)
        {
            windowFrame = null;
            itemID = VSConstants.VSITEMID_NIL;
            hierarchy = null;

            if (provider == null)
            {
                throw new ArgumentException("provider");
            }

            if (String.IsNullOrEmpty(fullPath))
            {
                throw new ArgumentException("fullPath");
            }

            //open document
            IVsUIShellOpenDocument shellOpenDoc = provider.GetService(typeof(IVsUIShellOpenDocument)) as IVsUIShellOpenDocument;
            IVsRunningDocumentTable pRDT = provider.GetService(typeof(IVsRunningDocumentTable)) as IVsRunningDocumentTable;
            if (pRDT != null && shellOpenDoc != null)
            {
                IntPtr punkDocData = IntPtr.Zero;
                uint docCookie;
                uint[] pitemid = new uint[1];
                IVsHierarchy ppIVsHierarchy;
                try
                {
                    ErrorHandler.ThrowOnFailure(pRDT.FindAndLockDocument((uint)_VSRDTFLAGS.RDT_NoLock, fullPath, out ppIVsHierarchy, out pitemid[0], out punkDocData, out docCookie));
                    int pfOpen;
                    uint flags = (logicalView == Guid.Empty) ? (uint)__VSIDOFLAGS.IDO_IgnoreLogicalView : 0;
                    ErrorHandler.ThrowOnFailure(shellOpenDoc.IsDocumentOpen((IVsUIHierarchy)ppIVsHierarchy, pitemid[0], fullPath, ref logicalView, flags, out hierarchy, pitemid, out windowFrame, out pfOpen));
                    if (windowFrame != null)
                    {
                        itemID = pitemid[0];
                        return (pfOpen == 1);
                    }
                }
                finally
                {
                    if (punkDocData != IntPtr.Zero)
                    {
                        Marshal.Release(punkDocData);
                    }
                }
            }
            return false;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.OpenAsMiscellaneousFile"]/*' />
        /// <devdoc>
        /// Open a file using the miscellaneous project.
        /// </devdoc>
        /// <param name="provider">The service provider.</param>
        /// <param name="path">Path to the item to open.</param>
        /// <param name="caption">Caption of the item.</param>
        /// <param name="editor">Unique identifier of the editor type.</param>
        /// <param name="physicalView">Name of physical view.</param>
        /// <param name="logicalView">Name of logical view.</param>
        public static void OpenAsMiscellaneousFile(IServiceProvider provider, string path, string caption, Guid editor, string physicalView, Guid logicalView)
        {

            if (provider == null)
            {
                throw new ArgumentException("provider");
            }

            if (String.IsNullOrEmpty(path))
            {
                throw new ArgumentException("path");
            }

            IVsProject3 proj = VsShellUtilities.GetMiscellaneousProject(provider);
            VSADDRESULT[] result = new VSADDRESULT[1];
            // NOTE: This method must use VSADDITEMOPERATION.VSADDITEMOP_CLONEFILE.
            // VSADDITEMOPERATION.VSADDITEMOP_OPENFILE doesn't work.
            VSADDITEMOPERATION op = VSADDITEMOPERATION.VSADDITEMOP_CLONEFILE;
            __VSCREATEEDITORFLAGS flags = __VSCREATEEDITORFLAGS.CEF_CLONEFILE;
            ErrorHandler.ThrowOnFailure(proj.AddItemWithSpecific(VSConstants.VSITEMID_NIL, op, caption, 1, new string[1] { path }, IntPtr.Zero,
                (uint)flags, ref editor, physicalView, ref logicalView, result));

            if (result[0] != VSADDRESULT.ADDRESULT_Success)
            {
                throw new ApplicationException(result[0].ToString());
            }
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetMiscellaneousProject"]/*' />
        /// <devdoc>
        /// Get miscellaneous project from current solution
        /// </devdoc>
        /// <param name="provider">The service provider</param>
        /// <returns>A refernce to the IVsProject3 interface for the misceleneous project.</returns>
        public static IVsProject3 GetMiscellaneousProject(IServiceProvider provider)
        {
            if (provider == null)
            {
                throw new ArgumentNullException("provider");
            }

            IVsHierarchy miscHierarchy = null;
            Guid miscProj = VSConstants.CLSID_MiscellaneousFilesProject;
            IVsSolution sln = (IVsSolution)provider.GetService(typeof(SVsSolution));
            int hr = sln.GetProjectOfGuid(ref miscProj, out miscHierarchy);

            if (ErrorHandler.Failed(hr) || miscHierarchy == null)
            {
                // need to create it then
                IntPtr ptr;
                Guid iidVsHierarchy = typeof(IVsHierarchy).GUID;
                __VSCREATEPROJFLAGS grfCreate = __VSCREATEPROJFLAGS.CPF_OPENFILE;
                //                if (!g_fShowMiscellaneousFilesProject)
                //                    grfCreate |= CPF_NOTINSLNEXPLR;
                ErrorHandler.ThrowOnFailure(sln.CreateProject(ref miscProj, null, null, null, (uint)grfCreate, ref iidVsHierarchy, out ptr));
                try
                {
                    miscHierarchy = (IVsHierarchy)Marshal.GetTypedObjectForIUnknown(ptr, typeof(IVsHierarchy));
                }
                finally
                {
                    Marshal.Release(ptr);
                }
            }
            return miscHierarchy as IVsProject3;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetMiscellaneousProject"]/*' />
        /// <devdoc>
        /// Get miscellaneous project from current solution
        /// </devdoc>
        /// <param name="provider">The service provider</param>
        /// <param name="create">If false, does not force creation of the misc project</param>
        /// <returns>A refernce to the IVsProject3 interface for the misceleneous project.</returns>
        public static IVsProject3 GetMiscellaneousProject(IServiceProvider provider, bool create)
        {
            if (provider == null)
            {
                throw new ArgumentNullException("provider");
            }

            IVsHierarchy miscHierarchy = null;
            Guid miscProj = VSConstants.CLSID_MiscellaneousFilesProject;
            IVsSolution2 sln = (IVsSolution2)provider.GetService(typeof(SVsSolution));
            int hr = sln.GetProjectOfGuid(ref miscProj, out miscHierarchy);

            if ((NativeMethods.Failed(hr) || miscHierarchy == null) && create)
            {
                return GetMiscellaneousProject(provider);
            }
            return miscHierarchy as IVsProject3;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.OpenDocument"]/*' />
        /// <devdoc>
        /// Open a document.
        /// </devdoc>
        /// <param name="provider">The service provider.</param>
        /// <param name="path">Full path to the document.</param>
        public static void OpenDocument(IServiceProvider provider, string path)
        {
            if (provider == null)
            {
                throw new ArgumentException("provider");
            }

            if (String.IsNullOrEmpty(path))
            {
                throw new ArgumentException("path");
            }

            IVsUIHierarchy hierarchy;
            uint itemID;
            IVsWindowFrame windowFrame;
            Guid logicalView = Guid.Empty;
            VsShellUtilities.OpenDocument(provider, path, logicalView, out hierarchy, out itemID, out windowFrame);
            windowFrame = null;
            hierarchy = null;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.OpenDocumentWithSpecificEditor"]/*' />
        /// <devdoc>
        /// Open a document using a specific editor. 
        /// </devdoc>
        /// <param name="provider">The service provider.</param>
        /// <param name="fullPath">Full path to the document.</param>
        /// <param name="editorType">Unique identifier of the editor type.</param>
        /// <param name="logicalView">In MultiView case determines view to be activated by IVsMultiViewDocumentView. For a list of logical view GUIDS, see constants starting with LOGVIEWID_ defined in NativeMethods class</param>
        /// <returns>A reference to the window frame that is mapped to the document.</returns>
        public static IVsWindowFrame OpenDocumentWithSpecificEditor(IServiceProvider provider, string fullPath, Guid editorType, Guid logicalView)
        {
            if (provider == null)
            {
                throw new ArgumentException("provider");
            }

            if (String.IsNullOrEmpty(fullPath))
            {
                throw new ArgumentException("fullPath");
            }

            IVsUIHierarchy hierarchy;
            uint itemID;
            IVsWindowFrame windowFrame;
            OpenDocumentWithSpecificEditor(provider, fullPath, editorType, logicalView, out hierarchy, out itemID, out windowFrame);
            hierarchy = null;
            return windowFrame;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.OpenDocumentWithSpecificEditor"]/*' />
        /// <devdoc>
        /// Open a document using a specific editor. 
        /// </devdoc>
        /// <param name="provider">The service provider.</param>
        /// <param name="fullPath">Full path to the document.</param>
        /// <param name="editorType">Unique identifier of the editor type.</param>
        /// <param name="logicalView">In MultiView case determines view to be activated by IVsMultiViewDocumentView. For a list of logical view GUIDS, see constants starting with LOGVIEWID_ defined in NativeMethods class</param>
        /// <param name="hierarchy">Reference to the IVsUIHierarchy interface of the project that can open the document.</param>
        /// <param name="itemID"> Reference to the hierarchy item identifier of the document in the project.</param>
        /// <param name="windowFrame">A reference to the window frame that is mapped to the document.</param>
        public static void OpenDocumentWithSpecificEditor(IServiceProvider provider, string fullPath, Guid editorType, Guid logicalView, out IVsUIHierarchy hierarchy, out uint itemID, out IVsWindowFrame windowFrame)
        {
            windowFrame = null;
            itemID = VSConstants.VSITEMID_NIL;
            hierarchy = null;

            if (provider == null)
            {
                throw new ArgumentException("provider");
            }

            if (String.IsNullOrEmpty(fullPath))
            {
                throw new ArgumentException("fullPath");
            }

            //open document
            IVsUIShellOpenDocument shellOpenDoc = provider.GetService(typeof(IVsUIShellOpenDocument)) as IVsUIShellOpenDocument;
            IVsRunningDocumentTable pRDT = provider.GetService(typeof(IVsRunningDocumentTable)) as IVsRunningDocumentTable;
            string physicalView = null;
            if (pRDT != null && shellOpenDoc != null)
            {
                ErrorHandler.ThrowOnFailure(shellOpenDoc.MapLogicalView(ref editorType, ref logicalView, out physicalView));
                // See if the requested editor is already open with the requested view.
                IntPtr punkDocData = IntPtr.Zero;
                uint docCookie;
                IVsHierarchy ppIVsHierarchy;
                try
                {
                    ErrorHandler.ThrowOnFailure(pRDT.FindAndLockDocument((uint)_VSRDTFLAGS.RDT_NoLock, fullPath, out ppIVsHierarchy, out itemID, out punkDocData, out docCookie));                    
                    int pfOpen;
                    uint flags = (uint)__VSIDOFLAGS.IDO_ActivateIfOpen;
                    int hr = shellOpenDoc.IsSpecificDocumentViewOpen((IVsUIHierarchy)ppIVsHierarchy, itemID, fullPath, ref editorType, physicalView, flags, out hierarchy, out itemID, out windowFrame, out pfOpen);
                    if (ErrorHandler.Succeeded(hr) && pfOpen == 1)
                    {
                        return;
                    }
                }
                finally
                { 
                    if (punkDocData != IntPtr.Zero)
                    {
                        Marshal.Release(punkDocData);
                    }
                }

                IOleServiceProvider psp;
                uint editorFlags = (uint)__VSSPECIFICEDITORFLAGS.VSSPECIFICEDITOR_UseEditor | (uint)__VSSPECIFICEDITORFLAGS.VSSPECIFICEDITOR_DoOpen;
                ErrorHandler.ThrowOnFailure(shellOpenDoc.OpenDocumentViaProjectWithSpecific(fullPath, editorFlags, ref editorType, physicalView, ref logicalView, out psp, out hierarchy, out itemID, out windowFrame));
                if (windowFrame != null)
                    ErrorHandler.ThrowOnFailure(windowFrame.Show());
                psp = null;
            }
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetProject"]/*' />
        /// <devdoc>
        /// Get reference to the IVsHierarchy interface for project that owns the document.
        /// </devdoc>
        /// <param name="site">The service provider.</param>
        /// <param name="moniker">The document moniker.</param>
        /// <returns>
        /// If the document is open, this is a reference to the IVsUIHierarchy Interface implementation of the project that owns the document. 
        /// If the document is not open, the value of this parameter is NULL. 
        /// </returns>
        public static IVsHierarchy GetProject(IServiceProvider site, string moniker)
        {
            if (site == null)
            {
                throw new ArgumentException("site");
            }

            if (String.IsNullOrEmpty(moniker))
            {
                throw new ArgumentException("moniker");
            }

            IVsUIShellOpenDocument opendoc = site.GetService(typeof(SVsUIShellOpenDocument)) as IVsUIShellOpenDocument;
            IVsUIHierarchy hierarchy = null;
            uint pitemid;
            IOleServiceProvider sp;
            int docInProj;
            int rc = opendoc.IsDocumentInAProject(moniker, out hierarchy, out pitemid, out sp, out docInProj);
            ErrorHandler.ThrowOnFailure(rc);
            return hierarchy as IVsHierarchy;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetRunningDocumentContents"]/*' />
        /// <devdoc>
        /// Get contents of file loaded by the running document table.
        /// </devdoc>
        /// <param name="site">The service provider.</param>
        /// <param name="path">Path to the file.</param>
        /// <returns>The contents of the file if it is loaded by RDT. Otherwise it returns null.</returns>
        public static string GetRunningDocumentContents(IServiceProvider site, string path)
        {
            if (site == null)
            {
                throw new ArgumentException("site");
            }

            if (String.IsNullOrEmpty(path))
            {
                throw new ArgumentException("path");
            }

            string text = null;
            IVsRunningDocumentTable pRDT = (IVsRunningDocumentTable)site.GetService(typeof(SVsRunningDocumentTable));
            if (pRDT != null)
            {
                IntPtr punkDocData = IntPtr.Zero;
                uint pitemid;
                uint docCookie;
                IVsHierarchy ppIVsHierarchy;
                try
                {
                    ErrorHandler.ThrowOnFailure(pRDT.FindAndLockDocument((uint)_VSRDTFLAGS.RDT_NoLock, path, out ppIVsHierarchy, out pitemid, out punkDocData, out docCookie));
                    if (punkDocData != IntPtr.Zero)
                    {
                        object docDataObj = Marshal.GetObjectForIUnknown(punkDocData);
                        IVsTextLines buffer = null;
                        if (docDataObj is IVsTextLines)
                        {
                            buffer = (IVsTextLines)docDataObj;
                        }
                        else if (docDataObj is IVsTextBufferProvider)
                        {
                            IVsTextBufferProvider tp = (IVsTextBufferProvider)docDataObj;
                            if (tp.GetTextBuffer(out buffer) != VSConstants.S_OK)
                                buffer = null;
                        }
                        if (buffer != null)
                        {
                            int endLine, endIndex;
                            ErrorHandler.ThrowOnFailure(buffer.GetLastLineIndex(out endLine, out endIndex));
                            ErrorHandler.ThrowOnFailure(buffer.GetLineText(0, 0, endLine, endIndex, out text));
                            buffer = null;
                            return text;
                        }
                    }
                }
                finally
                {
                    if (punkDocData != IntPtr.Zero)
                    {
                        Marshal.Release(punkDocData);
                    }
                }
            }

            return null;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetRDTDocumentInfo"]/*' />
        /// <devdoc>
        /// Get a reference to the IVsPersistDocData interface associated to a document in the Running Document Table.
        /// </devdoc>
        /// <param name="site">The service provider.</param>
        /// <param name="documentName">Path to the document.</param>
        /// <param name="hierarchy">[out, optional] Reference to the IVsHierarchy interface for the project who owns the document.</param>
        /// <param name="itemid">[out, optional] Reference to an item identifier in the hierarchy. </param>
        /// <param name="persistDocData">[out] A reference to the IVsPersistDocData interface associated to the document</param>
        /// <param name="docCookie">[out, optional] A reference to an abstract handle to the document. </param>
        public static void GetRDTDocumentInfo(IServiceProvider site, string documentName, out IVsHierarchy hierarchy, out uint itemid, out IVsPersistDocData persistDocData, out uint docCookie)
        {
            hierarchy = null;
            itemid = VSConstants.VSITEMID_NIL;
            persistDocData = null;
            docCookie = (uint)ShellConstants.VSDOCCOOKIE_NIL;

            if (site == null)
            {
                throw new ArgumentException("site");
            }

            if (String.IsNullOrEmpty(documentName))
            {
                throw new ArgumentException("documentName");
            }

            // Get the document info.
            IVsRunningDocumentTable rdt = site.GetService(typeof(IVsRunningDocumentTable)) as IVsRunningDocumentTable;
            if (rdt == null) return;

            IntPtr docData = IntPtr.Zero;
            try
            {
                ErrorHandler.ThrowOnFailure(rdt.FindAndLockDocument((uint)_VSRDTFLAGS.RDT_NoLock, documentName, out hierarchy, out itemid, out docData, out docCookie));


                if (docData != IntPtr.Zero)
                {
                    // if interface is not supported, return null
                    persistDocData = Marshal.GetObjectForIUnknown(docData) as IVsPersistDocData;
                }
            }
            finally
            {

                if (docData != IntPtr.Zero)
                {
                    Marshal.Release(docData);
                }
            }
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.SaveFileIfDirty"]/*' />
        /// <devdoc>
        /// Save file if it is dirty.
        /// </devdoc>
        /// <param name="site">The service provider.</param>
        /// <param name="fullPath">The full path of the file to be saved.</param>
        public static void SaveFileIfDirty(IServiceProvider site, string fullPath)
        {
            if (site == null)
            {
                throw new ArgumentException("site");
            }

            if (String.IsNullOrEmpty(fullPath))
            {
                throw new ArgumentException("fullPath");
            }

            IVsRunningDocumentTable pRDT = (IVsRunningDocumentTable)site.GetService(typeof(SVsRunningDocumentTable));
            if (pRDT != null)
            {
                IntPtr punkDocData;
                uint pitemid;
                uint docCookie;
                IVsHierarchy vsHierarchy;
                ErrorHandler.ThrowOnFailure(pRDT.FindAndLockDocument((uint)_VSRDTFLAGS.RDT_NoLock, fullPath, out vsHierarchy, out pitemid, out punkDocData, out docCookie));
                if (punkDocData != IntPtr.Zero)
                {
                    try
                    {
                        IVsPersistDocData2 pdd = (IVsPersistDocData2)Marshal.GetObjectForIUnknown(punkDocData);
                        int dirty;
                        ErrorHandler.ThrowOnFailure(pdd.IsDocDataDirty(out dirty));
                        if (dirty != 0)
                        {
                            string newdoc;
                            int cancelled;
                            ErrorHandler.ThrowOnFailure(pdd.SaveDocData(VSSAVEFLAGS.VSSAVE_Save, out newdoc, out cancelled));
                        }
                    }
                    finally
                    {
                        Marshal.Release(punkDocData);
                    }
                }
                vsHierarchy = null;
            }
            pRDT = null;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.SaveFileIfDirty"]/*' />
        /// <devdoc>
        /// Save document data for a text view.
        /// </devdoc>
        /// <param name="view">The view to be saved</param>
        public static void SaveFileIfDirty(IVsTextView view)
        {
            if (view == null)
            {
                throw new ArgumentException("view");
            }


            IVsTextLines buffer;
            ErrorHandler.ThrowOnFailure(view.GetBuffer(out buffer));
            IVsPersistDocData2 pdd = (IVsPersistDocData2)buffer;
            int dirty;
            ErrorHandler.ThrowOnFailure(pdd.IsDocDataDirty(out dirty));
            if (dirty != 0)
            {
                string newdoc;
                int cancelled;
                ErrorHandler.ThrowOnFailure(pdd.SaveDocData(VSSAVEFLAGS.VSSAVE_Save, out newdoc, out cancelled));
            }
            pdd = null;
            buffer = null;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.PromptYesNo"]/*' />
        /// <devdoc>
        /// Prompt the user with the specified message.
        /// </devdoc>
        /// <param name="message">The message to show.</param>
        /// <param name="title">The title of the message box.</param>
        /// <param name="icon">The icon to show on the message box.</param>
        /// <param name="uiShell">A reference to a IVsUIShell interface.</param>        
        /// <returns>Return true if the result is Yes, false otherwise.</returns>
        public static bool PromptYesNo(string message, string title, OLEMSGICON icon, IVsUIShell uiShell)
        {
            Guid emptyGuid = Guid.Empty;
            int result = 0;
            ErrorHandler.ThrowOnFailure(uiShell.ShowMessageBox(
                0,
                ref emptyGuid,
                title,
                message,
                null,
                0,
                OLEMSGBUTTON.OLEMSGBUTTON_YESNO,
                OLEMSGDEFBUTTON.OLEMSGDEFBUTTON_SECOND,
                icon,
                0,
                out result));

            return (result == NativeMethods.IDYES);
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.ShowMessageBox"]/*' />
        /// <devdoc>
        /// Show message box.
        /// </devdoc>
        /// <param name="serviceProvider">The service provider</param>
        /// <param name="message">The message to show</param>
        /// <param name="title">The title of the message box</param>
        /// <param name="icon">The icon to show on the message box</param>
        /// <param name="msgButton">The button type</param>
        /// <param name="defaultButton">The default button</param>
        /// <returns>If the method succeeds, it returns S_OK. If it fails, it returns an error code. If a referernce to the IVsUIShell interface cannot be retrived from the service provider then InvalidOperationException is thrown.</returns>
        public static int ShowMessageBox(IServiceProvider serviceProvider, string message, string title, OLEMSGICON icon, OLEMSGBUTTON msgButton, OLEMSGDEFBUTTON defaultButton)
        {
            Debug.Assert(serviceProvider != null, "Could not create MessageBox for a null serviceprovider");
            if (serviceProvider == null)
            {
                throw new ArgumentException("serviceProvider");
            }

            IVsUIShell uiShell = serviceProvider.GetService(typeof(IVsUIShell)) as IVsUIShell;
            Debug.Assert(uiShell != null, "Could not get the IVsUIShell object from the services exposed by this serviceprovider");
            if (uiShell == null)
            {
                throw new InvalidOperationException();
            }
            Guid emptyGuid = Guid.Empty;
            int result = 0;
            ErrorHandler.ThrowOnFailure(uiShell.ShowMessageBox(
                0,
                ref emptyGuid,
                title,
                message,
                null,
                0,
                msgButton,
                defaultButton,
                icon,
                0,
                out result));

            return result;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetTaskItems"]/*' />
        /// <devdoc>
        /// Get list of all tasks items.
        /// </devdoc>
        /// <param name="serviceProvider">The service provider.</param>
        /// <returns>A list of task items.</returns>
        public static IList<IVsTaskItem2> GetTaskItems(IServiceProvider serviceProvider)
        {
            IList<IVsTaskItem2> tasks = new List<IVsTaskItem2>();

            if (serviceProvider == null)
            {
                throw new ArgumentException("serviceProvider");
            }

            IVsTaskList taskList = serviceProvider.GetService(typeof(IVsTaskList)) as IVsTaskList;

            if (taskList == null)
            {
                throw new InvalidOperationException();
            }

            IVsEnumTaskItems enumTaskItems;
            try
            {
                ErrorHandler.ThrowOnFailure(taskList.EnumTaskItems(out enumTaskItems));

                if (enumTaskItems == null)
                {
                    return tasks;
                }

                int result = VSConstants.E_FAIL;
                uint[] fetched = new uint[1];
                do
                {
                    IVsTaskItem[] taskItems = new IVsTaskItem[1];

                    result = enumTaskItems.Next(1, taskItems, fetched);

                    if (fetched[0] == 1)
                    {
                        IVsTaskItem2 taskItem = taskItems[0] as IVsTaskItem2;
                        tasks.Add(taskItem);
                    }

                } while (result == VSConstants.S_OK && fetched[0] == 1);
            }
            catch (COMException e)
            {
                Trace.WriteLine("Exception : " + e.Message);
            }

            return tasks;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.EmptyTaskList"]/*' />
        /// <devdoc>
        /// Empty the task list.
        /// </devdoc>
        /// <param name="serviceProvider">The service provider.</param>
        /// <returns>If the method succeeds, it returns S_OK. If it fails, it returns an error code. </returns>
        public static int EmptyTaskList(IServiceProvider serviceProvider)
        {
            if (serviceProvider == null)
            {
                throw new ArgumentException("serviceProvider");
            }

            IVsTaskList taskList = serviceProvider.GetService(typeof(IVsTaskList)) as IVsTaskList;

            if (taskList == null)
            {
                throw new InvalidOperationException();
            }

            IVsEnumTaskItems enumTaskItems;
            int result = VSConstants.S_OK;
            try
            {
                ErrorHandler.ThrowOnFailure(taskList.EnumTaskItems(out enumTaskItems));

                if (enumTaskItems == null)
                {
                    throw new InvalidOperationException();
                }

                // Retrieve the task item text and check whether it is equal with one that supposed to be thrown.
                
                uint[] fetched = new uint[1];
                do
                {
                    IVsTaskItem[] taskItems = new IVsTaskItem[1];

                    result = enumTaskItems.Next(1, taskItems, fetched);

                    if (fetched[0] == 1)
                    {
                        IVsTaskItem2 taskItem = taskItems[0] as IVsTaskItem2;
                        if (taskItem != null)
                        {
                            int canDelete;
                            ErrorHandler.ThrowOnFailure(taskItem.CanDelete(out canDelete));
                            if (canDelete == 1)
                            {
                                ErrorHandler.ThrowOnFailure(taskItem.OnDeleteTask());
                            }
                        }
                    }

                } while (result == VSConstants.S_OK && fetched[0] == 1);

            }
            catch (COMException e)
            {
                Trace.WriteLine("Exception : " + e.Message);
                result = e.ErrorCode;
            }

            return result;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.LaunchDebugger"]/*' />
        /// <devdoc>
        /// Launch the debugger.
        /// </devdoc>
        /// <param name="serviceProvider">The service provider.</param>
        /// <param name="info">A reference to a VsDebugTargetInfo object.</param>
        public static void LaunchDebugger(IServiceProvider serviceProvider, VsDebugTargetInfo info)
        {
            Debug.Assert(serviceProvider != null, "Cannot launch the debugger on an empty service provider");
            if (serviceProvider == null)
            {
                throw new ArgumentException("serviceProvider");
            }

            info.cbSize = (uint)Marshal.SizeOf(info);
            IntPtr ptr = Marshal.AllocCoTaskMem((int)info.cbSize);
            Marshal.StructureToPtr(info, ptr, false);
            try
            {
                IVsDebugger d = serviceProvider.GetService(typeof(IVsDebugger)) as IVsDebugger;
                Debug.Assert(d != null, "Could not retrieve IVsDebugger from " + serviceProvider.GetType().Name);

                if (d == null)
                {
                    throw new InvalidOperationException();
                }
                
                ErrorHandler.ThrowOnFailure(d.LaunchDebugTargets(1, ptr));
            }
            catch (COMException e)
            {
                Trace.WriteLine("Exception : " + e.Message);
            }
            finally
            {
                if (ptr != IntPtr.Zero)
                {
                    Marshal.FreeCoTaskMem(ptr);
                }
            }
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetHierarchy"]/*' />
        /// <devdoc>
        /// Get reference to IVsHierarchy interface from project guid.
        /// </devdoc>
        /// <param name="site">The service provider.</param>
        /// <param name="projectGuid">A project guid.</param>
        ///<returns>A reference to an IVsHierarchy interface.</returns>
        public static IVsHierarchy GetHierarchy(IServiceProvider site, Guid projectGuid)
        {
            if (site == null)
            {
                throw new ArgumentException("site");
            }

            if (projectGuid == Guid.Empty)
            {
                throw new ArgumentException("projectGuid");
            }

            IVsHierarchy hierarchy = null;

            IVsSolution solution = site.GetService(typeof(SVsSolution)) as IVsSolution;

            if (solution == null)
            {
                throw new InvalidOperationException();
            }

            try
            {
                solution.GetProjectOfGuid(ref projectGuid, out hierarchy);
            }
            catch (COMException e)
            {
                Trace.WriteLine("Exception :" + e.Message);
            }
            // If the project is not loaded this is the exception thrown.
            catch (InvalidCastException e)
            {
                Trace.WriteLine("Exception :" + e.Message);
            }

            return hierarchy;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetUIHierarchyWindow"]/*' />
        /// <devdoc>
        /// Get reference to IVsUIHierarchyWindow interface from guid persistence slot.
        /// </devdoc>
        /// <param name="serviceProvider">The service provider.</param>
        /// <param name="guidPersistenceSlot">Unique identifier for a tool window created using IVsUIShell::CreateToolWindow. The caller of this method can use predefined identifiers that map to tool windows if those tool windows are known to the caller. </param>
        /// <returns>A reference to an IVsUIHierarchyWindow interface.</returns>
        public static IVsUIHierarchyWindow GetUIHierarchyWindow(IServiceProvider serviceProvider, Guid guidPersistenceSlot)
        {
            if (serviceProvider == null)
            {
                throw new ArgumentException("serviceProvider");
            }

            IVsUIShell shell = serviceProvider.GetService(typeof(SVsUIShell)) as IVsUIShell;

            Debug.Assert(shell != null, "Could not get the ui shell from the project");
            if (shell == null)
            {
                throw new InvalidOperationException();
            }

            object pvar = null;
            IVsWindowFrame frame = null;
            IVsUIHierarchyWindow uiHierarchyWindow = null;

            try
            {
                ErrorHandler.ThrowOnFailure(shell.FindToolWindow(0, ref guidPersistenceSlot, out frame));
                ErrorHandler.ThrowOnFailure(frame.GetProperty((int)__VSFPROPID.VSFPROPID_DocView, out pvar));
            }
            catch (COMException e)
            {
                Trace.WriteLine("Exception :" + e.Message);
            }
            finally
            {
                if (pvar != null)
                {
                    IVsWindowPane pane = (IVsWindowPane)pvar;

                    uiHierarchyWindow = (IVsUIHierarchyWindow)pane;
                }
            }

            return uiHierarchyWindow;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetOutputWindowPane"]/*' />
        /// <devdoc>
        /// Get reference to IVsOutputWindowPane interface from pane guid.
        /// </devdoc>
        /// <param name="serviceProvider">The service provider.</param>
        /// <param name="guidPane">A guid for the pane.</param>
        /// <returns>A reference to an IVsOutputWindowPane interface.</returns>
        public static IVsOutputWindowPane GetOutputWindowPane(IServiceProvider serviceProvider, Guid guidPane)
        {
            if (serviceProvider == null)
            {
                throw new ArgumentException("serviceProvider");
            }

            IVsOutputWindow outputWindow = serviceProvider.GetService(typeof(IVsOutputWindow)) as IVsOutputWindow;
            if (outputWindow == null)
            {
                throw new InvalidOperationException();
            }

            IVsOutputWindowPane outputWindowPane = null;
            try
            {
                ErrorHandler.ThrowOnFailure(outputWindow.GetPane(ref guidPane, out outputWindowPane));
            }
            catch (COMException e)
            {
                Trace.WriteLine("Exception :" + e.Message);
            }

            return outputWindowPane;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.GetDebugMode"]/*' />
        /// <devdoc>
        /// Get debug mode of the shell (design/break/shell).
        /// </devdoc>
        /// <param name="serviceProvider">The service provider.</param>
        /// <returns>A DBGMODE enumeration.</returns>
        public static DBGMODE GetDebugMode(IServiceProvider serviceProvider)
        {
            DBGMODE[] dbgmode = new DBGMODE[1] { DBGMODE.DBGMODE_Design };

            if (serviceProvider == null)
            {
                throw new ArgumentException("serviceProvider");
            }

            IVsDebugger debugger = serviceProvider.GetService(typeof(IVsDebugger)) as IVsDebugger;

            if (debugger == null)
            {
                throw new InvalidOperationException();
            }

            try
            {
                ErrorHandler.ThrowOnFailure(debugger.GetMode(dbgmode));
            }
            catch (COMException e)
            {
                Trace.WriteLine("Exception :" + e.Message);
            }

            return dbgmode[0];
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.IsVisualStudioInDesignMode"]/*' />
        /// <devdoc>
        /// Is Visual Studio in design mode.
        /// </devdoc>
        /// <param name="serviceProvider">The service provider.</param>
        /// <returns>true if visual studio is in design mode</returns>
        public static bool IsVisualStudioInDesignMode(IServiceProvider serviceProvider)
        {
            if (serviceProvider == null)
            {
                throw new ArgumentException("serviceProvider");
            }

            DBGMODE dbgMode = GetDebugMode(serviceProvider) & ~DBGMODE.DBGMODE_EncMask;

            return dbgMode == DBGMODE.DBGMODE_Design;
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.IsSolutionBuilding"]/*' />
        /// <devdoc>
        /// Is current solution building or deploying
        /// </devdoc>
        /// <param name="serviceProvider">The service provider</param>
        /// <returns>true if solution is building or deploying.</returns>
        public static bool IsSolutionBuilding(IServiceProvider serviceProvider)
        {
            if (serviceProvider == null)
            {
                throw new ArgumentException("serviceProvider");
            }

            IVsSolutionBuildManager solutionBuildManager = serviceProvider.GetService(typeof(IVsSolutionBuildManager)) as IVsSolutionBuildManager;

            if (solutionBuildManager == null)
            {
                throw new InvalidOperationException();
            }

            int returnValueAsInteger = 0;
            ErrorHandler.ThrowOnFailure(solutionBuildManager.QueryBuildManagerBusy(out returnValueAsInteger));
            return (returnValueAsInteger == 1);
        }

        /// <include file='doc\VsShellUtilities.uex' path='docs/doc[@for="VsShellUtilities.IsInAutomationFunction"]/*' />
        /// <devdoc>
        /// Is an extensibility object executing an automation function.
        /// </devdoc>
        /// <param name="serviceProvider">The service provider.</param>
        /// <returns>true if the extensiblity object is executing an automation function.</returns>
        public static bool IsInAutomationFunction(IServiceProvider serviceProvider)
        {
            if (serviceProvider == null)
            {
                throw new ArgumentException("serviceProvider");
            }

            IVsExtensibility extensibility = serviceProvider.GetService(typeof(IVsExtensibility)) as IVsExtensibility;

            if (extensibility == null)
            {
                throw new InvalidOperationException();
            }

            return (extensibility.IsInAutomationFunction() == 0) ? false : true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\TaskProvider.cs ===
//------------------------------------------------------------------------------
// <copyright file="TaskProvider.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell.Interop;
    using Microsoft.VisualStudio.TextManager.Interop;
    using Microsoft.Win32;
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.IO;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;

    using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
    using IServiceProvider = System.IServiceProvider;

    /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider"]' />
    /// <devdoc>
    ///     This class implements IVsTaskProvider.  It provides a 
    ///     framework-friendly way to define a package and its associated 
    ///     services.  
    /// </devdoc>
    [CLSCompliant(false)]
    [System.Runtime.InteropServices.ComVisible(true)]
    public class TaskProvider :

        IVsTaskProvider,
        IVsTaskProvider2,
        IVsTaskProvider3,
        IDisposable {

        internal IServiceProvider       provider;
        internal ImageList              imageList;
        internal IVsTaskList            taskList;
        internal uint                   taskListCookie;
        internal TaskCollection         tasks;
        internal StringCollection       subCategories;
        internal int                    suspended;
        internal bool                   dirty;
        internal Guid                   providerGuid;
        internal string                 name;
        internal bool                   alwaysVisible;
        internal bool                   disableAutoRoute;
        internal Guid                   toolbarGroup;
        internal int                    toolbarId;
        internal bool                   maintainOrder;
        private  bool                   inFinalRelease;


        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.TaskProvider"]/*' />
        public TaskProvider(IServiceProvider provider) {
            this.provider = provider;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.Finalize"]/*' />
        ~TaskProvider() {
            Dispose(false);
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.MaintainTaskOrder"]/*' />
        /// Determines whether or not the task list should maintain the task order given to it by the task provider.
        public bool MaintainInitialTaskOrder {
            get { return this.maintainOrder; }
            set { this.maintainOrder = value; }
        }

        /// The TaskList groups all tasks from multiple providers
        /// that provide the same GUID into one list.  
        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.ProviderGuid"]/*' />
        public Guid ProviderGuid {
            get { return this.providerGuid; }
            set { this.providerGuid = value; }
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.ProviderName"]/*' />
        /// Returns a localized human-readable name for this data provider.
        public string ProviderName {
            get { return this.name; }
            set { this.name = value; }
        }
        
        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.AlwaysVisible"]/*' />
        /// Provider is always visible in dropdown even if it has no tasks.
        public bool AlwaysVisible {
            get { return this.alwaysVisible; }
            set { this.alwaysVisible = value; }
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.DisableAutoRoute"]/*' />
        /// Provider is always visible in dropdown even if it has no tasks.
        public bool DisableAutoRoute
        {
            get { return this.disableAutoRoute; }
            set { this.disableAutoRoute = value; }
        }

        // Returns a group GUID and toolbar ID indicating which toolbar should be displayed when this
        // provider is active.  Set pguidGroup and pdwID to GUID_NULL and 0, respectively, to indicate
        // that this provider has no toolbar.  If you do provide a toolbar, you must include the
        // provider dropdown as the first group, by including this line in your CTC file:
        //     guidSHLMainMenu:IDG_VS_TASKLIST_PROVIDERLIST, <your toolbar's group>:<your toolbar menu ID>, 0x0100;
        // See vscommon\appid\inc\ShellCmdPlace.ctc for examples.
        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.ToolbarGroup"]/*' />
        public Guid ToolbarGroup {
            get { return this.toolbarGroup; }
            set { this.toolbarGroup = value; }
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.ToolbarId"]/*' />
        public int ToolbarId {
            get { return this.toolbarId; }
            set { this.toolbarId = value; }
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.ImageList"]/*' />
        public ImageList ImageList {
            get {
                return imageList;
            }
            set {
                if (imageList != value) {
                    imageList = value;
                    UpdateProviderInfo();
                }
            }
        }
        
        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.Subcategories"]/*' />
        public StringCollection Subcategories {
            get {
                if (subCategories == null) {
                    subCategories = new StringCollection();
                }
                return subCategories;
            }
        }
        
        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.Tasks"]/*' />
        public TaskCollection Tasks {
            get {
                if (tasks == null) {
                    tasks = new TaskCollection(this);
                }
                return tasks;
            }
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.VsTaskList"]/*' />
        protected virtual IVsTaskList VsTaskList {
            get {
                if (taskList == null) {
                    taskList = GetService(typeof(SVsTaskList)) as IVsTaskList;
                    if (taskList == null) {
                        throw new InvalidOperationException(SR.GetString(SR.General_MissingService, typeof(IVsTaskList).FullName));
                    }
                    NativeMethods.ThrowOnFailure( taskList.RegisterTaskProvider(this, out taskListCookie) );
                }

                return taskList;
            }
        }
        
        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.Dispose"]/*' />
        public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
        
        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.Dispose1"]/*' />
        [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        protected virtual void Dispose(bool disposing)
        {
			if (disposing)
			{
				if (tasks != null && !inFinalRelease)
				{
					tasks.Clear();
					tasks = null;
				}

				if (taskList != null)
				{
					try
					{
						// Don't check for the result code because here we can't do anything in case of failure
						taskList.UnregisterTaskProvider(taskListCookie);
					}
					catch (Exception)
					{ /* do nothing */ }
					taskList = null;
				}

				if (imageList != null)
				{
					imageList.Dispose();
					imageList = null;
				}
			}
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.GetService"]/*' />
        protected internal object GetService(Type serviceType) {
            if (provider != null) {
                return provider.GetService(serviceType);
            }
            return null;
        }
        
        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="Navigate"]/*' />
        /// <devdoc>
        ///     Navigates the document in the given task to the given logical view.
        /// </devdoc>
        public bool Navigate(Task task, Guid logicalView) {

            if (task == null) {
                throw new ArgumentNullException("task");
            }

            // Get the doc data for the task's document
            if (task.Document == null || task.Document.Length == 0) {
                return false;
            }

            IVsUIShellOpenDocument openDoc = GetService(typeof(IVsUIShellOpenDocument)) as IVsUIShellOpenDocument;
            if (openDoc == null) {
                return false;
            }

            IVsWindowFrame frame;
            IOleServiceProvider sp;
            IVsUIHierarchy hier;
            uint itemid;
            Guid logView = logicalView;

            if (NativeMethods.Failed(openDoc.OpenDocumentViaProject(task.Document, ref logView, out sp, out hier, out itemid, out frame)) || frame == null) {
                return false;
            }

            object docData;
            frame.GetProperty((int)__VSFPROPID.VSFPROPID_DocData, out docData);

            VsTextBuffer buffer = docData as VsTextBuffer;
            if (buffer == null) {
                IVsTextBufferProvider bufferProvider = docData as IVsTextBufferProvider;
                if (bufferProvider != null) {
                    IVsTextLines lines;
                    NativeMethods.ThrowOnFailure(bufferProvider.GetTextBuffer(out lines));
                    buffer = lines as VsTextBuffer;
                    Debug.Assert(buffer != null, "IVsTextLines does not implement IVsTextBuffer");
                    if (buffer == null) {
                        return false;
                    }
                }
            }

            // Finally, perform the navigation.
            IVsTextManager mgr = GetService(typeof(VsTextManagerClass)) as IVsTextManager;

            if (mgr == null) {
                return false;
            }

            int line = task.Line;
            // Buffer is zero based
            if (line > 0) line--;

            mgr.NavigateToLineAndColumn(buffer, ref logicalView, line, 0, line, 0);
            return true;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.Refresh"]/*' />
        public void Refresh() {
            if (suspended == 0) {
                dirty = false;
                NativeMethods.ThrowOnFailure( VsTaskList.RefreshTasks(taskListCookie) );
            } else {
                dirty = true;
            }
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.Show"]/*' />
        public virtual void Show() {
            IUIService uis = GetService(typeof(IUIService)) as IUIService;
            if (uis != null) {
                uis.ShowToolWindow(new Guid(EnvDTE.Constants.vsWindowKindTaskList));
            }
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.SuspendRefresh"]/*' />
        /// <devdoc>
        /// SuspendRefresh stops refresh of the task list from happening until ResumeRefresh
        /// is called.  It supports nested Suspend/Resume.  The reason for this method is because
        /// by default, every change to the TaskCollection results in a call to Refresh, and
        /// the task list updates synchronously when Refresh() is called, so this allows 
        /// batching of the updates to occur which results in cleaner UI experience.  For
        /// example, without this refreshing a long task list will cause the task list scrollbar 
        /// to shrink and grow in a very visible way. By calling Suspend/Resume instead the
        /// the update of the a longs task list happens with very little visual noise.
        /// </devdoc>
        public void SuspendRefresh()
        {
            if (suspended < int.MaxValue)
                suspended++;
            else
                Debug.Fail("TaskProvider.SuspendRefresh() was called int.MaxValue times.\nYou may want to change the counter to something bigger then an int");
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.ResumeRefresh"]/*' />
        public void ResumeRefresh() {
            if (suspended > 0) {
                suspended--;
                if (suspended == 0 && dirty) {
                    Refresh();
                }
            }
        }

        private void TasksChanged() {
            Refresh();
        }

        private void UpdateProviderInfo() {
            if (taskList != null) {
                NativeMethods.ThrowOnFailure( taskList.UpdateProviderInfo(taskListCookie) );
            }
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider.EnumTaskItems"]/*' />
        /// <internalonly/>
        int IVsTaskProvider.EnumTaskItems(out IVsEnumTaskItems items) {
            items = new VsEnumTaskItems(Tasks);
            return NativeMethods.S_OK;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider.ImageList"]/*' />
        /// <internalonly/>
        int IVsTaskProvider.ImageList(out IntPtr himagelist) {
            if (ImageList != null) {
                himagelist = ImageList.Handle;
            }
            else {
                himagelist = IntPtr.Zero;
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider.OnTaskListFinalRelease"]/*' />
        /// <internalonly/>
        int IVsTaskProvider.OnTaskListFinalRelease(IVsTaskList taskList) {
            inFinalRelease = true;
            Dispose(true);
            return NativeMethods.S_OK;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider.ReRegistrationKey"]/*' />
        /// <internalonly/>
        int IVsTaskProvider.ReRegistrationKey(out string key) {
            key = string.Format(System.Globalization.CultureInfo.InvariantCulture, "{0}.{1}", this.GetType().Name, this.GetHashCode());
            return NativeMethods.S_OK;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider.SubcategoryList"]/*' />
        /// <internalonly/>
        int IVsTaskProvider.SubcategoryList(uint cbstr, string[] rgbstr, out uint cnt) {
            if (subCategories != null) {
                cnt = (uint)subCategories.Count;

                for (int i = 0; i < cbstr && i < subCategories.Count; i++) {
                    rgbstr[i] = subCategories[i];
                }

            }
            else {
                cnt = 0;
            }
            return NativeMethods.S_OK;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider2.EnumTaskItems"]/*' />
        /// <internalonly/>
        int IVsTaskProvider2.EnumTaskItems(out IVsEnumTaskItems items) {
            return ((IVsTaskProvider)this).EnumTaskItems(out items);
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider2.ImageList"]/*' />
        /// <internalonly/>
        int IVsTaskProvider2.ImageList(out IntPtr himagelist) {
            return ((IVsTaskProvider)this).ImageList(out himagelist);
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider2.OnTaskListFinalRelease"]/*' />
        /// <internalonly/>
        int IVsTaskProvider2.OnTaskListFinalRelease(IVsTaskList taskList) {
            return ((IVsTaskProvider)this).OnTaskListFinalRelease(taskList);
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider2.ReRegistrationKey"]/*' />
        /// <internalonly/>
        int IVsTaskProvider2.ReRegistrationKey(out string key) {
            return ((IVsTaskProvider)this).ReRegistrationKey(out key);
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider2.SubcategoryList"]/*' />
        /// <internalonly/>
        int IVsTaskProvider2.SubcategoryList(uint cbstr, string[] rgbstr, out uint cnt) {
            return ((IVsTaskProvider)this).SubcategoryList(cbstr, rgbstr, out cnt);
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider2.MaintainInitialTaskOrder"]/*' />
        /// <internalonly/>
        int IVsTaskProvider2.MaintainInitialTaskOrder(out int fMaintainOrder) {
            fMaintainOrder = this.maintainOrder ? 1 : 0;
            return NativeMethods.S_OK;
        }

        // Returns the behavior flags for this provider.
        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider3.GetProviderFlags"]/*' />
        /// <internalonly/>
        int IVsTaskProvider3.GetProviderFlags(out uint tpfFlags){
            tpfFlags = (this.alwaysVisible) ? (uint)__VSTASKPROVIDERFLAGS.TPF_ALWAYSVISIBLE : 0;
            if (disableAutoRoute)
                tpfFlags |= (uint)__VSTASKPROVIDERFLAGS.TPF_NOAUTOROUTING;
            return NativeMethods.S_OK; 
        }
        
        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider3.GetProviderName"]/*' />
        /// <internalonly/>
        int IVsTaskProvider3.GetProviderName(out string pbstrName){
            pbstrName = this.name;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider3.GetProviderGuid"]/*' />
        /// <devdoc>
        /// Returns a unique ID for this provider.  This is used to persist and restore per-provider
        /// data managed by the task list, such as user customizations of column width and order.
        /// </devdoc>
        /// <internalonly/>
        int IVsTaskProvider3.GetProviderGuid(out Guid pguidProvider) {
            pguidProvider = this.GetType().GUID;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider.IVsTaskProvider3.GetProviderToolbar"]/*' />
        /// <internalonly/>
        int IVsTaskProvider3.GetProviderToolbar(out Guid pguidGroup, out uint pdwID) {
            pguidGroup = this.toolbarGroup;
            pdwID = (uint)this.toolbarId;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IVsTaskProvider3.GetColumnCount"]/*' />
        // Returns the total number of columns supported by this provider, including columns that are
        // not visible by default.
        int IVsTaskProvider3.GetColumnCount(out int count) {
            // todo: provide a way to define custom columns
            // right now it is getting default behavior for free.
            count = 0;
            return NativeMethods.E_FAIL;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IVsTaskProvider3.GetColumn"]/*' />
        // Gets the definition of an indexed column (0 <= iColumn < nColumns).
        int IVsTaskProvider3.GetColumn(int iColumn, VSTASKCOLUMN[] pColumn) {
            return NativeMethods.E_FAIL;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IVsTaskProvider3.GetSurrogateProviderGuid"]/*' />
        int IVsTaskProvider3.GetSurrogateProviderGuid(out System.Guid guid) {
            guid = Guid.Empty;
            return NativeMethods.E_NOTIMPL;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IVsTaskProvider3.OnBeginTaskEdit"]/*' />
        // Called when the user begins editing a task in-place.  Providers may want to avoid scrolling
        // the tasklist or changing the selection during editing, since these actions can force in-
        // place edit mode to be canceled abruptly.
        int IVsTaskProvider3.OnBeginTaskEdit(IVsTaskItem item) {
            return NativeMethods.S_OK;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IVsTaskProvider3.OnEndTaskEdit"]/*' />
        // Called when the user finishes editing a task in-place.  fCommitChanges indicates whether the
        // user chose to commit the changes or discard them.  This method may set *pfAllowChanges to
        // FALSE to disallow the user from exiting edit mode.  If fCommitChanges is TRUE, the changes
        // will have already been persisted down to the task item.
        int IVsTaskProvider3.OnEndTaskEdit(IVsTaskItem item, int fCommitChanges, out int fAllowChanges) {
            fAllowChanges = 1;
            return NativeMethods.S_OK;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection"]/*' />
        public sealed class TaskCollection :

            IList {

            private TaskProvider owner;
            private ArrayList list;

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.TaskCollection"]/*' />
            public TaskCollection(TaskProvider owner) {
                this.owner = owner;
                this.list = new ArrayList();
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.Count"]/*' />
            public int Count {
                get {
                    return list.Count;
                }
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.this"]/*' />
            public Task this[int index] {
                get {
                    return (Task)list[index];
                }
                set {
                    if (value == null) {
                        throw new ArgumentNullException("value");
                    }
                    Task t = this[index];
                    if (t != null) {
                        t.Owner = null;
                    }
                    list[index] = value;
                    value.Owner = owner;
                    owner.TasksChanged();
                }
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.Add"]/*' />
            public int Add(Task task) {
                if (task == null) {
                    throw new ArgumentNullException("task");
                }
                int index = list.Add(task);
                task.Owner = owner;
                owner.TasksChanged();
                return index;
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.Clear"]/*' />
            public void Clear() {
                if (list.Count > 0) {
                    foreach (Task t in list) {
                        t.Owner = null;
                    }
                    list.Clear();
                    owner.TasksChanged();
                }
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.Contains"]/*' />
            public bool Contains(Task task) {
                return list.Contains(task);
            }

            private void EnsureTask(object obj) {
                if (!(obj is Task)) {
                    throw new ArgumentException(SR.GetString(SR.General_InvalidType, typeof(Task).FullName), "obj");
                }
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.GetEnumerator"]/*' />
            public IEnumerator GetEnumerator() {
                return list.GetEnumerator();
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IndexOf"]/*' />
            public int IndexOf(Task task) {
                return list.IndexOf(task);
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.Insert"]/*' />
            public void Insert(int index, Task task) {
                if (task == null) {
                    throw new ArgumentNullException("task");
                }
                list.Insert(index, task);
                task.Owner = owner;
                owner.TasksChanged();
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.Remove"]/*' />
            public void Remove(Task task) {
                if (task == null) {
                    throw new ArgumentNullException("task");
                }
                list.Remove(task);
                task.Owner = null;
                owner.TasksChanged();
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.RemoveAt"]/*' />
            public void RemoveAt(int index) {
                Task t = this[index];
                t.Owner = null;
                list.RemoveAt(index);
                owner.TasksChanged();
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.ICollection.CopyTo"]/*' />
            /// <internalonly/>
            void ICollection.CopyTo(Array array, int index) {
                list.CopyTo(array, index);
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.ICollection.IsSynchronized"]/*' />
            /// <internalonly/>
            bool ICollection.IsSynchronized {
                get {
                    return false;
                }
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.ICollection.SyncRoot"]/*' />
            /// <internalonly/>
            object ICollection.SyncRoot {
                get {
                    return this;
                }
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IList.IsFixedSize"]/*' />
            /// <internalonly/>
            bool IList.IsFixedSize {
                get {
                    return false;
                }
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IList.IsReadOnly"]/*' />
            /// <internalonly/>
            bool IList.IsReadOnly {
                get {
                    return false;
                }
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IList.this"]/*' />
            /// <internalonly/>
            object IList.this[int index] {
                get {
                    return this[index];
                }
                set {
                    EnsureTask(value);
                    this[index] = (Task)value;
                }
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IList.Add"]/*' />
            /// <internalonly/>
            int IList.Add(object obj) {
                EnsureTask(obj);
                return Add((Task)obj);
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IList.Clear"]/*' />
            /// <internalonly/>
            void IList.Clear() {
                Clear();
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IList.Contains"]/*' />
            /// <internalonly/>
            bool IList.Contains(object obj) {
                EnsureTask(obj);
                return Contains((Task)obj);
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IList.IndexOf"]/*' />
            /// <internalonly/>
            int IList.IndexOf(object obj) {
                EnsureTask(obj);
                return IndexOf((Task)obj);
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IList.Insert"]/*' />
            /// <internalonly/>
            void IList.Insert(int index, object obj) {
                EnsureTask(obj);
                Insert(index, (Task)obj);
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IList.Remove"]/*' />
            /// <internalonly/>
            void IList.Remove(object obj) {
                EnsureTask(obj);
                Remove((Task)obj);
            }

            /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskCollection.IList.RemoveAt"]/*' />
            /// <internalonly/>
            void IList.RemoveAt(int index) {
                RemoveAt(index);
            }
        }

        private class VsEnumTaskItems : IVsEnumTaskItems {

            private TaskCollection tasks;
            private IEnumerator taskEnum;

            internal VsEnumTaskItems(TaskCollection tasks) {
                this.tasks = tasks;
                this.taskEnum = tasks.GetEnumerator();
            }

            public int Clone(out IVsEnumTaskItems newItems) {
                newItems = new VsEnumTaskItems(tasks);
                return NativeMethods.S_OK;
            }

            public int Next(uint celt, IVsTaskItem[] items, uint[] pceltFetched) {
                if (items == null || items.Length < celt)
                    throw new ArgumentException(String.Empty, "items");

                uint fetched = 0;

                while (fetched < celt && taskEnum.MoveNext()) {
                    items[fetched++] = (IVsTaskItem)taskEnum.Current;
                }

                if (pceltFetched != null && pceltFetched.Length > 0) {
                    pceltFetched[0] = fetched;
                }

                if (fetched == 0 && celt > 0) {
                    return NativeMethods.S_FALSE;
                }

                return NativeMethods.S_OK;
            }

            public int Reset() {
                taskEnum.Reset();
                return NativeMethods.S_OK;
            }

            public int Skip(uint count) {
                while (count != 0) {
                    count--;
                    if (!taskEnum.MoveNext() && count != 0) {
                        return NativeMethods.S_FALSE;
                    }
                }

                return NativeMethods.S_OK;
            }
        }
    }


    // <include file='doc\TaskProvider.uex' path='docs/doc[@for="TaskProvider"]' />
    /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="ErrorListProvider"]/*' />
    /// <devdoc>
    /// Use this provider to provide tasks for the Visual Studio Error List
    /// window. This task provider also has a Guid which is returned from
    /// </devdoc>
    [CLSCompliant(false)]
    public class ErrorListProvider : TaskProvider {
        IVsErrorList errorList;


        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="ErrorListProvider.TaskProvider"]/*' />
        public ErrorListProvider(IServiceProvider provider) : base(provider) {
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="ErrorListProvider.Finalize"]/*' />
        ~ErrorListProvider() {
            Dispose(false);
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="ErrorListProvider.Dispose1"]/*' />
        protected override void Dispose(bool disposing) {
            base.Dispose(disposing);
            this.errorList = null;
        }

        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="ErrorListProvider.VsTaskList"]/*' />
        protected override IVsTaskList VsTaskList {
            get {
                if (taskList == null) {

                    this.errorList = GetService(typeof(SVsErrorList)) as IVsErrorList;
                    if (errorList == null) {
                        return base.VsTaskList;
                    }
                    this.taskList = errorList as IVsTaskList;
                    if (taskList == null) {
                        throw new InvalidOperationException(SR.GetString(SR.General_MissingService, typeof(IVsTaskList).FullName));
                    }
                    NativeMethods.ThrowOnFailure(taskList.RegisterTaskProvider(this, out taskListCookie));
                }

                return taskList;
            }
        }

        // Activates the window and makes it visible.  This should only be called
        // at the completion of a build process.
        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="ErrorListProvider.BringToFront"]/*' />
        public void BringToFront() {
            IVsTaskList tasklist = this.VsTaskList;
            NativeMethods.ThrowOnFailure( errorList.BringToFront() );
            tasklist = null;
        }

        // Forces the error toggle "on", so that errors are visible in the list.  Warnings and
        // informational messages are not affected.
        /// <include file='doc\TaskProvider.uex' path='docs/doc[@for="ErrorListProvider.ForceShowErrors"]/*' />
        public void ForceShowErrors() {
            IVsTaskList tasklist = this.VsTaskList;
            NativeMethods.ThrowOnFailure( errorList.ForceShowErrors() );
            tasklist = null;
        }
    
        /// <include file='doc\ErrorListProvider.uex' path='docs/doc[@for="ErrorListProvider.Show"]/*' />
        public override void Show() {
            IUIService uis = GetService(typeof(IUIService)) as IUIService;
            if (uis != null) {
                Guid errorList = new Guid(EnvDTE80.WindowKinds.vsWindowKindErrorList);
                uis.ShowToolWindow(errorList);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\VsMenus.cs ===
//--------------------------------------------------------------------------
//  <copyright file="VsCommands.cs" company="Microsoft">
//      Copyright (c) Microsoft Corporation.  All rights reserved.
//  </copyright>
//  <summary>
//  </summary>
//--------------------------------------------------------------------------
using System;

namespace Microsoft.VisualStudio.Shell
{

    /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus"]/*' />
    public class VsMenus
	{
		// menu command guids.
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.guidStandardCommandSet97"]/*' />
        public static Guid guidStandardCommandSet97 = new Guid("5efc7975-14bc-11cf-9b2b-00aa00573819");
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.guidStandardCommandSet2K"]/*' />
        public static Guid guidStandardCommandSet2K = new Guid("1496A755-94DE-11D0-8C3F-00C04FC2AAE2");
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.guidVsVbaPkg"]/*' />
        public static Guid guidVsVbaPkg = new Guid(0xa659f1b3, 0xad34, 0x11d1, 0xab, 0xad, 0x0, 0x80, 0xc7, 0xb8, 0x9c, 0x95);
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.guidSHLMainMenu"]/*' />
        public static Guid guidSHLMainMenu = new Guid(0xd309f791, 0x903f, 0x11d0, 0x9e, 0xfc, 0x00, 0xa0, 0xc9, 0x11, 0x00, 0x4f);
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.guidVSUISet"]/*' />
        public static Guid guidVSUISet = new Guid("60481700-078b-11d1-aaf8-00a0c9055a90");
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.guidCciSet"]/*' />
        public static Guid guidCciSet = new Guid("2805D6BD-47A8-4944-8002-4e29b9ac2269");
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.guidVsUIHierarchyWindowCmds"]/*' />
        public static Guid guidVsUIHierarchyWindowCmds = new Guid("60481700-078B-11D1-AAF8-00A0C9055A90");
		
        // Special Menus.
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.IDM_VS_CTXT_CODEWIN"]/*' />
        public const int IDM_VS_CTXT_CODEWIN = 0x040D;
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.IDM_VS_CTXT_ITEMNODE"]/*' />
        public const int IDM_VS_CTXT_ITEMNODE = 0x0430;
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.IDM_VS_CTXT_PROJNODE"]/*' />
        public const int IDM_VS_CTXT_PROJNODE = 0x0402;
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.IDM_VS_CTXT_REFERENCEROOT"]/*' />
        public const int IDM_VS_CTXT_REFERENCEROOT = 0x0450;
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.IDM_VS_CTXT_REFERENCE"]/*' />
        public const int IDM_VS_CTXT_REFERENCE = 0x0451;
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.IDM_VS_CTXT_FOLDERNODE"]/*' />
        public const int IDM_VS_CTXT_FOLDERNODE = 0x0431;
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.IDM_VS_CTXT_NOCOMMANDS"]/*' />
        public const int IDM_VS_CTXT_NOCOMMANDS = 0x041A;
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.VSCmdOptQueryParameterList"]/*' />
        public const int VSCmdOptQueryParameterList = 1;
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.IDM_VS_CTXT_XPROJ_MULTIITEM"]/*' />
        public const int IDM_VS_CTXT_XPROJ_MULTIITEM = 0x0419;
        /// <include file='doc\VsMenus.uex' path='docs/doc[@for="VsMenus.IDM_VS_CTXT_XPROJ_PROJITEM"]/*' />
        public const int IDM_VS_CTXT_XPROJ_PROJITEM = 0x0417;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\VSConstants.cs ===
//------------------------------------------------------------------------------
// <copyright file="VSConstants.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio {

using System;
using System.Runtime.InteropServices;
using Microsoft.VisualStudio.TextManager.Interop;
using Microsoft.VisualStudio.OLE.Interop;



    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants"]/*' />
    [CLSCompliant(false)]
    public sealed class VSConstants {

    private VSConstants() {}

    // VS Command ID's

    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.cmdidToolsOptions"]/*' />
        public const int cmdidToolsOptions    = 264;

        /// Common OLE GUIDs
        /// <include file='doc\VSContants.uex' path='docs/doc[@for="VSConstants.IID_IUnknown"]/*' />
        public static readonly Guid IID_IUnknown = new Guid("{00000000-0000-0000-C000-000000000046}");                    


    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_VSStandardCommandSet97"]/*' />
        /// <summary>This GUID identifies the standard set of commands known by VisualStudio 97 (version 6).</summary>
        public static readonly Guid GUID_VSStandardCommandSet97 = new Guid("{5EFC7975-14BC-11CF-9B2B-00AA00573819}");

    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VSStd97CmdID"]/*' />
        [Guid("5EFC7975-14BC-11CF-9B2B-00AA00573819")]
        public enum VSStd97CmdID
        {
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AlignBottom"]/*' />
            AlignBottom = 1,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AlignHorizontalCenters"]/*' />
            AlignHorizontalCenters = 2,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AlignLeft"]/*' />
            AlignLeft = 3,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AlignRight"]/*' />
            AlignRight = 4,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AlignToGrid"]/*' />
            AlignToGrid = 5,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AlignTop"]/*' />
            AlignTop = 6,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AlignVerticalCenters"]/*' />
            AlignVerticalCenters = 7,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ArrangeBottom"]/*' />
            ArrangeBottom = 8,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ArrangeRight"]/*' />
            ArrangeRight = 9,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BringForward"]/*' />
            BringForward = 10,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BringToFront"]/*' />
            BringToFront = 11,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CenterHorizontally"]/*' />
            CenterHorizontally = 12,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CenterVertically"]/*' />
            CenterVertically = 13,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Code"]/*' />
            Code = 14,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Copy"]/*' />
            Copy = 15,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Cut"]/*' />
            Cut = 16,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Delete"]/*' />
            Delete = 17,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FontName"]/*' />
            FontName = 18,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FontNameGetList"]/*' />
            FontNameGetList = 500,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FontSize"]/*' />
            FontSize = 19,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FontSizeGetList"]/*' />
            FontSizeGetList = 501,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Group"]/*' />
            Group = 20,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.HorizSpaceConcatenate"]/*' />
            HorizSpaceConcatenate = 21,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.HorizSpaceDecrease"]/*' />
            HorizSpaceDecrease = 22,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.HorizSpaceIncrease"]/*' />
            HorizSpaceIncrease = 23,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.HorizSpaceMakeEqual"]/*' />
            HorizSpaceMakeEqual = 24,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.LockControls"]/*' />
            LockControls = 369,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.InsertObject"]/*' />
            InsertObject = 25,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Paste"]/*' />
            Paste = 26,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Print"]/*' />
            Print = 27,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Properties"]/*' />
            Properties = 28,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Redo"]/*' />
            Redo = 29,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MultiLevelRedo"]/*' />
            MultiLevelRedo = 30,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SelectAll"]/*' />
            SelectAll = 31,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SendBackward"]/*' />
            SendBackward = 32,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SendToBack"]/*' />
            SendToBack = 33,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowTable"]/*' />
            ShowTable = 34,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SizeToControl"]/*' />
            SizeToControl = 35,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SizeToControlHeight"]/*' />
            SizeToControlHeight = 36,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SizeToControlWidth"]/*' />
            SizeToControlWidth = 37,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SizeToFit"]/*' />
            SizeToFit = 38,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SizeToGrid"]/*' />
            SizeToGrid = 39,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SnapToGrid"]/*' />
            SnapToGrid = 40,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TabOrder"]/*' />
            TabOrder = 41,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Toolbox"]/*' />
            Toolbox = 42,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Undo"]/*' />
            Undo = 43,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MultiLevelUndo"]/*' />
            MultiLevelUndo = 44,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Ungroup"]/*' />
            Ungroup = 45,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.VertSpaceConcatenate"]/*' />
            VertSpaceConcatenate = 46,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.VertSpaceDecrease"]/*' />
            VertSpaceDecrease = 47,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.VertSpaceIncrease"]/*' />
            VertSpaceIncrease = 48,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.VertSpaceMakeEqual"]/*' />
            VertSpaceMakeEqual = 49,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ZoomPercent"]/*' />
            ZoomPercent = 50,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BackColor"]/*' />
            BackColor = 51,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Bold"]/*' />
            Bold = 52,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BorderColor"]/*' />
            BorderColor = 53,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BorderDashDot"]/*' />
            BorderDashDot = 54,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BorderDashDotDot"]/*' />
            BorderDashDotDot = 55,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BorderDashes"]/*' />
            BorderDashes = 56,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BorderDots"]/*' />
            BorderDots = 57,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BorderShortDashes"]/*' />
            BorderShortDashes = 58,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BorderSolid"]/*' />
            BorderSolid = 59,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BorderSparseDots"]/*' />
            BorderSparseDots = 60,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BorderWidth1"]/*' />
            BorderWidth1 = 61,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BorderWidth2"]/*' />
            BorderWidth2 = 62,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BorderWidth3"]/*' />
            BorderWidth3 = 63,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BorderWidth4"]/*' />
            BorderWidth4 = 64,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BorderWidth5"]/*' />
            BorderWidth5 = 65,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BorderWidth6"]/*' />
            BorderWidth6 = 66,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BorderWidthHairline"]/*' />
            BorderWidthHairline = 67,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Flat"]/*' />
            Flat = 68,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ForeColor"]/*' />
            ForeColor = 69,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Italic"]/*' />
            Italic = 70,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.JustifyCenter"]/*' />
            JustifyCenter = 71,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.JustifyGeneral"]/*' />
            JustifyGeneral = 72,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.JustifyLeft"]/*' />
            JustifyLeft = 73,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.JustifyRight"]/*' />
            JustifyRight = 74,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Raised"]/*' />
            Raised = 75,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Sunken"]/*' />
            Sunken = 76,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Underline"]/*' />
            Underline = 77,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Chiseled"]/*' />
            Chiseled = 78,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Etched"]/*' />
            Etched = 79,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Shadowed"]/*' />
            Shadowed = 80,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CompDebug1"]/*' />
            CompDebug1 = 81,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CompDebug2"]/*' />
            CompDebug2 = 82,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CompDebug3"]/*' />
            CompDebug3 = 83,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CompDebug4"]/*' />
            CompDebug4 = 84,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CompDebug5"]/*' />
            CompDebug5 = 85,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CompDebug6"]/*' />
            CompDebug6 = 86,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CompDebug7"]/*' />
            CompDebug7 = 87,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CompDebug8"]/*' />
            CompDebug8 = 88,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CompDebug9"]/*' />
            CompDebug9 = 89,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CompDebug10"]/*' />
            CompDebug10 = 90,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CompDebug11"]/*' />
            CompDebug11 = 91,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CompDebug12"]/*' />
            CompDebug12 = 92,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CompDebug13"]/*' />
            CompDebug13 = 93,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CompDebug14"]/*' />
            CompDebug14 = 94,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CompDebug15"]/*' />
            CompDebug15 = 95,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExistingSchemaEdit"]/*' />
            ExistingSchemaEdit = 96,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Find"]/*' />
            Find = 97,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.GetZoom"]/*' />
            GetZoom = 98,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.QueryOpenDesign"]/*' />
            QueryOpenDesign = 99,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.QueryOpenNew"]/*' />
            QueryOpenNew = 100,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SingleTableDesign"]/*' />
            SingleTableDesign = 101,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SingleTableNew"]/*' />
            SingleTableNew = 102,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowGrid"]/*' />
            ShowGrid = 103,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.NewTable"]/*' />
            NewTable = 104,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CollapsedView"]/*' />
            CollapsedView = 105,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FieldView"]/*' />
            FieldView = 106,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.VerifySQL"]/*' />
            VerifySQL = 107,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.HideTable"]/*' />
            HideTable = 108,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PrimaryKey"]/*' />
            PrimaryKey = 109,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Save"]/*' />
            Save = 110,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SaveAs"]/*' />
            SaveAs = 111,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SortAscending"]/*' />
            SortAscending = 112,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SortDescending"]/*' />
            SortDescending = 113,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AppendQuery"]/*' />
            AppendQuery = 114,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CrosstabQuery"]/*' />
            CrosstabQuery = 115,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DeleteQuery"]/*' />
            DeleteQuery = 116,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MakeTableQuery"]/*' />
            MakeTableQuery = 117,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SelectQuery"]/*' />
            SelectQuery = 118,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.UpdateQuery"]/*' />
            UpdateQuery = 119,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Parameters"]/*' />
            Parameters = 120,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Totals"]/*' />
            Totals = 121,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewCollapsed"]/*' />
            ViewCollapsed = 122,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewFieldList"]/*' />
            ViewFieldList = 123,


            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewKeys"]/*' />
            ViewKeys = 124,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewGrid"]/*' />
            ViewGrid = 125,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.InnerJoin"]/*' />
            InnerJoin = 126,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RightOuterJoin"]/*' />
            RightOuterJoin = 127,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.LeftOuterJoin"]/*' />
            LeftOuterJoin = 128,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FullOuterJoin"]/*' />
            FullOuterJoin = 129,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.UnionJoin"]/*' />
            UnionJoin = 130,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowSQLPane"]/*' />
            ShowSQLPane = 131,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowGraphicalPane"]/*' />
            ShowGraphicalPane = 132,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowDataPane"]/*' />
            ShowDataPane = 133,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowQBEPane"]/*' />
            ShowQBEPane = 134,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SelectAllFields"]/*' />
            SelectAllFields = 135,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OLEObjectMenuButton"]/*' />
            OLEObjectMenuButton = 136,

            // ids on the ole verbs menu - these must be sequential ie verblist0-verblist9
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ObjectVerbList0"]/*' />
            ObjectVerbList0 = 137,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ObjectVerbList1"]/*' />
            ObjectVerbList1 = 138,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ObjectVerbList2"]/*' />
            ObjectVerbList2 = 139,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ObjectVerbList3"]/*' />
            ObjectVerbList3 = 140,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ObjectVerbList4"]/*' />
            ObjectVerbList4 = 141,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ObjectVerbList5"]/*' />
            ObjectVerbList5 = 142,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ObjectVerbList6"]/*' />
            ObjectVerbList6 = 143,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ObjectVerbList7"]/*' />
            ObjectVerbList7 = 144,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ObjectVerbList8"]/*' />
            ObjectVerbList8 = 145,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ObjectVerbList9"]/*' />
            ObjectVerbList9 = 146,  // Unused on purpose!

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ConvertObject"]/*' />
            ConvertObject = 147,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CustomControl"]/*' />
            CustomControl = 148,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CustomizeItem"]/*' />
            CustomizeItem = 149,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Rename"]/*' />
            Rename = 150,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Import"]/*' />
            Import = 151,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.NewPage"]/*' />
            NewPage = 152,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Move"]/*' />
            Move = 153,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Cancel"]/*' />
            Cancel = 154,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Font"]/*' />
            Font = 155,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExpandLinks"]/*' />
            ExpandLinks = 156,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExpandImages"]/*' />
            ExpandImages = 157,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExpandPages"]/*' />
            ExpandPages = 158,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RefocusDiagram"]/*' />
            RefocusDiagram = 159,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TransitiveClosure"]/*' />
            TransitiveClosure = 160,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CenterDiagram"]/*' />
            CenterDiagram = 161,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ZoomIn"]/*' />
            ZoomIn = 162,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ZoomOut"]/*' />
            ZoomOut = 163,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RemoveFilter"]/*' />
            RemoveFilter = 164,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.HidePane"]/*' />
            HidePane = 165,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DeleteTable"]/*' />
            DeleteTable = 166,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DeleteRelationship"]/*' />
            DeleteRelationship = 167,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Remove"]/*' />
            Remove = 168,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.JoinLeftAll"]/*' />
            JoinLeftAll = 169,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.JoinRightAll"]/*' />
            JoinRightAll = 170,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AddToOutput"]/*' />
            AddToOutput = 171,      // Add selected fields to query output
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OtherQuery"]/*' />
            OtherQuery = 172,      // change query type to 'other'
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.GenerateChangeScript"]/*' />
            GenerateChangeScript = 173,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SaveSelection"]/*' />
            SaveSelection = 174,     // Save current selection
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutojoinCurrent"]/*' />
            AutojoinCurrent = 175,     // Autojoin current tables
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutojoinAlways"]/*' />
            AutojoinAlways = 176,     // Toggle Autojoin state
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.EditPage"]/*' />
            EditPage = 177,     // Launch editor for url
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewLinks"]/*' />
            ViewLinks = 178,     // Launch new webscope for url
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Stop"]/*' />
            Stop = 179,     // Stope webscope rendering
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Pause"]/*' />
            Pause = 180,     // Pause webscope rendering
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Resume"]/*' />
            Resume = 181,     // Resume webscope rendering
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FilterDiagram"]/*' />
            FilterDiagram = 182,     // Filter webscope diagram
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowAllObjects"]/*' />
            ShowAllObjects = 183,     // Show All objects in webscope diagram
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowApplications"]/*' />
            ShowApplications = 184,     // Show Application objects in webscope diagram
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowOtherObjects"]/*' />
            ShowOtherObjects = 185,     // Show other objects in webscope diagram
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowPrimRelationships"]/*' />
            ShowPrimRelationships = 186,     // Show primary relationships
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Expand"]/*' />
            Expand = 187,     // Expand links
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Collapse"]/*' />
            Collapse = 188,     // Collapse links
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Refresh"]/*' />
            Refresh = 189,     // Refresh Webscope diagram
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Layout"]/*' />
            Layout = 190,     // Layout websope diagram
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowResources"]/*' />
            ShowResources = 191,     // Show resouce objects in webscope diagram
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.InsertHTMLWizard"]/*' />
            InsertHTMLWizard = 192,     // Insert HTML using a Wizard
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowDownloads"]/*' />
            ShowDownloads = 193,     // Show download objects in webscope diagram
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowExternals"]/*' />
            ShowExternals = 194,     // Show external objects in webscope diagram
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowInBoundLinks"]/*' />
            ShowInBoundLinks = 195,     // Show inbound links in webscope diagram
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowOutBoundLinks"]/*' />
            ShowOutBoundLinks = 196,     // Show out bound links in webscope diagram
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowInAndOutBoundLinks"]/*' />
            ShowInAndOutBoundLinks = 197,     // Show in and out bound links in webscope diagram
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Preview"]/*' />
            Preview = 198,     // Preview page
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Open"]/*' />
            Open = 261,     // Open
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OpenWith"]/*' />
            OpenWith = 199,     // Open with
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowPages"]/*' />
            ShowPages = 200,     // Show HTML pages
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RunQuery"]/*' />
            RunQuery = 201,      // Runs a query
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ClearQuery"]/*' />
            ClearQuery = 202,      // Clears the query's associated cursor
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RecordFirst"]/*' />
            RecordFirst = 203,      // Go to first record in set
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RecordLast"]/*' />
            RecordLast = 204,      // Go to last record in set
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RecordNext"]/*' />
            RecordNext = 205,      // Go to next record in set
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RecordPrevious"]/*' />
            RecordPrevious = 206,      // Go to previous record in set
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RecordGoto"]/*' />
            RecordGoto = 207,      // Go to record via dialog
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RecordNew"]/*' />
            RecordNew = 208,      // Add a record to set

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.InsertNewMenu"]/*' />
            InsertNewMenu = 209,     // menu designer
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.InsertSeparator"]/*' />
            InsertSeparator = 210,     // menu designer
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.EditMenuNames"]/*' />
            EditMenuNames = 211,     // menu designer

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DebugExplorer"]/*' />
            DebugExplorer = 212,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DebugProcesses"]/*' />
            DebugProcesses = 213,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewThreadsWindow"]/*' />
            ViewThreadsWindow = 214,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.WindowUIList"]/*' />
            WindowUIList = 215,

            // ids on the file menu
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.NewProject"]/*' />
            NewProject = 216,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OpenProject"]/*' />
            OpenProject = 217,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OpenProjectFromWeb"]/*' />
            OpenProjectFromWeb = 450,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OpenSolution"]/*' />
            OpenSolution = 218,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CloseSolution"]/*' />
            CloseSolution = 219,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FileNew"]/*' />
            FileNew = 221,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.NewProjectFromExisting"]/*' />
            NewProjectFromExisting = 385,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FileOpen"]/*' />
            FileOpen = 222,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FileOpenFromWeb"]/*' />
            FileOpenFromWeb = 451,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FileClose"]/*' />
            FileClose = 223,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SaveSolution"]/*' />
            SaveSolution = 224,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SaveSolutionAs"]/*' />
            SaveSolutionAs = 225,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SaveProjectItemAs"]/*' />
            SaveProjectItemAs = 226,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PageSetup"]/*' />
            PageSetup = 227,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PrintPreview"]/*' />
            PrintPreview = 228,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Exit"]/*' />
            Exit = 229,

            // ids on the edit menu
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Replace"]/*' />
            Replace = 230,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Goto"]/*' />
            Goto = 231,

            // ids on the view menu
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PropertyPages"]/*' />
            PropertyPages = 232,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FullScreen"]/*' />
            FullScreen = 233,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ProjectExplorer"]/*' />
            ProjectExplorer = 234,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PropertiesWindow"]/*' />
            PropertiesWindow = 235,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListWindow"]/*' />
            TaskListWindow = 236,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OutputWindow"]/*' />
            OutputWindow = 237,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ObjectBrowser"]/*' />
            ObjectBrowser = 238,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DocOutlineWindow"]/*' />
            DocOutlineWindow = 239,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ImmediateWindow"]/*' />
            ImmediateWindow = 240,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.WatchWindow"]/*' />
            WatchWindow = 241,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.LocalsWindow"]/*' />
            LocalsWindow = 242,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CallStack"]/*' />
            CallStack = 243,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutosWindow"]/*' />
            AutosWindow = DebugReserved1,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ThisWindow"]/*' />
            ThisWindow = DebugReserved2,

            // ids on project menu
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AddNewItem"]/*' />
            AddNewItem = 220,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AddExistingItem"]/*' />
            AddExistingItem = 244,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.NewFolder"]/*' />
            NewFolder = 245,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SetStartupProject"]/*' />
            SetStartupProject = 246,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ProjectSettings"]/*' />
            ProjectSettings = 247,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ProjectReferences"]/*' />
            ProjectReferences = 367,

            // ids on the debug menu
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.StepInto"]/*' />
            StepInto = 248,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.StepOver"]/*' />
            StepOver = 249,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.StepOut"]/*' />
            StepOut = 250,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RunToCursor"]/*' />
            RunToCursor = 251,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AddWatch"]/*' />
            AddWatch = 252,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.EditWatch"]/*' />
            EditWatch = 253,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.QuickWatch"]/*' />
            QuickWatch = 254,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ToggleBreakpoint"]/*' />
            ToggleBreakpoint = 255,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ClearBreakpoints"]/*' />
            ClearBreakpoints = 256,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowBreakpoints"]/*' />
            ShowBreakpoints = 257,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SetNextStatement"]/*' />
            SetNextStatement = 258,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowNextStatement"]/*' />
            ShowNextStatement = 259,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.EditBreakpoint"]/*' />
            EditBreakpoint = 260,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DetachDebugger"]/*' />
            DetachDebugger = 262,

            // ids on the tools menu
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CustomizeKeyboard"]/*' />
            CustomizeKeyboard = 263,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ToolsOptions"]/*' />
            ToolsOptions = 264,

            // ids on the windows menu
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.NewWindow"]/*' />
            NewWindow = 265,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Split"]/*' />
            Split = 266,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Cascade"]/*' />
            Cascade = 267,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TileHorz"]/*' />
            TileHorz = 268,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TileVert"]/*' />
            TileVert = 269,

            // ids on the help menu
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TechSupport"]/*' />
            TechSupport = 270,

            // NOTE cmdidAbout and cmdidDebugOptions must be consecutive
            //      cmd after cmdidDebugOptions (ie 273) must not be used
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.About"]/*' />
            About = 271,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DebugOptions"]/*' />
            DebugOptions = 272,

            // ids on the watch context menu
            // CollapseWatch appears as 'Collapse Parent', on any
            // non-top-level item
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DeleteWatch"]/*' />
            DeleteWatch = 274,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CollapseWatch"]/*' />
            CollapseWatch = 275,
            // ids 276, 277, 278, 279, 280 are in use
            // below 
            // ids on the property browser context menu
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PbrsToggleStatus"]/*' />
            PbrsToggleStatus = 282,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PropbrsHide"]/*' />
            PropbrsHide = 283,

            // ids on the docking context menu
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DockingView"]/*' />
            DockingView = 284,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.HideActivePane"]/*' />
            HideActivePane = 285,
            // ids for window selection via keyboard
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PaneNextPane"]/*' />
            PaneNextPane = 316,  //(listed below in order)
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PanePrevPane"]/*' />
            PanePrevPane = 317,  //(listed below in order)
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PaneNextTab"]/*' />
            PaneNextTab = 286,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PanePrevTab"]/*' />
            PanePrevTab = 287,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PaneCloseToolWindow"]/*' />
            PaneCloseToolWindow = 288,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PaneActivateDocWindow"]/*' />
            PaneActivateDocWindow = 289,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DockingViewMDI"]/*' />
            DockingViewMDI = 290,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DockingViewFloater"]/*' />
            DockingViewFloater = 291,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideWindow"]/*' />
            AutoHideWindow = 292,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MoveToDropdownBar"]/*' />
            MoveToDropdownBar = 293,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FindCmd"]/*' />
            FindCmd = 294,  // internal Find commands
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Start"]/*' />
            Start = 295,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Restart"]/*' />
            Restart = 296,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AddinManager"]/*' />
            AddinManager = 297,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MultiLevelUndoList"]/*' />
            MultiLevelUndoList = 298,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MultiLevelRedoList"]/*' />
            MultiLevelRedoList = 299,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ToolboxAddTab"]/*' />
            ToolboxAddTab = 300,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ToolboxDeleteTab"]/*' />
            ToolboxDeleteTab = 301,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ToolboxRenameTab"]/*' />
            ToolboxRenameTab = 302,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ToolboxTabMoveUp"]/*' />
            ToolboxTabMoveUp = 303,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ToolboxTabMoveDown"]/*' />
            ToolboxTabMoveDown = 304,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ToolboxRenameItem"]/*' />
            ToolboxRenameItem = 305,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ToolboxListView"]/*' />
            ToolboxListView = 306,
            //(below) cmdidSearchSetCombo        307

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.WindowUIGetList"]/*' />
            WindowUIGetList = 308,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.InsertValuesQuery"]/*' />
            InsertValuesQuery = 309,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowProperties"]/*' />
            ShowProperties = 310,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ThreadSuspend"]/*' />
            ThreadSuspend = 311,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ThreadResume"]/*' />
            ThreadResume = 312,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ThreadSetFocus"]/*' />
            ThreadSetFocus = 313,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DisplayRadix"]/*' />
            DisplayRadix = 314,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OpenProjectItem"]/*' />
            OpenProjectItem = 315,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ClearPane"]/*' />
            ClearPane = 318,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.GotoErrorTag"]/*' />
            GotoErrorTag = 319,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListSortByCategory"]/*' />
            TaskListSortByCategory = 320,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListSortByFileLine"]/*' />
            TaskListSortByFileLine = 321,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListSortByPriority"]/*' />
            TaskListSortByPriority = 322,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListSortByDefaultSort"]/*' />
            TaskListSortByDefaultSort = 323,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListShowTooltip"]/*' />
            TaskListShowTooltip = 324,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListFilterByNothing"]/*' />
            TaskListFilterByNothing = 325,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CancelEZDrag"]/*' />
            CancelEZDrag = 326,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListFilterByCategoryCompiler"]/*' />
            TaskListFilterByCategoryCompiler = 327,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListFilterByCategoryComment"]/*' />
            TaskListFilterByCategoryComment = 328,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ToolboxAddItem"]/*' />
            ToolboxAddItem = 329,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ToolboxReset"]/*' />
            ToolboxReset = 330,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SaveProjectItem"]/*' />
            SaveProjectItem = 331,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SaveOptions"]/*' />
            SaveOptions = 959,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewForm"]/*' />
            ViewForm = 332,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewCode"]/*' />
            ViewCode = 333,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PreviewInBrowser"]/*' />
            PreviewInBrowser = 334,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BrowseWith"]/*' />
            BrowseWith = 336,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SearchSetCombo"]/*' />
            SearchSetCombo = 307,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SearchCombo"]/*' />
            SearchCombo = 337,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.EditLabel"]/*' />
            EditLabel = 338,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Exceptions"]/*' />
            Exceptions = 339,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DefineViews"]/*' />
            DefineViews = 340,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ToggleSelMode"]/*' />
            ToggleSelMode = 341,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ToggleInsMode"]/*' />
            ToggleInsMode = 342,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.LoadUnloadedProject"]/*' />
            LoadUnloadedProject = 343,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.UnloadLoadedProject"]/*' />
            UnloadLoadedProject = 344,

            // ids on the treegrids (watch/local/threads/stack)
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ElasticColumn"]/*' />
            ElasticColumn = 345,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.HideColumn"]/*' />
            HideColumn = 346,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListPreviousView"]/*' />
            TaskListPreviousView = 347,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ZoomDialog"]/*' />
            ZoomDialog = 348,

            // find/replace options
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FindHiddenText"]/*' />
            FindHiddenText = 349,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FindMatchCase"]/*' />
            FindMatchCase = 350,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FindWholeWord"]/*' />
            FindWholeWord = 351,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FindSimplePattern"]/*' />
            FindSimplePattern = 276,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FindRegularExpression"]/*' />
            FindRegularExpression = 352,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FindBackwards"]/*' />
            FindBackwards = 353,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FindInSelection"]/*' />
            FindInSelection = 354,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FindStop"]/*' />
            FindStop = 355,
            // UNUSED                               356
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FindInFiles"]/*' />
            FindInFiles = 277,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ReplaceInFiles"]/*' />
            ReplaceInFiles = 278,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.NextLocation"]/*' />
            NextLocation = 279,  // next item in task list, find in files results, etc.
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PreviousLocation"]/*' />
            PreviousLocation = 280,  // prev item "
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.GotoQuick"]/*' />
            GotoQuick = 281,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListNextError"]/*' />
            TaskListNextError = 357,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListPrevError"]/*' />
            TaskListPrevError = 358,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListFilterByCategoryUser"]/*' />
            TaskListFilterByCategoryUser = 359,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListFilterByCategoryShortcut"]/*' />
            TaskListFilterByCategoryShortcut = 360,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListFilterByCategoryHTML"]/*' />
            TaskListFilterByCategoryHTML = 361,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListFilterByCurrentFile"]/*' />
            TaskListFilterByCurrentFile = 362,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListFilterByChecked"]/*' />
            TaskListFilterByChecked = 363,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListFilterByUnchecked"]/*' />
            TaskListFilterByUnchecked = 364,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListSortByDescription"]/*' />
            TaskListSortByDescription = 365,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListSortByChecked"]/*' />
            TaskListSortByChecked = 366,

            // 367 is used above in cmdidProjectReferences
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.StartNoDebug"]/*' />
            StartNoDebug = 368,
            // 369 is used above in cmdidLockControls

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FindNext"]/*' />
            FindNext = 370,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FindPrev"]/*' />
            FindPrev = 371,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FindSelectedNext"]/*' />
            FindSelectedNext = 372,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FindSelectedPrev"]/*' />
            FindSelectedPrev = 373,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SearchGetList"]/*' />
            SearchGetList = 374,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.InsertBreakpoint"]/*' />
            InsertBreakpoint = 375,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.EnableBreakpoint"]/*' />
            EnableBreakpoint = 376,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.F1Help"]/*' />
            F1Help = 377,

            //UNUSED 378-396

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MoveToNextEZCntr"]/*' />
            MoveToNextEZCntr = 384,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.UpdateMarkerSpans"]/*' />
            UpdateMarkerSpans = 386,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MoveToPreviousEZCntr"]/*' />
            MoveToPreviousEZCntr = 393,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ProjectProperties"]/*' />
            ProjectProperties = 396,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PropSheetOrProperties"]/*' />
            PropSheetOrProperties = 397,

            // NOTE - the next items are debug only !!
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TshellStep"]/*' />
            TshellStep = 398,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TshellRun"]/*' />
            TshellRun = 399,

            // marker commands on the codewin menu
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MarkerCmd0"]/*' />
            MarkerCmd0 = 400,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MarkerCmd1"]/*' />
            MarkerCmd1 = 401,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MarkerCmd2"]/*' />
            MarkerCmd2 = 402,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MarkerCmd3"]/*' />
            MarkerCmd3 = 403,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MarkerCmd4"]/*' />
            MarkerCmd4 = 404,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MarkerCmd5"]/*' />
            MarkerCmd5 = 405,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MarkerCmd6"]/*' />
            MarkerCmd6 = 406,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MarkerCmd7"]/*' />
            MarkerCmd7 = 407,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MarkerCmd8"]/*' />
            MarkerCmd8 = 408,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MarkerCmd9"]/*' />
            MarkerCmd9 = 409,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MarkerLast"]/*' />
            MarkerLast = 409,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MarkerEnd"]/*' />
            MarkerEnd = 410,  // list terminator reserved

            // user-invoked project reload and unload
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ReloadProject"]/*' />
            ReloadProject = 412,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.UnloadProject"]/*' />
            UnloadProject = 413,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.NewBlankSolution"]/*' />
            NewBlankSolution = 414,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SelectProjectTemplate"]/*' />
            SelectProjectTemplate = 415,

            // document outline commands
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DetachAttachOutline"]/*' />
            DetachAttachOutline = 420,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowHideOutline"]/*' />
            ShowHideOutline = 421,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SyncOutline"]/*' />
            SyncOutline = 422,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RunToCallstCursor"]/*' />
            RunToCallstCursor = 423,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.NoCmdsAvailable"]/*' />
            NoCmdsAvailable = 424,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ContextWindow"]/*' />
            ContextWindow = 427,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Alias"]/*' />
            Alias = 428,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.GotoCommandLine"]/*' />
            GotoCommandLine = 429,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.EvaluateExpression"]/*' />
            EvaluateExpression = 430,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ImmediateMode"]/*' />
            ImmediateMode = 431,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.EvaluateStatement"]/*' />
            EvaluateStatement = 432,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FindResultWindow1"]/*' />
            FindResultWindow1 = 433,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FindResultWindow2"]/*' />
            FindResultWindow2 = 434,

            // 500 is used above in cmdidFontNameGetList
            // 501 is used above in cmdidFontSizeGetList

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RenameBookmark"]/*' />
            RenameBookmark = 559,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ToggleBookmark"]/*' />
            ToggleBookmark = 560,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DeleteBookmark"]/*' />
            DeleteBookmark = 561,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BookmarkWindowGoToBookmark"]/*' />
            BookmarkWindowGoToBookmark = 562,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.EnableBookmark"]/*' />
            EnableBookmark = 564,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.NewBookmarkFolder"]/*' />
            NewBookmarkFolder = 565,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.NextBookmarkFolder"]/*' />
            NextBookmarkFolder = 568,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PrevBookmarkFolder"]/*' />
            PrevBookmarkFolder = 569,

            // ids on the window menu - these must be sequential ie window1-morewind
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window1"]/*' />
            Window1 = 570,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window2"]/*' />
            Window2 = 571,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window3"]/*' />
            Window3 = 572,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window4"]/*' />
            Window4 = 573,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window5"]/*' />
            Window5 = 574,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window6"]/*' />
            Window6 = 575,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window7"]/*' />
            Window7 = 576,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window8"]/*' />
            Window8 = 577,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window9"]/*' />
            Window9 = 578,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window10"]/*' />
            Window10 = 579,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window11"]/*' />
            Window11 = 580,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window12"]/*' />
            Window12 = 581,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window13"]/*' />
            Window13 = 582,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window14"]/*' />
            Window14 = 583,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window15"]/*' />
            Window15 = 584,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window16"]/*' />
            Window16 = 585,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window17"]/*' />
            Window17 = 586,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window18"]/*' />
            Window18 = 587,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window19"]/*' />
            Window19 = 588,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window20"]/*' />
            Window20 = 589,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window21"]/*' />
            Window21 = 590,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window22"]/*' />
            Window22 = 591,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window23"]/*' />
            Window23 = 592,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window24"]/*' />
            Window24 = 593,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Window25"]/*' />
            Window25 = 594,    // note cmdidWindow25 is unused on purpose!
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MoreWindows"]/*' />
            MoreWindows = 595,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideAllWindows"]/*' />
            AutoHideAllWindows = 597,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListTaskHelp"]/*' />
            TaskListTaskHelp = 598,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ClassView"]/*' />
            ClassView = 599,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj1"]/*' />
            MRUProj1 = 600,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj2"]/*' />
            MRUProj2 = 601,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj3"]/*' />
            MRUProj3 = 602,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj4"]/*' />
            MRUProj4 = 603,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj5"]/*' />
            MRUProj5 = 604,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj6"]/*' />
            MRUProj6 = 605,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj7"]/*' />
            MRUProj7 = 606,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj8"]/*' />
            MRUProj8 = 607,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj9"]/*' />
            MRUProj9 = 608,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj10"]/*' />
            MRUProj10 = 609,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj11"]/*' />
            MRUProj11 = 610,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj12"]/*' />
            MRUProj12 = 611,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj13"]/*' />
            MRUProj13 = 612,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj14"]/*' />
            MRUProj14 = 613,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj15"]/*' />
            MRUProj15 = 614,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj16"]/*' />
            MRUProj16 = 615,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj17"]/*' />
            MRUProj17 = 616,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj18"]/*' />
            MRUProj18 = 617,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj19"]/*' />
            MRUProj19 = 618,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj20"]/*' />
            MRUProj20 = 619,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj21"]/*' />
            MRUProj21 = 620,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj22"]/*' />
            MRUProj22 = 621,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj23"]/*' />
            MRUProj23 = 622,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj24"]/*' />
            MRUProj24 = 623,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUProj25"]/*' />
            MRUProj25 = 624,   // note cmdidMRUProj25 is unused on purpose!

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SplitNext"]/*' />
            SplitNext = 625,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SplitPrev"]/*' />
            SplitPrev = 626,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CloseAllDocuments"]/*' />
            CloseAllDocuments = 627,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.NextDocument"]/*' />
            NextDocument = 628,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PrevDocument"]/*' />
            PrevDocument = 629,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool1"]/*' />
            Tool1 = 630,   // note cmdidTool1 - cmdidTool24 must be
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool2"]/*' />
            Tool2 = 631,   // consecutive
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool3"]/*' />
            Tool3 = 632,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool4"]/*' />
            Tool4 = 633,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool5"]/*' />
            Tool5 = 634,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool6"]/*' />
            Tool6 = 635,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool7"]/*' />
            Tool7 = 636,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool8"]/*' />
            Tool8 = 637,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool9"]/*' />
            Tool9 = 638,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool10"]/*' />
            Tool10 = 639,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool11"]/*' />
            Tool11 = 640,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool12"]/*' />
            Tool12 = 641,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool13"]/*' />
            Tool13 = 642,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool14"]/*' />
            Tool14 = 643,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool15"]/*' />
            Tool15 = 644,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool16"]/*' />
            Tool16 = 645,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool17"]/*' />
            Tool17 = 646,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool18"]/*' />
            Tool18 = 647,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool19"]/*' />
            Tool19 = 648,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool20"]/*' />
            Tool20 = 649,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool21"]/*' />
            Tool21 = 650,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool22"]/*' />
            Tool22 = 651,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool23"]/*' />
            Tool23 = 652,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Tool24"]/*' />
            Tool24 = 653,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExternalCommands"]/*' />
            ExternalCommands = 654,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PasteNextTBXCBItem"]/*' />
            PasteNextTBXCBItem = 655,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ToolboxShowAllTabs"]/*' />
            ToolboxShowAllTabs = 656,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ProjectDependencies"]/*' />
            ProjectDependencies = 657,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CloseDocument"]/*' />
            CloseDocument = 658,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ToolboxSortItems"]/*' />
            ToolboxSortItems = 659,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView1"]/*' />
            ViewBarView1 = 660,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView2"]/*' />
            ViewBarView2 = 661,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView3"]/*' />
            ViewBarView3 = 662,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView4"]/*' />
            ViewBarView4 = 663,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView5"]/*' />
            ViewBarView5 = 664,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView6"]/*' />
            ViewBarView6 = 665,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView7"]/*' />
            ViewBarView7 = 666,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView8"]/*' />
            ViewBarView8 = 667,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView9"]/*' />
            ViewBarView9 = 668,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView10"]/*' />
            ViewBarView10 = 669,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView11"]/*' />
            ViewBarView11 = 670,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView12"]/*' />
            ViewBarView12 = 671,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView13"]/*' />
            ViewBarView13 = 672,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView14"]/*' />
            ViewBarView14 = 673,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView15"]/*' />
            ViewBarView15 = 674,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView16"]/*' />
            ViewBarView16 = 675,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView17"]/*' />
            ViewBarView17 = 676,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView18"]/*' />
            ViewBarView18 = 677,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView19"]/*' />
            ViewBarView19 = 678,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView20"]/*' />
            ViewBarView20 = 679,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView21"]/*' />
            ViewBarView21 = 680,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView22"]/*' />
            ViewBarView22 = 681,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView23"]/*' />
            ViewBarView23 = 682,    //UNUSED
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewBarView24"]/*' />
            ViewBarView24 = 683,    //UNUSED

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SolutionCfg"]/*' />
            SolutionCfg = 684,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SolutionCfgGetList"]/*' />
            SolutionCfgGetList = 685,

            //
            // Schema table commands:
            // All invoke table property dialog and select appropriate page.
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ManageIndexes"]/*' />
            ManageIndexes = 675,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ManageRelationships"]/*' />
            ManageRelationships = 676,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ManageConstraints"]/*' />
            ManageConstraints = 677,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView1"]/*' />
            TaskListCustomView1 = 678,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView2"]/*' />
            TaskListCustomView2 = 679,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView3"]/*' />
            TaskListCustomView3 = 680,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView4"]/*' />
            TaskListCustomView4 = 681,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView5"]/*' />
            TaskListCustomView5 = 682,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView6"]/*' />
            TaskListCustomView6 = 683,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView7"]/*' />
            TaskListCustomView7 = 684,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView8"]/*' />
            TaskListCustomView8 = 685,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView9"]/*' />
            TaskListCustomView9 = 686,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView10"]/*' />
            TaskListCustomView10 = 687,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView11"]/*' />
            TaskListCustomView11 = 688,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView12"]/*' />
            TaskListCustomView12 = 689,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView13"]/*' />
            TaskListCustomView13 = 690,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView14"]/*' />
            TaskListCustomView14 = 691,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView15"]/*' />
            TaskListCustomView15 = 692,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView16"]/*' />
            TaskListCustomView16 = 693,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView17"]/*' />
            TaskListCustomView17 = 694,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView18"]/*' />
            TaskListCustomView18 = 695,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView19"]/*' />
            TaskListCustomView19 = 696,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView20"]/*' />
            TaskListCustomView20 = 697,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView21"]/*' />
            TaskListCustomView21 = 698,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView22"]/*' />
            TaskListCustomView22 = 699,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView23"]/*' />
            TaskListCustomView23 = 700,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView24"]/*' />
            TaskListCustomView24 = 701,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView25"]/*' />
            TaskListCustomView25 = 702,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView26"]/*' />
            TaskListCustomView26 = 703,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView27"]/*' />
            TaskListCustomView27 = 704,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView28"]/*' />
            TaskListCustomView28 = 705,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView29"]/*' />
            TaskListCustomView29 = 706,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView30"]/*' />
            TaskListCustomView30 = 707,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView31"]/*' />
            TaskListCustomView31 = 708,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView32"]/*' />
            TaskListCustomView32 = 709,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView33"]/*' />
            TaskListCustomView33 = 710,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView34"]/*' />
            TaskListCustomView34 = 711,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView35"]/*' />
            TaskListCustomView35 = 712,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView36"]/*' />
            TaskListCustomView36 = 713,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView37"]/*' />
            TaskListCustomView37 = 714,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView38"]/*' />
            TaskListCustomView38 = 715,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView39"]/*' />
            TaskListCustomView39 = 716,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView40"]/*' />
            TaskListCustomView40 = 717,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView41"]/*' />
            TaskListCustomView41 = 718,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView42"]/*' />
            TaskListCustomView42 = 719,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView43"]/*' />
            TaskListCustomView43 = 720,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView44"]/*' />
            TaskListCustomView44 = 721,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView45"]/*' />
            TaskListCustomView45 = 722,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView46"]/*' />
            TaskListCustomView46 = 723,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView47"]/*' />
            TaskListCustomView47 = 724,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView48"]/*' />
            TaskListCustomView48 = 725,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView49"]/*' />
            TaskListCustomView49 = 726,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaskListCustomView50"]/*' />
            TaskListCustomView50 = 727,  //not used on purpose, ends the list

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.WhiteSpace"]/*' />
            WhiteSpace = 728,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CommandWindow"]/*' />
            CommandWindow = 729,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CommandWindowMarkMode"]/*' />
            CommandWindowMarkMode = 730,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.LogCommandWindow"]/*' />
            LogCommandWindow = 731,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Shell"]/*' />
            Shell = 732,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SingleChar"]/*' />
            SingleChar = 733,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ZeroOrMore"]/*' />
            ZeroOrMore = 734,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OneOrMore"]/*' />
            OneOrMore = 735,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BeginLine"]/*' />
            BeginLine = 736,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.EndLine"]/*' />
            EndLine = 737,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BeginWord"]/*' />
            BeginWord = 738,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.EndWord"]/*' />
            EndWord = 739,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CharInSet"]/*' />
            CharInSet = 740,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CharNotInSet"]/*' />
            CharNotInSet = 741,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Or"]/*' />
            Or = 742,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Escape"]/*' />
            Escape = 743,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TagExp"]/*' />
            TagExp = 744,

            // Regex builder context help menu commands
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PatternMatchHelp"]/*' />
            PatternMatchHelp = 745,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RegExList"]/*' />
            RegExList = 746,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DebugReserved1"]/*' />
            DebugReserved1 = 747,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DebugReserved2"]/*' />
            DebugReserved2 = 748,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DebugReserved3"]/*' />
            DebugReserved3 = 749,
            //USED ABOVE                        750
            //USED ABOVE                        751
            //USED ABOVE                        752
            //USED ABOVE                        753

            //Regex builder wildcard menu commands
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.WildZeroOrMore"]/*' />
            WildZeroOrMore = 754,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.WildSingleChar"]/*' />
            WildSingleChar = 755,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.WildSingleDigit"]/*' />
            WildSingleDigit = 756,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.WildCharInSet"]/*' />
            WildCharInSet = 757,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.WildCharNotInSet"]/*' />
            WildCharNotInSet = 758,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FindWhatText"]/*' />
            FindWhatText = 759,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaggedExp1"]/*' />
            TaggedExp1 = 760,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaggedExp2"]/*' />
            TaggedExp2 = 761,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaggedExp3"]/*' />
            TaggedExp3 = 762,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaggedExp4"]/*' />
            TaggedExp4 = 763,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaggedExp5"]/*' />
            TaggedExp5 = 764,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaggedExp6"]/*' />
            TaggedExp6 = 765,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaggedExp7"]/*' />
            TaggedExp7 = 766,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaggedExp8"]/*' />
            TaggedExp8 = 767,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.TaggedExp9"]/*' />
            TaggedExp9 = 768,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.EditorWidgetClick"]/*' />
            EditorWidgetClick = 769,  // param 0 is the moniker as VT_BSTR, param 1 is the buffer line as VT_I4, and param 2 is the buffer index as VT_I4
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CmdWinUpdateAC"]/*' />
            CmdWinUpdateAC = 770,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SlnCfgMgr"]/*' />
            SlnCfgMgr = 771,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AddNewProject"]/*' />
            AddNewProject = 772,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AddExistingProject"]/*' />
            AddExistingProject = 773,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AddExistingProjFromWeb"]/*' />
            AddExistingProjFromWeb = 774,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext1"]/*' />
            AutoHideContext1 = 776,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext2"]/*' />
            AutoHideContext2 = 777,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext3"]/*' />
            AutoHideContext3 = 778,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext4"]/*' />
            AutoHideContext4 = 779,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext5"]/*' />
            AutoHideContext5 = 780,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext6"]/*' />
            AutoHideContext6 = 781,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext7"]/*' />
            AutoHideContext7 = 782,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext8"]/*' />
            AutoHideContext8 = 783,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext9"]/*' />
            AutoHideContext9 = 784,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext10"]/*' />
            AutoHideContext10 = 785,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext11"]/*' />
            AutoHideContext11 = 786,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext12"]/*' />
            AutoHideContext12 = 787,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext13"]/*' />
            AutoHideContext13 = 788,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext14"]/*' />
            AutoHideContext14 = 789,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext15"]/*' />
            AutoHideContext15 = 790,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext16"]/*' />
            AutoHideContext16 = 791,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext17"]/*' />
            AutoHideContext17 = 792,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext18"]/*' />
            AutoHideContext18 = 793,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext19"]/*' />
            AutoHideContext19 = 794,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext20"]/*' />
            AutoHideContext20 = 795,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext21"]/*' />
            AutoHideContext21 = 796,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext22"]/*' />
            AutoHideContext22 = 797,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext23"]/*' />
            AutoHideContext23 = 798,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext24"]/*' />
            AutoHideContext24 = 799,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext25"]/*' />
            AutoHideContext25 = 800,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext26"]/*' />
            AutoHideContext26 = 801,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext27"]/*' />
            AutoHideContext27 = 802,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext28"]/*' />
            AutoHideContext28 = 803,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext29"]/*' />
            AutoHideContext29 = 804,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext30"]/*' />
            AutoHideContext30 = 805,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext31"]/*' />
            AutoHideContext31 = 806,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext32"]/*' />
            AutoHideContext32 = 807,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AutoHideContext33"]/*' />
            AutoHideContext33 = 808,   // must remain unused

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavBackward"]/*' />
            ShellNavBackward = 809,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavForward"]/*' />
            ShellNavForward = 810,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate1"]/*' />
            ShellNavigate1 = 811,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate2"]/*' />
            ShellNavigate2 = 812,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate3"]/*' />
            ShellNavigate3 = 813,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate4"]/*' />
            ShellNavigate4 = 814,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate5"]/*' />
            ShellNavigate5 = 815,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate6"]/*' />
            ShellNavigate6 = 816,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate7"]/*' />
            ShellNavigate7 = 817,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate8"]/*' />
            ShellNavigate8 = 818,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate9"]/*' />
            ShellNavigate9 = 819,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate10"]/*' />
            ShellNavigate10 = 820,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate11"]/*' />
            ShellNavigate11 = 821,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate12"]/*' />
            ShellNavigate12 = 822,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate13"]/*' />
            ShellNavigate13 = 823,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate14"]/*' />
            ShellNavigate14 = 824,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate15"]/*' />
            ShellNavigate15 = 825,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate16"]/*' />
            ShellNavigate16 = 826,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate17"]/*' />
            ShellNavigate17 = 827,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate18"]/*' />
            ShellNavigate18 = 828,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate19"]/*' />
            ShellNavigate19 = 829,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate20"]/*' />
            ShellNavigate20 = 830,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate21"]/*' />
            ShellNavigate21 = 831,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate22"]/*' />
            ShellNavigate22 = 832,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate23"]/*' />
            ShellNavigate23 = 833,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate24"]/*' />
            ShellNavigate24 = 834,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate25"]/*' />
            ShellNavigate25 = 835,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate26"]/*' />
            ShellNavigate26 = 836,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate27"]/*' />
            ShellNavigate27 = 837,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate28"]/*' />
            ShellNavigate28 = 838,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate29"]/*' />
            ShellNavigate29 = 839,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate30"]/*' />
            ShellNavigate30 = 840,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate31"]/*' />
            ShellNavigate31 = 841,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate32"]/*' />
            ShellNavigate32 = 842,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellNavigate33"]/*' />
            ShellNavigate33 = 843,   // must remain unused

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate1"]/*' />
            ShellWindowNavigate1 = 844,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate2"]/*' />
            ShellWindowNavigate2 = 845,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate3"]/*' />
            ShellWindowNavigate3 = 846,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate4"]/*' />
            ShellWindowNavigate4 = 847,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate5"]/*' />
            ShellWindowNavigate5 = 848,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate6"]/*' />
            ShellWindowNavigate6 = 849,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate7"]/*' />
            ShellWindowNavigate7 = 850,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate8"]/*' />
            ShellWindowNavigate8 = 851,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate9"]/*' />
            ShellWindowNavigate9 = 852,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate10"]/*' />
            ShellWindowNavigate10 = 853,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate11"]/*' />
            ShellWindowNavigate11 = 854,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate12"]/*' />
            ShellWindowNavigate12 = 855,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate13"]/*' />
            ShellWindowNavigate13 = 856,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate14"]/*' />
            ShellWindowNavigate14 = 857,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate15"]/*' />
            ShellWindowNavigate15 = 858,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate16"]/*' />
            ShellWindowNavigate16 = 859,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate17"]/*' />
            ShellWindowNavigate17 = 860,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate18"]/*' />
            ShellWindowNavigate18 = 861,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate19"]/*' />
            ShellWindowNavigate19 = 862,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate20"]/*' />
            ShellWindowNavigate20 = 863,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate21"]/*' />
            ShellWindowNavigate21 = 864,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate22"]/*' />
            ShellWindowNavigate22 = 865,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate23"]/*' />
            ShellWindowNavigate23 = 866,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate24"]/*' />
            ShellWindowNavigate24 = 867,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate25"]/*' />
            ShellWindowNavigate25 = 868,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate26"]/*' />
            ShellWindowNavigate26 = 869,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate27"]/*' />
            ShellWindowNavigate27 = 870,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate28"]/*' />
            ShellWindowNavigate28 = 871,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate29"]/*' />
            ShellWindowNavigate29 = 872,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate30"]/*' />
            ShellWindowNavigate30 = 873,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate31"]/*' />
            ShellWindowNavigate31 = 874,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate32"]/*' />
            ShellWindowNavigate32 = 875,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShellWindowNavigate33"]/*' />
            ShellWindowNavigate33 = 876,   // must remain unused

            // ObjectSearch cmds
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBSDoFind"]/*' />
            OBSDoFind = 877,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBSMatchCase"]/*' />
            OBSMatchCase = 878,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBSMatchSubString"]/*' />
            OBSMatchSubString = 879,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBSMatchWholeWord"]/*' />
            OBSMatchWholeWord = 880,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBSMatchPrefix"]/*' />
            OBSMatchPrefix = 881,

            // build cmds
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BuildSln"]/*' />
            BuildSln = 882,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RebuildSln"]/*' />
            RebuildSln = 883,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DeploySln"]/*' />
            DeploySln = 884,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CleanSln"]/*' />
            CleanSln = 885,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BuildSel"]/*' />
            BuildSel = 886,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RebuildSel"]/*' />
            RebuildSel = 887,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DeploySel"]/*' />
            DeploySel = 888,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CleanSel"]/*' />
            CleanSel = 889,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CancelBuild"]/*' />
            CancelBuild = 890,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BatchBuildDlg"]/*' />
            BatchBuildDlg = 891,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BuildCtx"]/*' />
            BuildCtx = 892,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RebuildCtx"]/*' />
            RebuildCtx = 893,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DeployCtx"]/*' />
            DeployCtx = 894,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CleanCtx"]/*' />
            CleanCtx = 895,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.QryManageIndexes"]/*' />
            QryManageIndexes = 896,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PrintDefault"]/*' />
            PrintDefault = 897,         // quick print
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BrowseDoc"]/*' />
            BrowseDoc = 898,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowStartPage"]/*' />
            ShowStartPage = 899,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile1"]/*' />
            MRUFile1 = 900,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile2"]/*' />
            MRUFile2 = 901,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile3"]/*' />
            MRUFile3 = 902,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile4"]/*' />
            MRUFile4 = 903,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile5"]/*' />
            MRUFile5 = 904,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile6"]/*' />
            MRUFile6 = 905,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile7"]/*' />
            MRUFile7 = 906,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile8"]/*' />
            MRUFile8 = 907,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile9"]/*' />
            MRUFile9 = 908,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile10"]/*' />
            MRUFile10 = 909,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile11"]/*' />
            MRUFile11 = 910,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile12"]/*' />
            MRUFile12 = 911,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile13"]/*' />
            MRUFile13 = 912,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile14"]/*' />
            MRUFile14 = 913,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile15"]/*' />
            MRUFile15 = 914,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile16"]/*' />
            MRUFile16 = 915,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile17"]/*' />
            MRUFile17 = 916,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile18"]/*' />
            MRUFile18 = 917,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile19"]/*' />
            MRUFile19 = 918,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile20"]/*' />
            MRUFile20 = 919,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile21"]/*' />
            MRUFile21 = 920,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile22"]/*' />
            MRUFile22 = 921,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile23"]/*' />
            MRUFile23 = 922,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile24"]/*' />
            MRUFile24 = 923,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MRUFile25"]/*' />
            MRUFile25 = 924,   // note cmdidMRUFile25 is unused on purpose!

            //External Tools Context Menu Commands
            // continued at 1109
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExtToolsCurPath"]/*' />
            ExtToolsCurPath = 925,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExtToolsCurDir"]/*' />
            ExtToolsCurDir = 926,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExtToolsCurFileName"]/*' />
            ExtToolsCurFileName = 927,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExtToolsCurExtension"]/*' />
            ExtToolsCurExtension = 928,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExtToolsProjDir"]/*' />
            ExtToolsProjDir = 929,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExtToolsProjFileName"]/*' />
            ExtToolsProjFileName = 930,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExtToolsSlnDir"]/*' />
            ExtToolsSlnDir = 931,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExtToolsSlnFileName"]/*' />
            ExtToolsSlnFileName = 932,


            // Object Browsing & ClassView cmds
            // Shared shell cmds (for accessing Object Browsing functionality)
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.GotoDefn"]/*' />
            GotoDefn = 935,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.GotoDecl"]/*' />
            GotoDecl = 936,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BrowseDefn"]/*' />
            BrowseDefn = 937,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SyncClassView"]/*' />
            SyncClassView = 938,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowMembers"]/*' />
            ShowMembers = 939,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowBases"]/*' />
            ShowBases = 940,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowDerived"]/*' />
            ShowDerived = 941,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowDefns"]/*' />
            ShowDefns = 942,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowRefs"]/*' />
            ShowRefs = 943,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowCallers"]/*' />
            ShowCallers = 944,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowCallees"]/*' />
            ShowCallees = 945,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AddClass"]/*' />
            AddClass = 946,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AddNestedClass"]/*' />
            AddNestedClass = 947,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AddInterface"]/*' />
            AddInterface = 948,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AddMethod"]/*' />
            AddMethod = 949,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AddProperty"]/*' />
            AddProperty = 950,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AddEvent"]/*' />
            AddEvent = 951,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AddVariable"]/*' />
            AddVariable = 952,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ImplementInterface"]/*' />
            ImplementInterface = 953,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Override"]/*' />
            Override = 954,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AddFunction"]/*' />
            AddFunction = 955,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AddConnectionPoint"]/*' />
            AddConnectionPoint = 956,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.AddIndexer"]/*' />
            AddIndexer = 957,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BuildOrder"]/*' />
            BuildOrder = 958,
            //959 used above for cmdidSaveOptions

            // Object Browser Tool Specific cmds
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBShowHidden"]/*' />
            OBShowHidden = 960,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBEnableGrouping"]/*' />
            OBEnableGrouping = 961,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBSetGroupingCriteria"]/*' />
            OBSetGroupingCriteria = 962,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBBack"]/*' />
            OBBack = 963,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBForward"]/*' />
            OBForward = 964,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBShowPackages"]/*' />
            OBShowPackages = 965,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBSearchCombo"]/*' />
            OBSearchCombo = 966,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBSearchOptWholeWord"]/*' />
            OBSearchOptWholeWord = 967,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBSearchOptSubstring"]/*' />
            OBSearchOptSubstring = 968,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBSearchOptPrefix"]/*' />
            OBSearchOptPrefix = 969,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBSearchOptCaseSensitive"]/*' />
            OBSearchOptCaseSensitive = 970,

            // ClassView Tool Specific cmds
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CVGroupingNone"]/*' />
            CVGroupingNone = 971,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CVGroupingSortOnly"]/*' />
            CVGroupingSortOnly = 972,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CVGroupingGrouped"]/*' />
            CVGroupingGrouped = 973,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CVShowPackages"]/*' />
            CVShowPackages = 974,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CVNewFolder"]/*' />
            CVNewFolder = 975,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CVGroupingSortAccess"]/*' />
            CVGroupingSortAccess = 976,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ObjectSearch"]/*' />
            ObjectSearch = 977,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ObjectSearchResults"]/*' />
            ObjectSearchResults = 978,

            // Further Obj Browsing cmds at 1095

            // build cascade menus
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Build1"]/*' />
            Build1 = 979,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Build2"]/*' />
            Build2 = 980,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Build3"]/*' />
            Build3 = 981,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Build4"]/*' />
            Build4 = 982,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Build5"]/*' />
            Build5 = 983,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Build6"]/*' />
            Build6 = 984,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Build7"]/*' />
            Build7 = 985,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Build8"]/*' />
            Build8 = 986,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Build9"]/*' />
            Build9 = 987,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BuildLast"]/*' />
            BuildLast = 988,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Rebuild1"]/*' />
            Rebuild1 = 989,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Rebuild2"]/*' />
            Rebuild2 = 990,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Rebuild3"]/*' />
            Rebuild3 = 991,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Rebuild4"]/*' />
            Rebuild4 = 992,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Rebuild5"]/*' />
            Rebuild5 = 993,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Rebuild6"]/*' />
            Rebuild6 = 994,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Rebuild7"]/*' />
            Rebuild7 = 995,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Rebuild8"]/*' />
            Rebuild8 = 996,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Rebuild9"]/*' />
            Rebuild9 = 997,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RebuildLast"]/*' />
            RebuildLast = 998,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Clean1"]/*' />
            Clean1 = 999,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Clean2"]/*' />
            Clean2 = 1000,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Clean3"]/*' />
            Clean3 = 1001,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Clean4"]/*' />
            Clean4 = 1002,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Clean5"]/*' />
            Clean5 = 1003,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Clean6"]/*' />
            Clean6 = 1004,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Clean7"]/*' />
            Clean7 = 1005,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Clean8"]/*' />
            Clean8 = 1006,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Clean9"]/*' />
            Clean9 = 1007,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CleanLast"]/*' />
            CleanLast = 1008,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Deploy1"]/*' />
            Deploy1 = 1009,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Deploy2"]/*' />
            Deploy2 = 1010,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Deploy3"]/*' />
            Deploy3 = 1011,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Deploy4"]/*' />
            Deploy4 = 1012,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Deploy5"]/*' />
            Deploy5 = 1013,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Deploy6"]/*' />
            Deploy6 = 1014,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Deploy7"]/*' />
            Deploy7 = 1015,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Deploy8"]/*' />
            Deploy8 = 1016,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Deploy9"]/*' />
            Deploy9 = 1017,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DeployLast"]/*' />
            DeployLast = 1018,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BuildProjPicker"]/*' />
            BuildProjPicker = 1019,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.RebuildProjPicker"]/*' />
            RebuildProjPicker = 1020,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CleanProjPicker"]/*' />
            CleanProjPicker = 1021,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DeployProjPicker"]/*' />
            DeployProjPicker = 1022,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ResourceView"]/*' />
            ResourceView = 1023,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ShowHomePage"]/*' />
            ShowHomePage = 1024,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.EditMenuIDs"]/*' />
            EditMenuIDs = 1025,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.LineBreak"]/*' />
            LineBreak = 1026,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CPPIdentifier"]/*' />
            CPPIdentifier = 1027,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.QuotedString"]/*' />
            QuotedString = 1028,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SpaceOrTab"]/*' />
            SpaceOrTab = 1029,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Integer"]/*' />
            Integer = 1030,
            //unused 1031-1035

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CustomizeToolbars"]/*' />
            CustomizeToolbars = 1036,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MoveToTop"]/*' />
            MoveToTop = 1037,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.WindowHelp"]/*' />
            WindowHelp = 1038,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewPopup"]/*' />
            ViewPopup = 1039,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CheckMnemonics"]/*' />
            CheckMnemonics = 1040,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PRSortAlphabeticaly"]/*' />
            PRSortAlphabeticaly = 1041,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PRSortByCategory"]/*' />
            PRSortByCategory = 1042,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ViewNextTab"]/*' />
            ViewNextTab = 1043,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CheckForUpdates"]/*' />
            CheckForUpdates = 1044,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Browser1"]/*' />
            Browser1 = 1045,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Browser2"]/*' />
            Browser2 = 1046,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Browser3"]/*' />
            Browser3 = 1047,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Browser4"]/*' />
            Browser4 = 1048,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Browser5"]/*' />
            Browser5 = 1049,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Browser6"]/*' />
            Browser6 = 1050,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Browser7"]/*' />
            Browser7 = 1051,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Browser8"]/*' />
            Browser8 = 1052,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Browser9"]/*' />
            Browser9 = 1053,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Browser10"]/*' />
            Browser10 = 1054,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Browser11"]/*' />
            Browser11 = 1055,  //note unused on purpose to end list

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OpenDropDownOpen"]/*' />
            OpenDropDownOpen = 1058,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OpenDropDownOpenWith"]/*' />
            OpenDropDownOpenWith = 1059,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ToolsDebugProcesses"]/*' />
            ToolsDebugProcesses = 1060,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PaneNextSubPane"]/*' />
            PaneNextSubPane = 1062,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PanePrevSubPane"]/*' />
            PanePrevSubPane = 1063,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MoveFileToProject1"]/*' />
            MoveFileToProject1 = 1070,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MoveFileToProject2"]/*' />
            MoveFileToProject2 = 1071,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MoveFileToProject3"]/*' />
            MoveFileToProject3 = 1072,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MoveFileToProject4"]/*' />
            MoveFileToProject4 = 1073,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MoveFileToProject5"]/*' />
            MoveFileToProject5 = 1074,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MoveFileToProject6"]/*' />
            MoveFileToProject6 = 1075,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MoveFileToProject7"]/*' />
            MoveFileToProject7 = 1076,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MoveFileToProject8"]/*' />
            MoveFileToProject8 = 1077,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MoveFileToProject9"]/*' />
            MoveFileToProject9 = 1078,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MoveFileToProjectLast"]/*' />
            MoveFileToProjectLast = 1079,  // unused in order to end list
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.MoveFileToProjectPick"]/*' />
            MoveFileToProjectPick = 1081,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.DefineSubset"]/*' />
            DefineSubset = 1095,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SubsetCombo"]/*' />
            SubsetCombo = 1096,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SubsetGetList"]/*' />
            SubsetGetList = 1097,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBSortObjectsAlpha"]/*' />
            OBSortObjectsAlpha = 1098,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBSortObjectsType"]/*' />
            OBSortObjectsType = 1099,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBSortObjectsAccess"]/*' />
            OBSortObjectsAccess = 1100,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBGroupObjectsType"]/*' />
            OBGroupObjectsType = 1101,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBGroupObjectsAccess"]/*' />
            OBGroupObjectsAccess = 1102,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBSortMembersAlpha"]/*' />
            OBSortMembersAlpha = 1103,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBSortMembersType"]/*' />
            OBSortMembersType = 1104,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBSortMembersAccess"]/*' />
            OBSortMembersAccess = 1105,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PopBrowseContext"]/*' />
            PopBrowseContext = 1106,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.GotoRef"]/*' />
            GotoRef = 1107,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.OBSLookInReferences"]/*' />
            OBSLookInReferences = 1108,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExtToolsTargetPath"]/*' />
            ExtToolsTargetPath = 1109,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExtToolsTargetDir"]/*' />
            ExtToolsTargetDir = 1110,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExtToolsTargetFileName"]/*' />
            ExtToolsTargetFileName = 1111,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExtToolsTargetExtension"]/*' />
            ExtToolsTargetExtension = 1112,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExtToolsCurLine"]/*' />
            ExtToolsCurLine = 1113,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExtToolsCurCol"]/*' />
            ExtToolsCurCol = 1114,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExtToolsCurText"]/*' />
            ExtToolsCurText = 1115,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BrowseNext"]/*' />
            BrowseNext = 1116,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BrowsePrev"]/*' />
            BrowsePrev = 1117,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BrowseUnload"]/*' />
            BrowseUnload = 1118,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.QuickObjectSearch"]/*' />
            QuickObjectSearch = 1119,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.ExpandAll"]/*' />
            ExpandAll = 1120,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.BookmarkWindow"]/*' />
            BookmarkWindow = 1122,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.CodeExpansionWindow"]/*' />
            CodeExpansionWindow = 1123,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.NextDocumentNav"]/*' />
            NextDocumentNav = 1124,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.PrevDocumentNav"]/*' />
            PrevDocumentNav = 1125,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.StandardMax"]/*' />
            StandardMax = 1500,

            ///////////////////////////////////////////
            //
            // cmdidStandardMax is now thought to be
            // obsolete. Any new shell commands should
            // be added to the end of StandardCommandSet2K
            // which appears below.
            //
            // If you are not adding shell commands,
            // you shouldn't be doing it in this file! 
            //
            ///////////////////////////////////////////


            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FormsFirst"]/*' />
            FormsFirst = 0x00006000,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.FormsLast"]/*' />
            FormsLast = 0x00006FFF,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.VBEFirst"]/*' />
            VBEFirst = 0x00008000,


            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Zoom200"]/*' />
            Zoom200 = 0x00008002,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Zoom150"]/*' />
            Zoom150 = 0x00008003,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Zoom100"]/*' />
            Zoom100 = 0x00008004,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Zoom75"]/*' />
            Zoom75 = 0x00008005,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Zoom50"]/*' />
            Zoom50 = 0x00008006,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Zoom25"]/*' />
            Zoom25 = 0x00008007,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.Zoom10"]/*' />
            Zoom10 = 0x00008010,


            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.VBELast"]/*' />
            VBELast = 0x00009FFF,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SterlingFirst"]/*' />
            SterlingFirst = 0x0000A000,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.SterlingLast"]/*' />
            SterlingLast = 0x0000BFFF,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.uieventidFirst"]/*' />
            uieventidFirst = 0xC000,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.uieventidSelectRegion"]/*' />
            uieventidSelectRegion = 0xC001,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.uieventidDrop"]/*' />
            uieventidDrop = 0xC002,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd97CmdID.uieventidLast"]/*' />
            uieventidLast = 0xDFFF,
        }

    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VSStd2K"]/*' />
        /// <summary>
        /// GUID for the 2K command set. This is a set of standard editor commands.
        /// </summary>
        public static readonly Guid VSStd2K = new Guid("{1496A755-94DE-11D0-8C3F-00C04FC2AAE2}");

    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VSStd2KCmdID"]/*' />
        /// <summary>
        /// Set of the standard, shared editor commands in StandardCommandSet2k.
        /// </summary>
        [Guid("1496A755-94DE-11D0-8C3F-00C04FC2AAE2")]
        public enum VSStd2KCmdID
        {
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TYPECHAR"]/*' />
            TYPECHAR = 1,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.BACKSPACE"]/*' />
            BACKSPACE = 2,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RETURN"]/*' />
            RETURN = 3,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TAB"]/*' />
            TAB = 4,  // test
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.BACKTAB"]/*' />
            BACKTAB = 5,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DELETE"]/*' />
            DELETE = 6,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LEFT"]/*' />
            LEFT = 7,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LEFT_EXT"]/*' />
            LEFT_EXT = 8,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RIGHT"]/*' />
            RIGHT = 9,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RIGHT_EXT"]/*' />
            RIGHT_EXT = 10,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UP"]/*' />
            UP = 11,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UP_EXT"]/*' />
            UP_EXT = 12,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DOWN"]/*' />
            DOWN = 13,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DOWN_EXT"]/*' />
            DOWN_EXT = 14,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.HOME"]/*' />
            HOME = 15,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.HOME_EXT"]/*' />
            HOME_EXT = 16,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.END"]/*' />
            END = 17,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.END_EXT"]/*' />
            END_EXT = 18,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.BOL"]/*' />
            BOL = 19,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.BOL_EXT"]/*' />
            BOL_EXT = 20,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FIRSTCHAR"]/*' />
            FIRSTCHAR = 21,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FIRSTCHAR_EXT"]/*' />
            FIRSTCHAR_EXT = 22,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EOL"]/*' />
            EOL = 23,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EOL_EXT"]/*' />
            EOL_EXT = 24,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LASTCHAR"]/*' />
            LASTCHAR = 25,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LASTCHAR_EXT"]/*' />
            LASTCHAR_EXT = 26,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PAGEUP"]/*' />
            PAGEUP = 27,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PAGEUP_EXT"]/*' />
            PAGEUP_EXT = 28,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PAGEDN"]/*' />
            PAGEDN = 29,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PAGEDN_EXT"]/*' />
            PAGEDN_EXT = 30,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TOPLINE"]/*' />
            TOPLINE = 31,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TOPLINE_EXT"]/*' />
            TOPLINE_EXT = 32,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.BOTTOMLINE"]/*' />
            BOTTOMLINE = 33,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.BOTTOMLINE_EXT"]/*' />
            BOTTOMLINE_EXT = 34,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SCROLLUP"]/*' />
            SCROLLUP = 35,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SCROLLDN"]/*' />
            SCROLLDN = 36,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SCROLLPAGEUP"]/*' />
            SCROLLPAGEUP = 37,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SCROLLPAGEDN"]/*' />
            SCROLLPAGEDN = 38,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SCROLLLEFT"]/*' />
            SCROLLLEFT = 39,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SCROLLRIGHT"]/*' />
            SCROLLRIGHT = 40,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SCROLLBOTTOM"]/*' />
            SCROLLBOTTOM = 41,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SCROLLCENTER"]/*' />
            SCROLLCENTER = 42,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SCROLLTOP"]/*' />
            SCROLLTOP = 43,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SELECTALL"]/*' />
            SELECTALL = 44,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SELTABIFY"]/*' />
            SELTABIFY = 45,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SELUNTABIFY"]/*' />
            SELUNTABIFY = 46,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SELLOWCASE"]/*' />
            SELLOWCASE = 47,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SELUPCASE"]/*' />
            SELUPCASE = 48,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SELTOGGLECASE"]/*' />
            SELTOGGLECASE = 49,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SELTITLECASE"]/*' />
            SELTITLECASE = 50,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SELSWAPANCHOR"]/*' />
            SELSWAPANCHOR = 51,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GOTOLINE"]/*' />
            GOTOLINE = 52,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GOTOBRACE"]/*' />
            GOTOBRACE = 53,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GOTOBRACE_EXT"]/*' />
            GOTOBRACE_EXT = 54,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GOBACK"]/*' />
            GOBACK = 55,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SELECTMODE"]/*' />
            SELECTMODE = 56,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TOGGLE_OVERTYPE_MODE"]/*' />
            TOGGLE_OVERTYPE_MODE = 57,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CUT"]/*' />
            CUT = 58,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.COPY"]/*' />
            COPY = 59,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PASTE"]/*' />
            PASTE = 60,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CUTLINE"]/*' />
            CUTLINE = 61,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DELETELINE"]/*' />
            DELETELINE = 62,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DELETEBLANKLINES"]/*' />
            DELETEBLANKLINES = 63,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DELETEWHITESPACE"]/*' />
            DELETEWHITESPACE = 64,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DELETETOEOL"]/*' />
            DELETETOEOL = 65,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DELETETOBOL"]/*' />
            DELETETOBOL = 66,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OPENLINEABOVE"]/*' />
            OPENLINEABOVE = 67,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OPENLINEBELOW"]/*' />
            OPENLINEBELOW = 68,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INDENT"]/*' />
            INDENT = 69,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UNINDENT"]/*' />
            UNINDENT = 70,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UNDO"]/*' />
            UNDO = 71,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UNDONOMOVE"]/*' />
            UNDONOMOVE = 72,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.REDO"]/*' />
            REDO = 73,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.REDONOMOVE"]/*' />
            REDONOMOVE = 74,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DELETEALLTEMPBOOKMARKS"]/*' />
            DELETEALLTEMPBOOKMARKS = 75,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TOGGLETEMPBOOKMARK"]/*' />
            TOGGLETEMPBOOKMARK = 76,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GOTONEXTBOOKMARK"]/*' />
            GOTONEXTBOOKMARK = 77,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GOTOPREVBOOKMARK"]/*' />
            GOTOPREVBOOKMARK = 78,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FIND"]/*' />
            FIND = 79,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.REPLACE"]/*' />
            REPLACE = 80,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.REPLACE_ALL"]/*' />
            REPLACE_ALL = 81,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FINDNEXT"]/*' />
            FINDNEXT = 82,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FINDNEXTWORD"]/*' />
            FINDNEXTWORD = 83,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FINDPREV"]/*' />
            FINDPREV = 84,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FINDPREVWORD"]/*' />
            FINDPREVWORD = 85,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FINDAGAIN"]/*' />
            FINDAGAIN = 86,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TRANSPOSECHAR"]/*' />
            TRANSPOSECHAR = 87,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TRANSPOSEWORD"]/*' />
            TRANSPOSEWORD = 88,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TRANSPOSELINE"]/*' />
            TRANSPOSELINE = 89,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SELECTCURRENTWORD"]/*' />
            SELECTCURRENTWORD = 90,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DELETEWORDRIGHT"]/*' />
            DELETEWORDRIGHT = 91,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DELETEWORDLEFT"]/*' />
            DELETEWORDLEFT = 92,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.WORDPREV"]/*' />
            WORDPREV = 93,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.WORDPREV_EXT"]/*' />
            WORDPREV_EXT = 94,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.WORDNEXT"]/*' />
            WORDNEXT = 96,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.WORDNEXT_EXT"]/*' />
            WORDNEXT_EXT = 97,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.COMMENTBLOCK"]/*' />
            COMMENTBLOCK = 98,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UNCOMMENTBLOCK"]/*' />
            UNCOMMENTBLOCK = 99,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SETREPEATCOUNT"]/*' />
            SETREPEATCOUNT = 100,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.WIDGETMARGIN_LBTNDOWN"]/*' />
            WIDGETMARGIN_LBTNDOWN = 101,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SHOWCONTEXTMENU"]/*' />
            SHOWCONTEXTMENU = 102,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CANCEL"]/*' />
            CANCEL = 103,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PARAMINFO"]/*' />
            PARAMINFO = 104,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TOGGLEVISSPACE"]/*' />
            TOGGLEVISSPACE = 105,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TOGGLECARETPASTEPOS"]/*' />
            TOGGLECARETPASTEPOS = 106,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.COMPLETEWORD"]/*' />
            COMPLETEWORD = 107,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SHOWMEMBERLIST"]/*' />
            SHOWMEMBERLIST = 108,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FIRSTNONWHITEPREV"]/*' />
            FIRSTNONWHITEPREV = 109,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FIRSTNONWHITENEXT"]/*' />
            FIRSTNONWHITENEXT = 110,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.HELPKEYWORD"]/*' />
            HELPKEYWORD = 111,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FORMATSELECTION"]/*' />
            FORMATSELECTION = 112,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OPENURL"]/*' />
            OPENURL = 113,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTFILE"]/*' />
            INSERTFILE = 114,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TOGGLESHORTCUT"]/*' />
            TOGGLESHORTCUT = 115,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.QUICKINFO"]/*' />
            QUICKINFO = 116,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LEFT_EXT_COL"]/*' />
            LEFT_EXT_COL = 117,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RIGHT_EXT_COL"]/*' />
            RIGHT_EXT_COL = 118,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UP_EXT_COL"]/*' />
            UP_EXT_COL = 119,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DOWN_EXT_COL"]/*' />
            DOWN_EXT_COL = 120,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TOGGLEWORDWRAP"]/*' />
            TOGGLEWORDWRAP = 121,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ISEARCH"]/*' />
            ISEARCH = 122,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ISEARCHBACK"]/*' />
            ISEARCHBACK = 123,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.BOL_EXT_COL"]/*' />
            BOL_EXT_COL = 124,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EOL_EXT_COL"]/*' />
            EOL_EXT_COL = 125,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.WORDPREV_EXT_COL"]/*' />
            WORDPREV_EXT_COL = 126,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.WORDNEXT_EXT_COL"]/*' />
            WORDNEXT_EXT_COL = 127,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OUTLN_HIDE_SELECTION"]/*' />
            OUTLN_HIDE_SELECTION = 128,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OUTLN_TOGGLE_CURRENT"]/*' />
            OUTLN_TOGGLE_CURRENT = 129,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OUTLN_TOGGLE_ALL"]/*' />
            OUTLN_TOGGLE_ALL = 130,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OUTLN_STOP_HIDING_ALL"]/*' />
            OUTLN_STOP_HIDING_ALL = 131,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OUTLN_STOP_HIDING_CURRENT"]/*' />
            OUTLN_STOP_HIDING_CURRENT = 132,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OUTLN_COLLAPSE_TO_DEF"]/*' />
            OUTLN_COLLAPSE_TO_DEF = 133,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DOUBLECLICK"]/*' />
            DOUBLECLICK = 134,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EXTERNALLY_HANDLED_WIDGET_CLICK"]/*' />
            EXTERNALLY_HANDLED_WIDGET_CLICK = 135,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.COMMENT_BLOCK"]/*' />
            COMMENT_BLOCK = 136,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UNCOMMENT_BLOCK"]/*' />
            UNCOMMENT_BLOCK = 137,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OPENFILE"]/*' />
            OPENFILE = 138,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NAVIGATETOURL"]/*' />
            NAVIGATETOURL = 139,

            // For editor internal use only
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.HANDLEIMEMESSAGE"]/*' />
            HANDLEIMEMESSAGE = 140,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SELTOGOBACK"]/*' />
            SELTOGOBACK = 141,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.COMPLETION_HIDE_ADVANCED"]/*' />
            COMPLETION_HIDE_ADVANCED = 142,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FORMATDOCUMENT"]/*' />
            FORMATDOCUMENT = 143,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OUTLN_START_AUTOHIDING"]/*' />
            OUTLN_START_AUTOHIDING = 144,

            // Last Standard Editor Command (+1)
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FINAL"]/*' />
            FINAL = 145,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_DECREASEFILTER"]/*' />
            ECMD_DECREASEFILTER = 146,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_COPYTIP"]/*' />
            ECMD_COPYTIP = 148,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_PASTETIP"]/*' />
            ECMD_PASTETIP = 149,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_LEFTCLICK"]/*' />
            ECMD_LEFTCLICK = 150,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_GOTONEXTBOOKMARKINDOC"]/*' />
            ECMD_GOTONEXTBOOKMARKINDOC = 151,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_GOTOPREVBOOKMARKINDOC"]/*' />
            ECMD_GOTOPREVBOOKMARKINDOC = 152,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_INVOKESNIPPETFROMSHORTCUT"]/*' />
            ECMD_INVOKESNIPPETFROMSHORTCUT = 154,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AUTOCOMPLETE"]/*' />
            AUTOCOMPLETE = 155,

            ///  <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_INVOKESNIPPETPICKER2"]/*' />
            ECMD_INVOKESNIPPETPICKER2 = 156,
            ///  <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_DELETEALLBOOKMARKSINDOC"]/*' />
            ECMD_DELETEALLBOOKMARKSINDOC = 157,
            ///  <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CONVERTTABSTOSPACES"]/*' />
            ECMD_CONVERTTABSTOSPACES = 158,
            ///  <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CONVERTSPACESTOTABS"]/*' />
            ECMD_CONVERTSPACESTOTABS = 159,
            ///  <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_FINAL"]/*' />
            ECMD_FINAL = 160,

            ///////////////////////////////////////////////////////////////
            // Some new commands created during CTC file rationalisation
            ///////////////////////////////////////////////////////////////
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.STOP"]/*' />
            STOP = 220,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.REVERSECANCEL"]/*' />
            REVERSECANCEL = 221,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SLNREFRESH"]/*' />
            SLNREFRESH = 222,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SAVECOPYOFITEMAS"]/*' />
            SAVECOPYOFITEMAS = 223,
            //
            // Shareable commands originating in the HTML editor
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWELEMENT"]/*' />
            NEWELEMENT = 224,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWATTRIBUTE"]/*' />
            NEWATTRIBUTE = 225,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWCOMPLEXTYPE"]/*' />
            NEWCOMPLEXTYPE = 226,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWSIMPLETYPE"]/*' />
            NEWSIMPLETYPE = 227,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWGROUP"]/*' />
            NEWGROUP = 228,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWATTRIBUTEGROUP"]/*' />
            NEWATTRIBUTEGROUP = 229,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWKEY"]/*' />
            NEWKEY = 230,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWRELATION"]/*' />
            NEWRELATION = 231,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EDITKEY"]/*' />
            EDITKEY = 232,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EDITRELATION"]/*' />
            EDITRELATION = 233,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.MAKETYPEGLOBAL"]/*' />
            MAKETYPEGLOBAL = 234,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PREVIEWDATASET"]/*' />
            PREVIEWDATASET = 235,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GENERATEDATASET"]/*' />
            GENERATEDATASET = 236,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CREATESCHEMA"]/*' />
            CREATESCHEMA = 237,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LAYOUTINDENT"]/*' />
            LAYOUTINDENT = 238,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LAYOUTUNINDENT"]/*' />
            LAYOUTUNINDENT = 239,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.REMOVEHANDLER"]/*' />
            REMOVEHANDLER = 240,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EDITHANDLER"]/*' />
            EDITHANDLER = 241,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDHANDLER"]/*' />
            ADDHANDLER = 242,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.STYLE"]/*' />
            STYLE = 243,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.STYLEGETLIST"]/*' />
            STYLEGETLIST = 244,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FONTSTYLE"]/*' />
            FONTSTYLE = 245,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FONTSTYLEGETLIST"]/*' />
            FONTSTYLEGETLIST = 246,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PASTEASHTML"]/*' />
            PASTEASHTML = 247,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWBORDERS"]/*' />
            VIEWBORDERS = 248,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWDETAILS"]/*' />
            VIEWDETAILS = 249,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EXPANDCONTROLS"]/*' />
            EXPANDCONTROLS = 250,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.COLLAPSECONTROLS"]/*' />
            COLLAPSECONTROLS = 251,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SHOWSCRIPTONLY"]/*' />
            SHOWSCRIPTONLY = 252,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTTABLE"]/*' />
            INSERTTABLE = 253,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTCOLLEFT"]/*' />
            INSERTCOLLEFT = 254,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTCOLRIGHT"]/*' />
            INSERTCOLRIGHT = 255,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTROWABOVE"]/*' />
            INSERTROWABOVE = 256,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTROWBELOW"]/*' />
            INSERTROWBELOW = 257,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DELETETABLE"]/*' />
            DELETETABLE = 258,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DELETECOLS"]/*' />
            DELETECOLS = 259,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DELETEROWS"]/*' />
            DELETEROWS = 260,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SELECTTABLE"]/*' />
            SELECTTABLE = 261,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SELECTTABLECOL"]/*' />
            SELECTTABLECOL = 262,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SELECTTABLEROW"]/*' />
            SELECTTABLEROW = 263,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SELECTTABLECELL"]/*' />
            SELECTTABLECELL = 264,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.MERGECELLS"]/*' />
            MERGECELLS = 265,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SPLITCELL"]/*' />
            SPLITCELL = 266,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTCELL"]/*' />
            INSERTCELL = 267,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DELETECELLS"]/*' />
            DELETECELLS = 268,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SEAMLESSFRAME"]/*' />
            SEAMLESSFRAME = 269,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWFRAME"]/*' />
            VIEWFRAME = 270,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DELETEFRAME"]/*' />
            DELETEFRAME = 271,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SETFRAMESOURCE"]/*' />
            SETFRAMESOURCE = 272,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWLEFTFRAME"]/*' />
            NEWLEFTFRAME = 273,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWRIGHTFRAME"]/*' />
            NEWRIGHTFRAME = 274,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWTOPFRAME"]/*' />
            NEWTOPFRAME = 275,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWBOTTOMFRAME"]/*' />
            NEWBOTTOMFRAME = 276,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SHOWGRID"]/*' />
            SHOWGRID = 277,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SNAPTOGRID"]/*' />
            SNAPTOGRID = 278,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.BOOKMARK"]/*' />
            BOOKMARK = 279,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.HYPERLINK"]/*' />
            HYPERLINK = 280,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.IMAGE"]/*' />
            IMAGE = 281,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTFORM"]/*' />
            INSERTFORM = 282,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTSPAN"]/*' />
            INSERTSPAN = 283,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SMARTTASKS"]/*' />
            DIV = 284,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.HTMLCLIENTSCRIPTBLOCK"]/*' />
            HTMLCLIENTSCRIPTBLOCK = 285,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.HTMLSERVERSCRIPTBLOCK"]/*' />
            HTMLSERVERSCRIPTBLOCK = 286,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.BULLETEDLIST"]/*' />
            BULLETEDLIST = 287,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NUMBEREDLIST"]/*' />
            NUMBEREDLIST = 288,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EDITSCRIPT"]/*' />
            EDITSCRIPT = 289,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EDITCODEBEHIND"]/*' />
            EDITCODEBEHIND = 290,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DOCOUTLINEHTML"]/*' />
            DOCOUTLINEHTML = 291,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DOCOUTLINESCRIPT"]/*' />
            DOCOUTLINESCRIPT = 292,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RUNATSERVER"]/*' />
            RUNATSERVER = 293,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.WEBFORMSVERBS"]/*' />
            WEBFORMSVERBS = 294,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.WEBFORMSTEMPLATES"]/*' />
            WEBFORMSTEMPLATES = 295,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ENDTEMPLATE"]/*' />
            ENDTEMPLATE = 296,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EDITDEFAULTEVENT"]/*' />
            EDITDEFAULTEVENT = 297,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SUPERSCRIPT"]/*' />
            SUPERSCRIPT = 298,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SUBSCRIPT"]/*' />
            SUBSCRIPT = 299,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EDITSTYLE"]/*' />
            EDITSTYLE = 300,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDIMAGEHEIGHTWIDTH"]/*' />
            ADDIMAGEHEIGHTWIDTH = 301,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.REMOVEIMAGEHEIGHTWIDTH"]/*' />
            REMOVEIMAGEHEIGHTWIDTH = 302,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LOCKELEMENT"]/*' />
            LOCKELEMENT = 303,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWSTYLEORGANIZER"]/*' />
            VIEWSTYLEORGANIZER = 304,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_AUTOCLOSEOVERRIDE"]/*' />
            ECMD_AUTOCLOSEOVERRIDE = 305,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWANY"]/*' />
            NEWANY = 306,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWANYATTRIBUTE"]/*' />
            NEWANYATTRIBUTE = 307,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DELETEKEY"]/*' />
            DELETEKEY = 308,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AUTOARRANGE"]/*' />
            AUTOARRANGE = 309,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VALIDATESCHEMA"]/*' />
            VALIDATESCHEMA = 310,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWFACET"]/*' />
            NEWFACET = 311,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VALIDATEXMLDATA"]/*' />
            VALIDATEXMLDATA = 312,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DOCOUTLINETOGGLE"]/*' />
            DOCOUTLINETOGGLE = 313,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VALIDATEHTMLDATA"]/*' />
            VALIDATEHTMLDATA = 314,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWXMLSCHEMAOVERVIEW"]/*' />
            VIEWXMLSCHEMAOVERVIEW = 315,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SHOWDEFAULTVIEW"]/*' />
            SHOWDEFAULTVIEW        = 316,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EXPAND_CHILDREN"]/*' />
            EXPAND_CHILDREN        = 317,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.COLLAPSE_CHILDREN"]/*' />
            COLLAPSE_CHILDREN      = 318,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TOPDOWNLAYOUT"]/*' />
            TOPDOWNLAYOUT          = 319,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LEFTRIGHTLAYOUT"]/*' />
            LEFTRIGHTLAYOUT        = 320,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTCELLRIGHT"]/*' />
            INSERTCELLRIGHT        = 321,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EDITMASTER"]/*' />
            EDITMASTER             = 322,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTSNIPPET"]/*' />
            INSERTSNIPPET          = 323,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FORMATANDVALIDATION"]/*' />
            FORMATANDVALIDATION    = 324,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.COLLAPSETAG"]/*' />
            COLLAPSETAG            = 325,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SELECT_TAG"]/*' />
            SELECT_TAG                = 329,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SELECT_TAG_CONTENT"]/*' />
            SELECT_TAG_CONTENT        = 330,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CHECK_ACCESSIBILITY"]/*' />
            CHECK_ACCESSIBILITY    = 331,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UNCOLLAPSETAG"]/*' />
            UNCOLLAPSETAG            = 332,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GENERATEPAGERESOURCE"]/*' />
            GENERATEPAGERESOURCE    = 333,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SHOWNONVISUALCONTROLS"]/*' />
            SHOWNONVISUALCONTROLS    = 334,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RESIZECOLUMN"]/*' />
            RESIZECOLUMN            = 335,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RESIZEROW"]/*' />
            RESIZEROW              = 336,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.MAKEABSOLUTE"]/*' />
            MAKEABSOLUTE        = 337,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.MAKERELATIVE"]/*' />
            MAKERELATIVE        = 338,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.MAKESTATIC"]/*' />
            MAKESTATIC             = 339,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTLAYER"]/*' />
            INSERTLAYER        = 340,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UPDATEDESIGNVIEW"]/*' />
            UPDATEDESIGNVIEW        = 341,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UPDATESOURCEVIEW"]/*' />
            UPDATESOURCEVIEW       = 342,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTCAPTION"]/*' />
            INSERTCAPTION        = 343,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DELETECAPTION"]/*' />
            DELETECAPTION          = 344,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.MAKEPOSITIONNOTSET"]/*' />
            MAKEPOSITIONNOTSET     = 345,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AUTOPOSITIONOPTIONS"]/*' />
            AUTOPOSITIONOPTIONS    = 346,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EDITIMAGE"]/*' />
            EDITIMAGE              = 347,

            //
            // Shareable commands originating in the VC project
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.COMPILE"]/*' />
            COMPILE = 350,
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PROJSETTINGS"]/*' />
            PROJSETTINGS = 352,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LINKONLY"]/*' />
            LINKONLY = 353,
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.REMOVE"]/*' />
            REMOVE = 355,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PROJSTARTDEBUG"]/*' />
            PROJSTARTDEBUG = 356,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PROJSTEPINTO"]/*' />
            PROJSTEPINTO = 357,
            //
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UPDATEWEBREF"]/*' />
            UPDATEWEBREF = 360,
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDRESOURCE"]/*' />
            ADDRESOURCE = 362,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.WEBDEPLOY"]/*' />
            WEBDEPLOY = 363,
            //
            // Shareable commands originating in the VB and VBA projects
            // Note that there are two versions of each command. One
            // version is originally from the main (project) menu and the
            // other version from a cascading "Add" context menu. The main
            // difference between the two commands is that the main menu
            // version starts with the text "Add" whereas this is not
            // present on the context menu version.
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDHTMLPAGE"]/*' />
            ADDHTMLPAGE = 400,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDHTMLPAGECTX"]/*' />
            ADDHTMLPAGECTX = 401,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDMODULE"]/*' />
            ADDMODULE = 402,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDMODULECTX"]/*' />
            ADDMODULECTX = 403,
            // unused 404
            // unused 405
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDWFCFORM"]/*' />
            ADDWFCFORM = 406,
            // unused 407
            // unused 408
            // unused 409
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDWEBFORM"]/*' />
            ADDWEBFORM = 410,
            // unused 411
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDUSERCONTROL"]/*' />
            ADDUSERCONTROL = 412,
            // unused 413 to 425
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDDHTMLPAGE"]/*' />
            ADDDHTMLPAGE = 426,
            // unused 427 to 431
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDIMAGEGENERATOR"]/*' />
            ADDIMAGEGENERATOR = 432,
            // unused 433
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDINHERWFCFORM"]/*' />
            ADDINHERWFCFORM = 434,
            // unused 435
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDINHERCONTROL"]/*' />
            ADDINHERCONTROL = 436,
            // unused 437
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDWEBUSERCONTROL"]/*' />
            ADDWEBUSERCONTROL = 438,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.BUILDANDBROWSE"]/*' />
            BUILDANDBROWSE = 439,
            // unused 440
            // unused 441
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDTBXCOMPONENT"]/*' />
            ADDTBXCOMPONENT = 442,
            // unused 443
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDWEBSERVICE"]/*' />
            ADDWEBSERVICE = 444,
            // unused 445
            //
            // Shareable commands originating in the VFP project
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDVFPPAGE"]/*' />
            ADDVFPPAGE = 500,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SETBREAKPOINT"]/*' />
            SETBREAKPOINT = 501,
            //
            // Shareable commands originating in the HELP WORKSHOP project
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SHOWALLFILES"]/*' />
            SHOWALLFILES = 600,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDTOPROJECT"]/*' />
            ADDTOPROJECT = 601,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDBLANKNODE"]/*' />
            ADDBLANKNODE = 602,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDNODEFROMFILE"]/*' />
            ADDNODEFROMFILE = 603,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CHANGEURLFROMFILE"]/*' />
            CHANGEURLFROMFILE = 604,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EDITTOPIC"]/*' />
            EDITTOPIC = 605,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EDITTITLE"]/*' />
            EDITTITLE = 606,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.MOVENODEUP"]/*' />
            MOVENODEUP = 607,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.MOVENODEDOWN"]/*' />
            MOVENODEDOWN = 608,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.MOVENODELEFT"]/*' />
            MOVENODELEFT = 609,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.MOVENODERIGHT"]/*' />
            MOVENODERIGHT = 610,
            //
            // Shareable commands originating in the Deploy project
            //
            // Note there are two groups of deploy project commands.
            // The first group of deploy commands.
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDOUTPUT"]/*' />
            ADDOUTPUT = 700,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDFILE"]/*' />
            ADDFILE = 701,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.MERGEMODULE"]/*' />
            MERGEMODULE = 702,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDCOMPONENTS"]/*' />
            ADDCOMPONENTS = 703,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LAUNCHINSTALLER"]/*' />
            LAUNCHINSTALLER = 704,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LAUNCHUNINSTALL"]/*' />
            LAUNCHUNINSTALL = 705,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LAUNCHORCA"]/*' />
            LAUNCHORCA = 706,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FILESYSTEMEDITOR"]/*' />
            FILESYSTEMEDITOR = 707,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.REGISTRYEDITOR"]/*' />
            REGISTRYEDITOR = 708,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FILETYPESEDITOR"]/*' />
            FILETYPESEDITOR = 709,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.USERINTERFACEEDITOR"]/*' />
            USERINTERFACEEDITOR = 710,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CUSTOMACTIONSEDITOR"]/*' />
            CUSTOMACTIONSEDITOR = 711,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LAUNCHCONDITIONSEDITOR"]/*' />
            LAUNCHCONDITIONSEDITOR = 712,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EDITOR"]/*' />
            EDITOR = 713,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EXCLUDE"]/*' />
            EXCLUDE = 714,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.REFRESHDEPENDENCIES"]/*' />
            REFRESHDEPENDENCIES = 715,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWOUTPUTS"]/*' />
            VIEWOUTPUTS = 716,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWDEPENDENCIES"]/*' />
            VIEWDEPENDENCIES = 717,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWFILTER"]/*' />
            VIEWFILTER = 718,

            //
            // The Second group of deploy commands.
            // Note that there is a special sub-group in which the relative 
            // positions are important (see below)
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.KEY"]/*' />
            KEY = 750,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.STRING"]/*' />
            STRING = 751,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.BINARY"]/*' />
            BINARY = 752,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DWORD"]/*' />
            DWORD = 753,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.KEYSOLO"]/*' />
            KEYSOLO = 754,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.IMPORT"]/*' />
            IMPORT = 755,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FOLDER"]/*' />
            FOLDER = 756,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PROJECTOUTPUT"]/*' />
            PROJECTOUTPUT = 757,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FILE"]/*' />
            FILE = 758,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDMERGEMODULES"]/*' />
            ADDMERGEMODULES = 759,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CREATESHORTCUT"]/*' />
            CREATESHORTCUT = 760,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LARGEICONS"]/*' />
            LARGEICONS = 761,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SMALLICONS"]/*' />
            SMALLICONS = 762,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LIST"]/*' />
            LIST = 763,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DETAILS"]/*' />
            DETAILS = 764,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDFILETYPE"]/*' />
            ADDFILETYPE = 765,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDACTION"]/*' />
            ADDACTION = 766,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SETASDEFAULT"]/*' />
            SETASDEFAULT = 767,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.MOVEUP"]/*' />
            MOVEUP = 768,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.MOVEDOWN"]/*' />
            MOVEDOWN = 769,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDDIALOG"]/*' />
            ADDDIALOG = 770,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.IMPORTDIALOG"]/*' />
            IMPORTDIALOG = 771,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDFILESEARCH"]/*' />
            ADDFILESEARCH = 772,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDREGISTRYSEARCH"]/*' />
            ADDREGISTRYSEARCH = 773,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDCOMPONENTSEARCH"]/*' />
            ADDCOMPONENTSEARCH = 774,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDLAUNCHCONDITION"]/*' />
            ADDLAUNCHCONDITION = 775,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDCUSTOMACTION"]/*' />
            ADDCUSTOMACTION = 776,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OUTPUTS"]/*' />
            OUTPUTS = 777,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DEPENDENCIES"]/*' />
            DEPENDENCIES = 778,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FILTER"]/*' />
            FILTER = 779,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.COMPONENTS"]/*' />
            COMPONENTS = 780,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ENVSTRING"]/*' />
            ENVSTRING = 781,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CREATEEMPTYSHORTCUT"]/*' />
            CREATEEMPTYSHORTCUT = 782,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDFILECONDITION"]/*' />
            ADDFILECONDITION = 783,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDREGISTRYCONDITION"]/*' />
            ADDREGISTRYCONDITION = 784,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDCOMPONENTCONDITION"]/*' />
            ADDCOMPONENTCONDITION = 785,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDURTCONDITION"]/*' />
            ADDURTCONDITION = 786,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDIISCONDITION"]/*' />
            ADDIISCONDITION = 787,

            //
            // The relative positions of the commands within the following deploy
            // subgroup must remain unaltered, although the group as a whole may
            // be repositioned. Note that the first and last elements are special
            // boundary elements.
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SPECIALFOLDERBASE"]/*' />
            SPECIALFOLDERBASE = 800,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.USERSAPPLICATIONDATAFOLDER"]/*' />
            USERSAPPLICATIONDATAFOLDER = 800,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.COMMONFILES64FOLDER"]/*' />
            COMMONFILES64FOLDER = 801,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.COMMONFILESFOLDER"]/*' />
            COMMONFILESFOLDER = 802,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CUSTOMFOLDER"]/*' />
            CUSTOMFOLDER = 803, 
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.USERSDESKTOP"]/*' />
            USERSDESKTOP = 804, 
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.USERSFAVORITESFOLDER"]/*' />
            USERSFAVORITESFOLDER = 805, 
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FONTSFOLDER"]/*' />
            FONTSFOLDER = 806, 
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GLOBALASSEMBLYCACHEFOLDER"]/*' />
            GLOBALASSEMBLYCACHEFOLDER = 807, 
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.MODULERETARGETABLEFOLDER"]/*' />
            MODULERETARGETABLEFOLDER = 808, 
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.USERSPERSONALDATAFOLDER"]/*' />
            USERSPERSONALDATAFOLDER = 809, 
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PROGRAMFILES64FOLDER"]/*' />
            PROGRAMFILES64FOLDER = 810,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PROGRAMFILESFOLDER"]/*' />
            PROGRAMFILESFOLDER = 811, 
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.USERSPROGRAMSMENU"]/*' />
            USERSPROGRAMSMENU = 812, 
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.USERSSENDTOMENU"]/*' />
            USERSSENDTOMENU = 813, 
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SHAREDCOMPONENTSFOLDER"]/*' />
            SHAREDCOMPONENTSFOLDER = 814, 
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.USERSSTARTMENU"]/*' />
            USERSSTARTMENU = 815, 
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.USERSSTARTUPFOLDER"]/*' />
            USERSSTARTUPFOLDER = 816, 
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SYSTEM64FOLDER"]/*' />
            SYSTEM64FOLDER = 817,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SYSTEMFOLDER"]/*' />
            SYSTEMFOLDER = 818,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.APPLICATIONFOLDER"]/*' />
            APPLICATIONFOLDER = 819, 
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.USERSTEMPLATEFOLDER"]/*' />
            USERSTEMPLATEFOLDER = 820, 
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.WEBCUSTOMFOLDER"]/*' />
            WEBCUSTOMFOLDER = 821, 
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.WINDOWSFOLDER"]/*' />
            WINDOWSFOLDER = 822, 
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SPECIALFOLDERLAST"]/*' />
            SPECIALFOLDERLAST = 823, 
            // End of deploy sub-group
            //
            // Shareable commands originating in the Visual Studio Analyzer project
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EXPORTEVENTS"]/*' />
            EXPORTEVENTS = 900,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.IMPORTEVENTS"]/*' />
            IMPORTEVENTS = 901,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWEVENT"]/*' />
            VIEWEVENT = 902,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWEVENTLIST"]/*' />
            VIEWEVENTLIST = 903,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWCHART"]/*' />
            VIEWCHART = 904,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWMACHINEDIAGRAM"]/*' />
            VIEWMACHINEDIAGRAM = 905,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWPROCESSDIAGRAM"]/*' />
            VIEWPROCESSDIAGRAM = 906,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWSOURCEDIAGRAM"]/*' />
            VIEWSOURCEDIAGRAM = 907,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWSTRUCTUREDIAGRAM"]/*' />
            VIEWSTRUCTUREDIAGRAM = 908,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWTIMELINE"]/*' />
            VIEWTIMELINE = 909,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWSUMMARY"]/*' />
            VIEWSUMMARY = 910,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.APPLYFILTER"]/*' />
            APPLYFILTER = 911,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CLEARFILTER"]/*' />
            CLEARFILTER = 912,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.STARTRECORDING"]/*' />
            STARTRECORDING = 913,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.STOPRECORDING"]/*' />
            STOPRECORDING = 914,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PAUSERECORDING"]/*' />
            PAUSERECORDING = 915,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ACTIVATEFILTER"]/*' />
            ACTIVATEFILTER = 916,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SHOWFIRSTEVENT"]/*' />
            SHOWFIRSTEVENT = 917,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SHOWPREVIOUSEVENT"]/*' />
            SHOWPREVIOUSEVENT = 918,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SHOWNEXTEVENT"]/*' />
            SHOWNEXTEVENT = 919,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SHOWLASTEVENT"]/*' />
            SHOWLASTEVENT = 920,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.REPLAYEVENTS"]/*' />
            REPLAYEVENTS = 921,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.STOPREPLAY"]/*' />
            STOPREPLAY = 922,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INCREASEPLAYBACKSPEED"]/*' />
            INCREASEPLAYBACKSPEED = 923,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DECREASEPLAYBACKSPEED"]/*' />
            DECREASEPLAYBACKSPEED = 924,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDMACHINE"]/*' />
            ADDMACHINE = 925,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDREMOVECOLUMNS"]/*' />
            ADDREMOVECOLUMNS = 926,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SORTCOLUMNS"]/*' />
            SORTCOLUMNS = 927,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SAVECOLUMNSETTINGS"]/*' />
            SAVECOLUMNSETTINGS = 928,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RESETCOLUMNSETTINGS"]/*' />
            RESETCOLUMNSETTINGS = 929,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SIZECOLUMNSTOFIT"]/*' />
            SIZECOLUMNSTOFIT = 930,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AUTOSELECT"]/*' />
            AUTOSELECT = 931,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AUTOFILTER"]/*' />
            AUTOFILTER = 932,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AUTOPLAYTRACK"]/*' />
            AUTOPLAYTRACK = 933,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GOTOEVENT"]/*' />
            GOTOEVENT = 934,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ZOOMTOFIT"]/*' />
            ZOOMTOFIT = 935,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDGRAPH"]/*' />
            ADDGRAPH = 936,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.REMOVEGRAPH"]/*' />
            REMOVEGRAPH = 937,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CONNECTMACHINE"]/*' />
            CONNECTMACHINE = 938,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DISCONNECTMACHINE"]/*' />
            DISCONNECTMACHINE = 939,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EXPANDSELECTION"]/*' />
            EXPANDSELECTION = 940,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.COLLAPSESELECTION"]/*' />
            COLLAPSESELECTION = 941,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDFILTER"]/*' />
            ADDFILTER = 942,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDPREDEFINED0"]/*' />
            ADDPREDEFINED0 = 943,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDPREDEFINED1"]/*' />
            ADDPREDEFINED1 = 944,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDPREDEFINED2"]/*' />
            ADDPREDEFINED2 = 945,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDPREDEFINED3"]/*' />
            ADDPREDEFINED3 = 946,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDPREDEFINED4"]/*' />
            ADDPREDEFINED4 = 947,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDPREDEFINED5"]/*' />
            ADDPREDEFINED5 = 948,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDPREDEFINED6"]/*' />
            ADDPREDEFINED6 = 949,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDPREDEFINED7"]/*' />
            ADDPREDEFINED7 = 950,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDPREDEFINED8"]/*' />
            ADDPREDEFINED8 = 951,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TIMELINESIZETOFIT"]/*' />
            TIMELINESIZETOFIT = 952,

            //
            // Shareable commands originating with Crystal Reports
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FIELDVIEW"]/*' />
            FIELDVIEW = 1000,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SELECTEXPERT"]/*' />
            SELECTEXPERT = 1001,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TOPNEXPERT"]/*' />
            TOPNEXPERT = 1002,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SORTORDER"]/*' />
            SORTORDER = 1003,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PROPPAGE"]/*' />
            PROPPAGE = 1004,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.HELP"]/*' />
            HELP = 1005,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SAVEREPORT"]/*' />
            SAVEREPORT = 1006,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTSUMMARY"]/*' />
            INSERTSUMMARY = 1007,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTGROUP"]/*' />
            INSERTGROUP = 1008,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTSUBREPORT"]/*' />
            INSERTSUBREPORT = 1009,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTCHART"]/*' />
            INSERTCHART = 1010,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTPICTURE"]/*' />
            INSERTPICTURE = 1011,
            //
            // Shareable commands from the common project area (DirPrj)
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SETASSTARTPAGE"]/*' />
            SETASSTARTPAGE = 1100,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RECALCULATELINKS"]/*' />
            RECALCULATELINKS = 1101,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.WEBPERMISSIONS"]/*' />
            WEBPERMISSIONS = 1102,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.COMPARETOMASTER"]/*' />
            COMPARETOMASTER = 1103,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.WORKOFFLINE"]/*' />
            WORKOFFLINE = 1104,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SYNCHRONIZEFOLDER"]/*' />
            SYNCHRONIZEFOLDER = 1105,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SYNCHRONIZEALLFOLDERS"]/*' />
            SYNCHRONIZEALLFOLDERS = 1106,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.COPYPROJECT"]/*' />
            COPYPROJECT = 1107,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.IMPORTFILEFROMWEB"]/*' />
            IMPORTFILEFROMWEB = 1108,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INCLUDEINPROJECT"]/*' />
            INCLUDEINPROJECT = 1109,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EXCLUDEFROMPROJECT"]/*' />
            EXCLUDEFROMPROJECT = 1110,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.BROKENLINKSREPORT"]/*' />
            BROKENLINKSREPORT = 1111,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDPROJECTOUTPUTS"]/*' />
            ADDPROJECTOUTPUTS = 1112,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDREFERENCE"]/*' />
            ADDREFERENCE = 1113,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDWEBREFERENCE"]/*' />
            ADDWEBREFERENCE = 1114,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDWEBREFERENCECTX"]/*' />
            ADDWEBREFERENCECTX = 1115,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UPDATEWEBREFERENCE"]/*' />
            UPDATEWEBREFERENCE = 1116,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RUNCUSTOMTOOL"]/*' />
            RUNCUSTOMTOOL = 1117,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SETRUNTIMEVERSION"]/*' />
            SETRUNTIMEVERSION     = 1118,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWREFINOBJECTBROWSER"]/*' />
            VIEWREFINOBJECTBROWSER  = 1119,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PUBLISH"]/*' />
            PUBLISH               = 1120,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PUBLISHCTX"]/*' />
            PUBLISHCTX            = 1121,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.STARTOPTIONS"]/*' />
            STARTOPTIONS          = 1124,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADDREFERENCECTX"]/*' />
            ADDREFERENCECTX       = 1125,
            // note cmdidPropertyManager is consuming 1126  and it shouldn't
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.STARTOPTIONSCTX"]/*' />
            STARTOPTIONSCTX       = 1127,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DETACHLOCALDATAFILECTX"]/*' />
            DETACHLOCALDATAFILECTX  = 1128,

           //
            // Shareable commands for right drag operations
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DRAG_MOVE"]/*' />
            DRAG_MOVE = 1140,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DRAG_COPY"]/*' />
            DRAG_COPY = 1141,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DRAG_CANCEL"]/*' />
            DRAG_CANCEL = 1142,

            //
            // Shareable commands from the VC resource editor
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TESTDIALOG"]/*' />
            TESTDIALOG = 1200,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SPACEACROSS"]/*' />
            SPACEACROSS = 1201,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SPACEDOWN"]/*' />
            SPACEDOWN = 1202,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TOGGLEGRID"]/*' />
            TOGGLEGRID = 1203,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TOGGLEGUIDES"]/*' />
            TOGGLEGUIDES = 1204,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SIZETOTEXT"]/*' />
            SIZETOTEXT = 1205,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CENTERVERT"]/*' />
            CENTERVERT = 1206,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CENTERHORZ"]/*' />
            CENTERHORZ = 1207,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FLIPDIALOG"]/*' />
            FLIPDIALOG = 1208,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SETTABORDER"]/*' />
            SETTABORDER = 1209,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.BUTTONRIGHT"]/*' />
            BUTTONRIGHT = 1210,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.BUTTONBOTTOM"]/*' />
            BUTTONBOTTOM = 1211,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AUTOLAYOUTGROW"]/*' />
            AUTOLAYOUTGROW = 1212,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AUTOLAYOUTNORESIZE"]/*' />
            AUTOLAYOUTNORESIZE = 1213,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AUTOLAYOUTOPTIMIZE"]/*' />
            AUTOLAYOUTOPTIMIZE = 1214,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GUIDESETTINGS"]/*' />
            GUIDESETTINGS = 1215,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RESOURCEINCLUDES"]/*' />
            RESOURCEINCLUDES = 1216,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RESOURCESYMBOLS"]/*' />
            RESOURCESYMBOLS = 1217,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OPENBINARY"]/*' />
            OPENBINARY = 1218,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RESOURCEOPEN"]/*' />
            RESOURCEOPEN = 1219,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RESOURCENEW"]/*' />
            RESOURCENEW = 1220,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RESOURCENEWCOPY"]/*' />
            RESOURCENEWCOPY = 1221,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERT"]/*' />
            INSERT = 1222,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EXPORT"]/*' />
            EXPORT = 1223,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CTLMOVELEFT"]/*' />
            CTLMOVELEFT = 1224,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CTLMOVEDOWN"]/*' />
            CTLMOVEDOWN = 1225,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CTLMOVERIGHT"]/*' />
            CTLMOVERIGHT = 1226,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CTLMOVEUP"]/*' />
            CTLMOVEUP = 1227,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CTLSIZEDOWN"]/*' />
            CTLSIZEDOWN = 1228,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CTLSIZEUP"]/*' />
            CTLSIZEUP = 1229,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CTLSIZELEFT"]/*' />
            CTLSIZELEFT = 1230,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CTLSIZERIGHT"]/*' />
            CTLSIZERIGHT = 1231,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWACCELERATOR"]/*' />
            NEWACCELERATOR = 1232,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CAPTUREKEYSTROKE"]/*' />
            CAPTUREKEYSTROKE = 1233,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INSERTACTIVEXCTL"]/*' />
            INSERTACTIVEXCTL = 1234,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.INVERTCOLORS"]/*' />
            INVERTCOLORS = 1235,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FLIPHORIZONTAL"]/*' />
            FLIPHORIZONTAL = 1236,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FLIPVERTICAL"]/*' />
            FLIPVERTICAL = 1237,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ROTATE90"]/*' />
            ROTATE90 = 1238,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SHOWCOLORSWINDOW"]/*' />
            SHOWCOLORSWINDOW = 1239,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWSTRING"]/*' />
            NEWSTRING = 1240,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWINFOBLOCK"]/*' />
            NEWINFOBLOCK = 1241,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DELETEINFOBLOCK"]/*' />
            DELETEINFOBLOCK = 1242,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ADJUSTCOLORS"]/*' />
            ADJUSTCOLORS = 1243,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LOADPALETTE"]/*' />
            LOADPALETTE = 1244,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SAVEPALETTE"]/*' />
            SAVEPALETTE = 1245,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CHECKMNEMONICS"]/*' />
            CHECKMNEMONICS = 1246,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DRAWOPAQUE"]/*' />
            DRAWOPAQUE = 1247,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TOOLBAREDITOR"]/*' />
            TOOLBAREDITOR = 1248,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GRIDSETTINGS"]/*' />
            GRIDSETTINGS = 1249,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEWDEVICEIMAGE"]/*' />
            NEWDEVICEIMAGE = 1250,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OPENDEVICEIMAGE"]/*' />
            OPENDEVICEIMAGE = 1251,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DELETEDEVICEIMAGE"]/*' />
            DELETEDEVICEIMAGE = 1252,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VIEWASPOPUP"]/*' />
            VIEWASPOPUP = 1253,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CHECKMENUMNEMONICS"]/*' />
            CHECKMENUMNEMONICS = 1254,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SHOWIMAGEGRID"]/*' />
            SHOWIMAGEGRID = 1255,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SHOWTILEGRID"]/*' />
            SHOWTILEGRID = 1256,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.MAGNIFY"]/*' />
            MAGNIFY = 1257,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ResProps"]/*' />
            ResProps = 1258,
            //
            // Shareable commands from the VC resource editor (Image editor toolbar)
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PICKRECTANGLE"]/*' />
            PICKRECTANGLE = 1300,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PICKREGION"]/*' />
            PICKREGION = 1301,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PICKCOLOR"]/*' />
            PICKCOLOR = 1302,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ERASERTOOL"]/*' />
            ERASERTOOL = 1303,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FILLTOOL"]/*' />
            FILLTOOL = 1304,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PENCILTOOL"]/*' />
            PENCILTOOL = 1305,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.BRUSHTOOL"]/*' />
            BRUSHTOOL = 1306,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AIRBRUSHTOOL"]/*' />
            AIRBRUSHTOOL = 1307,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LINETOOL"]/*' />
            LINETOOL = 1308,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CURVETOOL"]/*' />
            CURVETOOL = 1309,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TEXTTOOL"]/*' />
            TEXTTOOL = 1310,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RECTTOOL"]/*' />
            RECTTOOL = 1311,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OUTLINERECTTOOL"]/*' />
            OUTLINERECTTOOL = 1312,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FILLEDRECTTOOL"]/*' />
            FILLEDRECTTOOL = 1313,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ROUNDRECTTOOL"]/*' />
            ROUNDRECTTOOL = 1314,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OUTLINEROUNDRECTTOOL"]/*' />
            OUTLINEROUNDRECTTOOL = 1315,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FILLEDROUNDRECTTOOL"]/*' />
            FILLEDROUNDRECTTOOL = 1316,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ELLIPSETOOL"]/*' />
            ELLIPSETOOL = 1317,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OUTLINEELLIPSETOOL"]/*' />
            OUTLINEELLIPSETOOL = 1318,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FILLEDELLIPSETOOL"]/*' />
            FILLEDELLIPSETOOL = 1319,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SETHOTSPOT"]/*' />
            SETHOTSPOT = 1320,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ZOOMTOOL"]/*' />
            ZOOMTOOL = 1321,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ZOOM1X"]/*' />
            ZOOM1X = 1322,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ZOOM2X"]/*' />
            ZOOM2X = 1323,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ZOOM6X"]/*' />
            ZOOM6X = 1324,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ZOOM8X"]/*' />
            ZOOM8X = 1325,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TRANSPARENTBCKGRND"]/*' />
            TRANSPARENTBCKGRND = 1326,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OPAQUEBCKGRND"]/*' />
            OPAQUEBCKGRND = 1327,
            //---------------------------------------------------
            // The commands ECMD_ERASERSMALL thru ECMD_LINELARGER
            // must be left in the same order for the use of the
            // Resource Editor - They may however be relocated as
            // a complete block
            //---------------------------------------------------
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ERASERSMALL"]/*' />
            ERASERSMALL = 1328,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ERASERMEDIUM"]/*' />
            ERASERMEDIUM = 1329,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ERASERLARGE"]/*' />
            ERASERLARGE = 1330,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ERASERLARGER"]/*' />
            ERASERLARGER = 1331,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CIRCLELARGE"]/*' />
            CIRCLELARGE = 1332,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CIRCLEMEDIUM"]/*' />
            CIRCLEMEDIUM = 1333,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CIRCLESMALL"]/*' />
            CIRCLESMALL = 1334,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SQUARELARGE"]/*' />
            SQUARELARGE = 1335,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SQUAREMEDIUM"]/*' />
            SQUAREMEDIUM = 1336,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SQUARESMALL"]/*' />
            SQUARESMALL = 1337,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LEFTDIAGLARGE"]/*' />
            LEFTDIAGLARGE = 1338,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LEFTDIAGMEDIUM"]/*' />
            LEFTDIAGMEDIUM = 1339,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LEFTDIAGSMALL"]/*' />
            LEFTDIAGSMALL = 1340,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RIGHTDIAGLARGE"]/*' />
            RIGHTDIAGLARGE = 1341,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RIGHTDIAGMEDIUM"]/*' />
            RIGHTDIAGMEDIUM = 1342,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RIGHTDIAGSMALL"]/*' />
            RIGHTDIAGSMALL = 1343,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SPLASHSMALL"]/*' />
            SPLASHSMALL = 1344,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SPLASHMEDIUM"]/*' />
            SPLASHMEDIUM = 1345,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SPLASHLARGE"]/*' />
            SPLASHLARGE = 1346,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LINESMALLER"]/*' />
            LINESMALLER = 1347,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LINESMALL"]/*' />
            LINESMALL = 1348,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LINEMEDIUM"]/*' />
            LINEMEDIUM = 1349,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LINELARGE"]/*' />
            LINELARGE = 1350,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LINELARGER"]/*' />
            LINELARGER = 1351,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LARGERBRUSH"]/*' />
            LARGERBRUSH = 1352,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.LARGEBRUSH"]/*' />
            LARGEBRUSH = 1353,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.STDBRUSH"]/*' />
            STDBRUSH = 1354,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SMALLBRUSH"]/*' />
            SMALLBRUSH = 1355,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SMALLERBRUSH"]/*' />
            SMALLERBRUSH = 1356,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ZOOMIN"]/*' />
            ZOOMIN = 1357,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ZOOMOUT"]/*' />
            ZOOMOUT = 1358,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PREVCOLOR"]/*' />
            PREVCOLOR = 1359,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PREVECOLOR"]/*' />
            PREVECOLOR = 1360,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEXTCOLOR"]/*' />
            NEXTCOLOR = 1361,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEXTECOLOR"]/*' />
            NEXTECOLOR = 1362,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.IMG_OPTIONS"]/*' />
            IMG_OPTIONS = 1363,

            //
            // Sharable Commands from Visual Web Developer (website projects)
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.STARTWEBADMINTOOL"]/*' />
            STARTWEBADMINTOOL     = 1400,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NESTRELATEDFILES"]/*' />
            NESTRELATEDFILES      = 1401,

            //---------------------------------------------------

            //
            // Shareable commands from WINFORMS
            //
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CANCELDRAG"]/*' />
            CANCELDRAG = 1500,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DEFAULTACTION"]/*' />
            DEFAULTACTION = 1501,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CTLMOVEUPGRID"]/*' />
            CTLMOVEUPGRID = 1502,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CTLMOVEDOWNGRID"]/*' />
            CTLMOVEDOWNGRID = 1503,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CTLMOVELEFTGRID"]/*' />
            CTLMOVELEFTGRID = 1504,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CTLMOVERIGHTGRID"]/*' />
            CTLMOVERIGHTGRID = 1505,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CTLSIZERIGHTGRID"]/*' />
            CTLSIZERIGHTGRID = 1506,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CTLSIZEUPGRID"]/*' />
            CTLSIZEUPGRID = 1507,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CTLSIZELEFTGRID"]/*' />
            CTLSIZELEFTGRID = 1508,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CTLSIZEDOWNGRID"]/*' />
            CTLSIZEDOWNGRID = 1509,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NEXTCTL"]/*' />
            NEXTCTL = 1510,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PREVCTL"]/*' />
            PREVCTL = 1511,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RENAME"]/*' />
            RENAME                = 1550,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EXTRACTMETHOD"]/*' />
            EXTRACTMETHOD         = 1551,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ENCAPSULATEFIELD"]/*' />
            ENCAPSULATEFIELD      = 1552,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EXTRACTINTERFACE"]/*' />
            EXTRACTINTERFACE      = 1553,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PROMOTELOCAL"]/*' />
            PROMOTELOCAL          = 1554,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.REMOVEPARAMETERS"]/*' />
            REMOVEPARAMETERS      = 1555,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.REORDERPARAMETERS"]/*' />
            REORDERPARAMETERS     = 1556,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GENERATEMETHODSTUB"]/*' />
            GENERATEMETHODSTUB    = 1557,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.IMPLEMENTINTERFACEIMPLICIT"]/*' />
            IMPLEMENTINTERFACEIMPLICIT   = 1558,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.IMPLEMENTINTERFACEEXPLICIT"]/*' />
            IMPLEMENTINTERFACEEXPLICIT   = 1559,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.IMPLEMENTABSTRACTCLASS"]/*' />
            IMPLEMENTABSTRACTCLASS       = 1560,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SURROUNDWITH"]/*' />
            SURROUNDWITH                 = 1561,

            // this is coming in with the VS2K guid?
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.QUICKOBJECTSEARCH"]/*' />
            QUICKOBJECTSEARCH = 1119,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ToggleWordWrapOW"]/*' />
            ToggleWordWrapOW = 1600,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GotoNextLocationOW"]/*' />
            GotoNextLocationOW = 1601,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GotoPrevLocationOW"]/*' />
            GotoPrevLocationOW = 1602,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.BuildOnlyProject"]/*' />
            BuildOnlyProject = 1603,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RebuildOnlyProject"]/*' />
            RebuildOnlyProject = 1604,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CleanOnlyProject"]/*' />
            CleanOnlyProject = 1605,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SetBuildStartupsOnlyOnRun"]/*' />
            SetBuildStartupsOnlyOnRun = 1606,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UnhideAll"]/*' />
            UnhideAll = 1607,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.HideFolder"]/*' />
            HideFolder = 1608,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UnhideFolders"]/*' />
            UnhideFolders = 1609,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CopyFullPathName"]/*' />
            CopyFullPathName = 1610,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SaveFolderAsSolution"]/*' />
            SaveFolderAsSolution = 1611,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ManageUserSettings"]/*' />
            ManageUserSettings = 1612,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewSolutionFolder"]/*' />
            NewSolutionFolder = 1613,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ClearPaneOW"]/*' />
            ClearPaneOW = 1615,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GotoErrorTagOW"]/*' />
            GotoErrorTagOW = 1616,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GotoNextErrorTagOW"]/*' />
            GotoNextErrorTagOW = 1617,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GotoPrevErrorTagOW"]/*' />
            GotoPrevErrorTagOW = 1618,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ClearPaneFR1"]/*' />
            ClearPaneFR1 = 1619,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GotoErrorTagFR1"]/*' />
            GotoErrorTagFR1 = 1620,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GotoNextErrorTagFR1"]/*' />
            GotoNextErrorTagFR1 = 1621,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GotoPrevErrorTagFR1"]/*' />
            GotoPrevErrorTagFR1 = 1622,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ClearPaneFR2"]/*' />
            ClearPaneFR2 = 1623,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GotoErrorTagFR2"]/*' />
            GotoErrorTagFR2 = 1624,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GotoNextErrorTagFR2"]/*' />
            GotoNextErrorTagFR2 = 1625,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GotoPrevErrorTagFR2"]/*' />
            GotoPrevErrorTagFR2 = 1626,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OutputPaneCombo"]/*' />
            OutputPaneCombo = 1627,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OutputPaneComboList"]/*' />
            OutputPaneComboList = 1628,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DisableDockingChanges"]/*' />
            DisableDockingChanges = 1629,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ToggleFloat"]/*' />
            ToggleFloat = 1630,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ResetLayout"]/*' />
            ResetLayout = 1631,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewSolutionFolderBar"]/*' />
            NewSolutionFolderBar = 1638,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DataShortcut"]/*' />
            DataShortcut = 1639,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NextToolWindow"]/*' />
            NextToolWindow = 1640,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PrevToolWindow"]/*' />
            PrevToolWindow = 1641,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.BrowseToFileInExplorer"]/*' />
            BrowseToFileInExplorer = 1642,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ShowEzMDIFileMenu"]/*' />
            ShowEzMDIFileMenu = 1643,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.PrevToolWindowNav"]/*' />
            PrevToolWindowNav = 1645,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.StaticAnalysisOnlyProject"]/*' />
            StaticAnalysisOnlyProject = 1646,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_RUNFXCOPSEL"]/*' />
            ECMD_RUNFXCOPSEL = 1647,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CloseAllButThis"]/*' />
            CloseAllButThis = 1650,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ControlGallery"]/*' />
            ControlGallery = 1700,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FullScreen2"]/*' />
            FullScreen2 = 1775,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NavigateBack"]/*' />
            NavigateBack = 1800,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NavigateForward"]/*' />
            NavigateForward = 1801,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CORRECTION_1"]/*' />
            ECMD_CORRECTION_1 = 1900,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CORRECTION_2"]/*' />
            ECMD_CORRECTION_2 = 1901,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CORRECTION_3"]/*' />
            ECMD_CORRECTION_3 = 1902,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CORRECTION_4"]/*' />
            ECMD_CORRECTION_4 = 1903,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CORRECTION_5"]/*' />
            ECMD_CORRECTION_5 = 1904,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CORRECTION_6"]/*' />
            ECMD_CORRECTION_6 = 1905,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CORRECTION_7"]/*' />
            ECMD_CORRECTION_7 = 1906,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CORRECTION_8"]/*' />
            ECMD_CORRECTION_8 = 1907,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CORRECTION_9"]/*' />
            ECMD_CORRECTION_9 = 1908,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CORRECTION_10"]/*' />
            ECMD_CORRECTION_10 = 1909,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.OBAddReference"]/*' />
            OBAddReference = 1914,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.FindReferences"]/*' />
            FindReferences = 1915,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CodeDefView"]/*' />
            CodeDefView = 1926,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CodeDefViewGoToPrev"]/*' />
            CodeDefViewGoToPrev = 1927,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CodeDefViewGoToNext"]/*' />
            CodeDefViewGoToNext = 1928,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CodeDefViewEditDefinition"]/*' />
            CodeDefViewEditDefinition = 1929,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CodeDefViewChooseEncoding"]/*' />
            CodeDefViewChooseEncoding = 1930,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ViewInClassDiagram"]/*' />
            ViewInClassDiagram = 1931,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_ADDDBTABLE"]/*' />
            ECMD_ADDDBTABLE = 1950,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_ADDDATATABLE"]/*' />
            ECMD_ADDDATATABLE = 1951,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_ADDFUNCTION"]/*' />
            ECMD_ADDFUNCTION = 1952,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_ADDRELATION"]/*' />
            ECMD_ADDRELATION = 1953,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_ADDKEY"]/*' />
            ECMD_ADDKEY = 1954,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_ADDCOLUMN"]/*' />
            ECMD_ADDCOLUMN = 1955,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CONVERT_DBTABLE"]/*' />
            ECMD_CONVERT_DBTABLE = 1956,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CONVERT_DATATABLE"]/*' />
            ECMD_CONVERT_DATATABLE = 1957,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_GENERATE_DATABASE"]/*' />
            ECMD_GENERATE_DATABASE = 1958,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CONFIGURE_CONNECTIONS"]/*' />
            ECMD_CONFIGURE_CONNECTIONS = 1959,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_IMPORT_XMLSCHEMA"]/*' />
            ECMD_IMPORT_XMLSCHEMA = 1960,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_SYNC_WITH_DATABASE"]/*' />
            ECMD_SYNC_WITH_DATABASE = 1961,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CONFIGURE"]/*' />
            ECMD_CONFIGURE = 1962,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CREATE_DATAFORM"]/*' />
            ECMD_CREATE_DATAFORM = 1963,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CREATE_ENUM"]/*' />
            ECMD_CREATE_ENUM = 1964,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_INSERT_FUNCTION"]/*' />
            ECMD_INSERT_FUNCTION = 1965,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_EDIT_FUNCTION"]/*' />
            ECMD_EDIT_FUNCTION = 1966,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_SET_PRIMARY_KEY"]/*' />
            ECMD_SET_PRIMARY_KEY = 1967,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_INSERT_COLUMN"]/*' />
            ECMD_INSERT_COLUMN = 1968,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_AUTO_SIZE"]/*' />
            ECMD_AUTO_SIZE = 1969,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_SHOW_RELATION_LABELS"]/*' />
            ECMD_SHOW_RELATION_LABELS = 1970,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VSDGenerateDataSet"]/*' />
            VSDGenerateDataSet = 1971,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VSDPreview"]/*' />
            VSDPreview = 1972,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VSDConfigureAdapter"]/*' />
            VSDConfigureAdapter = 1973,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VSDViewDatasetSchema"]/*' />
            VSDViewDatasetSchema = 1974,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VSDDatasetProperties"]/*' />
            VSDDatasetProperties = 1975,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VSDParameterizeForm"]/*' />
            VSDParameterizeForm = 1976,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.VSDAddChildForm"]/*' />
            VSDAddChildForm = 1977,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_EDITCONSTRAINT"]/*' />
            ECMD_EDITCONSTRAINT = 1978,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_DELETECONSTRAINT"]/*' />
            ECMD_DELETECONSTRAINT = 1979,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_EDITDATARELATION"]/*' />
            ECMD_EDITDATARELATION = 1980,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CloseProject"]/*' />
            CloseProject = 1982,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ReloadCommandBars"]/*' />
            ReloadCommandBars = 1983,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SolutionPlatform"]/*' />
            SolutionPlatform = 1990,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SolutionPlatformGetList"]/*' />
            SolutionPlatformGetList = 1991,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_DATAACCESSOR"]/*' />
            ECMD_DATAACCESSOR = 2000,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_ADD_DATAACCESSOR"]/*' />
            ECMD_ADD_DATAACCESSOR = 2001,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_QUERY"]/*' />
            ECMD_QUERY = 2002,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_ADD_QUERY"]/*' />
            ECMD_ADD_QUERY = 2003,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_PUBLISHSELECTION"]/*' />
            ECMD_PUBLISHSELECTION = 2005,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_PUBLISHSLNCTX"]/*' />
            ECMD_PUBLISHSLNCTX = 2006,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowserShowCallsTo"]/*' />
            CallBrowserShowCallsTo = 2010,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowserShowCallsFrom"]/*' />
            CallBrowserShowCallsFrom = 2011,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowserShowNewCallsTo"]/*' />
            CallBrowserShowNewCallsTo = 2012,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowserShowNewCallsFrom"]/*' />
            CallBrowserShowNewCallsFrom = 2013,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser1ShowCallsTo"]/*' />
            CallBrowser1ShowCallsTo = 2014,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser2ShowCallsTo"]/*' />
            CallBrowser2ShowCallsTo = 2015,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser3ShowCallsTo"]/*' />
            CallBrowser3ShowCallsTo = 2016,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser4ShowCallsTo"]/*' />
            CallBrowser4ShowCallsTo = 2017,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser5ShowCallsTo"]/*' />
            CallBrowser5ShowCallsTo = 2018,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser6ShowCallsTo"]/*' />
            CallBrowser6ShowCallsTo = 2019,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser7ShowCallsTo"]/*' />
            CallBrowser7ShowCallsTo = 2020,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser8ShowCallsTo"]/*' />
            CallBrowser8ShowCallsTo = 2021,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser9ShowCallsTo"]/*' />
            CallBrowser9ShowCallsTo = 2022,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser10ShowCallsTo"]/*' />
            CallBrowser10ShowCallsTo = 2023,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser11ShowCallsTo"]/*' />
            CallBrowser11ShowCallsTo = 2024,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser12ShowCallsTo"]/*' />
            CallBrowser12ShowCallsTo = 2025,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser13ShowCallsTo"]/*' />
            CallBrowser13ShowCallsTo = 2026,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser14ShowCallsTo"]/*' />
            CallBrowser14ShowCallsTo = 2027,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser15ShowCallsTo"]/*' />
            CallBrowser15ShowCallsTo = 2028,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser16ShowCallsTo"]/*' />
            CallBrowser16ShowCallsTo = 2029,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser1ShowCallsFrom"]/*' />
            CallBrowser1ShowCallsFrom = 2030,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser2ShowCallsFrom"]/*' />
            CallBrowser2ShowCallsFrom = 2031,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser3ShowCallsFrom"]/*' />
            CallBrowser3ShowCallsFrom = 2032,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser4ShowCallsFrom"]/*' />
            CallBrowser4ShowCallsFrom = 2033,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser5ShowCallsFrom"]/*' />
            CallBrowser5ShowCallsFrom = 2034,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser6ShowCallsFrom"]/*' />
            CallBrowser6ShowCallsFrom = 2035,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser7ShowCallsFrom"]/*' />
            CallBrowser7ShowCallsFrom = 2036,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser8ShowCallsFrom"]/*' />
            CallBrowser8ShowCallsFrom = 2037,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser9ShowCallsFrom"]/*' />
            CallBrowser9ShowCallsFrom = 2038,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser10ShowCallsFrom"]/*' />
            CallBrowser10ShowCallsFrom = 2039,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser11ShowCallsFrom"]/*' />
            CallBrowser11ShowCallsFrom = 2040,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser12ShowCallsFrom"]/*' />
            CallBrowser12ShowCallsFrom = 2041,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser13ShowCallsFrom"]/*' />
            CallBrowser13ShowCallsFrom = 2042,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser14ShowCallsFrom"]/*' />
            CallBrowser14ShowCallsFrom = 2043,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser15ShowCallsFrom"]/*' />
            CallBrowser15ShowCallsFrom = 2044,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser16ShowCallsFrom"]/*' />
            CallBrowser16ShowCallsFrom = 2045,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser1ShowFullNames"]/*' />
            CallBrowser1ShowFullNames = 2046,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser2ShowFullNames"]/*' />
            CallBrowser2ShowFullNames = 2047,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser3ShowFullNames"]/*' />
            CallBrowser3ShowFullNames = 2048,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser4ShowFullNames"]/*' />
            CallBrowser4ShowFullNames = 2049,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser5ShowFullNames"]/*' />
            CallBrowser5ShowFullNames = 2050,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser6ShowFullNames"]/*' />
            CallBrowser6ShowFullNames = 2051,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser7ShowFullNames"]/*' />
            CallBrowser7ShowFullNames = 2052,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser8ShowFullNames"]/*' />
            CallBrowser8ShowFullNames = 2053,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser9ShowFullNames"]/*' />
            CallBrowser9ShowFullNames = 2054,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser10ShowFullNames"]/*' />
            CallBrowser10ShowFullNames = 2055,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser11ShowFullNames"]/*' />
            CallBrowser11ShowFullNames = 2056,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser12ShowFullNames"]/*' />
            CallBrowser12ShowFullNames = 2057,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser13ShowFullNames"]/*' />
            CallBrowser13ShowFullNames = 2058,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser14ShowFullNames"]/*' />
            CallBrowser14ShowFullNames = 2059,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser15ShowFullNames"]/*' />
            CallBrowser15ShowFullNames = 2060,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser16ShowFullNames"]/*' />
            CallBrowser16ShowFullNames = 2061,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser1Settings"]/*' />
            CallBrowser1Settings = 2062,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser2Settings"]/*' />
            CallBrowser2Settings = 2063,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser3Settings"]/*' />
            CallBrowser3Settings = 2064,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser4Settings"]/*' />
            CallBrowser4Settings = 2065,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser5Settings"]/*' />
            CallBrowser5Settings = 2066,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser6Settings"]/*' />
            CallBrowser6Settings = 2067,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser7Settings"]/*' />
            CallBrowser7Settings = 2068,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser8Settings"]/*' />
            CallBrowser8Settings = 2069,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser9Settings"]/*' />
            CallBrowser9Settings = 2070,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser10Settings"]/*' />
            CallBrowser10Settings = 2071,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser11Settings"]/*' />
            CallBrowser11Settings = 2072,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser12Settings"]/*' />
            CallBrowser12Settings = 2073,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser13Settings"]/*' />
            CallBrowser13Settings = 2074,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser14Settings"]/*' />
            CallBrowser14Settings = 2075,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser15Settings"]/*' />
            CallBrowser15Settings = 2076,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser16Settings"]/*' />
            CallBrowser16Settings = 2077,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser1SortAlpha"]/*' />
            CallBrowser1SortAlpha = 2078,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser2SortAlpha"]/*' />
            CallBrowser2SortAlpha = 2079,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser3SortAlpha"]/*' />
            CallBrowser3SortAlpha = 2080,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser4SortAlpha"]/*' />
            CallBrowser4SortAlpha = 2081,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser5SortAlpha"]/*' />
            CallBrowser5SortAlpha = 2082,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser6SortAlpha"]/*' />
            CallBrowser6SortAlpha = 2083,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser7SortAlpha"]/*' />
            CallBrowser7SortAlpha = 2084,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser8SortAlpha"]/*' />
            CallBrowser8SortAlpha = 2085,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser9SortAlpha"]/*' />
            CallBrowser9SortAlpha = 2086,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser10SortAlpha"]/*' />
            CallBrowser10SortAlpha = 2087,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser11SortAlpha"]/*' />
            CallBrowser11SortAlpha = 2088,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser12SortAlpha"]/*' />
            CallBrowser12SortAlpha = 2089,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser13SortAlpha"]/*' />
            CallBrowser13SortAlpha = 2090,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser14SortAlpha"]/*' />
            CallBrowser14SortAlpha = 2091,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser15SortAlpha"]/*' />
            CallBrowser15SortAlpha = 2092,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser16SortAlpha"]/*' />
            CallBrowser16SortAlpha = 2093,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser1SortAccess"]/*' />
            CallBrowser1SortAccess = 2094,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser2SortAccess"]/*' />
            CallBrowser2SortAccess = 2095,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser3SortAccess"]/*' />
            CallBrowser3SortAccess = 2096,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser4SortAccess"]/*' />
            CallBrowser4SortAccess = 2097,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser5SortAccess"]/*' />
            CallBrowser5SortAccess = 2098,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser6SortAccess"]/*' />
            CallBrowser6SortAccess = 2099,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser7SortAccess"]/*' />
            CallBrowser7SortAccess = 2100,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser8SortAccess"]/*' />
            CallBrowser8SortAccess = 2101,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser9SortAccess"]/*' />
            CallBrowser9SortAccess = 2102,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser10SortAccess"]/*' />
            CallBrowser10SortAccess = 2103,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser11SortAccess"]/*' />
            CallBrowser11SortAccess = 2104,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser12SortAccess"]/*' />
            CallBrowser12SortAccess = 2105,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser13SortAccess"]/*' />
            CallBrowser13SortAccess = 2106,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser14SortAccess"]/*' />
            CallBrowser14SortAccess = 2107,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser15SortAccess"]/*' />
            CallBrowser15SortAccess = 2108,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser16SortAccess"]/*' />
            CallBrowser16SortAccess = 2109,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ShowCallBrowser"]/*' />
            ShowCallBrowser = 2120,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser1"]/*' />
            CallBrowser1 = 2121,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser2"]/*' />
            CallBrowser2 = 2122,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser3"]/*' />
            CallBrowser3 = 2123,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser4"]/*' />
            CallBrowser4 = 2124,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser5"]/*' />
            CallBrowser5 = 2125,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser6"]/*' />
            CallBrowser6 = 2126,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser7"]/*' />
            CallBrowser7 = 2127,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser8"]/*' />
            CallBrowser8 = 2128,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser9"]/*' />
            CallBrowser9 = 2129,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser10"]/*' />
            CallBrowser10 = 2130,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser11"]/*' />
            CallBrowser11 = 2131,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser12"]/*' />
            CallBrowser12 = 2132,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser13"]/*' />
            CallBrowser13 = 2133,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser14"]/*' />
            CallBrowser14 = 2134,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser15"]/*' />
            CallBrowser15 = 2135,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser16"]/*' />
            CallBrowser16 = 2136,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser17"]/*' />
            CallBrowser17 = 2137,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GlobalUndo"]/*' />
            GlobalUndo = 2138,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GlobalRedo"]/*' />
            GlobalRedo = 2139,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowserShowCallsToCmd"]/*' />
            CallBrowserShowCallsToCmd = 2140,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowserShowCallsFromCmd"]/*' />
            CallBrowserShowCallsFromCmd = 2141,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowserShowNewCallsToCmd"]/*' />
            CallBrowserShowNewCallsToCmd = 2142,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowserShowNewCallsFromCmd"]/*' />
            CallBrowserShowNewCallsFromCmd = 2143,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser1Search"]/*' />
            CallBrowser1Search = 2145,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser2Search"]/*' />
            CallBrowser2Search = 2146,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser3Search"]/*' />
            CallBrowser3Search = 2147,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser4Search"]/*' />
            CallBrowser4Search = 2148,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser5Search"]/*' />
            CallBrowser5Search = 2149,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser6Search"]/*' />
            CallBrowser6Search = 2150,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser7Search"]/*' />
            CallBrowser7Search = 2151,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser8Search"]/*' />
            CallBrowser8Search = 2152,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser9Search"]/*' />
            CallBrowser9Search = 2153,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser10Search"]/*' />
            CallBrowser10Search = 2154,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser11Search"]/*' />
            CallBrowser11Search = 2155,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser12Search"]/*' />
            CallBrowser12Search = 2156,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser13Search"]/*' />
            CallBrowser13Search = 2157,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser14Search"]/*' />
            CallBrowser14Search = 2158,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser15Search"]/*' />
            CallBrowser15Search = 2159,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser16Search"]/*' />
            CallBrowser16Search = 2160,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser1Refresh"]/*' />
            CallBrowser1Refresh = 2161,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser2Refresh"]/*' />
            CallBrowser2Refresh = 2162,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser3Refresh"]/*' />
            CallBrowser3Refresh = 2163,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser4Refresh"]/*' />
            CallBrowser4Refresh = 2164,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser5Refresh"]/*' />
            CallBrowser5Refresh = 2165,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser6Refresh"]/*' />
            CallBrowser6Refresh = 2166,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser7Refresh"]/*' />
            CallBrowser7Refresh = 2167,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser8Refresh"]/*' />
            CallBrowser8Refresh = 2168,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser9Refresh"]/*' />
            CallBrowser9Refresh = 2169,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser10Refresh"]/*' />
            CallBrowser10Refresh = 2170,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser11Refresh"]/*' />
            CallBrowser11Refresh = 2171,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser12Refresh"]/*' />
            CallBrowser12Refresh = 2172,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser13Refresh"]/*' />
            CallBrowser13Refresh = 2173,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser14Refresh"]/*' />
            CallBrowser14Refresh = 2174,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser15Refresh"]/*' />
            CallBrowser15Refresh = 2175,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser16Refresh"]/*' />
            CallBrowser16Refresh = 2176,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser1SearchCombo"]/*' />
            CallBrowser1SearchCombo = 2180,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser2SearchCombo"]/*' />
            CallBrowser2SearchCombo = 2181,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser3SearchCombo"]/*' />
            CallBrowser3SearchCombo = 2182,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser4SearchCombo"]/*' />
            CallBrowser4SearchCombo = 2183,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser5SearchCombo"]/*' />
            CallBrowser5SearchCombo = 2184,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser6SearchCombo"]/*' />
            CallBrowser6SearchCombo = 2185,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser7SearchCombo"]/*' />
            CallBrowser7SearchCombo = 2186,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser8SearchCombo"]/*' />
            CallBrowser8SearchCombo = 2187,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser9SearchCombo"]/*' />
            CallBrowser9SearchCombo = 2188,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser10SearchCombo"]/*' />
            CallBrowser10SearchCombo = 2189,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser11SearchCombo"]/*' />
            CallBrowser11SearchCombo = 2190,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser12SearchCombo"]/*' />
            CallBrowser12SearchCombo = 2191,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser13SearchCombo"]/*' />
            CallBrowser13SearchCombo = 2192,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser14SearchCombo"]/*' />
            CallBrowser14SearchCombo = 2193,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser15SearchCombo"]/*' />
            CallBrowser15SearchCombo = 2194,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser16SearchCombo"]/*' />
            CallBrowser16SearchCombo = 2195,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TaskListProviderCombo"]/*' />
            TaskListProviderCombo = 2200,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TaskListProviderComboList"]/*' />
            TaskListProviderComboList = 2201,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CreateUserTask"]/*' />
            CreateUserTask = 2202,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ErrorListShowErrors"]/*' />
            ErrorListShowErrors = 2210,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ErrorListShowWarnings"]/*' />
            ErrorListShowWarnings = 2211,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ErrorListShowMessages"]/*' />
            ErrorListShowMessages = 2212,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.Registration"]/*' />
            Registration = 2214,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser1SearchComboList"]/*' />
            CallBrowser1SearchComboList = 2215,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser2SearchComboList"]/*' />
            CallBrowser2SearchComboList = 2216,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser3SearchComboList"]/*' />
            CallBrowser3SearchComboList = 2217,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser4SearchComboList"]/*' />
            CallBrowser4SearchComboList = 2218,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser5SearchComboList"]/*' />
            CallBrowser5SearchComboList = 2219,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser6SearchComboList"]/*' />
            CallBrowser6SearchComboList = 2220,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser7SearchComboList"]/*' />
            CallBrowser7SearchComboList = 2221,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser8SearchComboList"]/*' />
            CallBrowser8SearchComboList = 2222,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser9SearchComboList"]/*' />
            CallBrowser9SearchComboList = 2223,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser10SearchComboList"]/*' />
            CallBrowser10SearchComboList = 2224,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser11SearchComboList"]/*' />
            CallBrowser11SearchComboList = 2225,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser12SearchComboList"]/*' />
            CallBrowser12SearchComboList = 2226,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser13SearchComboList"]/*' />
            CallBrowser13SearchComboList = 2227,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser14SearchComboList"]/*' />
            CallBrowser14SearchComboList = 2228,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser15SearchComboList"]/*' />
            CallBrowser15SearchComboList = 2229,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser16SearchComboList"]/*' />
            CallBrowser16SearchComboList = 2230,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SnippetProp"]/*' />
            SnippetProp = 2240,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SnippetRef"]/*' />
            SnippetRef = 2241,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SnippetRepl"]/*' />
            SnippetRepl = 2242,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.StartPage"]/*' />
            StartPage = 2245,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EditorLineFirstColumn"]/*' />
            EditorLineFirstColumn = 2250,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EditorLineFirstColumnExtend"]/*' />
            EditorLineFirstColumnExtend = 2251,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SEServerExplorer"]/*' />
            SEServerExplorer = 2260,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SEDataExplorer"]/*' />
            SEDataExplorer = 2261,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_UPDATEMGDRES"]/*' />
            ECMD_UPDATEMGDRES = 358,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_PROJTOOLORDER"]/*' />
            ECMD_PROJTOOLORDER = 367,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_PROJECTTOOLFILES"]/*' />
            ECMD_PROJECTTOOLFILES = 368,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_OTB_PGO_INSTRUMENT"]/*' />
            ECMD_OTB_PGO_INSTRUMENT = 369,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_OTB_PGO_OPT"]/*' />
            ECMD_OTB_PGO_OPT = 370,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_OTB_PGO_UPDATE"]/*' />
            ECMD_OTB_PGO_UPDATE = 371,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_OTB_PGO_RUNSCENARIO"]/*' />
            ECMD_OTB_PGO_RUNSCENARIO = 372,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_TAB"]/*' />
            ECMD_TAB = 4,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_ADDMASTERPAGE"]/*' />
            ECMD_ADDMASTERPAGE = 411,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_ADDCONTENTPAGE"]/*' />
            ECMD_ADDCONTENTPAGE = 413,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_ADDSTYLESHEET"]/*' />
            ECMD_ADDSTYLESHEET = 445,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_SETBROWSELOCATION"]/*' />
            ECMD_SETBROWSELOCATION = 446,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_REFRESHFOLDER"]/*' />
            ECMD_REFRESHFOLDER = 447,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_SETBROWSELOCATIONCTX"]/*' />
            ECMD_SETBROWSELOCATIONCTX = 448,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_VIEWMARKUP"]/*' />
            ECMD_VIEWMARKUP = 449,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_NEXTMETHOD"]/*' />
            ECMD_NEXTMETHOD = 450,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_PREVMETHOD"]/*' />
            ECMD_PREVMETHOD = 451,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_RENAMESYMBOL"]/*' />
            ECMD_RENAMESYMBOL = 452,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_SHOWREFERENCES"]/*' />
            ECMD_SHOWREFERENCES = 453,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CREATESNIPPET"]/*' />
            ECMD_CREATESNIPPET = 454,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CREATEREPLACEMENT"]/*' />
            ECMD_CREATEREPLACEMENT = 455,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_INSERTCOMMENT"]/*' />
            ECMD_INSERTCOMMENT = 456,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_VALIDATION_TARGET"]/*' />
            ECMD_VALIDATION_TARGET = 11281,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_VALIDATION_TARGET_GET_LIST"]/*' />
            ECMD_VALIDATION_TARGET_GET_LIST = 11282,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CSS_TARGET"]/*' />
            ECMD_CSS_TARGET = 11283,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CSS_TARGET_GET_LIST"]/*' />
            ECMD_CSS_TARGET_GET_LIST = 11284,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewDiagram"]/*' />
            NewDiagram = 0x3004,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewTable"]/*' />
            NewTable = 0x3006,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewDBItem"]/*' />
            NewDBItem = 0x300E,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewTrigger"]/*' />
            NewTrigger = 0x3010,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.Debug"]/*' />
            Debug = 0x3012,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewProcedure"]/*' />
            NewProcedure = 0x3013,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewQuery"]/*' />
            NewQuery = 0x3014,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RefreshLocal"]/*' />
            RefreshLocal = 0x3015,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DbAddDataConnection"]/*' />
            DbAddDataConnection = 0x3017,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DBDefDBRef"]/*' />
            DBDefDBRef = 0x3018,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RunCmd"]/*' />
            RunCmd = 0x3019,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RunOn"]/*' />
            RunOn = 0x301A,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewDBRef"]/*' />
            NewDBRef = 0x301B,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SetAsDef"]/*' />
            SetAsDef = 0x301C,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CreateCmdFile"]/*' />
            CreateCmdFile = 0x301D,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.Cancel"]/*' />
            Cancel = 0x301E,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewDatabase"]/*' />
            NewDatabase = 0x3020,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewUser"]/*' />
            NewUser = 0x3021,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewRole"]/*' />
            NewRole = 0x3022,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ChangeLogin"]/*' />
            ChangeLogin = 0x3023,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewView"]/*' />
            NewView = 0x3024,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ModifyConnection"]/*' />
            ModifyConnection = 0x3025,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.Disconnect"]/*' />
            Disconnect = 0x3026,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CopyScript"]/*' />
            CopyScript = 0x3027,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AddSCC"]/*' />
            AddSCC = 0x3028,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RemoveSCC"]/*' />
            RemoveSCC = 0x3029,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GetLatest"]/*' />
            GetLatest = 0x3030,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CheckOut"]/*' />
            CheckOut = 0x3031,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CheckIn"]/*' />
            CheckIn = 0x3032,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UndoCheckOut"]/*' />
            UndoCheckOut = 0x3033,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AddItemSCC"]/*' />
            AddItemSCC = 0x3034,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewPackageSpec"]/*' />
            NewPackageSpec = 0x3035,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewPackageBody"]/*' />
            NewPackageBody = 0x3036,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.InsertSQL"]/*' />
            InsertSQL = 0x3037,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RunSelection"]/*' />
            RunSelection = 0x3038,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UpdateScript"]/*' />
            UpdateScript = 0x3039,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewScript"]/*' />
            NewScript = 0x303C,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewFunction"]/*' />
            NewFunction = 0x303D,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewTableFunction"]/*' />
            NewTableFunction = 0x303E,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewInlineFunction"]/*' />
            NewInlineFunction = 0x303F,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AddDiagram"]/*' />
            AddDiagram = 0x3040,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AddTable"]/*' />
            AddTable = 0x3041,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AddSynonym"]/*' />
            AddSynonym = 0x3042,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AddView"]/*' />
            AddView = 0x3043,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AddProcedure"]/*' />
            AddProcedure = 0x3044,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AddFunction"]/*' />
            AddFunction = 0x3045,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AddTableFunction"]/*' />
            AddTableFunction = 0x3046,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AddInlineFunction"]/*' />
            AddInlineFunction = 0x3047,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AddPkgSpec"]/*' />
            AddPkgSpec = 0x3048,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AddPkgBody"]/*' />
            AddPkgBody = 0x3049,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AddTrigger"]/*' />
            AddTrigger = 0x304A,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ExportData"]/*' />
            ExportData = 0x304B,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DbnsVcsAdd"]/*' />
            DbnsVcsAdd = 0x304C,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DbnsVcsRemove"]/*' />
            DbnsVcsRemove = 0x304D,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DbnsVcsCheckout"]/*' />
            DbnsVcsCheckout = 0x304E,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DbnsVcsUndoCheckout"]/*' />
            DbnsVcsUndoCheckout = 0x304F,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DbnsVcsCheckin"]/*' />
            DbnsVcsCheckin = 0x3050,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SERetrieveData"]/*' />
            SERetrieveData = 0x3060,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SEEditTextObject"]/*' />
            SEEditTextObject = 0x3061,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DesignSQLBlock"]/*' />
            DesignSQLBlock = 0x3064,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RegisterSQLInstance"]/*' />
            RegisterSQLInstance = 0x3065,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UnregisterSQLInstance"]/*' />
            UnregisterSQLInstance = 0x3066,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CommandWindowSaveScript"]/*' />
            CommandWindowSaveScript = 0x3106,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CommandWindowRunScript"]/*' />
            CommandWindowRunScript = 0x3107,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CommandWindowCursorUp"]/*' />
            CommandWindowCursorUp = 0x3108,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CommandWindowCursorDown"]/*' />
            CommandWindowCursorDown = 0x3109,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CommandWindowCursorLeft"]/*' />
            CommandWindowCursorLeft = 0x310A,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CommandWindowCursorRight"]/*' />
            CommandWindowCursorRight = 0x310B,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CommandWindowHistoryUp"]/*' />
            CommandWindowHistoryUp = 0x310C,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CommandWindowHistoryDown"]/*' />
            CommandWindowHistoryDown = 0x310D,
        }

        // Editor factory constants

        /// <include file='doc\VSContants.uex' path='docs/doc[@for="VSConstants.CEF_CLONEFILE"]/*' />
        /// <devdoc>Mutually exclusive w/_OPENFILE</devdoc>
        public const uint CEF_CLONEFILE = 0x00000001;
        /// <include file='doc\VSContants.uex' path='docs/doc[@for="VSConstants.CEF_OPENFILE"]/*' />
        /// <devdoc>Mutually exclusive w/_CLONEFILE</devdoc>
        public const uint CEF_OPENFILE = 0x00000002;
        /// <include file='doc\VSContants.uex' path='docs/doc[@for="VSConstants.CEF_SILENT"]/*' />
        /// <devdoc>Editor factory should create editor silently.</devdoc>
        public const uint CEF_SILENT = 0x00000004;
        /// <include file='doc\VSContants.uex' path='docs/doc[@for="VSConstants.CEF_OPENASNEW"]/*' />
        /// <devdoc>Editor factory should perform necessary fixups.</devdoc>
        public const uint CEF_OPENASNEW = 0x00000008;


    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_VsUIHierarchyWindowCmds"]/*' />
        /// <summary>Command Group GUID for commands that only apply to the UIHierarchyWindow.</summary>
        public static readonly Guid GUID_VsUIHierarchyWindowCmds = new Guid("{60481700-078b-11d1-aaf8-00a0c9055a90}");

    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VsUIHierarchyWindowCmdIds"]/*' />
        /// <summary>
        /// The following commands are special commands that only apply to the UIHierarchyWindow.
        /// They are defined as part of the command group GUID: GUID_VsUIHierarchyWindowCmds.
        /// </summary>
        [Guid("60481700-078b-11d1-aaf8-00a0c9055a90")]
        public enum VsUIHierarchyWindowCmdIds
        {
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VsUIHierarchyWindowCmdIds.UIHWCMDID_RightClick"]/*' />
            /// <summary></summary>
            UIHWCMDID_RightClick        = 1,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VsUIHierarchyWindowCmdIds.UIHWCMDID_DoubleClick"]/*' />
            /// <summary></summary>
            UIHWCMDID_DoubleClick       = 2,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VsUIHierarchyWindowCmdIds.UIHWCMDID_EnterKey"]/*' />
            /// <summary></summary>
            UIHWCMDID_EnterKey          = 3,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VsUIHierarchyWindowCmdIds.UIHWCMDID_StartLabelEdit"]/*' />
            /// <summary></summary>
            UIHWCMDID_StartLabelEdit    = 4,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VsUIHierarchyWindowCmdIds.UIHWCMDID_CommitLabelEdit"]/*' />
            /// <summary></summary>
            UIHWCMDID_CommitLabelEdit   = 5,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VsUIHierarchyWindowCmdIds.UIHWCMDID_CancelLabelEdit"]/*' />
            /// <summary></summary>
            UIHWCMDID_CancelLabelEdit   = 6
        }

    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VSSELELEMID"]/*' />
        /// <summary>
        /// These element IDs are the only element IDs that can be used with the selection service.
        /// </summary>
        public enum VSSELELEMID
        {
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSSELELEMID.SEID_UndoManager"]/*' />
            /// <summary></summary>
            SEID_UndoManager        = 0,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSSELELEMID.SEID_WindowFrame"]/*' />
            /// <summary></summary>
            SEID_WindowFrame        = 1,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSSELELEMID.SEID_DocumentFrame"]/*' />
            /// <summary></summary>
            SEID_DocumentFrame      = 2,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSSELELEMID.SEID_StartupProject"]/*' />
            /// <summary></summary>
            SEID_StartupProject     = 3,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSSELELEMID.SEID_PropertyBrowserSID"]/*' />
            /// <summary></summary>
            SEID_PropertyBrowserSID = 4,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSSELELEMID.SEID_UserContext"]/*' />
            /// <summary></summary>
            SEID_UserContext        = 5,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSSELELEMID.SEID_ResultList"]/*' />
            /// <summary></summary>
            SEID_ResultList         = 6,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSSELELEMID.SEID_LastWindowFrame"]/*' />
            /// <summary></summary>
            SEID_LastWindowFrame    = 7
        }

    // VS Guids

        // Note: We don't define here the GUIDs for the standard tool windows because these
        // GUIDs are defined in System.ComponentModel.Design.StandardToolWindows

    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CLSID_HtmDocData"]/*' />
        /// <summary>The document's data is HTML.</summary>
        public static readonly Guid CLSID_HtmDocData = new Guid("{62C81794-A9EC-11D0-8198-00A0C91BBEE3}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CLSID_HtmedPackage"]/*' />
        /// <summary>GUID of the HTML package.</summary>
        public static readonly Guid CLSID_HtmedPackage = new Guid("{1B437D20-F8FE-11D2-A6AE-00104BCC7269}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CLSID_HtmlLanguageService"]/*' />
        /// <summary>GUID of the HTML language service.</summary>
        public static readonly Guid CLSID_HtmlLanguageService = new Guid("{58E975A0-F8FE-11D2-A6AE-00104BCC7269}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_HtmlEditorFactory"]/*' />
        /// <summary>GUID of the HTML editor factory.</summary>
        public static readonly Guid GUID_HtmlEditorFactory = new Guid("{C76D83F8-A489-11D0-8195-00A0C91BBEE3}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_TextEditorFactory"]/*' />
        /// <summary>GUID of the Text editor factory.</summary>
        public static readonly Guid GUID_TextEditorFactory = new Guid("{8B382828-6202-11d1-8870-0000F87579D2}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_HTMEDAllowExistingDocData"]/*' />
        /// <summary>GUID used to mark a TextBuffer in order to tell to the HTML editor factory to accept preexisting doc data.</summary>
        public static readonly Guid GUID_HTMEDAllowExistingDocData = new Guid("{5742D216-8071-4779-BF5F-A24D5F3142BA}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CLSID_VsEnvironmentPackage"]/*' />
        /// <summary>GUID for the environment package.</summary>
        public static readonly Guid CLSID_VsEnvironmentPackage = new Guid("{DA9FB551-C724-11d0-AE1F-00A0C90FFFC3}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_VsNewProjectPseudoFolder"]/*' />
        /// <summary>GUID for the "Visual Studio" pseudo folder in the registry.</summary>
        public static readonly Guid GUID_VsNewProjectPseudoFolder = new Guid("{DCF2A94A-45B0-11d1-ADBF-00C04FB6BE4C}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CLSID_MiscellaneousFilesProject"]/*' />
        /// <summary>GUID for the "Miscellaneous Files" project.</summary>
        public static readonly Guid CLSID_MiscellaneousFilesProject = new Guid("{A2FE74E1-B743-11d0-AE1A-00A0C90FFFC3}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CLSID_SolutionItemsProject"]/*' />
        /// <summary>GUID for Solution Items project.</summary>
        public static readonly Guid CLSID_SolutionItemsProject = new Guid("{D1DCDB85-C5E8-11d2-BFCA-00C04F990235}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.SID_SVsGeneralOutputWindowPane"]/*' />
        /// <summary>Pseudo service that returns a IID_IVsOutputWindowPane interface of the General output pane in the VS environment.
        /// Querying for this service will cause the General output pane to be created if it hasn't yet been created.
        /// </summary>
        public static readonly Guid SID_SVsGeneralOutputWindowPane = new Guid("{65482c72-defa-41b7-902c-11c091889c83}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.SID_SUIHostCommandDispatcher"]/*' />
        /// <summary>
        /// SUIHostCommandDispatcher service returns an object that implements IOleCommandTarget.
        /// This object handles command routing for the Environment. Use this service if you need to
        /// route a command based on the current selection/state of the Environment.
        /// </summary>
        public static readonly Guid SID_SUIHostCommandDispatcher = new Guid("{e69cd190-1276-11d1-9f64-00a0c911004f}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CLSID_VsUIHierarchyWindow"]/*' />
        /// <summary></summary>
        public static readonly Guid CLSID_VsUIHierarchyWindow = new Guid("{7D960B07-7AF8-11D0-8E5E-00A0C911005A}");

    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_DefaultEditor"]/*' />
        /// <summary></summary>
        public static readonly Guid GUID_DefaultEditor = new Guid("{6AC5EF80-12BF-11D1-8E9B-00A0C911005A}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_ExternalEditor"]/*' />
        /// <summary></summary>
        public static readonly Guid GUID_ExternalEditor = new Guid("{8137C9E8-35FE-4AF2-87B0-DE3C45F395FD}");

        //--------------------------------------------------------------------
        // GUIDs for some panes of the Output Window
        //--------------------------------------------------------------------
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_BuildOutputWindowPane"]/*' />
        /// <summary>GUID of the build pane inside the output window.</summary>
        public static readonly Guid GUID_BuildOutputWindowPane = new Guid("{1BD8A850-02D1-11d1-BEE7-00A0C913D1F8}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_OutWindowDebugPane"]/*' />
        /// <summary>GUID of the debug pane inside the output window.</summary>
        public static readonly Guid GUID_OutWindowDebugPane = new Guid("{FC076020-078A-11D1-A7DF-00A0C9110051}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_OutWindowGeneralPane"]/*' />
        /// <summary>GUID of the general output pane inside the output window.</summary>
        public static readonly Guid GUID_OutWindowGeneralPane = new Guid("{3c24d581-5591-4884-a571-9fe89915cd64}");

        // Guids for GetOutputPane.
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.BuildOrder"]/*' />
        public static readonly Guid BuildOrder = new Guid("2032b126-7c8d-48ad-8026-0e0348004fc0");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.BuildOutput"]/*' />
        public static readonly Guid BuildOutput = new Guid("1BD8A850-02D1-11d1-BEE7-00A0C913D1F8");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.DebugOutput"]/*' />
        public static readonly Guid DebugOutput = new Guid("FC076020-078A-11D1-A7DF-00A0C9110051");

        //--------------------------------------------------------------------
        // standard item types, to be returned from VSHPROPID_TypeGuid
        //--------------------------------------------------------------------

    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_ItemType_PhysicalFile"]/*' />
        /// <summary>Physical file on disk or web (IVsProject::GetMkDocument returns a file path).</summary>
        public static readonly Guid GUID_ItemType_PhysicalFile = new Guid("{6bb5f8ee-4483-11d3-8bcf-00c04f8ec28c}");

    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_ItemType_PhysicalFolder"]/*' />
        /// <summary>Physical folder on disk or web (IVsProject::GetMkDocument returns a directory path).</summary>

        public static readonly Guid GUID_ItemType_PhysicalFolder = new Guid("{6bb5f8ef-4483-11d3-8bcf-00c04f8ec28c}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_ItemType_VirtualFolder"]/*' />
        /// <summary>Non-physical folder (folder is logical and not a physical file system directory).</summary>

        public static readonly Guid GUID_ItemType_VirtualFolder = new Guid("{6bb5f8f0-4483-11d3-8bcf-00c04f8ec28c}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_ItemType_SubProject"]/*' />
        /// <summary>A nested hierarchy project.</summary>
        public static readonly Guid GUID_ItemType_SubProject = new Guid("{EA6618E8-6E24-4528-94BE-6889FE16485C}");

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_BrowseFilePage"]/*' />
        /// <summary>The BrowseFile page.</summary>
        public static readonly Guid GUID_BrowseFilePage = new Guid("2483F435-673D-4fa3-8ADD-B51442F65349");

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.guidCOMPLUSLibrary"]/*' />
        public static readonly Guid guidCOMPLUSLibrary = new Guid(0x1ec72fd7, 0xc820, 0x4273, 0x9a, 0x21, 0x77, 0x7a, 0x5c, 0x52, 0x2e, 0x03);

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CLSID_ComPlusOnlyDebugEngine"]/*' />
        public static readonly Guid CLSID_ComPlusOnlyDebugEngine = new Guid("449EC4CC-30D2-4032-9256-EE18EB41B62B");

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_VS_DEPTYPE_BUILD_PROJECT"]/*' />
        public static readonly Guid GUID_VS_DEPTYPE_BUILD_PROJECT = new Guid("707d11b6-91ca-11d0-8a3e-00a0c91e2acd");

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_ProjectDesignerEditor"]/*' />
        /// <summary>The propejct designer guid.</summary>
        public static readonly Guid GUID_ProjectDesignerEditor = new Guid("04b8ab82-a572-4fef-95ce-5222444b6b64");

        // Build options from the idl file.
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VS_BUILDABLEPROJECTCFGOPTS_REBUILD"]/*' />
        public const uint VS_BUILDABLEPROJECTCFGOPTS_REBUILD = 1;
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VS_BUILDABLEPROJECTCFGOPTS_BUILD_SELECTION_ONLY"]/*' />
        public const uint VS_BUILDABLEPROJECTCFGOPTS_BUILD_SELECTION_ONLY = 2;
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VS_BUILDABLEPROJECTCFGOPTS_BUILD_ACTIVE_DOCUMENT_ONLY"]/*' />
        public const uint VS_BUILDABLEPROJECTCFGOPTS_BUILD_ACTIVE_DOCUMENT_ONLY = 4;
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VS_BUILDABLEPROJECTCFGOPTS_PRIVATE"]/*' />
        public const uint VS_BUILDABLEPROJECTCFGOPTS_PRIVATE = 0xFFFF0000;    // flags private to a particular implementation

        //--------------------------------------------------------------------
        // GUIDs used in calling IVsMonitorSelection::GetCmdUIContextCookie()
        //--------------------------------------------------------------------
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.UICONTEXT_SolutionBuilding"]/*' />
        /// <summary></summary>
        public static readonly Guid UICONTEXT_SolutionBuilding            = new Guid("{adfc4e60-0397-11d1-9f4e-00a0c911004f}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.UICONTEXT_Debugging"]/*' />
        /// <summary></summary>
        public static readonly Guid UICONTEXT_Debugging                   = new Guid("{adfc4e61-0397-11d1-9f4e-00a0c911004f}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.UICONTEXT_Dragging"]/*' />
        /// <summary></summary>
        public static readonly Guid UICONTEXT_Dragging                    = new Guid("{b706f393-2e5b-49e7-9e2e-b1825f639b63}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.UICONTEXT_FullScreenMode"]/*' />
        /// <summary></summary>
        public static readonly Guid UICONTEXT_FullScreenMode              = new Guid("{adfc4e62-0397-11d1-9f4e-00a0c911004f}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.UICONTEXT_DesignMode"]/*' />
        /// <summary></summary>
        public static readonly Guid UICONTEXT_DesignMode                  = new Guid("{adfc4e63-0397-11d1-9f4e-00a0c911004f}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.UICONTEXT_NoSolution"]/*' />
        /// <summary></summary>
        public static readonly Guid UICONTEXT_NoSolution                  = new Guid("{adfc4e64-0397-11d1-9f4e-00a0c911004f}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.UICONTEXT_SolutionExists"]/*' />
        /// <summary></summary>
        public static readonly Guid UICONTEXT_SolutionExists              = new Guid("{f1536ef8-92ec-443c-9ed7-fdadf150da82}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.UICONTEXT_EmptySolution"]/*' />
        /// <summary></summary>
        public static readonly Guid UICONTEXT_EmptySolution               = new Guid("{adfc4e65-0397-11d1-9f4e-00a0c911004f}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.UICONTEXT_SolutionHasSingleProject"]/*' />
        /// <summary></summary>
        public static readonly Guid UICONTEXT_SolutionHasSingleProject    = new Guid("{adfc4e66-0397-11d1-9f4e-00a0c911004f}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.UICONTEXT_SolutionHasMultipleProjects"]/*' />
        /// <summary></summary>
        public static readonly Guid UICONTEXT_SolutionHasMultipleProjects = new Guid("{93694fa0-0397-11d1-9f4e-00a0c911004f}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.UICONTEXT_CodeWindow"]/*' />
        /// <summary></summary>
        public static readonly Guid UICONTEXT_CodeWindow                  = new Guid("{8fe2df1d-e0da-4ebe-9d5c-415d40e487b5}");

        //--------------------------------------------------------------------
        // GUIDS for built in task list views
        //--------------------------------------------------------------------
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_VsTaskListViewAll"]/*' />
        /// <summary></summary>
        public static readonly Guid GUID_VsTaskListViewAll              = new Guid("{1880202e-fc20-11d2-8bb1-00c04f8ec28c}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_VsTaskListViewUserTasks"]/*' />
        /// <summary></summary>
        public static readonly Guid GUID_VsTaskListViewUserTasks        = new Guid("{1880202f-fc20-11d2-8bb1-00c04f8ec28c}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_VsTaskListViewShortcutTasks"]/*' />
        /// <summary></summary>
        public static readonly Guid GUID_VsTaskListViewShortcutTasks    = new Guid("{18802030-fc20-11d2-8bb1-00c04f8ec28c}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_VsTaskListViewHTMLTasks"]/*' />
        /// <summary></summary>
        public static readonly Guid GUID_VsTaskListViewHTMLTasks        = new Guid("{36ac1c0d-fe86-11d2-8bb1-00c04f8ec28c}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_VsTaskListViewCompilerTasks"]/*' />
        /// <summary></summary>
        public static readonly Guid GUID_VsTaskListViewCompilerTasks    = new Guid("{18802033-fc20-11d2-8bb1-00c04f8ec28c}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_VsTaskListViewCommentTasks"]/*' />
        /// <summary></summary>
        public static readonly Guid GUID_VsTaskListViewCommentTasks     = new Guid("{18802034-fc20-11d2-8bb1-00c04f8ec28c}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_VsTaskListViewCurrentFileTasks"]/*' />
        /// <summary></summary>
        public static readonly Guid GUID_VsTaskListViewCurrentFileTasks = new Guid("{18802035-fc20-11d2-8bb1-00c04f8ec28c}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_VsTaskListViewCheckedTasks"]/*' />
        /// <summary></summary>
        public static readonly Guid GUID_VsTaskListViewCheckedTasks     = new Guid("{18802036-fc20-11d2-8bb1-00c04f8ec28c}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_VsTaskListViewUncheckedTasks"]/*' />
        /// <summary></summary>
        public static readonly Guid GUID_VsTaskListViewUncheckedTasks   = new Guid("{18802037-fc20-11d2-8bb1-00c04f8ec28c}");

    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CLSID_VsTaskList"]/*' />
        /// <summary></summary>
        public static readonly Guid CLSID_VsTaskList            = new Guid("{BC5955D5-aa0d-11d0-a8c5-00a0c921a4d2}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CLSID_VsTaskListPackage"]/*' />
        /// <summary></summary>
        public static readonly Guid CLSID_VsTaskListPackage     = new Guid("{4A9B7E50-aa16-11d0-a8c5-00a0c921a4d2}");


    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.SID_SVsToolboxActiveXDataProvider"]/*' />
        /// <summary></summary>
        public static readonly Guid SID_SVsToolboxActiveXDataProvider = new Guid("{35222106-bb44-11d0-8c46-00c04fc2aae2}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CLSID_VsDocOutlinePackage"]/*' />
        /// <summary></summary>
        public static readonly Guid CLSID_VsDocOutlinePackage         = new Guid("{21af45b0-ffa5-11d0-b63f-00a0c922e851}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CLSID_VsCfgProviderEventsHelper"]/*' />
        /// <summary></summary>
        public static readonly Guid CLSID_VsCfgProviderEventsHelper   = new Guid("{99913f1f-1ee3-11d1-8a6e-00c04f682e21}");


        //--------------------------------------------------------------------
        // Component Selector page GUIDs
        //--------------------------------------------------------------------
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_COMPlusPage"]/*' />
        /// <summary></summary>
        public static readonly Guid GUID_COMPlusPage    = new Guid("{9A341D95-5A64-11d3-BFF9-00C04F990235}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_COMClassicPage"]/*' />
        /// <summary></summary>
        public static readonly Guid GUID_COMClassicPage = new Guid("{9A341D96-5A64-11d3-BFF9-00C04F990235}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_SolutionPage"]/*' />
        /// <summary></summary>
        public static readonly Guid GUID_SolutionPage   = new Guid("{9A341D97-5A64-11d3-BFF9-00C04F990235}");

        //--------------------------------------------------------------------
        // Logical View GUIDs
        //--------------------------------------------------------------------
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.LOGVIEWID_Primary"]/*' />
        /// <summary>Kind of view for document or data: Primary (default) view.</summary>
        public static readonly Guid LOGVIEWID_Primary         = Guid.Empty;
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.LOGVIEWID_Debugging"]/*' />
        /// <summary>Kind of view for document or data: Debugger view.</summary>
        public static readonly Guid LOGVIEWID_Debugging       = new Guid("{7651A700-06E5-11D1-8EBD-00A0C90F26EA}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.LOGVIEWID_Code "]/*' />
        /// <summary>Kind of view for document or data: Code editor view.</summary>
        public static readonly Guid LOGVIEWID_Code            = new Guid("{7651A701-06E5-11D1-8EBD-00A0C90F26EA}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.LOGVIEWID_Designer"]/*' />
        /// <summary>Kind of view for document or data: Designer view.</summary>
        public static readonly Guid LOGVIEWID_Designer        = new Guid("{7651A702-06E5-11D1-8EBD-00A0C90F26EA}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.LOGVIEWID_TextView"]/*' />
        /// <summary>Kind of view for document or data: Text editor view.</summary>
        public static readonly Guid LOGVIEWID_TextView        = new Guid("{7651A703-06E5-11D1-8EBD-00A0C90F26EA}");
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.LOGVIEWID_UserChooseView"]/*' />
        /// <summary>Kind of view for document or data: A user defined view.</summary>
        public static readonly Guid LOGVIEWID_UserChooseView  = new Guid("{7651A704-06E5-11D1-8EBD-00A0C90F26EA}");

    // VS Constants

    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VSITEMID_NIL"]/*' />
        /// <summary>Special items inside a VsHierarchy: no node.</summary>
        public const uint VSITEMID_NIL               = unchecked((uint)-1);
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VSITEMID_ROOT"]/*' />
        /// <summary>Special items inside a VsHierarchy: the hierarchy itself.</summary>
        public const uint VSITEMID_ROOT              = unchecked((uint)-2);
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VSITEMID_SELECTION"]/*' />
        /// <summary>Special items inside a VsHierarchy: all the currently selected items.</summary>
        public const uint VSITEMID_SELECTION         = unchecked((uint)-3);
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VSCOOKIE_NIL"]/*' />
        /// <summary>Special value for a cookie (e.g. returned from IVsRunningDocumentTable.FindAndLockDocument): no cookie.</summary>
        public const uint VSCOOKIE_NIL               = 0;

        // for IVsSelectionEvents flags
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.UndoManager"]/*' />
        /// <summary>IVsSelectionEvents.OnElementValueChanged flag: The undo manager.</summary>
        public const uint UndoManager = 0x0;
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.WindowFrame"]/*' />
        /// <summary>IVsSelectionEvents.OnElementValueChanged flag: A window frame.</summary>
        public const uint WindowFrame = 0x1;
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.DocumentFrame"]/*' />
        /// <summary>IVsSelectionEvents.OnElementValueChanged flag: A document frame.</summary>
        public const uint DocumentFrame = 0x2;
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.StartupProject"]/*' />
        /// <summary>IVsSelectionEvents.OnElementValueChanged flag: The startup project.</summary>
        public const uint StartupProject = 0x3;
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.PropertyBrowserSID"]/*' />
        /// <summary>IVsSelectionEvents.OnElementValueChanged flag: The property borowser.</summary>
        public const uint PropertyBrowserSID = 0x4;
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.UserContext"]/*' />
        /// <summary>IVsSelectionEvents.OnElementValueChanged flag: A user context.</summary>
        public const uint UserContext = 0x5;

    // VS HRESULTS

    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VS_E_PROJECTALREADYEXISTS"]/*' />
        /// <summary>VS specific error HRESULT for "Project already exists".</summary>
        public const int VS_E_PROJECTALREADYEXISTS  = unchecked((int)0x80041FE0);
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VS_E_PACKAGENOTLOADED"]/*' />
        /// <summary>VS specific error HRESULT for "Package not loaded".</summary>
        public const int VS_E_PACKAGENOTLOADED = unchecked((int)0x80041FE1);
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VS_E_PROJECTNOTLOADED"]/*' />
        /// <summary>VS specific error HRESULT for "Project not loaded".</summary>
        public const int VS_E_PROJECTNOTLOADED = unchecked((int)0x80041FE2);
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VS_E_SOLUTIONNOTOPEN"]/*' />
        /// <summary>VS specific error HRESULT for "Solution not open".</summary>
        public const int VS_E_SOLUTIONNOTOPEN =  unchecked((int)0x80041FE3);
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VS_E_SOLUTIONALREADYOPEN"]/*' />
        /// <summary>VS specific error HRESULT for "Solution already open".</summary>
        public const int VS_E_SOLUTIONALREADYOPEN = unchecked((int)0x80041FE4);
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VS_E_PROJECTMIGRATIONFAILED"]/*' />
        /// <summary>VS specific error HRESULT for "Project configuration failed".</summary>
        public const int VS_E_PROJECTMIGRATIONFAILED  = unchecked((int)0x80041FE5);
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VS_E_INCOMPATIBLEDOCDATA"]/*' />
        /// <summary>VS specific error HRESULT for "Incompatible document data".</summary>
        public const int VS_E_INCOMPATIBLEDOCDATA = unchecked((int)0x80041FEA);
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VS_E_UNSUPPORTEDFORMAT"]/*' />
        /// <summary>VS specific error HRESULT for "Unsupported format".</summary>
        public const int VS_E_UNSUPPORTEDFORMAT = unchecked((int)0x80041FEB);
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VS_E_WIZARDBACKBUTTONPRESS"]/*' />
        /// <summary>VS specific error HRESULT for "Wizard back button pressed".</summary>
        public const int VS_E_WIZARDBACKBUTTONPRESS = unchecked((int)0x80041fff);
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VS_S_PROJECTFORWARDED"]/*' />
        /// <summary>VS specific success HRESULT for "Project forwarded".</summary>
    public const int VS_S_PROJECTFORWARDED = unchecked((int)0x41ff0);
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VS_S_TBXMARKER"]/*' />
        /// <summary>VS specific success HRESULT for "Toolbox marker".</summary>
        public const int VS_S_TBXMARKER = unchecked((int)0x41ff1);

    // Selection Containter Constants
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.ALL"]/*' />
        public const uint ALL = 0x1;
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.SELECTED"]/*' />
        public const uint SELECTED = 0x2;

        // OLE HRESULTS - may be returned by OLE or related VS methods
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSConstants.OleErrors"]/*' />
        public const int 
        OLE_E_OLEVERB = unchecked((int)0x80040000),
        OLE_E_ADVF = unchecked((int)0x80040001),
        OLE_E_ENUM_NOMORE = unchecked((int)0x80040002),
        OLE_E_ADVISENOTSUPPORTED = unchecked((int)0x80040003),
        OLE_E_NOCONNECTION = unchecked((int)0x80040004),
        OLE_E_NOTRUNNING = unchecked((int)0x80040005),
        OLE_E_NOCACHE = unchecked((int)0x80040006),
        OLE_E_BLANK = unchecked((int)0x80040007),
        OLE_E_CLASSDIFF = unchecked((int)0x80040008),
        OLE_E_CANT_GETMONIKER = unchecked((int)0x80040009),
        OLE_E_CANT_BINDTOSOURCE = unchecked((int)0x8004000A),
        OLE_E_STATIC = unchecked((int)0x8004000B),
        OLE_E_PROMPTSAVECANCELLED = unchecked((int)0x8004000C),
        OLE_E_INVALIDRECT = unchecked((int)0x8004000D),
        OLE_E_WRONGCOMPOBJ = unchecked((int)0x8004000E),
        OLE_E_INVALIDHWND = unchecked((int)0x8004000F),
        OLE_E_NOT_INPLACEACTIVE = unchecked((int)0x80040010),
        OLE_E_CANTCONVERT = unchecked((int)0x80040011),
        OLE_E_NOSTORAGE = unchecked((int)0x80040012);

        // OLE DISP HRESULTS - may be returned by OLE DISP or related VS methods 

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSConstants.OleDispatchErrors"]/*' />
        public const int 
        DISP_E_UNKNOWNINTERFACE = unchecked((int)0x80020001),
        DISP_E_MEMBERNOTFOUND = unchecked((int)0x80020003),
        DISP_E_PARAMNOTFOUND = unchecked((int)0x80020004),
        DISP_E_TYPEMISMATCH = unchecked((int)0x80020005),
        DISP_E_UNKNOWNNAME = unchecked((int)0x80020006),
        DISP_E_NONAMEDARGS = unchecked((int)0x80020007),
        DISP_E_BADVARTYPE = unchecked((int)0x80020008),
        DISP_E_EXCEPTION = unchecked((int)0x80020009),
        DISP_E_OVERFLOW = unchecked((int)0x8002000A),
        DISP_E_BADINDEX = unchecked((int)0x8002000B),
        DISP_E_UNKNOWNLCID = unchecked((int)0x8002000C),
        DISP_E_ARRAYISLOCKED = unchecked((int)0x8002000D),
        DISP_E_BADPARAMCOUNT = unchecked((int)0x8002000E),
        DISP_E_PARAMNOTOPTIONAL = unchecked((int)0x8002000F),
        DISP_E_BADCALLEE = unchecked((int)0x80020010),
        DISP_E_NOTACOLLECTION = unchecked((int)0x80020011),
        DISP_E_DIVBYZERO = unchecked((int)0x80020012),
        DISP_E_BUFFERTOOSMALL = unchecked((int)0x80020013);


        //-----------------------------------------------------------------------------
        //  VS_E_BUSY is returned by interfaces to asynchronous behavior when the
        //  object in question in already busy.  For example, starting a build while
        //  a buildable project configuration object is in the process of cleaning,
        //  building or checking for out of date-ness.
        //-----------------------------------------------------------------------------
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VS_E_BUSY"]/*' />
        /// <summary>
        /// VS specific error HRESULT returned by interfaces to asynchronous behavior when the
        /// object in question in already busy.
        /// </summary>
        public const int VS_E_BUSY = unchecked((int)0x80040200);
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VS_E_SPECIFYING_OUTPUT_UNSUPPORTED"]/*' />
        /// <summary>
        /// Is returned by build interfaces that have parameters for specifying an array of IVsOutput's
        /// but the implementation can only apply the method to all outputs.
        /// </summary>
        public const int VS_E_SPECIFYING_OUTPUT_UNSUPPORTED = unchecked((int)0x80040201);

    // General HRESULTS

    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.S_FALSE"]/*' />
        /// <summary>HRESULT for FALSE (not an error).</summary>
        public const int S_FALSE =   0x00000001;
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.S_OK"]/*' />
        /// <summary>HRESULT for generic success.</summary>
        public const int S_OK =      0x00000000;
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.UNDO_E_CLIENTABORT"]/*' />
        /// <summary>Error HRESULT for a client abort.</summary>
        public const int UNDO_E_CLIENTABORT = unchecked((int)0x80044001);
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.E_OUTOFMEMORY"]/*' />
        /// <summary>Error HRESULT for out of memory.</summary>
        public const int E_OUTOFMEMORY = unchecked((int)0x8007000E);
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.E_INVALIDARG"]/*' />
        /// <summary>Error HRESULT for an invalid argument.</summary>
        public const int E_INVALIDARG = unchecked((int)0x80070057);
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.E_FAIL"]/*' />
        /// <summary>Error HRESULT for a generic failure.</summary>
        public const int E_FAIL = unchecked((int)0x80004005);
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.E_NOINTERFACE"]/*' />
        /// <summary>Error HRESULT for the request of a not implemented interface.</summary>
        public const int E_NOINTERFACE = unchecked((int)0x80004002);
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.E_NOTIMPL"]/*' />
        /// <summary>Error HRESULT for the call to a not implemented method.</summary>
        public const int E_NOTIMPL = unchecked((int)0x80004001);
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.E_UNEXPECTED"]/*' />
        /// <summary>Error HRESULT for an unexpected condition.</summary>
        public const int E_UNEXPECTED = unchecked((int)0x8000FFFF);
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.E_POINTER"]/*' />
        /// <summary>Error HRESULT for a null or invalid pointer.</summary>
        public const int E_POINTER = unchecked((int)0x80004003);
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.E_HANDLE"]/*' />
        /// <summary>Error HRESULT for an invalid HANDLE.</summary>
    public const int E_HANDLE = unchecked((int)0x80070006);
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.E_ABORT"]/*' />
        /// <summary>Error HRESULT for an abort.</summary>
    public const int E_ABORT = unchecked((int)0x80004004);
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.E_ACCESSDENIED"]/*' />
        /// <summary>Error HRESULT for an access denied.</summary>
    public const int E_ACCESSDENIED = unchecked((int)0x80070005);
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.E_PENDING"]/*' />
        /// <summary>Error HRESULT for a pending condition.</summary>
    public const int E_PENDING = unchecked((int)0x8000000A);    

    // Window Messages
        internal const int WM_USER = 0x0400;

        // VS specific messages
        // These definitions are for broadcasting a notification message via
        //   IVsBroadcastMessageEvents::OnBroadcastMessage to indicate that the cmdbar
        //   metrics have changed.
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VSM_TOOLBARMETRICSCHANGE"]/*' />
        /// <summary>Toolbar metrics changed.</summary>
        public const int VSM_TOOLBARMETRICSCHANGE   = WM_USER + 0x0C52;
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VSM_ENTERMODAL"]/*' />
        /// <summary></summary>
        public const int VSM_ENTERMODAL             = WM_USER + 0x0C53;
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VSM_EXITMODAL"]/*' />
        /// <summary></summary>
        public const int VSM_EXITMODAL              = WM_USER + 0x0C54;

        // messages sent from Component Selector dialog to page dialogs.
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CPDN_SELCHANGED"]/*' />
        /// <summary>Inform of selection change on page.</summary>
        public const int CPDN_SELCHANGED            = WM_USER + 1280;
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CPDN_SELDBLCLICK"]/*' />
        /// <summary>Inform of doubld-click on selected item on page.</summary>
        public const int CPDN_SELDBLCLICK           = WM_USER + 1281;
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CPPM_INITIALIZELIST"]/*' />
        /// <summary>Initialize list of available components.</summary>
        public const int CPPM_INITIALIZELIST        = WM_USER + 1285;
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CPPM_QUERYCANSELECT"]/*' />
        /// <summary>Determine whether Select button should be enabled.</summary>
        public const int CPPM_QUERYCANSELECT        = WM_USER + 1286;
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CPPM_GETSELECTION"]/*' />
        /// <summary>Retrieve information about selection.</summary>
        public const int CPPM_GETSELECTION          = WM_USER + 1287;
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CPPM_INITIALIZETAB"]/*' />
        /// <summary>Initialize tab with VARIANT in VSCOMPONENTSELECTORTABINIT.</summary>
        public const int CPPM_INITIALIZETAB         = WM_USER + 1288;
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CPPM_SETMULTISELECT"]/*' />
        /// <summary>Set multiple-selection mode for picker.</summary>
        public const int CPPM_SETMULTISELECT        = WM_USER + 1289;
    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CPPM_CLEARSELECTION"]/*' />
        /// <summary>Reset and clear selection in list of available components.</summary>
        public const int CPPM_CLEARSELECTION        = WM_USER + 1290;

    }

    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Win32Methods"]/*' />
    [CLSCompliant(false)]
    public class Win32Methods {
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Win32Methods.SetParent"]/*' />
        /// <summary>
        /// Changes the parent window of the specified child window.
        /// </summary>
        /// <param name="hWnd">Handle to the child window.</param>
        /// <param name="hWndParent">Handle to the new parent window. If this parameter is NULL, the desktop window becomes the new parent window.</param>
        /// <returns>A handle to the previous parent window indicates success. NULL indicates failure.</returns>
        [DllImport("User32", ExactSpelling = true, CharSet = CharSet.Auto)]
        public static extern IntPtr SetParent(IntPtr hWnd, IntPtr hWndParent);

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Win32Methods.IsDialogMessageA"]/*' />
        [DllImport("user32.dll", EntryPoint = "IsDialogMessageA", SetLastError = true, CharSet = CharSet.Ansi, ExactSpelling = true, CallingConvention = CallingConvention.StdCall)]
        public static extern bool IsDialogMessageA(IntPtr hDlg, ref MSG msg);


    }

    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="IEventHandler"]/*' />
    [ComImport(),Guid("9BDA66AE-CA28-4e22-AA27-8A7218A0E3FA"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown), CLSCompliant(false)]
    public interface IEventHandler {

        // converts the underlying codefunction into an event handler for the given event
        // if the given event is NULL, then the function will handle no events
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="IEventHandler.AddHandler"]/*' />
        [PreserveSig]
        int AddHandler(string bstrEventName); 

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="IEventHandler.RemoveHandler"]/*' />
        [PreserveSig]
        int RemoveHandler(string bstrEventName);

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="IEventHandler.GetHandledEvents"]/*' />
        IVsEnumBSTR GetHandledEvents();

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="IEventHandler.HandlesEvent"]/*' />
        bool HandlesEvent(string bstrEventName);
    }

    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="ErrorHandler"]/*' />
    public sealed class ErrorHandler {

        private ErrorHandler() {}

    // Helper Methods

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="ErrorHandler.Succeeded"]/*' />
        /// <summary>
        /// Checks if a HRESULT is a success return code.
        /// </summary>
        /// <param name="hr">The HRESULT to test.</param>
        /// <returns>true if hr represents a success, false otherwise.</returns>
        public static bool Succeeded(int hr) {
            return(hr >= 0);
        }

    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="ErrorHandler.Failed"]/*' />
        /// <summary>
        /// Checks if a HRESULT is an error return code.
        /// </summary>
        /// <param name="hr">The HRESULT to test.</param>
        /// <returns>true if hr represents an error, false otherwise.</returns>
        public static bool Failed(int hr) {
            return(hr < 0);
        }

    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="ErrorHandler.ThrowOnFailure"]/*' />
        /// <summary>
        /// Checks if the parameter is a success or failure HRESULT and throws an exception in case
        /// of failure.
        /// </summary>
        /// <param name="hr">The HRESULT to test.</param>
        public static int ThrowOnFailure(int hr) {
            return ThrowOnFailure(hr, null);
        }

    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="ErrorHandler.ThrowOnFailure"]/*' />
        /// <summary>
        /// Checks if the parameter is a success or failure HRESULT and throws an exception if it is a
        /// failure that is not included in the array of well-known failures.
        /// </summary>
        /// <param name="hr">The HRESULT to test.</param>
        /// <param name="expectedHRFailure">Array of well-known and expected failures.</param>
        public static int ThrowOnFailure(int hr, params int[] expectedHRFailure) {
            if ( Failed(hr) )
            {
                if ((null == expectedHRFailure) || (Array.IndexOf(expectedHRFailure, hr) < 0))
                {
                    Marshal.ThrowExceptionForHR(hr);
                }
            }
            return hr;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\DefaultRegistryRootAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="DefaultRegistryRootAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;

    /// <include file='doc\DefaultRegistryRootAttribute.uex' path='docs/doc[@for="DefaultRegistryRootAttribute"]' />
    /// <devdoc>
    ///     This attribute defines the default registry root this package was designed to work with.  
    ///     This attribute exists on the Package base class and contains the root for the version of 
    ///     Visual Studio the package was copiled for.  The various path and registry methods on 
    ///     Package make use of this attribute, as does default registration code that setup will 
    ///     use to register packages. 
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=false, Inherited=true)]
    public sealed class DefaultRegistryRootAttribute : Attribute {

        private string _root;
    
        /// <include file='doc\DefaultRegistryRootAttribute.uex' path='docs/doc[@for="DefaultRegistryRootAttribute.DefaultRegistryRootAttribute"]' />
        /// <devdoc>
        ///     Creates a new DefaultRegistryRootAttribute.
        /// </devdoc>
        public DefaultRegistryRootAttribute (string root) {
            if (root == null) {
                throw new ArgumentNullException("root");
            }
            _root = root;
        }
        
        /// <include file='doc\DefaultRegistryRootAttribute.uex' path='docs/doc[@for="DefaultRegistryRootAttribute.Root"]' />
        /// <devdoc>
        ///     Returns the default registry root.
        /// </devdoc>
        public string Root {
            get {
                return _root;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\DesignPropertyDescriptor.cs ===
//--------------------------------------------------------------------------
//  <copyright file="DesignPropertyDescriptor.cs" company="Microsoft">
//      Copyright (c) Microsoft Corporation.  All rights reserved.
//  </copyright>
//  <summary>
//  </summary>
//--------------------------------------------------------------------------
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.Designer.Interfaces;
using Microsoft.VisualStudio.Shell;
using System;
using System.Collections;
using System.ComponentModel;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using System.Xml;
using System.Diagnostics;

namespace Microsoft.VisualStudio.Shell
{
	/// <summary>
	/// The purpose of DesignPropertyDescriptor is to allow us to customize the
	/// display name of the property in the property grid.  None of the CLR
	/// implementations of PropertyDescriptor allow you to change the DisplayName.
	/// </summary>
	public class DesignPropertyDescriptor : PropertyDescriptor
	{
		private string displayName; // Custom display name
		private PropertyDescriptor property;	// Base property descriptor
		private Hashtable editors = new Hashtable(); // Type -> editor instance
		private TypeConverter converter;


		/// <summary>
		/// Delegates to base.
		/// </summary>
		public override string DisplayName
		{
			get
			{
				return this.displayName;
			}
		}

		/// <summary>
		/// Delegates to base.
		/// </summary>
		public override Type ComponentType
		{
			get
			{
				return this.property.ComponentType;
			}
		}

		/// <summary>
		/// Delegates to base.
		/// </summary>
		public override bool IsReadOnly
		{
			get
			{
				return this.property.IsReadOnly;
			}
		}

		/// <summary>
		/// Delegates to base.
		/// </summary>
		public override Type PropertyType
		{
			get
			{
				return this.property.PropertyType;
			}
		}


		/// <summary>
		/// Delegates to base.
		/// </summary>
		public override object GetEditor(Type editorBaseType)
		{
			object editor = this.editors[editorBaseType];
			if (editor == null)
			{
				for (int i = 0; i < this.Attributes.Count; i++)
				{
					EditorAttribute attr = Attributes[i] as EditorAttribute;
					if (attr == null)
					{
						continue;
					}
					Type editorType = Type.GetType(attr.EditorBaseTypeName);
					if (editorBaseType == editorType)
					{
						Type type = GetTypeFromNameProperty(attr.EditorTypeName);
						if (type != null)
						{
							editor = CreateInstance(type);
							this.editors[type] = editor; // cache it
							break;
						}
					}
				}
			}
			return editor;
		}


		/// <summary>
		/// Return type converter for property
		/// </summary>
		public override TypeConverter Converter
		{
			get
			{
				if (converter == null)
				{
					PropertyPageTypeConverterAttribute attr = (PropertyPageTypeConverterAttribute)Attributes[typeof(PropertyPageTypeConverterAttribute)];
					if (attr != null && attr.ConverterType != null)
					{
						converter = (TypeConverter)CreateInstance(attr.ConverterType);
					}

					if (converter == null)
					{
						converter = TypeDescriptor.GetConverter(this.PropertyType);
					}
				}
				return converter;
			}
		}



		/// <summary>
		/// Convert name to a Type object.
		/// </summary>
		public virtual Type GetTypeFromNameProperty(string typeName)
		{
			return Type.GetType(typeName);
		}


		/// <summary>
		/// Delegates to base.
		/// </summary>
		public override bool CanResetValue(object component)
		{
			bool result = this.property.CanResetValue(component);
			return result;
		}

		/// <summary>
		/// Delegates to base.
		/// </summary>
		public override object GetValue(object component)
		{
			object value = this.property.GetValue(component);
			return value;
		}

		/// <summary>
		/// Delegates to base.
		/// </summary>
		public override void ResetValue(object component)
		{
			this.property.ResetValue(component);
		}

		/// <summary>
		/// Delegates to base.
		/// </summary>
		public override void SetValue(object component, object value)
		{
			this.property.SetValue(component, value);
		}

		/// <summary>
		/// Delegates to base.
		/// </summary>
		public override bool ShouldSerializeValue(object component)
		{
			bool result = this.property.ShouldSerializeValue(component);
			return result;
		}

		/// <summary>
		/// Constructor.  Copy the base property descriptor and also hold a pointer
		/// to it for calling its overridden abstract methods.
		/// </summary>
		public DesignPropertyDescriptor(PropertyDescriptor prop) : base(prop)
		{
			this.property = prop;

			Attribute attr = prop.Attributes[typeof(DisplayNameAttribute)];

			if (attr is DisplayNameAttribute)
			{
				this.displayName = ((DisplayNameAttribute)attr).DisplayName;
			}
			else
			{
				this.displayName = prop.Name;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\Flavor\ProjectDocumentsChangeEventsArgs.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace Microsoft.VisualStudio.Shell.Flavor
{
    /// <include file='doc\ProjectDocumentsChangeEventArgs.uex' path='docs/doc[@for="ProjectDocumentsChangeEventArgs"]/*' />
    public sealed class ProjectDocumentsChangeEventArgs : EventArgs
	{
		private string mkDocument = null;
        /// <include file='doc\ProjectDocumentsChangeEventArgs.uex' path='docs/doc[@for="ProjectDocumentsChangeEventArgs.MkDocument"]/*' />
        /// <devdoc>
		/// Unique name of the Project item that was changed.
		/// Use IVsProject.IsDocumentInProject() to map to an itemid.
		/// </devdoc>
		public string MkDocument
		{
			get { return mkDocument; }
			set { mkDocument = value; }
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\EventSinkCollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="LogicalView.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Collections;
    using System.Diagnostics;

    /// <include file='doc\EventSinkCollection.uex' path='docs/doc[@for="EventSinkCollection"]/*' />
    /// <summary>
    /// Maps objects to and from integer "cookies".  This helps in the implementation
    /// of VS interfaces that have Advise/Unadvise methods, for example, IVsHierarchy,
    /// IVsCfgProvider2, IVsBuildableProjectCfg and so on.
    /// </summary>
    [CLSCompliant(false)]
    public class EventSinkCollection : IEnumerable {
        ArrayList map;

        /// <include file='doc\EventSinkCollection.uex' path='docs/doc[@for="EventSinkCollection.EventSinkCollection"]/*' />
        public EventSinkCollection() {
        }

        ArrayList GetMap() {
            if (this.map == null) this.map = new ArrayList();
            return this.map;
        }

        /// <include file='doc\EventSinkCollection.uex' path='docs/doc[@for="EventSinkCollection.Count"]/*' />
        /// <devdov>
        /// Returns the total number of sinks in the collection.  Some of these might be null though.
        /// </devdov>
        public int Count {
            get { return (this.map == null) ? 0 : this.map.Count; }
        }

        /// <include file='doc\EventSinkCollection.uex' path='docs/doc[@for="EventSinkCollection.Add"]/*' />
        /// <devdov>
        /// Add an event sink and return it's cookie which can be used in the RemoveAt method.
        /// </devdov>
        public uint Add(Object o) {
            if (o == null)
                throw new ArgumentNullException("o");

            // re-use empty slots so the ArrayList doesn't grow infinitely.
            for (int i = 0, n = this.GetMap().Count; i < n; i++) {
                if (map[i] == null) {
                    map[i] = o;
                    return (uint)i+1; // cookie must be one based else VS doesn't call Unadvise
                }
            }
            this.map.Add(o);
            return (uint)this.map.Count;
        }
        /// <include file='doc\EventSinkCollection.uex' path='docs/doc[@for="EventSinkCollection.Remove"]/*' />
        /// <devdov>
        /// Remove the specified event sink from the collection
        /// </devdov>
        public void Remove(Object obj) {
            if (obj == null)
                throw new ArgumentNullException("obj");

            if (this.map != null)
            {
                for (int i = 0, n = map.Count; i < n; i++)
                {
                    if (this.map[i] == obj)
                    {
                        this.map[i] = null; // these gap will be reused.
                        if (i == n - 1)
                        {
                            // compact the array list whenever possible.
                            while (i > 0 && this.map[i - 1] == null)
                            {
                                i--;
                            }
                            this.map.RemoveRange(i, n - i);
                        }
                        return;
                    }
                }
            }
            throw new ArgumentOutOfRangeException("obj");
        }
        /// <include file='doc\EventSinkCollection.uex' path='docs/doc[@for="EventSinkCollection.RemoveAt"]/*' />
        /// <devdov>
        /// Remove the specified event sink by the cookie integer returned from the Add method.
        /// </devdov>
        public void RemoveAt(uint cookie) {
            if (this.map != null){
                this.map[(int)cookie - 1] = null;  // cookie is 1-based
            }
        }
        /// <include file='doc\EventSinkCollection.uex' path='docs/doc[@for="EventSinkCollection.SetAt"]/*' />
        /// <devdov>
        /// Update the event sink associated with the given cookie.
        /// </devdov>
        public void SetAt(uint cookie, object value) {
            this.GetMap()[(int)cookie - 1] = value;
        }
        
        /// <include file='doc\EventSinkCollection.uex' path='docs/doc[@for="EventSinkCollection.this"]/*' />
        /// <devdov>
        /// Indexor access to the event sink.  Cookie is 1-based.
        /// </devdov>
        public object this[uint cookie] {
            get {
                return (this.map != null && cookie > 0 && cookie <= this.map.Count) ? this.map[(int)cookie-1] : null;
            }
            set {
                this.GetMap()[(int)cookie-1] = value;
            }
        }
        /// <include file='doc\EventSinkCollection.uex' path='docs/doc[@for="EventSinkCollection.Clear"]/*' />
        /// <devdov>
        /// Remove all event sinks.
        /// </devdov>
        public void Clear() {
            if (this.map != null) this.map.Clear();
        }

        /// <include file='doc\EventSinkCollection.uex' path='docs/doc[@for="EventSinkCollection.IEnumerable.GetEnumerator"]/*' />
        /// <internalonly/>
        IEnumerator IEnumerable.GetEnumerator() {
            return new EventSinkEnumerator(map);
        }
        internal class EventSinkEnumerator : IEnumerator {
            ArrayList map;            
            int pos;

            public EventSinkEnumerator(ArrayList map) {
                this.map = map; 
                this.pos = -1;
            }
            object IEnumerator.Current {
                get { return (this.map != null && this.pos >= 0 && this.pos < this.map.Count) ? this.map[this.pos] : null; }
            }
            bool IEnumerator.MoveNext() {
                if (this.map == null) return false;
                int n = this.map.Count;
                if (this.pos < n) {
                    this.pos++;
                    while (this.pos < n && this.map[this.pos] == null) // skip nulls
                        this.pos++;

                    if (this.pos < n) {
                        return true;
                    }
                    return false;
                }
                return false;
            }
            void IEnumerator.Reset() {
                this.pos = -1;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\IConfigureToolboxItem.cs ===
//------------------------------------------------------------------------------
// <copyright file="IConfigureToolboxItem.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {
    
    using System;
    using System.Drawing.Design;
    using Microsoft.VisualStudio.Shell.Interop;

    /// <include file='doc\IConfigureToolboxItem.uex' path='docs/doc[@for="IConfigureToolboxItem"]' />
    /// <devdoc>
    ///    This interface can be implemented on a creatable object.  The toolbox service will call
    ///    ConfigureToolboxItem on this interface when a new toolbox item is first added to the
    ///    toolbox.  This gives an external party a chance to add additional data to the toolbox item's
    ///    Properties dictionary.  This data then gets serialized as a permanent part of the toolbox item.
    /// 
    ///    Objects that implement this interface should be declared through a 
    ///    ProvideToolboxItemConfigurationAttribute attached to the package.  This attribute will register 
    ///    the object under the local CLSID hive in the VS registry and also add a reference to the GUID in
    ///    VSREGROOT\ToolboxItemConfiguration.  The data contained in this registry entry
    ///    is as follows:
    /// 
    ///    VSREGROOT\ToolboxItemConfiguration
    ///        AssemblyName
    ///             ConfigurationTypeName={guid}
    /// 
    ///    As an example:
    /// 
    ///    VSREGROOT\ToolboxItemConfiguration
    ///        System, Version=2.0.3500
    ///            CompactFrameworkProvider = {GUID}
    /// 
    /// 
    ///    The assembly name is parsed and the various keys are matched.  Keys can have a
    ///    "*" in them to be taken as wildcards.  So, for example, to cover all versions
    ///    of System.WindowsForms you would specify:
    /// 
    ///    System.Windows.Forms, Version=*, PublicKeyToken=969...
    /// 
    ///    The assembly name may also be a wildcard to load the configuration object
    ///    for all toolbox items (not recommended).
    /// </devdoc>
    public interface IConfigureToolboxItem {

        /// <include file='doc\IConfigureToolboxItem.uex' path='docs/doc[@for="IConfigureToolboxItem.ConfigureToolboxItem"]' />
        /// <devdoc>
        ///     Adds extra configuration information to thish toolbox item.
        /// </devdoc>
        void ConfigureToolboxItem(ToolboxItem item);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\IProfileManager.cs ===
//------------------------------------------------------------------------------
// <copyright file="IProfileManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {
    
    using System;
    using Microsoft.VisualStudio.Shell.Interop;

    /// <include file='doc\IProfileManager.uex' path='docs/doc[@for="IProfileManager"]' />
    /// <devdoc>
    /// Interface used to provide import/export capabilities of properties
    /// usually stored in the registry.
    /// </devdoc>
    [CLSCompliant(false)]
    public interface IProfileManager {
        /// <include file='doc\IProfileManager.uex' path='docs/doc[@for=IProfileManager.SaveSettingsToXml]/*' />
        /// <devdoc>
        /// Summary of SaveSettingsToXml.
        /// </devdoc>
        /// <param name='writer'></param>
        void SaveSettingsToXml(IVsSettingsWriter writer);

        /// <include file='doc\IProfileManager.uex' path='docs/doc[@for=IProfileManager.LoadSettingsFromXml]/*' />
        /// <devdoc>
        /// Summary of LoadSettingsFromXml.
        /// </devdoc>
        /// <param name='reader'></param>
        void LoadSettingsFromXml(IVsSettingsReader reader);

        /// <include file='doc\IProfileManager.uex' path='docs/doc[@for=IProfileManager.SaveSettingsToStorage]/*' />
        /// <devdoc>
        /// Summary of SaveSettingsToStorage.
        /// </devdoc>
        void SaveSettingsToStorage();

        /// <include file='doc\IProfileManager.uex' path='docs/doc[@for=IProfileManager.LoadSettingsFromStorage]/*' />
        /// <devdoc>
        /// Summary of LoadSettingsFromStorage.
        /// </devdoc>
        void LoadSettingsFromStorage();

        /// <include file='doc\IProfileManager.uex' path='docs/doc[@for=IProfileManager.ResetSettings]/*' />
        /// <devdoc>
        /// Reset your settings (__UserSettingsFlags.USF_ResetOnImport was set).
        /// </devdoc>
        void ResetSettings();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\DialogContainerWithToolbar.cs ===
//------------------------------------------------------------------------------
// <copyright file="WindowPane.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell.Interop;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Windows.Forms;
using System.Security.Permissions;

using IDropTarget = Microsoft.VisualStudio.OLE.Interop.IDropTarget;
using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
using IServiceProvider = System.IServiceProvider;
using IMessageFilter = System.Windows.Forms.IMessageFilter;

namespace Microsoft.VisualStudio.Shell {

    /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar"]/*' />
    /// <devdoc>
    /// This class is the base class for forms that need to be displayed as modal dialogs inside VisualStudio.
    /// </devdoc>
    [CLSCompliant(false)]
    public class DialogContainerWithToolbar : Form,
        IVsToolWindowToolbar,
        IServiceProvider,
        IMessageFilter
    {
        /// <devdoc>
        /// This class is used to change the control contained by the form to a
        /// IVsWindowPane. This is expecially needed if the control is a form,
        /// because WinForms will not allow us to make it child of another form.
        /// </devdoc>
        private class WindowPaneAdapter : WindowPane
        {
            private Control control;
            private DialogContainerWithToolbar container;
            private IntPtr paneHwnd;

            private int left;
            private int top;
            private int height;
            private int width;

            public WindowPaneAdapter(DialogContainerWithToolbar container, Control control) :
                base ((IServiceProvider)container)
            {
                this.container = container;
                this.paneHwnd = IntPtr.Zero;
                this.control = control;
            }

            protected override void Dispose(bool disposing)
            {
                if (disposing)
                {
                    if (null != control)
                    {
                        control.Dispose();
                        control = null;
                    }
                    paneHwnd = IntPtr.Zero;
                }
                base.Dispose(disposing);
            }

            public IntPtr Handle
            {
                get { return paneHwnd; }
            }

            public void Focus()
            {
                control.Focus();
            }

            // Create the pane at the specific coordinates.
            public void Create(int left, int top, int height, int width)
            {
                // Check if the pane was created before.
                if (IntPtr.Zero != paneHwnd)
                    throw new InvalidOperationException();

                // Create the object.
                NativeMethods.ThrowOnFailure(
                    ((IVsWindowPane)this).CreatePaneWindow(container.Handle, left, top, width, height, out paneHwnd));

                // Store the coordinates
                this.left = left;
                this.top = top;
                this.height = height;
                this.width = width;
            }

            // Returns the IWin32Window interface (used to access the handle of the control)
            public override IWin32Window Window
            {
                get { return (IWin32Window)control;  }
            }

            // Move the the pane to the specific coordinates.
            public void Move(int left, int top, int height, int width)
            {
                if (IntPtr.Zero == Handle)
                    return;

                bool result = UnsafeNativeMethods.SetWindowPos(
                                Handle, 
                                IntPtr.Zero, 
                                left, 
                                top,
                                width,
                                height,
                                NativeMethods.SWP_NOZORDER | NativeMethods.SWP_NOACTIVATE);

                if ( !result)
                    throw new Exception();

                this.left = left;
                this.top = top;
                this.height = height;
                this.width = width;
            }

            public int Left
            {
                get { return left; }
            }

            public int Top
            {
                get { return top; }
            }

            public int Height
            {
                get { return height; }
            }

            public int Width
            {
                get { return width; }
            }
        }

        private class ShowDialogContainer : Container
        {
            private IServiceProvider provider;
            public ShowDialogContainer(IServiceProvider sp)
            {
                provider = sp;
            }

            protected override object GetService(Type serviceType)
            {
                if (provider != null)
                {
                    object service = provider.GetService(serviceType);
                    if (null != service)
                        return service;
                }
                return base.GetService(serviceType);
            }
        }

        // Variables to handle the contained control
        private WindowPaneAdapter containedForm;
        private System.Drawing.Size controlSize;

        // Toolbar handling
        private IVsToolWindowToolbarHost toolbarHost;
        private RECT toolbarRect;
        private CommandID toolbarCommandId;
        private VSTWT_LOCATION toolbarLocation;
        private IDropTarget toolbarDropTarget;

        // Services
        private IServiceProvider provider;
        private OleMenuCommandService commandService;
        private uint commandTargetCookie;

        /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar.DialogContainerWithToolbar"]/*' />
        /// <devdoc>
        /// Constructor of the DialogContainerWithToolbar. This constructor allow the caller to set a IServiceProvider,
        /// the conatined control and an additional IOleCommandTarget implementation that will be chained to the one
        /// implemented by OleMenuCommandTarget.
        /// </devdoc>
        public DialogContainerWithToolbar(IServiceProvider sp, Control contained, IOleCommandTarget parentCommandTarget)
        {
            if (null == contained)
                throw new ArgumentNullException("contained");

            if (null == sp)
                throw new ArgumentNullException("sp");

            PrivateInit(sp, contained, parentCommandTarget);
        }

        /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar.DialogContainerWithToolbar1"]/*' />
        /// <devdoc>
        /// Constructor of the DialogContainerWithToolbar. This constructor allow the caller to set a IServiceProvider and
        /// the conatined control.
        /// </devdoc>
        public DialogContainerWithToolbar(IServiceProvider sp, Control contained)
        {
            if (null == contained)
                throw new ArgumentNullException("contained");

            if (null == sp)
                throw new ArgumentNullException("sp");

            IOleCommandTarget parentTarget = contained as IOleCommandTarget;
            PrivateInit(sp, contained, parentTarget);
        }

        /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar.DialogContainerWithToolbar2"]/*' />
        /// <devdoc>
        /// Constructor of the DialogContainerWithToolbar. This constructor allow the caller to set a IServiceProvider.
        /// </devdoc>
        public DialogContainerWithToolbar(IServiceProvider sp)
        {
            if (null == sp)
                throw new ArgumentNullException("sp");

            PrivateInit(sp, null, null);
        }

        /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar.DialogContainerWithToolbar3"]/*' />
        /// <devdoc>
        /// Constructor of the DialogContainerWithToolbar.
        /// </devdoc>
        public DialogContainerWithToolbar()
        {
            PrivateInit(null, null, null);
        }

        private void RegisterCommandTarget()
        {
            if (null == provider)
                throw new InvalidOperationException();

            IVsRegisterPriorityCommandTarget registerCommandTarget = (IVsRegisterPriorityCommandTarget)provider.GetService(typeof(SVsRegisterPriorityCommandTarget));
            if (null != registerCommandTarget)
                NativeMethods.ThrowOnFailure(
                    registerCommandTarget.RegisterPriorityCommandTarget(
                        0,
                        (IOleCommandTarget)commandService,
                        out commandTargetCookie));
        }

        private void PrivateInit(IServiceProvider sp, Control contained, IOleCommandTarget parentTarget)
        {
            provider = sp;

            commandTargetCookie = 0;
            if (null == parentTarget)
            {
                commandService = new OleMenuCommandService(sp);
            }
            else
            {
                commandService = new OleMenuCommandService(sp, parentTarget);
            }
            if (null != sp)
            {
                // Now we have to register the IOleCommandTarget implemented by the OleCommandService
                // as a priority command target, so it will be called by the shell.
                RegisterCommandTarget();
            }

            // Set the defaults for the toolbar (empty toolbar placed at the top)
            toolbarRect.left = 0;
            toolbarRect.top = 0;
            toolbarRect.right = 0;
            toolbarRect.bottom = 0;
            toolbarCommandId = null;
            toolbarLocation = VSTWT_LOCATION.VSTWT_TOP;

            if (null == contained)
            {
                containedForm = null;
            }
            else
            {
                controlSize = contained.ClientSize;
                containedForm = new WindowPaneAdapter(this, contained);
                this.Site = contained.Site;
                Form innerForm = contained as Form;
                if (null != innerForm)
                {
                    // If the contained control is a form, then copy some
                    // of its property to this one.
                    this.AcceptButton = innerForm.AcceptButton;
                    this.AccessibleDefaultActionDescription = innerForm.AccessibleDefaultActionDescription;
                    this.AccessibleDescription = innerForm.AccessibleDescription;
                    this.AccessibleName = innerForm.AccessibleName;
                    this.AccessibleRole = innerForm.AccessibleRole;
                    this.AllowDrop = innerForm.AllowDrop;
                    this.AllowTransparency = innerForm.AllowTransparency;
                    this.AutoScaleDimensions = innerForm.AutoScaleDimensions;
                    this.AutoScaleMode = innerForm.AutoScaleMode;
                    this.AutoScroll = innerForm.AutoScroll;
                    this.AutoScrollMargin = innerForm.AutoScrollMargin;
                    this.AutoScrollMinSize = innerForm.AutoScrollMinSize;
                    this.AutoScrollPosition = innerForm.AutoScrollPosition;
                    this.BindingContext = innerForm.BindingContext;
                    this.Bounds = innerForm.Bounds;
                    this.CancelButton = innerForm.CancelButton;
                    this.ContextMenu = innerForm.ContextMenu;
                    this.ControlBox = innerForm.ControlBox;
                    this.Cursor = innerForm.Cursor;
                    this.DesktopBounds = innerForm.DesktopBounds;
                    this.DesktopLocation = innerForm.DesktopLocation;
                    this.Font = innerForm.Font;
                    this.FormBorderStyle = innerForm.FormBorderStyle;
                    this.Icon = innerForm.Icon;
                    this.IsAccessible = innerForm.IsAccessible;
                    this.MaximizeBox = innerForm.MaximizeBox;
                    this.MaximumSize = innerForm.MaximumSize;
                    this.Menu = innerForm.Menu;
                    this.MinimizeBox = innerForm.MinimizeBox;
                    this.MinimumSize = innerForm.MinimumSize;
                    this.Opacity = innerForm.Opacity;
                    this.Region = innerForm.Region;
                    this.RightToLeft = innerForm.RightToLeft;
                    this.ShowInTaskbar = innerForm.ShowInTaskbar;
                    this.SizeGripStyle = innerForm.SizeGripStyle;
                    this.StartPosition = innerForm.StartPosition;
                    this.Text = innerForm.Text;
                    this.TopLevel = innerForm.TopLevel;
                    this.TopMost = innerForm.TopMost;
                    this.TransparencyKey = innerForm.TransparencyKey;
                }
            }
            // At the end of the copy we have to set the properties that we want
            // to enforse (right now only the HelpButton on the command bar).
            this.HelpButton = true;

            // Set the callbacks for the events that this default implementation will handle.
            this.Load += new EventHandler(FormLoad);
            this.Closing += new System.ComponentModel.CancelEventHandler(OnClosing);
        }

        /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar.SetSite"]/*' />
        /// <devdoc>
        /// Set the site for this window.
        /// </devdoc>
        public void SetSite(IServiceProvider sp)
        {
            if (null != provider)
                throw new InvalidOperationException();

            provider = sp;
            RegisterCommandTarget();
        }

        /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar.Dispose"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                // Make sure that all the resources are closed.
                OnClosing(this, new System.ComponentModel.CancelEventArgs());
            }
            base.Dispose(disposing);
        }

        private void OnClosing(object sender, System.ComponentModel.CancelEventArgs e)
        {
            // Close the toolbar host.
            if (null != toolbarHost)
            {
                toolbarHost.Close(0);
                toolbarHost = null;
            }
            // Close and dispose the main pane.
            if (null != containedForm)
            {
                ((IVsWindowPane)containedForm).ClosePane();
                containedForm = null;
            }
            // Check if we are still registered as priority command target
            if ( (0 != commandTargetCookie) && (null != provider) )
            {
                IVsRegisterPriorityCommandTarget registerCommandTarget = GetService(typeof(SVsRegisterPriorityCommandTarget)) as IVsRegisterPriorityCommandTarget;
                if (null != registerCommandTarget)
                    registerCommandTarget.UnregisterPriorityCommandTarget(commandTargetCookie);
                commandTargetCookie = 0;
            }
            if (null != e)
                e.Cancel = false;
        }

        object IServiceProvider.GetService(System.Type serviceType)
        {
            if ( serviceType.IsEquivalentTo(typeof(IVsToolWindowToolbar)) )
                return this;

            if ( serviceType.IsEquivalentTo(typeof(IOleCommandTarget)) )
                return commandService;

            if ( (serviceType.IsEquivalentTo(typeof(IVsToolWindowToolbarHost))) && (null != ToolbarHost) )
                return ToolbarHost;

            return provider.GetService(serviceType);
        }

        /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar.ToolbarID"]/*' />
        /// <devdoc>
        /// Gets or Sets the CommandID of the toolbar contained in this dialog.
        /// </devdoc>
        public CommandID ToolbarID
        {
            get { return toolbarCommandId; }
            set { toolbarCommandId = value; }
        }

        /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar.ToolbarLocation"]/*' />
        /// <devdoc>
        /// Location of the toolbar (Top, left, right ot bottom).
        /// </devdoc>
        public VSTWT_LOCATION ToolbarLocation
        {
            get { return toolbarLocation; }
            set { toolbarLocation = value; }
        }

        /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar.ToolbarDropTarget"]/*' />
        /// <summary>
        /// If the toolwindow has a ToolBar, allows intercepting drag and drop operations on the toolbar.
        /// Otherwise this is null
        /// </summary>
        public IDropTarget ToolbarDropTarget
        {
            get { return toolbarDropTarget; }
            set { toolbarDropTarget = value; }
        }

        /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar.ToolbarHost"]/*' />
        /// <devdoc>
        /// Gets the IVsToolWindowToolbarHost interface for this window.
        /// </devdoc>
        public IVsToolWindowToolbarHost ToolbarHost
        {
            get
            {
                // Check if there is a cached pointer to the interface.
                if (null != toolbarHost)
                    return toolbarHost;

                // If no cached version exist, we have to get a new one
                // from the UIShell service.
                IVsUIShell uiShell = (IVsUIShell)provider.GetService(typeof(SVsUIShell));
                NativeMethods.ThrowOnFailure(
                    uiShell.SetupToolbar(Handle, (IVsToolWindowToolbar)this, out toolbarHost));
                return toolbarHost;
            }
        }

        /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar.CommandService"]/*' />
        /// <devdoc>
        /// Returns the command service used to check the status or execute
        /// the toolbar's commands.
        /// </devdoc>
        public IMenuCommandService CommandService
        {
            get { return commandService as IMenuCommandService; }
        }

        int IVsToolWindowToolbar.GetBorder(RECT[] rect)
        {
            // Check that the parameter is correct.
            if ((null == rect) || (rect.Length != 1))
                throw new ArgumentException("rect");

            // Return the client area of this form.
            rect[0].left = 0;
            rect[0].top = 0;
            rect[0].right = this.ClientSize.Width;
            rect[0].bottom = this.ClientSize.Height;

            return NativeMethods.S_OK;
        }

        int IVsToolWindowToolbar.SetBorderSpace(RECT[] rect)
        {
            // Check input parameter.
            if ((null == rect) || (rect.Length != 1))
                throw new ArgumentException("rect");

            // Store the toolbar informations and resize the main pane to leave room
            // for the commandbar.
            toolbarRect = rect[0];
            ResizePane();

            return NativeMethods.S_OK;
        }

        [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
        bool IMessageFilter.PreFilterMessage(ref Message m)
        {
            if (null != ToolbarHost)
            {
                int lResult;
                int hr = ToolbarHost.ProcessMouseActivationModal(m.HWnd,(uint)m.Msg, (uint)m.WParam, (int)m.LParam, out lResult);
                // Check for errors.
                if ( NativeMethods.Failed(hr) )
                    return false;
                // ProcessMouseActivationModal returns S_FALSE to stop the message processing, but this
                // function have to return true in this case.
                return (hr==NativeMethods.S_FALSE);
            }

            return false;
        }

        /// <include file='doc\DialogContainerWithToolbar.uex' path='docs/doc[@for="DialogContainerWithToolbar.ShowDialog"]/*' />
        /// <devdoc>
        /// Show this window as modal dialog.
        /// </devdoc>
        public new DialogResult ShowDialog()
        {
            // if we don't have a service provider we can not show the dialog correctly
            if (null == provider)
                throw new InvalidOperationException();

            DialogResult result;
            IMessageFilter filter = this as IMessageFilter;

            // Make sure that there is non visual containment for this form
            ShowDialogContainer dialogContainer = null;
            if (this.Site == null)
            {
                dialogContainer = new ShowDialogContainer((IServiceProvider)this);
                dialogContainer.Add(this);
            }

            try
            {
                // This form needs to install its message filter in order to
                // let the toolbar process the mouse events.
                Application.AddMessageFilter(filter);

                // Show the modal dialog
                result = base.ShowDialog();
            }
            finally
            {
                if (dialogContainer != null)
                    dialogContainer.Remove(this);
                Application.RemoveMessageFilter(filter);
            }

            return result;
        }

        private void ResizePane()
        {
            // Get the size of the window.
            System.Drawing.Size mySize = this.ClientSize;

            // toolbarRect is not a real rectangle, it store the space that we have
            // to free at the left, top, right and bottom of this form for the toolbar.
            // So we have to move the main pane out of the way.
            int x = toolbarRect.left;
            int y = toolbarRect.top;
            int width = mySize.Width - toolbarRect.left - toolbarRect.right;
            int height = mySize.Height - toolbarRect.top - toolbarRect.bottom;

            containedForm.Move(x, y, height, width);
        }

        private void ResizeForm(object sender, EventArgs e)
        {
            ResizePane();
            if (ToolbarHost != null)
                ToolbarHost.BorderChanged();
        }

        private void FormLoad(object sender, EventArgs e)
        {
            if (this.DesignMode)
                return;

            if (null == containedForm)
            {
                // Handle the case that the class was constructed with the parameterless
                // constructor, so no container control is created.
                // In this case we have to create a new control that will contain all the
                // controls contained by this form and use it to create the window pane.
                Control paneControl = new UserControl();
                while (this.Controls.Count > 0)
                {
                    Control ctl = this.Controls[0];
                    ctl.Parent = paneControl;
                }
                containedForm = new WindowPaneAdapter(this, paneControl);
                controlSize = this.ClientSize;
            }

            System.Drawing.Size mySize = this.ClientSize;

            // Check if this window has a toolbar.
            if (null != toolbarCommandId)
            {
                Guid toolbarCommandSet = toolbarCommandId.Guid;
                IVsToolWindowToolbarHost2 toolBarHost2 = (IVsToolWindowToolbarHost2)ToolbarHost;
                NativeMethods.ThrowOnFailure(
                    toolBarHost2.AddToolbar2(toolbarLocation, ref toolbarCommandSet, (uint)toolbarCommandId.ID, toolbarDropTarget));
                NativeMethods.ThrowOnFailure(ToolbarHost.Show(0));
                NativeMethods.ThrowOnFailure(ToolbarHost.ForceUpdateUI());
            }

            // Now we have to resize the form to make room for the toolbar.
            mySize.Width = controlSize.Width + toolbarRect.left + toolbarRect.right;
            mySize.Height = controlSize.Height + toolbarRect.top + toolbarRect.bottom;
            this.ClientSize = mySize;

            // Find the coordinate of the main pane.
            int x = toolbarRect.left;
            int y = toolbarRect.top;
            int width = mySize.Width - toolbarRect.left - toolbarRect.right;
            int height = mySize.Height - toolbarRect.top - toolbarRect.bottom;

            // Make sure that the pane is created.
            containedForm.Create(x, y, height, width);
            // Set the focus to the control
            containedForm.Focus();

            // Install the handler for the resize.
            this.Resize += new EventHandler(ResizeForm);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\IResxResourceService.cs ===
//------------------------------------------------------------------------------
// <copyright file="ResourcePicker.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    using System.IO;
    using System.Security.Permissions;
    using Microsoft.Win32;
    using System.Collections;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Drawing.Design;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;
    using System.Windows.Forms.ComponentModel;
    using System.Windows.Forms.Design;
    using System.Resources;
    using System.Resources.Tools;
    using System.Globalization;


    /// <include file='doc\IResXResourceService.uex' path='docs/doc[@for="IResXResourceService"]/*' />
    /// <devdoc>
    ///    <para>
    ///         This interface is an abstraction layer that allows various clients to control resxreaders and writers
    ///         that get used within Visual Studio.
    ///    </para>
    /// </devdoc>
    public interface IResXResourceService {

        /// <include file='doc\IResXResourceService.uex' path='docs/doc[@for="GetResXResourceReader"]/*' />
        /// <devdoc>
        ///    <para>
        ///         Returns a resx resource reader given a basepath and name
        ///    </para>
        /// </devdoc>
        IResourceReader GetResXResourceReader(string resXFullName, bool useResXDataNodes);

        /// <include file='doc\IResXResourceService.uex' path='docs/doc[@for="GetResXResourceReader"]/*' />
        /// <devdoc>
        ///    <para>
        ///         Returns a resx resource reader given a basepath and name
        ///    </para>
        /// </devdoc>
        IResourceReader GetResXResourceReader(TextReader textReader, bool useResXDataNodes, string basePath);

        /// <include file='doc\IResXResourceService.uex' path='docs/doc[@for="GetResXResourceWriter"]/*' />
        /// <devdoc>
        ///    <para>
        ///         Returns a resx resource writer given a basepath and name
        ///    </para>
        /// </devdoc>
        IResourceWriter GetResXResourceWriter(string resXFullName);

        /// <include file='doc\IResXResourceService.uex' path='docs/doc[@for="GetResXResourceWriter"]/*' />
        /// <devdoc>
        ///    <para>
        ///         Returns a resx resource writer given a basepath and name
        ///    </para>
        /// </devdoc>
        IResourceWriter GetResXResourceWriter(TextWriter textWriter, string basePath);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\Flavor\ProjectFactory.cs ===
/***************************************************************************
         Copyright (c) Microsoft Corporation, All rights reserved.             
    This code sample is provided "AS IS" without warranty of any kind, 
    it is not recommended for use in a production environment.
***************************************************************************/

namespace Microsoft.VisualStudio.Shell.Flavor
{
    using System;
    using System.Diagnostics;
    using System.Globalization;
    using System.Runtime.InteropServices;
    using Microsoft.VisualStudio.Shell.Interop;
    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell;


    /// <include file='doc\FlavoredProjectFactory.uex' path='docs/doc[@for="FlavoredProjectFactory"]/*' />
    /// <devdoc>
    /// The project factory for the project flavor.
    /// Note that this is also known as Project Subtype
    /// </devdoc>
    [CLSCompliant(false)]
    public abstract class FlavoredProjectFactory : IVsAggregatableProjectFactory, IVsProjectFactory
    {
        private ServiceProvider _serviceProvider;
        /// <include file='doc\FlavoredProjectFactory.uex' path='docs/doc[@for="FlavoredProjectFactory.ServiceProvider"]/*' />
        protected ServiceProvider serviceProvider
        {
            get { return _serviceProvider; }
        }

        /// <include file='doc\FlavoredProjectFactory.uex' path='docs/doc[@for="FlavoredProjectFactory.FlavoredProjectFactory"]/*' />
        public FlavoredProjectFactory()
        {
        }

        #region IVsProjectFactory

        int IVsProjectFactory.CanCreateProject(string fileName, uint flags, out int canCreate)
        {
            canCreate = this.CanCreateProject(fileName, flags) ? 1 : 0;
            return NativeMethods.S_OK;
        }
        /// <include file='doc\FlavoredProjectFactory.uex' path='docs/doc[@for="FlavoredProjectFactory.CanCreateProject"]/*' />
        /// <devdoc>
        /// This is called to ask the factory if it can create a project based on the current parameters
        /// </devdoc>
        /// <returns>True if the project can be created</returns>
        protected virtual bool CanCreateProject(string fileName, uint flags)
        {
            // Validate the filename
            bool canCreate = !string.IsNullOrEmpty(fileName);
            canCreate |= !PackageUtilities.ContainsInvalidFileNameChars(fileName);
            return canCreate;
        }

        /// <devdoc>
        /// This is not expected to be called unless using an extension other then the base project
        /// </devdoc>
        int IVsProjectFactory.CreateProject(string fileName, string location, string name, uint flags, ref Guid projectGuid, out System.IntPtr project, out int canceled)
        {
            this.CreateProject(fileName, location, name, flags, ref projectGuid, out project, out canceled);
            return NativeMethods.S_OK;
        }
        /// <include file='doc\FlavoredProjectFactory.uex' path='docs/doc[@for="FlavoredProjectFactory.CreateProject"]/*' />
        /// <devdoc>
        /// If you want to use your own extension, you will need to call IVsCreateAggregatedProject.CreateAggregatedProject()
        /// </devdoc>
        /// <returns>HRESULT</returns>
        protected virtual void CreateProject(string fileName, string location, string name, uint flags, ref Guid projectGuid, out System.IntPtr project, out int canceled)
        {
            // If the extension is that of the base project then we don't get called
            project = IntPtr.Zero;
            canceled = 0;
        }

        int IVsProjectFactory.Close()
        {
            this.Dispose(true);

            return NativeMethods.S_OK;
        }
        /// <include file='doc\FlavoredProjectFactory.uex' path='docs/doc[@for="FlavoredProjectFactory.Dispose"]/*' />
        protected virtual void Dispose(bool disposing)
        {
            if (_serviceProvider != null)
            {
                _serviceProvider.Dispose();
                _serviceProvider = null;
            }
        }

        int IVsProjectFactory.SetSite(Microsoft.VisualStudio.OLE.Interop.IServiceProvider provider)
        {
            // keep track of our service provider
            this._serviceProvider = new ServiceProvider(provider);

            this.Initialize();

            return NativeMethods.S_OK;
        }
        /// <include file='doc\FlavoredProjectFactory.uex' path='docs/doc[@for="FlavoredProjectFactory.Initialize"]/*' />
        /// <devdoc>
        /// Called by SetSite after setting our service provider
        /// </devdoc>
        protected virtual void Initialize()
        {
        }

        #endregion

        #region IVsAggregatableProjectFactory

        int IVsAggregatableProjectFactory.GetAggregateProjectType(string fileName, out string projectTypeGuid)
        {
            projectTypeGuid = this.ProjectTypeGuids(fileName);
            return NativeMethods.S_OK;
        }

        int IVsAggregatableProjectFactory.PreCreateForOuter(object outerProject, out object project)
        {
            project = null;
            project = PreCreateForOuter(outerProject);

            if (!(project is FlavoredProject))
            {
                // We are not throwing in this case as someone could create 1 factory that support creating both
                // flavored project and full project. Also, someone could have implemented their flavored project
                // without using our base class. Never the less, if executing in the debugger, we should log this
                // to the output window.
                string warning = String.Format(CultureInfo.InvariantCulture, "Expected to recieve a FlavoredProject from PreCreateForOuter.\n Recieved a {0}", project.GetType().FullName);
                Trace.WriteLine(warning);
                // If you build your own version of this assembly and you intend to use FlavoredProject, uncomment
                // the following line as this will make any problem more obvious on debug builds
                //Debug.Fail(warning);
            }

            if (project == null)
                return NativeMethods.E_FAIL;

            return NativeMethods.S_OK;
        }
        /// <include file='doc\FlavoredProjectFactory.uex' path='docs/doc[@for="FlavoredProjectFactory.PreCreateForOuter"]/*' />
        /// <devdoc>
        /// This function returns an instance of the project. This is just creating the object,
        /// VS will later call SetInner and InitializeForOuter to initialize it.
        /// </devdoc>
        /// <param name="outerProject"></param>
        /// <returns>The project subtype</returns>
        protected abstract object PreCreateForOuter(object outerProject);
        #endregion

        /// <include file='doc\FlavoredProjectFactory.uex' path='docs/doc[@for="FlavoredProjectFactory.ProjectTypeGuids"]/*' />
        protected virtual string ProjectTypeGuids(string file)
        {
            throw new NotImplementedException();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\Attributes.cs ===
//--------------------------------------------------------------------------
//  <copyright file="Attributes.cs" company="Microsoft">
//      Copyright (c) Microsoft Corporation.  All rights reserved.
//  </copyright>
//  <summary>
//  </summary>
//--------------------------------------------------------------------------
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.Designer.Interfaces;
using System;
using System.Collections;
using System.ComponentModel;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using System.Xml;
using System.Diagnostics;

namespace Microsoft.VisualStudio.Shell
{ 
    /// <include file='doc\Attributes.uex' path='docs/doc[@for="PropertyPageTypeConverterAttribute"]' />
    /// <summary>
    /// Defines our type converter.
    /// </summary>
    /// <remarks>This is needed to get rid of the type TypeConverter type that could not give back the Type we were passing to him.
    /// We do not want to use reflection to get the type back from the  ConverterTypeName. Also the GetType mthos does not spwan converters from other assemblies.</remarks>
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Enum | AttributeTargets.Property | AttributeTargets.Field)]
    public sealed class PropertyPageTypeConverterAttribute : Attribute
    {
        Type converterType;
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="PropertyPageTypeConverterAttribute.PropertyPageTypeConverterAttribute"]' />
        public PropertyPageTypeConverterAttribute(Type t)
        {
            this.converterType = t;
        }

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="PropertyPageTypeConverterAttribute.ConverterType"]' />
        public Type ConverterType
        {
            get
            {
                return this.converterType;
            }
        }
    }

    /// <include file='doc\Attributes.uex' path='docs/doc[@for="LocDisplayNameAttribute"]' />
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Property | AttributeTargets.Field, Inherited = false, AllowMultiple = false)]
    public sealed class LocDisplayNameAttribute : DisplayNameAttribute
    {
        string name;

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="LocDisplayNameAttribute.LocDisplayNameAttribute"]' />
        public LocDisplayNameAttribute(string name)
        {
            this.name = name;
        }

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="LocDisplayNameAttribute.DisplayName"]' />
        public override string DisplayName
        {
            get
            {
                string result = null;
                try
                {
                    result = Resources.ResourceManager.GetString(this.name, Resources.Culture);
                }
                catch (System.Resources.MissingManifestResourceException)
                {
                }
                if (result == null)
                {
                    Debug.Assert(false, "String resource '" + this.name + "' is missing");
                    result = this.name;
                }
                return result;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\LocalizableProperties.cs ===
//--------------------------------------------------------------------------
//  <copyright file="LocalizableProperties.cs" company="Microsoft">
//      Copyright (c) Microsoft Corporation.  All rights reserved.
//  </copyright>
//  <summary>
//  </summary>
//--------------------------------------------------------------------------
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.Designer.Interfaces;
using System;
using System.Collections;
using System.ComponentModel;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using System.Xml;
using System.Diagnostics;

namespace Microsoft.VisualStudio.Shell
{
    /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties]/*' />
    [ComVisible(true)]
    public class LocalizableProperties : ICustomTypeDescriptor
	{
        #region ICustomTypeDescriptor
        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.GetAttributes]/*' />
        public AttributeCollection GetAttributes() 
		{
            AttributeCollection col = TypeDescriptor.GetAttributes(this, true);
            return col;
        }

        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.GetDefaultEvent]/*' />
        public EventDescriptor GetDefaultEvent() 
		{
            EventDescriptor ed = TypeDescriptor.GetDefaultEvent(this, true);
            return ed;
        }

        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.GetDefaultProperty]/*' />
        public PropertyDescriptor GetDefaultProperty() 
		{
            PropertyDescriptor pd = TypeDescriptor.GetDefaultProperty(this, true);
            return pd;
        }

        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.GetEditor]/*' />
        public object GetEditor(Type editorBaseType) 
		{
            object o = TypeDescriptor.GetEditor(this, editorBaseType, true);
            return o;
        }

        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.GetEvents]/*' />
        public EventDescriptorCollection GetEvents() 
		{
            EventDescriptorCollection edc = TypeDescriptor.GetEvents(this, true);
            return edc;
        }

        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.GetEvents1]/*' />
        public EventDescriptorCollection GetEvents(System.Attribute[] attributes) 
		{
            EventDescriptorCollection edc = TypeDescriptor.GetEvents(this, attributes, true);
            return edc;
        }

        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.GetPropertyOwner]/*' />
        public object GetPropertyOwner(PropertyDescriptor pd) 
		{
            return this;
        }

        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.GetProperties]/*' />
        public PropertyDescriptorCollection GetProperties() 
		{
            PropertyDescriptorCollection pcol = GetProperties(null);
            return pcol;
        }

        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.GetProperties1]/*' />
        public PropertyDescriptorCollection GetProperties(System.Attribute[] attributes) 
		{
            ArrayList newList = new ArrayList();
            PropertyDescriptorCollection props = TypeDescriptor.GetProperties(this, attributes, true);

            for (int i = 0; i < props.Count; i++)
                newList.Add(CreateDesignPropertyDescriptor(props[i]));

            return new PropertyDescriptorCollection((PropertyDescriptor[])newList.ToArray(typeof(PropertyDescriptor)));;
        }

        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.CreateDesignPropertyDescriptor]/*' />
        public virtual DesignPropertyDescriptor CreateDesignPropertyDescriptor(PropertyDescriptor p) 
		{
            return new DesignPropertyDescriptor(p);
        }

        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.GetComponentName]/*' />
        public string GetComponentName() 
		{
            string name = TypeDescriptor.GetComponentName(this, true);
            return name;
        }

        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.GetConverter]/*' />
        public virtual TypeConverter GetConverter() 
		{
            TypeConverter tc = TypeDescriptor.GetConverter(this, true);
            return tc;
        }

        /// <include file='doc\LocalizableProperties.uex' path='docs/doc[@for=LocalizableProperties.GetClassName]/*' />
        public virtual string GetClassName() 
		{
			return this.GetType().FullName;
		}

        #endregion ICustomTypeDescriptor
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\LogicalView.cs ===
//------------------------------------------------------------------------------
// <copyright file="LogicalView.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Globalization;

    /// <include file='doc\LogicalView.uex' path='docs/doc[@for="LogicalView"]' />
    /// <devdoc>
    ///     This enum lists the supported logical views.
    /// </devdoc>
    [TypeConverter(typeof(LogicalViewConverter))]
    public enum LogicalView {

    	/// <include file='doc\LogicalView.uex' path='docs/doc[@for="LogicalView.Primary"]/*' />
    	Primary,
    	/// <include file='doc\LogicalView.uex' path='docs/doc[@for="LogicalView.Any"]/*' />
    	Any,
        /// <include file='doc\LogicalView.uex' path='docs/doc[@for="LogicalView.Debugging"]/*' />
        Debugging,
        /// <include file='doc\LogicalView.uex' path='docs/doc[@for="LogicalView.Code"]/*' />
        Code,
        /// <include file='doc\LogicalView.uex' path='docs/doc[@for="LogicalView.Designer"]/*' />
        Designer,
        /// <include file='doc\LogicalView.uex' path='docs/doc[@for="LogicalView.Text"]/*' />
        Text,
        /// <include file='doc\LogicalView.uex' path='docs/doc[@for="LogicalView.UserChoose"]/*' />
        UserChoose,
        /// <include file='doc\LogicalView.uex' path='docs/doc[@for="LogicalView.ProjectSpecific"]/*' />
        ProjectSpecific
    }

    /// <devdoc>
    ///     This type converter inherits from the normal enum
    ///     converter.  It adds the ability to convert to/from
    ///     GUID types.
    /// </devdoc>
    internal class LogicalViewConverter : EnumConverter {

        private Guid[] _guids = new Guid[] {
            new Guid("00000000-0000-0000-0000-000000000000"),
            new Guid("FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF"),
            new Guid("7651A700-06E5-11D1-8EBD-00A0C90F26EA"),
            new Guid("7651A701-06E5-11D1-8EBD-00A0C90F26EA"),
            new Guid("7651A702-06E5-11D1-8EBD-00A0C90F26EA"),
            new Guid("7651A703-06E5-11D1-8EBD-00A0C90F26EA"),
            new Guid("7651A704-06E5-11D1-8EBD-00A0C90F26EA"),
            new Guid("80A3471A-6B87-433E-A75A-9D461DE0645F")
        };

        private LogicalView[] _views = new LogicalView[] {
            LogicalView.Primary,
            LogicalView.Any,
            LogicalView.Debugging,
            LogicalView.Code,
            LogicalView.Designer,
            LogicalView.Text,
            LogicalView.UserChoose,
            LogicalView.ProjectSpecific
        };

        public LogicalViewConverter(Type enumType) : base(enumType) {
            Debug.Assert(_views.Length == _guids.Length, "Mismatch in view / guid relationship");
        }

        /// <devdoc>
        ///     Gets a value indicating whether this converter
        ///     can convert an object in the given source type to an enumeration object using
        ///     the specified context.
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(Guid)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }
        
        /// <devdoc>
        ///     Gets a value indicating whether this converter can
        ///     convert an object to the given destination type using the context.
        /// </devdoc>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(Guid)) {
                return true;
            }
            return base.CanConvertTo(context, destinationType);
        }

        /// <devdoc>
        ///     Converts the specified value object to an enumeration object.
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value is Guid) {
                for (int i = 0; i < _guids.Length; i++) {
                    if (value.Equals(_guids[i])) {
                        return _views[i];
                    }
                }
            }
            return base.ConvertFrom(context, culture, value);
        }
    
        /// <devdoc>
        ///     Converts the given value object to the specified destination type.
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(Guid) && value != null) {
                for (int i = 0; i < _views.Length; i++) {
                    if (value.Equals(_views[i])) {
                        return _guids[i];
                    }
                }
            }
            
            return base.ConvertTo(context, culture, value, destinationType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\MsiComponentIdAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright from='2003' to='2004' company='Microsoft Corporation'>           
//  Copyright (c) Microsoft Corporation, All rights reserved.             
//  This code sample is provided "AS IS" without warranty of any kind, 
//  it is not recommended for use in a production environment.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;

    /// <summary>
    ///     This attribute defines the MSI component ID that is used by the 
    ///     MSI installer. This component ID is used to indicate the install
    ///     path to this component.  This must be placed on a package class
    ///     if the package is to be installed by MSI.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=false, Inherited=false)]
    public sealed class MsiComponentIdAttribute : Attribute {

        private string _id;
    
        /// <summary>
        ///     Creates a new MsiComponentIdAttribute.
        /// </summary>
        public MsiComponentIdAttribute (string id) {
            if (id == null) {
                throw new ArgumentNullException("id");
            }
            _id = id;
        }
        
        /// <summary>
        ///     Returns the component registration ID.
        /// </summary>
        public string Id {
            get {
                return _id;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\MsiTokenAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="MsiTokenAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;

    /// <include file='doc\MsiTokenAttribute.uex' path='docs/doc[@for="MsiTokenAttribute"]' />
    /// <devdoc>
    ///     This attribute defines a token string for the MSI installer.  RegPkg
    ///     will search for these attributes on a package class to identify custom
    ///     replacement tokens when generating registry scripts for the Microsoft
    ///     Installer.  Possible token names vary, but RegPkg may query for the 
    ///     following tokens:
    ///
    ///     $ComponentPath  : the path to the component.
    ///     SystemFolder    : the path to the OS system folder (%systemroot%\system32)
    ///
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=false)]
    public sealed class MsiTokenAttribute : Attribute {

        private string _name;
        private string _value;
    
        /// <include file='doc\MsiTokenAttribute.uex' path='docs/doc[@for="MsiTokenAttribute.MsiTokenAttribute"]' />
        /// <devdoc>
        ///     Creates a new MsiTokenAttribute.
        /// </devdoc>
        public MsiTokenAttribute (string name, string value) {
            if (name == null) {
                throw new ArgumentNullException("name");
            }

            if (value == null) {
                throw new ArgumentNullException("value");
            }

            _name = name;
            _value = value;
        }
        
        /// <include file='doc\MsiTokenAttribute.uex' path='docs/doc[@for="MsiTokenAttribute.Name"]' />
        /// <devdoc>
        ///     Returns the MSI token name.
        /// </devdoc>
        public string Name {
            get {
                return _name;
            }
        }
        
        /// <include file='doc\MsiTokenAttribute.uex' path='docs/doc[@for="MsiTokenAttribute.Value"]' />
        /// <devdoc>
        ///     Returns the MSI token value.
        /// </devdoc>
        public string Value {
            get {
                return _value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\IProfileMigrator.cs ===
//------------------------------------------------------------------------------
// <copyright file="IProfileMigrator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {
    
    using System;
    using Microsoft.VisualStudio.Shell.Interop;

    /// <include file='doc\IProfileMigrator.uex' path='docs/doc[@for="IProfileMigrator"]' />
    /// <devdoc>
    /// Interface used to support custom migration of user settings from one version of the
    /// product to another.
    /// </devdoc>
    [CLSCompliant(false)]
    public interface IProfileMigrator {
        /// <include file='doc\IProfileMigrator.uex' path='docs/doc[@for=IProfileMigrator.MigrateSettings]/*' />
        /// <devdoc>
        /// Summary of MigrateSettings.
        /// </devdoc>
        /// <param name='reader'></param>
        /// <param name='writer'></param>
        void MigrateSettings(IVsSettingsReader reader, IVsSettingsWriter writer);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\OleDataObject.cs ===
﻿//------------------------------------------------------------------------------
// <copyright file="VsToolboxService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using Microsoft.VisualStudio.Shell.Ole2Bcl;
using System;
using WinForms = System.Windows.Forms;

using IOleDataObject = Microsoft.VisualStudio.OLE.Interop.IDataObject;
using IComDataObject = System.Runtime.InteropServices.ComTypes.IDataObject;
using IDataObject = System.Windows.Forms.IDataObject;

namespace Microsoft.VisualStudio.Shell
{
    /// <include file='doc\OleDataObject.uex' path='docs/doc[@for=OleDataObject]/*' />
    [CLSCompliant(false)]
    public class OleDataObject : WinForms.DataObject, IOleDataObject
    {
        private IOleDataObject oleData;

        /// <include file='doc\OleDataObject.uex' path='docs/doc[@for=OleDataObject.OleDataObject]/*' />
        public OleDataObject() 
        {
            oleData = (IOleDataObject)(new Ole2BclDataObject(this as IComDataObject));
        }

        /// <include file='doc\OleDataObject.uex' path='docs/doc[@for=OleDataObject.OleDataObject1]/*' />
        public OleDataObject(IDataObject winData) :
            base (winData)
        {
            this.oleData = winData as IOleDataObject;
            if (null == this.oleData)
                oleData = (IOleDataObject)(new Ole2BclDataObject(this as IComDataObject));
        }

        /// <include file='doc\OleDataObject.uex' path='docs/doc[@for=OleDataObject.OleDataObject2]/*' />
        public OleDataObject(IComDataObject comData) :
            base(comData)
        {
            oleData = comData as IOleDataObject;
            if (null == oleData)
                this.oleData = (IOleDataObject)(new Ole2BclDataObject(comData));
        }

        /// <include file='doc\OleDataObject.uex' path='docs/doc[@for=OleDataObject.OleDataObject3]/*' />
        public OleDataObject(IOleDataObject oleData) :
            base( (oleData is IComDataObject) ? (IComDataObject)oleData : (IComDataObject)(new Ole2BclDataObject(oleData)) )
        {
            this.oleData = oleData;
        }

        #region IOleDataObject Members

        int IOleDataObject.DAdvise(Microsoft.VisualStudio.OLE.Interop.FORMATETC[] pFormatetc, uint ADVF, Microsoft.VisualStudio.OLE.Interop.IAdviseSink pAdvSink, out uint pdwConnection)
        {
            return oleData.DAdvise(pFormatetc, ADVF, pAdvSink, out pdwConnection);
        }

        void IOleDataObject.DUnadvise(uint dwConnection)
        {
            oleData.DUnadvise(dwConnection);
        }

        int IOleDataObject.EnumDAdvise(out Microsoft.VisualStudio.OLE.Interop.IEnumSTATDATA ppenumAdvise)
        {
            return oleData.EnumDAdvise(out ppenumAdvise);
        }

        int IOleDataObject.EnumFormatEtc(uint dwDirection, out Microsoft.VisualStudio.OLE.Interop.IEnumFORMATETC ppenumFormatEtc)
        {
            return oleData.EnumFormatEtc(dwDirection, out ppenumFormatEtc);
        }

        int IOleDataObject.GetCanonicalFormatEtc(Microsoft.VisualStudio.OLE.Interop.FORMATETC[] pformatectIn, Microsoft.VisualStudio.OLE.Interop.FORMATETC[] pformatetcOut)
        {
            return oleData.GetCanonicalFormatEtc(pformatectIn, pformatetcOut);
        }

        void IOleDataObject.GetData(Microsoft.VisualStudio.OLE.Interop.FORMATETC[] pformatetcIn, Microsoft.VisualStudio.OLE.Interop.STGMEDIUM[] pRemoteMedium)
        {
            oleData.GetData(pformatetcIn, pRemoteMedium);
        }

        void IOleDataObject.GetDataHere(Microsoft.VisualStudio.OLE.Interop.FORMATETC[] pFormatetc, Microsoft.VisualStudio.OLE.Interop.STGMEDIUM[] pRemoteMedium)
        {
            oleData.GetDataHere(pFormatetc, pRemoteMedium);
        }

        int IOleDataObject.QueryGetData(Microsoft.VisualStudio.OLE.Interop.FORMATETC[] pFormatetc)
        {
            return oleData.QueryGetData(pFormatetc);
        }

        void IOleDataObject.SetData(Microsoft.VisualStudio.OLE.Interop.FORMATETC[] pFormatetc, Microsoft.VisualStudio.OLE.Interop.STGMEDIUM[] pmedium, int fRelease)
        {
            oleData.SetData(pFormatetc, pmedium, fRelease);
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\InstalledProductRegistrationAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright from='2003' to='2004' company='Microsoft Corporation'>           
//  Copyright (c) Microsoft Corporation, All rights reserved.             
//  This code sample is provided "AS IS" without warranty of any kind, 
//  it is not recommended for use in a production environment.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Globalization;
using System.ComponentModel;

namespace Microsoft.VisualStudio.Shell 
{

    /// <summary>
    ///     This attribute registers an 'installed product' for your package.  
    ///     This enables your package to present information on the VS
    ///     Splash Screen or Help About.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, Inherited=false)]
    public sealed class InstalledProductRegistrationAttribute : RegistrationAttribute 
    {

        private string _productName;
        private string _name;
        private string _productId;
        private string _productDetails;
        private string _iconResourceId;
        private bool _useInterface = false;
        private bool _usePackage = false;
        private bool _useVsProductId = false;

        /// <summary>
        /// Creates a new InstalledProductRegistrationAttribute to register your package with Help/About dialog.
        /// This is the simplest registration information necessary for 3rd party packages. 
        /// Providing product details is not a requirement, but is recommended.
        /// </summary>
        public InstalledProductRegistrationAttribute (string productName, string productDetails, string productId) 
             : this(productName, productDetails, productId, false)
        {
        }

        /// <summary>
        /// Creates a new InstalledProductRegistrationAttribute to register your package with Help/About dialog.
        /// </summary>
        /// <param name="useVsProductId">
        ///     Reserved for Microsoft internal use.
        /// </param>
        [Browsable(false)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public InstalledProductRegistrationAttribute (string productName, string productDetails, string productId, bool useVsProductId) 
        {
            _useVsProductId = useVsProductId;

            Initialize(productName, productDetails, productId);
        }
    
        /// <summary>
        /// Creates a new InstalledProductRegistrationAttribute to register your package with Help/About dialog.
        /// </summary>
        [Browsable(false)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        [Obsolete("This InstalledProductRegistrationAttribute constructor has been deprecated. Please use other constructor instead.")]    
        public InstalledProductRegistrationAttribute (bool useInterface, string productName, string productDetails, string productId) 
        {
            _useInterface = useInterface;
            if (_useInterface)
            {
                // If the object uses the interface in order to expose its informations to the
                // Help/About page, then the registration must use the package, otherwise there
                // is no way to know where to find such interface.
                _usePackage = true;
            }
            else
            {
                Initialize(productName, productDetails, productId);
            }
         }
                
        private void Initialize (string productName, string productDetails, string productId) 
        {   
            // This function should not be called if the product registration info is provided via interface
            if (UseInterface)
            {
                string errorMessage = string.Format(Resources.Culture, Resources.Reg_ErrorIncompatibleParametersValues, "useInterface", "productName");
                throw new ArgumentException(errorMessage);
            }
        
            // We are not using the interface, so we need the other parameters.
            // Let's check that they are not null or empty.
            if ((null == productName) || (productName.Trim().Length == 0))
                throw new ArgumentNullException("productName");
            productName = productName.Trim();

            // ProductDetails is not mandatory, but is recommended.
            if (null != productDetails)
                productDetails = productDetails.Trim();

            // If not using the same product ID as the rest of VS, then productId is required
            // When using the VS product ID, then PID should not be specified
            if (!UseVsProductId)
            {
                if ((null == productId) || (productId.Trim().Length == 0))
                    throw new ArgumentNullException("productId");
                productId = productId.Trim();
            }
            else
            {
                if (null != productId)
                {
                    string errorMessage = string.Format(Resources.Culture, Resources.Reg_ErrorIncompatibleParametersValues, "productId", "useVsProductId");
                    throw new ArgumentException(errorMessage);
                }
            }
            
            // Assign the values to the member variables
            _productName = productName;
            _productDetails = productDetails;
            _productId = productId;

            // Now that we know that the parameters are not empty, let's do a final
            // validation: the Help/About code assumes that if a registration is made
            // using a package, then both the product name and the product details are
            // id of resources (so they are supposed to be in the form "#nnn"), but if 
            // they are strings, then they both must be string (when product details are provided).
            if (!String.IsNullOrEmpty(ProductDetails))
            {
                if (((ProductNameResourceID != 0) && (ProductDetailsResourceID == 0)) ||
                    ((ProductNameResourceID == 0) && (ProductDetailsResourceID != 0)))
                {
                    // If we are here we have the resource id for only one entry and,
                    // according with the Help/About code, this is bad, so we have to
                    // throw an exception.
                    string errorMessage = string.Format(Resources.Culture, Resources.Reg_ErrorIncompatibleParametersTypes, "productName", "productDetails");
                    throw new ArgumentException(errorMessage);
                }
            }

            // Now check if the name and details are resource id because in this case
            // we have to use the package to register. Actually we check only the name
            // because of the previous test.
            _usePackage = (ProductNameResourceID != 0) ;
        }

        #region Properties
        /// <summary>
        /// Resource ID corresponding to the product name.
        /// </summary>
        public int ProductNameResourceID
        {
            get
            {
                if (_productName == null || _productName.Length < 2 || _productName[0]!='#' || !char.IsDigit(_productName[1]))
                    return 0;
                return int.Parse( _productName.Substring(1), CultureInfo.InvariantCulture);
            }
        }
        /// <summary>
        /// Resource ID for the details.
        /// </summary>
        public int ProductDetailsResourceID
        {
            get
            {
                if (_productDetails == null || _productDetails.Length < 2 || _productDetails[0]!='#' || !char.IsDigit(_productDetails[1]))
                    return 0;
                return int.Parse( _productDetails.Substring(1), CultureInfo.InvariantCulture);
            }
        }
        /// <summary>
        /// Resource ID of the icon.
        /// </summary>
        public int IconResourceID
        {
            get
            {
                if (String.IsNullOrEmpty(_iconResourceId) || _iconResourceId.Length < 2)
                    return 0;
                return int.Parse( _iconResourceId.Substring(1), CultureInfo.InvariantCulture);
            }
            set
            {
                _iconResourceId = @"#" + value.ToString(CultureInfo.InvariantCulture);
            }
        }
        /// <summary>
        /// Your product ID.
        /// </summary>
        public string ProductId
        {
            get {return _productId;}
        }
        /// <summary>
        /// The name of your product.
        /// </summary>
        public string ProductName
        {
            get { return _productName; }
        }

        /// <summary>
        /// The name of your product.
        /// </summary>
        public string LanguageIndependentName
        {
            get { return _name; }
            set { _name = value; }
        }

        private string GetNonEmptyName(RegistrationContext context)
        {
            string product = LanguageIndependentName;
            if (product != null)
                product = product.Trim();
            if (String.IsNullOrEmpty(product))
                product = context.ComponentType.Name;
            return product;
        }
        /// <summary>
        /// Detailed description of your product.
        /// </summary>
        public string ProductDetails
        {
            get {return _productDetails;}
        }
        /// <summary>
        /// Use IVsInstalledProduct to fill in the Help about dialog.
        /// The package must implement IVsInstalledProduct.
        /// </summary>
        public bool UseInterface
        {
            get {return _useInterface;}
        }
        /// <summary>
        /// True is the product installation will use the package ID
        /// </summary>
        public bool UsePackage {
            get 
            {
                return _usePackage;
            }
        }
        
        /// <summary>
        /// True is the product ID is the same as VisualStudio ID
        /// This is reserved for Microsoft internal use. 3rd party packages should provide their own product ID when the class is constructed.
        /// </summary>
        public bool UseVsProductId 
        {
            get { return _useVsProductId; }
        }
        
        #endregion

        private string RegKeyName (RegistrationContext context)
        {
            return string.Format(CultureInfo.InvariantCulture, "InstalledProducts\\{0}", GetNonEmptyName(context));
        }


        /// <summary>
        ///     Called to register this attribute with the given context.
        /// </summary>
        /// <param name="context">
        ///     Contains the location where the registration information should be placed.
        ///     It also contains other information such as the type being registered and path information.
        /// </param>
        public override void Register(RegistrationContext context) 
        {
            if (UseInterface)
            {
                context.Log.WriteLine(Resources.Reg_NotifyInstalledProductInterface);
            }
            else
            {
                context.Log.WriteLine(Resources.Reg_NotifyInstalledProduct, GetNonEmptyName(context), ProductId ?? ProductName);
            }

            using (Key packageKey = context.CreateKey(RegKeyName(context)))
            {

                // Set the 'Package' value if necessary
                if (UsePackage)
                {
                    packageKey.SetValue("Package", context.ComponentType.GUID.ToString("B"));
                }

                // Set the 'UseRegNameAsSplashName' flag if the user provided a short name that should be used on the splash screen
                if (!String.IsNullOrEmpty(_name))
                {
                    packageKey.SetValue("UseRegNameAsSplashName", 1);
                }

                // Set the 'UseInterface' value if necessary
                if (UseInterface)
                {
                    packageKey.SetValue("UseInterface", 1);
                }
                else
                {
                    // If UseInterface is 0, then the following are required for HelpAbout
                    packageKey.SetValue("", ProductName);
                    if (UseVsProductId)
                    {
                        packageKey.SetValue("UseVsProductID", 1);
                    }
                    else
                    {
                        packageKey.SetValue("PID", ProductId);
                    }

                    // Product details are optional
                    if (!String.IsNullOrEmpty(ProductDetails))
                    {
                        packageKey.SetValue("ProductDetails", ProductDetails);
                    }

                    // The icon resource id reg entry is only valid if there 
                    // is a package satellite and not using the interface
                    if (UsePackage && !String.IsNullOrEmpty(_iconResourceId))
                    {
                        packageKey.SetValue("LogoID", _iconResourceId);
                    }
                }
            }
        }

        /// <summary>
        /// Unregister this InstalledProducts entry.
        /// </summary>
        /// <param name="context"></param>
        public override void Unregister(RegistrationContext context) 
        {
            context.RemoveKey(RegKeyName(context));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\HelperMethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="HelperMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell
{
    using System;

    /// <summary>
    /// Static helper class that contains common routines.
    /// </summary>
    internal static class HelperMethods
    {
        /// <summary>
        /// Checks if the argument passed is null. If so, it throws ArgumentNullException.
        /// </summary>        
        internal static void CheckNullArgument(object argument, string name)
        {
            if (argument == null)
            {
                throw new ArgumentNullException(name);
            }
        }

        /// <summary>
        /// Checks if the string argument is null or empty. If it is null, it throws ArgumentNullException
        /// and if it is empty, it throws ArgumentException.
        /// </summary>
        internal static void CheckNullOrEmptyString(string argument, string name)
        {
            if (argument == null)
            {
                throw new ArgumentNullException(argument);
            }

            if (argument == String.Empty)
            {
                throw new ArgumentException(Resources.Argument_EmptyString, name);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell\Private\PackageRegistrationAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="PackageRegistrationAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;
    using System.IO;
    using System.ComponentModel;
    using System.ComponentModel.Design;

    /// <devdoc>
    ///     This attribute is defined on a package to get it to be registered.  It
    ///     is internal because packages are meant to be registered, so it is
    ///     implicit just by having a package in the assembly.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, Inherited=true, AllowMultiple=false)]
    public sealed class PackageRegistrationAttribute : RegistrationAttribute
    {
        private RegistrationMethod registrationMethod = RegistrationMethod.Default;
        private bool useManagedResources = false;
        private string satellitePath = null;
        
        /// <devdoc>
        ///     Select between specifying the Codebase entry or the Assembly entry in the registry.
        ///     This can be overriden during registration
        /// </devdoc>
        public RegistrationMethod RegisterUsing
        {
            get
            {
                return registrationMethod;
            }
            set
            {
                registrationMethod = value;
            }
        }

        /// <summary>
        /// For managed resources, there should not be a native ui dll registered.
        /// </summary>
        public bool UseManagedResourcesOnly
        {
            get { return useManagedResources; }
            set { useManagedResources = value; }
        }

        /// <summary>
        /// To specify a resource dll located in a different location then the default,
        /// set this property. This can be useful if your package is installed in the GAC.
        /// If this is not set, the directory where the package is located will be use.
        /// 
        /// Note that the dll should be located at the following path:
        ///        SatellitePath\lcid\PackageDllNameUI.dll
        /// </summary>
        public string SatellitePath
        {
            get { return satellitePath; }
            set { satellitePath = value; }
        }

        private string RegKeyName(RegistrationContext context)
        {
            return String.Format(CultureInfo.InvariantCulture, "Packages\\{0}", context.ComponentType.GUID.ToString("B"));
        }

        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        /// <param name="context">
        ///     Contains the location where the registration inforomation should be placed.
        ///     It also contains other information such as the type being registered 
        ///     and path of the assembly.
        /// </param>
        public override void Register(RegistrationContext context) {
            Type t = context.ComponentType;
            context.Log.WriteLine(SR.GetString(SR.Reg_NotifyPackage, t.Name, t.GUID.ToString("B")));

            Key packageKey = null;
            try
            {
                packageKey = context.CreateKey(RegKeyName(context));

                //use a friendly description if it exists.
                DescriptionAttribute attr = TypeDescriptor.GetAttributes(t)[typeof(DescriptionAttribute)] as DescriptionAttribute;
                if (attr != null && !String.IsNullOrEmpty(attr.Description)) {
                    packageKey.SetValue(string.Empty, attr.Description);
                }
                else {
                    packageKey.SetValue(string.Empty, t.AssemblyQualifiedName);
                }

                packageKey.SetValue("InprocServer32", context.InprocServerPath);
                packageKey.SetValue("Class", t.FullName);

                // If specified on the command line, let the command line option override
                if (context.RegistrationMethod != RegistrationMethod.Default)
                {
                    registrationMethod = context.RegistrationMethod;
                }

                // Select registration method
                switch (registrationMethod)
                {
                    case RegistrationMethod.Assembly:
                    case RegistrationMethod.Default:
                        packageKey.SetValue("Assembly", t.Assembly.FullName);
                        break;

                    case RegistrationMethod.CodeBase:
                        packageKey.SetValue("CodeBase", context.CodeBase);
                        break;
                }

                Key childKey = null;
                if (!useManagedResources)
                {
                    try
                    {
                        childKey = packageKey.CreateSubkey("SatelliteDll");

                        // Register the satellite dll
                        string satelliteDllPath;
                        if (SatellitePath != null)
                        {
                            // Use provided path
                            satelliteDllPath = context.EscapePath(SatellitePath);
                        }
                        else
                        {
                            // Default to package path
                            satelliteDllPath = context.ComponentPath;
                        }
                        childKey.SetValue("Path", satelliteDllPath);
                        childKey.SetValue("DllName", String.Format(CultureInfo.InvariantCulture, "{0}UI.dll", Path.GetFileNameWithoutExtension(t.Assembly.ManifestModule.Name)));
                    }
                    finally
                    {
                        if (childKey != null)
                            childKey.Close();
                    }
                }
            }
            finally
            {
                if (packageKey != null)
                    packageKey.Close();
            }
        }

        /// <devdoc>
        ///     Unregister this package.
        /// </devdoc>
        /// <param name="context"></param>
        public override void Unregister(RegistrationContext context) 
        {
            context.RemoveKey(RegKeyName(context));
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\ProvideAutomationAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideAutomationObjectAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;
    using System.Runtime.InteropServices;
    using Microsoft.Win32;
    
    /// <include file='doc\ProvideAutomationObjectAttribute.uex' path='docs/doc[@for="ProvideAutomationObjectAttribute"]' />
    /// <devdoc>
    ///     This attribute declares that a package provides a particular automation object.  The attributes on a 
    ///     package do not control the behavior of the package, but they can be used by registration 
    ///     tools to register the proper information with Visual Studio.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideAutomationObjectAttribute : RegistrationAttribute {

        private string name;
        private string description;

        /// <include file='doc\ProvideAutomationObjectAttribute.uex' path='docs/doc[@for="ProvideAutomationAttribute.ProvideAutomationObjectAttribute"]' />
        /// <devdoc>
        ///     Creates a new ProvideAutomationObjectAttribute.
        /// </devdoc>
        public ProvideAutomationObjectAttribute(string objectName)
        {
            if (objectName == null) {
                throw new ArgumentNullException("ObjectName");
            }

            name = objectName;
        }

        /// <include file='doc\ProvideAutomationAttribute.uex' path='docs/doc[@for="ProvideAutomationObjectAttribute.Name"]' />
        /// <devdoc>
        ///     Returns the name of the automation object declared in this attribute.
        /// </devdoc>
        public string Name {
            get {
                return name;
            }
        }

        /// <include file='doc\ProvideAutomationObjectAttribute.uex' path='docs/doc[@for="ProvideAutomationObjectAttribute.Description"]' />
        /// <devdoc>
        ///     The description of the automation object declared in this attribute.
        /// </devdoc>
        public string Description 
        {
            get {
                return description;
            }
            set {
                description = value;
            }
         }

        private string GetAutomationRegKey(Guid packageGuid)
        {
            return string.Format(CultureInfo.InvariantCulture, "Packages\\{0}\\Automation", packageGuid.ToString("B"));
        }

        /// <include file='doc\ProvideAutomationObjectAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains information such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) 
        {
            using (Key childKey = context.CreateKey(GetAutomationRegKey(context.ComponentType.GUID)))
            {
                string descValue = (Description == null) ? "" : Description;
                childKey.SetValue(Name, descValue);
            }
        }

        /// <include file='doc\ProvideAutomationObjectAttribute.uex' path='docs/doc[@for="ProvideAutomationObjectAttribute.Unregister"]' />
        /// <devdoc>
        /// Removes the registration information from the registration context.
        /// </devdoc>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(GetAutomationRegKey(context.ComponentType.GUID));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\DialogPage.cs ===
//------------------------------------------------------------------------------
// <copyright file="DialogPage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell.Interop;
    using System.Windows.Forms.Design;
    using Microsoft.Win32;
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing;
    using System.Runtime.InteropServices;
    using System.Windows.Forms;

    using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
    using IServiceProvider = System.IServiceProvider;

    /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage"]' />
    /// <devdoc>
    ///     DialogPage encompasses a tools dialog page.  The default dialog page 
    ///     examines itself for public properties, and offers these properties 
    ///     to the user in a property grid.  You can customize this behavior, 
    ///     however by overriding various methods on the page.  The dialog 
    ///     page will automatically persist any changes made to it to the user's 
    ///     section of the registry, provided that those properties provide 
    ///     support for to/from string conversions on their type converter.
    /// </devdoc>
    [CLSCompliant(false),ComVisible(true)]
    public class DialogPage : Component,
        IWin32Window,
        IProfileManager {

        private IWin32Window     _window;
        private DialogSubclass   _subclass;
        private DialogContainer _container;
        private string           _settingsPath;
        private bool             _initializing = false;
        private bool             _uiActive = false;
        private bool             _propertyChangedHooked = false;
        private EventHandler     _onPropertyChanged;

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.DialogPage"]' />
        /// <devdoc>
        /// Constructs the Dialog Page.
        /// </devdoc>
        public DialogPage() {
            HookProperties(true);
        }

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.AutomationObject"]' />
        /// <devdoc>
        ///     The object the dialog page is going to browse.  The
        ///     default returns "this", but you can change it to
        ///     browse any object you want.
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public virtual object AutomationObject {
            get {
                return this;
            }
        }
        
        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage".Site]' />
        /// <devdoc>
        ///     Override for the site property.  This override is used so we can
        ///     load and save our settings at the appropriate time.
        /// </devdoc>
        public override ISite Site {
            get {
                return base.Site;
                
            }
            set {
                if (value == null && base.Site != null) {
                    // This is dangerous at shut down time and is causing
                    // bad ExecutionEngineExceptions. It's also entirely redundant.
                    //SaveSettingsToStorage();
                }

                base.Site = value;

                if (value != null) {
                    LoadSettingsFromStorage();
                }
            }
        }
        
        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage".Window]' />
        /// <devdoc>
        ///     The window this dialog page will use for its UI.
        ///     This window handle must be constant, so if you are
        ///     returning a Windows Forms control you must make sure
        ///     it does not recreate its handle.  If the window object
        ///     implements IComponent it will be sited by the 
        ///     dialog page so it can get access to global services.
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        protected virtual IWin32Window Window {
            get {
                PropertyGrid grid = new PropertyGrid();
                grid.Location = new Point(0,0);
                grid.ToolbarVisible = false;
                grid.CommandsVisibleIfAvailable = false;
                grid.SelectedObject = AutomationObject;
                return grid;
            }
        }
        
        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.Dispose"]' />
        /// <devdoc>
        ///     Disposes this object.
        /// </devdoc>
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {

                if (_container != null)
                {
                    try
                    {
                        _container.Dispose();
                    }
                    catch (Exception)
                    {
                        Debug.Fail("Failed to dispose container");
                    }
                    _container = null;
                }

                if (_window != null && _window is IDisposable)
                {
                    try
                    {
                    ((IDisposable)_window).Dispose();
                    }
                    catch (Exception)
                    {
                        Debug.Fail("Failed to dispose window");
                    }
                    _window = null;
                }

                if (_subclass != null)
                {
                    _subclass = null;
                }

                HookProperties(false);
            }
            base.Dispose(disposing);
        }
        
        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.LoadSettingsFromStorage"]' />
        /// <devdoc>
        ///     This method is called when the dialog page should load
        ///     its default settings from the registry.  The default
        ///     implementation gets the Package service, gets the
        ///     user registry key, and reads in all properties for this
        ///     page that could be converted from strings.
        /// </devdoc>
        public virtual void LoadSettingsFromStorage() {
            _initializing = true;
            try {
                Package package = (Package)GetService(typeof(Package));
                Debug.Assert(package != null, "No package service; we cannot load settings");
                if (package != null) {
                    using (RegistryKey rootKey = package.UserRegistryRoot) {

                        string path = this.SettingsRegistryPath;
                        object automationObject = this.AutomationObject;

                        RegistryKey key = rootKey.OpenSubKey(path, false /* writable */);
                        if (key != null) {
                            using (key) {

                                string[] valueNames = key.GetValueNames();
                                PropertyDescriptorCollection properties = TypeDescriptor.GetProperties(automationObject);

                                foreach(string valueName in valueNames) {
                                    string value = key.GetValue(valueName).ToString();

                                    PropertyDescriptor prop = properties[valueName];
                                    if (prop != null && prop.Converter.CanConvertFrom(typeof(string))) {
                                        prop.SetValue(automationObject, prop.Converter.ConvertFromInvariantString(value));
                                    }
                                }
                            }
                        }
                    }
                }
            }
            finally {
                _initializing = false;
            }
            HookProperties(true); //hook if this failed during construction.
        }

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.LoadSettingsFromXml"]' />
        /// <devdoc>
        ///     This method is called when the dialog page should load
        ///     its default settings from the profile XML file.  
        /// </devdoc>
        public virtual void LoadSettingsFromXml(IVsSettingsReader reader) {
            _initializing = true;
            try {
                object automationObject = this.AutomationObject;
                PropertyDescriptorCollection properties = TypeDescriptor.GetProperties(automationObject, new Attribute[] {DesignerSerializationVisibilityAttribute.Visible});

                foreach(PropertyDescriptor property in properties) {
                    TypeConverter converter = property.Converter;
                    if (converter.CanConvertTo(typeof(string)) && converter.CanConvertFrom(typeof(string))) {
                        // read from the xml feed
                        string value = null;
                        object cv = null;
                        try {
                            if ( NativeMethods.Succeeded(reader.ReadSettingString(property.Name, out value)) && (value != null) )
                            {
                                cv = property.Converter.ConvertFromInvariantString(value);
                            }
                        } catch (Exception) {
                            // ReadSettingString throws an exception if the property 
                            // is not found and we also catch ConvertFromInvariantString
                            // exceptions so that we gracefully handle bad vssettings.
                        }
                        //not all values have to be present
                        if (cv != null) { 
                            property.SetValue(automationObject, cv);
                        }
                    }
                }
            }
            finally {
                _initializing = false;    //we have loaded from storage
            }
            HookProperties(true); //hook if this failed during construction.
        }

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.ResetSettings"]' />
        /// <devdoc>Override this method in order to reset your settings to your default values.</devdoc>
        public virtual void ResetSettings() {
        }

        /// <devdoc>
        /// This function hooks property change events so that we automatically serialize
        /// if the value changes outside of UI and loading
        /// </devdoc>
        private void HookProperties(bool hook) {
            if (_propertyChangedHooked != hook)  {
                
                if (_onPropertyChanged == null)
                    _onPropertyChanged = new EventHandler(OnPropertyChanged);

                object automationObject = null;
                try
                {
                    automationObject = this.AutomationObject;
                }
                catch (Exception e)
                {
                    Debug.Fail(e.ToString());  //assert this so we don't ship bad code.
                }

                if (automationObject!= null)  {
                    PropertyDescriptorCollection properties = TypeDescriptor.GetProperties(automationObject, new Attribute[] {DesignerSerializationVisibilityAttribute.Visible});

                    foreach(PropertyDescriptor property in properties) {
                        if (hook) 
                            property.AddValueChanged(automationObject, _onPropertyChanged);
                        else
                            property.RemoveValueChanged(automationObject, _onPropertyChanged);
                    }
                    _propertyChangedHooked = hook;
                }
            }
        }

        // Convert an item property value changed event into a list changed event
        private void OnPropertyChanged(object sender, EventArgs e)  {
            if (!_initializing && !_uiActive)
                SaveSettingsToStorage();
        }

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.OnActivate"]' />
        /// <devdoc>
        ///     This method is called when VS wants to activate this
        ///     page.  If true is returned, the page is activated.
        /// </devdoc>
        protected virtual void OnActivate(CancelEventArgs e) {
            _uiActive = true;
        }
        
        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.OnClosed"]' />
        /// <devdoc>
        ///     This event is raised when the page is closed.   
        /// </devdoc>
        protected virtual void OnClosed(EventArgs e) {
            _uiActive = false;
            LoadSettingsFromStorage(); //reload whatever is saved in storage so if someone is accessing this object, it will have the correct values.
        }

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.OnDeactivate"]' />
        /// <devdoc>
        ///     This method is called when VS wants to deatviate this
        ///     page.  If true is returned, the page is deactivated.
        /// </devdoc>
        protected virtual void OnDeactivate(CancelEventArgs e) {
        }

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.OnApply"]' />
        /// <devdoc>
        ///     This method is called when VS wants to save the user's 
        ///     changes then the dialog is dismissed.
        /// </devdoc>
        protected virtual void OnApply(PageApplyEventArgs e) {
            SaveSettingsToStorage();
        }

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.SaveSettingsToStorage"]' />
        /// <devdoc>
        ///     This method does the reverse of LoadSettingsFromStorage.
        /// </devdoc>
        public virtual void SaveSettingsToStorage() {
            Package package = (Package)GetService(typeof(Package));
            Debug.Assert(package != null, "No package service; we cannot load settings");
            if (package != null) {
                using (RegistryKey rootKey = package.UserRegistryRoot) {

                    string path = SettingsRegistryPath;
                    object automationObject = this.AutomationObject;
                    RegistryKey key = rootKey.OpenSubKey(path, true /* writable */);
                    if (key == null) {
                        key = rootKey.CreateSubKey(path);
                    }

                    using (key) {

                        PropertyDescriptorCollection properties = TypeDescriptor.GetProperties(automationObject, new Attribute[] { DesignerSerializationVisibilityAttribute.Visible });

                        foreach(PropertyDescriptor property in properties) {
                            TypeConverter converter = property.Converter;
                            if (converter.CanConvertTo(typeof(string)) && converter.CanConvertFrom(typeof(string))) {
                                key.SetValue(property.Name, converter.ConvertToInvariantString(property.GetValue(automationObject)));
                            }
                        }
                    }
                }
            }
        }

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.SaveSettingsToXml"]' />
        /// <devdoc>
        ///     This method does the reverse of LoadSettingsFromXml.
        /// </devdoc>
        public virtual void SaveSettingsToXml(IVsSettingsWriter writer) {
            object automationObject = this.AutomationObject;
            PropertyDescriptorCollection properties = TypeDescriptor.GetProperties(automationObject, new Attribute[] {DesignerSerializationVisibilityAttribute.Visible});
            // [clovett] Sort the names so that tests can depend on the order returned, otherwise the order changes
            // randomly based on some internal hashtable seed.  Besides it makes it easier for the user to
            // read the .vssettings files.
            ArrayList sortedNames = new ArrayList();
            foreach (PropertyDescriptor property in properties) {
                sortedNames.Add(property.Name);
            }
            sortedNames.Sort();
            foreach(string name in sortedNames) {
                PropertyDescriptor property = properties[name];
                TypeConverter converter = property.Converter;
                if (converter.CanConvertTo(typeof(string)) && converter.CanConvertFrom(typeof(string))) {
                    NativeMethods.ThrowOnFailure(
                        writer.WriteSettingString(property.Name, converter.ConvertToInvariantString(property.GetValue(automationObject)))
                    );
                }
            }
        }

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.SettingsRegistryPath"]' />
        /// <devdoc>
        /// This is where the settings are stored under [UserRegistryRoot]\DialogPage, the default
        /// is the full type name of your AutomationObject.
        /// </devdoc>
        protected string SettingsRegistryPath {
            get {
                if (this._settingsPath == null) {
                    this._settingsPath = "DialogPage\\" + this.AutomationObject.GetType().FullName;
                }
                return this._settingsPath;
            }
            set {
                this._settingsPath = value;
            }
        }

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.IWin32Window.Handle"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// IWin32Window implementation.  This just delegates to the Window property.
        /// </devdoc>
        IntPtr IWin32Window.Handle {
            get {

                if (_window == null) {
                    _window = Window;
                    if (_window is IComponent) {
                        if (_container == null) {
                            _container = new DialogContainer(Site);
                        }
                        _container.Add((IComponent)_window);
                    }
                    if (_subclass == null) {
                        _subclass = new DialogSubclass(this);
                    }
                }

                if (_subclass.Handle != _window.Handle) {
                    _subclass.AssignHandle(_window.Handle);
                }

                return _window.Handle;
            }
        }

        internal void ResetContainer() {
            if (_container != null && _window is IComponent) {
                // This resets the AmbientProperties.
                _container._ambientProperties = null;
                _container.Remove((IComponent)_window);                
                _container.Add((IComponent)_window);
            }
        }

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.ApplyKind"]/*' />
        /// <devdoc>
        /// Apply behavior.  Allows the OnApply event to be canceled with optional navigation instructions.
        /// </devdoc>
        public enum ApplyKind { 
            /// <summary>
            /// Apply - Allows the changes to be applied
            /// </summary>
            Apply = 0, 

            /// <summary>
            /// CancelNavigate - Cancels the apply event and navigates to the page cancelling the event.
            /// </summary>
            Cancel = 1, 
            
            /// <summary>
            /// CancelNoNavigate - Cancels the apply event and returns the active page, not the page cancelling the event.
            /// </summary>
            CancelNoNavigate = 2 
        };

        /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.PageApplyEventArgs"]/*' />
        /// <devdoc>
        /// Event arguments to allow the OnApply method to indicate how to handle the apply event.
        /// </devdoc>
        protected class PageApplyEventArgs : EventArgs
        {
            private ApplyKind _apply = ApplyKind.Apply;

            /// <include file='doc\DialogPage.uex' path='docs/doc[@for="DialogPage.AutomationObject.ApplyBehavior"]' />
            public ApplyKind ApplyBehavior
            {
                get
                {
                    return _apply;
                }
                set
                {
                    _apply = value;
                }
            }
        }

        /// <devdoc>
        ///     This class derives from container to provide a service provider
        ///     connection to the dialog page.
        /// </devdoc>
        private sealed class DialogContainer : Container {

            private IServiceProvider _provider;
            internal AmbientProperties _ambientProperties;

            /// <devdoc>
            ///     Creates a new container using the given service provider.
            /// </devdoc>
            public DialogContainer(IServiceProvider provider) {
                _provider = provider;
            }

            /// <devdoc>
            ///     Override to GetService so we can route requests
            ///     to the package's service provider.
            /// </devdoc>
            protected override object GetService(Type serviceType) {
                if (serviceType == null) {
                    throw new ArgumentNullException("serviceType");
                }
                if (serviceType.IsEquivalentTo(typeof(AmbientProperties))) {
                    if (_ambientProperties == null) {
                        IUIService uis = GetService(typeof(IUIService)) as IUIService;
                        _ambientProperties = new AmbientProperties();
                        _ambientProperties.Font = (Font)uis.Styles["DialogFont"];
                    }
                    return _ambientProperties;
                }
                if (_provider != null) {
                    object service = _provider.GetService(serviceType);
                    if (service != null) {
                        return service;
                    }
                }
                return base.GetService(serviceType);
            }
        }

        /// <devdoc>
        ///     This class derives from NativeWindow to provide a hook
        ///     into the window handle.  We use this hook so we can
        ///     respond to property sheet window messages that VS
        ///     will send us.
        /// </devdoc>
        private sealed class DialogSubclass : NativeWindow {

            private DialogPage _page;
            private bool       _closeCalled;

            /// <devdoc>
            ///     Create a new DialogSubclass
            /// </devdoc>
            internal DialogSubclass(DialogPage page) {
                _page = page;
                _closeCalled = false;
            }

            /// <devdoc>
            ///     Override for WndProc to handle our PSP messages
            /// </devdoc>
            protected override void WndProc(ref Message m) {

                CancelEventArgs ce;

                switch (m.Msg) { 
                    case NativeMethods.WM_NOTIFY:
                        NativeMethods.NMHDR nmhdr = (NativeMethods.NMHDR)Marshal.PtrToStructure(m.LParam, typeof(NativeMethods.NMHDR));
                        switch (nmhdr.code) {
                            case NativeMethods.PSN_RESET:
                                _closeCalled = true;
                                _page.OnClosed(EventArgs.Empty);
                                return;
                            case NativeMethods.PSN_APPLY:
                                PageApplyEventArgs pae = new PageApplyEventArgs(); 
                                _page.OnApply(pae);
                                switch (pae.ApplyBehavior)
                                {    
                                    case ApplyKind.Cancel:
                                        m.Result = (IntPtr)NativeMethods.PSNRET_INVALID;
                                        break;

                                    case ApplyKind.CancelNoNavigate:
                                        m.Result = (IntPtr)NativeMethods.PSNRET_INVALID_NOCHANGEPAGE;
                                        break;

                                    case ApplyKind.Apply:
                                    default:
                                        m.Result = IntPtr.Zero;
                                        break;
                                }
                                UnsafeNativeMethods.SetWindowLong(m.HWnd, NativeMethods.DWL_MSGRESULT, m.Result);
                                return;
                            case NativeMethods.PSN_KILLACTIVE:
                                ce = new CancelEventArgs();
                                _page.OnDeactivate(ce);
                                m.Result = (IntPtr)(ce.Cancel ? 1 : 0);
                                UnsafeNativeMethods.SetWindowLong(m.HWnd, NativeMethods.DWL_MSGRESULT, m.Result);
                                return;
                            case NativeMethods.PSN_SETACTIVE:
                                _closeCalled = false;
                                ce = new CancelEventArgs();
                                _page.OnActivate(ce);
                                m.Result = (IntPtr)(ce.Cancel ? -1 : 0);
                                UnsafeNativeMethods.SetWindowLong(m.HWnd, NativeMethods.DWL_MSGRESULT, m.Result);
                                return;
                        }
                        break;
                    case NativeMethods.WM_DESTROY:

                        // we can't tell the difference between OK and Apply (see above), so
                        // if we get a destroy and close hasn't been called, make sure we call it
                        //
                        if (!_closeCalled && _page != null) {
                            _page.OnClosed(EventArgs.Empty);
                        }
                        break;
                }

                base.WndProc(ref m);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\OleMenuCommandService.cs ===
//------------------------------------------------------------------------------
// <copyright file="OleMenuCommandService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.VisualStudio.Shell {
    
    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell.Interop;
    using Microsoft.Win32;
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Runtime.InteropServices;

    using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
    using IServiceProvider = System.IServiceProvider;
    using VSConstants = Microsoft.VisualStudio.VSConstants;

    /// <include file='doc\OleMenuCommandService.uex' path='docs/doc[@for="OleMenuCommandService"]/*' />
    /// <devdoc>
    ///    
    /// </devdoc>
    [CLSCompliant(false)]
    [System.Runtime.InteropServices.ComVisible(true)]
    public class OleMenuCommandService : System.ComponentModel.Design.MenuCommandService, IOleCommandTarget {

        internal static TraceSwitch MENUSERVICE = new TraceSwitch("MENUSERVICE", "MenuCommandService: Track menu command routing");

        private IOleCommandTarget _parentTarget;
        private IServiceProvider _provider;

        private static uint _queryStatusCount = 0;

        /// <include file='doc\OleMenuCommandService.uex' path='docs/doc[@for="OleMenuCommandService.OleMenuCommandService"]/*' />
        /// <devdoc>
        ///     Creates a new menu command service.
        /// </devdoc>
        public OleMenuCommandService(IServiceProvider serviceProvider) : base(serviceProvider){   
            _provider = serviceProvider;
        }


        /// <include file='doc\OleMenuCommandService.uex' path='docs/doc[@for="OleMenuCommandService.OleMenuCommandService1"]/*' />
        /// <devdoc>
        ///     Creates a new menu command service.
        /// </devdoc>
        public OleMenuCommandService(IServiceProvider serviceProvider, IOleCommandTarget parentCommandTarget) : base(serviceProvider) {
            if (parentCommandTarget == null) {
                throw new ArgumentNullException("parentCommandTarget");
            }
            _parentTarget = parentCommandTarget;
            _provider = serviceProvider;
        }

        /// <include file='doc\OleMenuCommandService.uex' path='docs/doc[@for="OleMenuCommandService.ServiceProvider"]/*' />
        /// <devdoc>
        ///     Returns the service provider.
        /// </devdoc>
        [Obsolete("This method is obsolete and will be removed before the end of M3.2.  Use the proected GetService method instead.")]
        protected IServiceProvider ServiceProvider {
            get {
                return _provider;
            }
        }

        public IOleCommandTarget ParentTarget {
            get { return _parentTarget; }
            set { _parentTarget = value; }
        }

        private MenuCommand FindCommand(Guid guid, int id, ref int hrReturn) {
            hrReturn = (int)Microsoft.VisualStudio.OLE.Interop.Constants.OLECMDERR_E_UNKNOWNGROUP;

            MenuCommand result = null;

            //first query the IMenuCommandService and ask it to FindCommand
            IMenuCommandService menuCommandService = GetService(typeof(IMenuCommandService)) as IMenuCommandService;
            if (menuCommandService != null)
            {
            	result = menuCommandService.FindCommand(new CommandID(guid, (int)id));	
            }
            //if the IMenuCommandService cames back w/o a command, then ask ourselves
            if (result == null && this != menuCommandService)
            {
            	result = FindCommand(guid, (int)id);
            }

            if(result == null) {
                ICollection commands = GetCommandList(guid);
                if(commands != null) {                
                    // The default error now must be "Not Supported" because the command group is known
                    hrReturn = (int)Microsoft.VisualStudio.OLE.Interop.Constants.OLECMDERR_E_NOTSUPPORTED;
                    Debug.WriteLineIf(MENUSERVICE.TraceVerbose, "\t...VSMCS Found group");
                    // Get the list of command inside this group
                    foreach (MenuCommand command in commands) {
                        // we are looping again on the list of commands to check the DynamicItemMatch
                        // but this is unavoidable in this context....
                        // If the command is a OleMenuCommand, then we can try to do a dynamic match
                        IOleMenuCommand vsCommand = command as IOleMenuCommand;
                        if ( (null != vsCommand) && (vsCommand.DynamicItemMatch(id)) )
                        {
                            Debug.WriteLineIf(MENUSERVICE.TraceVerbose, "\t...VSMCS Found command2");
                            hrReturn = NativeMethods.S_OK;
                            result = command;
                        }
                    }            
                }
            }else {
                Debug.WriteLineIf(MENUSERVICE.TraceVerbose, "\t... VSMCS Found command");
                hrReturn = NativeMethods.S_OK;
            }
            return result;
        }


        /// <include file='doc\OleMenuCommandService.uex' path='docs/doc[@for="OleMenuCommandService.GlobalInvoke"]/*' />
        /// <devdoc>
        ///     Invokes a command on the local form or in the global environment.
        ///     The local form is first searched for the given command ID.  If it is
        ///     found, it is invoked.  Otherwise the the command ID is passed to the
        ///     global environment command handler, if one is available.
        /// </devdoc>
        public override bool GlobalInvoke(CommandID commandID) {

            // is it local?
            if(base.GlobalInvoke(commandID)) {
                return true;
            }
            
            // pass it to the global handler
            IVsUIShell uiShellSvc = GetService(typeof(SVsUIShell)) as IVsUIShell;
            if (uiShellSvc != null) {
                Object dummy = null;
                Guid tmpGuid = commandID.Guid;
                if ( NativeMethods.Failed(uiShellSvc.PostExecCommand(ref tmpGuid, (uint)commandID.ID, 0, ref dummy)) )
                    return false;
                return true;
            }
            return false;
        }

        /// <include file='doc\OleMenuCommandService.uex' path='docs/doc[@for="OleMenuCommandService.GlobalInvoke1"]/*' />
        /// <devdoc>
        ///     Invokes a command on the local form or in the global environment.
        ///     The local form is first searched for the given command ID.  If it is
        ///     found, it is invoked.  Otherwise the the command ID is passed to the
        ///     global environment command handler, if one is available.
        /// </devdoc>
        public override bool GlobalInvoke(CommandID commandID, object arg) {

            // is it local?
            if(base.GlobalInvoke(commandID, arg)) {
                return true;
            }

            // pass it to the global handler
            IVsUIShell uiShellSvc = GetService(typeof(SVsUIShell)) as IVsUIShell;
            if (uiShellSvc == null)
                return false;

            Object dummy = arg;
            Guid tmpGuid = commandID.Guid;
            if ( NativeMethods.Failed(uiShellSvc.PostExecCommand(ref tmpGuid, (uint)commandID.ID, 0, ref dummy)) )
                return false;
            return true;
        }

        /// <include file='doc\OleMenuCommandService.uex' path='docs/doc[@for="OleMenuCommandService.OnCommandChanged"]/*' />
        /// <devdoc>
        ///     This is called by a menu command when it's status has changed.
        /// </devdoc>
        protected override void OnCommandsChanged(MenuCommandsChangedEventArgs e) {

            base.OnCommandsChanged(e);

            if (0 == _queryStatusCount) {
                // UpdateCommandUI(0) can not be called inside QueryStatus because this will cause an infinite
                // sequence of calls to QueryStatus during idle time.
                IVsUIShell uiShellSvc = GetService(typeof(SVsUIShell)) as IVsUIShell;
                if (uiShellSvc != null) {
                    NativeMethods.ThrowOnFailure(uiShellSvc.UpdateCommandUI(0));
                }
            }
        }

        /// <include file='doc\OleMenuCommandService.uex' path='docs/doc[@for="OleMenuCommandService.ShowContextMenu"]/*' />
        /// <devdoc>
        ///     Shows the context menu with the given command ID at the given
        ///     location.
        /// </devdoc>
        public override void ShowContextMenu(CommandID menuID, int x, int y) {
            
            IOleComponentUIManager cui = GetService(typeof(NativeMethods.OleComponentUIManager)) as IOleComponentUIManager;
            Debug.Assert(cui != null, "no component UI manager, so we can't display a context menu");
            if (cui != null) {
                POINTS[] pt = new POINTS[] { new POINTS() };
                pt[0].x = (short)x;
                pt[0].y = (short)y;

                Guid tmpGuid = menuID.Guid;
                NativeMethods.ThrowOnFailure( cui.ShowContextMenu(0, ref tmpGuid, menuID.ID, pt, this) );
            }
        }

        private uint HiWord(uint val) {
            return ((val >> 16) & 0xFFFF);
        }
        private uint LoWord(uint val) {
            return (val & 0xFFFF);
        }

        /// <include file='doc\OleMenuCommandService.uex' path='docs/doc[@for="OleMenuCommandService.IOleCommandTarget.Exec"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Executes the given command.
        /// </devdoc>
        int IOleCommandTarget.Exec(ref Guid guidGroup, uint nCmdId, uint nCmdExcept, IntPtr pIn, IntPtr vOut) {
            const uint vsCmdOptQueryParameterList = 1;

            Guid commandGroup = Guid.Empty;
            try {
                commandGroup = guidGroup;
            }
            catch (NullReferenceException) {
                // Here we assume that the only reason for the exception is a null guidGroup.
                // We do not handle the default command group as definied in the spec for IOleCommandTarget,
                // so we have to return OLECMDERR_E_NOTSUPPORTED.
                return (int)Microsoft.VisualStudio.OLE.Interop.Constants.OLECMDERR_E_NOTSUPPORTED;
            }

            int hr = NativeMethods.S_OK;

            MenuCommand cmd = FindCommand(commandGroup, (int)nCmdId, ref hr);
            // If the command is not supported check if it can be handled by the parent command service
            if ( (cmd== null || !cmd.Supported) && _parentTarget != null) 
            {
                return _parentTarget.Exec(ref commandGroup, nCmdId, nCmdExcept, pIn, vOut);
            }
            else if (cmd != null) {
                // Try to see if the command is a IOleMenuCommand.
                IOleMenuCommand vsCmd = cmd as IOleMenuCommand;
                // Check the execution flags;
                uint loWord = LoWord(nCmdExcept);
                // If the command is not an OleMenuCommand, it can not handle the show help option.
                if (((uint)OLECMDEXECOPT.OLECMDEXECOPT_SHOWHELP == loWord) && (null == vsCmd))
                {
                    return NativeMethods.S_OK;
                }
                object o = null;
                if (pIn != IntPtr.Zero)
                {
                    o = Marshal.GetObjectForNativeVariant(pIn);
                }
                if (null == vsCmd)
                {
                    cmd.Invoke(o);
                }
                else
                {
                    switch (loWord)
                    {
                        // Default execution of the command: call the Invoke method
                        case (uint)OLECMDEXECOPT.OLECMDEXECOPT_PROMPTUSER:
                        case (uint)OLECMDEXECOPT.OLECMDEXECOPT_DONTPROMPTUSER:
                        case (uint)OLECMDEXECOPT.OLECMDEXECOPT_DODEFAULT:
                            {
                                IMenuCommandInvokeEx invokeEx = vsCmd as IMenuCommandInvokeEx;
                                if (null != invokeEx)
                                {
                                    invokeEx.Invoke(o, vOut, (OLECMDEXECOPT)loWord);
                                }
                                else
                                {
                                    vsCmd.Invoke(o, vOut);
                                }
                            }
                            break;

                        case (uint)OLECMDEXECOPT.OLECMDEXECOPT_SHOWHELP:
                            // Check the hi word of the flags to see what kind of help
                            // is needed. We handle only the request for the parameters list.
                            if (vsCmdOptQueryParameterList == HiWord(nCmdExcept) && IntPtr.Zero != vOut)
                            {
                                // In this case vOut is a pointer to a VARIANT that will receive
                                // the parameters description.
                                if (!string.IsNullOrEmpty(vsCmd.ParametersDescription))
                                {
                                    Marshal.GetNativeVariantForObject(vsCmd.ParametersDescription, vOut);
                                }
                            }
                            break;

                        default:
                            break;
                    }
                }
            }

            return hr;

        }

        /// <include file='doc\OleMenuCommandService.uex' path='docs/doc[@for="OleMenuCommandService.IOleCommandTarget.QueryStatus"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Inquires about the status of a command.  A command's status indicates
        /// it's availability on the menu, it's visibility, and it's checked state.
        /// The exception thrown by this method indicates the current command status.
        /// </devdoc>
        int IOleCommandTarget.QueryStatus(ref Guid guidGroup, uint nCmdId, OLECMD[] oleCmd, IntPtr oleText) {
            // According with MSDN the Guid for the command group can be null and in this case the default
            // command group should be used. Given the interop definition of IOleCommandTarget, the only way
            // to detect a null guid is to try to access it and catch the NullReferenceExeption.
            Guid commandGroup = Guid.Empty;
            try {
                commandGroup = guidGroup;
            }
            catch (NullReferenceException) {
                // Here we assume that the only reason for the exception is a null guidGroup.
                // We do not handle the default command group as definied in the spec for IOleCommandTarget,
                // so we have to return OLECMDERR_E_NOTSUPPORTED.
                return (int)Microsoft.VisualStudio.OLE.Interop.Constants.OLECMDERR_E_NOTSUPPORTED;
            }

            _queryStatusCount += 1;
            int hr = NativeMethods.S_OK;
            try {
                for (uint i = 0; i < oleCmd.Length && NativeMethods.Succeeded(hr); i++)
                {
                    MenuCommand cmd = FindCommand(commandGroup, (int)oleCmd[i].cmdID, ref hr);

                    oleCmd[i].cmdf = 0;
                    if ((cmd != null) && NativeMethods.Succeeded(hr))
                    {
                        oleCmd[i].cmdf = (uint)cmd.OleStatus;
                    }

                    if ((oleCmd[i].cmdf & (int)NativeMethods.tagOLECMDF.OLECMDF_SUPPORTED) != 0)
                    {
                        // Find if the caller needs the text of the command
                        if ((IntPtr.Zero != oleText) && (NativeMethods.OLECMDTEXT.GetFlags(oleText) == NativeMethods.OLECMDTEXT.OLECMDTEXTF.OLECMDTEXTF_NAME))
                        {
                            string textToSet = null;
                            if (cmd is DesignerVerb)
                            {
                                textToSet = ((DesignerVerb)cmd).Text;
                            }
                            else if (cmd is IOleMenuCommand)
                            {
                                textToSet = ((IOleMenuCommand)cmd).Text;
                            }
                            if (null != textToSet)
                            {
                                NativeMethods.OLECMDTEXT.SetText(oleText, textToSet);
                            }
                        }
                    }
                    else if (_parentTarget != null)
                    {
                        // If the command is not supported and this command service has a parent,
                        // ask the parent about the command.
                        OLECMD[] newOleArray = { oleCmd[i] };
                        hr = _parentTarget.QueryStatus(ref commandGroup, 1, newOleArray, oleText);
                        oleCmd[i] = newOleArray[0];
                    }
                    // SBurke, if the flags are zero, the shell prefers
                    // that we return not supported, or else no one else will
                    // get asked
                    //
                    if (oleCmd[i].cmdf == 0) {
                        hr = NativeMethods.OLECMDERR_E_NOTSUPPORTED;
                    }
                }
            }
            finally {
                if (0 < _queryStatusCount)
                    _queryStatusCount -= 1;
            }
            return hr;

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\OleToBCL.cs ===
//------------------------------------------------------------------------------
// <copyright file="VsToolboxService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;

using OleInterop = Microsoft.VisualStudio.OLE.Interop;
using BclComTypes = System.Runtime.InteropServices.ComTypes;

using IOleAdviseSink = Microsoft.VisualStudio.OLE.Interop.IAdviseSink;
using IBclAdviseSink = System.Runtime.InteropServices.ComTypes.IAdviseSink;

namespace Microsoft.VisualStudio.Shell.Ole2Bcl
{
    internal sealed class StructConverter
    {
        // Private constructor to avoid creation of instances of this class
        private StructConverter() { }

        ///////////////////////////////////////////////////////////////////////////////////
        // FORMATETC
        static internal OleInterop.FORMATETC BclFormatETC2Ole(ref BclComTypes.FORMATETC bclFormat)
        {
            OleInterop.FORMATETC oleFormat;
            oleFormat.cfFormat = (ushort)bclFormat.cfFormat;
            oleFormat.dwAspect = (uint)bclFormat.dwAspect;
            oleFormat.lindex = bclFormat.lindex;
            oleFormat.ptd = bclFormat.ptd;
            oleFormat.tymed = (uint)bclFormat.tymed;
            return oleFormat;
        }
        static internal BclComTypes.FORMATETC OleFormatETC2Bcl(ref OleInterop.FORMATETC oleFormat)
        {
            BclComTypes.FORMATETC bclFormat;
            bclFormat.cfFormat = (short)oleFormat.cfFormat;
            bclFormat.dwAspect = (BclComTypes.DVASPECT)oleFormat.dwAspect;
            bclFormat.lindex = oleFormat.lindex;
            bclFormat.ptd = oleFormat.ptd;
            bclFormat.tymed = (BclComTypes.TYMED)oleFormat.tymed;
            return bclFormat;
        }
        //                                                                       FORMATETC
        ///////////////////////////////////////////////////////////////////////////////////

        ///////////////////////////////////////////////////////////////////////////////////
        // STGMEDIUM
        static internal OleInterop.STGMEDIUM BclSTGMEDIUM2Ole(ref BclComTypes.STGMEDIUM bclMedium)
        {
            OleInterop.STGMEDIUM oleMedium;
            oleMedium.pUnkForRelease = bclMedium.pUnkForRelease;
            oleMedium.tymed = (uint)bclMedium.tymed;
            oleMedium.unionmember = bclMedium.unionmember;
            return oleMedium;
        }
        static internal BclComTypes.STGMEDIUM OleSTGMEDIUM2Bcl(ref OleInterop.STGMEDIUM oleMedium)
        {
            BclComTypes.STGMEDIUM bclMedium;
            bclMedium.pUnkForRelease = oleMedium.pUnkForRelease;
            bclMedium.tymed = (BclComTypes.TYMED)oleMedium.tymed;
            bclMedium.unionmember = oleMedium.unionmember;
            return bclMedium;
        }
        //                                                                      STGMEDIUM
        ///////////////////////////////////////////////////////////////////////////////////

        ///////////////////////////////////////////////////////////////////////////////////
        // STATDATA
        static internal OleInterop.STATDATA BclSTATDATA2Ole(ref BclComTypes.STATDATA bclData)
        {
            OleInterop.STATDATA oleData;
            if (null == bclData.advSink)
            {
                oleData.pAdvSink = null;
            }
            else
            {
                oleData.pAdvSink = bclData.advSink as OleInterop.IAdviseSink;
                if (null == oleData.pAdvSink)
                    oleData.pAdvSink = (new AdviseSink(bclData.advSink));
            }
            oleData.ADVF = (uint)bclData.advf;
            oleData.dwConnection = (uint)bclData.connection;
            oleData.FORMATETC = BclFormatETC2Ole(ref bclData.formatetc);
            return oleData;
        }
        static internal BclComTypes.STATDATA OleSTATDATA2Bcl(ref OleInterop.STATDATA oleData)
        {
            BclComTypes.STATDATA bclData;
            if (null == oleData.pAdvSink)
            {
                bclData.advSink = null;
            }
            else
            {
                bclData.advSink = oleData.pAdvSink as BclComTypes.IAdviseSink;
                if (null == bclData.advSink)
                    bclData.advSink = (BclComTypes.IAdviseSink)(new AdviseSink(oleData.pAdvSink));
            }
            bclData.advf = (BclComTypes.ADVF)oleData.ADVF;
            bclData.connection = (int)oleData.dwConnection;
            bclData.formatetc = OleFormatETC2Bcl(ref oleData.FORMATETC);
            return bclData;
        }
        //                                                                        STATDATA
        ///////////////////////////////////////////////////////////////////////////////////
    }

    internal sealed class AdviseSink : IOleAdviseSink, IBclAdviseSink
    {
        private IOleAdviseSink oleSink;
        private IBclAdviseSink bclSink;

        // This class in a converter and it doesn't make sense to build it
        // without an interface to convert, so we make the default constructor
        // private to avoid that the compiler build a public one for us.
        private AdviseSink()
        {
        }

        internal AdviseSink(IOleAdviseSink oleSink)
        {
            if (null == oleSink)
                throw new ArgumentNullException("Microsoft.VisualStudio.OLE.Interop.IAdviseSink");
            this.oleSink = oleSink;
            this.bclSink = oleSink as IBclAdviseSink;
        }

        internal AdviseSink(IBclAdviseSink bclSink)
        {
            if (null == bclSink)
                throw new ArgumentNullException("System.Runtime.InteropServices.ComTypes.IAdviseSink");
            this.oleSink = bclSink as IOleAdviseSink;
            this.bclSink = bclSink;
        }

        //////////////////////////////////////////////////////////////
        // OnClose
        //
        void IOleAdviseSink.OnClose()
        {
            if (null != oleSink)
            {
                oleSink.OnClose();
            }
            else
            {
                bclSink.OnClose();
            }
        }
        void IBclAdviseSink.OnClose()
        {
            ((IOleAdviseSink)this).OnClose();
        }
        //
        //////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////
        // OnDataChange
        //
        void IOleAdviseSink.OnDataChange(OleInterop.FORMATETC[] pFormatetc, OleInterop.STGMEDIUM[] pStgmed)
        {
            if (null != oleSink)
            {
                oleSink.OnDataChange(pFormatetc, pStgmed);
            }
            else
            {
                // In order to call the version of this interface defined in the BCL
                // each array must contain exactly one object.
                if ((null == pFormatetc) || (null == pStgmed))
                    throw new ArgumentNullException("");
                if ((1 != pFormatetc.Length) || (1 != pStgmed.Length))
                    throw new InvalidOperationException();

                // Convert the parameters
                BclComTypes.FORMATETC bclFormat = StructConverter.OleFormatETC2Bcl(ref pFormatetc[0]);
                BclComTypes.STGMEDIUM bclMedium = StructConverter.OleSTGMEDIUM2Bcl(ref pStgmed[0]);

                // Now we can call the method on the BCL interface
                bclSink.OnDataChange(ref bclFormat, ref bclMedium);

                // Now we have to copy the parameters back into the original structures.
                pFormatetc[0] = StructConverter.BclFormatETC2Ole(ref bclFormat);
                pStgmed[0] = StructConverter.BclSTGMEDIUM2Ole(ref bclMedium);
            }
        }
        void IBclAdviseSink.OnDataChange(ref BclComTypes.FORMATETC format, ref BclComTypes.STGMEDIUM stgmedium)
        {
            if (null != bclSink)
            {
                bclSink.OnDataChange(ref format, ref stgmedium);
            }
            else
            {
                // As in the previous case we have to copy the parameters.
                OleInterop.FORMATETC[] pFormatetc = new OleInterop.FORMATETC[1];
                pFormatetc[0] = StructConverter.BclFormatETC2Ole(ref format);

                OleInterop.STGMEDIUM[] pStgmed = new OleInterop.STGMEDIUM[1];
                pStgmed[0] = StructConverter.BclSTGMEDIUM2Ole(ref stgmedium);

                // Call the original interface.
                oleSink.OnDataChange(pFormatetc, pStgmed);
            }
        }
        //
        //////////////////////////////////////////////////////////////

        void IOleAdviseSink.OnRename(OleInterop.IMoniker pmk)
        {
            if (null != oleSink)
            {
                oleSink.OnRename(pmk);
            }
            else
            {
                // TODO: Use the IMoniker converter when ready.
                bclSink.OnRename(null);
            }
        }
        void IBclAdviseSink.OnRename(BclComTypes.IMoniker moniker)
        {
            if (null != bclSink)
            {
                bclSink.OnRename(moniker);
            }
            else
            {
                // TODO: Use the IMoniker converter when ready.
                oleSink.OnRename(null);
            }
        }
        //
        //////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////
        // OnSave
        //
        void IOleAdviseSink.OnSave()
        {
            if (null != oleSink)
            {
                oleSink.OnSave();
            }
            else
            {
                bclSink.OnSave();
            }
        }
        void IBclAdviseSink.OnSave()
        {
            ((IOleAdviseSink)this).OnSave();
        }
        //
        //////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////
        // OnViewChange
        //
        void IOleAdviseSink.OnViewChange(uint aspect, int index)
        {
            if (null != oleSink)
            {
                oleSink.OnViewChange(aspect, index);
            }
            else
            {
                bclSink.OnViewChange((int)aspect, index);
            }
        }
        void IBclAdviseSink.OnViewChange(int aspect, int index)
        {
            ((IOleAdviseSink)this).OnViewChange((uint)aspect, index);
        }
        //
        //////////////////////////////////////////////////////////////

    }

    internal sealed class EnumSTATDATA : OleInterop.IEnumSTATDATA, BclComTypes.IEnumSTATDATA
    {
        private OleInterop.IEnumSTATDATA oleEnum;
        private BclComTypes.IEnumSTATDATA bclEnum;

        private EnumSTATDATA() { }

        internal EnumSTATDATA(OleInterop.IEnumSTATDATA oleEnum)
        {
            if (null == oleEnum)
                throw new ArgumentNullException("Microsoft.VisualStudio.OLE.Interop.IEnumSTATDATA");
            this.oleEnum = oleEnum;
            this.bclEnum = oleEnum as BclComTypes.IEnumSTATDATA;
        }

        internal EnumSTATDATA(BclComTypes.IEnumSTATDATA bclEnum)
        {
            if (null == bclEnum)
                throw new ArgumentNullException("System.Runtime.InteropServices.ComTypes.IEnumSTATDATA");
            this.oleEnum = bclEnum as OleInterop.IEnumSTATDATA;
            this.bclEnum = bclEnum;
        }

        //////////////////////////////////////////////////////////////
        // Clone
        void OleInterop.IEnumSTATDATA.Clone(out OleInterop.IEnumSTATDATA ppEnum)
        {
            ppEnum = null;
            if (null != oleEnum)
            {
                oleEnum.Clone(out ppEnum);
            }
            else
            {
                BclComTypes.IEnumSTATDATA bclCloned;
                bclEnum.Clone(out bclCloned);
                ppEnum = bclCloned as OleInterop.IEnumSTATDATA;
                if (null == ppEnum)
                    ppEnum = (OleInterop.IEnumSTATDATA)(new EnumSTATDATA(bclCloned));
            }
        }
        void BclComTypes.IEnumSTATDATA.Clone(out BclComTypes.IEnumSTATDATA newEnum)
        {
            newEnum = null;
            if (null != bclEnum)
            {
                bclEnum.Clone(out newEnum);
            }
            else
            {
                OleInterop.IEnumSTATDATA oleCloned;
                oleEnum.Clone(out oleCloned);
                newEnum = oleCloned as BclComTypes.IEnumSTATDATA;
                if (null == newEnum)
                    newEnum = (BclComTypes.IEnumSTATDATA)(new EnumSTATDATA(oleCloned));
            }
        }
        //
        //////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////
        // Next
        int OleInterop.IEnumSTATDATA.Next(uint celt, OleInterop.STATDATA[] rgelt, out uint pceltFetched)
        {
            pceltFetched = 0;
            if (null != oleEnum)
            {
                return oleEnum.Next(celt, rgelt, out pceltFetched);
            }

            BclComTypes.STATDATA[] bclStat = new BclComTypes.STATDATA[celt];
            int[] fetched = { (int)pceltFetched };
            int hr = bclEnum.Next((int)celt, bclStat, fetched);
            if (NativeMethods.Failed(hr))
                return hr;
            pceltFetched = (uint)fetched[0];
            for (int i = 0; i < pceltFetched; i++)
            {
                rgelt[i] = StructConverter.BclSTATDATA2Ole(ref bclStat[i]);
            }
            return hr;
        }
        int BclComTypes.IEnumSTATDATA.Next(int celt, BclComTypes.STATDATA[] rgelt, int[] pceltFetched)
        {
            if (null != bclEnum)
            {
                return bclEnum.Next(celt, rgelt, pceltFetched);
            }

            OleInterop.STATDATA[] oleStat = new OleInterop.STATDATA[celt];
            uint fetched;
            int hr = oleEnum.Next((uint)celt, oleStat, out fetched);
            if (NativeMethods.Failed(hr))
                return hr;
            if (null != pceltFetched)
                pceltFetched[0] = (int)fetched;
            for (int i = 0; i < fetched; i++)
            {
                rgelt[i] = StructConverter.OleSTATDATA2Bcl(ref oleStat[i]);
            }
            return hr;
        }
        //
        //////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////
        // Reset
        int OleInterop.IEnumSTATDATA.Reset()
        {
            if (null != oleEnum)
                return oleEnum.Reset();
            return bclEnum.Reset();
        }
        int BclComTypes.IEnumSTATDATA.Reset()
        {
            if (null != bclEnum)
                return bclEnum.Reset();
            return oleEnum.Reset();
        }
        //
        //////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////
        // Skip
        int OleInterop.IEnumSTATDATA.Skip(uint celt)
        {
            if (null != oleEnum)
                return oleEnum.Skip(celt);
            return bclEnum.Skip((int)celt);
        }
        int BclComTypes.IEnumSTATDATA.Skip(int celt)
        {
            if (null != bclEnum)
                return bclEnum.Skip(celt);
            return oleEnum.Skip((uint)celt);
        }
        //
        //////////////////////////////////////////////////////////////
    }

    internal sealed class EnumFORMATETC : OleInterop.IEnumFORMATETC, BclComTypes.IEnumFORMATETC
    {
        private OleInterop.IEnumFORMATETC oleEnum;
        private BclComTypes.IEnumFORMATETC bclEnum;

        private EnumFORMATETC() { }

        internal EnumFORMATETC(OleInterop.IEnumFORMATETC oleEnum)
        {
            if (null == oleEnum)
                throw new ArgumentNullException("Microsoft.VisualStudio.OLE.Interop.IEnumFORMATETC");
            this.oleEnum = oleEnum;
            this.bclEnum = oleEnum as BclComTypes.IEnumFORMATETC;
        }

        internal EnumFORMATETC(BclComTypes.IEnumFORMATETC bclEnum)
        {
            if (null == bclEnum)
                throw new ArgumentNullException("System.Runtime.InteropServices.ComTypes.IEnumFORMATETC");
            this.oleEnum = bclEnum as OleInterop.IEnumFORMATETC;
            this.bclEnum = bclEnum;
        }

        //////////////////////////////////////////////////////////////
        // Clone
        void OleInterop.IEnumFORMATETC.Clone(out OleInterop.IEnumFORMATETC ppEnum)
        {
            ppEnum = null;
            if (null != oleEnum)
            {
                oleEnum.Clone(out ppEnum);
            }
            else
            {
                BclComTypes.IEnumFORMATETC bclCloned;
                bclEnum.Clone(out bclCloned);
                ppEnum = bclCloned as OleInterop.IEnumFORMATETC;
                if (null == ppEnum)
                    ppEnum = (OleInterop.IEnumFORMATETC)(new EnumFORMATETC(bclCloned));
            }
        }
        void BclComTypes.IEnumFORMATETC.Clone(out BclComTypes.IEnumFORMATETC newEnum)
        {
            newEnum = null;
            if (null != bclEnum)
            {
                bclEnum.Clone(out newEnum);
            }
            else
            {
                OleInterop.IEnumFORMATETC oleCloned;
                oleEnum.Clone(out oleCloned);
                newEnum = oleCloned as BclComTypes.IEnumFORMATETC;
                if (null == newEnum)
                    newEnum = (BclComTypes.IEnumFORMATETC)(new EnumFORMATETC(oleCloned));
            }
        }
        //
        //////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////
        // Next
        int OleInterop.IEnumFORMATETC.Next(uint celt, OleInterop.FORMATETC[] rgelt, uint[] pceltFetched)
        {
            if (null != oleEnum)
            {
                return oleEnum.Next(celt, rgelt, pceltFetched);
            }

            BclComTypes.FORMATETC[] bclStat = new BclComTypes.FORMATETC[celt];
            int[] fetched = new int[1];
            int hr = bclEnum.Next((int)celt, bclStat, fetched);
            if (NativeMethods.Failed(hr))
                return hr;
            if (null != pceltFetched)
                pceltFetched[0] = (uint)fetched[0];
            for (int i = 0; i < fetched[0]; i++)
            {
                rgelt[i] = StructConverter.BclFormatETC2Ole(ref bclStat[i]);
            }
            return hr;
        }
        int BclComTypes.IEnumFORMATETC.Next(int celt, BclComTypes.FORMATETC[] rgelt, int[] pceltFetched)
        {
            if (null != bclEnum)
            {
                return bclEnum.Next(celt, rgelt, pceltFetched);
            }

            OleInterop.FORMATETC[] oleStat = new OleInterop.FORMATETC[celt];
            uint[] fetched = new uint[1];
            int hr = oleEnum.Next((uint)celt, oleStat, fetched);
            if (NativeMethods.Failed(hr))
                return hr;
            if (null != pceltFetched)
                pceltFetched[0] = (int)fetched[0];
            for (uint i = 0; i < fetched[0]; i++)
            {
                rgelt[i] = StructConverter.OleFormatETC2Bcl(ref oleStat[i]);
            }
            return hr;
        }
        //
        //////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////
        // Reset
        int OleInterop.IEnumFORMATETC.Reset()
        {
            if (null != oleEnum)
                return oleEnum.Reset();
            return bclEnum.Reset();
        }
        int BclComTypes.IEnumFORMATETC.Reset()
        {
            if (null != bclEnum)
                return bclEnum.Reset();
            return oleEnum.Reset();
        }
        //
        //////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////
        // Skip
        int OleInterop.IEnumFORMATETC.Skip(uint celt)
        {
            if (null != oleEnum)
                return oleEnum.Skip(celt);
            return bclEnum.Skip((int)celt);
        }
        int BclComTypes.IEnumFORMATETC.Skip(int celt)
        {
            if (null != bclEnum)
                return bclEnum.Skip(celt);
            return oleEnum.Skip((uint)celt);
        }
        //
        //////////////////////////////////////////////////////////////
    }

    internal sealed class Ole2BclDataObject : OleInterop.IDataObject, BclComTypes.IDataObject
    {
        private OleInterop.IDataObject oleData;
        private BclComTypes.IDataObject bclData;

        // Private default constructor: it is not allow to build instances of this class without
        // providing an interface to convert.
        private Ole2BclDataObject() { }

        internal Ole2BclDataObject(OleInterop.IDataObject oleData)
        {
            if (null == oleData)
                throw new ArgumentNullException("Microsoft.VisualStudio.OLE.Interop.IDataObject");
            this.oleData = oleData;
            //this.bclData = oleData as BclComTypes.IDataObject;
            this.bclData = null;
        }

        internal Ole2BclDataObject(BclComTypes.IDataObject bclData)
        {
            if (null == bclData)
                throw new ArgumentNullException("System.Runtime.InteropServices.ComTypes.IDataObject");
            //this.oleData = bclData as OleInterop.IDataObject;
            this.oleData = null;
            this.bclData = bclData;
        }

        #region OleInterop.IDataObject Members

        int OleInterop.IDataObject.DAdvise(OleInterop.FORMATETC[] pFormatetc, uint ADVF, OleInterop.IAdviseSink pAdvSink, out uint pdwConnection)
        {
            if (null != oleData)
                return oleData.DAdvise(pFormatetc, ADVF, pAdvSink, out pdwConnection);

            // We have to call the method in the BCL version of the interface, so we need to
            // convert the parameters to the other type of structure.

            // As first make sure that the array contains exactly one element.
            if ((null == pFormatetc) || (pFormatetc.Length != 1))
                throw new ArgumentException();

            // Now convert the patameters
            BclComTypes.FORMATETC bclFormat = StructConverter.OleFormatETC2Bcl(ref pFormatetc[0]);
            BclComTypes.IAdviseSink bclSink = pAdvSink as BclComTypes.IAdviseSink;
            if (null == bclSink)
                bclSink = new AdviseSink(pAdvSink);

            int connection;
            int hr = bclData.DAdvise(ref bclFormat, (BclComTypes.ADVF)(ADVF), bclSink, out connection);
            pdwConnection = (uint)connection;
            return hr;
        }

        void OleInterop.IDataObject.DUnadvise(uint dwConnection)
        {
            if (null != oleData)
                oleData.DUnadvise(dwConnection);
            else
                bclData.DUnadvise((int)dwConnection);
        }

        int OleInterop.IDataObject.EnumDAdvise(out OleInterop.IEnumSTATDATA ppenumAdvise)
        {
            if (null != oleData)
                return oleData.EnumDAdvise(out ppenumAdvise);

            // Call the BCL version of the method
            BclComTypes.IEnumSTATDATA bclEnum;
            int hr = bclData.EnumDAdvise(out bclEnum);
            NativeMethods.ThrowOnFailure(hr);
            if (null == bclEnum)
            {
                ppenumAdvise = null;
            }
            else
            {
                ppenumAdvise = bclEnum as OleInterop.IEnumSTATDATA;
                if (null == ppenumAdvise)
                    ppenumAdvise = (OleInterop.IEnumSTATDATA)(new EnumSTATDATA(bclEnum));
            }
            return hr;
        }

        int OleInterop.IDataObject.EnumFormatEtc(uint dwDirection, out OleInterop.IEnumFORMATETC ppenumFormatEtc)
        {
            if (null != oleData)
                return oleData.EnumFormatEtc(dwDirection, out ppenumFormatEtc);

            BclComTypes.IEnumFORMATETC bclEnum = bclData.EnumFormatEtc((BclComTypes.DATADIR)dwDirection);
            if (null == bclEnum)
            {
                ppenumFormatEtc = null;
            }
            else
            {
                ppenumFormatEtc = bclEnum as OleInterop.IEnumFORMATETC;
                if (null == ppenumFormatEtc)
                    ppenumFormatEtc = (OleInterop.IEnumFORMATETC)(new EnumFORMATETC(bclEnum));
            }
            return NativeMethods.S_OK;
        }

        int OleInterop.IDataObject.GetCanonicalFormatEtc(OleInterop.FORMATETC[] pformatectIn, OleInterop.FORMATETC[] pformatetcOut)
        {
            if (null != oleData)
                return oleData.GetCanonicalFormatEtc(pformatectIn, pformatetcOut);

            // Check that the arrays are not null and with only one element.
            if ((null == pformatectIn) || (pformatectIn.Length != 1) ||
                 (null == pformatetcOut) || (pformatetcOut.Length != 1))
                throw new ArgumentException();

            BclComTypes.FORMATETC bclFormatIn = StructConverter.OleFormatETC2Bcl(ref pformatectIn[0]);
            BclComTypes.FORMATETC bclFormatOut;
            int hr = bclData.GetCanonicalFormatEtc(ref bclFormatIn, out bclFormatOut);
            NativeMethods.ThrowOnFailure(hr);
            pformatetcOut[0] = StructConverter.BclFormatETC2Ole(ref bclFormatOut);
            return hr;
        }

        void OleInterop.IDataObject.GetData(OleInterop.FORMATETC[] pformatetcIn, OleInterop.STGMEDIUM[] pRemoteMedium)
        {
            if (null != oleData)
            {
                oleData.GetData(pformatetcIn, pRemoteMedium);
                return;
            }

            // Check that the arrays are not null and with only one element.
            if ((null == pformatetcIn) || (pformatetcIn.Length != 1) ||
                 (null == pRemoteMedium) || (pRemoteMedium.Length != 1))
                throw new ArgumentException();

            // Call the method on the BCL interface
            BclComTypes.FORMATETC bclFormat = StructConverter.OleFormatETC2Bcl(ref pformatetcIn[0]);
            BclComTypes.STGMEDIUM bclMedium;
            bclData.GetData(ref bclFormat, out bclMedium);
            pRemoteMedium[0] = StructConverter.BclSTGMEDIUM2Ole(ref bclMedium);
        }

        void OleInterop.IDataObject.GetDataHere(OleInterop.FORMATETC[] pFormatetc, OleInterop.STGMEDIUM[] pRemoteMedium)
        {
            if (null != oleData)
            {
                oleData.GetDataHere(pFormatetc, pRemoteMedium);
                return;
            }

            // Check that the arrays are not null and with only one element.
            if ((null == pFormatetc) || (pFormatetc.Length != 1) ||
                 (null == pRemoteMedium) || (pRemoteMedium.Length != 1))
                throw new ArgumentException();

            // Call the method on the BCL interface
            BclComTypes.FORMATETC bclFormat = StructConverter.OleFormatETC2Bcl(ref pFormatetc[0]);
            BclComTypes.STGMEDIUM bclMedium = StructConverter.OleSTGMEDIUM2Bcl(ref pRemoteMedium[0]);
            bclData.GetDataHere(ref bclFormat, ref bclMedium);
            pRemoteMedium[0] = StructConverter.BclSTGMEDIUM2Ole(ref bclMedium);
        }

        int OleInterop.IDataObject.QueryGetData(OleInterop.FORMATETC[] pFormatetc)
        {
            if (null != oleData)
                return oleData.QueryGetData(pFormatetc);

            if ((null == pFormatetc) || (1 != pFormatetc.Length))
                throw new ArgumentException();

            BclComTypes.FORMATETC bclFormat = StructConverter.OleFormatETC2Bcl(ref pFormatetc[0]);
            return bclData.QueryGetData(ref bclFormat);
        }

        void OleInterop.IDataObject.SetData(OleInterop.FORMATETC[] pFormatetc, OleInterop.STGMEDIUM[] pmedium, int fRelease)
        {
            if (null != oleData)
            {
                oleData.SetData(pFormatetc, pmedium, fRelease);
                return;
            }

            if ((null == pFormatetc) || (1 != pFormatetc.Length) ||
                (null == pmedium) || (1 != pmedium.Length))
                throw new ArgumentException();

            BclComTypes.FORMATETC bclFormat = StructConverter.OleFormatETC2Bcl(ref pFormatetc[0]);
            BclComTypes.STGMEDIUM bclMedium = StructConverter.OleSTGMEDIUM2Bcl(ref pmedium[0]);
            bclData.SetData(ref bclFormat, ref bclMedium, (fRelease == 0) ? false : true);
        }

        #endregion

        #region IDataObject Members

        int BclComTypes.IDataObject.DAdvise(ref BclComTypes.FORMATETC pFormatetc, BclComTypes.ADVF advf, BclComTypes.IAdviseSink adviseSink, out int connection)
        {
            if (null != bclData)
                return bclData.DAdvise(ref pFormatetc, advf, adviseSink, out connection);

            OleInterop.FORMATETC[] oleFormat = new OleInterop.FORMATETC[1];
            oleFormat[0] = StructConverter.BclFormatETC2Ole(ref pFormatetc);
            uint result;
            OleInterop.IAdviseSink oleSink = adviseSink as OleInterop.IAdviseSink;
            if (null == oleSink)
                oleSink = (OleInterop.IAdviseSink)(new AdviseSink(adviseSink));
            int hr = oleData.DAdvise(oleFormat, (uint)advf, oleSink, out result);
            NativeMethods.ThrowOnFailure(hr);
            connection = (int)result;
            return hr;
        }

        void BclComTypes.IDataObject.DUnadvise(int connection)
        {
            if (bclData != null)
                bclData.DUnadvise(connection);
            else
                oleData.DUnadvise((uint)connection);
        }

        int BclComTypes.IDataObject.EnumDAdvise(out BclComTypes.IEnumSTATDATA enumAdvise)
        {
            if (null != bclData)
                return bclData.EnumDAdvise(out enumAdvise);

            OleInterop.IEnumSTATDATA oleEnum;
            int hr = oleData.EnumDAdvise(out oleEnum);
            NativeMethods.ThrowOnFailure(hr);
            if (null == oleEnum)
            {
                enumAdvise = null;
            }
            else
            {
                enumAdvise = oleEnum as BclComTypes.IEnumSTATDATA;
                if (null == enumAdvise)
                    enumAdvise = (BclComTypes.IEnumSTATDATA)(new EnumSTATDATA(oleEnum));
            }
            return hr;
        }

        BclComTypes.IEnumFORMATETC BclComTypes.IDataObject.EnumFormatEtc(BclComTypes.DATADIR direction)
        {
            if (bclData != null)
                return bclData.EnumFormatEtc(direction);

            OleInterop.IEnumFORMATETC oleEnum;
            NativeMethods.ThrowOnFailure(oleData.EnumFormatEtc((uint)direction, out oleEnum));
            if (null == oleEnum)
                return null;
            BclComTypes.IEnumFORMATETC bclEnum = oleEnum as BclComTypes.IEnumFORMATETC;
            if (null == bclEnum)
                bclEnum = (BclComTypes.IEnumFORMATETC)(new EnumFORMATETC(oleEnum));
            return bclEnum;
        }

        int BclComTypes.IDataObject.GetCanonicalFormatEtc(ref BclComTypes.FORMATETC formatIn, out BclComTypes.FORMATETC formatOut)
        {
            if (null != bclData)
                return bclData.GetCanonicalFormatEtc(ref formatIn, out formatOut);

            OleInterop.FORMATETC[] oleFormatIn = new OleInterop.FORMATETC[1];
            OleInterop.FORMATETC[] oleFormatOut = new OleInterop.FORMATETC[1];
            oleFormatIn[0] = StructConverter.BclFormatETC2Ole(ref formatIn);
            int hr = oleData.GetCanonicalFormatEtc(oleFormatIn, oleFormatOut);
            NativeMethods.ThrowOnFailure(hr);
            formatOut = StructConverter.OleFormatETC2Bcl(ref oleFormatOut[0]);
            return hr;
        }

        void BclComTypes.IDataObject.GetData(ref BclComTypes.FORMATETC format, out BclComTypes.STGMEDIUM medium)
        {
            if (null != bclData)
            {
                bclData.GetData(ref format, out medium);
                return;
            }

            OleInterop.FORMATETC[] oleFormat = new OleInterop.FORMATETC[1];
            oleFormat[0] = StructConverter.BclFormatETC2Ole(ref format);
            OleInterop.STGMEDIUM[] oleMedium = new OleInterop.STGMEDIUM[1];
            oleData.GetData(oleFormat, oleMedium);
            medium = StructConverter.OleSTGMEDIUM2Bcl(ref oleMedium[0]);
        }

        void BclComTypes.IDataObject.GetDataHere(ref BclComTypes.FORMATETC format, ref BclComTypes.STGMEDIUM medium)
        {
            if (null != bclData)
            {
                bclData.GetDataHere(ref format, ref medium);
                return;
            }

            OleInterop.FORMATETC[] oleFormat = new OleInterop.FORMATETC[1];
            oleFormat[0] = StructConverter.BclFormatETC2Ole(ref format);
            OleInterop.STGMEDIUM[] oleMedium = new OleInterop.STGMEDIUM[1];
            oleMedium[0] = StructConverter.BclSTGMEDIUM2Ole(ref medium);
            oleData.GetDataHere(oleFormat, oleMedium);
            medium = StructConverter.OleSTGMEDIUM2Bcl(ref oleMedium[0]);
        }

        int BclComTypes.IDataObject.QueryGetData(ref BclComTypes.FORMATETC format)
        {
            if (null != bclData)
                return bclData.QueryGetData(ref format);

            OleInterop.FORMATETC[] oleFormat = new OleInterop.FORMATETC[1];
            oleFormat[0] = StructConverter.BclFormatETC2Ole(ref format);
            return oleData.QueryGetData(oleFormat);
        }

        void BclComTypes.IDataObject.SetData(ref BclComTypes.FORMATETC formatIn, ref BclComTypes.STGMEDIUM medium, bool release)
        {
            if (null != bclData)
            {
                bclData.SetData(ref formatIn, ref medium, release);
                return;
            }

            OleInterop.FORMATETC[] oleFormat = new OleInterop.FORMATETC[1];
            oleFormat[0] = StructConverter.BclFormatETC2Ole(ref formatIn);
            OleInterop.STGMEDIUM[] oleMedium = new OleInterop.STGMEDIUM[1];
            oleMedium[0] = StructConverter.BclSTGMEDIUM2Ole(ref medium);
            oleData.SetData(oleFormat, oleMedium, release ? 1 : 0);
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\ProvideEditorExtensionAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideEditorExtensionAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.IO;
    using System.Globalization;


    /// <include file='doc\ProvideEditorExtensionAttribute.uex' path='docs/doc[@for="ProvideEditorExtensionAttribute"]' />
    /// <devdoc>
    ///     This attribute associates a file extension to a given editor factory.  
    ///     The editor factory may be specified as either a GUID or a type and 
    ///     is placed on a package.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideEditorExtensionAttribute : RegistrationAttribute {

        private Guid factory;
        private string extension;
        private int priority;
        private Guid project;
        private string templateDir;
        private int resId;
        private bool editorFactoryNotify;
        private string editorName;
        
        /// <include file='doc\ProvideEditorExtensionAttribute.uex' path='docs/doc[@for="ProvideEditorExtensionAttribute.ProvideEditorExtensionAttribute"]' />
        /// <devdoc>
        ///     Creates a new attribute.
        /// </devdoc>
        public ProvideEditorExtensionAttribute (object factoryType, string extension, int priority) {

            if (!extension.StartsWith(".", StringComparison.OrdinalIgnoreCase)) {
                throw new ArgumentException(string.Format(Resources.Culture, Resources.Attributes_ExtensionNeedsDot, extension));
            }

            // figure out what type of object they passed in and get the GUID from it
            if (factoryType is string)
                this.factory = new Guid((string)factoryType);
            else if (factoryType is Type)
                this.factory = ((Type)factoryType).GUID;
            else if (factoryType is Guid)
                this.factory = (Guid)factoryType;
            else
                throw new ArgumentException(string.Format(Resources.Culture, Resources.Attributes_InvalidFactoryType, factoryType));

            this.extension = extension;
            this.priority = priority;
            this.project = Guid.Empty;
            this.templateDir = "";
            this.resId = 0;
            this.editorFactoryNotify = false;
        }
        
        /// <include file='doc\ProvideEditorExtensionAttribute.uex' path='docs/doc[@for="ProvideEditorExtensionAttribute.Extension"]' />
        /// <devdoc>
        ///     The file extension of the file.
        /// </devdoc>
        public string Extension {
            get {
                return extension;
            }
        }
        
        /// <include file='doc\ProvideEditorExtensionAttribute.uex' path='docs/doc[@for="ProvideEditorExtensionAttribute.Factory"]' />
        /// <devdoc>
        ///     The editor factory guid.
        /// </devdoc>
        public Guid Factory {
            get {
                return factory;
            }
        }
        
        /// <include file='doc\ProvideEditorExtensionAttribute.uex' path='docs/doc[@for="ProvideEditorExtensionAttribute.Priority"]' />
        /// <devdoc>
        ///     The priority of this extension registration.
        /// </devdoc>
        public int Priority {
            get {
                return priority;
            }
        }

        /// <include file='doc\ProvideEditorExtensionAttribute.uex' path='docs/doc[@for="ProvideEditorExtensionAttribute.ProjectGuid"]/*' />
        public string ProjectGuid {
            set { project = new System.Guid(value); }
            get { return project.ToString(); }
        }

        /// <include file='doc\ProvideEditorExtensionAttribute.uex' path='docs/doc[@for="ProvideEditorExtensionAttribute.EditorFactoryNotify"]/*' />
        public bool EditorFactoryNotify {
            get { return this.editorFactoryNotify; }
            set { this.editorFactoryNotify = value; }
        }

        /// <include file='doc\ProvideEditorExtensionAttribute.uex' path='docs/doc[@for="ProvideEditorExtensionAttribute.TemplateDir"]/*' />
        public string TemplateDir {
            get { return templateDir; }
            set { templateDir = value; }
        }

        /// <include file='doc\ProvideEditorExtensionAttribute.uex' path='docs/doc[@for="ProvideEditorExtensionAttribute.NameResourceID"]/*' />
        public int NameResourceID {
            get { return resId; }
            set { resId = value; }
        }

        /// <include file='doc\ProvideEditorExtensionAttribute.uex' path='docs/doc[@for="ProvideEditorExtensionAttribute.DefaultName"]/*' />
        public string DefaultName {
            get { return editorName; }
            set { editorName = value; }
        }

        /// <summary>
        ///        The reg key name of this extension.
        /// </summary>
        private string RegKeyName 
        {
            get 
            {
                return string.Format(CultureInfo.InvariantCulture, "Editors\\{0}", Factory.ToString("B"));
            }
        }

        /// <summary>
        ///        The reg key name of the project.
        /// </summary>
        private string ProjectRegKeyName(RegistrationContext context) 
        {
            return string.Format(CultureInfo.InvariantCulture,
                                 "Projects\\{0}\\AddItemTemplates\\TemplateDirs\\{1}",
                                 project.ToString("B"),
                                 context.ComponentType.GUID.ToString("B"));
        }

        private string EditorFactoryNotifyKey {
            get { return string.Format(CultureInfo.InvariantCulture, "Projects\\{0}\\FileExtensions\\{1}",
                                       project.ToString("B"),
                                       Extension);
            }
        }

        /// <include file='doc\ProvideEditorExtensionAttribute.uex' path='docs/doc[@for="Register"]' />
        /// <devdoc>
        ///     Called to register this attribute with the given context.  The context
        ///     contains the location where the registration inforomation should be placed.
        ///     it also contains such as the type being registered, and path information.
        ///
        ///     This method is called both for registration and unregistration.  The difference is
        ///     that unregistering just uses a hive that reverses the changes applied to it.
        /// </devdoc>
        public override void Register(RegistrationContext context) {
            context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyEditorExtension, Extension, Factory.ToString("B")));

            using (Key editorKey = context.CreateKey(RegKeyName))
            {
                if (!string.IsNullOrEmpty(DefaultName))
                {
                    editorKey.SetValue(null, DefaultName);
                }
                if (0 != resId)
                    editorKey.SetValue("DisplayName", "#" + resId.ToString(CultureInfo.InvariantCulture));
                editorKey.SetValue("Package", context.ComponentType.GUID.ToString("B"));
            }

            using (Key extensionKey = context.CreateKey(RegKeyName + "\\Extensions"))
            {
                extensionKey.SetValue(Extension.Substring(1), Priority);
            }

            // Build the path of the registry key for the "Add file to project" entry
            if (project != Guid.Empty)
            {
                string prjRegKey = ProjectRegKeyName(context) + "\\/1";
                using (Key projectKey = context.CreateKey( prjRegKey ))
                {
                    if (0 != resId)
                        projectKey.SetValue("", "#" + resId.ToString(CultureInfo.InvariantCulture));
                    if (templateDir.Length != 0)
                    {
                        Uri url = new Uri(context.ComponentType.Assembly.CodeBase);
                        string templates = url.LocalPath;
                        templates = System.IO.Path.Combine(System.IO.Path.GetDirectoryName(templates), templateDir);
                        templates = context.EscapePath( System.IO.Path.GetFullPath(templates) );
                        projectKey.SetValue("TemplatesDir", templates);
                    }
                    projectKey.SetValue("SortPriority", Priority);
                }
            }

            // Register the EditorFactoryNotify
            if ( EditorFactoryNotify )
            {
                // The IVsEditorFactoryNotify interface is called by the project system, so it doesn't make sense to
                // register it if there is no project associated to this editor.
                if (project == Guid.Empty)
                    throw new ArgumentException(Resources.Attributes_NoPrjForEditorFactoryNotify);

                // Create the registry key
                using (Key edtFactoryNotifyKey = context.CreateKey(EditorFactoryNotifyKey))
                {
                    edtFactoryNotifyKey.SetValue("EditorFactoryNotify", Factory.ToString("B"));
                }
            }
        }

        /// <include file='doc\ProvideEditorExtensionAttribute.uex' path='docs/doc[@for="Unregister"]' />
        /// <devdoc>
        /// Unregister this editor.
        /// </devdoc>
        /// <param name="context"></param>
        public override void Unregister(RegistrationContext context)
        {
            context.RemoveKey(RegKeyName);
            if (project != Guid.Empty)
            {
                context.RemoveKey(ProjectRegKeyName(context));
                if (EditorFactoryNotify)
                    context.RemoveKey(EditorFactoryNotifyKey);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\ProvideAutoLoadAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright from='2003' to='2004' company='Microsoft Corporation'>           
//  Copyright (c) Microsoft Corporation, All rights reserved.             
//  This code sample is provided "AS IS" without warranty of any kind, 
//  it is not recommended for use in a production environment.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.Globalization;

    /// <summary>
    ///     This attribute registers the package as an extender.  The GUID passed in determines
    ///     what is being extended. The attributes on a package do not control the behavior of
    ///     the package, but they can be used by registration tools to register the proper
    ///     information with Visual Studio.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideAutoLoadAttribute : RegistrationAttribute {

		private Guid loadGuid = Guid.Empty;

		/// <summary>
		///     Specify that the package should get loaded when this context is active.
		/// </summary>
		/// <param name="cmdUiContextGuid">Context which should trigger the loading of your package.</param>
		public ProvideAutoLoadAttribute(string cmdUiContextGuid) 
		{
			loadGuid = new Guid(cmdUiContextGuid);
		}

		/// <summary>
		/// Context Guid which triggers the loading of the package.
		/// </summary>
		public Guid LoadGuid
		{
			get
			{
				return loadGuid;
			}
		}

		/// <summary>
		///		The reg key name of this AutoLoad.
		/// </summary>
		private string RegKeyName 
		{
			get 
			{
				return string.Format(CultureInfo.InvariantCulture, "AutoLoadPackages\\{0}", loadGuid.ToString("B"));
			}
		}

		/// <summary>
		///     Called to register this attribute with the given context.  The context
		///     contains the location where the registration information should be placed.
		///     it also contains such as the type being registered, and path information.
		/// </summary>
		public override void Register(RegistrationContext context) 
		{
			context.Log.WriteLine(string.Format(Resources.Culture, Resources.Reg_NotifyAutoLoad, loadGuid.ToString("B")));

			using (Key childKey = context.CreateKey(RegKeyName))
                        {
			    childKey.SetValue(context.ComponentType.GUID.ToString("B"), 0);
			}
		}

		/// <summary>
		/// Unregister this AutoLoad specification.
		/// </summary>
		public override void Unregister(RegistrationContext context)
		{
			context.RemoveValue(RegKeyName, context.ComponentType.GUID.ToString("B"));
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell100\ProvideEditorFactoryAttribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvideEditorFactoryAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualStudio.Shell {

    using System;
    using System.ComponentModel;
    using System.Globalization;
    using Microsoft.VisualStudio.Shell.Interop;

    /// <include file='doc\ProvideEditorFactoryAttribute.uex' path='docs/doc[@for="ProvideEditorFactoryAttribute"]' />
    /// <devdoc>
    ///     This attribute declares that a package offers an editor factory.  A single 
    ///     package can provide multiple editor factories.  If a package declares that 
    ///     it provides an editor factory, it should create the factory and offer it 
    ///     to Visual Studio in the Initialize method of Package.
    /// </devdoc>
    [CLSCompliant(false)]
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true)]
    public sealed class ProvideEditorFactoryAttribute : RegistrationAttribute {

        private Type    _factoryType;
        private sh