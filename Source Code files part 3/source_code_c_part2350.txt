 open the DVD drive
	if ((NtStatus = WriteSMBusValue(0x20, 0x0C, FALSE, 0x00)) != STATUS_SUCCESS)
	{
//		err_Write(_T("DVD Tray Operation"), NtStatus); 
//		return;
	}

	// Wait for the tray to start opening
	for (i = 0; i < NumLoops; i++)
	{
		if ((NtStatus = ReadSMBusValue(0x20, 0x03, FALSE, &uDataValue)) != STATUS_SUCCESS)
		{
//			err_Read(_T("DVD TrayState"), NtStatus); 
//			return;
		}
		if (uDataValue == 0x31)  // The opening state
			break;
		Sleep(DVD_DELAY_BEWTEEN_POLLS);
	}
	if (i == NumLoops)
	{
//		err_DVDTrayNotOpen();
//		return;
	}
	
	// Issue a tray close Command to close the DVD drive
	if ((NtStatus = WriteSMBusValue(0x20, 0x0C, FALSE, 0x01)) != STATUS_SUCCESS)
	{
//		err_Write(_T("DVD Tray Operation"), NtStatus); 
//		return;
	}

	// Shutdown the system by writing 0x80 to the SMC System Reset Register
	NtStatus = WriteSMBusValue(0x20, 0x02, FALSE, 0x80);
	if(NtStatus != STATUS_SUCCESS)
	{
		// Again, don't report an error because no one is listening
//		err_Reset(NtStatus);
//		return;
	}
	Sleep(INFINITE);
} // end IMPLEMENT_TESTUNLOCKED (SMC, DVDSpinDownUtility, 19)

IMPLEMENT_TESTUNLOCKED (SMC, DVDOpenCloseMediaDetectTest, 20)
{
	#define DVD_DELAY_BEWTEEN_POLLS 20  // Number of milliseconds to sleep between polls of SMC registers
	ULONG uDataValue, i, NumLoops; 
	DWORD dwMediaDetectNumLoops;

	NumLoops = DVD_TIMEOUT_BETWEEN_OPERATIONS/DVD_DELAY_BEWTEEN_POLLS;
	dwMediaDetectNumLoops = dwDVDMediaDetectTimeout/DVD_DELAY_BEWTEEN_POLLS;
	// Wait for detection of media in the DVD drive
	for (i = 0; i < NumLoops; i++)
	{
		if ((NtStatus = ReadSMBusValue(0x20, 0x03, FALSE, &uDataValue)) != STATUS_SUCCESS)
		{
			err_Read(_T("DVD TrayState"), NtStatus); 
			return;
		}
		if (uDataValue == 0x60)  // Media is detected with the tray closed
			break;
		Sleep(DVD_DELAY_BEWTEEN_POLLS);
	}
	if (i == NumLoops)
	{
		err_NoDVDMediaDetected();
		return;
	}

	// Issue an Eject Command to open the DVD drive
	if ((NtStatus = WriteSMBusValue(0x20, 0x0C, FALSE, 0x00)) != STATUS_SUCCESS)
	{
		err_Write(_T("DVD Tray Operation"), NtStatus); 
		return;
	}

	// Wait for the tray to start opening
	for (i = 0; i < NumLoops; i++)
	{
		if ((NtStatus = ReadSMBusValue(0x20, 0x03, FALSE, &uDataValue)) != STATUS_SUCCESS)
		{
			err_Read(_T("DVD TrayState"), NtStatus); 
			return;
		}
		if ((uDataValue == 0x31) || (uDataValue == 0x10))  // The opening or the open state
			break;
		Sleep(DVD_DELAY_BEWTEEN_POLLS);
	}
	if (i == NumLoops)
	{
		err_DVDTrayNotOpen();
		return;
	}
	
	// Issue a tray close Command to close the DVD drive
	if ((NtStatus = WriteSMBusValue(0x20, 0x0C, FALSE, 0x01)) != STATUS_SUCCESS)
	{
		err_Write(_T("DVD Tray Operation"), NtStatus); 
		return;
	}
	// Wait for tray closed media detected or tray closed no media detected state to be indicated
	for (i = 0; i < dwMediaDetectNumLoops; i++)
	{
		if ((NtStatus = ReadSMBusValue(0x20, 0x03, FALSE, &uDataValue)) != STATUS_SUCCESS)
		{
			err_Read(_T("DVD TrayState"), NtStatus); 
			return;
		}
		if (uDataValue == 0x60) // The tray is closed and media is detected
			break;
		Sleep(DVD_DELAY_BEWTEEN_POLLS);
	}
	if (i == dwMediaDetectNumLoops)
	{
		err_NoDVDMediaDetected();
		return;
	}
	return;
} // end IMPLEMENT_TESTUNLOCKED (SMC, DVDOpenCloseMediaDetectTest, 20)

void CXModuleSMC::vNewSeed(UINT *pSeed)
{
	SYSTEMTIME systimeSeed;
	FILETIME filetimeSeed;

	GetSystemTime(&systimeSeed);
	SystemTimeToFileTime(&systimeSeed, &filetimeSeed);
	*pSeed = (UINT)filetimeSeed.dwLowDateTime;

	return;
}

DWORD CXModuleSMC::random(UINT *pScratch)
{
	DWORD ret;
	ret  = (*pScratch = *pScratch * 214013L + 2531011L) >> 16;
	ret |= (*pScratch = *pScratch * 214013L + 2531011L) & 0xFFFF0000;
	return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xtool\av.h ===
/*--

Copyright (c) Microsoft Corporation

Module Name:

    av.h

Abstract:

    This module contains the public data structures and procedure
    prototypes to identify AV packs and program TV encoder

--*/

#ifndef _AV_H
#define _AV_H

#if !defined(_NTSYSTEM_)
#define NTKERNELAVAPI DECLSPEC_IMPORT
#else
#define NTKERNELAVAPI
#endif

//
// AV pack identifiers
//
#define AV_PACK_NONE                      0x00000000

#define AV_PACK_STANDARD                  0x00000001
#define AV_PACK_RFU                       0x00000002
#define AV_PACK_SCART                     0x00000003
#define AV_PACK_HDTV                      0x00000004
#define AV_PACK_VGA                       0x00000005
#define AV_PACK_SVIDEO                    0x00000006
#define AV_PACK_MAX                       0x00000007

#define AV_PACK_MASK                      0x000000FF

//
// AV_ region types
//
#define AV_STANDARD_NTSC_M                0x00000100
#define AV_STANDARD_NTSC_J                0x00000200
#define AV_STANDARD_PAL_I                 0x00000300
#define AV_STANDARD_PAL_M                 0x00000400
#define AV_STANDARD_MAX                   0x00000500

#define AV_STANDARD_MASK                  0x0000FF00
#define AV_STANDARD_BIT_SHIFT             8

// Allows 16:9 for all SDTV and DTV modes.  HDTV 
// modes (720p and 1080i) are assumed to support 16:9.
//
#define AV_FLAGS_WIDESCREEN               0x00010000
#define AV_FLAGS_LETTERBOX                0x00100000

#define AV_ASPECT_RATIO_MASK              (AV_FLAGS_WIDESCREEN | AV_FLAGS_LETTERBOX)

// 480i support is assumed.
#define AV_FLAGS_HDTV_480i                0x00000000
#define AV_FLAGS_HDTV_720p                0x00020000
#define AV_FLAGS_HDTV_1080i               0x00040000
#define AV_FLAGS_HDTV_480p                0x00080000

#define AV_HDTV_MODE_MASK                 (AV_FLAGS_HDTV_480p | AV_FLAGS_HDTV_720p | AV_FLAGS_HDTV_1080i | AV_FLAGS_HDTV_480i)

// Whether the display is interlaced or not.
#define AV_FLAGS_INTERLACED               0x00200000

// Indicates a field-rendered mode.
#define AV_FLAGS_FIELD                    0x01000000

// Indicates that this is in the funky pixel aspect ratio mode.
#define AV_FLAGS_10x11PAR                 0x02000000

// The refresh rate supported by the display.
#define AV_FLAGS_60Hz                     0x00400000
#define AV_FLAGS_50Hz                     0x00800000

#define AV_REFRESH_MASK                   (AV_FLAGS_60Hz | AV_FLAGS_50Hz)

#define AV_USER_FLAGS_MASK                (AV_ASPECT_RATIO_MASK | AV_HDTV_MODE_MASK | AV_FLAGS_60Hz)
#define AV_USER_FLAGS_BIT_SHIFT           16

//
// TV encoder options
//

// !!! Do not change the MACROVISION_MODE value without
//    updating the DVD software!

#define AV_OPTION_MACROVISION_MODE        1
#define AV_OPTION_ENABLE_CC               2
#define AV_OPTION_DISABLE_CC              3
#define AV_OPTION_SEND_CC_DATA            4
#define AV_QUERY_CC_STATUS                5
#define AV_QUERY_AV_CAPABILITIES          6
#define AV_OPTION_BLANK_SCREEN            9
#define AV_OPTION_MACROVISION_COMMIT      10
#define AV_OPTION_FLICKER_FILTER          11
#define AV_OPTION_ZERO_MODE               12
#define AV_OPTION_QUERY_MODE              13
#define AV_OPTION_ENABLE_LUMA_FILTER      14
#define AV_OPTION_GUESS_FIELD             15
#define AV_QUERY_ENCODER_TYPE             16
#define AV_QUERY_MODE_TABLE_VERSION       17

//
// TV encoder types.
//

#define AV_ENCODER_CONEXANT_871           0

//
// Macrovision modes
//

#define AV_MV_OFF                         0
#define AV_MV_AGC_ONLY                    1
#define AV_MV_TWO_STRIPES_PLUS_AGC        2
#define AV_MV_FOUR_STRIPES_PLUS_AGC       3

NTKERNELAVAPI
ULONG
NTAPI
AvSetDisplayMode(
    IN  PVOID RegisterBase,
    IN  ULONG Step,
    IN  ULONG DisplayMode,            // mode from the AV_MODE list (avmode.h)
    IN  ULONG SourceColorFormat,      // D3DFORMAT
    IN  ULONG Pitch,
    IN  ULONG FrameBuffer
    );

NTKERNELAVAPI
VOID
NTAPI
AvSendTVEncoderOption(
    IN  PVOID RegisterBase,
    IN  ULONG Option,
    IN  ULONG Param,
    OUT PULONG Result
    );

NTKERNELAVAPI
PVOID
NTAPI
AvGetSavedDataAddress(
    VOID
    );

NTKERNELAVAPI
VOID
NTAPI
AvSetSavedDataAddress(
    PVOID address
    );

NTKERNELAVAPI
ULONG
NTAPI
AvSMCVideoModeToAVPack(
    ULONG VideoMode
    );

#endif // _AV_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xtool\xtool.h ===
// xTOOL.h - manufacturing process TOOL

#if !defined(_XTOOL_H_)
#define _XTOOL_H_

// supress futile warnings about assignment operators
#pragma warning (disable:4512)
#include "..\parameter.h"
#ifndef PASS
#define PASS 0
#endif
#ifndef FAIL
#define FAIL 0xFFFFFFFF
#endif

#define XTOOL_MODNUM   13

#define TOOL_HOST_TIMEOUT 180 // Wait for 3 minutes for the host to respond to any communications

// NTSTATUS
typedef LONG NTSTATUS; 
/*lint -save -e624 */  // Don't complain about different typedefs.
typedef NTSTATUS *PNTSTATUS;
/*lint -restore */  // Resume checking for different typedefs.
#define STATUS_SUCCESS ((NTSTATUS)0x00000000L) 
#define NTHALAPI     DECLSPEC_IMPORT

// SMBus functions.
extern "C"
{
NTHALAPI
NTSTATUS
NTAPI
HalReadSMBusValue(
	IN UCHAR SlaveAddress,
	IN UCHAR CommandCode,
	IN BOOLEAN ReadWordValue,
	OUT ULONG *DataValue
	);

#define HalReadSMBusByte(SlaveAddress, CommandCode, DataValue) \
	HalReadSMBusValue(SlaveAddress, CommandCode, FALSE, DataValue)

#define HalReadSMBusWord(SlaveAddress, CommandCode, DataValue) \
	HalReadSMBusValue(SlaveAddress, CommandCode, TRUE, DataValue)

NTHALAPI
NTSTATUS 
NTAPI
HalWriteSMBusValue(
	IN UCHAR SlaveAddress,
	IN UCHAR CommandCode,
	IN BOOLEAN WriteWordValue,
	IN ULONG DataValue
	);

#define HalWriteSMBusByte(SlaveAddress, CommandCode, DataValue) \
	HalWriteSMBusValue(SlaveAddress, CommandCode, FALSE, DataValue)

#define HalWriteSMBusWord(SlaveAddress, CommandCode, DataValue) \
	HalWriteSMBusValue(SlaveAddress, CommandCode, TRUE, DataValue)

} // end extern "C"


extern "C"
{
typedef struct _XBOX_KRNL_VERSION {
    USHORT Major;
    USHORT Minor;
    USHORT Build;
    USHORT Qfe;
} XBOX_KRNL_VERSION, *PXBOX_KRNL_VERSION;

extern const PXBOX_KRNL_VERSION XboxKrnlVersion;
} // end extern "C"




//
// Information about the current hardware that the system is running on
//
extern "C"
{
typedef struct _XBOX_HARDWARE_INFO {
    ULONG Flags;
    UCHAR GpuRevision;
    UCHAR McpRevision;
    UCHAR reserved[2];
} XBOX_HARDWARE_INFO;

extern const XBOX_HARDWARE_INFO* XboxHardwareInfo;
} // end extern "C"


//Some defines used for talking to the TIU board
#define AVMODEDISABLE	0
#define AVMODEVGA		1
#define AVMODESCART		6
#define AVMODENTSCCOMP	3
#define AVMODEHDTV		2
#define AVMODENTSCENH	4
//end TIU defines.


//-----------------------------------------------------------------------------------------------
//DISPLAY MODE DEFINES - required for auto-switching the output modes without restarting the DUT.
extern "C"
{
	extern DWORD D3D__AvInfo;
}

//End of DISPLAY MODE DEFINES
//-----------------------------------------------------------------------------------------------


// Naming of class test and module classes.
// 
// module class: CX<module>
// test class:   CX<module>Test<test>
//
// The names are important because the modules and exective are 
// all one project.  Since the classes are presented alphebetically, 
// using this naming convention makes the code easier to navigate.
//

class CXModuleTool : public CTestObj
{
public:
	DECLARE_XMTAMODULE (CXModuleTool, "tool", XTOOL_MODNUM);  //(module name, module number)

protected:
	// Error messages declared here ...
	//(Note: 0x000 - 0x00f reserved for XMTA)
	//

	// Error routines return true if the calling routine should abort, and false otherwise
	bool err_BADPARAMETER (LPCTSTR s1)
	{
		ReportError (0x010, L"Can't find configuration parameter \"%s\"\nThis configuration parameter doesn't exist or is invalid", s1); return (CheckAbort (HERE));
	}
	bool err_HostCommunicationError (int i1)
	{
		ReportError (0x011, L"iSendHost communication routine returned an error code of 0x%x", i1); return (CheckAbort (HERE)); 
	}
	bool err_RandomBufferIsEmpty ()
	{
		ReportError (0x012, L"The random number buffer from the host is empty"); return (CheckAbort (HERE)); 
	}
	bool err_HostResponseError (DWORD dwErrorCodeFromHost, LPCTSTR s1)
	{
		ReportError ((unsigned short)dwErrorCodeFromHost, L"The host responded with the following error message:\n%s", s1); return (CheckAbort (HERE));
	}
//	bool err_CouldNotAllocateRandomBuffer (DWORD dw1)
//	{
//		ReportError (0x011, L"Could not allocate a buffer to hold a random number of length %lu bytes", dw1); return (CheckAbort (HERE));
//	}
	bool err_SetDisplayMode (LPCTSTR s1)
	{
		ReportError (0x013, L"An error occured with the set_display_mode tool: %s", s1); return (CheckAbort (HERE));
	}
	bool err_D3DError (LPCTSTR s1)
	{
		ReportError (0x014, L"The following D3D function failed: %s", s1); return (CheckAbort (HERE));
	}
	bool err_NoGameRegionCode ()
	{
		ReportError (0x015, L"Could not obtain the game region code from the host computer"); return (CheckAbort (HERE)); 
	}
	bool err_GameRegionCodeTooLarge ()
	{
		ReportError (0x016, L"The game region returned by the host computer is too large"); return (CheckAbort (HERE)); 
	}
	bool err_GameRegionInvalid (LPCTSTR s1)
	{
		ReportError (0x017, L"The game region returned by the host computer \"%s\" cannot be converted to an integer", s1); return (CheckAbort (HERE)); 
	}
	bool err_NoTVRegionCode ()
	{
		ReportError (0x018, L"Could not obtain the TV region code from the host computer"); return (CheckAbort (HERE)); 
	}
	bool err_TVRegionCodeTooLarge ()
	{
		ReportError (0x019, L"The TV region returned by the host computer is too large"); return (CheckAbort (HERE)); 
	}
	bool err_TVRegionInvalid (LPCTSTR s1)
	{
		ReportError (0x01A, L"The TV region returned by the host computer \"%s\" cannot be converted to an integer", s1); return (CheckAbort (HERE)); 
	}
	bool err_NoMACAddress ()
	{
		ReportError (0x01B, L"Could not obtain the XBox MAC address from the host computer"); return (CheckAbort (HERE)); 
	}
	bool err_MACAddressTooLarge ()
	{
		ReportError (0x01C, L"The MAC Address returned by the host computer is too large"); return (CheckAbort (HERE)); 
	}
	bool err_MACAddressInvalid (LPCTSTR s1)
	{
		ReportError (0x01D, L"The MAC Address returned by the host computer \"%s\" cannot be converted to integers", s1); return (CheckAbort (HERE)); 
	}
	bool err_NoSerialNumber ()
	{
		ReportError (0x01E, L"Could not obtain the XBox serial number from the host computer"); return (CheckAbort (HERE)); 
	}
	bool err_SerialNumberTooLarge ()
	{
		ReportError (0x01F, L"The serial number returned by the host computer is too large"); return (CheckAbort (HERE)); 
	}
	bool err_SMCWrite(LPCTSTR s1, DWORD dw1)
	{
		ReportError (0x020, L"Write to SMC %s Register Failed. NTSTATUS = 0x%08lX", s1, dw1); return (CheckAbort (HERE));
	}
	bool err_SMCRead(LPCTSTR s1, DWORD dw1)
	{
		ReportError (0x021, L"Read from SMC %s Register Failed. NTSTATUS = 0x%08lX", s1, dw1); return (CheckAbort (HERE));
	}
	bool err_NoGenPerBoxDataResponse ()
	{
		ReportError (0x022, L"Could not obtain a GenPerBoxData response from the host computer"); return (CheckAbort (HERE)); 
	}
	bool err_HardDriveKeyTooLarge ()
	{
		ReportError (0x023, L"The Hard Drive Key returned by the host computer is too large"); return (CheckAbort (HERE)); 
	}
	bool err_RecoveryKeyTooLarge ()
	{
		ReportError (0x024, L"The Recovery Key returned by the host computer is too large"); return (CheckAbort (HERE)); 
	}
	bool err_OnlineKeyTooLarge ()
	{
		ReportError (0x025, L"The Online Key returned by the host computer is too large"); return (CheckAbort (HERE)); 
	}
	bool err_OutputBufferTooLarge ()
	{
		ReportError (0x026, L"The Output Buffer returned by the host computer is too large"); return (CheckAbort (HERE)); 
	}
	bool err_WritePerBadLength ()
	{
		ReportError (0x027, L"WritePerBoxData indicated that the Output Buffer data is the wrong length"); return (CheckAbort (HERE)); 
	}
	bool err_WritePerBadData ()
	{
		ReportError (0x028, L"WritePerBoxData indicated that it could not decrypt the Output Buffer data"); return (CheckAbort (HERE)); 
	}
	bool err_WritePerBadAccess ()
	{
		ReportError (0x029, L"WritePerBoxData indicated that it could not read or write the eeprom"); return (CheckAbort (HERE)); 
	}
	bool err_WritePerBadKey ()
	{
		ReportError (0x02A, L"WritePerBoxData indicated that the eeprom key is not random"); return (CheckAbort (HERE)); 
	}
	bool err_WritePerUnknown ()
	{
		ReportError (0x02B, L"WritePerBoxData indicated that an unknown error happened"); return (CheckAbort (HERE)); 
	}
	bool err_MessageTooLarge(DWORD dw1)
	{
		ReportError (0x02C, L"A message of %lu bytes to the host is larger than the message buffer size", dw1); return (CheckAbort (HERE));
	}
	bool err_VerifyPerBadData ()
	{
		ReportError (0x02D, L"VerifyPerBoxData indicated that it could not decrypt the eeprom keys"); return (CheckAbort (HERE)); 
	}
	bool err_VerifyPerBadAccess ()
	{
		ReportError (0x02E, L"VerifyPerBoxData indicated that it could not read or write the eeprom"); return (CheckAbort (HERE)); 
	}
	bool err_VerifyPerBadKey ()
	{
		ReportError (0x02F, L"VerifyPerBoxData indicated that the eeprom key is not random"); return (CheckAbort (HERE)); 
	}
	bool err_VerifyPerUnknown ()
	{
		ReportError (0x030, L"VerifyPerBoxData indicated that an unknown error happened"); return (CheckAbort (HERE)); 
	}
	bool err_NoFileReturned (LPCTSTR s1)
	{
		ReportError (0x031, L"Could not obtain the file \"%s\" from the host computer", s1); return (CheckAbort (HERE)); 
	}
	bool err_CouldNotMountUtilityDrive (DWORD dw1)
	{
		ReportError (0x032, L"Could not mount the XBox utility drive.  GetLastError returned: %lu", dw1); return (CheckAbort (HERE)); 
	}
	bool err_GPURevisionXor()
	{
		ReportError (0x033, L"\"GPURevisionAllowed[#]\" and \"GPURevisionNotAllowed[#]\" configuration parameters are mutually exclusive. Use one set or the other."); return (CheckAbort (HERE));
	}
	bool err_GPURevisionNotAllowed (DWORD dw1)
	{
		ReportError (0x034, L"GPU Revision is not allowed: 0x%2.2x.", dw1); return (CheckAbort (HERE));
	}
	bool err_MCPRevisionXor()
	{
		ReportError (0x035, L"\"MCPRevisionAllowed[#]\" and \"MCPRevisionNotAllowed[#]\" configuration parameters are mutually exclusive. Use one set or the other."); return (CheckAbort (HERE));
	}
	bool err_MCPRevisionNotAllowed (DWORD dw1)
	{
		ReportError (0x036, L"MCP Revision is not allowed: 0x%2.2x.", dw1); return (CheckAbort (HERE));
	}
	bool err_CouldNotMountDashboardPartition (DWORD dw1)
	{
		ReportError (0x037, L"Could not mount the XBox dashboard partition.  GetLastError returned: %lu", dw1); return (CheckAbort (HERE)); 
	}
	bool err_SCARTStatusNotReceivedFromHost ()
	{
		ReportError (0x038, L"Could not receive the voltage of the SCART Status line from the host computer"); return (CheckAbort (HERE)); 
	}
	bool err_SCARTStatusWrongVoltage (float f1, double dbl1, double dbl2)
	{
		ReportError (0x039, L"Actual SCART Status line voltage value (%.2lf) did not fall in the expected range (%.2lf - %.2lf)", (double)f1, dbl1, dbl2); return (CheckAbort (HERE)); 
	}
	bool err_RE_OUT_OF_MEMORY_P1 (DWORD dw1)
	{
		ReportError (0x03A, L"Out-of-memory error.  Could not allocate %d bytes of memory.", dw1); return (CheckAbort (HERE));
	}
	bool err_OPEN_FILE_P1L (char *s1)
	{
		ReportError (0x03B, L"Failed to open the file \"%S\" that is needed to perform the drive test", s1); return (CheckAbort (HERE));
	}
	bool err_BadKernelRevision (LPCTSTR s1)
	{
		ReportError (0x03C, L"The kernel revision of the XBox \"%s\" is not in the list of allowed kernels", s1); return (CheckAbort (HERE));
	}
	bool err_BadDVDRevision (LPCTSTR s1)
	{
		ReportError (0x03D, L"The DVD firmware revision of \"%s\" is not in the list of allowed DVD revisions", s1); return (CheckAbort (HERE));
	}
	bool err_NoImageFileSpecified ()
	{
		ReportError (0x03E, L"Cannot image the hard drive without a source file name"); return (CheckAbort (HERE));
	}
	bool err_RE_WRITE_LOGICAL_P3L (char *cp1, DWORD dw1, DWORDLONG dwl1)
	{
		ReportError (0x03F, L"Error writing device \"%S\".\nCould not write %lu bytes to offset %I64u.", cp1, dw1, dwl1); return (CheckAbort (HERE));
	}
	bool err_ImageFileWrongSize (char *cp1, DWORD dw1, DWORD dw2)
	{
		ReportError (0x040, L"The image file \"%S\" written to the hard drive is not the right size\nExpected the file to be %lu bytes, but is is %lu bytes instead", cp1, dw1, dw2); return (CheckAbort (HERE));
	}
	bool err_NoFileSizeReturned (LPCTSTR s1)
	{
		ReportError (0x041, L"Could not obtain the size of file \"%s\" from the host computer", s1); return (CheckAbort (HERE)); 
	}
	bool err_ImageFileZeroLength (LPCTSTR s1)
	{
		ReportError (0x042, L"The image file \"%s\" on the server is empty", s1); return (CheckAbort (HERE));
	}
	bool err_SettingFatalErrorRetryFlag ()
	{
		ReportError (0x043, L"Could not set the state of the Fatal Error Retry Flag"); return (CheckAbort (HERE));
	}
	bool err_QueryingFatalErrorCode ()
	{
		ReportError (0x044, L"Could not query the last UEM fatal error code from the XBox"); return (CheckAbort (HERE));
	}
	bool err_NamedStateBufferIsEmpty ()
	{
		ReportError (0x045, L"The named state data buffer from the host is empty"); return (CheckAbort (HERE)); 
	}
	bool err_UEMTooManyTotalErrors (DWORD dw1)
	{
		ReportError (0x046, L"There have been a total of %ld UEM errors, which is more than the permitted number", dw1); return (CheckAbort (HERE));
	}
	// Errors 0x47 through 0x66 are reserved for UEM errors
	bool err_UEMTooManyErrors (DWORD dw1, DWORD dw2, DWORD dw3, LPCTSTR s1)
	{
		ReportError ((WORD)dw1, L"There have been %ld UEM errors of type 0x%2.2lx: \"%s\", which is more than the permitted number", dw2, dw3, s1); return (CheckAbort (HERE));
	}
	bool err_ClearFatalErrorHistory ()
	{
		ReportError (0x067, L"Could not clear the UEM fatal error history"); return (CheckAbort (HERE));
	}
	bool err_NoEepromSerialNumber ()
	{
		ReportError (0x068, L"Could not read the XBox serial number from the eeprom"); return (CheckAbort (HERE)); 
	}
	bool err_SerialNumberMismatch (char *c1, char *c2)
	{
		ReportError (0x069, L"The serial number obtained from the host, %S, does not match the number read from the eeprom, %S", c1, c2); return (CheckAbort (HERE)); 
	}
	bool err_NoEepromMACAddress ()
	{
		ReportError (0x06A, L"Could not read the XBox MAC address from the eeprom"); return (CheckAbort (HERE)); 
	}
	bool err_MACAddressMismatch (DWORD dw1, DWORD dw2, DWORD dw3, DWORD dw4)
	{
		ReportError (0x06B, L"The MAC address obtained from the host, %4.4lx%8.8lx, does not match the number read from the eeprom, %4.4lx%8.8lx", dw1, dw2, dw3, dw4); return (CheckAbort (HERE)); 
	}

	
	// Parameters declared here ...
	//
	DWORD dwRandomNumberLength;
//	int m_cfgInt;
//	UINT m_cfgUint;
//	LPCTSTR m_cfgString;
//	int m_cfgChoice;

	int m_vidMode;//The display mode (resoulution) to be used.
	LPCTSTR m_pack;
	LPCTSTR m_standard;
	LPCTSTR	m_HDTVmode;
	LPCTSTR	m_TIUStatus;
	int m_flagWidescreen;
	int m_flagRefreshRate;
	BYTE m_AVMode;

	virtual bool InitializeParameters();
	
	bool InitializeDisplaySettings(int mode);
	bool InitializeInterfaceBoard(BYTE avMode);
	//Output some dubug messages to give visibility of flag settings.
	void ReportVideoSettings();
	bool bMountUtilityDrive();
	bool bMountDashboardPartition();
	void vNewSeed(UINT *pSeed);
	DWORD random(UINT *pScratch);

public:
	// Common functions go here.  Put any functions that need 
	// to be global to the tests in the module class
	//
	void HelperFunction (); // delete this
};

#endif // _XTOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xtv\ntsccb.cpp ===
// 
// (c) Copyright 2000-2000 Intel Corp. All rights reserved.
//   ntsccb.cpp: used to implement ntsc-m and ntsc-Japan color bars 
//   tests for composite and s-video output. The subtests include 
//	ntscmcompcb, ntscmsvcb, ntscjcompcb, and ntscjsvcb
//
//////////////////////////////////////////////////////////////////////
#include <stdlib.h>
#include <wchar.h>
#include <iostream>
#include <string>
#include <sstream>
#include "..\stdafx.h"
#include "..\statkeys.h"
#include "XTV.h"

#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ| D3DFVF_NORMAL|D3DFVF_DIFFUSE)
#define MAX_VERTS 640
#define EIACb_ELEMS	22

//ntsc-m TV standard with Composite and s-video output sourse for Color Bars test
IMPLEMENT_TESTLOCKED (TV, ntscmcompcb, 1)
{
	CHostResponse CHR;
	DWORD  dwMeasureResultBuffSize=EIACb_ELEMS*2*sizeof(DWORD);
	DWORD *dwMeasureResultBuff=new DWORD[dwMeasureResultBuffSize/(sizeof(DWORD))];
	char *send_buf = NULL;
	BOOL bPass = TRUE;
	DWORD dwBufferToHostLength, dwActualBytesReceived, dwErrorCodeFromHost,i;
	int iError,videomode;
	dwBufferToHostLength=NULL;

	if (CheckAbort (HERE)){ Cleanup(); return;};

	//Init arrays to hold response data.
	NTSCM_COMP_CB_DATA MeasuredNtscmCompCbLumaIRE[NUMBER_OF_CBARS];
	NTSCM_COMP_CB_DATA MeasuredNtscmCompCbChromaIRE[NUMBER_OF_CBARS];
	NTSCM_COMP_CB_DATA MeasuredNtscmCompCbChromaPhase[NUMBER_OF_CBARS];
	
	videomode=GetCfgInt(L"videomode", 1);
	switch(videomode)
	{
		case 1:
			DrawNTSCCB();
			NTSCCBRender();
			break;
		case 3:
			DrawMode3NTSCCB();
			NTSCCBRender();
			break;


		default:
			break;
	}
    // Present the backbuffer contents to the display
    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
	
	//Outer retry loop.
	//Sometimes the capture happens before the image is ready ready for processing, resulting in a false failure.
	//Retry up to the config value number of times to help prevent false failures.
	
	for(int attempts=0; attempts < m_testRetries; attempts++)
	{
		if ((iError = g_host.iSendHost(MID_NTSC_M_COMP_CB, send_buf, dwBufferToHostLength, CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, XTV_TIMEOUT)) != EVERYTHINGS_OK)
		{

		if (dwErrorCodeFromHost != 0)
			{
				// Process error from host
				err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost);
				return;
			}
			else
			{
				// Process a communication error
				// This test module just reports the number of the communication error that was received
				err_HostCommunicationError(iError);
				return;
			}
		}
		else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
		{
			// The response buffer is empty, so take appropriate action (like an error message)
			err_RecordBufferIsEmpty();
			return;
		}
		else // The response is not NULL, and is not an error message, so process it
		{
			if (dwActualBytesReceived < dwMeasureResultBuffSize)
			{
				err_RecordBufferIsNotCorrectLength(dwMeasureResultBuffSize, dwActualBytesReceived);
				return;
			}
		}

		memcpy(dwMeasureResultBuff, CHR.pvBufferFromHost, dwMeasureResultBuffSize); 

		// using string input to extract the datas in the measureresultbuff
		using namespace std;
		string input((char *)dwMeasureResultBuff);
		istringstream inputString(input);

		inputString >>m_LumaIREWhite		>>m_LumaIREYellow 
					>>m_LumaIRECyan			>>m_LumaIREGreen
					>>m_LumaIREMagenta 		>>m_LumaIRERed 
					>>m_LumaIREBlue 		>>m_LumaIREBlack
					>>m_ChromaIREWhite		>>m_ChromaIREYellow 
					>>m_ChromaIRECyan 		>>m_ChromaIREGreen
					>>m_ChromaIREMagenta	>>m_ChromaIRERed 
					>>m_ChromaIREBlue 		>>m_ChromaIREBlack
					//>> m_ChromaPhaseWhite
					>>m_ChromaPhaseYellow	>>m_ChromaPhaseCyan 
					>>m_ChromaPhaseGreen	>>m_ChromaPhaseMagenta 
					>>m_ChromaPhaseRed		>>m_ChromaPhaseBlue ;
					//>> m_ChromaPhaseBlack;

		MeasuredNtscmCompCbLumaIRE[0].dblLumaIRE=m_LumaIREWhite;
		MeasuredNtscmCompCbLumaIRE[1].dblLumaIRE= m_LumaIREYellow;
		MeasuredNtscmCompCbLumaIRE[2].dblLumaIRE= m_LumaIRECyan;
		MeasuredNtscmCompCbLumaIRE[3].dblLumaIRE= m_LumaIREGreen;
		MeasuredNtscmCompCbLumaIRE[4].dblLumaIRE= m_LumaIREMagenta;
		MeasuredNtscmCompCbLumaIRE[5].dblLumaIRE= m_LumaIRERed;
		MeasuredNtscmCompCbLumaIRE[6].dblLumaIRE= m_LumaIREBlue;
		MeasuredNtscmCompCbLumaIRE[7].dblLumaIRE= m_LumaIREBlack;

		MeasuredNtscmCompCbChromaIRE[0].dblChromaIRE= m_ChromaIREWhite;
		MeasuredNtscmCompCbChromaIRE[1].dblChromaIRE= m_ChromaIREYellow;
		MeasuredNtscmCompCbChromaIRE[2].dblChromaIRE= m_ChromaIRECyan;
		MeasuredNtscmCompCbChromaIRE[3].dblChromaIRE= m_ChromaIREGreen;
		MeasuredNtscmCompCbChromaIRE[4].dblChromaIRE= m_ChromaIREMagenta;
		MeasuredNtscmCompCbChromaIRE[5].dblChromaIRE= m_ChromaIRERed;
		MeasuredNtscmCompCbChromaIRE[6].dblChromaIRE= m_ChromaIREBlue;
		MeasuredNtscmCompCbChromaIRE[7].dblChromaIRE= m_ChromaIREBlack;

		//MeasuredNtscChromaPhase[0].dblChromaPhase= m_ChromaPhaseWhite;
		MeasuredNtscmCompCbChromaPhase[0].dblChromaPhase= m_ChromaPhaseYellow;
		MeasuredNtscmCompCbChromaPhase[1].dblChromaPhase= m_ChromaPhaseCyan;
		MeasuredNtscmCompCbChromaPhase[2].dblChromaPhase= m_ChromaPhaseGreen;
		MeasuredNtscmCompCbChromaPhase[3].dblChromaPhase= m_ChromaPhaseMagenta;
		MeasuredNtscmCompCbChromaPhase[4].dblChromaPhase= m_ChromaPhaseRed;
		MeasuredNtscmCompCbChromaPhase[5].dblChromaPhase= m_ChromaPhaseBlue;
		//MeasuredNtscChromaPhase[7].dblChromaPhase= m_ChromaPhaseBlack;

		/*for (i=0;i<NUMBER_OF_CBARS;i++)
			ReportStatistic(NTSCM_COMPOSITE_COLOR_BAR,_T("LumaIRE[%lu]: %.1f"),i, MeasuredNtscmCompCbLumaIRE[i].dblLumaIRE);

		for (i=0;i<NUMBER_OF_CBARS;i++)
		ReportStatistic(NTSCM_COMPOSITE_COLOR_BAR, _T("ChromaIRE[%lu] %.1f"),i, MeasuredNtscmCompCbChromaIRE[i].dblChromaIRE);

		for(i=0;i<NUMBER_OF_CBARS-2;i++)
		ReportStatistic(NTSCM_COMPOSITE_COLOR_BAR, _T("ChromaPhase[%lu]  %.1f"),i, MeasuredNtscmCompCbChromaPhase[i].dblChromaPhase);
		*/
		//for (i=0;i<NUMBER_OF_CBARS;i++)
		//ReportWarning(L"%.1f, %lu, %lu, %lu",MeasuredNtscmCompCbLumaIRE[i].dblLumaIRE,dbStandardNtscParams[i].dwStdNtscCbParamLumaIRE,gdwColorBarLimitLumaIRE[i].dwLumaIREUpperLimit,gdwColorBarLimitLumaIRE[i].dwLumaIRELowerLimit);

		bPass = TRUE;
		for(i=0;i<NUMBER_OF_CBARS;i++)
		{
			if(	(MeasuredNtscmCompCbLumaIRE[i].dblLumaIRE < gdwColorBarLimitLumaIRE[i].dwLumaIRELowerLimit)||(MeasuredNtscmCompCbLumaIRE[i].dblLumaIRE > gdwColorBarLimitLumaIRE[i].dwLumaIREUpperLimit))
				bPass = FALSE;
		}

		if(bPass)
		{
			for(i=0;i<NUMBER_OF_CBARS;i++)
			{
				if(	(MeasuredNtscmCompCbChromaIRE[i].dblChromaIRE<	gdwColorBarLimitChromaIRE[i].dwChromaIRELowerLimit)||(MeasuredNtscmCompCbChromaIRE[i].dblChromaIRE>gdwColorBarLimitChromaIRE[i].dwChromaIREUpperLimit))
					bPass = FALSE;
			}
		}

		if(bPass)
		{
			for(i=0;i<NUMBER_OF_CBARS-2;i++)
			{
				if(	(MeasuredNtscmCompCbChromaPhase[i].dblChromaPhase<	gdwColorBarLimitChromaPhase[i].dwChromaPhaseLowerLimit)||(MeasuredNtscmCompCbChromaPhase[i].dblChromaPhase>gdwColorBarLimitChromaPhase[i].dwChromaPhaseUpperLimit))
	 				bPass = FALSE;
			}
		}
		
		if(bPass)
			break;

	}//end retry loop

	//Now that we have the real data, report out the stats.
	//Report Statistic data of NTSC-M Composite color bar for Luma IRE:
	ReportStatistic(NTSCM_COMPOSITE_COLOR_BAR_LUMA_IRE_WHITE, _T("%.1f"),m_LumaIREWhite);
	ReportStatistic(NTSCM_COMPOSITE_COLOR_BAR_LUMA_IRE_YELLOW, _T("%.1f"),m_LumaIREYellow);
	ReportStatistic(NTSCM_COMPOSITE_COLOR_BAR_LUMA_IRE_CYAN, _T("%.1f"),m_LumaIRECyan);
	ReportStatistic(NTSCM_COMPOSITE_COLOR_BAR_LUMA_IRE_GREEN, _T("%.1f"),m_LumaIREGreen);
	ReportStatistic(NTSCM_COMPOSITE_COLOR_BAR_LUMA_IRE_MAGENTA, _T("%.1f"),m_LumaIREMagenta);
	ReportStatistic(NTSCM_COMPOSITE_COLOR_BAR_LUMA_IRE_RED, _T("%.1f"),m_LumaIRERed);
	ReportStatistic(NTSCM_COMPOSITE_COLOR_BAR_LUMA_IRE_BLUE, _T("%.1f"),m_LumaIREBlue);
	ReportStatistic(NTSCM_COMPOSITE_COLOR_BAR_LUMA_IRE_BLACK, _T("%.1f"),m_LumaIREBlack);

	//Report Statistic data of NTSC-M Composite color bar for Chroma IRE:
	ReportStatistic(NTSCM_COMPOSITE_COLOR_BAR_CHROMA_IRE_WHITE, _T("%.1f"),m_ChromaIREWhite);
	ReportStatistic(NTSCM_COMPOSITE_COLOR_BAR_CHROMA_IRE_YELLOW, _T("%.1f"),m_ChromaIREYellow);
	ReportStatistic(NTSCM_COMPOSITE_COLOR_BAR_CHROMA_IRE_CYAN, _T("%.1f"),m_ChromaIRECyan);
	ReportStatistic(NTSCM_COMPOSITE_COLOR_BAR_CHROMA_IRE_GREEN, _T("%.1f"),m_ChromaIREGreen);
	ReportStatistic(NTSCM_COMPOSITE_COLOR_BAR_CHROMA_IRE_MAGENTA, _T("%.1f"),m_ChromaIREMagenta);
	ReportStatistic(NTSCM_COMPOSITE_COLOR_BAR_CHROMA_IRE_RED, _T("%.1f"),m_ChromaIRERed);
	ReportStatistic(NTSCM_COMPOSITE_COLOR_BAR_CHROMA_IRE_BLUE, _T("%.1f"),m_ChromaIREBlue);
	ReportStatistic(NTSCM_COMPOSITE_COLOR_BAR_CHROMA_IRE_BLACK, _T("%.1f"),m_ChromaIREBlack);


	//Report Statistic data of NTSC-M Composite color bar for Chroma Phase:
	//ReportStatistic(NTSCM_COMPOSITE_COLOR_BAR_CHROMA_IRE_WHITE, _T("%.1f"),m_ChromaIREWhite);
	ReportStatistic(NTSCM_COMPOSITE_COLOR_BAR_CHROMA_PHASE_YELLOW, _T("%.1f"),m_ChromaPhaseYellow);
	ReportStatistic(NTSCM_COMPOSITE_COLOR_BAR_CHROMA_PHASE_CYAN, _T("%.1f"),m_ChromaPhaseCyan);
	ReportStatistic(NTSCM_COMPOSITE_COLOR_BAR_CHROMA_PHASE_GREEN, _T("%.1f"),m_ChromaPhaseGreen);
	ReportStatistic(NTSCM_COMPOSITE_COLOR_BAR_CHROMA_PHASE_MAGENTA, _T("%.1f"),m_ChromaPhaseMagenta);
	ReportStatistic(NTSCM_COMPOSITE_COLOR_BAR_CHROMA_PHASE_RED, _T("%.1f"),m_ChromaPhaseRed);
	ReportStatistic(NTSCM_COMPOSITE_COLOR_BAR_CHROMA_PHASE_BLUE, _T("%.1f"),m_ChromaPhaseBlue);
	//ReportStatistic(NTSCM_COMPOSITE_COLOR_BAR_CHROMA_IRE_BLACK, _T("%.1f"),m_ChromaIREBlack);

	//If the test failed, sift through the data again to retrieve the failed value and report the error.
	if(!bPass)
	{
		for(i=0;i<NUMBER_OF_CBARS;i++)
		{
			if(	(MeasuredNtscmCompCbLumaIRE[i].dblLumaIRE < gdwColorBarLimitLumaIRE[i].dwLumaIRELowerLimit)||(MeasuredNtscmCompCbLumaIRE[i].dblLumaIRE > gdwColorBarLimitLumaIRE[i].dwLumaIREUpperLimit))
				err_LumaResultOutOfRange(i,MeasuredNtscmCompCbLumaIRE[i].dblLumaIRE, dbStandardNtscParams[i].dwStdNtscCbParamLumaIRE ,gdwColorBarLimitLumaIRE[i].dwLumaIREUpperLimit,gdwColorBarLimitLumaIRE[i].dwLumaIRELowerLimit);
		}

		for(i=0;i<NUMBER_OF_CBARS;i++)
		{
			if(	(MeasuredNtscmCompCbChromaIRE[i].dblChromaIRE<	gdwColorBarLimitChromaIRE[i].dwChromaIRELowerLimit)||(MeasuredNtscmCompCbChromaIRE[i].dblChromaIRE>gdwColorBarLimitChromaIRE[i].dwChromaIREUpperLimit))
				err_ChromaIREResultOutOfRange(i,MeasuredNtscmCompCbChromaIRE[i].dblChromaIRE, dbStandardNtscParams[i].dwStdNtscCbParamChromaIRE, gdwColorBarLimitChromaIRE[i].dwChromaIREUpperLimit,gdwColorBarLimitChromaIRE[i].dwChromaIRELowerLimit);
		}

		for(i=0;i<NUMBER_OF_CBARS-2;i++)
		{
			if(	(MeasuredNtscmCompCbChromaPhase[i].dblChromaPhase<	gdwColorBarLimitChromaPhase[i].dwChromaPhaseLowerLimit)||(MeasuredNtscmCompCbChromaPhase[i].dblChromaPhase>gdwColorBarLimitChromaPhase[i].dwChromaPhaseUpperLimit))
	 			err_ChromaPhaseResultOutOfRange(i,MeasuredNtscmCompCbChromaPhase[i].dblChromaPhase, 	dbStandardNtscParams[i].dwStdNtscCbParamChromaPhase,gdwColorBarLimitChromaPhase[i].dwChromaPhaseUpperLimit,gdwColorBarLimitChromaPhase[i].dwChromaPhaseLowerLimit);
		}	
	}
	
	Cleanup();

	return;
}



IMPLEMENT_TESTLOCKED (TV, ntscmsvcb, 2)
{

	CHostResponse CHR;
	char *send_buf = NULL;
	DWORD  dwMeasureResultBuffSize=EIACb_ELEMS*2*sizeof(DWORD);;
	DWORD *dwMeasureResultBuff=new DWORD[dwMeasureResultBuffSize/(sizeof(DWORD))];
	DWORD dwBufferToHostLength, dwActualBytesReceived, dwErrorCodeFromHost,i=0;
	int iError,videomode;
	dwBufferToHostLength=NULL;
	BOOL bPass = TRUE;
	
	if (CheckAbort (HERE)){ Cleanup(); return;};
	
	//Init the arrays to hold the measured data.
	NTSCM_SV_CB_DATA MeasuredNtscmSvCbLumaIRE[NUMBER_OF_CBARS];
	NTSCM_SV_CB_DATA MeasuredNtscmSvCbChromaIRE[NUMBER_OF_CBARS];
	NTSCM_SV_CB_DATA MeasuredNtscmSvCbChromaPhase[NUMBER_OF_CBARS];	

	videomode=GetCfgInt(L"videomode", 1);
	switch(videomode)
	{
		case 1:
			DrawNTSCCB();
			NTSCCBRender();
			break;
		case 3:
			DrawMode3NTSCCB();
			NTSCCBRender();
			break;
		default:
			break;
	}
	

    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
	//************************ LOOK HERE IF FAILING  ****************************
	//Why is this 5 second sleep here?
	//Sleep(5000);
	
	for(int attempts=0; attempts < m_testRetries; attempts++)
	{
		// send message to host
		if ((iError = g_host.iSendHost(MID_NTSC_M_SVIDEO_CB, send_buf, dwBufferToHostLength, CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, XTV_TIMEOUT)) != EVERYTHINGS_OK)
		{
			if (dwErrorCodeFromHost != 0)
			{
				// Process error from host
				if (err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost))
					return;
			}
			else
			{
				if (err_HostCommunicationError(iError))
					return;
			}
		}
		else if (CHR.pvBufferFromHost == NULL) // Don't access the response buffer if it is NULL
		{
			// The response buffer is NULL, so take appropriate action (like an error message)
			if (err_EchoBufferResponseIsNull())
				return;
		}
		else // The response is not NULL, and is not an error message, so process it
		{
			if (dwActualBytesReceived < dwMeasureResultBuffSize)
			{
				err_RecordBufferIsNotCorrectLength(dwMeasureResultBuffSize, dwActualBytesReceived);
				return;
			}
			// We received the measure resutls buffer the size that we wanted
		}

		memcpy(dwMeasureResultBuff, CHR.pvBufferFromHost, dwMeasureResultBuffSize); 

		// using string input to extract the datas
		using namespace std;
		string input((char *)dwMeasureResultBuff);
		istringstream inputString(input);

		inputString >>m_LumaIREWhite		>>m_LumaIREYellow
					>>m_LumaIRECyan			>>m_LumaIREGreen
					>>m_LumaIREMagenta		>>m_LumaIRERed
					>>m_LumaIREBlue			>>m_LumaIREBlack
					>>m_ChromaIREWhite		>>m_ChromaIREYellow
					>>m_ChromaIRECyan		>>m_ChromaIREGreen
					>>m_ChromaIREMagenta	>>m_ChromaIRERed 
					>>m_ChromaIREBlue		>>m_ChromaIREBlack
					>>m_ChromaPhaseYellow	>>m_ChromaPhaseCyan
					>>m_ChromaPhaseGreen	>>m_ChromaPhaseMagenta
					>>m_ChromaPhaseRed		>>m_ChromaPhaseBlue;
		//		>> m_ChromaPhaseBlack;

		MeasuredNtscmSvCbLumaIRE[0].dblLumaIRE=m_LumaIREWhite;
		MeasuredNtscmSvCbLumaIRE[1].dblLumaIRE= m_LumaIREYellow;
		MeasuredNtscmSvCbLumaIRE[2].dblLumaIRE= m_LumaIRECyan;
		MeasuredNtscmSvCbLumaIRE[3].dblLumaIRE= m_LumaIREGreen;
		MeasuredNtscmSvCbLumaIRE[4].dblLumaIRE= m_LumaIREMagenta;
		MeasuredNtscmSvCbLumaIRE[5].dblLumaIRE= m_LumaIRERed;
		MeasuredNtscmSvCbLumaIRE[6].dblLumaIRE= m_LumaIREBlue;
		MeasuredNtscmSvCbLumaIRE[7].dblLumaIRE= m_LumaIREBlack;

		MeasuredNtscmSvCbChromaIRE[0].dblChromaIRE= m_ChromaIREWhite;
		MeasuredNtscmSvCbChromaIRE[1].dblChromaIRE= m_ChromaIREYellow;
		MeasuredNtscmSvCbChromaIRE[2].dblChromaIRE= m_ChromaIRECyan;
		MeasuredNtscmSvCbChromaIRE[3].dblChromaIRE= m_ChromaIREGreen;
		MeasuredNtscmSvCbChromaIRE[4].dblChromaIRE= m_ChromaIREMagenta;
		MeasuredNtscmSvCbChromaIRE[5].dblChromaIRE= m_ChromaIRERed;
		MeasuredNtscmSvCbChromaIRE[6].dblChromaIRE= m_ChromaIREBlue;
		MeasuredNtscmSvCbChromaIRE[7].dblChromaIRE= m_ChromaIREBlack;

		//MeasuredNtscChromaPhase[0].dblChromaPhase= m_ChromaPhaseWhite;
		MeasuredNtscmSvCbChromaPhase[0].dblChromaPhase= m_ChromaPhaseYellow;
		MeasuredNtscmSvCbChromaPhase[1].dblChromaPhase= m_ChromaPhaseCyan;
		MeasuredNtscmSvCbChromaPhase[2].dblChromaPhase= m_ChromaPhaseGreen;
		MeasuredNtscmSvCbChromaPhase[3].dblChromaPhase= m_ChromaPhaseMagenta;
		MeasuredNtscmSvCbChromaPhase[4].dblChromaPhase= m_ChromaPhaseRed;
		MeasuredNtscmSvCbChromaPhase[5].dblChromaPhase= m_ChromaPhaseBlue;
		//MeasuredNtscChromaPhase[7].dblChromaPhase= m_ChromaPhaseBlack;

		bPass = TRUE;
		for (i=0;i<NUMBER_OF_CBARS;i++)
		{
			if(	(MeasuredNtscmSvCbLumaIRE[i].dblLumaIRE < gdwColorBarLimitLumaIRE[i].dwLumaIRELowerLimit)||(MeasuredNtscmSvCbLumaIRE[i].dblLumaIRE >=gdwColorBarLimitLumaIRE[i].dwLumaIREUpperLimit))
				bPass = FALSE;
		}
		if(bPass)
		{
			for(i=0;i<NUMBER_OF_CBARS;i++)
			{
				if(	(MeasuredNtscmSvCbChromaIRE[i].dblChromaIRE <gdwColorBarLimitChromaIRE[i].dwChromaIRELowerLimit)||(MeasuredNtscmSvCbChromaIRE[i].dblChromaIRE>gdwColorBarLimitChromaIRE[i].dwChromaIREUpperLimit))
					bPass = FALSE;	
			}
		}
		if(bPass)
		{
			for(i=0;i<NUMBER_OF_CBARS-2;i++)
			{
				if(	(MeasuredNtscmSvCbChromaPhase[i].dblChromaPhase <	gdwColorBarLimitChromaPhase[i].dwChromaPhaseLowerLimit)||(MeasuredNtscmSvCbChromaPhase[i].dblChromaPhase>gdwColorBarLimitChromaPhase[i].dwChromaPhaseUpperLimit))
					bPass = FALSE;
			}
		}
		if(bPass)
			break;

	}//end retry loop

	//Now that we have the real data, report out the stats.
	//Report Statistic data of NTSC-M Svideo color bar for Luma IRE:
	ReportStatistic(NTSCM_SVIDEO_COLOR_BAR_LUMA_IRE_WHITE, _T("%.1f"),m_LumaIREWhite);
	ReportStatistic(NTSCM_SVIDEO_COLOR_BAR_LUMA_IRE_YELLOW, _T("%.1f"),m_LumaIREYellow);
	ReportStatistic(NTSCM_SVIDEO_COLOR_BAR_LUMA_IRE_CYAN, _T("%.1f"),m_LumaIRECyan);
	ReportStatistic(NTSCM_SVIDEO_COLOR_BAR_LUMA_IRE_GREEN, _T("%.1f"),m_LumaIREGreen);
	ReportStatistic(NTSCM_SVIDEO_COLOR_BAR_LUMA_IRE_MAGENTA, _T("%.1f"),m_LumaIREMagenta);
	ReportStatistic(NTSCM_SVIDEO_COLOR_BAR_LUMA_IRE_RED, _T("%.1f"),m_LumaIRERed);
	ReportStatistic(NTSCM_SVIDEO_COLOR_BAR_LUMA_IRE_BLUE, _T("%.1f"),m_LumaIREBlue);
	ReportStatistic(NTSCM_SVIDEO_COLOR_BAR_LUMA_IRE_BLACK, _T("%.1f"),m_LumaIREBlack);

	//Report Statistic data of NTSC-M Svideo color bar for Chroma IRE:
	ReportStatistic(NTSCM_SVIDEO_COLOR_BAR_CHROMA_IRE_WHITE, _T("%.1f"),m_ChromaIREWhite);
	ReportStatistic(NTSCM_SVIDEO_COLOR_BAR_CHROMA_IRE_YELLOW, _T("%.1f"),m_ChromaIREYellow);
	ReportStatistic(NTSCM_SVIDEO_COLOR_BAR_CHROMA_IRE_CYAN, _T("%.1f"),m_ChromaIRECyan);
	ReportStatistic(NTSCM_SVIDEO_COLOR_BAR_CHROMA_IRE_GREEN, _T("%.1f"),m_ChromaIREGreen);
	ReportStatistic(NTSCM_SVIDEO_COLOR_BAR_CHROMA_IRE_MAGENTA, _T("%.1f"),m_ChromaIREMagenta);
	ReportStatistic(NTSCM_SVIDEO_COLOR_BAR_CHROMA_IRE_RED, _T("%.1f"),m_ChromaIRERed);
	ReportStatistic(NTSCM_SVIDEO_COLOR_BAR_CHROMA_IRE_BLUE, _T("%.1f"),m_ChromaIREBlue);
	ReportStatistic(NTSCM_SVIDEO_COLOR_BAR_CHROMA_IRE_BLACK, _T("%.1f"),m_ChromaIREBlack);

	//Report Statistic data of NTSC-M Svideo color bar for Chroma Phase:
	//ReportStatistic(NTSCM_COMPOSITE_COLOR_BAR_CHROMA_IRE_WHITE, _T("%.1f"),m_ChromaIREWhite);
	ReportStatistic(NTSCM_SVIDEO_COLOR_BAR_CHROMA_PHASE_YELLOW, _T("%.1f"),m_ChromaPhaseYellow);
	ReportStatistic(NTSCM_SVIDEO_COLOR_BAR_CHROMA_PHASE_CYAN, _T("%.1f"),m_ChromaPhaseCyan);
	ReportStatistic(NTSCM_SVIDEO_COLOR_BAR_CHROMA_PHASE_GREEN, _T("%.1f"),m_ChromaPhaseGreen);
	ReportStatistic(NTSCM_SVIDEO_COLOR_BAR_CHROMA_PHASE_MAGENTA, _T("%.1f"),m_ChromaPhaseMagenta);
	ReportStatistic(NTSCM_SVIDEO_COLOR_BAR_CHROMA_PHASE_RED, _T("%.1f"),m_ChromaPhaseRed);
	ReportStatistic(NTSCM_SVIDEO_COLOR_BAR_CHROMA_PHASE_BLUE, _T("%.1f"),m_ChromaPhaseBlue);
	//ReportStatistic(NTSCM_COMPOSITE_COLOR_BAR_CHROMA_IRE_BLACK, _T("%.1f"),m_ChromaIREBlack);

	if(!bPass)
	{
		for (i=0;i<NUMBER_OF_CBARS;i++)
		{
			if(	(MeasuredNtscmSvCbLumaIRE[i].dblLumaIRE < gdwColorBarLimitLumaIRE[i].dwLumaIRELowerLimit)||(MeasuredNtscmSvCbLumaIRE[i].dblLumaIRE >=gdwColorBarLimitLumaIRE[i].dwLumaIREUpperLimit))
				err_LumaResultOutOfRange(i, MeasuredNtscmSvCbLumaIRE[i].dblLumaIRE,dbStandardNtscParams[i].dwStdNtscCbParamLumaIRE,gdwColorBarLimitLumaIRE[i].dwLumaIREUpperLimit,gdwColorBarLimitLumaIRE[i].dwLumaIRELowerLimit);
		}

		for(i=0;i<NUMBER_OF_CBARS;i++)
		{
			if(	(MeasuredNtscmSvCbChromaIRE[i].dblChromaIRE <gdwColorBarLimitChromaIRE[i].dwChromaIRELowerLimit)||(MeasuredNtscmSvCbChromaIRE[i].dblChromaIRE>gdwColorBarLimitChromaIRE[i].dwChromaIREUpperLimit))
				err_ChromaIREResultOutOfRange(i, MeasuredNtscmSvCbChromaIRE[i].dblChromaIRE, dbStandardNtscParams[i].dwStdNtscCbParamChromaIRE,gdwColorBarLimitChromaIRE[i].dwChromaIREUpperLimit,gdwColorBarLimitChromaIRE[i].dwChromaIRELowerLimit);	
		}

		for(i=0;i<NUMBER_OF_CBARS-2;i++)
		{
			if(	(MeasuredNtscmSvCbChromaPhase[i].dblChromaPhase <	gdwColorBarLimitChromaPhase[i].dwChromaPhaseLowerLimit)||(MeasuredNtscmSvCbChromaPhase[i].dblChromaPhase>gdwColorBarLimitChromaPhase[i].dwChromaPhaseUpperLimit))
				err_ChromaPhaseResultOutOfRange(i, MeasuredNtscmSvCbChromaPhase[i].dblChromaPhase, dbStandardNtscParams[i].dwStdNtscCbParamChromaPhase,gdwColorBarLimitChromaPhase[i].dwChromaPhaseUpperLimit,gdwColorBarLimitChromaPhase[i].dwChromaPhaseLowerLimit);
		}
	}
	Cleanup();
	return;
}


//ntsc-japan TV standard with Composite and s-video output sourse for Color Bars test
IMPLEMENT_TESTLOCKED (TV, ntscjcompcb, 3)
{
	
	#define STR_SIZE	32
	CHostResponse CHR;
	DWORD  dwMeasureResultBuffSize=EIACb_ELEMS*2*sizeof(DWORD);
	DWORD *dwMeasureResultBuff=new DWORD[dwMeasureResultBuffSize/(sizeof(DWORD))];
	char *send_buf = NULL;
	DWORD dwBufferToHostLength, dwActualBytesReceived, dwErrorCodeFromHost,i;
	int iError,videomode;
	dwBufferToHostLength=NULL;
	BOOL bPass = TRUE;

	if (CheckAbort (HERE)){ Cleanup(); return;};
	
	//Init arrays to hold measured values.
	NTSCM_COMP_CB_DATA MeasuredNtscjCompCbLumaIRE[NUMBER_OF_CBARS];
	NTSCM_COMP_CB_DATA MeasuredNtscjCompCbChromaIRE[NUMBER_OF_CBARS];
	NTSCM_COMP_CB_DATA MeasuredNtscjCompCbChromaPhase[NUMBER_OF_CBARS];
	
	videomode=GetCfgInt(L"videomode", 1);
	switch(videomode)
	{
	case 1:
		DrawNTSCCB();
		NTSCCBRender();
		break;
	case 3:
		DrawMode3NTSCCB();
		NTSCCBRender();
		break;


	default:
		break;
	}

	// Present the backbuffer contents to the display
    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );


	for(int attempts=0; attempts < m_testRetries; attempts++)
	{
		if ((iError = g_host.iSendHost(MID_NTSC_JAPAN_COMP_CB, send_buf, dwBufferToHostLength, CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, XTV_TIMEOUT)) != EVERYTHINGS_OK)
		{
			if (dwErrorCodeFromHost != 0)
			{
				// Process error from host
				err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost);
				return;
			}
			else
			{
				// Process a communication error
				// This test module just reports the number of the communication error that was received
				err_HostCommunicationError(iError);
				return;
			}
		}
		else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
		{
			// The response buffer is empty, so take appropriate action (like an error message)
			err_RecordBufferIsEmpty();
			return;
		}
		else // The response is not NULL, and is not an error message, so process it
		{
			if (dwActualBytesReceived < dwMeasureResultBuffSize)
			{
				err_RecordBufferIsNotCorrectLength(dwMeasureResultBuffSize, dwActualBytesReceived);
				return;
			}
		}

		memcpy(dwMeasureResultBuff, CHR.pvBufferFromHost, dwMeasureResultBuffSize); 

		// using string input to extract the datas in the measureresultbuff
		using namespace std;
		string input((char *)dwMeasureResultBuff);
		istringstream inputString(input);

		inputString >>m_LumaIREWhite		>>m_LumaIREYellow
					>>m_LumaIRECyan			>>m_LumaIREGreen
					>>m_LumaIREMagenta		>>m_LumaIRERed
					>>m_LumaIREBlue			>>m_LumaIREBlack
					>>m_ChromaIREWhite		>>m_ChromaIREYellow 
					>>m_ChromaIRECyan		>>m_ChromaIREGreen
					>>m_ChromaIREMagenta	>>m_ChromaIRERed 
					>>m_ChromaIREBlue		>>m_ChromaIREBlack
					>>m_ChromaPhaseYellow	>>m_ChromaPhaseCyan 
					>>m_ChromaPhaseGreen	>>m_ChromaPhaseMagenta
					>>m_ChromaPhaseRed		>>m_ChromaPhaseBlue;
					//>> m_ChromaPhaseBlack;

		MeasuredNtscjCompCbLumaIRE[0].dblLumaIRE=m_LumaIREWhite;
		MeasuredNtscjCompCbLumaIRE[1].dblLumaIRE= m_LumaIREYellow;
		MeasuredNtscjCompCbLumaIRE[2].dblLumaIRE= m_LumaIRECyan;
		MeasuredNtscjCompCbLumaIRE[3].dblLumaIRE= m_LumaIREGreen;
		MeasuredNtscjCompCbLumaIRE[4].dblLumaIRE= m_LumaIREMagenta;
		MeasuredNtscjCompCbLumaIRE[5].dblLumaIRE= m_LumaIRERed;
		MeasuredNtscjCompCbLumaIRE[6].dblLumaIRE= m_LumaIREBlue;
		MeasuredNtscjCompCbLumaIRE[7].dblLumaIRE= m_LumaIREBlack;

		MeasuredNtscjCompCbChromaIRE[0].dblChromaIRE= m_ChromaIREWhite;
		MeasuredNtscjCompCbChromaIRE[1].dblChromaIRE= m_ChromaIREYellow;
		MeasuredNtscjCompCbChromaIRE[2].dblChromaIRE= m_ChromaIRECyan;
		MeasuredNtscjCompCbChromaIRE[3].dblChromaIRE= m_ChromaIREGreen;
		MeasuredNtscjCompCbChromaIRE[4].dblChromaIRE= m_ChromaIREMagenta;
		MeasuredNtscjCompCbChromaIRE[5].dblChromaIRE= m_ChromaIRERed;
		MeasuredNtscjCompCbChromaIRE[6].dblChromaIRE= m_ChromaIREBlue;
		MeasuredNtscjCompCbChromaIRE[7].dblChromaIRE= m_ChromaIREBlack;

		//MeasuredNtscChromaPhase[0].dblChromaPhase= m_ChromaPhaseWhite;
		MeasuredNtscjCompCbChromaPhase[0].dblChromaPhase= m_ChromaPhaseYellow;
		MeasuredNtscjCompCbChromaPhase[1].dblChromaPhase= m_ChromaPhaseCyan;
		MeasuredNtscjCompCbChromaPhase[2].dblChromaPhase= m_ChromaPhaseGreen;
		MeasuredNtscjCompCbChromaPhase[3].dblChromaPhase= m_ChromaPhaseMagenta;
		MeasuredNtscjCompCbChromaPhase[4].dblChromaPhase= m_ChromaPhaseRed;
		MeasuredNtscjCompCbChromaPhase[5].dblChromaPhase= m_ChromaPhaseBlue;
		//MeasuredNtscChromaPhase[7].dblChromaPhase= m_ChromaPhaseBlack;

		bPass = TRUE;
		for(i=0;i<NUMBER_OF_CBARS;i++)
		{
			if(	(MeasuredNtscjCompCbLumaIRE[i].dblLumaIRE < gdwJapanCBLumaIRE[i].dwJapanLumaLower)||(MeasuredNtscjCompCbLumaIRE[i].dblLumaIRE > gdwJapanCBLumaIRE[i].dwJapanLumaUpper))
				bPass = FALSE;
		}

		if(bPass)
		{
			for(i=0;i<NUMBER_OF_CBARS;i++)
			{
				if(	(MeasuredNtscjCompCbChromaIRE[i].dblChromaIRE<	gdwColorBarLimitChromaIRE[i].dwChromaIRELowerLimit)||(MeasuredNtscjCompCbChromaIRE[i].dblChromaIRE>gdwColorBarLimitChromaIRE[i].dwChromaIREUpperLimit))
					bPass = FALSE;
			}
		}
		if(bPass)
		{
			for(i=0;i<NUMBER_OF_CBARS-2;i++)
			{
				if(	(MeasuredNtscjCompCbChromaPhase[i].dblChromaPhase<	gdwColorBarLimitChromaPhase[i].dwChromaPhaseLowerLimit)||(MeasuredNtscjCompCbChromaPhase[i].dblChromaPhase>gdwColorBarLimitChromaPhase[i].dwChromaPhaseUpperLimit))
	 				bPass = FALSE;
			}
		}
		if(bPass)
			break;
	}//end retry loop

	//Report Statistic data of NTSC-M Composite color bar for Luma IRE:
	ReportStatistic(NTSCJ_COMPOSITE_COLOR_BAR_LUMA_IRE_WHITE, _T("%.1f"),m_LumaIREWhite);
	ReportStatistic(NTSCJ_COMPOSITE_COLOR_BAR_LUMA_IRE_YELLOW, _T("%.1f"),m_LumaIREYellow);
	ReportStatistic(NTSCJ_COMPOSITE_COLOR_BAR_LUMA_IRE_CYAN, _T("%.1f"),m_LumaIRECyan);
	ReportStatistic(NTSCJ_COMPOSITE_COLOR_BAR_LUMA_IRE_GREEN, _T("%.1f"),m_LumaIREGreen);
	ReportStatistic(NTSCJ_COMPOSITE_COLOR_BAR_LUMA_IRE_MAGENTA, _T("%.1f"),m_LumaIREMagenta);
	ReportStatistic(NTSCJ_COMPOSITE_COLOR_BAR_LUMA_IRE_RED, _T("%.1f"),m_LumaIRERed);
	ReportStatistic(NTSCJ_COMPOSITE_COLOR_BAR_LUMA_IRE_BLUE, _T("%.1f"),m_LumaIREBlue);
	ReportStatistic(NTSCJ_COMPOSITE_COLOR_BAR_LUMA_IRE_BLACK, _T("%.1f"),m_LumaIREBlack);

	//Report Statistic data of NTSC-M Composite color bar for Chroma IRE:
	ReportStatistic(NTSCJ_COMPOSITE_COLOR_BAR_CHROMA_IRE_WHITE, _T("%.1f"),m_ChromaIREWhite);
	ReportStatistic(NTSCJ_COMPOSITE_COLOR_BAR_CHROMA_IRE_YELLOW, _T("%.1f"),m_ChromaIREYellow);
	ReportStatistic(NTSCJ_COMPOSITE_COLOR_BAR_CHROMA_IRE_CYAN, _T("%.1f"),m_ChromaIRECyan);
	ReportStatistic(NTSCJ_COMPOSITE_COLOR_BAR_CHROMA_IRE_GREEN, _T("%.1f"),m_ChromaIREGreen);
	ReportStatistic(NTSCJ_COMPOSITE_COLOR_BAR_CHROMA_IRE_MAGENTA, _T("%.1f"),m_ChromaIREMagenta);
	ReportStatistic(NTSCJ_COMPOSITE_COLOR_BAR_CHROMA_IRE_RED, _T("%.1f"),m_ChromaIRERed);
	ReportStatistic(NTSCJ_COMPOSITE_COLOR_BAR_CHROMA_IRE_BLUE, _T("%.1f"),m_ChromaIREBlue);
	ReportStatistic(NTSCJ_COMPOSITE_COLOR_BAR_CHROMA_IRE_BLACK, _T("%.1f"),m_ChromaIREBlack);


	//Report Statistic data of NTSC-M Composite color bar for Chroma Phase:
	//ReportStatistic(NTSCJ_COMPOSITE_COLOR_BAR_CHROMA_IRE_WHITE, _T("%.1f"),m_ChromaIREWhite);
	ReportStatistic(NTSCJ_COMPOSITE_COLOR_BAR_CHROMA_PHASE_YELLOW, _T("%.1f"),m_ChromaPhaseYellow);
	ReportStatistic(NTSCJ_COMPOSITE_COLOR_BAR_CHROMA_PHASE_CYAN, _T("%.1f"),m_ChromaPhaseCyan);
	ReportStatistic(NTSCJ_COMPOSITE_COLOR_BAR_CHROMA_PHASE_GREEN, _T("%.1f"),m_ChromaPhaseGreen);
	ReportStatistic(NTSCJ_COMPOSITE_COLOR_BAR_CHROMA_PHASE_MAGENTA, _T("%.1f"),m_ChromaPhaseMagenta);
	ReportStatistic(NTSCJ_COMPOSITE_COLOR_BAR_CHROMA_PHASE_RED, _T("%.1f"),m_ChromaPhaseRed);
	ReportStatistic(NTSCJ_COMPOSITE_COLOR_BAR_CHROMA_PHASE_BLUE, _T("%.1f"),m_ChromaPhaseBlue);
	//ReportStatistic(NTSCJ_COMPOSITE_COLOR_BAR_CHROMA_IRE_BLACK, _T("%.1f"),m_ChromaIREBlack);

	if(!bPass)
	{
		for(i=0;i<NUMBER_OF_CBARS;i++)
		{
			if(	(MeasuredNtscjCompCbLumaIRE[i].dblLumaIRE < gdwJapanCBLumaIRE[i].dwJapanLumaLower)||(MeasuredNtscjCompCbLumaIRE[i].dblLumaIRE > gdwJapanCBLumaIRE[i].dwJapanLumaUpper))
				err_LumaResultOutOfRange(i,MeasuredNtscjCompCbLumaIRE[i].dblLumaIRE,dbStandardNtscParams[i].dwStdNtscJapanCbParamLumaIRE,gdwJapanCBLumaIRE[i].dwJapanLumaUpper,	gdwJapanCBLumaIRE[i].dwJapanLumaLower);
		}
		for(i=0;i<NUMBER_OF_CBARS;i++)
		{
			if(	(MeasuredNtscjCompCbChromaIRE[i].dblChromaIRE<	gdwColorBarLimitChromaIRE[i].dwChromaIRELowerLimit)||(MeasuredNtscjCompCbChromaIRE[i].dblChromaIRE>gdwColorBarLimitChromaIRE[i].dwChromaIREUpperLimit))
				err_ChromaIREResultOutOfRange(i,MeasuredNtscjCompCbChromaIRE[i].dblChromaIRE, dbStandardNtscParams[i].dwStdNtscCbParamChromaIRE,gdwColorBarLimitChromaIRE[i].dwChromaIREUpperLimit,gdwColorBarLimitChromaIRE[i].dwChromaIRELowerLimit);
		}
		for(i=0;i<NUMBER_OF_CBARS-2;i++)
		{
			if(	(MeasuredNtscjCompCbChromaPhase[i].dblChromaPhase<	gdwColorBarLimitChromaPhase[i].dwChromaPhaseLowerLimit)||(MeasuredNtscjCompCbChromaPhase[i].dblChromaPhase>gdwColorBarLimitChromaPhase[i].dwChromaPhaseUpperLimit))
	 			err_ChromaPhaseResultOutOfRange(i,MeasuredNtscjCompCbChromaPhase[i].dblChromaPhase, dbStandardNtscParams[i].dwStdNtscCbParamChromaPhase,gdwColorBarLimitChromaPhase[i].dwChromaPhaseUpperLimit,gdwColorBarLimitChromaPhase[i].dwChromaPhaseLowerLimit);
		}
	}

	Cleanup();
	return;
}





IMPLEMENT_TESTLOCKED (TV, ntscjsvcb, 4)
{

	CHostResponse CHR;
	char *send_buf = NULL;
	DWORD  dwMeasureResultBuffSize=EIACb_ELEMS*2*sizeof(DWORD);;
	DWORD *dwMeasureResultBuff=new DWORD[dwMeasureResultBuffSize/(sizeof(DWORD))];
	DWORD dwBufferToHostLength, dwActualBytesReceived, dwErrorCodeFromHost,i=0;
	int iError,videomode;
	dwBufferToHostLength=NULL;
	BOOL bPass = TRUE;
	
	if (CheckAbort (HERE)){ Cleanup(); return;};

	//init arrays to hold measured values.
	NTSCM_SV_CB_DATA MeasuredNtscjSvCbLumaIRE[NUMBER_OF_CBARS];
	NTSCM_SV_CB_DATA MeasuredNtscjSvCbChromaIRE[NUMBER_OF_CBARS];
	NTSCM_SV_CB_DATA MeasuredNtscjSvCbChromaPhase[NUMBER_OF_CBARS];
		
	videomode=GetCfgInt(L"videomode", 1);
	switch(videomode)
	{
		case 1:
			DrawNTSCCB();
			NTSCCBRender();
			break;
		case 3:
			DrawMode3NTSCCB();
			NTSCCBRender();
			break;

		default:
			break;
	}

    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );

	for(int attempts=0; attempts < m_testRetries; attempts++)
	{
		if ((iError = g_host.iSendHost(MID_NTSC_JAPAN_SVIDEO_CB, send_buf, dwBufferToHostLength, CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, XTV_TIMEOUT)) != EVERYTHINGS_OK)
		{
			if (dwErrorCodeFromHost != 0)
			{
				// Process error from host
				if (err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost))
					return;
			}
			else
			{
				if (err_HostCommunicationError(iError))
					return;
			}
		}
		else if (CHR.pvBufferFromHost == NULL) 
		{
			if (err_EchoBufferResponseIsNull())
				return;
		}
		else // The response is not NULL, and is not an error message, so process it
		{
			if (dwActualBytesReceived < dwMeasureResultBuffSize)
			{
				err_RecordBufferIsNotCorrectLength(dwMeasureResultBuffSize, dwActualBytesReceived);
				return;
			}
			// We received the measure resutls buffer the size that we wanted
		}

		memcpy(dwMeasureResultBuff, CHR.pvBufferFromHost, dwMeasureResultBuffSize); 

		// using string input to extract the datas
		using namespace std;
		string input((char *)dwMeasureResultBuff);
		istringstream inputString(input);

		inputString >>m_LumaIREWhite		>>m_LumaIREYellow
					>>m_LumaIRECyan			>>m_LumaIREGreen
					>>m_LumaIREMagenta		>>m_LumaIRERed
					>>m_LumaIREBlue			>>m_LumaIREBlack
					>>m_ChromaIREWhite		>>m_ChromaIREYellow
					>>m_ChromaIRECyan		>>m_ChromaIREGreen
					>>m_ChromaIREMagenta	>>m_ChromaIRERed 
					>>m_ChromaIREBlue		>>m_ChromaIREBlack
					>>m_ChromaPhaseYellow	>>m_ChromaPhaseCyan
					>>m_ChromaPhaseGreen	>>m_ChromaPhaseMagenta
					>>m_ChromaPhaseRed		>>m_ChromaPhaseBlue;
					//>> m_ChromaPhaseBlack;

		MeasuredNtscjSvCbLumaIRE[0].dblLumaIRE=m_LumaIREWhite;
		MeasuredNtscjSvCbLumaIRE[1].dblLumaIRE= m_LumaIREYellow;
		MeasuredNtscjSvCbLumaIRE[2].dblLumaIRE= m_LumaIRECyan;
		MeasuredNtscjSvCbLumaIRE[3].dblLumaIRE= m_LumaIREGreen;
		MeasuredNtscjSvCbLumaIRE[4].dblLumaIRE= m_LumaIREMagenta;
		MeasuredNtscjSvCbLumaIRE[5].dblLumaIRE= m_LumaIRERed;
		MeasuredNtscjSvCbLumaIRE[6].dblLumaIRE= m_LumaIREBlue;
		MeasuredNtscjSvCbLumaIRE[7].dblLumaIRE= m_LumaIREBlack;

		MeasuredNtscjSvCbChromaIRE[0].dblChromaIRE= m_ChromaIREWhite;
		MeasuredNtscjSvCbChromaIRE[1].dblChromaIRE= m_ChromaIREYellow;
		MeasuredNtscjSvCbChromaIRE[2].dblChromaIRE= m_ChromaIRECyan;
		MeasuredNtscjSvCbChromaIRE[3].dblChromaIRE= m_ChromaIREGreen;
		MeasuredNtscjSvCbChromaIRE[4].dblChromaIRE= m_ChromaIREMagenta;
		MeasuredNtscjSvCbChromaIRE[5].dblChromaIRE= m_ChromaIRERed;
		MeasuredNtscjSvCbChromaIRE[6].dblChromaIRE= m_ChromaIREBlue;
		MeasuredNtscjSvCbChromaIRE[7].dblChromaIRE= m_ChromaIREBlack;

		//MeasuredNtscChromaPhase[0].dblChromaPhase= m_ChromaPhaseWhite;
		MeasuredNtscjSvCbChromaPhase[0].dblChromaPhase= m_ChromaPhaseYellow;
		MeasuredNtscjSvCbChromaPhase[1].dblChromaPhase= m_ChromaPhaseCyan;
		MeasuredNtscjSvCbChromaPhase[2].dblChromaPhase= m_ChromaPhaseGreen;
		MeasuredNtscjSvCbChromaPhase[3].dblChromaPhase= m_ChromaPhaseMagenta;
		MeasuredNtscjSvCbChromaPhase[4].dblChromaPhase= m_ChromaPhaseRed;
		MeasuredNtscjSvCbChromaPhase[5].dblChromaPhase= m_ChromaPhaseBlue;
		//MeasuredNtscChromaPhase[7].dblChromaPhase= m_ChromaPhaseBlack;
		
		bPass = TRUE;
		for (i=0;i<NUMBER_OF_CBARS;i++)
		{
			if(	(MeasuredNtscjSvCbLumaIRE[i].dblLumaIRE < 	gdwJapanCBLumaIRE[i].dwJapanLumaLower)||(MeasuredNtscjSvCbLumaIRE[i].dblLumaIRE >=	gdwJapanCBLumaIRE[i].dwJapanLumaUpper))
			bPass = FALSE;
		}
		if(bPass)
		{
			for(i=0;i<NUMBER_OF_CBARS;i++)
			{
				if(	(MeasuredNtscjSvCbChromaIRE[i].dblChromaIRE <gdwColorBarLimitChromaIRE[i].dwChromaIRELowerLimit)||(MeasuredNtscjSvCbChromaIRE[i].dblChromaIRE>gdwColorBarLimitChromaIRE[i].dwChromaIREUpperLimit))
					bPass = FALSE;	
			}
		}
		if(bPass)
		{
			for(i=0;i<NUMBER_OF_CBARS-2;i++)
			{
				if(	(MeasuredNtscjSvCbChromaPhase[i].dblChromaPhase <	gdwColorBarLimitChromaPhase[i].dwChromaPhaseLowerLimit)||(MeasuredNtscjSvCbChromaPhase[i].dblChromaPhase>gdwColorBarLimitChromaPhase[i].dwChromaPhaseUpperLimit))
					bPass = FALSE;
			}			
		}

		if(bPass)
			break;
	
	}//end retry loop
	
	//Report Statistic data of NTSC-Japan Svideo color bar for Luma IRE:
	ReportStatistic(NTSCJ_SVIDEO_COLOR_BAR_LUMA_IRE_WHITE, _T("%.1f"),m_LumaIREWhite);
	ReportStatistic(NTSCJ_SVIDEO_COLOR_BAR_LUMA_IRE_YELLOW, _T("%.1f"),m_LumaIREYellow);
	ReportStatistic(NTSCJ_SVIDEO_COLOR_BAR_LUMA_IRE_CYAN, _T("%.1f"),m_LumaIRECyan);
	ReportStatistic(NTSCJ_SVIDEO_COLOR_BAR_LUMA_IRE_GREEN, _T("%.1f"),m_LumaIREGreen);
	ReportStatistic(NTSCJ_SVIDEO_COLOR_BAR_LUMA_IRE_MAGENTA, _T("%.1f"),m_LumaIREMagenta);
	ReportStatistic(NTSCJ_SVIDEO_COLOR_BAR_LUMA_IRE_RED, _T("%.1f"),m_LumaIRERed);
	ReportStatistic(NTSCJ_SVIDEO_COLOR_BAR_LUMA_IRE_BLUE, _T("%.1f"),m_LumaIREBlue);
	ReportStatistic(NTSCJ_SVIDEO_COLOR_BAR_LUMA_IRE_BLACK, _T("%.1f"),m_LumaIREBlack);

	//Report Statistic data of NTSC-Japan Svideo color bar for Chroma IRE:
	ReportStatistic(NTSCJ_SVIDEO_COLOR_BAR_CHROMA_IRE_WHITE, _T("%.1f"),m_ChromaIREWhite);
	ReportStatistic(NTSCJ_SVIDEO_COLOR_BAR_CHROMA_IRE_YELLOW, _T("%.1f"),m_ChromaIREYellow);
	ReportStatistic(NTSCJ_SVIDEO_COLOR_BAR_CHROMA_IRE_CYAN, _T("%.1f"),m_ChromaIRECyan);
	ReportStatistic(NTSCJ_SVIDEO_COLOR_BAR_CHROMA_IRE_GREEN, _T("%.1f"),m_ChromaIREGreen);
	ReportStatistic(NTSCJ_SVIDEO_COLOR_BAR_CHROMA_IRE_MAGENTA, _T("%.1f"),m_ChromaIREMagenta);
	ReportStatistic(NTSCJ_SVIDEO_COLOR_BAR_CHROMA_IRE_RED, _T("%.1f"),m_ChromaIRERed);
	ReportStatistic(NTSCJ_SVIDEO_COLOR_BAR_CHROMA_IRE_BLUE, _T("%.1f"),m_ChromaIREBlue);
	ReportStatistic(NTSCJ_SVIDEO_COLOR_BAR_CHROMA_IRE_BLACK, _T("%.1f"),m_ChromaIREBlack);


	//Report Statistic data of NTSC-Japan Svideo color bar for Chroma Phase:
	//ReportStatistic(NTSCJ_COMPOSITE_COLOR_BAR_CHROMA_IRE_WHITE, _T("%.1f"),m_ChromaIREWhite);
	ReportStatistic(NTSCJ_SVIDEO_COLOR_BAR_CHROMA_PHASE_YELLOW, _T("%.1f"),m_ChromaPhaseYellow);
	ReportStatistic(NTSCJ_SVIDEO_COLOR_BAR_CHROMA_PHASE_CYAN, _T("%.1f"),m_ChromaPhaseCyan);
	ReportStatistic(NTSCJ_SVIDEO_COLOR_BAR_CHROMA_PHASE_GREEN, _T("%.1f"),m_ChromaPhaseGreen);
	ReportStatistic(NTSCJ_SVIDEO_COLOR_BAR_CHROMA_PHASE_MAGENTA, _T("%.1f"),m_ChromaPhaseMagenta);
	ReportStatistic(NTSCJ_SVIDEO_COLOR_BAR_CHROMA_PHASE_RED, _T("%.1f"),m_ChromaPhaseRed);
	ReportStatistic(NTSCJ_SVIDEO_COLOR_BAR_CHROMA_PHASE_BLUE, _T("%.1f"),m_ChromaPhaseBlue);
	//ReportStatistic(NTSCJ_COMPOSITE_COLOR_BAR_CHROMA_IRE_BLACK, _T("%.1f"),m_ChromaIREBlack);

	if(!bPass)
	{
		for (i=0;i<NUMBER_OF_CBARS;i++)
		{
			if(	(MeasuredNtscjSvCbLumaIRE[i].dblLumaIRE < 	gdwJapanCBLumaIRE[i].dwJapanLumaLower)||(MeasuredNtscjSvCbLumaIRE[i].dblLumaIRE >=	gdwJapanCBLumaIRE[i].dwJapanLumaUpper))
				err_LumaResultOutOfRange(i, MeasuredNtscjSvCbLumaIRE[i].dblLumaIRE,dbStandardNtscParams[i].dwStdNtscCbParamLumaIRE,	gdwJapanCBLumaIRE[i].dwJapanLumaUpper,	gdwJapanCBLumaIRE[i].dwJapanLumaLower);
		}
		for(i=0;i<NUMBER_OF_CBARS;i++)
		{
			if(	(MeasuredNtscjSvCbChromaIRE[i].dblChromaIRE <gdwColorBarLimitChromaIRE[i].dwChromaIRELowerLimit)||(MeasuredNtscjSvCbChromaIRE[i].dblChromaIRE>gdwColorBarLimitChromaIRE[i].dwChromaIREUpperLimit))
				err_ChromaIREResultOutOfRange(i, MeasuredNtscjSvCbChromaIRE[i].dblChromaIRE, dbStandardNtscParams[i].dwStdNtscCbParamChromaIRE,gdwColorBarLimitChromaIRE[i].dwChromaIREUpperLimit,gdwColorBarLimitChromaIRE[i].dwChromaIRELowerLimit);	
		}
		for(i=0;i<NUMBER_OF_CBARS-2;i++)
		{
			if(	(MeasuredNtscjSvCbChromaPhase[i].dblChromaPhase <	gdwColorBarLimitChromaPhase[i].dwChromaPhaseLowerLimit)||(MeasuredNtscjSvCbChromaPhase[i].dblChromaPhase>gdwColorBarLimitChromaPhase[i].dwChromaPhaseUpperLimit))
				err_ChromaPhaseResultOutOfRange(i, MeasuredNtscjSvCbChromaPhase[i].dblChromaPhase, dbStandardNtscParams[i].dwStdNtscCbParamChromaPhase,gdwColorBarLimitChromaPhase[i].dwChromaPhaseUpperLimit,gdwColorBarLimitChromaPhase[i].dwChromaPhaseLowerLimit);
		}
	}

	Cleanup();
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xtv\ntscmb.cpp ===
// 
// (c) Copyright 2000-2000 Intel Corp. All rights reserved.
//   ntscmb.cpp: used to implement ntsc-m and ntsc-Japan multiburst 
//   tests for composite and s-video output. The subtests include 
//	ntscmcompmb, ntscmsvmb, ntscjcompmb, and ntscjsvmb
//
//////////////////////////////////////////////////////////////////////
#include "..\stdafx.h"
#include <iostream>
#include <string>
#include <sstream>

#include "XTV.h"
#include "..\statkeys.h"


#define EIACb_ELEMS 8


IMPLEMENT_TESTLOCKED (TV, ntscmcompmb, 13)
{

	CHostResponse CHR;
	DWORD  dwMeasureResultBuffSize=EIACb_ELEMS*2*sizeof(DWORD);
	DWORD *dwMeasureResultBuff=new DWORD[dwMeasureResultBuffSize/(sizeof(DWORD))];
	char *send_buf = NULL;
	DWORD dwBufferToHostLength, dwActualBytesReceived, dwErrorCodeFromHost,i;
	int iError,videomode;
	dwBufferToHostLength=NULL;
	BOOL bPass = TRUE;

	if (CheckAbort (HERE)){ Cleanup(); return;};

	MULTIBURST_CONFIG_DATA MeasuredNtscmCompMb[NUMBER_OF_FREQ];

	videomode=GetCfgInt(L"videomode", 1);

	switch(videomode)
	{
		case 1:
			DrawNTSCMB();
			NTSCMBRender();
			break;
		case 3:
			DrawMode3NTSCMB();
			NTSCMBRender();
			break;
		default:
			break;
	}

    // Present the backbuffer contents to the display
    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
	
	//Sleep(1000);
	
	for(int attempts=0; attempts < m_testRetries; attempts++)
	{
		if ((iError = g_host.iSendHost(MID_NTSC_M_COMP_MB, send_buf, dwBufferToHostLength, CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, XTV_TIMEOUT)) != EVERYTHINGS_OK)
		{
			if (dwErrorCodeFromHost != 0)
			{
				// Process error from host
				err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost);
				return;
			}
			else
			{
				// Process a communication error
				// This test module just reports the number of the communication error that was received
				err_HostCommunicationError(iError);
				return;
			}
		}
		else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
		{
			// The response buffer is empty, so take appropriate action (like an error message)
			err_RecordBufferIsEmpty();
			return;
		}
		else // The response is not NULL, and is not an error message, so process it
		{
			if (dwActualBytesReceived < dwMeasureResultBuffSize)
			{
				err_RecordBufferIsNotCorrectLength(dwMeasureResultBuffSize, dwActualBytesReceived);
				return;
			}
		}

		memcpy(dwMeasureResultBuff, CHR.pvBufferFromHost, dwMeasureResultBuffSize); 

		using namespace std;
		string input((char *)dwMeasureResultBuff);
		istringstream inputString(input);
		
		inputString >> m_NtscmFreq1>>m_NtscmFreq2>>m_NtscmFreq3
					>> m_NtscmFreq4>>m_NtscmFreq5>> m_NtscmFreq6>> m_NtscmFreq7;

		bPass = TRUE;
		if(m_NtscmFreq2>MAXATTENU) MeasuredNtscmCompMb[0].dbFreqResponse=m_NtscmFreq2;
		else MeasuredNtscmCompMb[0].dbFreqResponse=0.0;

		if(m_NtscmFreq3>MAXATTENU) MeasuredNtscmCompMb[1].dbFreqResponse=m_NtscmFreq3;
		else MeasuredNtscmCompMb[1].dbFreqResponse=0.0;

		if(m_NtscmFreq4>MAXATTENU) MeasuredNtscmCompMb[2].dbFreqResponse=m_NtscmFreq4;
		else MeasuredNtscmCompMb[2].dbFreqResponse=0.0;

		if(m_NtscmFreq5>MAXATTENU) MeasuredNtscmCompMb[3].dbFreqResponse=m_NtscmFreq5;
		else MeasuredNtscmCompMb[3].dbFreqResponse=0.0;

		if(m_NtscmFreq6>MAXATTENU) MeasuredNtscmCompMb[4].dbFreqResponse=m_NtscmFreq6;
		else MeasuredNtscmCompMb[4].dbFreqResponse=0.0;

		if(m_NtscmFreq7>MAXATTENU) MeasuredNtscmCompMb[5].dbFreqResponse=m_NtscmFreq7;
		else MeasuredNtscmCompMb[5].dbFreqResponse=0.0;
	
		for(i=0;i<NUMBER_OF_FREQ;i++)
		{
			if((MeasuredNtscmCompMb[i].dbFreqResponse<dbFreqLimit[i].NtscCompLowerLimit) || (MeasuredNtscmCompMb[i].dbFreqResponse>dbFreqLimit[i].NtscCompUpperLimit))
				bPass = FALSE;
		}

		if(bPass)
			break;

	}//end retry loop

	ReportStatistic(NTSCM_COMPOSITE_MULTIBURST_FREQUEN_PACKET1,_T("%.1f"), MeasuredNtscmCompMb[0].dbFreqResponse);
	ReportStatistic(NTSCM_COMPOSITE_MULTIBURST_FREQUEN_PACKET2,_T("%.1f"), MeasuredNtscmCompMb[1].dbFreqResponse);
	ReportStatistic(NTSCM_COMPOSITE_MULTIBURST_FREQUEN_PACKET3,_T("%.1f"), MeasuredNtscmCompMb[2].dbFreqResponse);
	ReportStatistic(NTSCM_COMPOSITE_MULTIBURST_FREQUEN_PACKET4,_T("%.1f"), MeasuredNtscmCompMb[3].dbFreqResponse);
	ReportStatistic(NTSCM_COMPOSITE_MULTIBURST_FREQUEN_PACKET5,_T("%.1f"), MeasuredNtscmCompMb[4].dbFreqResponse);
	ReportStatistic(NTSCM_COMPOSITE_MULTIBURST_FREQUEN_PACKET6,_T("%.1f"), MeasuredNtscmCompMb[5].dbFreqResponse);

	if(!bPass)
	{
		if((MeasuredNtscmCompMb[0].dbFreqResponse==0.0)&&
					(MeasuredNtscmCompMb[1].dbFreqResponse==0.0)&&
					(MeasuredNtscmCompMb[2].dbFreqResponse==0.0)&&
					(MeasuredNtscmCompMb[3].dbFreqResponse==0.0)&&
					(MeasuredNtscmCompMb[4].dbFreqResponse==0.0)&&
					(MeasuredNtscmCompMb[5].dbFreqResponse==0.0) )
		{
				err_NoConnection();
		}
		else
		{
			for(i=0;i<NUMBER_OF_FREQ;i++)
			{
				if((MeasuredNtscmCompMb[i].dbFreqResponse<dbFreqLimit[i].NtscCompLowerLimit) || (MeasuredNtscmCompMb[i].dbFreqResponse>dbFreqLimit[i].NtscCompUpperLimit))
					err_MBurstResultOutOfRange (i+1,MeasuredNtscmCompMb[i].dbFreqResponse,dbFreqLimit[i].NtscCompLowerLimit, dbFreqLimit[i].NtscCompUpperLimit );
			}
		}
	}

	Cleanup();
	return;
}



IMPLEMENT_TESTLOCKED (TV, ntscmsvmb, 14)
{
	CHostResponse CHR;
	DWORD  dwMeasureResultBuffSize=EIACb_ELEMS*2*sizeof(DWORD);
	DWORD *dwMeasureResultBuff=new DWORD[dwMeasureResultBuffSize/(sizeof(DWORD))];
	char *send_buf = NULL;
	DWORD dwBufferToHostLength, dwActualBytesReceived, dwErrorCodeFromHost,i;
	int iError, videomode;
	dwBufferToHostLength=NULL;
	BOOL bPass = TRUE;

	if (CheckAbort (HERE)){ Cleanup(); return;};

	MULTIBURST_CONFIG_DATA MeasuredNtscmSvMb[NUMBER_OF_FREQ];

	videomode=GetCfgInt(L"videomode", 1);

	switch(videomode)
	{
		case 1:
			DrawNTSCMB();
			NTSCMBRender();
			break;
		case 3:
			DrawMode3NTSCMB();
			NTSCMBRender();
			break;
		default:
			break;
	}

    // Present the backbuffer contents to the display
    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
   
 	for(int attempts=0; attempts < m_testRetries; attempts++)
	{
		if ((iError = g_host.iSendHost(MID_NTSC_M_SVIDEO_MB, send_buf, dwBufferToHostLength, CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, XTV_TIMEOUT)) != EVERYTHINGS_OK)
		{
			if (dwErrorCodeFromHost != 0)
			{
				// Process error from host
				err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost);
				return;
			}
			else
			{
				// Process a communication error
				// This test module just reports the number of the communication error that was received
				err_HostCommunicationError(iError);
				return;
			}
		}
		else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
		{
			// The response buffer is empty, so take appropriate action (like an error message)
			err_RecordBufferIsEmpty();
			return;
		}
		else // The response is not NULL, and is not an error message, so process it
		{
			if (dwActualBytesReceived < dwMeasureResultBuffSize)
			{
				err_RecordBufferIsNotCorrectLength(dwMeasureResultBuffSize, dwActualBytesReceived);
				return;
			}
		}
	
		memcpy(dwMeasureResultBuff, CHR.pvBufferFromHost, dwMeasureResultBuffSize); 

		using namespace std;
		string input((char *)dwMeasureResultBuff);
		istringstream inputString(input);
		inputString >>m_NtscmFreq1>>m_NtscmFreq2>>m_NtscmFreq3>>m_NtscmFreq4
					>>m_NtscmFreq5>>m_NtscmFreq6>>m_NtscmFreq7;

		if(m_NtscmFreq2>MAXATTENU) MeasuredNtscmSvMb[0].dbFreqResponse=m_NtscmFreq2;
		else MeasuredNtscmSvMb[0].dbFreqResponse=0.0;

		if(m_NtscmFreq3>MAXATTENU) MeasuredNtscmSvMb[1].dbFreqResponse=m_NtscmFreq3;
		else MeasuredNtscmSvMb[1].dbFreqResponse=0.0;

		if(m_NtscmFreq4>MAXATTENU) MeasuredNtscmSvMb[2].dbFreqResponse=m_NtscmFreq4;
		else MeasuredNtscmSvMb[2].dbFreqResponse=0.0;

		if(m_NtscmFreq5>MAXATTENU) MeasuredNtscmSvMb[3].dbFreqResponse=m_NtscmFreq5;
		else MeasuredNtscmSvMb[3].dbFreqResponse=0.0;

		if(m_NtscmFreq6>MAXATTENU) MeasuredNtscmSvMb[4].dbFreqResponse=m_NtscmFreq6;
		else MeasuredNtscmSvMb[4].dbFreqResponse=0.0;

		if(m_NtscmFreq7>MAXATTENU) MeasuredNtscmSvMb[5].dbFreqResponse=m_NtscmFreq7;
		else MeasuredNtscmSvMb[5].dbFreqResponse=0.0;

		bPass = TRUE;
		for(i=0;i<NUMBER_OF_FREQ;i++)
		{
			if((MeasuredNtscmSvMb[i].dbFreqResponse<dbFreqLimit[i].NtscCompLowerLimit) || (MeasuredNtscmSvMb[i].dbFreqResponse>dbFreqLimit[i].NtscCompUpperLimit))
				bPass = FALSE;
		}

		if(bPass)
			break;

	}//end retry loop
	
	ReportStatistic(NTSCM_SVIDEO_MULTIBURST_FREQUEN_PACKET1,_T("%.1f"), MeasuredNtscmSvMb[0].dbFreqResponse);
	ReportStatistic(NTSCM_SVIDEO_MULTIBURST_FREQUEN_PACKET2,_T("%.1f"), MeasuredNtscmSvMb[1].dbFreqResponse);
	ReportStatistic(NTSCM_SVIDEO_MULTIBURST_FREQUEN_PACKET3,_T("%.1f"), MeasuredNtscmSvMb[2].dbFreqResponse);
	ReportStatistic(NTSCM_SVIDEO_MULTIBURST_FREQUEN_PACKET4,_T("%.1f"), MeasuredNtscmSvMb[3].dbFreqResponse);
	ReportStatistic(NTSCM_SVIDEO_MULTIBURST_FREQUEN_PACKET5,_T("%.1f"), MeasuredNtscmSvMb[4].dbFreqResponse);
	ReportStatistic(NTSCM_SVIDEO_MULTIBURST_FREQUEN_PACKET6,_T("%.1f"), MeasuredNtscmSvMb[5].dbFreqResponse);

	if(!bPass)
	{
		if((MeasuredNtscmSvMb[0].dbFreqResponse==0.0)&&(MeasuredNtscmSvMb[1].dbFreqResponse==0.0)&&(MeasuredNtscmSvMb[2].dbFreqResponse==0.0)&&(MeasuredNtscmSvMb[3].dbFreqResponse==0.0)&&(MeasuredNtscmSvMb[4].dbFreqResponse==0.0)&&(MeasuredNtscmSvMb[5].dbFreqResponse==0.0))
		   err_NoConnection();
		
		else
		{
			for(i=0;i<NUMBER_OF_FREQ;i++)
			{
				if((MeasuredNtscmSvMb[i].dbFreqResponse<dbFreqLimit[i].NtscCompLowerLimit) || (MeasuredNtscmSvMb[i].dbFreqResponse>dbFreqLimit[i].NtscCompUpperLimit))
					err_MBurstResultOutOfRange (i+1,MeasuredNtscmSvMb[i].dbFreqResponse,dbFreqLimit[i].NtscCompLowerLimit, dbFreqLimit[i].NtscCompUpperLimit );
			}
		}
	}

	Cleanup();
	return;
}



IMPLEMENT_TESTLOCKED (TV, ntscjcompmb, 15)
{
	CHostResponse CHR;
	DWORD  dwMeasureResultBuffSize=EIACb_ELEMS*2*sizeof(DWORD);
	DWORD *dwMeasureResultBuff=new DWORD[dwMeasureResultBuffSize/(sizeof(DWORD))];
	char *send_buf = NULL;
	DWORD dwBufferToHostLength, dwActualBytesReceived, dwErrorCodeFromHost,i;
	int iError,videomode;
	dwBufferToHostLength=NULL;
	BOOL bPass = TRUE;

	if (CheckAbort (HERE)){ Cleanup(); return;};

	MULTIBURST_CONFIG_DATA MeasuredNtscjCompMb[NUMBER_OF_FREQ];

	videomode=GetCfgInt(L"videomode", 1);

	switch(videomode)
	{
		case 1:
			DrawNTSCMB();
			NTSCMBRender();
			break;
		case 3:
			DrawMode3NTSCMB();
			NTSCMBRender();
			break;
		default:
			break;
	}


    // Present the backbuffer contents to the display
    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
   
 	
	for(int attempts=0; attempts < m_testRetries; attempts++)
	{
		if ((iError = g_host.iSendHost(MID_NTSC_JAPAN_COMP_MB, send_buf, dwBufferToHostLength, CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, XTV_TIMEOUT)) != EVERYTHINGS_OK)
		{
			if (dwErrorCodeFromHost != 0)
			{
				// Process error from host
				err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost);
				return;
			}
			else
			{
				// Process a communication error
				// This test module just reports the number of the communication error that was received
				err_HostCommunicationError(iError);
				return;
			}
		}
		else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
		{
			// The response buffer is empty, so take appropriate action (like an error message)
			err_RecordBufferIsEmpty();
			return;
		}
		else // The response is not NULL, and is not an error message, so process it
		{
			if (dwActualBytesReceived < dwMeasureResultBuffSize)
			{
				err_RecordBufferIsNotCorrectLength(dwMeasureResultBuffSize, dwActualBytesReceived);
				return;
			}
		}
		memcpy(dwMeasureResultBuff, CHR.pvBufferFromHost, dwMeasureResultBuffSize); 

		using namespace std;
		string input((char *)dwMeasureResultBuff);
		istringstream inputString(input);
		inputString >>m_NtscjFreq1>>m_NtscjFreq2>>m_NtscjFreq3>>m_NtscjFreq4
					>>m_NtscjFreq5>>m_NtscjFreq6>>m_NtscjFreq7;

		if(m_NtscjFreq2>MAXATTENU) MeasuredNtscjCompMb[0].dbFreqResponse=m_NtscjFreq2;
		else MeasuredNtscjCompMb[0].dbFreqResponse=0.0;

		if(m_NtscjFreq3>MAXATTENU) MeasuredNtscjCompMb[1].dbFreqResponse=m_NtscjFreq3;
		else MeasuredNtscjCompMb[1].dbFreqResponse=0.0;

		if(m_NtscjFreq4>MAXATTENU) MeasuredNtscjCompMb[2].dbFreqResponse=m_NtscjFreq4;
		else MeasuredNtscjCompMb[2].dbFreqResponse=0.0;

		if(m_NtscjFreq5>MAXATTENU) MeasuredNtscjCompMb[3].dbFreqResponse=m_NtscjFreq5;
		else MeasuredNtscjCompMb[3].dbFreqResponse=0.0;

		if(m_NtscjFreq6>MAXATTENU) MeasuredNtscjCompMb[4].dbFreqResponse=m_NtscjFreq6;
		else MeasuredNtscjCompMb[4].dbFreqResponse=0.0;

		if(m_NtscjFreq7>MAXATTENU) MeasuredNtscjCompMb[5].dbFreqResponse=m_NtscjFreq7;
		else MeasuredNtscjCompMb[5].dbFreqResponse=0.0;

		bPass=TRUE;
		for(i=0;i<NUMBER_OF_FREQ;i++)
		{
			if((MeasuredNtscjCompMb[i].dbFreqResponse<dbFreqLimit[i].NtscCompLowerLimit) || (MeasuredNtscjCompMb[i].dbFreqResponse>dbFreqLimit[i].NtscCompUpperLimit))
				bPass = FALSE;
		}

		if(bPass)
			break;
	}//end retry loop

	ReportStatistic(NTSCJ_COMPOSITE_MULTIBURST_FREQUEN_PACKET1,_T("%.1f"), MeasuredNtscjCompMb[0].dbFreqResponse);
	ReportStatistic(NTSCJ_COMPOSITE_MULTIBURST_FREQUEN_PACKET2,_T("%.1f"), MeasuredNtscjCompMb[1].dbFreqResponse);
	ReportStatistic(NTSCJ_COMPOSITE_MULTIBURST_FREQUEN_PACKET3,_T("%.1f"), MeasuredNtscjCompMb[2].dbFreqResponse);
	ReportStatistic(NTSCJ_COMPOSITE_MULTIBURST_FREQUEN_PACKET4,_T("%.1f"), MeasuredNtscjCompMb[3].dbFreqResponse);
	ReportStatistic(NTSCJ_COMPOSITE_MULTIBURST_FREQUEN_PACKET5,_T("%.1f"), MeasuredNtscjCompMb[4].dbFreqResponse);
	ReportStatistic(NTSCJ_COMPOSITE_MULTIBURST_FREQUEN_PACKET6,_T("%.1f"), MeasuredNtscjCompMb[5].dbFreqResponse);

	if(!bPass)
	{
		if((MeasuredNtscjCompMb[0].dbFreqResponse==0.0)&&(MeasuredNtscjCompMb[1].dbFreqResponse==0.0)&&(MeasuredNtscjCompMb[2].dbFreqResponse==0.0)&&(MeasuredNtscjCompMb[3].dbFreqResponse==0.0)&&(MeasuredNtscjCompMb[4].dbFreqResponse==0.0)&&(MeasuredNtscjCompMb[5].dbFreqResponse==0.0))
			err_NoConnection();
		else
		{
			for(i=0;i<NUMBER_OF_FREQ;i++)
			{
				if((MeasuredNtscjCompMb[i].dbFreqResponse<dbFreqLimit[i].NtscCompLowerLimit) || (MeasuredNtscjCompMb[i].dbFreqResponse>dbFreqLimit[i].NtscCompUpperLimit))
					err_MBurstResultOutOfRange (i+1,MeasuredNtscjCompMb[i].dbFreqResponse,dbFreqLimit[i].NtscCompLowerLimit, dbFreqLimit[i].NtscCompUpperLimit );
			}
		}
	}

	Cleanup();
	return;
}



IMPLEMENT_TESTLOCKED (TV, ntscjsvmb, 16)
{
	CHostResponse CHR;
	DWORD  dwMeasureResultBuffSize=EIACb_ELEMS*2*sizeof(DWORD);
	DWORD *dwMeasureResultBuff=new DWORD[dwMeasureResultBuffSize/(sizeof(DWORD))];
	char *send_buf = NULL;
	DWORD dwBufferToHostLength, dwActualBytesReceived, dwErrorCodeFromHost,i;
	int iError,videomode;
	dwBufferToHostLength=NULL;
	BOOL bPass = TRUE;

	if (CheckAbort (HERE)){ Cleanup(); return;};

	MULTIBURST_CONFIG_DATA MeasuredNtscjSvMb[NUMBER_OF_FREQ];

	videomode=GetCfgInt(L"videomode", 1);

	switch(videomode)
	{
		case 1:
			DrawNTSCMB();
			NTSCMBRender();
			break;
		case 3:
			DrawMode3NTSCMB();
			NTSCMBRender();
			break;
		default:
			break;
	}

    // Present the backbuffer contents to the display
    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
   
 	for(int attempts=0; attempts < m_testRetries; attempts++)
	{
		if ((iError = g_host.iSendHost(MID_NTSC_JAPAN_SVIDEO_MB, send_buf, dwBufferToHostLength, CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, XTV_TIMEOUT)) != EVERYTHINGS_OK)
		{
			if (dwErrorCodeFromHost != 0)
			{
				// Process error from host
				err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost);
				return;
			}
			else
			{
				// Process a communication error
				// This test module just reports the number of the communication error that was received
				err_HostCommunicationError(iError);
				return;
			}
		}
		else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
		{
			// The response buffer is empty, so take appropriate action (like an error message)
			err_RecordBufferIsEmpty();
			return;
		}
		else // The response is not NULL, and is not an error message, so process it
		{
			if (dwActualBytesReceived < dwMeasureResultBuffSize)
			{
				err_RecordBufferIsNotCorrectLength(dwMeasureResultBuffSize, dwActualBytesReceived);
				return;
			}
		}

		memcpy(dwMeasureResultBuff, CHR.pvBufferFromHost, dwMeasureResultBuffSize); 

		using namespace std;
		string input((char *)dwMeasureResultBuff);
		istringstream inputString(input);
		inputString >>m_NtscjFreq1>>m_NtscjFreq2>>m_NtscjFreq3>>m_NtscjFreq4
					>>m_NtscjFreq5>>m_NtscjFreq6>>m_NtscjFreq7;

		if(m_NtscjFreq2>MAXATTENU) MeasuredNtscjSvMb[0].dbFreqResponse=m_NtscjFreq2;
		else MeasuredNtscjSvMb[0].dbFreqResponse=0.0;

		if(m_NtscjFreq3>MAXATTENU) MeasuredNtscjSvMb[1].dbFreqResponse=m_NtscjFreq3;
		else MeasuredNtscjSvMb[1].dbFreqResponse=0.0;

		if(m_NtscjFreq4>MAXATTENU) MeasuredNtscjSvMb[2].dbFreqResponse=m_NtscjFreq4;
		else MeasuredNtscjSvMb[2].dbFreqResponse=0.0;

		if(m_NtscjFreq5>MAXATTENU) MeasuredNtscjSvMb[3].dbFreqResponse=m_NtscjFreq5;
		else MeasuredNtscjSvMb[3].dbFreqResponse=0.0;

		if(m_NtscjFreq6>MAXATTENU) MeasuredNtscjSvMb[4].dbFreqResponse=m_NtscjFreq6;
		else MeasuredNtscjSvMb[4].dbFreqResponse=0.0;

		if(m_NtscjFreq7>MAXATTENU) MeasuredNtscjSvMb[5].dbFreqResponse=m_NtscjFreq7;
		else MeasuredNtscjSvMb[5].dbFreqResponse=0.0;

		for(i=0;i<NUMBER_OF_FREQ;i++)
		{
			if((MeasuredNtscjSvMb[i].dbFreqResponse<dbFreqLimit[i].NtscCompLowerLimit) || (MeasuredNtscjSvMb[i].dbFreqResponse>dbFreqLimit[i].NtscCompUpperLimit))
				bPass=FALSE;
		}
		
		if(bPass)
			break;

	}//end retry loop

	ReportStatistic(NTSCJ_SVIDEO_MULTIBURST_FREQUEN_PACKET1,_T("%.1f"), MeasuredNtscjSvMb[0].dbFreqResponse);
	ReportStatistic(NTSCJ_SVIDEO_MULTIBURST_FREQUEN_PACKET2,_T("%.1f"), MeasuredNtscjSvMb[1].dbFreqResponse);
	ReportStatistic(NTSCJ_SVIDEO_MULTIBURST_FREQUEN_PACKET3,_T("%.1f"), MeasuredNtscjSvMb[2].dbFreqResponse);
	ReportStatistic(NTSCJ_SVIDEO_MULTIBURST_FREQUEN_PACKET4,_T("%.1f"), MeasuredNtscjSvMb[3].dbFreqResponse);
	ReportStatistic(NTSCJ_SVIDEO_MULTIBURST_FREQUEN_PACKET5,_T("%.1f"), MeasuredNtscjSvMb[4].dbFreqResponse);
	ReportStatistic(NTSCJ_SVIDEO_MULTIBURST_FREQUEN_PACKET6,_T("%.1f"), MeasuredNtscjSvMb[5].dbFreqResponse);

	if(!bPass)
	{
		if((MeasuredNtscjSvMb[0].dbFreqResponse==0.0)&&(MeasuredNtscjSvMb[1].dbFreqResponse==0.0)&&(MeasuredNtscjSvMb[2].dbFreqResponse==0.0)&&(MeasuredNtscjSvMb[3].dbFreqResponse==0.0)&&(MeasuredNtscjSvMb[4].dbFreqResponse==0.0)&&(MeasuredNtscjSvMb[5].dbFreqResponse==0.0))
			err_NoConnection();
		else
		{
			for(i=0;i<NUMBER_OF_FREQ;i++)
			{
				if((MeasuredNtscjSvMb[i].dbFreqResponse<dbFreqLimit[i].NtscCompLowerLimit) || (MeasuredNtscjSvMb[i].dbFreqResponse>dbFreqLimit[i].NtscCompUpperLimit))
					err_MBurstResultOutOfRange (i+1,MeasuredNtscjSvMb[i].dbFreqResponse,dbFreqLimit[i].NtscCompLowerLimit, dbFreqLimit[i].NtscCompUpperLimit );
			}
		}
	}

	Cleanup();
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xtv\palbcb.cpp ===
// 
// (c) Copyright 2000-2000 Intel Corp. All rights reserved.
//   palbcb.cpp: used to implement pal(b) secam tv-standard for color bars 
//   tests with composite and s-video output. The subtests include 
//	 palbcompcb, palbsvcb, palmcompcb, palmsvcb, secamcompcb, and secamsvcb
//
//////////////////////////////////////////////////////////////////////

#include "..\stdafx.h"
#include <iostream>
#include <string>
#include <sstream>
#include "XTV.h"
#include "..\statkeys.h"


#define EBUCb_ELEMS	22

IMPLEMENT_TESTLOCKED (TV, palbcompcb, 5)
{
	
	CHostResponse CHR;
	char *send_buf = NULL;
	DWORD  dwMeasureResultBuffSize=EBUCb_ELEMS*2*sizeof(DWORD);
	DWORD *dwMeasureResultBuff=new DWORD[dwMeasureResultBuffSize/(sizeof(DWORD))];
	DWORD dwBufferToHostLength, dwActualBytesReceived, dwErrorCodeFromHost,i;
	int iError,videomode;
	dwBufferToHostLength=NULL;
	BOOL bPass = TRUE;

	if (CheckAbort (HERE)){ Cleanup(); return;};

	NTSCM_COMP_CB_DATA MeasuredPalbCompCbLumaIRE[NUMBER_OF_CBARS];
	NTSCM_COMP_CB_DATA MeasuredPalbCompCbChromaIRE[NUMBER_OF_CBARS];
	NTSCM_COMP_CB_DATA MeasuredPalbCompCbChromaPhase[NUMBER_OF_CBARS];

	videomode=GetCfgInt(L"videomode", -1);

	switch(videomode)
	{
		case 1:
			DrawPALCB();
			PALCBRender();
			break;
		case 3:
			DrawMode3PALCB();
			PALCBRender();
			break;
		case 4:
			DrawMode4PALCB();
			PALCBRender();
			break;
		case 6:
			DrawMode6PALCB();
			PALCBRender();
			break;

		default:
			break;
	}

    // Present the backbuffer contents to the display
    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
	
	for(int attempts=0; attempts<m_testRetries; attempts++)
	{
		if ((iError = g_host.iSendHost(MID_PAL_BDGHI_COMP_CB, send_buf, dwBufferToHostLength, CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, XTV_TIMEOUT)) != EVERYTHINGS_OK)
		{
			if (dwErrorCodeFromHost != 0)
			{
				// Process error from host
				if (err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost))
					return;
			}
			else
			{
				// Process a communication error
				// This test module just reports the number of the communication error that was received
				if (err_HostCommunicationError(iError))
					return;
			}
		}
		else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
		{
			// The response buffer is empty, so take appropriate action (like an error message)
			err_RecordBufferIsEmpty();
			return;
		}
		else // The response is not NULL, and is not an error message, so process it
		{
			if (dwActualBytesReceived < dwMeasureResultBuffSize)
			{
				err_RecordBufferIsNotCorrectLength(dwMeasureResultBuffSize, dwActualBytesReceived);
				return;
			}
		}

		memcpy(dwMeasureResultBuff, CHR.pvBufferFromHost, dwMeasureResultBuffSize); 

		// using string input to extract the datas from host in the measureresultbuff
		using namespace std;
		string input((char *)dwMeasureResultBuff);
		istringstream inputString(input);

		inputString >>m_LumaIREWhite		>>m_LumaIREYellow
					>>m_LumaIRECyan			>>m_LumaIREGreen
					>>m_LumaIREMagenta		>>m_LumaIRERed
					>>m_LumaIREBlue			>>m_LumaIREBlack
					>>m_ChromaIREWhite		>>m_ChromaIREYellow
					>>m_ChromaIRECyan		>>m_ChromaIREGreen
					>>m_ChromaIREMagenta	>>m_ChromaIRERed
					>>m_ChromaIREBlue		>>m_ChromaIREBlack
					>>m_ChromaPhaseYellow	>>m_ChromaPhaseCyan
					>>m_ChromaPhaseGreen	>>m_ChromaPhaseMagenta
					>>m_ChromaPhaseRed		>>m_ChromaPhaseBlue;

		MeasuredPalbCompCbLumaIRE[0].dblLumaIRE=m_LumaIREWhite;
		MeasuredPalbCompCbLumaIRE[1].dblLumaIRE= m_LumaIREYellow;
		MeasuredPalbCompCbLumaIRE[2].dblLumaIRE= m_LumaIRECyan;
		MeasuredPalbCompCbLumaIRE[3].dblLumaIRE= m_LumaIREGreen;
		MeasuredPalbCompCbLumaIRE[4].dblLumaIRE= m_LumaIREMagenta;
		MeasuredPalbCompCbLumaIRE[5].dblLumaIRE= m_LumaIRERed;
		MeasuredPalbCompCbLumaIRE[6].dblLumaIRE= m_LumaIREBlue;
		MeasuredPalbCompCbLumaIRE[7].dblLumaIRE= m_LumaIREBlack;

		MeasuredPalbCompCbChromaIRE[0].dblChromaIRE= m_ChromaIREWhite;
		MeasuredPalbCompCbChromaIRE[1].dblChromaIRE= m_ChromaIREYellow;
		MeasuredPalbCompCbChromaIRE[2].dblChromaIRE= m_ChromaIRECyan;
		MeasuredPalbCompCbChromaIRE[3].dblChromaIRE= m_ChromaIREGreen;
		MeasuredPalbCompCbChromaIRE[4].dblChromaIRE= m_ChromaIREMagenta;
		MeasuredPalbCompCbChromaIRE[5].dblChromaIRE= m_ChromaIRERed;
		MeasuredPalbCompCbChromaIRE[6].dblChromaIRE= m_ChromaIREBlue;
		MeasuredPalbCompCbChromaIRE[7].dblChromaIRE= m_ChromaIREBlack;

		//MeasuredNtscChromaPhase[0].dblChromaPhase= m_ChromaPhaseWhite;
		MeasuredPalbCompCbChromaPhase[0].dblChromaPhase= m_ChromaPhaseYellow;
		MeasuredPalbCompCbChromaPhase[1].dblChromaPhase= m_ChromaPhaseCyan;
		MeasuredPalbCompCbChromaPhase[2].dblChromaPhase= m_ChromaPhaseGreen;
		MeasuredPalbCompCbChromaPhase[3].dblChromaPhase= m_ChromaPhaseMagenta;
		MeasuredPalbCompCbChromaPhase[4].dblChromaPhase= m_ChromaPhaseRed;
		MeasuredPalbCompCbChromaPhase[5].dblChromaPhase= m_ChromaPhaseBlue;
		//MeasuredNtscChromaPhase[7].dblChromaPhase= m_ChromaPhaseBlack;

		bPass = TRUE;
		for(i=0;i<NUMBER_OF_CBARS;i++)
		{
			if(	(MeasuredPalbCompCbLumaIRE[i].dblLumaIRE < gdwColorBarLimitLumaIRE[i].dwPalCbLumaIRELowerLimit)||(MeasuredPalbCompCbLumaIRE[i].dblLumaIRE > gdwColorBarLimitLumaIRE[i].dwPalCbLumaIREUpperLimit))
				bPass = FALSE;
		}
		if(bPass)
		{
			for(i=0;i<NUMBER_OF_CBARS;i++)
			{
				if(	(MeasuredPalbCompCbChromaIRE[i].dblChromaIRE<	gdwColorBarLimitChromaIRE[i].dwPalCbChromaIRELowerLimit)||(MeasuredPalbCompCbChromaIRE[i].dblChromaIRE>gdwColorBarLimitChromaIRE[i].dwPalCbChromaIREUpperLimit))
					bPass = FALSE;
			}
		}
		if(bPass)
		{
			for(i=0;i<NUMBER_OF_CBARS-2;i++)
			{
				if(	(MeasuredPalbCompCbChromaPhase[i].dblChromaPhase<	gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseLowerLimit)||(MeasuredPalbCompCbChromaPhase[i].dblChromaPhase>gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseUpperLimit))
	 				bPass = FALSE;
			}
		}

		if(bPass)
			break;
	
	}//end retry loop


	//Report Statistic data of PAL-BDGHI Composite color bar for Luma IRE:
	ReportStatistic(PAL_BDGHI_COMPOSITE_COLOR_BAR_LUMA_IRE_WHITE, _T("%.1f"),m_LumaIREWhite);
	ReportStatistic(PAL_BDGHI_COMPOSITE_COLOR_BAR_LUMA_IRE_YELLOW, _T("%.1f"),m_LumaIREYellow);
	ReportStatistic(PAL_BDGHI_COMPOSITE_COLOR_BAR_LUMA_IRE_CYAN, _T("%.1f"),m_LumaIRECyan);
	ReportStatistic(PAL_BDGHI_COMPOSITE_COLOR_BAR_LUMA_IRE_GREEN, _T("%.1f"),m_LumaIREGreen);
	ReportStatistic(PAL_BDGHI_COMPOSITE_COLOR_BAR_LUMA_IRE_MAGENTA, _T("%.1f"),m_LumaIREMagenta);
	ReportStatistic(PAL_BDGHI_COMPOSITE_COLOR_BAR_LUMA_IRE_RED, _T("%.1f"),m_LumaIRERed);
	ReportStatistic(PAL_BDGHI_COMPOSITE_COLOR_BAR_LUMA_IRE_BLUE, _T("%.1f"),m_LumaIREBlue);
	ReportStatistic(PAL_BDGHI_COMPOSITE_COLOR_BAR_LUMA_IRE_BLACK, _T("%.1f"),m_LumaIREBlack);

	//Report Statistic data of PAL-BDGHI Composite color bar for Chroma IRE:
	ReportStatistic(PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_IRE_WHITE, _T("%.1f"),m_ChromaIREWhite);
	ReportStatistic(PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_IRE_YELLOW, _T("%.1f"),m_ChromaIREYellow);
	ReportStatistic(PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_IRE_CYAN, _T("%.1f"),m_ChromaIRECyan);
	ReportStatistic(PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_IRE_GREEN, _T("%.1f"),m_ChromaIREGreen);
	ReportStatistic(PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_IRE_MAGENTA, _T("%.1f"),m_ChromaIREMagenta);
	ReportStatistic(PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_IRE_RED, _T("%.1f"),m_ChromaIRERed);
	ReportStatistic(PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_IRE_BLUE, _T("%.1f"),m_ChromaIREBlue);
	ReportStatistic(PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_IRE_BLACK, _T("%.1f"),m_ChromaIREBlack);


	//Report Statistic data of PAL-BDGHI Composite color bar for Chroma Phase:
	//ReportStatistic(PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_IRE_WHITE, _T("%.1f"),m_ChromaIREWhite);
	ReportStatistic(PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_PHASE_YELLOW, _T("%.1f"),m_ChromaPhaseYellow);
	ReportStatistic(PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_PHASE_CYAN, _T("%.1f"),m_ChromaPhaseCyan);
	ReportStatistic(PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_PHASE_GREEN, _T("%.1f"),m_ChromaPhaseGreen);
	ReportStatistic(PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_PHASE_MAGENTA, _T("%.1f"),m_ChromaPhaseMagenta);
	ReportStatistic(PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_PHASE_RED, _T("%.1f"),m_ChromaPhaseRed);
	ReportStatistic(PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_PHASE_BLUE, _T("%.1f"),m_ChromaPhaseBlue);
	//ReportStatistic(PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_IRE_BLACK, _T("%.1f"),m_ChromaIREBlack);

	if(!bPass)
	{
		for(i=0;i<NUMBER_OF_CBARS;i++)
		{
			if(	(MeasuredPalbCompCbLumaIRE[i].dblLumaIRE < gdwColorBarLimitLumaIRE[i].dwPalCbLumaIRELowerLimit)||(MeasuredPalbCompCbLumaIRE[i].dblLumaIRE > gdwColorBarLimitLumaIRE[i].dwPalCbLumaIREUpperLimit))
				err_LumaResultOutOfRange(i,MeasuredPalbCompCbLumaIRE[i].dblLumaIRE,dbStandardPalParams[i].dwStdPalCbParamLumaIRE,gdwColorBarLimitLumaIRE[i].dwPalCbLumaIREUpperLimit,gdwColorBarLimitLumaIRE[i].dwPalCbLumaIRELowerLimit);
		}
		for(i=0;i<NUMBER_OF_CBARS;i++)
		{
			if(	(MeasuredPalbCompCbChromaIRE[i].dblChromaIRE<	gdwColorBarLimitChromaIRE[i].dwPalCbChromaIRELowerLimit)||(MeasuredPalbCompCbChromaIRE[i].dblChromaIRE>gdwColorBarLimitChromaIRE[i].dwPalCbChromaIREUpperLimit))
				err_ChromaIREResultOutOfRange(i,MeasuredPalbCompCbChromaIRE[i].dblChromaIRE, dbStandardPalParams[i].dwStdPalCbParamChromaIRE,gdwColorBarLimitChromaIRE[i].dwPalCbChromaIREUpperLimit,gdwColorBarLimitChromaIRE[i].dwPalCbChromaIRELowerLimit);
		}
		for(i=0;i<NUMBER_OF_CBARS-2;i++)
		{
			if(	(MeasuredPalbCompCbChromaPhase[i].dblChromaPhase<	gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseLowerLimit)||(MeasuredPalbCompCbChromaPhase[i].dblChromaPhase>gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseUpperLimit))
	 			 err_ChromaPhaseResultOutOfRange(i,MeasuredPalbCompCbChromaPhase[i].dblChromaPhase, 	dbStandardPalParams[i].dwStdPalCbParamChromaPhase,gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseUpperLimit,gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseLowerLimit);
		}
	}

	Cleanup();
	return;
	
}


//pal(b) tv standard with s-video output source for the color bar test
IMPLEMENT_TESTLOCKED (TV, palbsvcb, 6)
{

	CHostResponse CHR;
	char *send_buf = NULL;
	DWORD  dwMeasureResultBuffSize=EBUCb_ELEMS*2*sizeof(DWORD);
	DWORD *dwMeasureResultBuff=new DWORD[dwMeasureResultBuffSize/(sizeof(DWORD))];
	DWORD dwBufferToHostLength, dwActualBytesReceived, dwErrorCodeFromHost,i;
	int iError,videomode;
	dwBufferToHostLength=NULL;
	BOOL bPass = TRUE;

	if (CheckAbort (HERE)){ Cleanup(); return;};

	NTSCM_COMP_CB_DATA MeasuredPalbSvCbLumaIRE[NUMBER_OF_CBARS];
	NTSCM_COMP_CB_DATA MeasuredPalbSvCbChromaIRE[NUMBER_OF_CBARS];
	NTSCM_COMP_CB_DATA MeasuredPalbSvCbChromaPhase[NUMBER_OF_CBARS];

	videomode=GetCfgInt(L"videomode", -1);
	switch(videomode)
	{
		case 1:
			DrawPALCB();
			PALCBRender();
			break;
		case 3:
			DrawMode3PALCB();
			PALCBRender();
			break;
		case 4:
			DrawMode4PALCB();
			PALCBRender();
			break;
		case 6:
			DrawMode6PALCB();
			PALCBRender();
			break;

		default:
			break;
	}

    // Present the backbuffer contents to the display
    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
 
	for(int attempts=0; attempts<m_testRetries; attempts++)
	{
		if ((iError = g_host.iSendHost(MID_PAL_BDGHI_SVIDEO_CB, send_buf, dwBufferToHostLength, CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, XTV_TIMEOUT)) != EVERYTHINGS_OK)
		{
			if (dwErrorCodeFromHost != 0)
			{
				// Process error from host
				if (err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost))
					return;
			}
			else
			{
				// Process a communication error
				// This test module just reports the number of the communication error that was received
				if (err_HostCommunicationError(iError))
					return;
			}
		}

		else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
		{
			// The response buffer is empty, so take appropriate action (like an error message)
			err_RecordBufferIsEmpty();
			return;
		}
		else // The response is not NULL, and is not an error message, so process it
		{
			if (dwActualBytesReceived < dwMeasureResultBuffSize)
			{
				err_RecordBufferIsNotCorrectLength(dwMeasureResultBuffSize, dwActualBytesReceived);
				return;
			}
			
		}

		//ReportDebug(BIT0,L"After conversion to widerchar:\n%s", (LPCTSTR)CHR.pvBufferFromHost);

		memcpy(dwMeasureResultBuff, CHR.pvBufferFromHost, dwMeasureResultBuffSize); 
		// using string input to extract the datas in the measureresultbuff
		using namespace std;
		string input((char *)dwMeasureResultBuff);
		istringstream inputString(input);

		inputString >>m_LumaIREWhite >>m_LumaIREYellow >>m_LumaIRECyan >>m_LumaIREGreen
					>>m_LumaIREMagenta >>m_LumaIRERed >>m_LumaIREBlue >>m_LumaIREBlack
					>> m_ChromaIREWhite >>m_ChromaIREYellow >>m_ChromaIRECyan >>m_ChromaIREGreen
					>>m_ChromaIREMagenta >>m_ChromaIRERed >>m_ChromaIREBlue >>m_ChromaIREBlack
					>>m_ChromaPhaseYellow >>m_ChromaPhaseCyan >>m_ChromaPhaseGreen
					>>m_ChromaPhaseMagenta >>m_ChromaPhaseRed >>m_ChromaPhaseBlue;

		MeasuredPalbSvCbLumaIRE[0].dblLumaIRE=m_LumaIREWhite;
		MeasuredPalbSvCbLumaIRE[1].dblLumaIRE= m_LumaIREYellow;
		MeasuredPalbSvCbLumaIRE[2].dblLumaIRE= m_LumaIRECyan;
		MeasuredPalbSvCbLumaIRE[3].dblLumaIRE= m_LumaIREGreen;
		MeasuredPalbSvCbLumaIRE[4].dblLumaIRE= m_LumaIREMagenta;
		MeasuredPalbSvCbLumaIRE[5].dblLumaIRE= m_LumaIRERed;
		MeasuredPalbSvCbLumaIRE[6].dblLumaIRE= m_LumaIREBlue;
		MeasuredPalbSvCbLumaIRE[7].dblLumaIRE= m_LumaIREBlack;

		MeasuredPalbSvCbChromaIRE[0].dblChromaIRE= m_ChromaIREWhite;
		MeasuredPalbSvCbChromaIRE[1].dblChromaIRE= m_ChromaIREYellow;
		MeasuredPalbSvCbChromaIRE[2].dblChromaIRE= m_ChromaIRECyan;
		MeasuredPalbSvCbChromaIRE[3].dblChromaIRE= m_ChromaIREGreen;
		MeasuredPalbSvCbChromaIRE[4].dblChromaIRE= m_ChromaIREMagenta;
		MeasuredPalbSvCbChromaIRE[5].dblChromaIRE= m_ChromaIRERed;
		MeasuredPalbSvCbChromaIRE[6].dblChromaIRE= m_ChromaIREBlue;
		MeasuredPalbSvCbChromaIRE[7].dblChromaIRE= m_ChromaIREBlack;

		//MeasuredNtscChromaPhase[0].dblChromaPhase= m_ChromaPhaseWhite;
		MeasuredPalbSvCbChromaPhase[0].dblChromaPhase= m_ChromaPhaseYellow;
		MeasuredPalbSvCbChromaPhase[1].dblChromaPhase= m_ChromaPhaseCyan;
		MeasuredPalbSvCbChromaPhase[2].dblChromaPhase= m_ChromaPhaseGreen;
		MeasuredPalbSvCbChromaPhase[3].dblChromaPhase= m_ChromaPhaseMagenta;
		MeasuredPalbSvCbChromaPhase[4].dblChromaPhase= m_ChromaPhaseRed;
		MeasuredPalbSvCbChromaPhase[5].dblChromaPhase= m_ChromaPhaseBlue;
		//MeasuredNtscChromaPhase[7].dblChromaPhase= m_ChromaPhaseBlack;
		
		bPass = TRUE;
		for(i=0;i<NUMBER_OF_CBARS;i++)
		{
			if(	(MeasuredPalbSvCbLumaIRE[i].dblLumaIRE < gdwColorBarLimitLumaIRE[i].dwPalCbLumaIRELowerLimit)||(MeasuredPalbSvCbLumaIRE[i].dblLumaIRE > gdwColorBarLimitLumaIRE[i].dwPalCbLumaIREUpperLimit))
				bPass = FALSE;
		}
		if(bPass)
		{
			for(i=0;i<NUMBER_OF_CBARS;i++)
			{
				if(	(MeasuredPalbSvCbChromaIRE[i].dblChromaIRE<	gdwColorBarLimitChromaIRE[i].dwPalCbChromaIRELowerLimit)||(MeasuredPalbSvCbChromaIRE[i].dblChromaIRE>gdwColorBarLimitChromaIRE[i].dwPalCbChromaIREUpperLimit))
					bPass = FALSE;
			}
		}
		if(bPass)
		{
			for(i=0;i<NUMBER_OF_CBARS-2;i++)
			{
				if(	(MeasuredPalbSvCbChromaPhase[i].dblChromaPhase<	gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseLowerLimit)||(MeasuredPalbSvCbChromaPhase[i].dblChromaPhase>gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseUpperLimit))
	 				bPass = FALSE;
			}
		}
		if(bPass)
			break;

	}//end retry loop

	//Report Statistic data of PAL-BDGHI Svideo color bar for Luma IRE:
	ReportStatistic(PAL_BDGHI_SVIDEO_COLOR_BAR_LUMA_IRE_WHITE, _T("%.1f"),m_LumaIREWhite);
	ReportStatistic(PAL_BDGHI_SVIDEO_COLOR_BAR_LUMA_IRE_YELLOW, _T("%.1f"),m_LumaIREYellow);
	ReportStatistic(PAL_BDGHI_SVIDEO_COLOR_BAR_LUMA_IRE_CYAN, _T("%.1f"),m_LumaIRECyan);
	ReportStatistic(PAL_BDGHI_SVIDEO_COLOR_BAR_LUMA_IRE_GREEN, _T("%.1f"),m_LumaIREGreen);
	ReportStatistic(PAL_BDGHI_SVIDEO_COLOR_BAR_LUMA_IRE_MAGENTA, _T("%.1f"),m_LumaIREMagenta);
	ReportStatistic(PAL_BDGHI_SVIDEO_COLOR_BAR_LUMA_IRE_RED, _T("%.1f"),m_LumaIRERed);
	ReportStatistic(PAL_BDGHI_SVIDEO_COLOR_BAR_LUMA_IRE_BLUE, _T("%.1f"),m_LumaIREBlue);
	ReportStatistic(PAL_BDGHI_SVIDEO_COLOR_BAR_LUMA_IRE_BLACK, _T("%.1f"),m_LumaIREBlack);

	//Report Statistic data of PAL-BDGHI Svideo color bar for Chroma IRE:
	ReportStatistic(PAL_BDGHI_SVIDEO_COLOR_BAR_CHROMA_IRE_WHITE, _T("%.1f"),m_ChromaIREWhite);
	ReportStatistic(PAL_BDGHI_SVIDEO_COLOR_BAR_CHROMA_IRE_YELLOW, _T("%.1f"),m_ChromaIREYellow);
	ReportStatistic(PAL_BDGHI_SVIDEO_COLOR_BAR_CHROMA_IRE_CYAN, _T("%.1f"),m_ChromaIRECyan);
	ReportStatistic(PAL_BDGHI_SVIDEO_COLOR_BAR_CHROMA_IRE_GREEN, _T("%.1f"),m_ChromaIREGreen);
	ReportStatistic(PAL_BDGHI_SVIDEO_COLOR_BAR_CHROMA_IRE_MAGENTA, _T("%.1f"),m_ChromaIREMagenta);
	ReportStatistic(PAL_BDGHI_SVIDEO_COLOR_BAR_CHROMA_IRE_RED, _T("%.1f"),m_ChromaIRERed);
	ReportStatistic(PAL_BDGHI_SVIDEO_COLOR_BAR_CHROMA_IRE_BLUE, _T("%.1f"),m_ChromaIREBlue);
	ReportStatistic(PAL_BDGHI_SVIDEO_COLOR_BAR_CHROMA_IRE_BLACK, _T("%.1f"),m_ChromaIREBlack);

	//Report Statistic data of PAL-BDGHI Svideo color bar for Chroma Phase:
	//ReportStatistic(PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_IRE_WHITE, _T("%.1f"),m_ChromaIREWhite);
	ReportStatistic(PAL_BDGHI_SVIDEO_COLOR_BAR_CHROMA_PHASE_YELLOW, _T("%.1f"),m_ChromaPhaseYellow);
	ReportStatistic(PAL_BDGHI_SVIDEO_COLOR_BAR_CHROMA_PHASE_CYAN, _T("%.1f"),m_ChromaPhaseCyan);
	ReportStatistic(PAL_BDGHI_SVIDEO_COLOR_BAR_CHROMA_PHASE_GREEN, _T("%.1f"),m_ChromaPhaseGreen);
	ReportStatistic(PAL_BDGHI_SVIDEO_COLOR_BAR_CHROMA_PHASE_MAGENTA, _T("%.1f"),m_ChromaPhaseMagenta);
	ReportStatistic(PAL_BDGHI_SVIDEO_COLOR_BAR_CHROMA_PHASE_RED, _T("%.1f"),m_ChromaPhaseRed);
	ReportStatistic(PAL_BDGHI_SVIDEO_COLOR_BAR_CHROMA_PHASE_BLUE, _T("%.1f"),m_ChromaPhaseBlue);
	//ReportStatistic(PAL_BDGHI_COMPOSITE_COLOR_BAR_CHROMA_IRE_BLACK, _T("%.1f"),m_ChromaIREBlack);

	if(!bPass)
	{
		for(i=0;i<NUMBER_OF_CBARS;i++)
		{
			if(	(MeasuredPalbSvCbLumaIRE[i].dblLumaIRE < gdwColorBarLimitLumaIRE[i].dwPalCbLumaIRELowerLimit)||(MeasuredPalbSvCbLumaIRE[i].dblLumaIRE > gdwColorBarLimitLumaIRE[i].dwPalCbLumaIREUpperLimit))
				err_LumaResultOutOfRange(i,MeasuredPalbSvCbLumaIRE[i].dblLumaIRE,	dbStandardPalParams[i].dwStdPalCbParamLumaIRE,gdwColorBarLimitLumaIRE[i].dwPalCbLumaIREUpperLimit,gdwColorBarLimitLumaIRE[i].dwPalCbLumaIRELowerLimit);
		}

		for(i=0;i<NUMBER_OF_CBARS;i++)
		{
			if(	(MeasuredPalbSvCbChromaIRE[i].dblChromaIRE<	gdwColorBarLimitChromaIRE[i].dwPalCbChromaIRELowerLimit)||(MeasuredPalbSvCbChromaIRE[i].dblChromaIRE>gdwColorBarLimitChromaIRE[i].dwPalCbChromaIREUpperLimit))
				err_ChromaIREResultOutOfRange(i,MeasuredPalbSvCbChromaIRE[i].dblChromaIRE, 	dbStandardPalParams[i].dwStdPalCbParamChromaIRE,gdwColorBarLimitChromaIRE[i].dwPalCbChromaIREUpperLimit,gdwColorBarLimitChromaIRE[i].dwPalCbChromaIRELowerLimit);
		}

		for(i=0;i<NUMBER_OF_CBARS-2;i++)
		{
			if(	(MeasuredPalbSvCbChromaPhase[i].dblChromaPhase<	gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseLowerLimit)||(MeasuredPalbSvCbChromaPhase[i].dblChromaPhase>gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseUpperLimit))
				err_ChromaPhaseResultOutOfRange(i,MeasuredPalbSvCbChromaPhase[i].dblChromaPhase, 	dbStandardPalParams[i].dwStdPalCbParamChromaPhase,gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseUpperLimit,gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseLowerLimit);
		}
	}

	Cleanup();
	return;
}


//secam tv standard with composite output source for the color bar test
IMPLEMENT_TESTLOCKED (TV, secamcompcb, 7)
{
	
	CHostResponse CHR;
	char *send_buf = NULL;
	DWORD  dwMeasureResultBuffSize=EBUCb_ELEMS*2*sizeof(DWORD);
	DWORD *dwMeasureResultBuff=new DWORD[dwMeasureResultBuffSize/(sizeof(DWORD))];
	DWORD dwBufferToHostLength, dwActualBytesReceived, dwErrorCodeFromHost,i;
	int iError;
	dwBufferToHostLength=NULL;
	BOOL bPass = TRUE;

	if (CheckAbort (HERE)){ Cleanup(); return;};

	NTSCM_COMP_CB_DATA MeasuredSecamCompCbLumaIRE[NUMBER_OF_CBARS];
	NTSCM_COMP_CB_DATA MeasuredSecamCompCbChromaIRE[NUMBER_OF_CBARS];
	NTSCM_COMP_CB_DATA MeasuredSecamCompCbChromaPhase[NUMBER_OF_CBARS];
		
	DrawPALCB();
    // Render the scene
    PALCBRender();

    // Present the backbuffer contents to the display
    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );

	
	for(int attempts=0; attempts<m_testRetries; attempts++)
	{
		if ((iError = g_host.iSendHost(MID_SECAM_COMP_CB, send_buf, dwBufferToHostLength, CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, XTV_TIMEOUT)) != EVERYTHINGS_OK)
		{
			if (dwErrorCodeFromHost != 0)
			{
				// Process error from host
				if (err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost))
					return;
			}
			else
			{
				// Process a communication error
				// This test module just reports the number of the communication error that was received
				if (err_HostCommunicationError(iError))
					return;
			}
		}
		else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
		{
			// The response buffer is empty, so take appropriate action (like an error message)
			err_RecordBufferIsEmpty();
			return;
		}
		else // The response is not NULL, and is not an error message, so process it
		{
			if (dwActualBytesReceived < dwMeasureResultBuffSize)
			{
				err_RecordBufferIsNotCorrectLength(dwMeasureResultBuffSize, dwActualBytesReceived);
				return;
			}
		}

		memcpy(dwMeasureResultBuff, CHR.pvBufferFromHost, dwMeasureResultBuffSize); 

		// using string input to extract the datas in the measureresultbuff
		using namespace std;
		string input((char *)dwMeasureResultBuff);
		istringstream inputString(input);

		inputString >> m_LumaIREWhite >>m_LumaIREYellow>>m_LumaIRECyan >> m_LumaIREGreen
					>>m_LumaIREMagenta >> m_LumaIRERed >> m_LumaIREBlue >> m_LumaIREBlack
					>> m_ChromaIREWhite >>m_ChromaIREYellow >>m_ChromaIRECyan >> m_ChromaIREGreen
					>>m_ChromaIREMagenta >> m_ChromaIRERed >> m_ChromaIREBlue >> m_ChromaIREBlack
					>>m_ChromaPhaseYellow >>m_ChromaPhaseCyan >> m_ChromaPhaseGreen>>m_ChromaPhaseMagenta 
					>> m_ChromaPhaseRed >> m_ChromaPhaseBlue;

		MeasuredSecamCompCbLumaIRE[0].dblLumaIRE=m_LumaIREWhite;
		MeasuredSecamCompCbLumaIRE[1].dblLumaIRE= m_LumaIREYellow;
		MeasuredSecamCompCbLumaIRE[2].dblLumaIRE= m_LumaIRECyan;
		MeasuredSecamCompCbLumaIRE[3].dblLumaIRE= m_LumaIREGreen;
		MeasuredSecamCompCbLumaIRE[4].dblLumaIRE= m_LumaIREMagenta;
		MeasuredSecamCompCbLumaIRE[5].dblLumaIRE= m_LumaIRERed;
		MeasuredSecamCompCbLumaIRE[6].dblLumaIRE= m_LumaIREBlue;
		MeasuredSecamCompCbLumaIRE[7].dblLumaIRE= m_LumaIREBlack;

		MeasuredSecamCompCbChromaIRE[0].dblChromaIRE= m_ChromaIREWhite;
		MeasuredSecamCompCbChromaIRE[1].dblChromaIRE= m_ChromaIREYellow;
		MeasuredSecamCompCbChromaIRE[2].dblChromaIRE= m_ChromaIRECyan;
		MeasuredSecamCompCbChromaIRE[3].dblChromaIRE= m_ChromaIREGreen;
		MeasuredSecamCompCbChromaIRE[4].dblChromaIRE= m_ChromaIREMagenta;
		MeasuredSecamCompCbChromaIRE[5].dblChromaIRE= m_ChromaIRERed;
		MeasuredSecamCompCbChromaIRE[6].dblChromaIRE= m_ChromaIREBlue;
		MeasuredSecamCompCbChromaIRE[7].dblChromaIRE= m_ChromaIREBlack;

		//MeasuredNtscChromaPhase[0].dblChromaPhase= m_ChromaPhaseWhite;
		MeasuredSecamCompCbChromaPhase[0].dblChromaPhase= m_ChromaPhaseYellow;
		MeasuredSecamCompCbChromaPhase[1].dblChromaPhase= m_ChromaPhaseCyan;
		MeasuredSecamCompCbChromaPhase[2].dblChromaPhase= m_ChromaPhaseGreen;
		MeasuredSecamCompCbChromaPhase[3].dblChromaPhase= m_ChromaPhaseMagenta;
		MeasuredSecamCompCbChromaPhase[4].dblChromaPhase= m_ChromaPhaseRed;
		MeasuredSecamCompCbChromaPhase[5].dblChromaPhase= m_ChromaPhaseBlue;
		//MeasuredNtscChromaPhase[7].dblChromaPhase= m_ChromaPhaseBlack;

		bPass=TRUE;		
		for(i=0;i<NUMBER_OF_CBARS;i++)
		{
			if(	(MeasuredSecamCompCbLumaIRE[i].dblLumaIRE < gdwColorBarLimitLumaIRE[i].dwPalCbLumaIRELowerLimit)||(MeasuredSecamCompCbLumaIRE[i].dblLumaIRE > gdwColorBarLimitLumaIRE[i].dwPalCbLumaIREUpperLimit))
				bPass=FALSE;
		}

		if(bPass)
		{
			for(i=0;i<NUMBER_OF_CBARS;i++)
			{
				if(	(MeasuredSecamCompCbChromaIRE[i].dblChromaIRE<	gdwColorBarLimitChromaIRE[i].dwPalCbChromaIRELowerLimit)||(MeasuredSecamCompCbChromaIRE[i].dblChromaIRE>gdwColorBarLimitChromaIRE[i].dwPalCbChromaIREUpperLimit))
					bPass = FALSE;
			}
		}
		if(bPass)
		{
			for(i=0;i<NUMBER_OF_CBARS-2;i++)
			{
				if(	(MeasuredSecamCompCbChromaPhase[i].dblChromaPhase<	gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseLowerLimit)||(MeasuredSecamCompCbChromaPhase[i].dblChromaPhase>gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseUpperLimit))
	 				bPass=FALSE;		
			}
		}
		if(bPass)
			break;

	}//end retry loop


	if(!bPass)
	{
		for(i=0;i<NUMBER_OF_CBARS;i++)
		{
			if(	(MeasuredSecamCompCbLumaIRE[i].dblLumaIRE < gdwColorBarLimitLumaIRE[i].dwPalCbLumaIRELowerLimit)||(MeasuredSecamCompCbLumaIRE[i].dblLumaIRE > gdwColorBarLimitLumaIRE[i].dwPalCbLumaIREUpperLimit))
				err_LumaResultOutOfRange(i,MeasuredSecamCompCbLumaIRE[i].dblLumaIRE, dbStandardPalParams[i].dwStdPalCbParamLumaIRE,gdwColorBarLimitLumaIRE[i].dwPalCbLumaIREUpperLimit,gdwColorBarLimitLumaIRE[i].dwPalCbLumaIRELowerLimit);
		}
		for(i=0;i<NUMBER_OF_CBARS;i++)
		{
			if(	(MeasuredSecamCompCbChromaIRE[i].dblChromaIRE<	gdwColorBarLimitChromaIRE[i].dwPalCbChromaIRELowerLimit)||(MeasuredSecamCompCbChromaIRE[i].dblChromaIRE>gdwColorBarLimitChromaIRE[i].dwPalCbChromaIREUpperLimit))
				err_ChromaIREResultOutOfRange(i,MeasuredSecamCompCbChromaIRE[i].dblChromaIRE, dbStandardPalParams[i].dwStdPalCbParamChromaIRE,gdwColorBarLimitChromaIRE[i].dwPalCbChromaIREUpperLimit,gdwColorBarLimitChromaIRE[i].dwPalCbChromaIRELowerLimit);
		}
		for(i=0;i<NUMBER_OF_CBARS-2;i++)
		{
			if(	(MeasuredSecamCompCbChromaPhase[i].dblChromaPhase<	gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseLowerLimit)||(MeasuredSecamCompCbChromaPhase[i].dblChromaPhase>gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseUpperLimit))
				err_ChromaPhaseResultOutOfRange(i,MeasuredSecamCompCbChromaPhase[i].dblChromaPhase, 	dbStandardPalParams[i].dwStdPalCbParamChromaPhase,gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseUpperLimit,gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseLowerLimit);		
		}
	}

	Cleanup();
	return;
}

//secam tv standard with s-video output source for the color bar test
IMPLEMENT_TESTLOCKED (TV, secamsvcb, 8)
{
	CHostResponse CHR;
	char *send_buf = NULL;
	DWORD  dwMeasureResultBuffSize=EBUCb_ELEMS*2*sizeof(DWORD);
	DWORD *dwMeasureResultBuff=new DWORD[dwMeasureResultBuffSize/(sizeof(DWORD))];
	DWORD dwBufferToHostLength, dwActualBytesReceived, dwErrorCodeFromHost,i;
	int iError;
	dwBufferToHostLength=NULL;
	BOOL bPass=TRUE;


	if (CheckAbort (HERE)){ Cleanup(); return;};
	
	NTSCM_COMP_CB_DATA MeasuredSecamSvCbLumaIRE[NUMBER_OF_CBARS];
	NTSCM_COMP_CB_DATA MeasuredSecamSvCbChromaIRE[NUMBER_OF_CBARS];
	NTSCM_COMP_CB_DATA MeasuredSecamSvCbChromaPhase[NUMBER_OF_CBARS];
	
	DrawPALCB();

    // Render the scene
    PALCBRender();

    // Present the backbuffer contents to the display
    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
  

	for(int attempts=0; attempts<m_testRetries; attempts++)
	{
		if ((iError = g_host.iSendHost(MID_SECAM_SVIDEO_CB, send_buf, dwBufferToHostLength, CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, XTV_TIMEOUT)) != EVERYTHINGS_OK)
		{
			if (dwErrorCodeFromHost != 0)
			{
				// Process error from host
				if (err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost))
					return;
			}
			else
			{
				// Process a communication error
				// This test module just reports the number of the communication error that was received
				if (err_HostCommunicationError(iError))
					return;
			}
		}

			else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
		{
			// The response buffer is empty, so take appropriate action (like an error message)
			err_RecordBufferIsEmpty();
			return;
		}
		else // The response is not NULL, and is not an error message, so process it
		{
			if (dwActualBytesReceived < dwMeasureResultBuffSize)
			{
				err_RecordBufferIsNotCorrectLength(dwMeasureResultBuffSize, dwActualBytesReceived);
				return;
			}
			
		}

		memcpy(dwMeasureResultBuff, CHR.pvBufferFromHost, dwMeasureResultBuffSize); 

		// using string input to extract the datas in the measureresultbuff
		using namespace std;
		string input((char *)dwMeasureResultBuff);
		istringstream inputString(input);

		inputString >> m_LumaIREWhite >>m_LumaIREYellow >>m_LumaIRECyan >> m_LumaIREGreen
					>>m_LumaIREMagenta >> m_LumaIRERed >> m_LumaIREBlue >> m_LumaIREBlack
					>> m_ChromaIREWhite >>m_ChromaIREYellow >>m_ChromaIRECyan >> m_ChromaIREGreen
					>>m_ChromaIREMagenta >> m_ChromaIRERed >> m_ChromaIREBlue >> m_ChromaIREBlack
					>>m_ChromaPhaseYellow >>m_ChromaPhaseCyan >> m_ChromaPhaseGreen>>m_ChromaPhaseMagenta 
					>> m_ChromaPhaseRed >> m_ChromaPhaseBlue;

		MeasuredSecamSvCbLumaIRE[0].dblLumaIRE=m_LumaIREWhite;
		MeasuredSecamSvCbLumaIRE[1].dblLumaIRE= m_LumaIREYellow;
		MeasuredSecamSvCbLumaIRE[2].dblLumaIRE= m_LumaIRECyan;
		MeasuredSecamSvCbLumaIRE[3].dblLumaIRE= m_LumaIREGreen;
		MeasuredSecamSvCbLumaIRE[4].dblLumaIRE= m_LumaIREMagenta;
		MeasuredSecamSvCbLumaIRE[5].dblLumaIRE= m_LumaIRERed;
		MeasuredSecamSvCbLumaIRE[6].dblLumaIRE= m_LumaIREBlue;
		MeasuredSecamSvCbLumaIRE[7].dblLumaIRE= m_LumaIREBlack;

		MeasuredSecamSvCbChromaIRE[0].dblChromaIRE= m_ChromaIREWhite;
		MeasuredSecamSvCbChromaIRE[1].dblChromaIRE= m_ChromaIREYellow;
		MeasuredSecamSvCbChromaIRE[2].dblChromaIRE= m_ChromaIRECyan;
		MeasuredSecamSvCbChromaIRE[3].dblChromaIRE= m_ChromaIREGreen;
		MeasuredSecamSvCbChromaIRE[4].dblChromaIRE= m_ChromaIREMagenta;
		MeasuredSecamSvCbChromaIRE[5].dblChromaIRE= m_ChromaIRERed;
		MeasuredSecamSvCbChromaIRE[6].dblChromaIRE= m_ChromaIREBlue;
		MeasuredSecamSvCbChromaIRE[7].dblChromaIRE= m_ChromaIREBlack;

		//MeasuredNtscChromaPhase[0].dblChromaPhase= m_ChromaPhaseWhite;
		MeasuredSecamSvCbChromaPhase[0].dblChromaPhase= m_ChromaPhaseYellow;
		MeasuredSecamSvCbChromaPhase[1].dblChromaPhase= m_ChromaPhaseCyan;
		MeasuredSecamSvCbChromaPhase[2].dblChromaPhase= m_ChromaPhaseGreen;
		MeasuredSecamSvCbChromaPhase[3].dblChromaPhase= m_ChromaPhaseMagenta;
		MeasuredSecamSvCbChromaPhase[4].dblChromaPhase= m_ChromaPhaseRed;
		MeasuredSecamSvCbChromaPhase[5].dblChromaPhase= m_ChromaPhaseBlue;
		//MeasuredNtscChromaPhase[7].dblChromaPhase= m_ChromaPhaseBlack;

		bPass=TRUE;
		for(i=0;i<NUMBER_OF_CBARS;i++)
		{
			if(	(MeasuredSecamSvCbLumaIRE[i].dblLumaIRE < gdwColorBarLimitLumaIRE[i].dwPalCbLumaIRELowerLimit)||(MeasuredSecamSvCbLumaIRE[i].dblLumaIRE > gdwColorBarLimitLumaIRE[i].dwPalCbLumaIREUpperLimit))
				bPass=FALSE;
		}
		if(bPass)
		{
			for(i=0;i<NUMBER_OF_CBARS;i++)
			{
				if(	(MeasuredSecamSvCbChromaIRE[i].dblChromaIRE<	gdwColorBarLimitChromaIRE[i].dwPalCbChromaIRELowerLimit)||(MeasuredSecamSvCbChromaIRE[i].dblChromaIRE>gdwColorBarLimitChromaIRE[i].dwPalCbChromaIREUpperLimit))
					bPass=FALSE;
			}
		}
		if(bPass)
		{
			for(i=0;i<NUMBER_OF_CBARS-2;i++)
			{
				if(	(MeasuredSecamSvCbChromaPhase[i].dblChromaPhase<	gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseLowerLimit)||(MeasuredSecamSvCbChromaPhase[i].dblChromaPhase>gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseUpperLimit))
	 				bPass = FALSE;
			}
		}

	}//end retry loop

	if(!bPass)
	{
		for(i=0;i<NUMBER_OF_CBARS;i++)
		{
			if(	(MeasuredSecamSvCbLumaIRE[i].dblLumaIRE < gdwColorBarLimitLumaIRE[i].dwPalCbLumaIRELowerLimit)||(MeasuredSecamSvCbLumaIRE[i].dblLumaIRE > gdwColorBarLimitLumaIRE[i].dwPalCbLumaIREUpperLimit))
				err_LumaResultOutOfRange(i,MeasuredSecamSvCbLumaIRE[i].dblLumaIRE,	dbStandardPalParams[i].dwStdPalCbParamLumaIRE,gdwColorBarLimitLumaIRE[i].dwPalCbLumaIREUpperLimit,gdwColorBarLimitLumaIRE[i].dwPalCbLumaIRELowerLimit);
		}
		for(i=0;i<NUMBER_OF_CBARS;i++){
			if(	(MeasuredSecamSvCbChromaIRE[i].dblChromaIRE<	gdwColorBarLimitChromaIRE[i].dwPalCbChromaIRELowerLimit)||(MeasuredSecamSvCbChromaIRE[i].dblChromaIRE>gdwColorBarLimitChromaIRE[i].dwPalCbChromaIREUpperLimit))
				err_ChromaIREResultOutOfRange(i,MeasuredSecamSvCbChromaIRE[i].dblChromaIRE, 	dbStandardPalParams[i].dwStdPalCbParamChromaIRE,gdwColorBarLimitChromaIRE[i].dwPalCbChromaIREUpperLimit,gdwColorBarLimitChromaIRE[i].dwPalCbChromaIRELowerLimit);
		}
		for(i=0;i<NUMBER_OF_CBARS-2;i++){
			if(	(MeasuredSecamSvCbChromaPhase[i].dblChromaPhase<	gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseLowerLimit)||(MeasuredSecamSvCbChromaPhase[i].dblChromaPhase>gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseUpperLimit))
	 			err_ChromaPhaseResultOutOfRange(i,MeasuredSecamSvCbChromaPhase[i].dblChromaPhase, 	dbStandardPalParams[i].dwStdPalCbParamChromaPhase,gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseUpperLimit,gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseLowerLimit);
		}
	}

	Cleanup();
	return;
	
}



IMPLEMENT_TESTLOCKED (TV, palmcompcb, 9)
{
CHostResponse CHR;
	char *send_buf = NULL;
	DWORD  dwMeasureResultBuffSize=EBUCb_ELEMS*2*sizeof(DWORD);
	DWORD *dwMeasureResultBuff=new DWORD[dwMeasureResultBuffSize/(sizeof(DWORD))];
	DWORD dwBufferToHostLength, dwActualBytesReceived, dwErrorCodeFromHost,i;
	int iError;
	dwBufferToHostLength=NULL;
	BOOL bPass = TRUE;

	if (CheckAbort (HERE)){ Cleanup(); return;};

	NTSCM_COMP_CB_DATA MeasuredPalbCompCbLumaIRE[NUMBER_OF_CBARS];
	NTSCM_COMP_CB_DATA MeasuredPalbCompCbChromaIRE[NUMBER_OF_CBARS];
	NTSCM_COMP_CB_DATA MeasuredPalbCompCbChromaPhase[NUMBER_OF_CBARS];
	
	DrawPALCB();
	PALCBRender();

    // Present the backbuffer contents to the display
    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
	
	
	for(int attempts=0; attempts<m_testRetries; attempts++)
	{
		if ((iError = g_host.iSendHost(MID_PAL_M_COMP_CB, send_buf, dwBufferToHostLength, CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, XTV_TIMEOUT)) != EVERYTHINGS_OK)
		{
			if (dwErrorCodeFromHost != 0)
			{
				// Process error from host
				if (err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost))
					return;
			}
			else
			{
				// Process a communication error
				// This test module just reports the number of the communication error that was received
				if (err_HostCommunicationError(iError))
					return;
			}
		}
		else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
		{
			// The response buffer is empty, so take appropriate action (like an error message)
			err_RecordBufferIsEmpty();
			return;
		}
		else // The response is not NULL, and is not an error message, so process it
		{
			if (dwActualBytesReceived < dwMeasureResultBuffSize)
			{
				err_RecordBufferIsNotCorrectLength(dwMeasureResultBuffSize, dwActualBytesReceived);
				return;
			}
		}

		memcpy(dwMeasureResultBuff, CHR.pvBufferFromHost, dwMeasureResultBuffSize); 

		// using string input to extract the datas from host in the measureresultbuff
		using namespace std;
		string input((char *)dwMeasureResultBuff);
		istringstream inputString(input);

		inputString >> m_LumaIREWhite >>m_LumaIREYellow >>m_LumaIRECyan >> m_LumaIREGreen>>m_LumaIREMagenta 
					>> m_LumaIRERed >> m_LumaIREBlue >> m_LumaIREBlack
					>> m_ChromaIREWhite >>m_ChromaIREYellow >>m_ChromaIRECyan >> m_ChromaIREGreen
					>>m_ChromaIREMagenta >> m_ChromaIRERed >> m_ChromaIREBlue >> m_ChromaIREBlack
					>>m_ChromaPhaseYellow >>m_ChromaPhaseCyan >> m_ChromaPhaseGreen>>m_ChromaPhaseMagenta >> m_ChromaPhaseRed 
					>> m_ChromaPhaseBlue;

		MeasuredPalbCompCbLumaIRE[0].dblLumaIRE=m_LumaIREWhite;
		MeasuredPalbCompCbLumaIRE[1].dblLumaIRE= m_LumaIREYellow;
		MeasuredPalbCompCbLumaIRE[2].dblLumaIRE= m_LumaIRECyan;
		MeasuredPalbCompCbLumaIRE[3].dblLumaIRE= m_LumaIREGreen;
		MeasuredPalbCompCbLumaIRE[4].dblLumaIRE= m_LumaIREMagenta;
		MeasuredPalbCompCbLumaIRE[5].dblLumaIRE= m_LumaIRERed;
		MeasuredPalbCompCbLumaIRE[6].dblLumaIRE= m_LumaIREBlue;
		MeasuredPalbCompCbLumaIRE[7].dblLumaIRE= m_LumaIREBlack;

		MeasuredPalbCompCbChromaIRE[0].dblChromaIRE= m_ChromaIREWhite;
		MeasuredPalbCompCbChromaIRE[1].dblChromaIRE= m_ChromaIREYellow;
		MeasuredPalbCompCbChromaIRE[2].dblChromaIRE= m_ChromaIRECyan;
		MeasuredPalbCompCbChromaIRE[3].dblChromaIRE= m_ChromaIREGreen;
		MeasuredPalbCompCbChromaIRE[4].dblChromaIRE= m_ChromaIREMagenta;
		MeasuredPalbCompCbChromaIRE[5].dblChromaIRE= m_ChromaIRERed;
		MeasuredPalbCompCbChromaIRE[6].dblChromaIRE= m_ChromaIREBlue;
		MeasuredPalbCompCbChromaIRE[7].dblChromaIRE= m_ChromaIREBlack;

		//MeasuredNtscChromaPhase[0].dblChromaPhase= m_ChromaPhaseWhite;
		MeasuredPalbCompCbChromaPhase[0].dblChromaPhase= m_ChromaPhaseYellow;
		MeasuredPalbCompCbChromaPhase[1].dblChromaPhase= m_ChromaPhaseCyan;
		MeasuredPalbCompCbChromaPhase[2].dblChromaPhase= m_ChromaPhaseGreen;
		MeasuredPalbCompCbChromaPhase[3].dblChromaPhase= m_ChromaPhaseMagenta;
		MeasuredPalbCompCbChromaPhase[4].dblChromaPhase= m_ChromaPhaseRed;
		MeasuredPalbCompCbChromaPhase[5].dblChromaPhase= m_ChromaPhaseBlue;
		//MeasuredNtscChromaPhase[7].dblChromaPhase= m_ChromaPhaseBlack;

		bPass = TRUE;
		for(i=0;i<NUMBER_OF_CBARS;i++)
		{
			if(	(MeasuredPalbCompCbLumaIRE[i].dblLumaIRE < gdwColorBarLimitLumaIRE[i].dwPalCbLumaIRELowerLimit)||(MeasuredPalbCompCbLumaIRE[i].dblLumaIRE > gdwColorBarLimitLumaIRE[i].dwPalCbLumaIREUpperLimit))
				bPass=FALSE;
		}
		if(bPass)
		{
			for(i=0;i<NUMBER_OF_CBARS;i++)
			{
				if(	(MeasuredPalbCompCbChromaIRE[i].dblChromaIRE<	gdwColorBarLimitChromaIRE[i].dwPalCbChromaIRELowerLimit)||(MeasuredPalbCompCbChromaIRE[i].dblChromaIRE>gdwColorBarLimitChromaIRE[i].dwPalCbChromaIREUpperLimit))
					bPass=FALSE;
			}
		}
		if(bPass)
		{
			for(i=0;i<NUMBER_OF_CBARS-2;i++)
			{
				if(	(MeasuredPalbCompCbChromaPhase[i].dblChromaPhase<	gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseLowerLimit)||(MeasuredPalbCompCbChromaPhase[i].dblChromaPhase>gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseUpperLimit))
	 				bPass=FALSE;
			}
		}
		if(bPass)
			break;

	}//end retry loop

	//Report Statistic data of PAL-M Composite color bar for Luma IRE:
	ReportStatistic(PAL_M_COMPOSITE_COLOR_BAR_LUMA_IRE_WHITE, _T("%.1f"),m_LumaIREWhite);
	ReportStatistic(PAL_M_COMPOSITE_COLOR_BAR_LUMA_IRE_YELLOW, _T("%.1f"),m_LumaIREYellow);
	ReportStatistic(PAL_M_COMPOSITE_COLOR_BAR_LUMA_IRE_CYAN, _T("%.1f"),m_LumaIRECyan);
	ReportStatistic(PAL_M_COMPOSITE_COLOR_BAR_LUMA_IRE_GREEN, _T("%.1f"),m_LumaIREGreen);
	ReportStatistic(PAL_M_COMPOSITE_COLOR_BAR_LUMA_IRE_MAGENTA, _T("%.1f"),m_LumaIREMagenta);
	ReportStatistic(PAL_M_COMPOSITE_COLOR_BAR_LUMA_IRE_RED, _T("%.1f"),m_LumaIRERed);
	ReportStatistic(PAL_M_COMPOSITE_COLOR_BAR_LUMA_IRE_BLUE, _T("%.1f"),m_LumaIREBlue);
	ReportStatistic(PAL_M_COMPOSITE_COLOR_BAR_LUMA_IRE_BLACK, _T("%.1f"),m_LumaIREBlack);

	//Report Statistic data of PAL-M Composite color bar for Chroma IRE:
	ReportStatistic(PAL_M_COMPOSITE_COLOR_BAR_CHROMA_IRE_WHITE, _T("%.1f"),m_ChromaIREWhite);
	ReportStatistic(PAL_M_COMPOSITE_COLOR_BAR_CHROMA_IRE_YELLOW, _T("%.1f"),m_ChromaIREYellow);
	ReportStatistic(PAL_M_COMPOSITE_COLOR_BAR_CHROMA_IRE_CYAN, _T("%.1f"),m_ChromaIRECyan);
	ReportStatistic(PAL_M_COMPOSITE_COLOR_BAR_CHROMA_IRE_GREEN, _T("%.1f"),m_ChromaIREGreen);
	ReportStatistic(PAL_M_COMPOSITE_COLOR_BAR_CHROMA_IRE_MAGENTA, _T("%.1f"),m_ChromaIREMagenta);
	ReportStatistic(PAL_M_COMPOSITE_COLOR_BAR_CHROMA_IRE_RED, _T("%.1f"),m_ChromaIRERed);
	ReportStatistic(PAL_M_COMPOSITE_COLOR_BAR_CHROMA_IRE_BLUE, _T("%.1f"),m_ChromaIREBlue);
	ReportStatistic(PAL_M_COMPOSITE_COLOR_BAR_CHROMA_IRE_BLACK, _T("%.1f"),m_ChromaIREBlack);


	//Report Statistic data of PAL-M Composite color bar for Chroma Phase:
	//ReportStatistic(PAL_M_COMPOSITE_COLOR_BAR_CHROMA_IRE_WHITE, _T("%.1f"),m_ChromaIREWhite);
	ReportStatistic(PAL_M_COMPOSITE_COLOR_BAR_CHROMA_PHASE_YELLOW, _T("%.1f"),m_ChromaPhaseYellow);
	ReportStatistic(PAL_M_COMPOSITE_COLOR_BAR_CHROMA_PHASE_CYAN, _T("%.1f"),m_ChromaPhaseCyan);
	ReportStatistic(PAL_M_COMPOSITE_COLOR_BAR_CHROMA_PHASE_GREEN, _T("%.1f"),m_ChromaPhaseGreen);
	ReportStatistic(PAL_M_COMPOSITE_COLOR_BAR_CHROMA_PHASE_MAGENTA, _T("%.1f"),m_ChromaPhaseMagenta);
	ReportStatistic(PAL_M_COMPOSITE_COLOR_BAR_CHROMA_PHASE_RED, _T("%.1f"),m_ChromaPhaseRed);
	ReportStatistic(PAL_M_COMPOSITE_COLOR_BAR_CHROMA_PHASE_BLUE, _T("%.1f"),m_ChromaPhaseBlue);
	//ReportStatistic(PAL_M_COMPOSITE_COLOR_BAR_CHROMA_IRE_BLACK, _T("%.1f"),m_ChromaIREBlack);

	if(!bPass)
	{
		for(i=0;i<NUMBER_OF_CBARS;i++)
		{
			if(	(MeasuredPalbCompCbLumaIRE[i].dblLumaIRE < gdwColorBarLimitLumaIRE[i].dwPalCbLumaIRELowerLimit)||(MeasuredPalbCompCbLumaIRE[i].dblLumaIRE > gdwColorBarLimitLumaIRE[i].dwPalCbLumaIREUpperLimit))
				err_LumaResultOutOfRange(i,MeasuredPalbCompCbLumaIRE[i].dblLumaIRE, dbStandardPalParams[i].dwStdPalCbParamLumaIRE,gdwColorBarLimitLumaIRE[i].dwPalCbLumaIREUpperLimit,gdwColorBarLimitLumaIRE[i].dwPalCbLumaIRELowerLimit);
		}
		for(i=0;i<NUMBER_OF_CBARS;i++)
		{
			if(	(MeasuredPalbCompCbChromaIRE[i].dblChromaIRE<	gdwColorBarLimitChromaIRE[i].dwPalCbChromaIRELowerLimit)||(MeasuredPalbCompCbChromaIRE[i].dblChromaIRE>gdwColorBarLimitChromaIRE[i].dwPalCbChromaIREUpperLimit))
				err_ChromaIREResultOutOfRange(i,MeasuredPalbCompCbChromaIRE[i].dblChromaIRE, dbStandardPalParams[i].dwStdPalCbParamChromaIRE,gdwColorBarLimitChromaIRE[i].dwPalCbChromaIREUpperLimit,gdwColorBarLimitChromaIRE[i].dwPalCbChromaIRELowerLimit);
		}
		for(i=0;i<NUMBER_OF_CBARS-2;i++)
		{
			if(	(MeasuredPalbCompCbChromaPhase[i].dblChromaPhase<	gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseLowerLimit)||(MeasuredPalbCompCbChromaPhase[i].dblChromaPhase>gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseUpperLimit))
	 			err_ChromaPhaseResultOutOfRange(i,MeasuredPalbCompCbChromaPhase[i].dblChromaPhase, 	dbStandardPalParams[i].dwStdPalCbParamChromaPhase,gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseUpperLimit,gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseLowerLimit);
		}
	}

	Cleanup();
	return;
	
}



IMPLEMENT_TESTLOCKED (TV, palmsvcb, 10)
{
CHostResponse CHR;
	char *send_buf = NULL;
	DWORD  dwMeasureResultBuffSize=EBUCb_ELEMS*2*sizeof(DWORD);
	DWORD *dwMeasureResultBuff=new DWORD[dwMeasureResultBuffSize/(sizeof(DWORD))];
	DWORD dwBufferToHostLength, dwActualBytesReceived, dwErrorCodeFromHost,i;
	int iError;
	dwBufferToHostLength=NULL;
	BOOL bPass=TRUE;

	if (CheckAbort (HERE)){ Cleanup(); return;};

	NTSCM_COMP_CB_DATA MeasuredPalbCompCbLumaIRE[NUMBER_OF_CBARS];
	NTSCM_COMP_CB_DATA MeasuredPalbCompCbChromaIRE[NUMBER_OF_CBARS];
	NTSCM_COMP_CB_DATA MeasuredPalbCompCbChromaPhase[NUMBER_OF_CBARS];
	
	DrawPALCB();
	PALCBRender();

    // Present the backbuffer contents to the display
    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
	
	for(int attempts=0; attempts<m_testRetries; attempts++)
	{
		if ((iError = g_host.iSendHost(MID_PAL_M_SVIDEO_CB, send_buf, dwBufferToHostLength, CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, XTV_TIMEOUT)) != EVERYTHINGS_OK)
		{
			if (dwErrorCodeFromHost != 0)
			{
				// Process error from host
				if (err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost))
					return;
			}
			else
			{
				// Process a communication error
				// This test module just reports the number of the communication error that was received
				if (err_HostCommunicationError(iError))
					return;
			}
		}
		else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
		{
			// The response buffer is empty, so take appropriate action (like an error message)
			err_RecordBufferIsEmpty();
			return;
		}
		else // The response is not NULL, and is not an error message, so process it
		{
			if (dwActualBytesReceived < dwMeasureResultBuffSize)
			{
				err_RecordBufferIsNotCorrectLength(dwMeasureResultBuffSize, dwActualBytesReceived);
				return;
			}
		}

		memcpy(dwMeasureResultBuff, CHR.pvBufferFromHost, dwMeasureResultBuffSize); 

		// using string input to extract the datas from host in the measureresultbuff
		using namespace std;
		string input((char *)dwMeasureResultBuff);
		istringstream inputString(input);

		inputString >> m_LumaIREWhite >>m_LumaIREYellow >>m_LumaIRECyan >> m_LumaIREGreen>>m_LumaIREMagenta 
					>> m_LumaIRERed >> m_LumaIREBlue >> m_LumaIREBlack
					>> m_ChromaIREWhite >>m_ChromaIREYellow >>m_ChromaIRECyan >> m_ChromaIREGreen
					>>m_ChromaIREMagenta >> m_ChromaIRERed >> m_ChromaIREBlue >> m_ChromaIREBlack
					>>m_ChromaPhaseYellow >>m_ChromaPhaseCyan >> m_ChromaPhaseGreen>>m_ChromaPhaseMagenta >> m_ChromaPhaseRed 
					>> m_ChromaPhaseBlue;

		MeasuredPalbCompCbLumaIRE[0].dblLumaIRE=m_LumaIREWhite;
		MeasuredPalbCompCbLumaIRE[1].dblLumaIRE= m_LumaIREYellow;
		MeasuredPalbCompCbLumaIRE[2].dblLumaIRE= m_LumaIRECyan;
		MeasuredPalbCompCbLumaIRE[3].dblLumaIRE= m_LumaIREGreen;
		MeasuredPalbCompCbLumaIRE[4].dblLumaIRE= m_LumaIREMagenta;
		MeasuredPalbCompCbLumaIRE[5].dblLumaIRE= m_LumaIRERed;
		MeasuredPalbCompCbLumaIRE[6].dblLumaIRE= m_LumaIREBlue;
		MeasuredPalbCompCbLumaIRE[7].dblLumaIRE= m_LumaIREBlack;

		MeasuredPalbCompCbChromaIRE[0].dblChromaIRE= m_ChromaIREWhite;
		MeasuredPalbCompCbChromaIRE[1].dblChromaIRE= m_ChromaIREYellow;
		MeasuredPalbCompCbChromaIRE[2].dblChromaIRE= m_ChromaIRECyan;
		MeasuredPalbCompCbChromaIRE[3].dblChromaIRE= m_ChromaIREGreen;
		MeasuredPalbCompCbChromaIRE[4].dblChromaIRE= m_ChromaIREMagenta;
		MeasuredPalbCompCbChromaIRE[5].dblChromaIRE= m_ChromaIRERed;
		MeasuredPalbCompCbChromaIRE[6].dblChromaIRE= m_ChromaIREBlue;
		MeasuredPalbCompCbChromaIRE[7].dblChromaIRE= m_ChromaIREBlack;

		//MeasuredNtscChromaPhase[0].dblChromaPhase= m_ChromaPhaseWhite;
		MeasuredPalbCompCbChromaPhase[0].dblChromaPhase= m_ChromaPhaseYellow;
		MeasuredPalbCompCbChromaPhase[1].dblChromaPhase= m_ChromaPhaseCyan;
		MeasuredPalbCompCbChromaPhase[2].dblChromaPhase= m_ChromaPhaseGreen;
		MeasuredPalbCompCbChromaPhase[3].dblChromaPhase= m_ChromaPhaseMagenta;
		MeasuredPalbCompCbChromaPhase[4].dblChromaPhase= m_ChromaPhaseRed;
		MeasuredPalbCompCbChromaPhase[5].dblChromaPhase= m_ChromaPhaseBlue;
		//MeasuredNtscChromaPhase[7].dblChromaPhase= m_ChromaPhaseBlack;

		bPass=TRUE;
		for(i=0;i<NUMBER_OF_CBARS;i++)
		{
			if(	(MeasuredPalbCompCbLumaIRE[i].dblLumaIRE < gdwColorBarLimitLumaIRE[i].dwPalCbLumaIRELowerLimit)||(MeasuredPalbCompCbLumaIRE[i].dblLumaIRE > gdwColorBarLimitLumaIRE[i].dwPalCbLumaIREUpperLimit))
				bPass=FALSE;
		}
		if(bPass)
		{
			for(i=0;i<NUMBER_OF_CBARS;i++)
			{
				if(	(MeasuredPalbCompCbChromaIRE[i].dblChromaIRE<	gdwColorBarLimitChromaIRE[i].dwPalCbChromaIRELowerLimit)||(MeasuredPalbCompCbChromaIRE[i].dblChromaIRE>gdwColorBarLimitChromaIRE[i].dwPalCbChromaIREUpperLimit))
					bPass=FALSE;
			}
		}
		if(bPass)
		{
			for(i=0;i<NUMBER_OF_CBARS-2;i++)
			{
				if(	(MeasuredPalbCompCbChromaPhase[i].dblChromaPhase<	gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseLowerLimit)||(MeasuredPalbCompCbChromaPhase[i].dblChromaPhase>gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseUpperLimit))
	 				bPass=FALSE;
			}
		}
		if(bPass)
			break;
	
	}//end retry loop

	//Report Statistic data of PAL-M Svideo color bar for Luma IRE:
	ReportStatistic(PAL_M_SVIDEO_COLOR_BAR_LUMA_IRE_WHITE, _T("%.1f"),m_LumaIREWhite);
	ReportStatistic(PAL_M_SVIDEO_COLOR_BAR_LUMA_IRE_YELLOW, _T("%.1f"),m_LumaIREYellow);
	ReportStatistic(PAL_M_SVIDEO_COLOR_BAR_LUMA_IRE_CYAN, _T("%.1f"),m_LumaIRECyan);
	ReportStatistic(PAL_M_SVIDEO_COLOR_BAR_LUMA_IRE_GREEN, _T("%.1f"),m_LumaIREGreen);
	ReportStatistic(PAL_M_SVIDEO_COLOR_BAR_LUMA_IRE_MAGENTA, _T("%.1f"),m_LumaIREMagenta);
	ReportStatistic(PAL_M_SVIDEO_COLOR_BAR_LUMA_IRE_RED, _T("%.1f"),m_LumaIRERed);
	ReportStatistic(PAL_M_SVIDEO_COLOR_BAR_LUMA_IRE_BLUE, _T("%.1f"),m_LumaIREBlue);
	ReportStatistic(PAL_M_SVIDEO_COLOR_BAR_LUMA_IRE_BLACK, _T("%.1f"),m_LumaIREBlack);

	//Report Statistic data of PAL-M Svideo color bar for Chroma IRE:
	ReportStatistic(PAL_M_SVIDEO_COLOR_BAR_CHROMA_IRE_WHITE, _T("%.1f"),m_ChromaIREWhite);
	ReportStatistic(PAL_M_SVIDEO_COLOR_BAR_CHROMA_IRE_YELLOW, _T("%.1f"),m_ChromaIREYellow);
	ReportStatistic(PAL_M_SVIDEO_COLOR_BAR_CHROMA_IRE_CYAN, _T("%.1f"),m_ChromaIRECyan);
	ReportStatistic(PAL_M_SVIDEO_COLOR_BAR_CHROMA_IRE_GREEN, _T("%.1f"),m_ChromaIREGreen);
	ReportStatistic(PAL_M_SVIDEO_COLOR_BAR_CHROMA_IRE_MAGENTA, _T("%.1f"),m_ChromaIREMagenta);
	ReportStatistic(PAL_M_SVIDEO_COLOR_BAR_CHROMA_IRE_RED, _T("%.1f"),m_ChromaIRERed);
	ReportStatistic(PAL_M_SVIDEO_COLOR_BAR_CHROMA_IRE_BLUE, _T("%.1f"),m_ChromaIREBlue);
	ReportStatistic(PAL_M_SVIDEO_COLOR_BAR_CHROMA_IRE_BLACK, _T("%.1f"),m_ChromaIREBlack);

	//Report Statistic data of PAL-M Svideo color bar for Chroma Phase:
	//ReportStatistic(PAL_M_COMPOSITE_COLOR_BAR_CHROMA_IRE_WHITE, _T("%.1f"),m_ChromaIREWhite);
	ReportStatistic(PAL_M_SVIDEO_COLOR_BAR_CHROMA_PHASE_YELLOW, _T("%.1f"),m_ChromaPhaseYellow);
	ReportStatistic(PAL_M_SVIDEO_COLOR_BAR_CHROMA_PHASE_CYAN, _T("%.1f"),m_ChromaPhaseCyan);
	ReportStatistic(PAL_M_SVIDEO_COLOR_BAR_CHROMA_PHASE_GREEN, _T("%.1f"),m_ChromaPhaseGreen);
	ReportStatistic(PAL_M_SVIDEO_COLOR_BAR_CHROMA_PHASE_MAGENTA, _T("%.1f"),m_ChromaPhaseMagenta);
	ReportStatistic(PAL_M_SVIDEO_COLOR_BAR_CHROMA_PHASE_RED, _T("%.1f"),m_ChromaPhaseRed);
	ReportStatistic(PAL_M_SVIDEO_COLOR_BAR_CHROMA_PHASE_BLUE, _T("%.1f"),m_ChromaPhaseBlue);
	//ReportStatistic(PAL_M_COMPOSITE_COLOR_BAR_CHROMA_IRE_BLACK, _T("%.1f"),m_ChromaIREBlack);

	if(!bPass)
	{
		for(i=0;i<NUMBER_OF_CBARS;i++)
		{
			if(	(MeasuredPalbCompCbLumaIRE[i].dblLumaIRE < gdwColorBarLimitLumaIRE[i].dwPalCbLumaIRELowerLimit)||(MeasuredPalbCompCbLumaIRE[i].dblLumaIRE > gdwColorBarLimitLumaIRE[i].dwPalCbLumaIREUpperLimit))
				err_LumaResultOutOfRange(i, MeasuredPalbCompCbLumaIRE[i].dblLumaIRE, dbStandardPalParams[i].dwStdPalCbParamLumaIRE,gdwColorBarLimitLumaIRE[i].dwPalCbLumaIREUpperLimit,gdwColorBarLimitLumaIRE[i].dwPalCbLumaIRELowerLimit);
		}

		for(i=0;i<NUMBER_OF_CBARS;i++)
		{
			if(	(MeasuredPalbCompCbChromaIRE[i].dblChromaIRE<	gdwColorBarLimitChromaIRE[i].dwPalCbChromaIRELowerLimit)||(MeasuredPalbCompCbChromaIRE[i].dblChromaIRE>gdwColorBarLimitChromaIRE[i].dwPalCbChromaIREUpperLimit))
				err_ChromaIREResultOutOfRange(i,MeasuredPalbCompCbChromaIRE[i].dblChromaIRE, dbStandardPalParams[i].dwStdPalCbParamChromaIRE,gdwColorBarLimitChromaIRE[i].dwPalCbChromaIREUpperLimit,gdwColorBarLimitChromaIRE[i].dwPalCbChromaIRELowerLimit);
		}
		for(i=0;i<NUMBER_OF_CBARS-2;i++)
		{
			if(	(MeasuredPalbCompCbChromaPhase[i].dblChromaPhase<	gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseLowerLimit)||(MeasuredPalbCompCbChromaPhase[i].dblChromaPhase>gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseUpperLimit))
	 			err_ChromaPhaseResultOutOfRange(i,MeasuredPalbCompCbChromaPhase[i].dblChromaPhase, 	dbStandardPalParams[i].dwStdPalCbParamChromaPhase,gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseUpperLimit,gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseLowerLimit);
		}
	}

	Cleanup();
	return;

}


IMPLEMENT_TESTLOCKED (TV, palncompcb, 11)
{
	CHostResponse CHR;
	char *send_buf = NULL;
	DWORD  dwMeasureResultBuffSize=EBUCb_ELEMS*2*sizeof(DWORD);
	DWORD *dwMeasureResultBuff=new DWORD[dwMeasureResultBuffSize/(sizeof(DWORD))];
	DWORD dwBufferToHostLength, dwActualBytesReceived, dwErrorCodeFromHost,i;
	int iError;
	dwBufferToHostLength=NULL;
	BOOL bPass=TRUE;

	if (CheckAbort (HERE)){ Cleanup(); return;};

	NTSCM_COMP_CB_DATA MeasuredPalbCompCbLumaIRE[NUMBER_OF_CBARS];
	NTSCM_COMP_CB_DATA MeasuredPalbCompCbChromaIRE[NUMBER_OF_CBARS];
	NTSCM_COMP_CB_DATA MeasuredPalbCompCbChromaPhase[NUMBER_OF_CBARS];

	
	DrawPALCB();
	PALCBRender();

    // Present the backbuffer contents to the display
    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );

	for(int attempts=0; attempts<m_testRetries; attempts++)
	{
		if ((iError = g_host.iSendHost(MID_PAL_N_COMP_CB, send_buf, dwBufferToHostLength, CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, XTV_TIMEOUT)) != EVERYTHINGS_OK)
		{
			if (dwErrorCodeFromHost != 0)
			{
				// Process error from host
				if (err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost))
					return;
			}
			else
			{
				// Process a communication error
				// This test module just reports the number of the communication error that was received
				if (err_HostCommunicationError(iError))
					return;
			}
		}
		else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
		{
			// The response buffer is empty, so take appropriate action (like an error message)
			err_RecordBufferIsEmpty();
			return;
		}
		else // The response is not NULL, and is not an error message, so process it
		{
			if (dwActualBytesReceived < dwMeasureResultBuffSize)
			{
				err_RecordBufferIsNotCorrectLength(dwMeasureResultBuffSize, dwActualBytesReceived);
				return;
			}
		}

		memcpy(dwMeasureResultBuff, CHR.pvBufferFromHost, dwMeasureResultBuffSize); 

		// using string input to extract the datas from host in the measureresultbuff
		using namespace std;
		string input((char *)dwMeasureResultBuff);
		istringstream inputString(input);

		inputString >> m_LumaIREWhite >>m_LumaIREYellow >>m_LumaIRECyan >> m_LumaIREGreen>>m_LumaIREMagenta 
					>> m_LumaIRERed >> m_LumaIREBlue >> m_LumaIREBlack
					>> m_ChromaIREWhite >>m_ChromaIREYellow >>m_ChromaIRECyan >> m_ChromaIREGreen
					>>m_ChromaIREMagenta >> m_ChromaIRERed >> m_ChromaIREBlue >> m_ChromaIREBlack
					>>m_ChromaPhaseYellow >>m_ChromaPhaseCyan >> m_ChromaPhaseGreen>>m_ChromaPhaseMagenta >> m_ChromaPhaseRed 
					>> m_ChromaPhaseBlue;

		MeasuredPalbCompCbLumaIRE[0].dblLumaIRE=m_LumaIREWhite;
		MeasuredPalbCompCbLumaIRE[1].dblLumaIRE= m_LumaIREYellow;
		MeasuredPalbCompCbLumaIRE[2].dblLumaIRE= m_LumaIRECyan;
		MeasuredPalbCompCbLumaIRE[3].dblLumaIRE= m_LumaIREGreen;
		MeasuredPalbCompCbLumaIRE[4].dblLumaIRE= m_LumaIREMagenta;
		MeasuredPalbCompCbLumaIRE[5].dblLumaIRE= m_LumaIRERed;
		MeasuredPalbCompCbLumaIRE[6].dblLumaIRE= m_LumaIREBlue;
		MeasuredPalbCompCbLumaIRE[7].dblLumaIRE= m_LumaIREBlack;

		MeasuredPalbCompCbChromaIRE[0].dblChromaIRE= m_ChromaIREWhite;
		MeasuredPalbCompCbChromaIRE[1].dblChromaIRE= m_ChromaIREYellow;
		MeasuredPalbCompCbChromaIRE[2].dblChromaIRE= m_ChromaIRECyan;
		MeasuredPalbCompCbChromaIRE[3].dblChromaIRE= m_ChromaIREGreen;
		MeasuredPalbCompCbChromaIRE[4].dblChromaIRE= m_ChromaIREMagenta;
		MeasuredPalbCompCbChromaIRE[5].dblChromaIRE= m_ChromaIRERed;
		MeasuredPalbCompCbChromaIRE[6].dblChromaIRE= m_ChromaIREBlue;
		MeasuredPalbCompCbChromaIRE[7].dblChromaIRE= m_ChromaIREBlack;

		//MeasuredNtscChromaPhase[0].dblChromaPhase= m_ChromaPhaseWhite;
		MeasuredPalbCompCbChromaPhase[0].dblChromaPhase= m_ChromaPhaseYellow;
		MeasuredPalbCompCbChromaPhase[1].dblChromaPhase= m_ChromaPhaseCyan;
		MeasuredPalbCompCbChromaPhase[2].dblChromaPhase= m_ChromaPhaseGreen;
		MeasuredPalbCompCbChromaPhase[3].dblChromaPhase= m_ChromaPhaseMagenta;
		MeasuredPalbCompCbChromaPhase[4].dblChromaPhase= m_ChromaPhaseRed;
		MeasuredPalbCompCbChromaPhase[5].dblChromaPhase= m_ChromaPhaseBlue;
		//MeasuredNtscChromaPhase[7].dblChromaPhase= m_ChromaPhaseBlack;

		bPass=TRUE;
		for(i=0;i<NUMBER_OF_CBARS;i++)
		{
			if(	(MeasuredPalbCompCbLumaIRE[i].dblLumaIRE < gdwColorBarLimitLumaIRE[i].dwPalCbLumaIRELowerLimit)||(MeasuredPalbCompCbLumaIRE[i].dblLumaIRE > gdwColorBarLimitLumaIRE[i].dwPalCbLumaIREUpperLimit))
				bPass=FALSE;
		}
		if(bPass)
		{
			for(i=0;i<NUMBER_OF_CBARS;i++)
			{
				if(	(MeasuredPalbCompCbChromaIRE[i].dblChromaIRE<	gdwColorBarLimitChromaIRE[i].dwPalCbChromaIRELowerLimit)||(MeasuredPalbCompCbChromaIRE[i].dblChromaIRE>gdwColorBarLimitChromaIRE[i].dwPalCbChromaIREUpperLimit))
					bPass=FALSE;
			}
		}
		if(bPass)
		{
			for(i=0;i<NUMBER_OF_CBARS-2;i++){
				if(	(MeasuredPalbCompCbChromaPhase[i].dblChromaPhase<	gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseLowerLimit)||(MeasuredPalbCompCbChromaPhase[i].dblChromaPhase>gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseUpperLimit))
	 				bPass=FALSE;
			}
		}
		if(bPass)
			break;
		
	}//end retry loop

	if(!bPass)
	{
		for(i=0;i<NUMBER_OF_CBARS;i++)
		{
			if(	(MeasuredPalbCompCbLumaIRE[i].dblLumaIRE < gdwColorBarLimitLumaIRE[i].dwPalCbLumaIRELowerLimit)||(MeasuredPalbCompCbLumaIRE[i].dblLumaIRE > gdwColorBarLimitLumaIRE[i].dwPalCbLumaIREUpperLimit))
				err_LumaResultOutOfRange(i,MeasuredPalbCompCbLumaIRE[i].dblLumaIRE, dbStandardPalParams[i].dwStdPalCbParamLumaIRE,gdwColorBarLimitLumaIRE[i].dwPalCbLumaIREUpperLimit,gdwColorBarLimitLumaIRE[i].dwPalCbLumaIRELowerLimit);
		}
		for(i=0;i<NUMBER_OF_CBARS;i++)
		{
			if(	(MeasuredPalbCompCbChromaIRE[i].dblChromaIRE<	gdwColorBarLimitChromaIRE[i].dwPalCbChromaIRELowerLimit)||(MeasuredPalbCompCbChromaIRE[i].dblChromaIRE>gdwColorBarLimitChromaIRE[i].dwPalCbChromaIREUpperLimit))
				err_ChromaIREResultOutOfRange(i,MeasuredPalbCompCbChromaIRE[i].dblChromaIRE, dbStandardPalParams[i].dwStdPalCbParamChromaIRE,gdwColorBarLimitChromaIRE[i].dwPalCbChromaIREUpperLimit,gdwColorBarLimitChromaIRE[i].dwPalCbChromaIRELowerLimit);
		}
		for(i=0;i<NUMBER_OF_CBARS-2;i++)
		{
			if(	(MeasuredPalbCompCbChromaPhase[i].dblChromaPhase<	gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseLowerLimit)||(MeasuredPalbCompCbChromaPhase[i].dblChromaPhase>gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseUpperLimit))
	 			err_ChromaPhaseResultOutOfRange(i,MeasuredPalbCompCbChromaPhase[i].dblChromaPhase, 	dbStandardPalParams[i].dwStdPalCbParamChromaPhase,gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseUpperLimit,gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseLowerLimit);
		}
	}
	
	Cleanup();
	return;

}


IMPLEMENT_TESTLOCKED (TV, palnsvpcb, 12)
{

	CHostResponse CHR;
	char *send_buf = NULL;
	DWORD  dwMeasureResultBuffSize=EBUCb_ELEMS*2*sizeof(DWORD);
	DWORD *dwMeasureResultBuff=new DWORD[dwMeasureResultBuffSize/(sizeof(DWORD))];
	DWORD dwBufferToHostLength, dwActualBytesReceived, dwErrorCodeFromHost,i;
	int iError;
	dwBufferToHostLength=NULL;
	BOOL bPass=TRUE;

	if (CheckAbort (HERE)){ Cleanup(); return;};

	NTSCM_COMP_CB_DATA MeasuredPalbCompCbLumaIRE[NUMBER_OF_CBARS];
	NTSCM_COMP_CB_DATA MeasuredPalbCompCbChromaIRE[NUMBER_OF_CBARS];
	NTSCM_COMP_CB_DATA MeasuredPalbCompCbChromaPhase[NUMBER_OF_CBARS];
	
	DrawPALCB();
	PALCBRender();

    // Present the backbuffer contents to the display
    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );

	for(int attempts=0; attempts<m_testRetries; attempts++)
	{
		if ((iError = g_host.iSendHost(MID_PAL_N_SVIDEO_CB, send_buf, dwBufferToHostLength, CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, XTV_TIMEOUT)) != EVERYTHINGS_OK)
		{
			if (dwErrorCodeFromHost != 0)
			{
				// Process error from host
				if (err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost))
					return;
			}
			else
			{
				// Process a communication error
				// This test module just reports the number of the communication error that was received
				if (err_HostCommunicationError(iError))
					return;
			}
		}
		else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
		{
			// The response buffer is empty, so take appropriate action (like an error message)
			err_RecordBufferIsEmpty();
			return;
		}
		else // The response is not NULL, and is not an error message, so process it
		{
			if (dwActualBytesReceived < dwMeasureResultBuffSize)
			{
				err_RecordBufferIsNotCorrectLength(dwMeasureResultBuffSize, dwActualBytesReceived);
				return;
			}
		}

		memcpy(dwMeasureResultBuff, CHR.pvBufferFromHost, dwMeasureResultBuffSize); 

		// using string input to extract the datas from host in the measureresultbuff
		using namespace std;
		string input((char *)dwMeasureResultBuff);
		istringstream inputString(input);

		inputString >> m_LumaIREWhite >>m_LumaIREYellow >>m_LumaIRECyan >> m_LumaIREGreen>>m_LumaIREMagenta 
					>> m_LumaIRERed >> m_LumaIREBlue >> m_LumaIREBlack
					>> m_ChromaIREWhite >>m_ChromaIREYellow >>m_ChromaIRECyan >> m_ChromaIREGreen
					>>m_ChromaIREMagenta >> m_ChromaIRERed >> m_ChromaIREBlue >> m_ChromaIREBlack
					>>m_ChromaPhaseYellow >>m_ChromaPhaseCyan >> m_ChromaPhaseGreen>>m_ChromaPhaseMagenta >> m_ChromaPhaseRed 
					>> m_ChromaPhaseBlue;

		MeasuredPalbCompCbLumaIRE[0].dblLumaIRE=m_LumaIREWhite;
		MeasuredPalbCompCbLumaIRE[1].dblLumaIRE= m_LumaIREYellow;
		MeasuredPalbCompCbLumaIRE[2].dblLumaIRE= m_LumaIRECyan;
		MeasuredPalbCompCbLumaIRE[3].dblLumaIRE= m_LumaIREGreen;
		MeasuredPalbCompCbLumaIRE[4].dblLumaIRE= m_LumaIREMagenta;
		MeasuredPalbCompCbLumaIRE[5].dblLumaIRE= m_LumaIRERed;
		MeasuredPalbCompCbLumaIRE[6].dblLumaIRE= m_LumaIREBlue;
		MeasuredPalbCompCbLumaIRE[7].dblLumaIRE= m_LumaIREBlack;

		MeasuredPalbCompCbChromaIRE[0].dblChromaIRE= m_ChromaIREWhite;
		MeasuredPalbCompCbChromaIRE[1].dblChromaIRE= m_ChromaIREYellow;
		MeasuredPalbCompCbChromaIRE[2].dblChromaIRE= m_ChromaIRECyan;
		MeasuredPalbCompCbChromaIRE[3].dblChromaIRE= m_ChromaIREGreen;
		MeasuredPalbCompCbChromaIRE[4].dblChromaIRE= m_ChromaIREMagenta;
		MeasuredPalbCompCbChromaIRE[5].dblChromaIRE= m_ChromaIRERed;
		MeasuredPalbCompCbChromaIRE[6].dblChromaIRE= m_ChromaIREBlue;
		MeasuredPalbCompCbChromaIRE[7].dblChromaIRE= m_ChromaIREBlack;

		//MeasuredNtscChromaPhase[0].dblChromaPhase= m_ChromaPhaseWhite;
		MeasuredPalbCompCbChromaPhase[0].dblChromaPhase= m_ChromaPhaseYellow;
		MeasuredPalbCompCbChromaPhase[1].dblChromaPhase= m_ChromaPhaseCyan;
		MeasuredPalbCompCbChromaPhase[2].dblChromaPhase= m_ChromaPhaseGreen;
		MeasuredPalbCompCbChromaPhase[3].dblChromaPhase= m_ChromaPhaseMagenta;
		MeasuredPalbCompCbChromaPhase[4].dblChromaPhase= m_ChromaPhaseRed;
		MeasuredPalbCompCbChromaPhase[5].dblChromaPhase= m_ChromaPhaseBlue;
		//MeasuredNtscChromaPhase[7].dblChromaPhase= m_ChromaPhaseBlack;

		bPass=TRUE;
		for(i=0;i<NUMBER_OF_CBARS;i++)
		{
			if(	(MeasuredPalbCompCbLumaIRE[i].dblLumaIRE < gdwColorBarLimitLumaIRE[i].dwPalCbLumaIRELowerLimit)||(MeasuredPalbCompCbLumaIRE[i].dblLumaIRE > gdwColorBarLimitLumaIRE[i].dwPalCbLumaIREUpperLimit))
				bPass=FALSE;
		}
		if(bPass)
		{
			for(i=0;i<NUMBER_OF_CBARS;i++)
			{
				if(	(MeasuredPalbCompCbChromaIRE[i].dblChromaIRE<	gdwColorBarLimitChromaIRE[i].dwPalCbChromaIRELowerLimit)||(MeasuredPalbCompCbChromaIRE[i].dblChromaIRE>gdwColorBarLimitChromaIRE[i].dwPalCbChromaIREUpperLimit))
					bPass=FALSE;
			}
		}
		if(bPass)
		{
			for(i=0;i<NUMBER_OF_CBARS-2;i++)
			{
				if(	(MeasuredPalbCompCbChromaPhase[i].dblChromaPhase<	gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseLowerLimit)||(MeasuredPalbCompCbChromaPhase[i].dblChromaPhase>gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseUpperLimit))
	 				bPass=FALSE;
			}
		}
		if(bPass)
			break;

	}//end retry loop
	
	
	if(!bPass)
	{
		for(i=0;i<NUMBER_OF_CBARS;i++)
		{
			if(	(MeasuredPalbCompCbLumaIRE[i].dblLumaIRE < gdwColorBarLimitLumaIRE[i].dwPalCbLumaIRELowerLimit)||(MeasuredPalbCompCbLumaIRE[i].dblLumaIRE > gdwColorBarLimitLumaIRE[i].dwPalCbLumaIREUpperLimit))
				err_LumaResultOutOfRange(i, MeasuredPalbCompCbLumaIRE[i].dblLumaIRE, dbStandardPalParams[i].dwStdPalCbParamLumaIRE,gdwColorBarLimitLumaIRE[i].dwPalCbLumaIREUpperLimit,gdwColorBarLimitLumaIRE[i].dwPalCbLumaIRELowerLimit);
		}
		for(i=0;i<NUMBER_OF_CBARS;i++)
		{
			if(	(MeasuredPalbCompCbChromaIRE[i].dblChromaIRE<	gdwColorBarLimitChromaIRE[i].dwPalCbChromaIRELowerLimit)||(MeasuredPalbCompCbChromaIRE[i].dblChromaIRE>gdwColorBarLimitChromaIRE[i].dwPalCbChromaIREUpperLimit))
				err_ChromaIREResultOutOfRange(i,MeasuredPalbCompCbChromaIRE[i].dblChromaIRE, dbStandardPalParams[i].dwStdPalCbParamChromaIRE,gdwColorBarLimitChromaIRE[i].dwPalCbChromaIREUpperLimit,gdwColorBarLimitChromaIRE[i].dwPalCbChromaIRELowerLimit);
		}
		for(i=0;i<NUMBER_OF_CBARS-2;i++)
		{
			if(	(MeasuredPalbCompCbChromaPhase[i].dblChromaPhase<	gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseLowerLimit)||(MeasuredPalbCompCbChromaPhase[i].dblChromaPhase>gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseUpperLimit))
	 			err_ChromaPhaseResultOutOfRange(i,MeasuredPalbCompCbChromaPhase[i].dblChromaPhase, 	dbStandardPalParams[i].dwStdPalCbParamChromaPhase,gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseUpperLimit,gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseLowerLimit);
		}
	}

	Cleanup();
	return;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xtv\palmb.cpp ===
// 
// (c) Copyright 2000-2000 Intel Corp. All rights reserved.
//   ntscmb.cpp: used to implement ntsc-m and ntsc-Japan multiburst 
//   tests for composite and s-video output. The subtests include 
//	ntscmcompmb, ntscmsvmb, ntscjcompmb, and ntscjsvmb
//
//////////////////////////////////////////////////////////////////////
#include "..\stdafx.h"
#include <iostream>
#include <string>
#include <sstream>

#include "XTV.h"
#include "..\statkeys.h"



#define Burst_Elems	8

IMPLEMENT_TESTLOCKED (TV, palbcompmb, 17)
{
	CHostResponse CHR;
	DWORD  dwMeasureResultBuffSize=Burst_Elems*2*sizeof(DWORD);
	DWORD *dwMeasureResultBuff=new DWORD[dwMeasureResultBuffSize/(sizeof(DWORD))];
	char *send_buf = NULL;
	DWORD dwBufferToHostLength, dwActualBytesReceived, dwErrorCodeFromHost,i;
	int iError,videomode;
	dwBufferToHostLength=NULL;
	BOOL bPass=TRUE;


	if (CheckAbort (HERE)){ Cleanup(); return;};

	MULTIBURST_CONFIG_DATA MeasuredPalbCompMb[NUMBER_OF_FREQ];

	videomode=GetCfgInt(L"videomode", -1);

	switch(videomode)
	{
		case 1:
			DrawPalMB();
			PALMBRender();
			break;
		case 3:
			DrawMode3PALMB();
			PALMBRender();
			break;
		case 4:
			DrawMode4PALMB();
			PALMBRender();
			break;
		case 6:
			DrawMode6PALMB();
			PALMBRender();
			break;

		default:
			break;
	}


    // Present the backbuffer contents to the display
    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
   
	for(int attempts=0; attempts<m_testRetries; attempts++)
	{
		if ((iError = g_host.iSendHost(MID_PAL_BDGHI_COMP_MB, send_buf, dwBufferToHostLength, CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, XTV_TIMEOUT)) != EVERYTHINGS_OK)
		{
			if (dwErrorCodeFromHost != 0)
			{
				// Process error from host
				err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost);
				return;
			}
			else
			{
				// Process a communication error
				// This test module just reports the number of the communication error that was received
				err_HostCommunicationError(iError);
				return;
			}
		}
		else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
		{
			// The response buffer is empty, so take appropriate action (like an error message)
			err_RecordBufferIsEmpty();
			return;
		}
		else // The response is not NULL, and is not an error message, so process it
		{
			if (dwActualBytesReceived < dwMeasureResultBuffSize)
			{
				err_RecordBufferIsNotCorrectLength(dwMeasureResultBuffSize, dwActualBytesReceived);
				return;
			}
		}
		memcpy(dwMeasureResultBuff, CHR.pvBufferFromHost, dwMeasureResultBuffSize); 

		using namespace std;
		string input((char *)dwMeasureResultBuff);
		istringstream inputString(input);
		inputString >>m_PalbFreq1 >>m_PalbFreq2	>>m_PalbFreq3 >>m_PalbFreq4
					>>m_PalbFreq5 >>m_PalbFreq6	>>m_PalbFreq7;


		if(m_PalbFreq2>MAXATTENU) MeasuredPalbCompMb[0].dbFreqResponse=m_PalbFreq2;
		else MeasuredPalbCompMb[0].dbFreqResponse=0.0;

		if(m_PalbFreq3>MAXATTENU) MeasuredPalbCompMb[1].dbFreqResponse=m_PalbFreq3;
		else MeasuredPalbCompMb[1].dbFreqResponse=0.0;

		if(m_PalbFreq4>MAXATTENU) MeasuredPalbCompMb[2].dbFreqResponse=m_PalbFreq4;
		else MeasuredPalbCompMb[2].dbFreqResponse=0.0;

		if(m_PalbFreq5>MAXATTENU) MeasuredPalbCompMb[3].dbFreqResponse=m_PalbFreq5;
		else MeasuredPalbCompMb[3].dbFreqResponse=0.0;

		if(m_PalbFreq6>MAXATTENU) MeasuredPalbCompMb[4].dbFreqResponse=m_PalbFreq6;
		else MeasuredPalbCompMb[4].dbFreqResponse=0.0;

		if(m_PalbFreq7>MAXATTENU) MeasuredPalbCompMb[5].dbFreqResponse=m_PalbFreq7;
		else MeasuredPalbCompMb[5].dbFreqResponse=0.0;


		bPass=TRUE;
		for(i=0;i<NUMBER_OF_FREQ;i++)
		{
			if((MeasuredPalbCompMb[i].dbFreqResponse<dbFreqLimit[i].PalCompLowerLimit) || (MeasuredPalbCompMb[i].dbFreqResponse>dbFreqLimit[i].PalCompUpperLimit))
				bPass=FALSE;
		}
		
	}//end retry loop
	
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET1,_T("%.1f"),MeasuredPalbCompMb[0].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET2,_T("%.1f"), MeasuredPalbCompMb[1].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET3,_T("%.1f"), MeasuredPalbCompMb[2].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET4,_T("%.1f"), MeasuredPalbCompMb[3].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET5,_T("%.1f"), MeasuredPalbCompMb[4].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET6,_T("%.1f"), MeasuredPalbCompMb[5].dbFreqResponse);

	if(!bPass)
	{
		for(i=0;i<NUMBER_OF_FREQ;i++)
		{
			if((MeasuredPalbCompMb[i].dbFreqResponse<dbFreqLimit[i].PalCompLowerLimit) || (MeasuredPalbCompMb[i].dbFreqResponse>dbFreqLimit[i].PalCompUpperLimit))
				err_MBurstResultOutOfRange (i+1,MeasuredPalbCompMb[i].dbFreqResponse,dbFreqLimit[i].PalCompLowerLimit,dbFreqLimit[i].PalCompUpperLimit );
		}
	}

	Cleanup();
	return;

}



IMPLEMENT_TESTLOCKED (TV, palbsvmb, 18)
{
	CHostResponse CHR;
	DWORD  dwMeasureResultBuffSize=Burst_Elems*2*sizeof(DWORD);
	DWORD *dwMeasureResultBuff=new DWORD[dwMeasureResultBuffSize/(sizeof(DWORD))];
	char *send_buf = NULL;
	DWORD dwBufferToHostLength, dwActualBytesReceived, dwErrorCodeFromHost,i;	
	int iError,videomode;
	dwBufferToHostLength=NULL;
	BOOL bPass=TRUE;
	
	if (CheckAbort (HERE)){ Cleanup(); return;};

	MULTIBURST_CONFIG_DATA MeasuredPalbSvMb[NUMBER_OF_FREQ];	
	videomode=GetCfgInt(L"videomode", -1);

	switch(videomode)
	{
		case 1:
			DrawPalMB();
			PALMBRender();
			break;
		case 3:
			DrawMode3PALMB();
			PALMBRender();
			break;
		case 4:
			DrawMode4PALMB();
			PALMBRender();
			break;
		case 6:
			DrawMode6PALMB();
			PALMBRender();
			break;

		default:
			break;
	}

    // Present the backbuffer contents to the display
    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
   
	for(int attempts=0; attempts<m_testRetries; attempts++)
	{
		if ((iError = g_host.iSendHost(MID_PAL_BDGHI_SVIDEO_MB, send_buf, dwBufferToHostLength, CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, XTV_TIMEOUT)) != EVERYTHINGS_OK)
		{
			if (dwErrorCodeFromHost != 0)
			{
				// Process error from host
				err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost);
				return;
			}
			else
			{
				// Process a communication error
				// This test module just reports the number of the communication error that was received
				err_HostCommunicationError(iError);
				return;
			}
		}
		else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
		{
			// The response buffer is empty, so take appropriate action (like an error message)
			err_RecordBufferIsEmpty();
			return;
		}
		else // The response is not NULL, and is not an error message, so process it
		{
			if (dwActualBytesReceived < dwMeasureResultBuffSize)
			{
				err_RecordBufferIsNotCorrectLength(dwMeasureResultBuffSize, dwActualBytesReceived);
				return;
			}
		}
		memcpy(dwMeasureResultBuff, CHR.pvBufferFromHost, dwMeasureResultBuffSize); 

		using namespace std;
		string input((char *)dwMeasureResultBuff);
		istringstream inputString(input);

		inputString >>m_PalbFreq1 >>m_PalbFreq2 >>m_PalbFreq3 >>m_PalbFreq4
					>>m_PalbFreq5 >>m_PalbFreq6 >>m_PalbFreq7;

		if(m_PalbFreq2>MAXATTENU) MeasuredPalbSvMb[0].dbFreqResponse=m_PalbFreq2;
		else MeasuredPalbSvMb[0].dbFreqResponse=0.0;

		if(m_PalbFreq3>MAXATTENU) MeasuredPalbSvMb[1].dbFreqResponse=m_PalbFreq3;
		else MeasuredPalbSvMb[1].dbFreqResponse=0.0;

		if(m_PalbFreq4>MAXATTENU) MeasuredPalbSvMb[2].dbFreqResponse=m_PalbFreq4;
		else MeasuredPalbSvMb[2].dbFreqResponse=0.0;

		if(m_PalbFreq5>MAXATTENU) MeasuredPalbSvMb[3].dbFreqResponse=m_PalbFreq5;
		else MeasuredPalbSvMb[3].dbFreqResponse=0.0;

		if(m_PalbFreq6>MAXATTENU) MeasuredPalbSvMb[4].dbFreqResponse=m_PalbFreq6;
		else MeasuredPalbSvMb[4].dbFreqResponse=0.0;

		if(m_PalbFreq7>MAXATTENU) MeasuredPalbSvMb[5].dbFreqResponse=m_PalbFreq7;
		else MeasuredPalbSvMb[5].dbFreqResponse=0.0;

		bPass=TRUE;
		for(i=0;i<NUMBER_OF_FREQ;i++)
		{
			if((MeasuredPalbSvMb[i].dbFreqResponse<dbFreqLimit[i].PalCompLowerLimit) || (MeasuredPalbSvMb[i].dbFreqResponse>dbFreqLimit[i].PalCompUpperLimit))
				bPass=FALSE;
		}
		if(bPass)
			break;

	}//end retry loop
	
	ReportStatistic(PAL_BDGHI_SVIDEO_MULTIBURST_FREQUEN_PACKET1,_T("%.1f"),MeasuredPalbSvMb[0].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_SVIDEO_MULTIBURST_FREQUEN_PACKET2,_T("%.1f"), MeasuredPalbSvMb[1].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_SVIDEO_MULTIBURST_FREQUEN_PACKET3,_T("%.1f"), MeasuredPalbSvMb[2].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_SVIDEO_MULTIBURST_FREQUEN_PACKET4,_T("%.1f"), MeasuredPalbSvMb[3].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_SVIDEO_MULTIBURST_FREQUEN_PACKET5,_T("%.1f"), MeasuredPalbSvMb[4].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_SVIDEO_MULTIBURST_FREQUEN_PACKET6,_T("%.1f"), MeasuredPalbSvMb[5].dbFreqResponse);

	if(!bPass)
	{
		for(i=0;i<NUMBER_OF_FREQ;i++)
		{
			if((MeasuredPalbSvMb[i].dbFreqResponse<dbFreqLimit[i].PalCompLowerLimit) || (MeasuredPalbSvMb[i].dbFreqResponse>dbFreqLimit[i].PalCompUpperLimit))
				err_MBurstResultOutOfRange (i+1,MeasuredPalbSvMb[i].dbFreqResponse,dbFreqLimit[i].PalSvLowerLimit,dbFreqLimit[i].PalCompUpperLimit );
		}
	}
	
	Cleanup();
	return;

}




IMPLEMENT_TESTLOCKED (TV, secamcompmb, 19)
{
	CHostResponse CHR;
	DWORD  dwMeasureResultBuffSize=Burst_Elems*2*sizeof(DWORD);
	DWORD *dwMeasureResultBuff=new DWORD[dwMeasureResultBuffSize/(sizeof(DWORD))];
	char *send_buf = NULL;
	DWORD dwBufferToHostLength, dwActualBytesReceived, dwErrorCodeFromHost,i;
	int iError;
	dwBufferToHostLength=NULL;
	BOOL bPass=TRUE;

	if (CheckAbort (HERE)){ Cleanup(); return;};

	MULTIBURST_CONFIG_DATA MeasuredPalbCompMb[NUMBER_OF_FREQ];

	DrawPalMB();
    PALMBRender();

    // Present the backbuffer contents to the display
    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
   
	for(int attempts=0; attempts<m_testRetries; attempts++)
	{
		if ((iError = g_host.iSendHost(MID_SECAM_COMP_MB, send_buf, dwBufferToHostLength, CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, XTV_TIMEOUT)) != EVERYTHINGS_OK)
		{

		if (dwErrorCodeFromHost != 0)
			{
				// Process error from host
				err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost);
				return;
			}
			else
			{
				// Process a communication error
				// This test module just reports the number of the communication error that was received
				err_HostCommunicationError(iError);
				return;
			}
		}
		else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
		{
			// The response buffer is empty, so take appropriate action (like an error message)
			err_RecordBufferIsEmpty();
			return;
		}
		else // The response is not NULL, and is not an error message, so process it
		{
			if (dwActualBytesReceived < dwMeasureResultBuffSize)
			{
				err_RecordBufferIsNotCorrectLength(dwMeasureResultBuffSize, dwActualBytesReceived);
				return;
			}
			
		}
		memcpy(dwMeasureResultBuff, CHR.pvBufferFromHost, dwMeasureResultBuffSize); 

		using namespace std;
		string input((char *)dwMeasureResultBuff);
		istringstream inputString(input);


		inputString >>m_PalbFreq1 >>m_PalbFreq2 >>m_PalbFreq3 >>m_PalbFreq4
					>>m_PalbFreq5 >>m_PalbFreq6 >>m_PalbFreq7;

		if(m_PalbFreq2>MAXATTENU) MeasuredPalbCompMb[0].dbFreqResponse=m_PalbFreq2;
		else MeasuredPalbCompMb[0].dbFreqResponse=0.0;

		if(m_PalbFreq3>MAXATTENU) MeasuredPalbCompMb[1].dbFreqResponse=m_PalbFreq3;
		else MeasuredPalbCompMb[1].dbFreqResponse=0.0;

		if(m_PalbFreq4>MAXATTENU) MeasuredPalbCompMb[2].dbFreqResponse=m_PalbFreq4;
		else MeasuredPalbCompMb[2].dbFreqResponse=0.0;

		if(m_PalbFreq5>MAXATTENU) MeasuredPalbCompMb[3].dbFreqResponse=m_PalbFreq5;
		else MeasuredPalbCompMb[3].dbFreqResponse=0.0;

		if(m_PalbFreq6>MAXATTENU) MeasuredPalbCompMb[4].dbFreqResponse=m_PalbFreq6;
		else MeasuredPalbCompMb[4].dbFreqResponse=0.0;

		if(m_PalbFreq7>MAXATTENU) MeasuredPalbCompMb[5].dbFreqResponse=m_PalbFreq7;
		else MeasuredPalbCompMb[5].dbFreqResponse=0.0;

		bPass=TRUE;
		for(i=0;i<NUMBER_OF_FREQ;i++)
		{
			if((MeasuredPalbCompMb[i].dbFreqResponse<dbFreqLimit[i].PalCompLowerLimit) || (MeasuredPalbCompMb[i].dbFreqResponse>dbFreqLimit[i].PalCompUpperLimit))
				bPass=FALSE;
		}
		if(bPass)
			break;

	}//end retry loop

	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET1,_T("%.1f"),MeasuredPalbCompMb[0].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET2,_T("%.1f"), MeasuredPalbCompMb[1].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET3,_T("%.1f"), MeasuredPalbCompMb[2].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET4,_T("%.1f"), MeasuredPalbCompMb[3].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET5,_T("%.1f"), MeasuredPalbCompMb[4].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET6,_T("%.1f"), MeasuredPalbCompMb[5].dbFreqResponse);

	
	if(!bPass)
	{
		if((MeasuredPalbCompMb[0].dbFreqResponse==0.0)&&(MeasuredPalbCompMb[1].dbFreqResponse==0.0)&&(MeasuredPalbCompMb[2].dbFreqResponse==0.0)&&(MeasuredPalbCompMb[3].dbFreqResponse==0.0)&&(MeasuredPalbCompMb[4].dbFreqResponse==0.0)&&(MeasuredPalbCompMb[5].dbFreqResponse==0.0))
			err_NoConnection();
		else
		{
			for(i=0;i<NUMBER_OF_FREQ;i++)
			{
				if((MeasuredPalbCompMb[i].dbFreqResponse<dbFreqLimit[i].PalCompLowerLimit) || (MeasuredPalbCompMb[i].dbFreqResponse>dbFreqLimit[i].PalCompUpperLimit))
					err_MBurstResultOutOfRange (i+1,MeasuredPalbCompMb[i].dbFreqResponse,dbFreqLimit[i].PalCompLowerLimit,dbFreqLimit[i].PalCompUpperLimit );
			}
		}
	}

	Cleanup();
	return;

}




IMPLEMENT_TESTLOCKED (TV, secamsvmb, 20)
{
	CHostResponse CHR;
	DWORD  dwMeasureResultBuffSize=Burst_Elems*2*sizeof(DWORD);
	DWORD *dwMeasureResultBuff=new DWORD[dwMeasureResultBuffSize/(sizeof(DWORD))];
	char *send_buf = NULL;
	DWORD dwBufferToHostLength, dwActualBytesReceived, dwErrorCodeFromHost,i;
	int iError;
	dwBufferToHostLength=NULL;
	BOOL bPass=TRUE;

	if (CheckAbort (HERE)){ Cleanup(); return;};

	MULTIBURST_CONFIG_DATA MeasuredPalbSvMb[NUMBER_OF_FREQ];

	DrawPalMB();
    PALMBRender();

    // Present the backbuffer contents to the display
    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
    	
	for(int attempts=0; attempts<m_testRetries; attempts++)
	{
		if ((iError = g_host.iSendHost(MID_SECAM_SVIDEO_MB, send_buf, dwBufferToHostLength, CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, XTV_TIMEOUT)) != EVERYTHINGS_OK)
		{
			if (dwErrorCodeFromHost != 0)
			{
				// Process error from host
				err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost);
				return;
			}
			else
			{
				// Process a communication error
				// This test module just reports the number of the communication error that was received
				err_HostCommunicationError(iError);
				return;
			}
		}
		else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
		{
			// The response buffer is empty, so take appropriate action (like an error message)
			err_RecordBufferIsEmpty();
			return;
		}
		else // The response is not NULL, and is not an error message, so process it
		{
			if (dwActualBytesReceived < dwMeasureResultBuffSize)
			{
				err_RecordBufferIsNotCorrectLength(dwMeasureResultBuffSize, dwActualBytesReceived);
				return;
			}
		}

		memcpy(dwMeasureResultBuff, CHR.pvBufferFromHost, dwMeasureResultBuffSize); 

		using namespace std;
		string input((char *)dwMeasureResultBuff);
		istringstream inputString(input);

		inputString >>m_PalbFreq1 >>m_PalbFreq2 >>m_PalbFreq3 >>m_PalbFreq4
					>>m_PalbFreq5 >>m_PalbFreq6 >>m_PalbFreq7;

		if(m_PalbFreq2>MAXATTENU) MeasuredPalbSvMb[0].dbFreqResponse=0.0;
		else MeasuredPalbSvMb[0].dbFreqResponse=m_PalbFreq2;

		if(m_PalbFreq3>MAXATTENU) MeasuredPalbSvMb[1].dbFreqResponse=0.0;
		else MeasuredPalbSvMb[1].dbFreqResponse=m_PalbFreq3;

		if(m_PalbFreq4>MAXATTENU) MeasuredPalbSvMb[2].dbFreqResponse=0.0;
		else MeasuredPalbSvMb[2].dbFreqResponse=m_PalbFreq4;

		if(m_PalbFreq5>MAXATTENU) MeasuredPalbSvMb[3].dbFreqResponse=0.0;
		else MeasuredPalbSvMb[3].dbFreqResponse=m_PalbFreq5;

		if(m_PalbFreq6>MAXATTENU) MeasuredPalbSvMb[4].dbFreqResponse=0.0;
		else MeasuredPalbSvMb[4].dbFreqResponse=m_PalbFreq6;

		if(m_PalbFreq7>MAXATTENU) MeasuredPalbSvMb[5].dbFreqResponse=0.0;
		else MeasuredPalbSvMb[5].dbFreqResponse=m_PalbFreq7;

		bPass=TRUE;
		for(i=0;i<NUMBER_OF_FREQ;i++)
		{
			if((MeasuredPalbSvMb[i].dbFreqResponse<dbFreqLimit[i].PalCompLowerLimit) || (MeasuredPalbSvMb[i].dbFreqResponse>dbFreqLimit[i].PalCompUpperLimit))
				bPass=FALSE;
		}
		if(bPass)
			break;

	}//end retry loop
	
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET1,_T("%.1f"),MeasuredPalbSvMb[0].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET2,_T("%.1f"), MeasuredPalbSvMb[1].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET3,_T("%.1f"), MeasuredPalbSvMb[2].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET4,_T("%.1f"), MeasuredPalbSvMb[3].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET5,_T("%.1f"), MeasuredPalbSvMb[4].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET6,_T("%.1f"), MeasuredPalbSvMb[5].dbFreqResponse);

	if(!bPass)
	{
		if((MeasuredPalbSvMb[0].dbFreqResponse==0.0)&&(MeasuredPalbSvMb[1].dbFreqResponse==0.0)&&(MeasuredPalbSvMb[2].dbFreqResponse==0.0)&&(MeasuredPalbSvMb[3].dbFreqResponse==0.0)&&(MeasuredPalbSvMb[4].dbFreqResponse==0.0)&&(MeasuredPalbSvMb[5].dbFreqResponse==0.0))
			err_NoConnection();
		else
		{
			for(i=0;i<NUMBER_OF_FREQ;i++)
			{
				if((MeasuredPalbSvMb[i].dbFreqResponse<dbFreqLimit[i].PalCompLowerLimit) || (MeasuredPalbSvMb[i].dbFreqResponse>dbFreqLimit[i].PalCompUpperLimit))
					err_MBurstResultOutOfRange (i+1,MeasuredPalbSvMb[i].dbFreqResponse,dbFreqLimit[i].PalSvLowerLimit,dbFreqLimit[i].PalCompUpperLimit );
			}
		}
	}

	Cleanup();
	return;

}




IMPLEMENT_TESTLOCKED (TV, palmcompmb, 21)
{


	CHostResponse CHR;
	DWORD  dwMeasureResultBuffSize=Burst_Elems*2*sizeof(DWORD);
	DWORD *dwMeasureResultBuff=new DWORD[dwMeasureResultBuffSize/(sizeof(DWORD))];
	char *send_buf = NULL;
	DWORD dwBufferToHostLength, dwActualBytesReceived, dwErrorCodeFromHost,i;
	int iError;
	dwBufferToHostLength=NULL;
	BOOL bPass=TRUE;

	if (CheckAbort (HERE)){ Cleanup(); return;};

	MULTIBURST_CONFIG_DATA MeasuredPalmCompMb[NUMBER_OF_FREQ];

	DrawPalMB();
	PALMBRender();

    // Present the backbuffer contents to the display
    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
   
 	for(int attempts=0; attempts<m_testRetries; attempts++)
	{
		if ((iError = g_host.iSendHost(MID_PAL_M_COMP_MB, send_buf, dwBufferToHostLength, CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, XTV_TIMEOUT)) != EVERYTHINGS_OK)
		{
			if (dwErrorCodeFromHost != 0)
			{
				// Process error from host
				err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost);
				return;
			}
			else
			{
				// Process a communication error
				// This test module just reports the number of the communication error that was received
				err_HostCommunicationError(iError);
				return;
			}
		}
		else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
		{
			// The response buffer is empty, so take appropriate action (like an error message)
			err_RecordBufferIsEmpty();
			return;
		}
		else // The response is not NULL, and is not an error message, so process it
		{
			if (dwActualBytesReceived < dwMeasureResultBuffSize)
			{
				err_RecordBufferIsNotCorrectLength(dwMeasureResultBuffSize, dwActualBytesReceived);
				return;
			}
		}
		memcpy(dwMeasureResultBuff, CHR.pvBufferFromHost, dwMeasureResultBuffSize); 

		using namespace std;
		string input((char *)dwMeasureResultBuff);
		istringstream inputString(input);

		inputString >>m_PalmFreq1 >>m_PalmFreq2 >>m_PalmFreq3 >>m_PalmFreq4
					>>m_PalmFreq5 >>m_PalmFreq6 >>m_PalmFreq7;

		if(m_PalbFreq2>MAXATTENU) MeasuredPalmCompMb[0].dbFreqResponse=0.0;
		else MeasuredPalmCompMb[0].dbFreqResponse=m_PalbFreq2;

		if(m_PalbFreq3>MAXATTENU) MeasuredPalmCompMb[1].dbFreqResponse=0.0;
		else MeasuredPalmCompMb[1].dbFreqResponse=m_PalbFreq3;

		if(m_PalbFreq4>MAXATTENU) MeasuredPalmCompMb[2].dbFreqResponse=0.0;
		else MeasuredPalmCompMb[2].dbFreqResponse=m_PalbFreq4;

		if(m_PalbFreq5>MAXATTENU) MeasuredPalmCompMb[3].dbFreqResponse=0.0;
		else MeasuredPalmCompMb[3].dbFreqResponse=m_PalbFreq5;

		if(m_PalbFreq6>MAXATTENU) MeasuredPalmCompMb[4].dbFreqResponse=0.0;
		else MeasuredPalmCompMb[4].dbFreqResponse=m_PalbFreq6;

		if(m_PalbFreq7>MAXATTENU) MeasuredPalmCompMb[5].dbFreqResponse=0.0;
		else MeasuredPalmCompMb[5].dbFreqResponse=m_PalbFreq7;

		bPass=TRUE;
		for(i=0;i<NUMBER_OF_FREQ;i++)
		{
			if((MeasuredPalmCompMb[i].dbFreqResponse<dbFreqLimit[i].PalCompLowerLimit) || (MeasuredPalmCompMb[i].dbFreqResponse>dbFreqLimit[i].PalCompUpperLimit))
				bPass=FALSE;
		}
		if(bPass)
			break;

	}//end retry loop

	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET1,_T("%.1f"),MeasuredPalmCompMb[0].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET2,_T("%.1f"), MeasuredPalmCompMb[1].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET3,_T("%.1f"), MeasuredPalmCompMb[2].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET4,_T("%.1f"), MeasuredPalmCompMb[3].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET5,_T("%.1f"), MeasuredPalmCompMb[4].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET6,_T("%.1f"), MeasuredPalmCompMb[5].dbFreqResponse);

	if(!bPass)
	{
		if((MeasuredPalmCompMb[0].dbFreqResponse==0.0)&&(MeasuredPalmCompMb[1].dbFreqResponse==0.0)&&(MeasuredPalmCompMb[2].dbFreqResponse==0.0)&&(MeasuredPalmCompMb[3].dbFreqResponse==0.0)&&(MeasuredPalmCompMb[4].dbFreqResponse==0.0)&&(MeasuredPalmCompMb[5].dbFreqResponse==0.0))
			err_NoConnection();
		else
		{
			for(i=0;i<NUMBER_OF_FREQ;i++)
			{
				if((MeasuredPalmCompMb[i].dbFreqResponse<dbFreqLimit[i].PalCompLowerLimit) || (MeasuredPalmCompMb[i].dbFreqResponse>dbFreqLimit[i].PalCompUpperLimit))
					err_MBurstResultOutOfRange (i+1,MeasuredPalmCompMb[i].dbFreqResponse,dbFreqLimit[i].PalCompLowerLimit,dbFreqLimit[i].PalCompUpperLimit );
			}
		}
	}
	
	Cleanup();
	return;

}




IMPLEMENT_TESTLOCKED (TV, palmsvmb, 22)
{

	CHostResponse CHR;
	DWORD  dwMeasureResultBuffSize=Burst_Elems*2*sizeof(DWORD);
	DWORD *dwMeasureResultBuff=new DWORD[dwMeasureResultBuffSize/(sizeof(DWORD))];
	char *send_buf = NULL;
	DWORD dwBufferToHostLength, dwActualBytesReceived, dwErrorCodeFromHost,i;
	int iError;
	dwBufferToHostLength=NULL;
	BOOL bPass=TRUE;

	if (CheckAbort (HERE)){ Cleanup(); return;};

	MULTIBURST_CONFIG_DATA MeasuredPalmSvMb[NUMBER_OF_FREQ];

	DrawPalMB();
	PALMBRender();

    // Present the backbuffer contents to the display
    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
   
 	for(int attempts=0; attempts<m_testRetries; attempts++)
	{
		if ((iError = g_host.iSendHost(MID_PAL_M_SVIDEO_MB, send_buf, dwBufferToHostLength, CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, XTV_TIMEOUT)) != EVERYTHINGS_OK)
		{
			if (dwErrorCodeFromHost != 0)
			{
				// Process error from host
				err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost);
				return;
			}
			else
			{
				// Process a communication error
				// This test module just reports the number of the communication error that was received
				err_HostCommunicationError(iError);
				return;
			}
		}
		else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
		{
			// The response buffer is empty, so take appropriate action (like an error message)
			err_RecordBufferIsEmpty();
			return;
		}
		else // The response is not NULL, and is not an error message, so process it
		{
			if (dwActualBytesReceived < dwMeasureResultBuffSize)
			{
				err_RecordBufferIsNotCorrectLength(dwMeasureResultBuffSize, dwActualBytesReceived);
				return;
			}
			
		}
		memcpy(dwMeasureResultBuff, CHR.pvBufferFromHost, dwMeasureResultBuffSize); 

		using namespace std;
		string input((char *)dwMeasureResultBuff);
		istringstream inputString(input);
		
		inputString >>m_PalbFreq1 >>m_PalbFreq2 >>m_PalbFreq3 >>m_PalbFreq4
					>>m_PalbFreq5 >>m_PalbFreq6 >>m_PalbFreq7;

		if(m_PalbFreq2>MAXATTENU) MeasuredPalmSvMb[0].dbFreqResponse=0.0;
		else MeasuredPalmSvMb[0].dbFreqResponse=m_PalbFreq2;

		if(m_PalbFreq3>MAXATTENU) MeasuredPalmSvMb[1].dbFreqResponse=0.0;
		else MeasuredPalmSvMb[1].dbFreqResponse=m_PalbFreq3;

		if(m_PalbFreq4>MAXATTENU) MeasuredPalmSvMb[2].dbFreqResponse=0.0;
		else MeasuredPalmSvMb[2].dbFreqResponse=m_PalbFreq4;

		if(m_PalbFreq5>MAXATTENU) MeasuredPalmSvMb[3].dbFreqResponse=0.0;
		else MeasuredPalmSvMb[3].dbFreqResponse=m_PalbFreq5;

		if(m_PalbFreq6>MAXATTENU) MeasuredPalmSvMb[4].dbFreqResponse=0.0;
		else MeasuredPalmSvMb[4].dbFreqResponse=m_PalbFreq6;

		if(m_PalbFreq7>MAXATTENU) MeasuredPalmSvMb[5].dbFreqResponse=0.0;
		else MeasuredPalmSvMb[5].dbFreqResponse=m_PalbFreq7;

		bPass=TRUE;
		for(i=0;i<NUMBER_OF_FREQ;i++)
		{
			if((MeasuredPalmSvMb[i].dbFreqResponse<dbFreqLimit[i].PalCompLowerLimit) || (MeasuredPalmSvMb[i].dbFreqResponse>dbFreqLimit[i].PalCompUpperLimit))
				bPass=FALSE;
		}
		if(bPass)
			break;

	}//end retry loop

	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET1,_T("%.1f"),MeasuredPalmSvMb[0].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET2,_T("%.1f"), MeasuredPalmSvMb[1].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET3,_T("%.1f"), MeasuredPalmSvMb[2].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET4,_T("%.1f"), MeasuredPalmSvMb[3].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET5,_T("%.1f"), MeasuredPalmSvMb[4].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET6,_T("%.1f"), MeasuredPalmSvMb[5].dbFreqResponse);

	if(!bPass)
	{
		if((MeasuredPalmSvMb[0].dbFreqResponse==0.0)&&(MeasuredPalmSvMb[1].dbFreqResponse==0.0)&&(MeasuredPalmSvMb[2].dbFreqResponse==0.0)&&(MeasuredPalmSvMb[3].dbFreqResponse==0.0)&&(MeasuredPalmSvMb[4].dbFreqResponse==0.0)&&(MeasuredPalmSvMb[5].dbFreqResponse==0.0))
			err_NoConnection();
		else
		{
			for(i=0;i<NUMBER_OF_FREQ;i++)
			{
				if((MeasuredPalmSvMb[i].dbFreqResponse<dbFreqLimit[i].PalCompLowerLimit) || (MeasuredPalmSvMb[i].dbFreqResponse>dbFreqLimit[i].PalCompUpperLimit))
					err_MBurstResultOutOfRange (i+1,MeasuredPalmSvMb[i].dbFreqResponse,dbFreqLimit[i].PalSvLowerLimit,dbFreqLimit[i].PalCompUpperLimit );
			}
		}
	}

	Cleanup();
	return;

}



IMPLEMENT_TESTLOCKED (TV, palncompmb, 23)
{

	CHostResponse CHR;
	DWORD  dwMeasureResultBuffSize=Burst_Elems*2*sizeof(DWORD);
	DWORD *dwMeasureResultBuff=new DWORD[dwMeasureResultBuffSize/(sizeof(DWORD))];
	char *send_buf = NULL;
	DWORD dwBufferToHostLength, dwActualBytesReceived, dwErrorCodeFromHost,i;
	int iError;
	dwBufferToHostLength=NULL;
	BOOL bPass=TRUE;
	
	if (CheckAbort (HERE)){ Cleanup(); return;};

	MULTIBURST_CONFIG_DATA MeasuredPalmCompMb[NUMBER_OF_FREQ];

	DrawPalMB();
    PALMBRender();

    // Present the backbuffer contents to the display
    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
   
	for(int attempts=0; attempts<m_testRetries; attempts++)
	{
		if ((iError = g_host.iSendHost(MID_PAL_N_COMP_MB, send_buf, dwBufferToHostLength, CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, XTV_TIMEOUT)) != EVERYTHINGS_OK)
		{
			if (dwErrorCodeFromHost != 0)
			{
				// Process error from host
				err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost);
				return;
			}
			else
			{
				// Process a communication error
				// This test module just reports the number of the communication error that was received
				err_HostCommunicationError(iError);
				return;
			}
		}
		else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
		{
			// The response buffer is empty, so take appropriate action (like an error message)
			err_RecordBufferIsEmpty();
			return;
		}
		else // The response is not NULL, and is not an error message, so process it
		{
			if (dwActualBytesReceived < dwMeasureResultBuffSize)
			{
				err_RecordBufferIsNotCorrectLength(dwMeasureResultBuffSize, dwActualBytesReceived);
				return;
			}
		}

		memcpy(dwMeasureResultBuff, CHR.pvBufferFromHost, dwMeasureResultBuffSize); 

		using namespace std;
		string input((char *)dwMeasureResultBuff);
		istringstream inputString(input);

		inputString >>m_PalmFreq1 >>m_PalmFreq2 >>m_PalmFreq3 >>m_PalmFreq4
					>>m_PalmFreq5 >>m_PalmFreq6 >>m_PalmFreq7;

		if(m_PalbFreq2>MAXATTENU) MeasuredPalmCompMb[0].dbFreqResponse=0.0;
		else MeasuredPalmCompMb[0].dbFreqResponse=m_PalbFreq2;

		if(m_PalbFreq3>MAXATTENU) MeasuredPalmCompMb[1].dbFreqResponse=0.0;
		else MeasuredPalmCompMb[1].dbFreqResponse=m_PalbFreq3;

		if(m_PalbFreq4>MAXATTENU) MeasuredPalmCompMb[2].dbFreqResponse=0.0;
		else MeasuredPalmCompMb[2].dbFreqResponse=m_PalbFreq4;

		if(m_PalbFreq5>MAXATTENU) MeasuredPalmCompMb[3].dbFreqResponse=0.0;
		else MeasuredPalmCompMb[3].dbFreqResponse=m_PalbFreq5;

		if(m_PalbFreq6>MAXATTENU) MeasuredPalmCompMb[4].dbFreqResponse=0.0;
		else MeasuredPalmCompMb[4].dbFreqResponse=m_PalbFreq6;

		if(m_PalbFreq7>MAXATTENU) MeasuredPalmCompMb[5].dbFreqResponse=0.0;
		else MeasuredPalmCompMb[5].dbFreqResponse=m_PalbFreq7;

		bPass=TRUE;
		for(i=0;i<NUMBER_OF_FREQ;i++)
		{
			if((MeasuredPalmCompMb[i].dbFreqResponse<dbFreqLimit[i].PalCompLowerLimit) || (MeasuredPalmCompMb[i].dbFreqResponse>dbFreqLimit[i].PalCompUpperLimit))
				bPass=FALSE;
		}
		if(bPass)
			break;

	}//end retry loop

	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET1,_T("%.1f"),MeasuredPalmCompMb[0].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET2,_T("%.1f"), MeasuredPalmCompMb[1].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET3,_T("%.1f"), MeasuredPalmCompMb[2].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET4,_T("%.1f"), MeasuredPalmCompMb[3].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET5,_T("%.1f"), MeasuredPalmCompMb[4].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET6,_T("%.1f"), MeasuredPalmCompMb[5].dbFreqResponse);

	if(!bPass)
	{
		if((MeasuredPalmCompMb[0].dbFreqResponse==0.0)&&(MeasuredPalmCompMb[1].dbFreqResponse==0.0)&&(MeasuredPalmCompMb[2].dbFreqResponse==0.0)&&(MeasuredPalmCompMb[3].dbFreqResponse==0.0)&&(MeasuredPalmCompMb[4].dbFreqResponse==0.0)&&(MeasuredPalmCompMb[5].dbFreqResponse==0.0))
			err_NoConnection();
		else
		{
			for(i=0;i<NUMBER_OF_FREQ;i++)
			{
				if((MeasuredPalmCompMb[i].dbFreqResponse<dbFreqLimit[i].PalCompLowerLimit) || (MeasuredPalmCompMb[i].dbFreqResponse>dbFreqLimit[i].PalCompUpperLimit))
					err_MBurstResultOutOfRange (i+1,MeasuredPalmCompMb[i].dbFreqResponse,dbFreqLimit[i].PalCompLowerLimit,dbFreqLimit[i].PalCompUpperLimit );
			}
		}
	}

	Cleanup();
	return;
}



IMPLEMENT_TESTLOCKED (TV, palnsvpmb, 24)
{

	CHostResponse CHR;
	DWORD  dwMeasureResultBuffSize=Burst_Elems*2*sizeof(DWORD);
	DWORD *dwMeasureResultBuff=new DWORD[dwMeasureResultBuffSize/(sizeof(DWORD))];
	char *send_buf = NULL;
	DWORD dwBufferToHostLength, dwActualBytesReceived, dwErrorCodeFromHost,i;
	int iError;
	dwBufferToHostLength=NULL;
	BOOL bPass=TRUE;

	if (CheckAbort (HERE)){ Cleanup(); return;};

	MULTIBURST_CONFIG_DATA MeasuredPalmSvMb[NUMBER_OF_FREQ];

	DrawPalMB();
	PALMBRender();

    // Present the backbuffer contents to the display
    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
   
 	for(int attempts=0; attempts<m_testRetries; attempts++)
	{
		if ((iError = g_host.iSendHost(MID_PAL_N_SVIDEO_MB, send_buf, dwBufferToHostLength, CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, XTV_TIMEOUT)) != EVERYTHINGS_OK)
		{

			if (dwErrorCodeFromHost != 0)
			{
				// Process error from host
				err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost);
				return;
			}
			else
			{
				// Process a communication error
				// This test module just reports the number of the communication error that was received
				err_HostCommunicationError(iError);
				return;
			}
		}
		else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
		{
			// The response buffer is empty, so take appropriate action (like an error message)
			err_RecordBufferIsEmpty();
			return;
		}
		else // The response is not NULL, and is not an error message, so process it
		{
			if (dwActualBytesReceived < dwMeasureResultBuffSize)
			{
				err_RecordBufferIsNotCorrectLength(dwMeasureResultBuffSize, dwActualBytesReceived);
				return;
			}
			
		}
		memcpy(dwMeasureResultBuff, CHR.pvBufferFromHost, dwMeasureResultBuffSize); 

		using namespace std;
		string input((char *)dwMeasureResultBuff);
		istringstream inputString(input);

		inputString >>m_PalbFreq1 >>m_PalbFreq2 >>m_PalbFreq3 >>m_PalbFreq4
					>>m_PalbFreq5 >>m_PalbFreq6 >>m_PalbFreq7;

		if(m_PalbFreq2>MAXATTENU) MeasuredPalmSvMb[0].dbFreqResponse=0.0;
		else MeasuredPalmSvMb[0].dbFreqResponse=m_PalbFreq2;

		if(m_PalbFreq3>MAXATTENU) MeasuredPalmSvMb[1].dbFreqResponse=0.0;
		else MeasuredPalmSvMb[1].dbFreqResponse=m_PalbFreq3;

		if(m_PalbFreq4>MAXATTENU) MeasuredPalmSvMb[2].dbFreqResponse=0.0;
		else MeasuredPalmSvMb[2].dbFreqResponse=m_PalbFreq4;

		if(m_PalbFreq5>MAXATTENU) MeasuredPalmSvMb[3].dbFreqResponse=0.0;
		else MeasuredPalmSvMb[3].dbFreqResponse=m_PalbFreq5;

		if(m_PalbFreq6>MAXATTENU) MeasuredPalmSvMb[4].dbFreqResponse=0.0;
		else MeasuredPalmSvMb[4].dbFreqResponse=m_PalbFreq6;

		if(m_PalbFreq7>MAXATTENU) MeasuredPalmSvMb[5].dbFreqResponse=0.0;
		else MeasuredPalmSvMb[5].dbFreqResponse=m_PalbFreq7;

		bPass=TRUE;
		for(i=0;i<NUMBER_OF_FREQ;i++)
		{
			if((MeasuredPalmSvMb[i].dbFreqResponse<dbFreqLimit[i].PalCompLowerLimit) || (MeasuredPalmSvMb[i].dbFreqResponse>dbFreqLimit[i].PalCompUpperLimit))
				bPass=FALSE;
		}
		if(bPass)
			break;

	}//end retry loop

	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET1,_T("%.1f"),MeasuredPalmSvMb[0].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET2,_T("%.1f"), MeasuredPalmSvMb[1].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET3,_T("%.1f"), MeasuredPalmSvMb[2].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET4,_T("%.1f"), MeasuredPalmSvMb[3].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET5,_T("%.1f"), MeasuredPalmSvMb[4].dbFreqResponse);
	ReportStatistic(PAL_BDGHI_COMPOSITE_MULTIBURST_FREQUEN_PACKET6,_T("%.1f"), MeasuredPalmSvMb[5].dbFreqResponse);

	if(!bPass)
	{
		if((MeasuredPalmSvMb[0].dbFreqResponse==0.0)&&(MeasuredPalmSvMb[1].dbFreqResponse==0.0)&&(MeasuredPalmSvMb[2].dbFreqResponse==0.0)&&(MeasuredPalmSvMb[3].dbFreqResponse==0.0)&&(MeasuredPalmSvMb[4].dbFreqResponse==0.0)&&(MeasuredPalmSvMb[5].dbFreqResponse==0.0))
			err_NoConnection();
		else
		{
			for(i=0;i<NUMBER_OF_FREQ;i++)
			{
				if((MeasuredPalmSvMb[i].dbFreqResponse<dbFreqLimit[i].PalCompLowerLimit) || (MeasuredPalmSvMb[i].dbFreqResponse>dbFreqLimit[i].PalCompUpperLimit))
					err_MBurstResultOutOfRange (i+1,MeasuredPalmSvMb[i].dbFreqResponse,dbFreqLimit[i].PalSvLowerLimit,dbFreqLimit[i].PalCompUpperLimit );
			}
		}
	}
	
	Cleanup();
	return;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xtv\tv_linear.cpp ===
// 
// (c) Copyright 2000-2000 Intel Corp. All rights reserved.
//   ntsccb.cpp: used to implement ntsc-m and ntsc-Japan color bars 
//   tests for composite and s-video output. The subtests include 
//	ntscmcompcb, ntscmsvcb, ntscjcompcb, and ntscjsvcb
//
//////////////////////////////////////////////////////////////////////
#include <stdlib.h>
#include <wchar.h>
#include <string>
#include "..\stdafx.h"
#include "..\statkeys.h"
#include "XTV.h"

// A structure for our custom vertex type
struct TV_CUSTOMVERTEX
{
    FLOAT x, y, z, rhw; // The transformed position for the vertex
    DWORD color;        // The vertex color
};

// Our custom FVF, which describes our custom vertex structure
#define D3DFVF_TV_CUSTOMVERTEX (D3DFVF_XYZRHW | D3DFVF_DIFFUSE)

//***************************
//  ** WARNING **
//
// The contents of this struct must match the contents of the same struct 
// contatined in the xtvcapture utility.
//BYTE align the data.
#pragma pack(1)
struct TV_LINEAR_SETUP_INFO
{
	int		pass;
	int		tolerance;
	int		line;
	int		column;
	int		expected;
	int		measured;
	int		difference;
	int		tv_mode;
	int		pattern;
	int 	color;
	int		maxRed;
	int		maxGreen;
	int		maxBlue;
};
#pragma pack()
//****************************

//TV color bar linear image for testing
IMPLEMENT_TESTLOCKED (TV, tv_linearity, 25)
{
	CHostResponse CHR;
	DWORD dwActualBytesReceived, dwErrorCodeFromHost;
	TV_LINEAR_SETUP_INFO setup;
	TV_LINEAR_SETUP_INFO *pReturned;
	TV_LINEAR_SETUP_INFO results;
	LPCTSTR tvMode;
	LPCTSTR tvPattern;
	int iError, tolerance;
	BOOL bPass=TRUE;
	

	
	if (CheckAbort (HERE)){ Cleanup(); return;};

	//Get the config parameters
	tolerance=GetCfgInt(L"tol", 10);
	m_bUseMemoryFill = GetCfgInt(L"use_memfill", 0);
	tvMode = GetCfgString( L"tv_mode", NULL);
	tvPattern = GetCfgString( L"pattern", NULL);
	m_dwDisplayHeight = g_d3dpp.BackBufferHeight;
	


	if( tvMode == NULL)
	{
		err_BADPARAMETER( L"tv_mode");
		Cleanup();
		return;
	}
	if( tvPattern == NULL)
	{
		err_BADPARAMETER( L"pattern");
		Cleanup();
		return;
	}

    //Init the setup struct parameters.
	memset(&setup, 0, sizeof(setup));
	memset(&results, 0, sizeof(results));
	setup.tolerance = tolerance;

	if(!wcsicmp(tvMode, L"ntsc_m"))
	{
		//NTSC_M mode - draw the pattern and continue.
		setup.tv_mode = NTSC_M;
		if(!wcsicmp(tvPattern, L"horizontal"))
		{
			setup.pattern = H_PATTERN;
			TVTestDrawHorizontalLinearityPattern();
		}
		else if(!wcsicmp(tvPattern, L"vertical"))
		{
			setup.pattern = V_PATTERN;
			TVTestDrawVerticalLinearityPattern();
		}
		else
		{
			err_BADPARAMETER( L"pattern");
			Cleanup();
			return;
		}
		TVTestRender(setup.pattern);
	}
	//TVTestReportSurfaceData();
	
	for(int attempts=0; attempts<m_testRetries; attempts++)
	{
		memset(&results, 0, sizeof(results));
		//Call the host utility message to take the measurement 
		if ((iError = g_host.iSendHost(MID_TV_LINEARITY, (char *)&setup, sizeof(setup), CHR, &dwActualBytesReceived, &dwErrorCodeFromHost, 180)) != EVERYTHINGS_OK)
		{

			if (dwErrorCodeFromHost != 0)
			{
				// Process error from host
				err_HostResponseError(dwErrorCodeFromHost, (LPCTSTR)CHR.pvBufferFromHost);
				return;
			}
			else
			{
				// Process a communication error
				// This test module just reports the number of the communication error that was received
				err_HostCommunicationError(iError);
				return;
			}
		}
		
		else if ((CHR.pvBufferFromHost == NULL) || (dwActualBytesReceived == 0)) // Don't access the response buffer if it is NULL
		{
			// The response buffer is empty, so take appropriate action (like an error message)
			err_RecordBufferIsEmpty();
			return;
		}
		
		else // The response is not NULL, and is not an error message, so process it
		{
			// Analyze the response data from the host
			pReturned = (TV_LINEAR_SETUP_INFO *)CHR.pvBufferFromHost;
			memcpy(&results, pReturned, sizeof(struct TV_LINEAR_SETUP_INFO));
		}

		//Now look at the results returned and act accordingly.
		bPass=TRUE;
		if(results.pass != TRUE)
			bPass=FALSE;
		else
			break;
			//Made it to hear means the test passed - good job dude!

		if(attempts+1 < m_testRetries)
			ReportWarning(L"Attempt %d failed, retrying again...", attempts+1);
	
	}//end retry loop
	
	//Report out the stats.
	if(setup.pattern == H_PATTERN)
	{
		ReportStatistic(NTSCM_COMPOSITE_HORIZONTAL_LINEARITY_MAX_RED, _T("%d"), results.maxRed);
		ReportStatistic(NTSCM_COMPOSITE_HORIZONTAL_LINEARITY_MAX_GREEN, _T("%d"), results.maxGreen);
		ReportStatistic(NTSCM_COMPOSITE_HORIZONTAL_LINEARITY_MAX_BLUE, _T("%d"), results.maxBlue);
	}
	else if(setup.pattern == V_PATTERN)
	{
		ReportStatistic(NTSCM_COMPOSITE_VERTICAL_LINEARITY_MAX_RED, _T("%d"), results.maxRed);
		ReportStatistic(NTSCM_COMPOSITE_VERTICAL_LINEARITY_MAX_GREEN, _T("%d"), results.maxGreen);
		ReportStatistic(NTSCM_COMPOSITE_VERTICAL_LINEARITY_MAX_BLUE, _T("%d"), results.maxBlue);
	}
	
	if(!bPass)
	{
		//The PASS flag was set to FALSE.  We failed a linearity check.
		//Decode the returned data and report out the failure.
		//err_TVTestLinearity(LPCTSTR tvmode, LPCTSTR color, int line, int column, int meas, int exp, int diff, int tol)
		TCHAR mode[16];
		TCHAR color[8];
		TCHAR pattern[16];

		if(results.tv_mode == 1)
			swprintf(mode, L"NTSC_M");

		if(results.color == RED)
			swprintf(color,  L"RED");
		else if(results.color == GREEN)
			swprintf(color,  L"GREEN");
		else if(results.color == BLUE)
			swprintf(color,  L"BLUE");

		if(results.pattern == H_PATTERN)
			swprintf(pattern, L"HORIZONTAL");
		else if(results.pattern == V_PATTERN)
			swprintf(pattern, L"VERTICAL");
		
		/*
		ReportWarning(L"Results Data - Mode=%s\n"), mode);
		ReportWarning(L"Pass=%d\n", results.pass);
		ReportWarning(L"Color=%s\n", color);
		ReportWarning(L"Line=%d\n", results.line);
		ReportWarning(L"Column=%d\n", results.column);
		ReportWarning(L"Measured=%d\n", results.measured);
		ReportWarning(L"Expected=%d\n", results.expected);
		ReportWarning(L"Difference=%d\n", results.difference);
		ReportWarning(L"Tolerance=%d\n", results.tolerance);
		*/

		err_TVTestLinearity(mode, pattern, color, results.line, results.column, results.measured, results.expected, results.difference, results.tolerance);
		if (CheckAbort (HERE)){ Cleanup(); return;};
	}
		
	Cleanup();
	return;
}



BOOL CXModuleTV::TVTestDrawHorizontalLinearityPattern()
{
    
	TV_CUSTOMVERTEX* g_Vertices;
	int column = 0, width = 0, vert = 0;
	float startLine, firstRow, secondRow, thirdRow, height = 0.0f;
	
	width = m_dwDisplayWidth = (int)g_d3dpp.BackBufferWidth;
    height = (float)g_d3dpp.BackBufferHeight;
	

	startLine = 0.0f;
	firstRow  = (height / 3.0f) - 1.0f;
	secondRow = ((height / 3.0f)*2) - 1.0f;
	thirdRow = height - 2.0f;

	m_sectionsToDraw = 3;
	g_Vertices = new TV_CUSTOMVERTEX [(m_sectionsToDraw * width * 2)];
	

	startLine = 2.0f;
	

	//Now start drawing the columns.
	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//red shade
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = startLine;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = D3DCOLOR_XRGB(255,0,0);
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = D3DCOLOR_XRGB(0,0,0);
    		vert++;
		}
	  
    }

	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//green shade
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = firstRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = D3DCOLOR_XRGB(0,255,0);
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = D3DCOLOR_XRGB(0,0,0);
    		vert++;
		}
    }

	for(column = 0; column < width; column++)
    {
		if(column < width)
		{	//blue shade
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = secondRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = D3DCOLOR_XRGB(0,0,255);
			vert++;		
			g_Vertices[vert].x = (float)column;
			g_Vertices[vert].y = thirdRow;
			g_Vertices[vert].z = 0.0f;
			g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = D3DCOLOR_XRGB(0,0,0);
    		vert++;
		}
    }


	// Create the vertex buffer. Here we are allocating enough memory
    // (from the default pool) to hold all our 3 custom vertices. We also
    // specify the FVF, so the vertex buffer knows what data it contains.
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( (m_sectionsToDraw * width * 2)*sizeof(TV_CUSTOMVERTEX),
                                                  D3DUSAGE_WRITEONLY,
												  D3DFVF_TV_CUSTOMVERTEX,
                                                  D3DPOOL_MANAGED, &m_pTVPatternVB ) ) )
    {
		SAFE_DELETE_ARRAY(g_Vertices);
		return FALSE;
    }

    // Now we fill the vertex buffer. To do this, we need to Lock() the VB to
    // gain access to the vertices. This mechanism is required becuase vertex
    // buffers may be in device memory.
	TV_CUSTOMVERTEX* pVertices;
    if( FAILED( m_pTVPatternVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ) ) )
	{
		SAFE_DELETE_ARRAY(g_Vertices);
        return FALSE;
	}
    
	memcpy( pVertices, g_Vertices, ((m_sectionsToDraw * width * 2)*sizeof(TV_CUSTOMVERTEX) ));
    m_pTVPatternVB->Unlock();
	SAFE_DELETE_ARRAY(g_Vertices);
	
    return TRUE;
}


BOOL CXModuleTV::TVTestDrawVerticalLinearityPattern()
{
    
	TV_CUSTOMVERTEX* g_Vertices;
	int line, firstColumn, secondColumn, thirdColumn, width = 0, vert = 0;
	//float startLine, firstRow, secondRow, thirdRow, height = 0.0f;
	float startLine, height = 0.0f;

	width = m_dwDisplayWidth = (int)g_d3dpp.BackBufferWidth;
    height = (float)g_d3dpp.BackBufferHeight;
	

	startLine = 0.0f;
	firstColumn  = (width / 3) - 1;
	secondColumn = ((width / 3)*2) - 1;
	thirdColumn = width - 2;

	m_sectionsToDraw = 3;
	g_Vertices = new TV_CUSTOMVERTEX [(m_sectionsToDraw * (int)height * 2)];
	

	startLine = 2.0f;
	

	//Now start drawing the columns.
	for(line = 0; line < (int)height; line++)
    {
		//Red shade
		g_Vertices[vert].x = 0;
		g_Vertices[vert].y = (float)line;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = D3DCOLOR_XRGB(255,0,0);
		vert++;		
		g_Vertices[vert].x = (float)firstColumn;
		g_Vertices[vert].y = (float)line;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = D3DCOLOR_XRGB(0,0,0);
    	vert++;
    }

	for(line = 0; line < (int)height; line++)
    {
		//green shade
		g_Vertices[vert].x = (float)firstColumn+1;
		g_Vertices[vert].y = (float)line;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = D3DCOLOR_XRGB(0,255,0);
		vert++;		
		g_Vertices[vert].x = (float)secondColumn;
		g_Vertices[vert].y = (float)line;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = D3DCOLOR_XRGB(0,0,0);
    	vert++;
    }

	for(line = 0; line < (int)height; line++)
    {
		//blue shade
		g_Vertices[vert].x = (float)secondColumn+1;
		g_Vertices[vert].y = (float)line;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = D3DCOLOR_XRGB(0,0,255);
		vert++;		
		g_Vertices[vert].x = (float)thirdColumn;
		g_Vertices[vert].y = (float)line;
		g_Vertices[vert].z = 0.0f;
		g_Vertices[vert].rhw = 1.0f;	g_Vertices[vert].color = D3DCOLOR_XRGB(0,0,0);
    	vert++;
	}

	// Create the vertex buffer. Here we are allocating enough memory
    // (from the default pool) to hold all our 3 custom vertices. We also
    // specify the FVF, so the vertex buffer knows what data it contains.
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( (m_sectionsToDraw * (int)height * 2)*sizeof(TV_CUSTOMVERTEX),
                                                  D3DUSAGE_WRITEONLY,
												  D3DFVF_TV_CUSTOMVERTEX,
                                                  D3DPOOL_MANAGED, &m_pTVPatternVB ) ) )
    {
		SAFE_DELETE_ARRAY(g_Vertices);
		return FALSE;
    }

    // Now we fill the vertex buffer. To do this, we need to Lock() the VB to
    // gain access to the vertices. This mechanism is required becuase vertex
    // buffers may be in device memory.
	TV_CUSTOMVERTEX* pVertices;
    if( FAILED( m_pTVPatternVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ) ) )
	{
		SAFE_DELETE_ARRAY(g_Vertices);
        return FALSE;
	}
    
	memcpy( pVertices, g_Vertices, ((m_sectionsToDraw * (int)height * 2)*sizeof(TV_CUSTOMVERTEX) ));
    m_pTVPatternVB->Unlock();
	SAFE_DELETE_ARRAY(g_Vertices);
	
    return TRUE;
}

//******************************************************
//
// This function fills the display surface with a WORD bit pattern defined as
// a parameter from the INI file.
//
//******************************************************
BOOL CXModuleTV::FillSurfaceWithHorizontalPattern()
{
	// Fill the rectangle in the image with random data based on seed
	D3DLOCKED_RECT pLockedRect;		//Locked rectangle struct for determing surface image data.
	LONG pitch;
	BYTE *pBits;
	HRESULT hr;
	LPDWORD pData;
	LPDIRECT3DSURFACE8 lpd3dSurface;
	int bytesPerLine, r, g, b;
	DWORD x, y, line, Width, Height, Gradient;
	DWORD PitchAdjust;
	
	lpd3dSurface = NULL;
	Width=m_dwDisplayWidth;
	Height=m_dwDisplayHeight;
	
	if((hr = g_pd3dDevice->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &lpd3dSurface)) != D3D_OK)
	{	//Fatal error - exit the test.
		ReportDebug(0x1, _T("TV_LINEAR.CPP - Failed to GetBackBuffer() for FillPattern()!"));
		ReportD3DError(hr);
		if (CheckAbort (HERE))
		{
			SAFE_RELEASE(lpd3dSurface);
			Cleanup();
			return 0;
		}
	}
	
	hr = lpd3dSurface->LockRect( &pLockedRect, NULL, D3DLOCK_TILED);
	if(hr != D3D_OK)
	{
		ReportD3DError(hr);
		return FALSE;
	}
	
	//rand.seed(seed);
//	ReportWarning(L"pitch=%d, bpl=%d", pitch, bytesPerLine);

	PitchAdjust = pLockedRect.Pitch / 4 - m_dwDisplayWidth;

    pData = (LPDWORD)pLockedRect.pBits;

	Gradient = 256 / (Height/3);
	
        
	//Draw the red gradient first.
	for(line=0; line < (Height / 3); line++)
	{
		r = ( (line * Gradient)>255)?255 : (line * Gradient);
		g=b=0;
		for (x = 0; x < Width; x++)
		{
			*pData++ = D3DCOLOR_ARGB(0, r, g, b);
		}
		pData += PitchAdjust;
	}

	//Draw the green gradient second.
	for(line=0; line < (Height / 3); line++)
	{
		g = ( (line * Gradient)>255)?255 : (line * Gradient);
		r=b=0;
		for (x = 0; x < Width; x++)
		{
			*pData++ = D3DCOLOR_ARGB(0, r, g, b);
		}
		pData += PitchAdjust;
	}

	//Draw the green gradient second.
	for(line=0; line < (Height / 3); line++)
	{
		b = ( (line * Gradient)>255)?255 : (line * Gradient);
		r=g=0;
		for (x = 0; x < Width; x++)
		{
			*pData++ = D3DCOLOR_ARGB(0, r, g, b);
		}
		pData += PitchAdjust;
	}

	lpd3dSurface->UnlockRect();
	SAFE_RELEASE(lpd3dSurface);
		
	return TRUE;
}



//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Draws the scene
//-----------------------------------------------------------------------------
VOID CXModuleTV::TVTestRender(int pattern)
{
	HRESULT hr;
	LPDIRECT3DSURFACE8 pFrontBuffer;
	LPDIRECT3DSURFACE8 pBackBuffer;


	// Clear the backbuffer
    g_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_STENCIL, D3DCOLOR_XRGB(0,0,0), 1.0f, 0 );
	
	// Begin the scene
    g_pd3dDevice->BeginScene();
	
	/*
	if(m_bUseBitmap)
	{
		//Draw the lines for the pixel count
		g_pd3dDevice->SetStreamSource( 0, m_pTVPatternVB, sizeof(TV_CUSTOMVERTEX) );
		g_pd3dDevice->SetVertexShader( D3DFVF_TV_CUSTOMVERTEX );
		if(pattern == H_PATTERN)
			g_pd3dDevice->DrawPrimitive( D3DPT_LINELIST, 0, ((int)m_dwDisplayWidth * m_sectionsToDraw));
		else if(pattern == V_PATTERN)
			g_pd3dDevice->DrawPrimitive( D3DPT_LINELIST, 0, ((int)m_dwDisplayHeight * m_sectionsToDraw));
		
		// End the scene
		g_pd3dDevice->EndScene();

		// Present the backbuffer contents to the display
		g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
			
		g_pd3dDevice->GetBackBuffer( -1, D3DBACKBUFFER_TYPE_MONO, &pFrontBuffer);
		hr = XGWriteSurfaceToFile( pFrontBuffer, "z:\\pattern.bmp");
		SAFE_RELEASE(pFrontBuffer);
		
		if(hr != S_OK)
			err_DIRECTX_API ( hr, L"Failed saving surface to bitmap file.");

		// Clear the backbuffer
		g_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_STENCIL, D3DCOLOR_XRGB(0,0,0), 1.0f, 0 );
		// Begin the scene
		g_pd3dDevice->BeginScene();
		// End the scene
		g_pd3dDevice->EndScene();
		// Present the backbuffer contents to the display
		g_pd3dDevice->Present( NULL, NULL, NULL, NULL );


		g_pd3dDevice->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &pBackBuffer);
		// Begin the scene
	    g_pd3dDevice->BeginScene();

		
		hr = D3DXLoadSurfaceFromFile(pBackBuffer,
								NULL,
								NULL,
								"z:\\pattern.bmp",
								NULL,
								D3DX_FILTER_NONE,
								0,
								NULL);
		SAFE_RELEASE(pBackBuffer);

		if(hr != D3D_OK)
			err_DIRECTX_API ( hr, L"Failed loading surface from bitmap file.");

	}
	*/
	if(m_bUseMemoryFill)
	{
		FillSurfaceWithHorizontalPattern();

	}


	else
	{

		//Draw the lines for the pixel count
		g_pd3dDevice->SetStreamSource( 0, m_pTVPatternVB, sizeof(TV_CUSTOMVERTEX) );
		g_pd3dDevice->SetVertexShader( D3DFVF_TV_CUSTOMVERTEX );
		if(pattern == H_PATTERN)
			g_pd3dDevice->DrawPrimitive( D3DPT_LINELIST, 0, ((int)m_dwDisplayWidth * m_sectionsToDraw));
		else if(pattern == V_PATTERN)
			g_pd3dDevice->DrawPrimitive( D3DPT_LINELIST, 0, ((int)m_dwDisplayHeight * m_sectionsToDraw));
	}
	
	// End the scene
    g_pd3dDevice->EndScene();

    // Present the backbuffer contents to the display
    g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xtv\XTV.cpp ===
// (c) Copyright 2000-2001 Intel Corp. All rights reserved.
//
// XTV.cpp: implementation of the CXModuleTV class.
//
//////////////////////////////////////////////////////////////////////

#include "..\stdafx.h"
#include "XTV.h"

#define AM 75   //75% Amplitude
#define SA 100  //100% Saturation
#define NUMBER_OF_BARS 8
#define STR_SIZE	64
struct CUSTOMVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };

//create vertex of NTSC TV standard for each bars
CUSTOMVERTEX wv[4], yv[4],cv[4],gv[4],mv[4],rv[4],bv[4],sbv[4],skv[4]
,skvb[4],smv[4],skv1[4],scv[4],skv2[4],swv[4],swvb[4],skvb2[4];

//create vertex of PAL TV standard for each bars
CUSTOMVERTEX pwv[4], pyv[4],pcv[4],pgv[4],pmv[4],prv[4],pbv[4],pbkv[4];

IMPLEMENT_MODULELOCKED (CXModuleTV);

bool CXModuleTV::InitializeParameters()
{

	DWORD i;
	wchar_t wszTempBuff[STR_SIZE];
	m_pVB= NULL;
	m_pTVPatternVB = NULL;


	if (!CTestObj::InitializeParameters ())
		return false;

	m_testRetries = GetCfgInt( L"retries", 1);


//***********************************************************
//******* get the upper and lower limits for NTSC color bars 
//************************************************************
	//	NtscmLuma IRE upper limits
	for(i=0;i<NUMBER_OF_BARS;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"ntscmcompcb", L"luma_ire_upper",i);
	if((DWORD)GetCfgUint(wszTempBuff,NULL)==NULL){
		gdwColorBarLimitLumaIRE[i].dwUpperLimitLumaIRE=DEFAULTPARAM;
//	ReportWarning(L"NtscmLumaUpperLimits::%lu\n", gdwColorBarLimitLumaIRE[i].dwUpperLimitLumaIRE);
	}else{
	gdwColorBarLimitLumaIRE[i].dwUpperLimitLumaIRE=(DWORD)GetCfgUint(wszTempBuff,NULL);
//	ReportWarning(L"NtscmLumaUpperLimits::%lu\n", gdwColorBarLimitLumaIRE[i].dwUpperLimitLumaIRE);
		}
}

	//NtscmLumaIRE lower limits

	for(i=0;i<NUMBER_OF_BARS;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"ntscmcompcb", L"luma_ire_lower",i);
	if((DWORD)GetCfgUint(wszTempBuff,NULL)==NULL){
	gdwColorBarLimitLumaIRE[i].dwLowerLimitLumaIRE=DEFAULTPARAM;
//	ReportWarning(L"NtscmLumaLowerLimits::%lu\n", gdwColorBarLimitLumaIRE[i].dwLowerLimitLumaIRE);
	}else{
	gdwColorBarLimitLumaIRE[i].dwLowerLimitLumaIRE=(DWORD)GetCfgUint(wszTempBuff,NULL);
//	ReportWarning(L"NtscmLumaLowerLimits::%lu\n", gdwColorBarLimitLumaIRE[i].dwLowerLimitLumaIRE);
	}

}
	//NtscmchromaIRE upper limits
	for(i=0;i<NUMBER_OF_BARS;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"ntscmcompcb", L"chroma_ire_upper",i);
	if((DWORD)GetCfgUint(wszTempBuff,NULL)==NULL){
	gdwColorBarLimitChromaIRE[i].dwUpperLimitChromaIRE=DEFAULTPARAM;
//	ReportWarning(L"NtscmChromaIREUpperLimits:%lu\n", gdwColorBarLimitChromaIRE[i].dwUpperLimitChromaIRE);
	}else{
	gdwColorBarLimitChromaIRE[i].dwUpperLimitChromaIRE=(DWORD)GetCfgUint(wszTempBuff,NULL);
//	ReportWarning(L"NtscmChromaIREUpperLimits:%lu\n", gdwColorBarLimitChromaIRE[i].dwUpperLimitChromaIRE);
		}
}
	//NtscmchromaIRE lower limits

	for(i=0;i<NUMBER_OF_BARS;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"ntscmcompcb", L"chroma_ire_lower",i);
	if((DWORD)GetCfgUint(wszTempBuff,NULL)==NULL){
	gdwColorBarLimitChromaIRE[i].dwLowerLimitChromaIRE=DEFAULTPARAM;
	gdwColorBarLimitChromaIRE[0].dwLowerLimitChromaIRE=ZEROPARAM;
	gdwColorBarLimitChromaIRE[7].dwLowerLimitChromaIRE=ZEROPARAM;
//	ReportWarning(L"NtscmChromaIRELowerLimits: %lu\n", gdwColorBarLimitChromaIRE[i].dwLowerLimitChromaIRE);
	}else{
	gdwColorBarLimitChromaIRE[i].dwLowerLimitChromaIRE=(DWORD)GetCfgUint(wszTempBuff,NULL);
//	ReportWarning(L"NtscmChromaIRELowerLimits: %lu\n", gdwColorBarLimitChromaIRE[i].dwLowerLimitChromaIRE);
	}
}
	
	//NtscmchromaPhase upper limits
	for(i=0;i<NUMBER_OF_BARS-2;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"ntscmcompcb", L"chroma_phase_upper",i);
	if((DWORD)GetCfgUint(wszTempBuff,NULL)==NULL){
	gdwColorBarLimitChromaPhase[i].dwUpperLimitChromaPhase=PHASEDEFAULTPARAM;
//	ReportWarning(L"NtscmChromaPhaseUpperLimits::%lu\n", gdwColorBarLimitChromaPhase[i].	dwUpperLimitChromaPhase);
	}else{
	gdwColorBarLimitChromaPhase[i].dwUpperLimitChromaPhase=(DWORD)GetCfgUint(wszTempBuff,NULL);
//	ReportWarning(L"NtscmChromaPhaseUpperLimits::%lu\n", gdwColorBarLimitChromaPhase[i].	dwUpperLimitChromaPhase);
	}
}
	//NtscmchromaPhase lower limits

	for(i=0;i<NUMBER_OF_BARS-2;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"ntscmcompcb", L"chroma_phase_lower",i);
	if((DWORD)GetCfgUint(wszTempBuff,NULL)==NULL){
	gdwColorBarLimitChromaPhase[i].dwLowerLimitChromaPhase=PHASEDEFAULTPARAM;
//	ReportWarning(L"NtscmChromaPhaseLowerLimits: %lu\n", gdwColorBarLimitChromaPhase[i].dwLowerLimitChromaPhase);
	}else{
	gdwColorBarLimitChromaPhase[i].dwLowerLimitChromaPhase=(DWORD)GetCfgUint(wszTempBuff,NULL);
//	ReportWarning(L"NtscmChromaPhaseLowerLimits: %lu\n", gdwColorBarLimitChromaPhase[i].dwLowerLimitChromaPhase);
		}
}

//***************************************************************
//******* get the standard video paramters for NTSC color bars 
//***************************************************************

	//NtscmTekStandard LumaIRE video parameters
 const int NtscmLumaIREDefaultParam[]={75,66,54,46,34,26,14,7};
 const int NtscmChromaIREDefaultParam[]={0,62,87,81,81,87,61,0};
 const int NtscmChromaPhaseDefaultParam[]={169,286,243,64,107,351};

 //NtscmTekStandard LumaIRE video parameters
	for(i=0;i<NUMBER_OF_BARS;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"ntscmcompcb", L"std_ntsccb_luma_ire",i);
	if((DWORD)GetCfgUint(wszTempBuff,NULL)==NULL){
	dbStandardNtscParams[i].dwStdNtscCbParamLumaIRE=NtscmLumaIREDefaultParam[i];
	ReportWarning(L"TektronixStdNtscLumaIRE: %lu\n", dbStandardNtscParams[i].dwStdNtscCbParamLumaIRE);
	}else{
		dbStandardNtscParams[i].dwStdNtscCbParamLumaIRE=(DWORD)GetCfgUint(wszTempBuff,NULL);
//	ReportWarning(L"TektronixStdNtscLumaIRE: %lu\n", dbStandardNtscParams[i].dwStdNtscCbParamLumaIRE);
	}
	}

//NtscmTekStandard ChromaIRE video parameters
for(i=0;i<NUMBER_OF_BARS;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"ntscmcompcb", L"std_ntsccb_chroma_ire",i);
	if((DWORD)GetCfgUint(wszTempBuff,NULL)==NULL){
	dbStandardNtscParams[i].dwStdNtscCbParamChromaIRE=NtscmChromaIREDefaultParam[i];
//	ReportWarning(L"TektronixStdNtscChromaIRE: %lu\n", 	dbStandardNtscParams[i].dwStdNtscCbParamChromaIRE);
	}else{
	dbStandardNtscParams[i].dwStdNtscCbParamChromaIRE=(DWORD)GetCfgUint(wszTempBuff,NULL);
//	ReportWarning(L"TektronixStdNtscChromaIRE: %lu\n", 	dbStandardNtscParams[i].dwStdNtscCbParamChromaIRE);
	}
}

	//NtscmTekStandard ChromaPhase video parameters
	for(i=0;i<(NUMBER_OF_BARS-2);i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"ntscmcompcb", L"std_ntsccb_chroma_phase",i);
	if((DWORD)GetCfgUint(wszTempBuff,NULL)==NULL){
	dbStandardNtscParams[i].dwStdNtscCbParamChromaPhase=NtscmChromaPhaseDefaultParam[i];
//	ReportWarning(L"TektronixStdNtscChromaPhase: %lu\n", dbStandardNtscParams[i].dwStdNtscCbParamChromaPhase);
	}else{
		dbStandardNtscParams[i].dwStdNtscCbParamChromaPhase=(DWORD)GetCfgUint(wszTempBuff,NULL);
//	ReportWarning(L"TektronixStdNtscChromaPhase: %lu\n", dbStandardNtscParams[i].dwStdNtscCbParamChromaPhase);
	}
	}

//*******************************************************************************
//**NTSCCB: Standard parmater + Upper limits and Standard parameter - lower limits
//*******************************************************************************

	// NtscmLumaIRE_Std_parameters + LumaIRE_Upper_Limits

   for(i=0;i<NUMBER_OF_BARS;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"ntscmcompcb", L"std_ntsccb_luma_ire",i);
	if((DWORD)GetCfgUint(wszTempBuff,NULL)==NULL){
	dbStandardNtscParams[i].dwStdNtscCbParamLumaIRE= NtscmLumaIREDefaultParam[i];
	gdwColorBarLimitLumaIRE[i].dwLumaIREUpperLimit=dbStandardNtscParams[i].dwStdNtscCbParamLumaIRE+gdwColorBarLimitLumaIRE[i].dwUpperLimitLumaIRE;
//	ReportWarning(L"NtscmLumaIREUpperLimits: %lu\n", gdwColorBarLimitLumaIRE[i].dwLumaIREUpperLimit);
	}else{

	for(i=0;i<NUMBER_OF_BARS;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"ntscmcompcb", L"std_ntsccb_luma_ire",i);
	dbStandardNtscParams[i].dwStdNtscCbParamLumaIRE=(DWORD)GetCfgUint(wszTempBuff,NULL);
	gdwColorBarLimitLumaIRE[i].dwLumaIREUpperLimit=dbStandardNtscParams[i].dwStdNtscCbParamLumaIRE+gdwColorBarLimitLumaIRE[i].dwUpperLimitLumaIRE;
//	ReportWarning(L"NtscmLumaIREUpperLimits: %lu\n", gdwColorBarLimitLumaIRE[i].dwLumaIREUpperLimit);
		}
	}
  }

	
	// NtscmLumaIRE_Std_parameters - LumaIRE_Lower_limits

	for(i=0;i<NUMBER_OF_BARS;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"ntscmcompcb", L"std_ntsccb_luma_ire",i);
	if((DWORD)GetCfgUint(wszTempBuff,NULL)==NULL){
	dbStandardNtscParams[i].dwStdNtscCbParamLumaIRE=NtscmLumaIREDefaultParam[i];
	gdwColorBarLimitLumaIRE[i].dwLumaIRELowerLimit=dbStandardNtscParams[i].dwStdNtscCbParamLumaIRE-gdwColorBarLimitLumaIRE[i].dwLowerLimitLumaIRE;
//	ReportWarning(L"NtscmLumaIRELowerLimits: %lu\n", gdwColorBarLimitLumaIRE[i].dwLumaIRELowerLimit);
	}else{
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"ntscmcompcb", L"std_ntsccb_luma_ire",i);
	dbStandardNtscParams[i].dwStdNtscCbParamLumaIRE=(DWORD)GetCfgUint(wszTempBuff,NULL);
	gdwColorBarLimitLumaIRE[i].dwLumaIRELowerLimit=dbStandardNtscParams[i].dwStdNtscCbParamLumaIRE-gdwColorBarLimitLumaIRE[i].dwLowerLimitLumaIRE;
//	ReportWarning(L"NtscmLumaIRELowerLimits: %lu\n", gdwColorBarLimitLumaIRE[i].dwLumaIRELowerLimit);
		}
}


	// NtscmChromaIRE_Std_parameters + ChromaIRE_upper_limits

	
	for(i=1;i<NUMBER_OF_BARS-1;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"ntscmcompcb", L"std_ntsccb_chroma_ire",i);
	if((DWORD)GetCfgUint(wszTempBuff,NULL)==NULL){
	dbStandardNtscParams[i].dwStdNtscCbParamChromaIRE=NtscmChromaIREDefaultParam[i];
	dbStandardNtscParams[0].dwStdNtscCbParamChromaIRE=ZEROPARAM;
	dbStandardNtscParams[7].dwStdNtscCbParamChromaIRE=ZEROPARAM;
	gdwColorBarLimitChromaIRE[i].dwChromaIREUpperLimit=dbStandardNtscParams[i].dwStdNtscCbParamChromaIRE+gdwColorBarLimitChromaIRE[i].dwUpperLimitChromaIRE;
//	ReportWarning(L"NtscmChromaIREUpperLimits: %lu\n", gdwColorBarLimitChromaIRE[i].dwChromaIREUpperLimit);
	}else{
	for(i=0;i<NUMBER_OF_BARS;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"ntscmcompcb", L"std_ntsccb_chroma_ire",i);
	dbStandardNtscParams[i].dwStdNtscCbParamChromaIRE=(DWORD)GetCfgUint(wszTempBuff,NULL);
	gdwColorBarLimitChromaIRE[i].dwChromaIREUpperLimit=dbStandardNtscParams[i].dwStdNtscCbParamChromaIRE+gdwColorBarLimitChromaIRE[i].dwUpperLimitChromaIRE;
//	ReportWarning(L"NtscmChromaIREUpperLimits: %lu\n", gdwColorBarLimitChromaIRE[i].dwChromaIREUpperLimit);
	}
	}
}	

	//  NtscmChromaIRE_Std_parameters - ChromaIRE_lower_limits	
	for(i=1;i<NUMBER_OF_BARS-1;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"ntscmcompcb", L"std_ntsccb_chroma_ire",i);
	if((DWORD)GetCfgUint(wszTempBuff,NULL)==NULL){
	dbStandardNtscParams[i].dwStdNtscCbParamChromaIRE=NtscmChromaIREDefaultParam[i];
	dbStandardNtscParams[i].dwStdNtscCbParamChromaIRE=ZEROPARAM;
	dbStandardNtscParams[i].dwStdNtscCbParamChromaIRE=ZEROPARAM;
    gdwColorBarLimitChromaIRE[i].dwChromaIRELowerLimit=dbStandardNtscParams[i].dwStdNtscCbParamChromaIRE-gdwColorBarLimitChromaIRE[i].dwLowerLimitChromaIRE;
//	ReportWarning(L"NtscmChromaIRELowerLimits: %lu\n", gdwColorBarLimitChromaIRE[i].dwChromaIRELowerLimit);
	}else{

	for(i=0;i<NUMBER_OF_BARS;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"ntscmcompcb", L"std_ntsccb_chroma_ire",i);
	dbStandardNtscParams[i].dwStdNtscCbParamChromaIRE=(DWORD)GetCfgUint(wszTempBuff,NULL);
	gdwColorBarLimitChromaIRE[i].dwChromaIRELowerLimit=dbStandardNtscParams[i].dwStdNtscCbParamChromaIRE-gdwColorBarLimitChromaIRE[i].dwLowerLimitChromaIRE;
//	ReportWarning(L"NtscmChromaIRELowerLimits: %lu\n", gdwColorBarLimitChromaIRE[i].dwChromaIRELowerLimit);
		}
	}
}

	// NtscmChromaPhase_Std_parameters + ChromaPhase_upper_limits	
	for(i=0;i<(NUMBER_OF_BARS-2);i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"ntscmcompcb", L"std_ntsccb_chroma_phase",i);
	if((DWORD)GetCfgUint(wszTempBuff,NULL)==NULL){
	gdwColorBarLimitChromaPhase[i].dwChromaPhaseUpperLimit=NtscmChromaPhaseDefaultParam[i];
	gdwColorBarLimitChromaPhase[i].dwChromaPhaseUpperLimit=dbStandardNtscParams[i].dwStdNtscCbParamChromaPhase+gdwColorBarLimitChromaPhase[i].dwUpperLimitChromaPhase;
//	ReportWarning(L"NtscmChromaPhaseUpperLimits: %lu\n", gdwColorBarLimitChromaPhase[i].dwChromaPhaseUpperLimit);
	}else{
	dbStandardNtscParams[i].dwStdNtscCbParamChromaPhase=(DWORD)GetCfgUint(wszTempBuff,NULL);
	gdwColorBarLimitChromaPhase[i].dwChromaPhaseUpperLimit=dbStandardNtscParams[i].dwStdNtscCbParamChromaPhase+gdwColorBarLimitChromaPhase[i].dwUpperLimitChromaPhase;
//	ReportWarning(L"NtscmChromaPhaseUpperLimits: %lu\n", gdwColorBarLimitChromaPhase[i].dwChromaPhaseUpperLimit);
		}
	}

	// NtscmChromaPhase_Std_parameters - ChromaPhase_lower_limits	
	for(i=0;i<(NUMBER_OF_BARS-2);i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"ntscmcompcb", L"std_ntsccb_chroma_phase",i);
	if((DWORD)GetCfgUint(wszTempBuff,NULL)==NULL){
	gdwColorBarLimitChromaPhase[i].dwChromaPhaseLowerLimit=NtscmChromaPhaseDefaultParam[i];
	gdwColorBarLimitChromaPhase[i].dwChromaPhaseLowerLimit=dbStandardNtscParams[i].dwStdNtscCbParamChromaPhase-gdwColorBarLimitChromaPhase[i].dwLowerLimitChromaPhase;
//	ReportWarning(L"ChromaPhaseLowerLimits: %lu\n", gdwColorBarLimitChromaPhase[i].dwChromaPhaseLowerLimit);
	}else{
	dbStandardNtscParams[i].dwStdNtscCbParamChromaPhase=(DWORD)GetCfgUint(wszTempBuff,NULL);
	gdwColorBarLimitChromaPhase[i].dwChromaPhaseLowerLimit=dbStandardNtscParams[i].dwStdNtscCbParamChromaPhase-gdwColorBarLimitChromaPhase[i].dwLowerLimitChromaPhase;
//	ReportWarning(L"ChromaPhaseLowerLimits: %lu\n", gdwColorBarLimitChromaPhase[i].dwChromaPhaseLowerLimit);
	}
}


//*******************************************************************************
//**NTSCJapanCB: Tektronix Std Luma Paramters for NTSC-Japan
//*******************************************************************************

 const int NtscjLumaIREDefaultParam[]={75,66,53,44,31,22,9,7};


	for(i=0;i<NUMBER_OF_BARS;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"ntsc_japan", L"std_param",i);
	if((DWORD)GetCfgUint(wszTempBuff,NULL)==NULL){
	dbStandardNtscParams[i].dwStdNtscJapanCbParamLumaIRE=NtscjLumaIREDefaultParam[i];
//	ReportWarning(L"TektronixStdNtscJapanLumaIRE: %lu\n", dbStandardNtscParams[i].dwStdNtscJapanCbParamLumaIRE);
	}else{
	for(i=0;i<NUMBER_OF_BARS;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"ntsc_japan", L"std_param",i);
	dbStandardNtscParams[i].dwStdNtscJapanCbParamLumaIRE=(DWORD)GetCfgUint(wszTempBuff,NULL);
//	ReportWarning(L"TektronixStdNtscJapanLumaIRE: %lu\n", dbStandardNtscParams[i].dwStdNtscJapanCbParamLumaIRE);
		}
	}
}

//	Ntsc-japan LumaIRE Upper limits
	for(i=0;i<NUMBER_OF_BARS;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"ntsc_japan", L"upper_limits",i);
	if((DWORD)GetCfgUint(wszTempBuff,NULL)==NULL){
	gdwJapanCBLumaIRE[i].dwJapanLumaUpper=DEFAULTPARAM;
//	ReportWarning(L"NtscJapanLumaIREUpperlimits: %lu\n", 	gdwJapanCBLumaIRE[i].dwJapanLumaUpper);
	}else{
	for(i=0;i<NUMBER_OF_BARS;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"ntsc_japan", L"upper_limits",i);
	gdwJapanCBLumaIRE[i].dwJapanLumaUpper=(DWORD)GetCfgUint(wszTempBuff,NULL);
//	ReportWarning(L"NtscJapanLumaIREUpperlimits: %lu\n", 	gdwJapanCBLumaIRE[i].dwJapanLumaUpper);
		}
	}
}	

// Ntsc-japan LumaIre Lower limits
	for(i=0;i<NUMBER_OF_BARS;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"ntsc_japan", L"lower_limits",i);
	if((DWORD)GetCfgUint(wszTempBuff,NULL)==NULL){
	gdwJapanCBLumaIRE[i].dwJapanLumaLower=DEFAULTPARAM;
//	ReportWarning(L"NtscJapanLumaIRELowerlimits: %lu\n", gdwColorBarLimitLumaIRE[i].dwJapanLumaLower);
	}else{
	for(i=0;i<NUMBER_OF_BARS;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"ntsc_japan", L"lower_limits",i);
	gdwJapanCBLumaIRE[i].dwJapanLumaLower=(DWORD)GetCfgUint(wszTempBuff,NULL);
//	ReportWarning(L"NtscJapanLumaIRELowerlimits: %lu\n", 	gdwJapanCBLumaIRE[i].dwJapanLumaLower);
		}
	}
}

	// Ntsc_japan_LumaIRE_Std_parameters + LumaIRE_Upper_Limits

		for(i=0;i<NUMBER_OF_BARS;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"ntsc_japan", L"std_param",i);
	if((DWORD)GetCfgUint(wszTempBuff,NULL)==NULL){
	dbStandardNtscParams[i].dwStdNtscJapanCbParamLumaIRE= NtscjLumaIREDefaultParam[i];
	gdwJapanCBLumaIRE[i].dwJapanLumaUpper=dbStandardNtscParams[i].dwStdNtscJapanCbParamLumaIRE+	gdwJapanCBLumaIRE[i].dwJapanLumaUpper;
//	ReportWarning(L"NtscjLumaIREUpperLimits: %lu\n", 	gdwJapanCBLumaIRE[i].dwJapanLumaUpper);
	}else{
	for(i=0;i<NUMBER_OF_BARS;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"ntsc_japan", L"std_param",i);
	dbStandardNtscParams[i].dwStdNtscJapanCbParamLumaIRE=(DWORD)GetCfgUint(wszTempBuff,NULL);
	gdwJapanCBLumaIRE[i].dwJapanLumaUpper=dbStandardNtscParams[i].dwStdNtscJapanCbParamLumaIRE+	gdwJapanCBLumaIRE[i].dwJapanLumaUpper;
//	ReportWarning(L"NtscjLumaIREUpperLimits: %lu\n", gdwColorBarLimitLumaIRE[i].dwJapanLumaUpper);
		}
	}
}
	// NtscjLumaIRE_Std_parameters - LumaIRE_Lower_limits

	for(i=0;i<NUMBER_OF_BARS;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"ntsc_japan", L"std_param",i);
	if((DWORD)GetCfgUint(wszTempBuff,NULL)==NULL){
	dbStandardNtscParams[i].dwStdNtscJapanCbParamLumaIRE=NtscjLumaIREDefaultParam[i];
	gdwJapanCBLumaIRE[i].dwJapanLumaLower=dbStandardNtscParams[i].dwStdNtscJapanCbParamLumaIRE-gdwJapanCBLumaIRE[i].dwJapanLumaLower;
//	ReportWarning(L"NtscjLumaIRELowerLimits: %lu\n", 	gdwJapanCBLumaIRE[i].dwJapanLumaLower);
	}else{

	for(i=0;i<NUMBER_OF_BARS;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"ntsc_japan", L"std_param",i);
	dbStandardNtscParams[i].dwStdNtscJapanCbParamLumaIRE=(DWORD)GetCfgUint(wszTempBuff,NULL);
	gdwJapanCBLumaIRE[i].dwJapanLumaLower=dbStandardNtscParams[i].dwStdNtscJapanCbParamLumaIRE-gdwJapanCBLumaIRE[i].dwJapanLumaLower;
//	ReportWarning(L"NtscjLumaIRELowerLimits: %lu\n", 	gdwJapanCBLumaIRE[i].dwJapanLumaLower);
		}
	}
}



//********************* PAL UPPPER and LOWER LIMITS ***********
//****** Get the upper and lower limits for PAL
//************************************************************
	//	PalLuma IRE upper limits

	for(i=0;i<NUMBER_OF_BARS;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"palbcompcb", L"luma_ire_upper",i);
if((DWORD)GetCfgUint(wszTempBuff,NULL)==NULL){
	gdwColorBarLimitLumaIRE[i].dwUpperLimitLumaIRE=DEFAULTPARAM ;
//	ReportWarning(L"PalLumaUpperLimits::%lu\n", gdwColorBarLimitLumaIRE[i].dwUpperLimitLumaIRE);
}else{
	gdwColorBarLimitLumaIRE[i].dwUpperLimitLumaIRE=(DWORD)GetCfgUint(wszTempBuff,NULL);
//	ReportWarning(L"PalLumaUpperLimits::%lu\n", gdwColorBarLimitLumaIRE[i].dwUpperLimitLumaIRE);
		}
}


	//LumaIRE lower limits

	for(i=0;i<NUMBER_OF_BARS-1;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"palbcompcb", L"luma_ire_lower",i);
if((DWORD)GetCfgUint(wszTempBuff,NULL)==NULL){
	gdwColorBarLimitLumaIRE[i].dwLowerLimitLumaIRE=DEFAULTPARAM ;
	gdwColorBarLimitLumaIRE[7].dwLowerLimitLumaIRE=ZEROPARAM;
//	ReportWarning(L"PalLumaLowerLimits: %lu\n", gdwColorBarLimitLumaIRE[i].dwLowerLimitLumaIRE);
}else{

	for(i=0;i<NUMBER_OF_BARS;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"palbcompcb", L"luma_ire_lower",i);
	gdwColorBarLimitLumaIRE[i].dwLowerLimitLumaIRE=(DWORD)GetCfgUint(wszTempBuff,NULL);
 //  	ReportWarning(L"PalLumaLowerLimits: %lu\n", gdwColorBarLimitLumaIRE[i].dwLowerLimitLumaIRE);
		}
	}
}

	//PalchromaIRE upper limits
	for(i=0;i<NUMBER_OF_BARS;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"palbcompcb", L"chroma_ire_upper",i);
if((DWORD)GetCfgUint(wszTempBuff,NULL)==NULL){
gdwColorBarLimitChromaIRE[i].dwUpperLimitChromaIRE=DEFAULTPARAM;
//	ReportWarning(L"PalChromaIREUpperLimits:%lu\n", gdwColorBarLimitChromaIRE[i].dwUpperLimitChromaIRE);
}else{
		gdwColorBarLimitChromaIRE[i].dwUpperLimitChromaIRE=(DWORD)GetCfgUint(wszTempBuff,NULL);
 //	ReportWarning(L"PalChromaIREUpperLimits:%lu\n", gdwColorBarLimitChromaIRE[i].dwUpperLimitChromaIRE);
	}
}

	//PalchromaIRE lower limits

	for(i=1;i<NUMBER_OF_BARS-1;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"palbcompcb", L"chroma_ire_lower",i);
 if((DWORD)GetCfgUint(wszTempBuff,NULL)==NULL){
	gdwColorBarLimitChromaIRE[i].dwLowerLimitChromaIRE=DEFAULTPARAM;
	gdwColorBarLimitChromaIRE[0].dwLowerLimitChromaIRE=ZEROPARAM;
	gdwColorBarLimitChromaIRE[7].dwLowerLimitChromaIRE=ZEROPARAM;
//	ReportWarning(L"PalChromaIRELowerLimits: %lu\n", gdwColorBarLimitChromaIRE[i].dwLowerLimitChromaIRE);
	}else{
	for(i=0;i<NUMBER_OF_BARS;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"palbcompcb", L"chroma_ire_lower",i);
	gdwColorBarLimitChromaIRE[i].dwLowerLimitChromaIRE=(DWORD)GetCfgUint(wszTempBuff,NULL);
//	ReportWarning(L"PalChromaIRELowerLimits: %lu\n", gdwColorBarLimitChromaIRE[i].dwLowerLimitChromaIRE);
		}
	}
}
	
	//PalchromaPhase upper limits
	for(i=0;i<NUMBER_OF_BARS-2;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"palbcompcb", L"chroma_phase_upper",i);
  if((DWORD)GetCfgUint(wszTempBuff,NULL)==NULL){
	gdwColorBarLimitChromaPhase[i].dwUpperLimitChromaPhase=PHASEDEFAULTPARAM;
//	ReportWarning(L"PalChromaPhaseUpperLimits:%lu\n", gdwColorBarLimitChromaPhase[i].dwUpperLimitChromaPhase);
  }else{
	gdwColorBarLimitChromaPhase[i].dwUpperLimitChromaPhase=(DWORD)GetCfgUint(wszTempBuff,NULL);
 //	ReportWarning(L"PalChromaPhaseUpperLimits:%lu\n", gdwColorBarLimitChromaPhase[i].dwUpperLimitChromaPhase);
	}
}

	//PalchromaPhase lower limits

	for(i=0;i<NUMBER_OF_BARS-2;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"palbcompcb", L"chroma_phase_lower",i);
if((DWORD)GetCfgUint(wszTempBuff,NULL)==NULL){
	gdwColorBarLimitChromaPhase[i].dwLowerLimitChromaPhase=PHASEDEFAULTPARAM;
//	ReportWarning(L"PalChromaPhaseLowerLimits: %lu\n", gdwColorBarLimitChromaPhase[i].dwLowerLimitChromaPhase);
}else{
	gdwColorBarLimitChromaPhase[i].dwLowerLimitChromaPhase=(DWORD)GetCfgUint(wszTempBuff,NULL);
// 	ReportWarning(L"PalChromaPhaseLowerLimits: %lu\n", gdwColorBarLimitChromaPhase[i].dwLowerLimitChromaPhase);
	}
}

//********************* PAL TV standards ***********
//****** Get the standard video parameters for Pal
//**************************************************
	//Standard LumaIRE video parameters for pal tv standards
 const int PalLumaDefaultParam[]={98,65,51,43,30,21,8,0};
 const int PalChromaIREDefaultParam[]={0,63,89,83,83,90,62,0};
 const int PalChromaPhaseDefaultParam[]={169,287,244,63,106,349};

//Tektronix LumaIRE video parameters for pal tv standards
	for(i=0;i<NUMBER_OF_BARS-1;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"palbcompcb", L"std_palcb_luma_ire",i);
if((DWORD)GetCfgUint(wszTempBuff,NULL)==NULL){
dbStandardPalParams[i].dwStdPalCbParamLumaIRE=PalLumaDefaultParam[i];
 //ReportWarning(L"Pal-TekStdLumaIRE: %lu\n", dbStandardPalParams[i].dwStdPalCbParamLumaIRE);
}else{
	for(i=0;i<NUMBER_OF_BARS;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"palbcompcb", L"std_palcb_luma_ire",i);
	dbStandardPalParams[i].dwStdPalCbParamLumaIRE=(DWORD)GetCfgUint(wszTempBuff,NULL);
// ReportWarning(L"Pal-TekStdLumaIRE: %lu\n", dbStandardPalParams[i].dwStdPalCbParamLumaIRE);
		}
	}
}

//Tektronix ChromaIRE video parameters for pal tv standards
	for(i=1;i<NUMBER_OF_BARS-1;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"palbcompcb", L"std_palcb_chroma_ire",i);
if((DWORD)GetCfgUint(wszTempBuff,NULL)==NULL){
	dbStandardPalParams[i].dwStdPalCbParamChromaIRE=PalChromaIREDefaultParam[i];
	dbStandardPalParams[0].dwStdPalCbParamChromaIRE=ZEROPARAM;
	dbStandardPalParams[7].dwStdPalCbParamChromaIRE=ZEROPARAM;
//	ReportWarning(L"Pal-TekStdChromaIRE: %lu\n", dbStandardPalParams[i].dwStdPalCbParamChromaIRE);
}else{	
	for(i=0;i<NUMBER_OF_BARS;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"palbcompcb", L"std_palcb_chroma_ire",i);
	dbStandardPalParams[i].dwStdPalCbParamChromaIRE=(DWORD)GetCfgUint(wszTempBuff,NULL);
//	ReportWarning(L"Pal-TekStdChromaIRE: %lu\n", dbStandardPalParams[i].dwStdPalCbParamChromaIRE);
		}
	}
}

	//Tektronix ChromaPhase video parameters for pal tv standards
	for(i=0;i<(NUMBER_OF_BARS-2);i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"palbcompcb", L"std_palcb_chroma_phase",i);
if((DWORD)GetCfgUint(wszTempBuff,NULL)==NULL){
	dbStandardPalParams[i].dwStdPalCbParamChromaPhase=PalChromaPhaseDefaultParam[i];
//	ReportWarning(L"Pal-TekStdChromaPhase: %lu\n", dbStandardPalParams[i].dwStdPalCbParamChromaPhase);
}else{
		dbStandardPalParams[i].dwStdPalCbParamChromaPhase=(DWORD)GetCfgUint(wszTempBuff,NULL);
//	ReportWarning(L"Pal-TekStdChromaPhase: %lu\n", dbStandardPalParams[i].dwStdPalCbParamChromaPhase);
	}

	}


//*******************************************************************************
//***PAL_CB: Standard parmater + Upper limits and Standard parameter - lower limits
//*******************************************************************************

	// Pal-TekLumaIRE_Std_parameters + LumaIRE_Upper_Limits

		for(i=0;i<NUMBER_OF_BARS-1;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"palbcompcb", L"std_palcb_luma_ire",i);
 if((DWORD)GetCfgUint(wszTempBuff,NULL)==NULL){
	dbStandardPalParams[i].dwStdPalCbParamLumaIRE=PalLumaDefaultParam[i];
//	ReportWarning(L"Pal-LumaIREUpperLimits: %lu\n", gdwColorBarLimitLumaIRE[i].dwPalCbLumaIREUpperLimit);
	}else{
	for(i=0;i<NUMBER_OF_BARS;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"palbcompcb", L"std_palcb_luma_ire",i);
		dbStandardPalParams[i].dwStdPalCbParamLumaIRE=(DWORD)GetCfgUint(wszTempBuff,NULL);

	gdwColorBarLimitLumaIRE[i].dwPalCbLumaIREUpperLimit=dbStandardPalParams[i].dwStdPalCbParamLumaIRE + gdwColorBarLimitLumaIRE[i].dwUpperLimitLumaIRE;
//	ReportWarning(L"pal-LumaIREUpperLimits: %lu\n", gdwColorBarLimitLumaIRE[i].dwPalCbLumaIREUpperLimit);
		}
	}
}
	// Pal-LumaIRE_Std_parameters - LumaIRE_Lower_limits

	for(i=0;i<NUMBER_OF_BARS-1;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"palbcompcb", L"std_palcb_luma_ire",i);
	if((DWORD)GetCfgUint(wszTempBuff,NULL)==NULL){
	dbStandardPalParams[i].dwStdPalCbParamLumaIRE=PalLumaDefaultParam[i];
//	ReportWarning(L"Pal-LumaIRELowerLimits: %lu\n", gdwColorBarLimitLumaIRE[i].dwPalCbLumaIRELowerLimit);
	}else{
	for(i=0;i<NUMBER_OF_BARS;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"palbcompcb", L"std_palcb_luma_ire",i);
	dbStandardPalParams[i].dwStdPalCbParamLumaIRE=(DWORD)GetCfgUint(wszTempBuff,NULL);
	gdwColorBarLimitLumaIRE[i].dwPalCbLumaIRELowerLimit=dbStandardPalParams[i].dwStdPalCbParamLumaIRE-gdwColorBarLimitLumaIRE[i].dwLowerLimitLumaIRE;
//	ReportWarning(L"LumaIRELowerLimits: %lu\n", gdwColorBarLimitLumaIRE[i].dwPalCbLumaIRELowerLimit);
		}
	}
}

	// Pal-ChromaIRE_Std_parameters + ChromaIRE_upper_limits	
	for(i=0;i<NUMBER_OF_BARS;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"palbcompcb", L"std_palcb_chroma_ire",i);
if((DWORD)GetCfgUint(wszTempBuff,NULL)==NULL){
	dbStandardPalParams[i].dwStdPalCbParamChromaIRE=PalChromaIREDefaultParam[i];
	dbStandardPalParams[0].dwStdPalCbParamChromaIRE=ZEROPARAM;
	dbStandardPalParams[7].dwStdPalCbParamChromaIRE=ZEROPARAM;
//	ReportWarning(L"Pal-ChromaIREUpperLimits: %lu\n", gdwColorBarLimitChromaIRE[i].dwPalCbChromaIREUpperLimit);
	}else{
	for(i=0;i<NUMBER_OF_BARS;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"palbcompcb", L"std_palcb_chroma_ire",i);
	dbStandardPalParams[i].dwStdPalCbParamChromaIRE=(DWORD)GetCfgUint(wszTempBuff,NULL);
	gdwColorBarLimitChromaIRE[i].dwPalCbChromaIREUpperLimit=dbStandardPalParams[i].dwStdPalCbParamChromaIRE+gdwColorBarLimitChromaIRE[i].dwUpperLimitChromaIRE;
//	ReportWarning(L"Pal-ChromaIREUpperLimits: %lu\n", gdwColorBarLimitChromaIRE[i].dwPalCbChromaIREUpperLimit);
		}
	}
}

	//  Pal-ChromaIRE_Std_parameters - ChromaIRE_lower_limits	
	for(i=1;i<NUMBER_OF_BARS-1;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"palbcompcb", L"std_palcb_chroma_ire",i);
if((DWORD)GetCfgUint(wszTempBuff,NULL)==NULL){
	dbStandardPalParams[i].dwStdPalCbParamChromaIRE=PalChromaIREDefaultParam[i];
	dbStandardPalParams[0].dwStdPalCbParamChromaIRE=ZEROPARAM;
	dbStandardPalParams[7].dwStdPalCbParamChromaIRE=ZEROPARAM;
//	ReportWarning(L"Pal-ChromaIRELowerLimits: %lu\n", gdwColorBarLimitChromaIRE[i].dwPalCbChromaIRELowerLimit);
}else{
for(i=0;i<NUMBER_OF_BARS;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"palbcompcb", L"std_palcb_chroma_ire",i);
	dbStandardPalParams[i].dwStdPalCbParamChromaIRE=(DWORD)GetCfgUint(wszTempBuff,NULL);
	gdwColorBarLimitChromaIRE[i].dwPalCbChromaIRELowerLimit=	dbStandardPalParams[i].dwStdPalCbParamChromaIRE-gdwColorBarLimitChromaIRE[i].dwLowerLimitChromaIRE;
//	ReportWarning(L"Pal-ChromaIRELowerLimits: %lu\n", gdwColorBarLimitChromaIRE[i].dwPalCbChromaIRELowerLimit);
		}
	}
}

	// Pal-ChromaPhase_Std_parameters + ChromaPhase_upper_limits	
	for(i=0;i<(NUMBER_OF_BARS-2);i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"palbcompcb", L"std_palcb_chroma_phase",i);
if((DWORD)GetCfgUint(wszTempBuff,NULL)==NULL){
	dbStandardPalParams[i].dwStdPalCbParamChromaPhase=PalChromaPhaseDefaultParam[i];
//	ReportWarning(L"Pal-ChromaPhaseUpperLimits: %lu\n", gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseUpperLimit);
}else{
	for(i=0;i<(NUMBER_OF_BARS-2);i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"palbcompcb", L"std_palcb_chroma_phase",i);
	dbStandardPalParams[i].dwStdPalCbParamChromaPhase=(DWORD)GetCfgUint(wszTempBuff,NULL);
	gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseUpperLimit=dbStandardPalParams[i].dwStdPalCbParamChromaPhase+gdwColorBarLimitChromaPhase[i].dwUpperLimitChromaPhase;
//	ReportWarning(L"Pal-ChromaPhaseUpperLimits: %lu\n", gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseUpperLimit);
		}
	}
}
	// Pal-ChromaPhase_Std_parameters - ChromaPhase_lower_limits	
	for(i=0;i<(NUMBER_OF_BARS-2);i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"palbcompcb", L"std_palcb_chroma_phase",i);
	if((DWORD)GetCfgUint(wszTempBuff,NULL)==NULL){
	dbStandardPalParams[i].dwStdPalCbParamChromaPhase=PalChromaPhaseDefaultParam[i];
//	ReportWarning(L"Pal-ChromaPhaseLowerLimits: %lu\n", gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseLowerLimit);
	}else{
	for(i=0;i<(NUMBER_OF_BARS-2);i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"palbcompcb", L"std_palcb_chroma_phase",i);
	dbStandardPalParams[i].dwStdPalCbParamChromaPhase=(DWORD)GetCfgUint(wszTempBuff,NULL);
	gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseLowerLimit=dbStandardPalParams[i].dwStdPalCbParamChromaPhase-gdwColorBarLimitChromaPhase[i].dwLowerLimitChromaPhase;
//	ReportWarning(L"Pal-ChromaPhaseLowerLimits: %lu\n", gdwColorBarLimitChromaPhase[i].dwPalCbChromaPhaseLowerLimit);
		}
	}
}

//*********************************************************************
//******* get the upper and lower limits for NTSC/Composite Multiburst 
//*********************************************************************


	//Multiburst NTSC/Composite upper and lower limits
	for(i=0;i<NUMBER_OF_FREQ;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"ntscmcompmb", L"freq_respnse_comp_lower",i);
	dbFreqLimit[i].NtscCompLowerLimit=(DWORD)GetCfgInt(wszTempBuff,NULL);
//	ReportDebug(BIT0,L"NTSCMBurstCompLowerLimits: %d(dB)\n",	dbFreqLimit[i].NtscCompLowerLimit );

	}

	for(i=0;i<NUMBER_OF_FREQ;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"ntscmcompmb", L"freq_respnse_comp_upper",i);
		dbFreqLimit[i].NtscCompUpperLimit=(DWORD)GetCfgInt(wszTempBuff,NULL);	
		
//	ReportDebug(BIT0,L"NTSCMBurstCompUpperLimits: %d(dB)\n",	dbFreqLimit[i].NtscCompUpperLimit );

	}
//*********************************************************************
//******* get the upper and lower limits for NTSC/S-Video Multiburst 
//*********************************************************************


	//Multiburst NTSC/S-Video upper and lower limits
	for(i=0;i<NUMBER_OF_FREQ;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"ntscmcompmb", L"freq_respnse_sv_lower",i);
	dbFreqLimit[i].NtscSvLowerLimit=(DWORD)GetCfgInt(wszTempBuff,NULL);
//	ReportDebug(BIT0,L"NTSCMBurstSvLowerLimits: %d(dB)\n",	dbFreqLimit[i].NtscSvLowerLimit );

	}

	for(i=0;i<NUMBER_OF_FREQ;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"ntscmcompmb", L"freq_respnse_sv_upper",i);
		dbFreqLimit[i].NtscSvUpperLimit=(DWORD)GetCfgInt(wszTempBuff,NULL);	
		
//	ReportDebug(BIT0,L"NTSCMBurstSvUpperLimits: %d(dB)\n",	dbFreqLimit[i].NtscSvUpperLimit );

	}


//********************************************************************
//******* get the upper and lower limits for PAL/Composite Multiburst 
//********************************************************************



//Multiburst PAL/Compsoite upper and lower limits
	for(i=0;i<NUMBER_OF_FREQ;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"palcompmb", L"freq_respnse_comp_lower",i);
	dbFreqLimit[i].PalCompLowerLimit=(DWORD)GetCfgInt(wszTempBuff,NULL);
//	ReportDebug(BIT0,L"PALMBurstCompLowerLimits: %d(dB)\n",	dbFreqLimit[i].PalCompLowerLimit);

	}

	for(i=0;i<NUMBER_OF_FREQ;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"palcompmb", L"freq_respnse_commp_upper",i);
		dbFreqLimit[i].PalCompUpperLimit=(DWORD)GetCfgInt(wszTempBuff,NULL);	
//	ReportDebug(BIT0,L"PALMBurstCompUpperLimits: %d(dB)\n",	dbFreqLimit[i].PalCompUpperLimit );

	}


//********************************************************************
//******* get the upper and lower limits for PAL/S-Video Multiburst 
//********************************************************************

//Multiburst PAL/Svideo upper and lower limits
	for(i=0;i<NUMBER_OF_FREQ;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"palcompmb", L"freq_respnse_sv_lower",i);
	dbFreqLimit[i].PalSvLowerLimit=(DWORD)GetCfgInt(wszTempBuff,NULL);
//	ReportDebug(BIT0,L"PALMBurstSvLowerLimits: %d(dB)\n",	dbFreqLimit[i].PalSvLowerLimit);

	}

	for(i=0;i<NUMBER_OF_FREQ;i++){
	swprintf(wszTempBuff, L"%s.%s[%lu]", L"palcompmb", L"freq_respnse_sv_upper",i);
		dbFreqLimit[i].PalSvUpperLimit=(DWORD)GetCfgInt(wszTempBuff,NULL);	
//	ReportDebug(BIT0,L"PALMBurstSvUpperLimits: %d(dB)\n",	dbFreqLimit[i].PalSvUpperLimit );

	}

	return true;
}
 







//-----------------------------------------------------------------------------
// Name: Cleanup()
// Desc: Releases all previously initialized objects
//-----------------------------------------------------------------------------




VOID CXModuleTV::Cleanup()
{

 if( m_pVB != NULL )        
        m_pVB->Release();

 SAFE_RELEASE(m_pTVPatternVB);

 //    if( m_pD3D != NULL )       
//        m_pD3D->Release();

//g_pd3dDevice->Reset(&g_d3dpp);

}


BOOL CXModuleTV::DrawNTSCCB()
{

#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ| D3DFVF_NORMAL|D3DFVF_DIFFUSE)

	HRESULT hr;
    static LPDIRECT3DVERTEXBUFFER8 m_pVB  = NULL;

if((hr = g_pd3dDevice->CreateVertexBuffer( 17*4*sizeof(CUSTOMVERTEX),
                                                  D3DUSAGE_WRITEONLY, D3DFVF_CUSTOMVERTEX,
                                                  D3DPOOL_MANAGED, &m_pVB )) != D3D_OK)
	{
		ReportD3DError(hr);
		return FALSE;
	}

  //CUSTOMVERTEX* pwv;

if(FAILED(m_pVB->Lock(0,0,(BYTE**)&wv,0)))
return false;
wv[0].p = D3DXVECTOR4( 0, 0, 1.0f, 1.0f );     wv[0].color =0xffffffff;
wv[1].p = D3DXVECTOR4( 91.00f, 0, 1.0f, 1.0f );   wv[1].color =0xffffffff;
wv[2].p = D3DXVECTOR4( 0, 320.0f, 1.0f,1.0f  );   wv[2].color =0xffffffff;
wv[3].p = D3DXVECTOR4( 91.00f, 320.0f,	1.0f,1.0f ); wv[3].color =0xffffffff;
 //memcpy( pwv, wv, 4*sizeof(CUSTOMVERTEX) );

m_pVB->Unlock();

//Yellow
// CUSTOMVERTEX* pyv;
if(FAILED(m_pVB->Lock(0,0,(BYTE**)&yv,0)))
return false;

yv[0].p = D3DXVECTOR4( 91.00f, 0,	1.0f, 1.0f ); yv[0].color = 0xffffff00;
yv[1].p = D3DXVECTOR4( 182.00f, 0,	1.0f, 1.0f ); yv[1].color = 0xffffff00;
yv[2].p = D3DXVECTOR4( 91.00f, 320.0f,1.0f, 1.0f ); yv[2].color =0xffffff00;
yv[3].p = D3DXVECTOR4( 182.00f, 320.0f,1.0f, 1.0f ); yv[3].color =0xffffff00;

//memcpy( pyv, yv, 4*sizeof(CUSTOMVERTEX) );
m_pVB->Unlock();

//Cyan

//CUSTOMVERTEX* pcv;
if(FAILED(m_pVB->Lock(0,0,(BYTE**)&cv,0)))
return false;

cv[0].p = D3DXVECTOR4( 182.00f, 0,	1.0f, 1.0f ); cv[0].color =0xff00ffff;
cv[1].p = D3DXVECTOR4( 273.00f, 0,	1.0f, 1.0f ); cv[1].color = 0xff00ffff;
cv[2].p = D3DXVECTOR4( 182.00f, 320.0f,1.0f, 1.0f ); cv[3].color = 0xff00ffff;
cv[3].p = D3DXVECTOR4( 273.00f, 320.0f,1.0f, 1.0f ); cv[2].color =0xff00ffff;
 //memcpy( pcv, cv, 4*sizeof(CUSTOMVERTEX) );

m_pVB->Unlock();

//Green (blue)
//CUSTOMVERTEX* pgv;
if(FAILED(m_pVB->Lock(0,0,(BYTE**)&gv,0)))
return false;

gv[0].p = D3DXVECTOR4( 273.00f, 0,	1.0f, 1.0f ); gv[0].color = 0xff00ff00;
gv[1].p = D3DXVECTOR4( 364.00f, 0,	1.0f, 1.0f ); gv[1].color = 0xff00ff00;
gv[2].p = D3DXVECTOR4( 273.00f, 320.0f,1.0f, 1.0f ); gv[2].color =0xff00ff00;
gv[3].p = D3DXVECTOR4( 364.00f, 320.0f,1.0f, 1.0f ); gv[3].color = 0xff00ff00;
 //memcpy( pgv, gv, 4*sizeof(CUSTOMVERTEX) );

m_pVB->Unlock();

//Magenta
m_pVB->Lock(0,0,(BYTE**)&mv,0);
mv[0].p = D3DXVECTOR4( 364.00f, 0,	1.0f, 1.0f ); mv[0].color = 0xffff00ff;
mv[1].p = D3DXVECTOR4( 456.00f, 0,	1.0f, 1.0f ); mv[1].color = 0xffff00ff;
mv[2].p = D3DXVECTOR4( 364.00f, 320.0f,1.0f, 1.0f ); mv[2].color = 0xffff00ff;
mv[3].p = D3DXVECTOR4( 456.00f, 320.0f,1.0f, 1.0f ); mv[3].color =0xffff00ff; 
m_pVB->Unlock();

//Red (black)
m_pVB->Lock(0,0,(BYTE**)&rv,0);
rv[0].p = D3DXVECTOR4( 456.00f, 0,	1.0f, 1.0f ); rv[0].color = 0xffff0000;
rv[1].p = D3DXVECTOR4( 547.00f, 0,	1.0f, 1.0f ); rv[1].color = 0xffff0000;
rv[2].p = D3DXVECTOR4( 456.00f, 320.0f,1.0f, 1.0f ); rv[2].color =0xffff0000;
rv[3].p = D3DXVECTOR4( 547.00f, 320.0f,1.0f, 1.0f ); rv[3].color =0xffff0000;
m_pVB->Unlock();

//Blue
m_pVB->Lock(0,0,(BYTE**)&bv,0);
bv[0].p = D3DXVECTOR4( 547.00f, 0,	1.0f, 1.0f ); bv[0].color = 0xff0000ff;
bv[1].p = D3DXVECTOR4( 640.00f, 0,	1.0f, 1.0f ); bv[1].color =0xff0000ff;
bv[2].p = D3DXVECTOR4( 547.00f, 320.0f,1.0f, 1.0f ); bv[2].color =0xff0000ff;
bv[3].p = D3DXVECTOR4( 640.00f, 320.0f,1.0f, 1.0f ); bv[3].color =0xff0000ff;
m_pVB->Unlock();
//Small Blue bar
m_pVB->Lock(0,0,(BYTE**)&sbv,0);
sbv[0].p = D3DXVECTOR4( 0, 320.0f,	1.0f, 1.0f ); sbv[0].color = 0xff0000ff;
sbv[1].p = D3DXVECTOR4( 91.42850f, 320.0f,	1.0f, 1.0f ); sbv[1].color = 0xff0000ff;
sbv[2].p = D3DXVECTOR4( 0, 360.0f,1.0f, 1.0f ); sbv[2].color = 0xff0000ff;
sbv[3].p = D3DXVECTOR4( 91.4285f, 360.0f,1.0f, 1.0f ); sbv[3].color =0xff0000ff;
m_pVB->Unlock();

//small black bar
m_pVB->Lock(0,0,(BYTE**)&skv,0);
skv[0].p = D3DXVECTOR4( 91.4285f, 320.0f,	1.0f, 1.0f ); skv[0].color = 0;
skv[1].p = D3DXVECTOR4( 182.875f, 320.0f,	1.0f, 1.0f ); skv[1].color = 0;
skv[2].p = D3DXVECTOR4( 91.4285f, 360.0f,1.0f, 1.0f ); skv[2].color =0;
skv[3].p = D3DXVECTOR4( 182.875f, 360.0f,1.0f, 1.0f ); skv[3].color = 0;

m_pVB->Unlock();

//small Magenta bar
m_pVB->Lock(0,0,(BYTE**)&smv,0);

smv[0].p = D3DXVECTOR4( 182.875f, 320.0f,	1.0f, 1.0f ); smv[0].color =0xffff00ff; 
smv[1].p = D3DXVECTOR4( 274.304f, 320.0f,	1.0f, 1.0f ); smv[1].color = 0xffff00ff;
smv[2].p = D3DXVECTOR4( 182.875f, 360.0f,1.0f, 1.0f ); smv[2].color = 0xffff00ff;
smv[3].p = D3DXVECTOR4( 274.304f, 360.0f,1.0f, 1.0f ); smv[3].color =0xffff00ff;
m_pVB->Unlock();


// small black/green
m_pVB->Lock(0,0,(BYTE**)&skv1,0);
skv1[0].p = D3DXVECTOR4( 274.304f, 320.0f,	1.0f, 1.0f ); skv1[0].color = 0x00000000;
skv1[1].p = D3DXVECTOR4( 365.732f, 320.0f,	1.0f, 1.0f ); skv1[1].color = 0x00000000;
skv1[2].p = D3DXVECTOR4( 274.304f, 360.0f,1.0f, 1.0f ); skv1[2].color =0x00000000;
skv1[3].p = D3DXVECTOR4( 365.732f, 360.0f,1.0f, 1.0f ); skv1[3].color = 0x00000000;
m_pVB->Unlock();


// small cyan/Magenta
m_pVB->Lock(0,0,(BYTE**)&scv,0);
scv[0].p = D3DXVECTOR4( 365.732f, 320.0f,	1.0f, 1.0f ); scv[0].color =0xff00ffff; 
scv[1].p = D3DXVECTOR4( 457.161f, 320.0f,	1.0f, 1.0f ); scv[1].color =0xff00ffff; 
scv[2].p = D3DXVECTOR4( 365.732f, 360.0f,1.0f, 1.0f ); scv[2].color =0xff00ffff;
scv[3].p = D3DXVECTOR4( 457.161f, 360.0f,1.0f, 1.0f ); scv[3].color =0xff00ffff; 

m_pVB->Unlock();

//small black/red
m_pVB->Lock(0,0,(BYTE**)&skv2,0);
skv2[0].p = D3DXVECTOR4( 457.161f, 320.0f,	1.0f, 1.0f ); skv2[0].color = 0x00000000;
skv2[1].p = D3DXVECTOR4( 548.589f, 320.0f,	1.0f, 1.0f ); skv2[1].color = 0x00000000;
skv2[2].p = D3DXVECTOR4( 457.161f, 360.0f,1.0f, 1.0f ); skv2[2].color =0x00000000;
skv2[3].p = D3DXVECTOR4( 548.585f, 360.0f,1.0f, 1.0f ); skv2[3].color = 0x00000000;
m_pVB->Unlock();


//small white/blue
m_pVB->Lock(0,0,(BYTE**)&swv,0);
swv[0].p = D3DXVECTOR4( 548.589f, 320.0f, 1.0f, 1.0f );     swv[0].color = 0xffffffff;
swv[1].p = D3DXVECTOR4( 640.0f, 320.0f, 1.0f, 1.0f );   swv[1].color = 0xffffffff;
swv[2].p = D3DXVECTOR4( 548.589f, 360.0f, 1.0f,1.0f  );   swv[2].color = 0xffffffff;
swv[3].p = D3DXVECTOR4( 640.0f, 360.0f,	1.0f,1.0f ); swv[3].color = 0xffffffff;
m_pVB->Unlock();



//Bottom black bar
m_pVB->Lock(0,0,(BYTE**)&skvb,0);
skvb[0].p = D3DXVECTOR4(0, 360.0f,	1.0f, 1.0f ); skvb[0].color =0x00000000;
skvb[1].p = D3DXVECTOR4( 121.629f, 360.0f,	1.0f, 1.0f ); skvb[1].color =0x00000000; 
skvb[2].p = D3DXVECTOR4( 0, 480.0f,1.0f, 1.0f ); skvb[2].color =0x00000000;
skvb[3].p = D3DXVECTOR4( 121.629f, 480.0f,1.0f, 1.0f ); skvb[3].color =0x00000000; 
m_pVB->Unlock();

//Bottom white bar
m_pVB->Lock(0,0,(BYTE**)&swvb,0);
swvb[0].p = D3DXVECTOR4( 121.629f, 360.0f, 1.0f, 1.0f );     swvb[0].color = 0xffffffff;
swvb[1].p = D3DXVECTOR4( 228.590f, 360.0f, 1.0f, 1.0f );   swvb[1].color = 0xffffffff;
swvb[2].p = D3DXVECTOR4( 121.629f, 480.0f, 1.0f,1.0f  );   swvb[2].color = 0xffffffff;
swvb[3].p = D3DXVECTOR4( 228.590f, 480.0f,	1.0f,1.0f ); swvb[3].color = 0xffffffff;
m_pVB->Unlock();

//Bottom black bar2
m_pVB->Lock(0,0,(BYTE**)&skvb2,0);
skvb2[0].p = D3DXVECTOR4(228.590f, 360.0f,	1.0f, 1.0f ); skvb2[0].color =0x00000000;
skvb2[1].p = D3DXVECTOR4( 640.0f, 360.0f,	1.0f, 1.0f ); skvb2[1].color =0x00000000; 
skvb2[2].p = D3DXVECTOR4( 228.590f, 480.0f,1.0f, 1.0f ); skvb2[2].color =0x00000000;
skvb2[3].p = D3DXVECTOR4( 640.0f, 480.0f,1.0f, 1.0f ); skvb2[3].color =0x00000000; 
m_pVB->Unlock();



return true;

}

BOOL CXModuleTV::DrawPALCB()
{
	HRESULT hr;
static LPDIRECT3DVERTEXBUFFER8 m_pVB  = NULL;


if((hr = g_pd3dDevice->CreateVertexBuffer( 17*4*sizeof(CUSTOMVERTEX),
                                                  D3DUSAGE_WRITEONLY, D3DFVF_CUSTOMVERTEX,
                                                  D3DPOOL_MANAGED, &m_pVB )) != D3D_OK)
	{
		ReportD3DError(hr);
		return FALSE;
	}


//PAL TV Standard for 640x480 video mode
//White

m_pVB->Lock(0,0,(BYTE**)&pwv,0);
pwv[0].p = D3DXVECTOR4( 0, 0, 1.0f, 1.0f );     pwv[0].color = 0xffffffff;
pwv[1].p = D3DXVECTOR4( 80.0f, 0, 1.0f, 1.0f );   pwv[1].color = 0xffffffff;
pwv[2].p = D3DXVECTOR4( 0, 480.0f, 1.0f,1.0f  );   pwv[2].color = 0xffffffff;
pwv[3].p = D3DXVECTOR4( 80.0f, 480.0f,	1.0f,1.0f ); pwv[3].color = 0xffffffff;
m_pVB->Unlock();

//Yellow
m_pVB->Lock(0,0,(BYTE**)&pyv,0);
pyv[0].p = D3DXVECTOR4( 80.0f, 0,	1.0f, 1.0f ); pyv[0].color = 0xffffff00;
pyv[1].p = D3DXVECTOR4( 160.0f, 0,	1.0f, 1.0f ); pyv[1].color = 0xffffff00;
pyv[2].p = D3DXVECTOR4( 80.0f, 480.0f,1.0f, 1.0f ); pyv[2].color = 0xffffff00;
pyv[3].p = D3DXVECTOR4( 160.0f, 480.0f,1.0f, 1.0f ); pyv[3].color = 0xffffff00;
m_pVB->Unlock();

//Cyan
m_pVB->Lock(0,0,(BYTE**)&pcv,0);
pcv[0].p = D3DXVECTOR4( 160.0f, 0,	1.0f, 1.0f ); pcv[0].color = 0xff00ffff;
pcv[1].p = D3DXVECTOR4( 240.0f, 0,	1.0f, 1.0f ); pcv[1].color = 0xff00ffff;
pcv[2].p = D3DXVECTOR4( 160.0f, 480.0f,1.0f, 1.0f ); pcv[3].color = 0xff00ffff;
pcv[3].p = D3DXVECTOR4( 240.0f, 480.0f,1.0f, 1.0f ); pcv[2].color = 0xff00ffff;
m_pVB->Unlock();

//Green
m_pVB->Lock(0,0,(BYTE**)&pgv,0);
pgv[0].p = D3DXVECTOR4( 240.0f, 0,	1.0f, 1.0f ); pgv[0].color = 0xff00ff00;
pgv[1].p = D3DXVECTOR4( 320.0f, 0,	1.0f, 1.0f ); pgv[1].color = 0xff00ff00;
pgv[2].p = D3DXVECTOR4( 240.0f, 480.0f,1.0f, 1.0f ); pgv[2].color = 0xff00ff00;
pgv[3].p = D3DXVECTOR4( 320.0f, 480.0f,1.0f, 1.0f ); pgv[3].color = 0xff00ff00;
m_pVB->Unlock();

//Magenta
m_pVB->Lock(0,0,(BYTE**)&pmv,0);
pmv[0].p = D3DXVECTOR4( 320.0f, 0,	1.0f, 1.0f ); pmv[0].color = 0xffff00ff;
pmv[1].p = D3DXVECTOR4( 400.0f, 0,	1.0f, 1.0f ); pmv[1].color = 0xffff00ff;
pmv[2].p = D3DXVECTOR4( 320.0f, 480.0f,1.0f, 1.0f ); pmv[2].color = 0xffff00ff;
pmv[3].p = D3DXVECTOR4( 400.0f, 480.0f,1.0f, 1.0f ); pmv[3].color =0xffff00ff; 
m_pVB->Unlock();

//Red
m_pVB->Lock(0,0,(BYTE**)&prv,0);
prv[0].p = D3DXVECTOR4( 400.0f, 0,	1.0f, 1.0f ); prv[0].color = 0xffff0000;
prv[1].p = D3DXVECTOR4( 480.0f, 0,	1.0f, 1.0f ); prv[1].color = 0xffff0000;
prv[2].p = D3DXVECTOR4( 400.0f, 480.0f,1.0f, 1.0f ); prv[2].color =0xffff0000;
prv[3].p = D3DXVECTOR4( 480.0f, 480.0f,1.0f, 1.0f ); prv[3].color = 0xffff0000;
m_pVB->Unlock();

//Blue
m_pVB->Lock(0,0,(BYTE**)&pbv,0);
pbv[0].p = D3DXVECTOR4( 480.0f, 0,	1.0f, 1.0f ); pbv[0].color = 0xff0000ff;
pbv[1].p = D3DXVECTOR4( 560.0f, 0,	1.0f, 1.0f ); pbv[1].color = 0xff0000ff;
pbv[2].p = D3DXVECTOR4( 480.0f, 480.0f,1.0f, 1.0f ); pbv[2].color = 0xff0000ff;
pbv[3].p = D3DXVECTOR4( 560.0f, 480.0f,1.0f, 1.0f ); pbv[3].color =0xff0000ff;
m_pVB->Unlock();
//black
m_pVB->Lock(0,0,(BYTE**)&pbkv,0);
pbkv[0].p = D3DXVECTOR4( 560.0f, 0,	1.0f, 1.0f ); pbkv[0].color = 0x00000000;
pbkv[1].p = D3DXVECTOR4( 640.0f, 0,	1.0f, 1.0f ); pbkv[1].color = 0x00000000;
pbkv[2].p = D3DXVECTOR4( 560.0f, 480.0f,1.0f, 1.0f ); pbkv[2].color = 0x00000000;
pbkv[3].p = D3DXVECTOR4( 640.0f, 480.0f,1.0f, 1.0f ); pbkv[3].color =0x00000000;
m_pVB->Unlock();



	return true;

}

VOID CXModuleTV::NTSCCBRender()
{


 g_pd3dDevice->Clear( 0, NULL,
						D3DCLEAR_TARGET|D3DCLEAR_TARGET_R|D3DCLEAR_TARGET_G|D3DCLEAR_TARGET_G|
						D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, D3DCOLOR_XRGB(255,255,255), 1.0f, 0 );

   

    // Begin the scene
   g_pd3dDevice->BeginScene();

 //NTSC   
g_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
g_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, wv, sizeof(wv[0]));
g_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, yv, sizeof(yv[0]));
g_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, cv, sizeof(cv[0]));
g_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, gv, sizeof(gv[0]));
g_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, mv, sizeof(mv[0]));
g_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, rv, sizeof(rv[0]));
g_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, bv, sizeof(bv[0]));
g_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, sbv, sizeof(sbv[0]));
g_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, skv, sizeof(skv[0]));
g_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, skvb, sizeof(skvb[0]));
g_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, smv, sizeof(smv[0]));
g_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, skv1, sizeof(skv1[0]));
g_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, scv, sizeof(scv[0]));
g_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, skv2, sizeof(skv2[0]));
g_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, swv, sizeof(swv[0]));
g_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, swvb, sizeof(swvb[0]));
g_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, skvb2, sizeof(skvb2[0]));

   // End the scene
    g_pd3dDevice->EndScene();

    // Present the backbuffer contents to the display
  //  g_pd3dDevice->Present( NULL, NULL, NULL, NULL );

  
return;

}

VOID CXModuleTV::PALCBRender()
{

// Clear the backbuffer to a 75% white color
    
	 g_pd3dDevice->Clear( 0, NULL,
						D3DCLEAR_TARGET|D3DCLEAR_TARGET_R|D3DCLEAR_TARGET_G|D3DCLEAR_TARGET_G|
						D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, D3DCOLOR_XRGB(191,191,191), 1.0f, 0 );

	

    // Begin the scene
   g_pd3dDevice->BeginScene();
g_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );

g_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, pwv, sizeof(pwv[0]));
g_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, pyv, sizeof(pyv[0]));
g_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, pcv, sizeof(pcv[0]));
g_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, pgv, sizeof(pgv[0]));
g_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, pmv, sizeof(pmv[0]));
g_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, prv, sizeof(prv[0]));
g_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, pbv, sizeof(pbv[0]));
g_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, pbkv, sizeof(pbkv[0]));


    // End the scene
    g_pd3dDevice->EndScene();

   

return;
}

VOID CXModuleTV::ReportD3DError(DWORD error)
{
	switch(error)
	{
		case D3D_OK:
			err_DIRECTX_API (error, L"D3D_OK - No error occurred");
			break;

		case D3DERR_CONFLICTINGRENDERSTATE:
			err_DIRECTX_API (error, L"D3DERR_CONFLICTINGRENDERSTATE - Currently set render states can't be used together");
			break;

		case D3DERR_CONFLICTINGTEXTUREFILTER:
			err_DIRECTX_API (error, L"D3DERR_CONFLICTINGTEXTUREFILTER - Current texture filters can't be used together");
			break;

		case D3DERR_CONFLICTINGTEXTUREPALETTE:
			err_DIRECTX_API (error, L"D3DERR_CONFLICTINGTEXTUREPALETTE - Current textures can't be used simultaneously");
			break;

		case D3DERR_DEVICELOST:
			err_DIRECTX_API (error, L"D3DERR_DEVICELOST - Device is lost and can't be restored, so rendering is not possible");
			break;

		case D3DERR_DEVICENOTRESET:
			err_DIRECTX_API (error, L"D3DERR_DEVICENOTRESET - Device cannot be reset");
			break;

		case D3DERR_DRIVERINTERNALERROR:
			err_DIRECTX_API (error, L"D3DERR_DRIVERINTERNALERROR - Internal driver error");
			break;

		case D3DERR_INVALIDCALL:
			err_DIRECTX_API (error, L"D3DERR_INVALIDCALL - The method call is invalid. For example, a method's parameter may have an invalid value");
			break;

		case D3DERR_INVALIDDEVICE:
			err_DIRECTX_API (error, L"D3DERR_INVALIDDEVICE - The requested device type is not valid");
			break;

		case D3DERR_MOREDATA:
			err_DIRECTX_API (error, L"D3DERR_MOREDATA - There is more data available than the specified buffer size can hold");
			break;

		case D3DERR_NOTAVAILABLE:
			err_DIRECTX_API (error, L"D3DERR_NOTAVAILABLE - This device does not support the queried technique");
			break;

		case D3DERR_NOTFOUND:
			err_DIRECTX_API (error, L"D3DERR_NOTFOUND - The requested item was not found");
			break;

		case D3DERR_OUTOFVIDEOMEMORY:
			err_DIRECTX_API (error, L"D3DERR_OUTOFVIDEOMEMORY - Direct3D does not have enough display memory to perform the operation");
			break;

		case D3DERR_TOOMANYOPERATIONS:
			err_DIRECTX_API (error, L"D3DERR_TOOMANYOPERATIONS - Application is requesting more texture-filtering operations than the device supports");
			break;

		case D3DERR_UNSUPPORTEDALPHAARG:
			err_DIRECTX_API (error, L"D3DERR_UNSUPPORTEDALPHAARG - Device does not support a specified texture-blending argument for the alpha channel");
			break;

		case D3DERR_UNSUPPORTEDALPHAOPERATION:
			err_DIRECTX_API (error, L"D3DERR_UNSUPPORTEDALPHAOPERATION - Device does not support a specified texture-blending operation for the alpha channel");
			break;

		case D3DERR_UNSUPPORTEDCOLORARG:
			err_DIRECTX_API (error, L"D3DERR_UNSUPPORTEDCOLORARG - Device does not support a specified texture-blending argument for color values");
			break;

		case D3DERR_UNSUPPORTEDCOLOROPERATION:
			err_DIRECTX_API (error, L"D3DERR_UNSUPPORTEDCOLOROPERATION - Device does not support a specified texture-blending operation for color values");
			break;

		case D3DERR_UNSUPPORTEDFACTORVALUE:
			err_DIRECTX_API (error, L"D3DERR_UNSUPPORTEDFACTORVALUE - Device does not support the specified texture factor value");
			break;

		case D3DERR_UNSUPPORTEDTEXTUREFILTER:
			err_DIRECTX_API (error, L"D3DERR_UNSUPPORTEDTEXTUREFILTER - Device does not support the specified texture filter");
			break;

		case D3DERR_WRONGTEXTUREFORMAT:
			err_DIRECTX_API (error, L"D3DERR_WRONGTEXTUREFORMAT - Pixel format of the texture surface is not valid");
			break;

		case E_FAIL:
			err_DIRECTX_API (error, L"E_FAIL - An undetermined error occurred inside the Direct3D subsystem");
			break;

		case E_INVALIDARG:
			err_DIRECTX_API (error, L"E_INVALIDARG - An invalid parameter was passed to the returning function");
			break;

//		case E_INVALIDCALL:
//			err_DIRECTX_API (error, L"E_INVALIDCALL - The method call is invalid. For example, a method's parameter may have an invalid value.");
//			break;

		case E_OUTOFMEMORY:
			err_DIRECTX_API (error, L"E_OUTOFMEMORY - Direct3D could not allocate sufficient memory to complete the call");
			break;
	}

}





BOOL CXModuleTV::DrawNTSCMB()
{

struct CUSTOMVERTEX{ FLOAT x, y, z, rhw; DWORD color; };
#define D3DFVF_CUSTOMVERTEX_MB (D3DFVF_XYZRHW|D3DFVF_DIFFUSE)

CUSTOMVERTEX* vtx;


	DWORD i,d, Col=NTSC_COL_MODE1, pos=0, min=0, max=255, vert = 0;
	double j,Pixel_Clock=NTSC_Pixel_Clock;
	vtx= new CUSTOMVERTEX [NTSC_COL_MODE1 * 2];

//unsigned char *data=new unsigned char [BUFSIZE/(sizeof(unsigned char))];
wchar_t *data=new wchar_t [BUFSIZE/(sizeof(wchar_t))];

 

   for (i=0; i<NumFreq; i++) {
      double count=0.0;
      for (j = NTSC_mulit[i].start_time;
           j < NTSC_mulit[i].end_time;                     
		   j = j+1.0/Pixel_Clock) {
	    data[pos++]= (wchar_t)((double)AMP*
	       sin((double)(NTSC_mulit[i].freq*2*3.1416*count))  
		   *NTSC_mulit[i].amp + (NTSC_mulit[i].offset)*AMP);
	       count+=1/(1000000*Pixel_Clock);
      }
      if (i<NumFreq-1) {
	     for (j = NTSC_mulit[i].end_time;
		     j < NTSC_mulit[i+1].start_time;                     
		     j = j+1.0/Pixel_Clock) {
	       data[pos++]=(wchar_t)(285.7*AMP);
	     }
      }

                         
   }



 for (d=0;d<Col; d++) {
     if (data[d]>max) max=data[d];
     if (data[d]<min) min=data[d];
   }


	for( d = 0; d < Col; d++)
    {
		if(d < Col)
		{	
			DWORD color;
			color = data[d];
			
			vtx[vert].x = (float)d;				vtx[vert].y = 0.0f;
			vtx[vert].z = 0.0f;				vtx[vert].rhw = 0.0f;
			vtx[vert].color =D3DCOLOR_XRGB(color,color,color);
			vert++;		
			vtx[vert].x =(float)d;					vtx[vert].y = 480;
			vtx[vert].z = 0.0f;				vtx[vert].rhw = 0.0f;
			vtx[vert].color = D3DCOLOR_XRGB(color,color,color);
    		vert++;
		
			
		}
    }

   // specify the FVF, so the vertex buffer knows what data it contains.
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( NTSC_COL_MODE1*2*sizeof(CUSTOMVERTEX),
                                                  D3DUSAGE_WRITEONLY,
												  D3DFVF_CUSTOMVERTEX_MB,
                                                  D3DPOOL_MANAGED, &m_pVB ) ) )
    {
		SAFE_DELETE_ARRAY(data);
		SAFE_DELETE_ARRAY(vtx);
		return FALSE;
    }
   
	CUSTOMVERTEX* pVertices;
    if( FAILED( m_pVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ) ) )
	{
		SAFE_DELETE_ARRAY(data);
		SAFE_DELETE_ARRAY(vtx);
        return FALSE;
	}

    memcpy( pVertices, vtx, NTSC_COL_MODE1*2*sizeof(CUSTOMVERTEX) );
    m_pVB->Unlock();
	SAFE_DELETE_ARRAY(data);
	SAFE_DELETE_ARRAY(vtx);

    return TRUE;
}



VOID CXModuleTV::NTSCMBRender()
{

g_pd3dDevice->Clear( 0, NULL,
						D3DCLEAR_TARGET|D3DCLEAR_TARGET_R|D3DCLEAR_TARGET_G|D3DCLEAR_TARGET_G|
						D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, D3DCOLOR_XRGB(0,0,0), 1.0f, 0 );
		
    // Begin the scene
    g_pd3dDevice->BeginScene();


    //Draw the lines for the pixel count
	g_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(CUSTOMVERTEX) );
    g_pd3dDevice->SetVertexShader( D3DFVF_CUSTOMVERTEX_MB );
    g_pd3dDevice->DrawPrimitive( D3DPT_LINELIST, 0, (NTSC_COL_MODE3*2));

	
	// End the scene
    g_pd3dDevice->EndScene();


	

}

BOOL CXModuleTV::DrawPalMB()
{

struct CUSTOMVERTEX{ FLOAT x, y, z, rhw; DWORD color; };
#define D3DFVF_CUSTOMVERTEX_MB (D3DFVF_XYZRHW|D3DFVF_DIFFUSE)
CUSTOMVERTEX* vtx;



	DWORD d,i, Col=PAL_COL, pos=0, min=0, max=255, vert = 0;
	double j,Pixel_Clock=PAL_Pixel_Clock;;
	vtx= new CUSTOMVERTEX [PAL_COL * 2];

//unsigned char *data=new unsigned char [BUFSIZE/(sizeof(unsigned char))];
wchar_t *data=new wchar_t [BUFSIZE/(sizeof(wchar_t))];

 

   for (i=0; i<NumFreq; i++) {
      double count=0.0;
      for (j = PAL_mulit[i].start_time;
           j < PAL_mulit[i].end_time;                     
		   j = j+1.0/Pixel_Clock) {
	    data[pos++]= (wchar_t)((double)AMP*
	       sin((double)(PAL_mulit[i].freq*2*3.1416*count))  
		   *PAL_mulit[i].amp + (PAL_mulit[i].offset)*AMP);
	       count+=1/(1000000*Pixel_Clock);
      }
      if (i<NumFreq-1) {
	     for (j = PAL_mulit[i].end_time;
		     j < PAL_mulit[i+1].start_time;                     
		     j = j+1.0/Pixel_Clock) {
	       data[pos++]=(wchar_t)(285.7*AMP);
	     }
      }

                         
   }

 for (d=0;d<Col; d++) {
     if (data[d]>max) max=data[d];
     if (data[d]<min) min=data[d];
   }


	for( d = 0; d < Col; d++)
    {
		if(d < Col)
		{	
			DWORD color;
			color = data[d];
			
			vtx[vert].x = (float)d;				vtx[vert].y = 0.0f;
			vtx[vert].z = 0.0f;				vtx[vert].rhw = 1.0f;
			vtx[vert].color =D3DCOLOR_XRGB(color,color,color);
			vert++;		
			vtx[vert].x =(float)d;					vtx[vert].y = 480;
			vtx[vert].z = 0.0f;				vtx[vert].rhw = 1.0f;
			vtx[vert].color = D3DCOLOR_XRGB(color,color,color);
    		vert++;
		
		}
    }


   // specify the FVF, so the vertex buffer knows what data it contains.
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( PAL_COL*2*sizeof(CUSTOMVERTEX),
                                                  D3DUSAGE_WRITEONLY,
												  D3DFVF_CUSTOMVERTEX_MB,
                                                  D3DPOOL_MANAGED, &m_pVB ) ) )
    {
		SAFE_DELETE_ARRAY(data);
		SAFE_DELETE_ARRAY(vtx);
		return FALSE;
    }

   
	CUSTOMVERTEX* pVertices;
    if( FAILED( m_pVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ) ) )
	{
		SAFE_DELETE_ARRAY(data);
		SAFE_DELETE_ARRAY(vtx);
        return FALSE;
	}

    memcpy( pVertices, vtx, PAL_COL*2*sizeof(CUSTOMVERTEX) );
    m_pVB->Unlock();
	SAFE_DELETE_ARRAY(data);
	SAFE_DELETE_ARRAY(vtx);
	
    return TRUE;
}

VOID CXModuleTV::PALMBRender()
{

g_pd3dDevice->Clear( 0, NULL,
						D3DCLEAR_TARGET|D3DCLEAR_TARGET_R|D3DCLEAR_TARGET_G|D3DCLEAR_TARGET_G|
						D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, D3DCOLOR_XRGB(0,0,0), 1.0f, 0 );
		
    // Begin the scene
    g_pd3dDevice->BeginScene();

    //Draw the lines for the pixel count
	g_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(CUSTOMVERTEX) );
    g_pd3dDevice->SetVertexShader( D3DFVF_CUSTOMVERTEX_MB );
    g_pd3dDevice->DrawPrimitive( D3DPT_LINELIST, 0, (PAL_COL_MODE3*2));
	
	// End the scene
    g_pd3dDevice->EndScene();

}



BOOL CXModuleTV::DrawMode3NTSCCB()
{
//720x480=Mode3
#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ| D3DFVF_NORMAL|D3DFVF_DIFFUSE)

	HRESULT hr;
    static LPDIRECT3DVERTEXBUFFER8 m_pVB  = NULL;

if((hr = g_pd3dDevice->CreateVertexBuffer( 17*4*sizeof(CUSTOMVERTEX),
                                                  D3DUSAGE_WRITEONLY, D3DFVF_CUSTOMVERTEX,
                                                  D3DPOOL_MANAGED, &m_pVB )) != D3D_OK)
	{
		ReportD3DError(hr);
		return FALSE;
	}

  //CUSTOMVERTEX* pwv;

if(FAILED(m_pVB->Lock(0,0,(BYTE**)&wv,0)))
return false;
wv[0].p = D3DXVECTOR4( 0, 0, 1.0f, 1.0f );     wv[0].color =0xffffffff;
wv[1].p = D3DXVECTOR4( 102.85f, 0, 1.0f, 1.0f );   wv[1].color =0xffffffff;
wv[2].p = D3DXVECTOR4( 0, 320.0f, 1.0f,1.0f  );   wv[2].color =0xffffffff;
wv[3].p = D3DXVECTOR4( 102.85f, 320.0f,	1.0f,1.0f ); wv[3].color =0xffffffff;
 //memcpy( pwv, wv, 4*sizeof(CUSTOMVERTEX) );

m_pVB->Unlock();

//Yellow
// CUSTOMVERTEX* pyv;
if(FAILED(m_pVB->Lock(0,0,(BYTE**)&yv,0)))
return false;

yv[0].p = D3DXVECTOR4( 102.85f, 0,	1.0f, 1.0f ); yv[0].color = 0xffffff00;
yv[1].p = D3DXVECTOR4( 205.71f, 0,	1.0f, 1.0f ); yv[1].color = 0xffffff00;
yv[2].p = D3DXVECTOR4( 102.85f, 320.0f,1.0f, 1.0f ); yv[2].color =0xffffff00;
yv[3].p = D3DXVECTOR4( 205.71f, 320.0f,1.0f, 1.0f ); yv[3].color =0xffffff00;

//memcpy( pyv, yv, 4*sizeof(CUSTOMVERTEX) );
m_pVB->Unlock();

//Cyan

//CUSTOMVERTEX* pcv;
if(FAILED(m_pVB->Lock(0,0,(BYTE**)&cv,0)))
return false;

cv[0].p = D3DXVECTOR4( 205.71f, 0,	1.0f, 1.0f ); cv[0].color =0xff00ffff;
cv[1].p = D3DXVECTOR4( 308.56f, 0,	1.0f, 1.0f ); cv[1].color = 0xff00ffff;
cv[2].p = D3DXVECTOR4( 205.71f, 320.0f,1.0f, 1.0f ); cv[3].color = 0xff00ffff;
cv[3].p = D3DXVECTOR4( 308.56f, 320.0f,1.0f, 1.0f ); cv[2].color =0xff00ffff;
 //memcpy( pcv, cv, 4*sizeof(CUSTOMVERTEX) );

m_pVB->Unlock();

//Green (blue)
//CUSTOMVERTEX* pgv;
if(FAILED(m_pVB->Lock(0,0,(BYTE**)&gv,0)))
return false;

gv[0].p = D3DXVECTOR4( 308.56f, 0,	1.0f, 1.0f ); gv[0].color = 0xff00ff00;
gv[1].p = D3DXVECTOR4( 411.41f, 0,	1.0f, 1.0f ); gv[1].color = 0xff00ff00;
gv[2].p = D3DXVECTOR4( 308.56f, 320.0f,1.0f, 1.0f ); gv[2].color =0xff00ff00;
gv[3].p = D3DXVECTOR4( 411.41f, 320.0f,1.0f, 1.0f ); gv[3].color = 0xff00ff00;
 //memcpy( pgv, gv, 4*sizeof(CUSTOMVERTEX) );

m_pVB->Unlock();

//Magenta
m_pVB->Lock(0,0,(BYTE**)&mv,0);
mv[0].p = D3DXVECTOR4( 411.41f, 0,	1.0f, 1.0f ); mv[0].color = 0xffff00ff;
mv[1].p = D3DXVECTOR4( 514.26f, 0,	1.0f, 1.0f ); mv[1].color = 0xffff00ff;
mv[2].p = D3DXVECTOR4( 411.41f, 320.0f,1.0f, 1.0f ); mv[2].color = 0xffff00ff;
mv[3].p = D3DXVECTOR4( 514.26f, 320.0f,1.0f, 1.0f ); mv[3].color =0xffff00ff; 
m_pVB->Unlock();

//Red (black)
m_pVB->Lock(0,0,(BYTE**)&rv,0);
rv[0].p = D3DXVECTOR4( 514.26f, 0,	1.0f, 1.0f ); rv[0].color = 0xffff0000;
rv[1].p = D3DXVECTOR4( 617.11f, 0,	1.0f, 1.0f ); rv[1].color = 0xffff0000;
rv[2].p = D3DXVECTOR4( 514.26f, 320.0f,1.0f, 1.0f ); rv[2].color =0xffff0000;
rv[3].p = D3DXVECTOR4( 617.11f, 320.0f,1.0f, 1.0f ); rv[3].color =0xffff0000;
m_pVB->Unlock();

//Blue
m_pVB->Lock(0,0,(BYTE**)&bv,0);
bv[0].p = D3DXVECTOR4( 617.11f, 0,	1.0f, 1.0f ); bv[0].color = 0xff0000ff;
bv[1].p = D3DXVECTOR4( 720.00f, 0,	1.0f, 1.0f ); bv[1].color =0xff0000ff;
bv[2].p = D3DXVECTOR4( 617.11f, 320.0f,1.0f, 1.0f ); bv[2].color =0xff0000ff;
bv[3].p = D3DXVECTOR4( 720.00f, 320.0f,1.0f, 1.0f ); bv[3].color =0xff0000ff;
m_pVB->Unlock();

//Small Blue bar
m_pVB->Lock(0,0,(BYTE**)&sbv,0);
sbv[0].p = D3DXVECTOR4( 0, 320.0f,	1.0f, 1.0f ); sbv[0].color = 0xff0000ff;
sbv[1].p = D3DXVECTOR4( 102.85f, 320.0f,	1.0f, 1.0f ); sbv[1].color = 0xff0000ff;
sbv[2].p = D3DXVECTOR4( 0, 360.0f,1.0f, 1.0f ); sbv[2].color = 0xff0000ff;
sbv[3].p = D3DXVECTOR4( 102.85f, 360.0f,1.0f, 1.0f ); sbv[3].color =0xff0000ff;
m_pVB->Unlock();

//small black bar
m_pVB->Lock(0,0,(BYTE**)&skv,0);
skv[0].p = D3DXVECTOR4( 102.85f, 320.0f,	1.0f, 1.0f ); skv[0].color = 0;
skv[1].p = D3DXVECTOR4( 205.70f, 320.0f,	1.0f, 1.0f ); skv[1].color = 0;
skv[2].p = D3DXVECTOR4( 102.85f, 360.0f,1.0f, 1.0f ); skv[2].color =0;
skv[3].p = D3DXVECTOR4( 205.70f, 360.0f,1.0f, 1.0f ); skv[3].color = 0;

m_pVB->Unlock();

//small Magenta bar
m_pVB->Lock(0,0,(BYTE**)&smv,0);

smv[0].p = D3DXVECTOR4( 205.71f, 320.0f,	1.0f, 1.0f ); smv[0].color =0xffff00ff; 
smv[1].p = D3DXVECTOR4( 308.56f, 320.0f,	1.0f, 1.0f ); smv[1].color = 0xffff00ff;
smv[2].p = D3DXVECTOR4( 205.71f, 360.0f,1.0f, 1.0f ); smv[2].color = 0xffff00ff;
smv[3].p = D3DXVECTOR4( 308.56f, 360.0f,1.0f, 1.0f ); smv[3].color =0xffff00ff;
m_pVB->Unlock();


// small black/green
m_pVB->Lock(0,0,(BYTE**)&skv1,0);
skv1[0].p = D3DXVECTOR4( 308.56f, 320.0f,	1.0f, 1.0f ); skv1[0].color = 0x00000000;
skv1[1].p = D3DXVECTOR4( 411.41f, 320.0f,	1.0f, 1.0f ); skv1[1].color = 0x00000000;
skv1[2].p = D3DXVECTOR4( 308.56f, 360.0f,1.0f, 1.0f ); skv1[2].color =0x00000000;
skv1[3].p = D3DXVECTOR4( 411.41f, 360.0f,1.0f, 1.0f ); skv1[3].color = 0x00000000;
m_pVB->Unlock();


// small cyan/Magenta
m_pVB->Lock(0,0,(BYTE**)&scv,0);
scv[0].p = D3DXVECTOR4( 411.41f, 320.0f,	1.0f, 1.0f ); scv[0].color =0xff00ffff; 
scv[1].p = D3DXVECTOR4( 514.26f, 320.0f,	1.0f, 1.0f ); scv[1].color =0xff00ffff; 
scv[2].p = D3DXVECTOR4( 411.41f, 360.0f,1.0f, 1.0f ); scv[2].color =0xff00ffff;
scv[3].p = D3DXVECTOR4( 514.26f, 360.0f,1.0f, 1.0f ); scv[3].color =0xff00ffff; 

m_pVB->Unlock();

//small black/red
m_pVB->Lock(0,0,(BYTE**)&skv2,0);
skv2[0].p = D3DXVECTOR4( 514.26f, 320.0f,	1.0f, 1.0f ); skv2[0].color = 0x00000000;
skv2[1].p = D3DXVECTOR4( 617.11f, 320.0f,	1.0f, 1.0f ); skv2[1].color = 0x00000000;
skv2[2].p = D3DXVECTOR4( 514.26f, 360.0f,1.0f, 1.0f ); skv2[2].color =0x00000000;
skv2[3].p = D3DXVECTOR4( 617.11f, 360.0f,1.0f, 1.0f ); skv2[3].color = 0x00000000;
m_pVB->Unlock();


//small white/blue
m_pVB->Lock(0,0,(BYTE**)&swv,0);
swv[0].p = D3DXVECTOR4( 617.11f, 320.0f, 1.0f, 1.0f );     swv[0].color = 0xffffffff;
swv[1].p = D3DXVECTOR4( 720.0f, 320.0f, 1.0f, 1.0f );   swv[1].color = 0xffffffff;
swv[2].p = D3DXVECTOR4( 617.11f, 360.0f, 1.0f,1.0f  );   swv[2].color = 0xffffffff;
swv[3].p = D3DXVECTOR4( 720.0f, 360.0f,	1.0f,1.0f ); swv[3].color = 0xffffffff;
m_pVB->Unlock();



//Bottom black bar
m_pVB->Lock(0,0,(BYTE**)&skvb,0);
skvb[0].p = D3DXVECTOR4(0, 360.0f,	1.0f, 1.0f ); skvb[0].color =0x00000000;
skvb[1].p = D3DXVECTOR4( 137.13f, 360.0f,	1.0f, 1.0f ); skvb[1].color =0x00000000; 
skvb[2].p = D3DXVECTOR4( 0, 480.0f,1.0f, 1.0f ); skvb[2].color =0x00000000;
skvb[3].p = D3DXVECTOR4( 137.13f, 480.0f,1.0f, 1.0f ); skvb[3].color =0x00000000; 
m_pVB->Unlock();

//Bottom white bar
m_pVB->Lock(0,0,(BYTE**)&swvb,0);
swvb[0].p = D3DXVECTOR4( 137.13f, 360.0f, 1.0f, 1.0f );     swvb[0].color = 0xffffffff;
swvb[1].p = D3DXVECTOR4( 257.13f, 360.0f, 1.0f, 1.0f );   swvb[1].color = 0xffffffff;
swvb[2].p = D3DXVECTOR4( 137.13f, 480.0f, 1.0f,1.0f  );   swvb[2].color = 0xffffffff;
swvb[3].p = D3DXVECTOR4( 257.13f, 480.0f,	1.0f,1.0f ); swvb[3].color = 0xffffffff;
m_pVB->Unlock();

//Bottom black bar2
m_pVB->Lock(0,0,(BYTE**)&skvb2,0);
skvb2[0].p = D3DXVECTOR4(257.13f, 360.0f,	1.0f, 1.0f ); skvb2[0].color =0x00000000;
skvb2[1].p = D3DXVECTOR4( 720.0f, 360.0f,	1.0f, 1.0f ); skvb2[1].color =0x00000000; 
skvb2[2].p = D3DXVECTOR4( 257.13f, 480.0f,1.0f, 1.0f ); skvb2[2].color =0x00000000;
skvb2[3].p = D3DXVECTOR4( 720.0f, 480.0f,1.0f, 1.0f ); skvb2[3].color =0x00000000; 
m_pVB->Unlock();



return true;

}



BOOL CXModuleTV::DrawMode3PALCB()
{

	HRESULT hr;
static LPDIRECT3DVERTEXBUFFER8 m_pVB  = NULL;


if((hr = g_pd3dDevice->CreateVertexBuffer( 17*4*sizeof(CUSTOMVERTEX),
                                                  D3DUSAGE_WRITEONLY, D3DFVF_CUSTOMVERTEX,
                                                  D3DPOOL_MANAGED, &m_pVB )) != D3D_OK)
	{
		ReportD3DError(hr);
		return FALSE;
	}


//PAL TV Standard for 720x480 video mode3
//White

m_pVB->Lock(0,0,(BYTE**)&pwv,0);
pwv[0].p = D3DXVECTOR4( 0, 0, 1.0f, 1.0f );     pwv[0].color = 0xffffffff;
pwv[1].p = D3DXVECTOR4( 90.00f, 0, 1.0f, 1.0f );   pwv[1].color = 0xffffffff;
pwv[2].p = D3DXVECTOR4( 0, 480.0f, 1.0f,1.0f  );   pwv[2].color = 0xffffffff;
pwv[3].p = D3DXVECTOR4( 90.00f, 480.0f,	1.0f,1.0f ); pwv[3].color = 0xffffffff;
m_pVB->Unlock();

//Yellow
m_pVB->Lock(0,0,(BYTE**)&pyv,0);
pyv[0].p = D3DXVECTOR4( 90.00f, 0,	1.0f, 1.0f ); pyv[0].color = 0xffffff00;
pyv[1].p = D3DXVECTOR4( 180.00f, 0,	1.0f, 1.0f ); pyv[1].color = 0xffffff00;
pyv[2].p = D3DXVECTOR4( 90.00f, 480.0f,1.0f, 1.0f ); pyv[2].color = 0xffffff00;
pyv[3].p = D3DXVECTOR4( 180.00f, 480.0f,1.0f, 1.0f ); pyv[3].color = 0xffffff00;
m_pVB->Unlock();

//Cyan
m_pVB->Lock(0,0,(BYTE**)&pcv,0);
pcv[0].p = D3DXVECTOR4( 180.00f, 0,	1.0f, 1.0f ); pcv[0].color = 0xff00ffff;
pcv[1].p = D3DXVECTOR4( 270.00f, 0,	1.0f, 1.0f ); pcv[1].color = 0xff00ffff;
pcv[2].p = D3DXVECTOR4( 180.00f, 480.0f,1.0f, 1.0f ); pcv[3].color = 0xff00ffff;
pcv[3].p = D3DXVECTOR4( 270.00f, 480.0f,1.0f, 1.0f ); pcv[2].color = 0xff00ffff;
m_pVB->Unlock();

//Green
m_pVB->Lock(0,0,(BYTE**)&pgv,0);
pgv[0].p = D3DXVECTOR4( 270.00f, 0,	1.0f, 1.0f ); pgv[0].color = 0xff00ff00;
pgv[1].p = D3DXVECTOR4( 360.00f, 0,	1.0f, 1.0f ); pgv[1].color = 0xff00ff00;
pgv[2].p = D3DXVECTOR4( 270.00f, 480.0f,1.0f, 1.0f ); pgv[2].color = 0xff00ff00;
pgv[3].p = D3DXVECTOR4( 360.00f, 480.0f,1.0f, 1.0f ); pgv[3].color = 0xff00ff00;
m_pVB->Unlock();

//Magenta
m_pVB->Lock(0,0,(BYTE**)&pmv,0);
pmv[0].p = D3DXVECTOR4( 360.00f, 0,	1.0f, 1.0f ); pmv[0].color = 0xffff00ff;
pmv[1].p = D3DXVECTOR4( 450.00f, 0,	1.0f, 1.0f ); pmv[1].color = 0xffff00ff;
pmv[2].p = D3DXVECTOR4( 360.00f, 480.0f,1.0f, 1.0f ); pmv[2].color = 0xffff00ff;
pmv[3].p = D3DXVECTOR4( 450.00f, 480.0f,1.0f, 1.0f ); pmv[3].color =0xffff00ff; 
m_pVB->Unlock();

//Red
m_pVB->Lock(0,0,(BYTE**)&prv,0);
prv[0].p = D3DXVECTOR4( 450.00f, 0,	1.0f, 1.0f ); prv[0].color = 0xffff0000;
prv[1].p = D3DXVECTOR4( 540.00f, 0,	1.0f, 1.0f ); prv[1].color = 0xffff0000;
prv[2].p = D3DXVECTOR4( 450.00f, 480.0f,1.0f, 1.0f ); prv[2].color =0xffff0000;
prv[3].p = D3DXVECTOR4( 540.00f, 480.0f,1.0f, 1.0f ); prv[3].color = 0xffff0000;
m_pVB->Unlock();

//Blue
m_pVB->Lock(0,0,(BYTE**)&pbv,0);
pbv[0].p = D3DXVECTOR4( 540.00f, 0,	1.0f, 1.0f ); pbv[0].color = 0xff0000ff;
pbv[1].p = D3DXVECTOR4( 630.00f, 0,	1.0f, 1.0f ); pbv[1].color = 0xff0000ff;
pbv[2].p = D3DXVECTOR4( 540.00f, 480.0f,1.0f, 1.0f ); pbv[2].color = 0xff0000ff;
pbv[3].p = D3DXVECTOR4( 630.00f, 480.0f,1.0f, 1.0f ); pbv[3].color =0xff0000ff;
m_pVB->Unlock();
//black
m_pVB->Lock(0,0,(BYTE**)&pbkv,0);
pbkv[0].p = D3DXVECTOR4( 630.00f, 0,	1.0f, 1.0f ); pbkv[0].color = 0x00000000;
pbkv[1].p = D3DXVECTOR4( 720.00f, 0,	1.0f, 1.0f ); pbkv[1].color = 0x00000000;
pbkv[2].p = D3DXVECTOR4( 630.00f, 480.0f,1.0f, 1.0f ); pbkv[2].color = 0x00000000;
pbkv[3].p = D3DXVECTOR4( 720.00f, 480.0f,1.0f, 1.0f ); pbkv[3].color =0x00000000;
m_pVB->Unlock();



	return true;

}



BOOL CXModuleTV::DrawMode4PALCB()
{

HRESULT hr;
static LPDIRECT3DVERTEXBUFFER8 m_pVB  = NULL;


if((hr = g_pd3dDevice->CreateVertexBuffer( 17*4*sizeof(CUSTOMVERTEX),
                                                  D3DUSAGE_WRITEONLY, D3DFVF_CUSTOMVERTEX,
                                                  D3DPOOL_MANAGED, &m_pVB )) != D3D_OK)
	{
		ReportD3DError(hr);
		return FALSE;
	}

//PAL TV Standard for 640x576 video mode4
//White

m_pVB->Lock(0,0,(BYTE**)&pwv,0);
pwv[0].p = D3DXVECTOR4( 0, 0, 1.0f, 1.0f );     pwv[0].color = 0xffffffff;
pwv[1].p = D3DXVECTOR4( 80.0f, 0, 1.0f, 1.0f );   pwv[1].color = 0xffffffff;
pwv[2].p = D3DXVECTOR4( 0, 576.0f, 1.0f,1.0f  );   pwv[2].color = 0xffffffff;
pwv[3].p = D3DXVECTOR4( 80.0f, 576.0f,	1.0f,1.0f ); pwv[3].color = 0xffffffff;
m_pVB->Unlock();

//Yellow
m_pVB->Lock(0,0,(BYTE**)&pyv,0);
pyv[0].p = D3DXVECTOR4( 80.0f, 0,	1.0f, 1.0f ); pyv[0].color = 0xffffff00;
pyv[1].p = D3DXVECTOR4( 160.0f, 0,	1.0f, 1.0f ); pyv[1].color = 0xffffff00;
pyv[2].p = D3DXVECTOR4( 80.0f, 576.0f,1.0f, 1.0f ); pyv[2].color = 0xffffff00;
pyv[3].p = D3DXVECTOR4( 160.0f, 576.0f,1.0f, 1.0f ); pyv[3].color = 0xffffff00;
m_pVB->Unlock();

//Cyan
m_pVB->Lock(0,0,(BYTE**)&pcv,0);
pcv[0].p = D3DXVECTOR4( 160.0f, 0,	1.0f, 1.0f ); pcv[0].color = 0xff00ffff;
pcv[1].p = D3DXVECTOR4( 240.0f, 0,	1.0f, 1.0f ); pcv[1].color = 0xff00ffff;
pcv[2].p = D3DXVECTOR4( 160.0f, 576.0f,1.0f, 1.0f ); pcv[3].color = 0xff00ffff;
pcv[3].p = D3DXVECTOR4( 240.0f, 576.0f,1.0f, 1.0f ); pcv[2].color = 0xff00ffff;
m_pVB->Unlock();

//Green
m_pVB->Lock(0,0,(BYTE**)&pgv,0);
pgv[0].p = D3DXVECTOR4( 240.0f, 0,	1.0f, 1.0f ); pgv[0].color = 0xff00ff00;
pgv[1].p = D3DXVECTOR4( 320.0f, 0,	1.0f, 1.0f ); pgv[1].color = 0xff00ff00;
pgv[2].p = D3DXVECTOR4( 240.0f, 576.0f,1.0f, 1.0f ); pgv[2].color = 0xff00ff00;
pgv[3].p = D3DXVECTOR4( 320.0f, 576.0f,1.0f, 1.0f ); pgv[3].color = 0xff00ff00;
m_pVB->Unlock();

//Magenta
m_pVB->Lock(0,0,(BYTE**)&pmv,0);
pmv[0].p = D3DXVECTOR4( 320.0f, 0,	1.0f, 1.0f ); pmv[0].color = 0xffff00ff;
pmv[1].p = D3DXVECTOR4( 400.0f, 0,	1.0f, 1.0f ); pmv[1].color = 0xffff00ff;
pmv[2].p = D3DXVECTOR4( 320.0f, 576.0f,1.0f, 1.0f ); pmv[2].color = 0xffff00ff;
pmv[3].p = D3DXVECTOR4( 400.0f, 576.0f,1.0f, 1.0f ); pmv[3].color =0xffff00ff; 
m_pVB->Unlock();

//Red
m_pVB->Lock(0,0,(BYTE**)&prv,0);
prv[0].p = D3DXVECTOR4( 400.0f, 0,	1.0f, 1.0f ); prv[0].color = 0xffff0000;
prv[1].p = D3DXVECTOR4( 480.0f, 0,	1.0f, 1.0f ); prv[1].color = 0xffff0000;
prv[2].p = D3DXVECTOR4( 400.0f, 576.0f,1.0f, 1.0f ); prv[2].color =0xffff0000;
prv[3].p = D3DXVECTOR4( 480.0f, 576.0f,1.0f, 1.0f ); prv[3].color = 0xffff0000;
m_pVB->Unlock();

//Blue
m_pVB->Lock(0,0,(BYTE**)&pbv,0);
pbv[0].p = D3DXVECTOR4( 480.0f, 0,	1.0f, 1.0f ); pbv[0].color = 0xff0000ff;
pbv[1].p = D3DXVECTOR4( 560.0f, 0,	1.0f, 1.0f ); pbv[1].color = 0xff0000ff;
pbv[2].p = D3DXVECTOR4( 480.0f, 576.0f,1.0f, 1.0f ); pbv[2].color = 0xff0000ff;
pbv[3].p = D3DXVECTOR4( 560.0f, 576.0f,1.0f, 1.0f ); pbv[3].color =0xff0000ff;
m_pVB->Unlock();
//black
m_pVB->Lock(0,0,(BYTE**)&pbkv,0);
pbkv[0].p = D3DXVECTOR4( 560.0f, 0,	1.0f, 1.0f ); pbkv[0].color = 0x00000000;
pbkv[1].p = D3DXVECTOR4( 640.0f, 0,	1.0f, 1.0f ); pbkv[1].color = 0x00000000;
pbkv[2].p = D3DXVECTOR4( 560.0f, 576.0f,1.0f, 1.0f ); pbkv[2].color = 0x00000000;
pbkv[3].p = D3DXVECTOR4( 640.0f, 576.0f,1.0f, 1.0f ); pbkv[3].color =0x00000000;
m_pVB->Unlock();




return true;
}



BOOL CXModuleTV::DrawMode6PALCB()
{
	HRESULT hr;
static LPDIRECT3DVERTEXBUFFER8 m_pVB  = NULL;


if((hr = g_pd3dDevice->CreateVertexBuffer( 17*4*sizeof(CUSTOMVERTEX),
                                                  D3DUSAGE_WRITEONLY, D3DFVF_CUSTOMVERTEX,
                                                  D3DPOOL_MANAGED, &m_pVB )) != D3D_OK)
	{
		ReportD3DError(hr);
		return FALSE;
	}

//PAL TV Standard for 720x576 video mode6
//White

m_pVB->Lock(0,0,(BYTE**)&pwv,0);
pwv[0].p = D3DXVECTOR4( 0, 0, 1.0f, 1.0f );     pwv[0].color = 0xffffffff;
pwv[1].p = D3DXVECTOR4( 90.00f, 0, 1.0f, 1.0f );   pwv[1].color = 0xffffffff;
pwv[2].p = D3DXVECTOR4( 0, 576.0f, 1.0f,1.0f  );   pwv[2].color = 0xffffffff;
pwv[3].p = D3DXVECTOR4( 90.00f, 576.0f,	1.0f,1.0f ); pwv[3].color = 0xffffffff;
m_pVB->Unlock();

//Yellow
m_pVB->Lock(0,0,(BYTE**)&pyv,0);
pyv[0].p = D3DXVECTOR4( 90.00f, 0,	1.0f, 1.0f ); pyv[0].color = 0xffffff00;
pyv[1].p = D3DXVECTOR4( 180.00f, 0,	1.0f, 1.0f ); pyv[1].color = 0xffffff00;
pyv[2].p = D3DXVECTOR4( 90.00f, 576.0f,1.0f, 1.0f ); pyv[2].color = 0xffffff00;
pyv[3].p = D3DXVECTOR4( 180.00f, 576.0f,1.0f, 1.0f ); pyv[3].color = 0xffffff00;
m_pVB->Unlock();

//Cyan
m_pVB->Lock(0,0,(BYTE**)&pcv,0);
pcv[0].p = D3DXVECTOR4( 180.00f, 0,	1.0f, 1.0f ); pcv[0].color = 0xff00ffff;
pcv[1].p = D3DXVECTOR4( 270.00f, 0,	1.0f, 1.0f ); pcv[1].color = 0xff00ffff;
pcv[2].p = D3DXVECTOR4( 180.00f, 576.0f,1.0f, 1.0f ); pcv[3].color = 0xff00ffff;
pcv[3].p = D3DXVECTOR4( 270.00f, 576.0f,1.0f, 1.0f ); pcv[2].color = 0xff00ffff;
m_pVB->Unlock();

//Green
m_pVB->Lock(0,0,(BYTE**)&pgv,0);
pgv[0].p = D3DXVECTOR4( 270.00f, 0,	1.0f, 1.0f ); pgv[0].color = 0xff00ff00;
pgv[1].p = D3DXVECTOR4( 360.00f, 0,	1.0f, 1.0f ); pgv[1].color = 0xff00ff00;
pgv[2].p = D3DXVECTOR4( 270.00f, 576.0f,1.0f, 1.0f ); pgv[2].color = 0xff00ff00;
pgv[3].p = D3DXVECTOR4( 360.00f, 576.0f,1.0f, 1.0f ); pgv[3].color = 0xff00ff00;
m_pVB->Unlock();

//Magenta
m_pVB->Lock(0,0,(BYTE**)&pmv,0);
pmv[0].p = D3DXVECTOR4( 360.00f, 0,	1.0f, 1.0f ); pmv[0].color = 0xffff00ff;
pmv[1].p = D3DXVECTOR4( 450.00f, 0,	1.0f, 1.0f ); pmv[1].color = 0xffff00ff;
pmv[2].p = D3DXVECTOR4( 360.00f, 576.0f,1.0f, 1.0f ); pmv[2].color = 0xffff00ff;
pmv[3].p = D3DXVECTOR4( 450.00f, 576.0f,1.0f, 1.0f ); pmv[3].color =0xffff00ff; 
m_pVB->Unlock();

//Red
m_pVB->Lock(0,0,(BYTE**)&prv,0);
prv[0].p = D3DXVECTOR4( 450.00f, 0,	1.0f, 1.0f ); prv[0].color = 0xffff0000;
prv[1].p = D3DXVECTOR4( 540.00f, 0,	1.0f, 1.0f ); prv[1].color = 0xffff0000;
prv[2].p = D3DXVECTOR4( 450.00f, 576.0f,1.0f, 1.0f ); prv[2].color =0xffff0000;
prv[3].p = D3DXVECTOR4( 540.00f, 576.0f,1.0f, 1.0f ); prv[3].color = 0xffff0000;
m_pVB->Unlock();

//Blue
m_pVB->Lock(0,0,(BYTE**)&pbv,0);
pbv[0].p = D3DXVECTOR4( 540.00f, 0,	1.0f, 1.0f ); pbv[0].color = 0xff0000ff;
pbv[1].p = D3DXVECTOR4( 630.00f, 0,	1.0f, 1.0f ); pbv[1].color = 0xff0000ff;
pbv[2].p = D3DXVECTOR4( 540.00f, 576.0f,1.0f, 1.0f ); pbv[2].color = 0xff0000ff;
pbv[3].p = D3DXVECTOR4( 630.00f, 576.0f,1.0f, 1.0f ); pbv[3].color =0xff0000ff;
m_pVB->Unlock();
//black
m_pVB->Lock(0,0,(BYTE**)&pbkv,0);
pbkv[0].p = D3DXVECTOR4( 630.00f, 0,	1.0f, 1.0f ); pbkv[0].color = 0x00000000;
pbkv[1].p = D3DXVECTOR4( 720.00f, 0,	1.0f, 1.0f ); pbkv[1].color = 0x00000000;
pbkv[2].p = D3DXVECTOR4( 630.00f, 576.0f,1.0f, 1.0f ); pbkv[2].color = 0x00000000;
pbkv[3].p = D3DXVECTOR4( 720.00f, 576.0f,1.0f, 1.0f ); pbkv[3].color =0x00000000;
m_pVB->Unlock();


	return true;

}

BOOL CXModuleTV::DrawMode3NTSCMB()
{

struct CUSTOMVERTEX{ FLOAT x, y, z, rhw; DWORD color; };
#define D3DFVF_CUSTOMVERTEX_MB (D3DFVF_XYZRHW|D3DFVF_DIFFUSE)

CUSTOMVERTEX* vtx;

//NTSC_COL_MODE3
	DWORD i,d, Col=720, pos=0, min=0, max=255, vert = 0;
	double j,Pixel_Clock=NTSC_Pixel_Clock;
	vtx= new CUSTOMVERTEX [NTSC_COL_MODE3 * 2];

//unsigned char *data=new unsigned char [BUFSIZE/(sizeof(unsigned char))];
wchar_t *data=new wchar_t [BUFSIZE/(sizeof(wchar_t))];

 

   for (i=0; i<NumFreq; i++) {
      double count=0.0;
      for (j = NTSCMode3_mulit[i].start_time;
           j < NTSCMode3_mulit[i].end_time;                     
		   j = j+1.0/Pixel_Clock) {
	    data[pos++]= (wchar_t)((double)AMP*
	       sin((double)(NTSCMode3_mulit[i].freq*2*3.1416*count))  
		   *NTSCMode3_mulit[i].amp + (NTSCMode3_mulit[i].offset)*AMP);
	       count+=1/(1000000*Pixel_Clock);
      }
      if (i<NumFreq-1) {
	     for (j = NTSCMode3_mulit[i].end_time;
		     j < NTSCMode3_mulit[i+1].start_time;                     
		     j = j+1.0/Pixel_Clock) {
	       data[pos++]=(wchar_t)(285.7*AMP);
	     }
      }

                         
   }



 for (d=0;d<Col; d++) {
     if (data[d]>max) max=data[d];
     if (data[d]<min) min=data[d];
   }


	for( d = 0; d < Col; d++)
    {
		if(d < Col)
		{	
			DWORD color;
			color = data[d];
			
			vtx[vert].x = (float)d;				vtx[vert].y = 0.0f;
			vtx[vert].z = 0.0f;				vtx[vert].rhw = 0.0f;
			vtx[vert].color =D3DCOLOR_XRGB(color,color,color);
			vert++;		
			vtx[vert].x =(float)d;					vtx[vert].y = 480;
			vtx[vert].z = 0.0f;				vtx[vert].rhw = 0.0f;
			vtx[vert].color = D3DCOLOR_XRGB(color,color,color);
    		vert++;
		
			
		}
    }


   // specify the FVF, so the vertex buffer knows what data it contains.
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( NTSC_COL_MODE3*2*sizeof(CUSTOMVERTEX),
                                                  D3DUSAGE_WRITEONLY,
												  D3DFVF_CUSTOMVERTEX_MB,
                                                  D3DPOOL_MANAGED, &m_pVB ) ) )
    {
		SAFE_DELETE_ARRAY(data);
		SAFE_DELETE_ARRAY(vtx);
		return FALSE;
    }

   
	CUSTOMVERTEX* pVertices;
    if( FAILED( m_pVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ) ) )
	{
		SAFE_DELETE_ARRAY(data);
		SAFE_DELETE_ARRAY(vtx);
        return FALSE;
	}

    memcpy( pVertices, vtx, NTSC_COL_MODE3*2*sizeof(CUSTOMVERTEX) );
    m_pVB->Unlock();
	SAFE_DELETE_ARRAY(data);
	SAFE_DELETE_ARRAY(vtx);
	
    return TRUE;
}

BOOL CXModuleTV::DrawMode3PALMB()
{

struct CUSTOMVERTEX{ FLOAT x, y, z, rhw; DWORD color; };
#define D3DFVF_CUSTOMVERTEX_MB (D3DFVF_XYZRHW|D3DFVF_DIFFUSE)
CUSTOMVERTEX* vtx;



	DWORD d,i, Col=PAL_COL_MODE3, pos=0, min=0, max=255, vert = 0;
	double j,Pixel_Clock=PAL_Pixel_Clock;;
	vtx= new CUSTOMVERTEX [PAL_COL_MODE3 * 2];

//unsigned char *data=new unsigned char [BUFSIZE/(sizeof(unsigned char))];
wchar_t *data=new wchar_t [BUFSIZE/(sizeof(wchar_t))];
   for (i=0; i<NumFreq; i++) {
      double count=0.0;
      for (j = PALMode3_mulit[i].start_time;
           j < PALMode3_mulit[i].end_time;                     
		   j = j+1.0/Pixel_Clock) {
	    data[pos++]= (wchar_t)((double)AMP*
	       sin((double)(PALMode3_mulit[i].freq*2*3.1416*count))  
		   *PALMode3_mulit[i].amp + (PALMode3_mulit[i].offset)*AMP);
	       count+=1/(1000000*Pixel_Clock);
      }
      if (i<NumFreq-1) {
	     for (j = PALMode3_mulit[i].end_time;
		     j < PALMode3_mulit[i+1].start_time;                     
		     j = j+1.0/Pixel_Clock) {
	       data[pos++]=(wchar_t)(285.7*AMP);
	     }
      }

                         
   }

 for (d=0;d<Col; d++) {
     if (data[d]>max) max=data[d];
     if (data[d]<min) min=data[d];
   }


	for( d = 0; d < Col; d++)
    {
		if(d < Col)
		{	
			DWORD color;
			color = data[d];
			
			vtx[vert].x = (float)d;				vtx[vert].y = 0.0f;
			vtx[vert].z = 0.0f;				vtx[vert].rhw = 1.0f;
			vtx[vert].color =D3DCOLOR_XRGB(color,color,color);
			vert++;		
			vtx[vert].x =(float)d;					vtx[vert].y = 480;
			vtx[vert].z = 0.0f;				vtx[vert].rhw = 1.0f;
			vtx[vert].color = D3DCOLOR_XRGB(color,color,color);
    		vert++;
		
		}
    }


   // specify the FVF, so the vertex buffer knows what data it contains.
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( PAL_COL_MODE3*2*sizeof(CUSTOMVERTEX),
                                                  D3DUSAGE_WRITEONLY,
												  D3DFVF_CUSTOMVERTEX_MB,
                                                  D3DPOOL_MANAGED, &m_pVB ) ) )
    {
		SAFE_DELETE_ARRAY(data);
		SAFE_DELETE_ARRAY(vtx);
		return FALSE;
    }

   
	CUSTOMVERTEX* pVertices;
    if( FAILED( m_pVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ) ) )
	{
		SAFE_DELETE_ARRAY(data);
		SAFE_DELETE_ARRAY(vtx);
        return FALSE;
	}

    memcpy( pVertices, vtx, PAL_COL_MODE3*2*sizeof(CUSTOMVERTEX) );
    m_pVB->Unlock();
	SAFE_DELETE_ARRAY(data);
	SAFE_DELETE_ARRAY(vtx);

    return true;
}

BOOL CXModuleTV::DrawMode4PALMB()
{

struct CUSTOMVERTEX{ FLOAT x, y, z, rhw; DWORD color; };
#define D3DFVF_CUSTOMVERTEX_MB (D3DFVF_XYZRHW|D3DFVF_DIFFUSE)
CUSTOMVERTEX* vtx;

	DWORD d,i, Col=PAL_COL_MODE4, pos=0, min=0, max=255, vert = 0;
	double j,Pixel_Clock=PAL_Pixel_Clock;;
	vtx= new CUSTOMVERTEX [PAL_COL_MODE4* 2];

//unsigned char *data=new unsigned char [BUFSIZE/(sizeof(unsigned char))];
wchar_t *data=new wchar_t [BUFSIZE/(sizeof(wchar_t))];

   for (i=0; i<NumFreq; i++) {
      double count=0.0;
      for (j = PAL_mulit[i].start_time;
           j < PAL_mulit[i].end_time;                     
		   j = j+1.0/Pixel_Clock) {
	    data[pos++]= (wchar_t)((double)AMP*
	       sin((double)(PAL_mulit[i].freq*2*3.1416*count))  
		   *PAL_mulit[i].amp + (PAL_mulit[i].offset)*AMP);
	       count+=1/(1000000*Pixel_Clock);
      }
      if (i<NumFreq-1) {
	     for (j = PAL_mulit[i].end_time;
		     j < PAL_mulit[i+1].start_time;                     
		     j = j+1.0/Pixel_Clock) {
	       data[pos++]=(wchar_t)(285.7*AMP);
	     }
      }

                         
   }

 for (d=0;d<Col; d++) {
     if (data[d]>max) max=data[d];
     if (data[d]<min) min=data[d];
   }


	for( d = 0; d < Col; d++)
    {
		if(d < Col)
		{	
			DWORD color;
			color = data[d];
			
			vtx[vert].x = (float)d;				vtx[vert].y = 0.0f;
			vtx[vert].z = 0.0f;				vtx[vert].rhw = 1.0f;
			vtx[vert].color =D3DCOLOR_XRGB(color,color,color);
			vert++;		
			vtx[vert].x =(float)d;					vtx[vert].y = 576;
			vtx[vert].z = 0.0f;				vtx[vert].rhw = 1.0f;
			vtx[vert].color = D3DCOLOR_XRGB(color,color,color);
    		vert++;
		
		}
    }


   // specify the FVF, so the vertex buffer knows what data it contains.
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( PAL_COL_MODE4*2*sizeof(CUSTOMVERTEX),
                                                  D3DUSAGE_WRITEONLY,
												  D3DFVF_CUSTOMVERTEX_MB,
                                                  D3DPOOL_MANAGED, &m_pVB ) ) )
    {
		SAFE_DELETE_ARRAY(data);
		SAFE_DELETE_ARRAY(vtx);
		return FALSE;
    }

   
	CUSTOMVERTEX* pVertices;
    if( FAILED( m_pVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ) ) )
	{
		SAFE_DELETE_ARRAY(data);
		SAFE_DELETE_ARRAY(vtx);
        return FALSE;
	}

    memcpy( pVertices, vtx, PAL_COL_MODE4*2*sizeof(CUSTOMVERTEX) );
    m_pVB->Unlock();
	SAFE_DELETE_ARRAY(data);
	SAFE_DELETE_ARRAY(vtx);
	
    return true;
}

BOOL CXModuleTV::DrawMode6PALMB()
{

struct CUSTOMVERTEX{ FLOAT x, y, z, rhw; DWORD color; };
#define D3DFVF_CUSTOMVERTEX_MB (D3DFVF_XYZRHW|D3DFVF_DIFFUSE)
CUSTOMVERTEX* vtx;



	DWORD d,i, Col=PAL_COL_MODE6, pos=0, min=0, max=255, vert = 0;
	double j,Pixel_Clock=PAL_Pixel_Clock;;
	vtx= new CUSTOMVERTEX [PAL_COL_MODE6 * 2];

//unsigned char *data=new unsigned char [BUFSIZE/(sizeof(unsigned char))];
wchar_t *data=new wchar_t [BUFSIZE/(sizeof(wchar_t))];

   for (i=0; i<NumFreq; i++) {
      double count=0.0;
      for (j = PALMode6_mulit[i].start_time;
           j < PALMode6_mulit[i].end_time;                     
		   j = j+1.0/Pixel_Clock) {
	    data[pos++]= (wchar_t)((double)AMP*
	       sin((double)(PALMode6_mulit[i].freq*2*3.1416*count))  
		   *PALMode6_mulit[i].amp + (PALMode6_mulit[i].offset)*AMP);
	       count+=1/(1000000*Pixel_Clock);
      }
      if (i<NumFreq-1) {
	     for (j = PALMode6_mulit[i].end_time;
		     j < PALMode6_mulit[i+1].start_time;                     
		     j = j+1.0/Pixel_Clock) {
	       data[pos++]=(wchar_t)(285.7*AMP);
	     }
      }

                         
   }

 for (d=0;d<Col; d++) {
     if (data[d]>max) max=data[d];
     if (data[d]<min) min=data[d];
   }


	for( d = 0; d < Col; d++)
    {
		if(d < Col)
		{	
			DWORD color;
			color = data[d];
			
			vtx[vert].x = (float)d;				vtx[vert].y = 0.0f;
			vtx[vert].z = 0.0f;				vtx[vert].rhw = 1.0f;
			vtx[vert].color =D3DCOLOR_XRGB(color,color,color);
			vert++;		
			vtx[vert].x =(float)d;					vtx[vert].y = 576;
			vtx[vert].z = 0.0f;				vtx[vert].rhw = 1.0f;
			vtx[vert].color = D3DCOLOR_XRGB(color,color,color);
    		vert++;
		
		}
    }


   // specify the FVF, so the vertex buffer knows what data it contains.
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( PAL_COL_MODE6*2*sizeof(CUSTOMVERTEX),
                                                  D3DUSAGE_WRITEONLY,
												  D3DFVF_CUSTOMVERTEX_MB,
                                                  D3DPOOL_MANAGED, &m_pVB ) ) )
    {
		SAFE_DELETE_ARRAY(data);
		SAFE_DELETE_ARRAY(vtx);
		return FALSE;
    }

   
	CUSTOMVERTEX* pVertices;
    if( FAILED( m_pVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ) ) )
	{
		SAFE_DELETE_ARRAY(data);
		SAFE_DELETE_ARRAY(vtx);
        return FALSE;
	}

    memcpy( pVertices, vtx, PAL_COL_MODE6*2*sizeof(CUSTOMVERTEX) );
    m_pVB->Unlock();
	SAFE_DELETE_ARRAY(data);
	SAFE_DELETE_ARRAY(vtx);

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xtv\XTV.h ===
// XTV.h: interface for the CXModuleTV class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XTV_H__68FC7951_E13F_4E1F_925A_2F29AE3E15A0__INCLUDED_)
#define AFX_XTV_H__68FC7951_E13F_4E1F_925A_2F29AE3E15A0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <xgraphics.h>
#include "..\testobj.h"

#define XTV_TIMEOUT	180
#define NUMBER_OF_COLOR_BARS 8
#define NUMBER_OF_FREQ	6
#define MAX_ELEM	16
#define NumFreq 8
#define AMP             255.0/(714.5-53.6)
#define NTSC_COL_MODE1    640
#define NTSC_ROW_MODE1    480
#define NTSC_COL_MODE3    720
#define NTSC_ROW_MODE3    480
#define PAL_COL     640   
#define PAL_ROW	    480
#define PAL_COL_MODE3	  720
#define PAL_ROW_MODE3     480
#define PAL_COL_MODE4	640
#define PAL_ROW_MODE4	576
#define PAL_COL_MODE6	720
#define PAL_ROW_MODE6	576
#define MAXATTENU		-26
#define NTSC_Pixel_Clock     12.2727
#define PAL_Pixel_Clock      12.29   
#define BUFSIZE 2500
#define DEFAULTPARAM 5
#define PHASEDEFAULTPARAM 3
#define ZEROPARAM 0
#define RED   0
#define GREEN 1
#define BLUE  2
#define NTSC_M 1
#define H_PATTERN 0
#define V_PATTERN 1


typedef enum{
	xbWhite=0,
	xbYellow,
	xbCyan,
	xbGreen,
	xbMagenta,
	xbRed,
	xbBlue,
	xbBlack,
	NUMBER_OF_CBARS
}COLORBARS;




typedef struct {
	double dbLumaWhiteIRE;  
	double dbLumaYellowIRE;  
	double dbLumaCyanIRE; 
	double dbLumaGreenIRE;  
	double dbLumaMagentaIRE;  
	double dbLumaRedIRE; 
	double dbLumaBlueIRE;  
	double dbLumaBlackIRE;  
} STD_NTSC_CB_LUMA_IRE;

typedef struct {
	double dbChromaWhiteIRE;  
	double dbChromaYellowIRE;  
	double dbChromaCyanIRE; 
	double dbChromaGreenIRE;  
	double dbChromaMagentaIRE;  
	double dbChromaRedIRE; 
	double dbChromaBlueIRE;  
	double dbChromaBlackIRE;  
} STD_NTSC_CB_CHROMA_IRE;

typedef struct {
//	double dbChromaWhitePhase;  
	double dbChromaYellowPhase;  
	double dbChromaCyanPhase; 
	double dbChromaGreenPhase;  
	double dbChromaMagentaPhase;  
	double dbChromaRedPhase; 
	double dbChromaBluePhase;  
//	double dbChromaBlackPhase;  
} STD_NTSC_CB_CHROMA_PHASE;



typedef struct{
	DWORD	dwNumElements;
	double	dblLumaIRE;
	double  dblChromaIRE;
	double  dblChromaPhase;
}NTSCM_COMP_CB_DATA;

typedef struct{
	DWORD	dwNumElements;
	double	dblLumaIRE;
	double  dblChromaIRE;
	double  dblChromaPhase;
}NTSCM_SV_CB_DATA;


typedef struct{
	DWORD	dwNumElements;
	double	dbFreqResponse;
}MULTIBURST_CONFIG_DATA;


typedef struct {

	LPCTSTR pwszCXTVOutDevName;
	DWORD	dwNumberOfCbs;
	DWORD	dwUpperLimitLumaIRE;
	DWORD	dwUpperLimitChromaIRE;
	DWORD	dwUpperLimitChromaPhase;
	DWORD	dwLowerLimitLumaIRE;
	DWORD	dwLowerLimitChromaIRE;
	DWORD	dwLowerLimitChromaPhase;



// ntsc std+upper and std-lower
	DWORD	dwLumaIREUpperLimit;
	DWORD	dwLumaIRELowerLimit;
	DWORD   dwJapanLumaUpper;
	DWORD   dwJapanLumaLower;
	DWORD	dwChromaIREUpperLimit;
	DWORD	dwChromaIRELowerLimit;
	DWORD	dwChromaPhaseUpperLimit;
	DWORD	dwChromaPhaseLowerLimit;

//Pal std+upper and std-lower

	DWORD	dwPalCbLumaIREUpperLimit;
	DWORD	dwPalCbLumaIRELowerLimit;
	DWORD	dwPalCbChromaIREUpperLimit;
	DWORD	dwPalCbChromaIRELowerLimit;
	DWORD	dwPalCbChromaPhaseUpperLimit;
	DWORD	dwPalCbChromaPhaseLowerLimit;

	

} XTV_CB_COFIG_ATTR;


typedef struct {

//std ntsccb parameters
	DWORD   dwStdNtscCbParamLumaIRE;
	DWORD	dwStdNtscCbParamChromaIRE;
	DWORD	dwStdNtscCbParamChromaPhase;
	DWORD	dwStdNtscJapanCbParamLumaIRE;
	
}XTV_STD_NTSC_PARAMS;

/*
typedef struct {

//std ntsccb parameters
	DWORD   dwStdNtscjCbParamLumaIRE;
	DWORD	dwStdNtscjCbParamChromaIRE;
	DWORD	dwStdNtscjCbParamChromaPhase;
}XTV_STD_NTSCJ_PARAMS;*/


typedef struct {

	DWORD   dwStdPalCbParamLumaIRE;
	DWORD	dwStdPalCbParamChromaIRE;
	DWORD	dwStdPalCbParamChromaPhase;
}XTV_STD_PAL_PARAMS;

typedef struct {
int NtscCompLowerLimit;
int  NtscCompUpperLimit;
//int NtscJapanCompUpperLimit;
//int NtscJapanCompLowerLimit;
int PalCompLowerLimit;
int PalCompUpperLimit;
int NtscSvLowerLimit;
int  NtscSvUpperLimit;
int PalSvLowerLimit;
int PalSvUpperLimit;


} XTV_MB_CONFIG_ATTR;


struct FreqElement {
    double freq;          // Hz
    double start_time;    // micro second
    double end_time;
    double amp;           // mv
    double offset;
};

//amp=(500-71.43)/2=214.285=214.3mv
//tektronix

static struct FreqElement NTSC_mulit[]={
   {      0.0,   9.5, 12.7,    0.0,  500.0},
   {      0.0,  12.7, 15.7,    0.0,   71.4},
  // {	  0.0,  15.7, 17.2,    0.0,   285.7},
   { 500000.0,  17.2, 23.2,  214.3,  285.7},
   {1000000.0,  24.6, 30.6,  214.3,  285.7},
   {2000000.0,  32.0, 38.0,  214.3,  285.7},
   {3000000.0,  39.4, 45.4,  214.3,  285.7},
   {3580000.0,  46.8, 52.8,  214.3,  285.7},
  //{0.0,        52.8, 53.98,   0.0,  285.7},
   {4200000.0,  54.2, 60.2,  214.3,  285.7},
   {0.0,        60.2, 61.98,   0.0,  285.7},
};

static struct FreqElement NTSCMode3_mulit[]={
   {      0.0,   10.7, 14.3,    0.0,  500.0},
   {      0.0,  14.3, 16.9,    0.0,   71.4},
   { 500000.0,  19.4, 26.1,  214.3,  285.7},
   {1000000.0,  27.7, 34.4,  214.3,  285.7},
   {2000000.0,  36.0, 42.8,  214.3,  285.7},
   {3000000.0,  44.3, 51.1,  214.3,  285.7},
   {3580000.0,  52.7, 59.4,  214.3,  285.7},
   {4200000.0,  60.9, 67.7,  214.3,  285.7},
   {0.0,        67.7, 69.8,   0.0,  285.7},
};

/*
//bitmap ntsc

static struct FreqElement NTSC_mulit[]={
   {      0.0,   9.4, 13.5,    0.0,  500.0},
   {      0.0,  13.5, 17.5,    0.0,   71.4},
   { 500000.0,  19.3, 25.5,  214.3,  285.7},
   {1000000.0,  27.0, 32.5,  214.3,  285.7},
   {2000000.0,  34.0, 39.5,  214.3,  285.7},
   {3000000.0,  41.0, 46.5,  214.3,  285.7},
   {3580000.0,  48.2, 54.2,  214.3,  285.7},
   {4200000.0,  56.2, 60.2,  214.3,  285.7},
   {	0.0,    60.2, 62.0,    0.0, 285.7},
};
*/



/* tektronix
static struct FreqElement PAL_mulit[]={
   {      0.0,  12.0, 16.0,    0.0,  560.0},
   {      0.0,  16.0, 20.0,    0.0,  140.0},
   {	  0.0,  20.0, 23.6,    0.0,  350.0},
   { 500000.0,  23.6, 29.1,  280.0,  350.0},
   {1000000.0,  29.6, 35.1,  280.0,  350.0},
   {2000000.0,  35.6, 41.1,  280.0,  350.0},
   {3000000.0,  41.6, 47.1,  280.0,  350.0},
   {4000000.0,  47.6, 53.1,  280.0,  350.0},
   {5000000.0,  53.6, 59.1,  280.0,  350.0},
};
*/

// bitmap: 640x480

static struct FreqElement PAL_mulit[]={
   {      0.0,  9.5,  13.2,    0.0,  560.0},
   {      0.0,  13.2, 17.5,    0.0,  140.0},
   { 500000.0,  19.5, 25.5,  280.0,  350.0},
   {1000000.0,  27.0, 32.5,  280.0,  350.0},
   {2000000.0,  34.0, 39.6,  280.0,  350.0},
   {4000000.0,  41.2, 46.6,  280.0,  350.0},
   {4800000.0,  48.5, 54.1,  280.0,  350.0},
   {5800000.0,  55.8, 61.1,  280.0,  350.0},
   {0.0,        61.1, 62.0,     0.0, 350.0},
};

//bitmap: Mode3:720x480

static struct FreqElement PALMode3_mulit[]={
   {      0.0,  10.7, 14.9,    0.0,  560.0},
   {      0.0,  14.9, 19.6,    0.0,  140.0},
   { 500000.0,  21.9, 28.7,  280.0,  350.0},
   {1000000.0,  30.4, 36.5,  280.0,  350.0},
   {2000000.0,  38.3, 44.6,  280.0,  350.0},
   {4000000.0,  46.4, 52.4,  280.0,  350.0},
   {4800000.0,  54.6, 60.7,  280.0,  350.0},
   {5800000.0,  62.8, 68.7,  280.0,  350.0},
   {0.0,        68.7, 69.8,     0.0, 350.0},
};
//Mode6: 720x576

static struct FreqElement PALMode6_mulit[]={
   {      0.0,  10.7, 14.9,    0.0,  560.0},
   {      0.0,  14.9, 19.6,    0.0,  140.0},
   { 500000.0,  21.9, 28.7,  280.0,  350.0},
   {1000000.0,  30.4, 36.5,  280.0,  350.0},
   {2000000.0,  38.3, 44.6,  280.0,  350.0},
   {4000000.0,  46.4, 52.4,  280.0,  350.0},
   {4800000.0,  54.6, 60.7,  280.0,  350.0},
   {5800000.0,  62.8, 68.7,  280.0,  350.0},
   {0.0,        68.7, 69.8,     0.0, 350.0},
};


// For deleting and releasing objects
#define SAFE_DELETE(p)       { delete (p);     (p)=NULL; }
#define SAFE_DELETE_ARRAY(p) { delete[] (p);   (p)=NULL; }
#define SAFE_RELEASE(p)      { if(p) { (p)->Release(); (p)=NULL; } }


class CXModuleTV : public CTestObj  
{
public:
	
	DWORD gdwIgnoreError;
	DECLARE_XMTAMODULE (CXModuleTV, "TV", MODNUM_TV);
	XTV_CB_COFIG_ATTR	*gpXboxCbConfigAttr;
	XTV_CB_COFIG_ATTR	gdwColorBarLimitLumaIRE[NUMBER_OF_COLOR_BARS];
	XTV_CB_COFIG_ATTR	gdwColorBarLimitChromaIRE[NUMBER_OF_COLOR_BARS];
	XTV_CB_COFIG_ATTR	gdwColorBarLimitChromaPhase[NUMBER_OF_COLOR_BARS];
	XTV_CB_COFIG_ATTR   gdwJapanCBLumaIRE[NUMBER_OF_COLOR_BARS];
	XTV_MB_CONFIG_ATTR	dbFreqLimit[NUMBER_OF_FREQ];
	
	XTV_STD_NTSC_PARAMS dbStandardNtscParams[NUMBER_OF_COLOR_BARS];
//	XTV_STD_NTSCJ_PARAMS dbStandardNtscjParams[NUMBER_OF_COLOR_BARS];
	XTV_STD_PAL_PARAMS dbStandardPalParams[NUMBER_OF_COLOR_BARS];

protected:
	BOOL DrawMode6PALMB();
	BOOL DrawMode4PALMB();
	BOOL DrawMode3PALMB();
	BOOL DrawMode3NTSCMB();
	BOOL DrawMode6PALCB();
	BOOL DrawMode4PALCB();
	BOOL DrawMode3PALCB();
	BOOL DrawMode3NTSCCB();
	virtual bool InitializeParameters();
	BOOL DrawPalMB();
	VOID NTSCMBRender();
    VOID PALMBRender();
	BOOL DrawNTSCMB();
	VOID PALCBRender();
	VOID NTSCCBRender();
	BOOL DrawPALCB();
	BOOL DrawNTSCCB();
	BOOL TVTestDrawHorizontalLinearityPattern();
	BOOL TVTestDrawVerticalLinearityPattern();
	VOID TVTestRender(int pattern);
	BOOL FillSurfaceWithHorizontalPattern();
	void FillBuffer(unsigned long *start_address, int count, unsigned long data);
	void FillBuffer(unsigned char *start_address, int count, unsigned long pattern);
	VOID Cleanup();
	int m_testScenes;
	int m_vidMode;
	int m_bpp;
	int m_sectionsToDraw;
	int m_testRetries;
	int m_bUseMemoryFill;
	DWORD m_dwDisplayWidth;
	DWORD m_dwDisplayHeight;
	VOID ReportD3DError(DWORD error);
	LPDIRECT3DVERTEXBUFFER8		m_pVB;
	LPDIRECT3DVERTEXBUFFER8		m_pTVPatternVB;	
	//LPDIRECT3D8					m_pD3D;	
	//D3DPRESENT_PARAMETERS		m_d3dpp;



	double m_LumaIREWhite;
	double m_LumaIREYellow;
	double m_LumaIRECyan;
	double m_LumaIREGreen;
	double m_LumaIREMagenta;
	double m_LumaIRERed;
	double m_LumaIREBlue;
	double m_LumaIREBlack;

	double m_ChromaIREWhite;
	double m_ChromaIREYellow;
	double m_ChromaIRECyan;
	double m_ChromaIREGreen;
	double m_ChromaIREMagenta;
	double m_ChromaIRERed;
	double m_ChromaIREBlue;
	double m_ChromaIREBlack;

	double m_ChromaPhaseWhite;
	double m_ChromaPhaseYellow;
	double m_ChromaPhaseCyan;
	double m_ChromaPhaseGreen;	
	double m_ChromaPhaseMagenta;	
	double m_ChromaPhaseRed;	
	double m_ChromaPhaseBlue;
	double m_ChromaPhaseBlack;

	double m_NtscmFreq1;
	double m_NtscmFreq2;
	double m_NtscmFreq3;
	double m_NtscmFreq4;
	double m_NtscmFreq5;
	double m_NtscmFreq6;
	double m_NtscmFreq7;


	double m_NtscjFreq1;
	double m_NtscjFreq2;
	double m_NtscjFreq3;
	double m_NtscjFreq4;
	double m_NtscjFreq5;
	double m_NtscjFreq6;
	double m_NtscjFreq7;

	double m_PalbFreq1;
	double m_PalbFreq2;
	double m_PalbFreq3;
	double m_PalbFreq4;
	double m_PalbFreq5;
	double m_PalbFreq6;
	double m_PalbFreq7;

	double m_PalmFreq1;
	double m_PalmFreq2;
	double m_PalmFreq3;
	double m_PalmFreq4;
	double m_PalmFreq5;
	double m_PalmFreq6;
	double m_PalmFreq7;


	double m_SecamFreq1;
	double m_SecamFreq2;
	double m_SecamFreq3;
	double m_SecamFreq4;
	double m_SecamFreq5;
	double m_SecamFreq6;
	double m_SecamFreq7;


	bool err_BADPARAMETER (LPCTSTR s1)
	{
		ReportError (0x010, L"Failed to find configuration parameter \"%s\"\nThis configuration parameter doesn't exist or is invalid", s1); 
		return (CheckAbort (HERE));
//return false;
}


	//Default message for general DirectX API error.
	bool err_DIRECTX_API (HRESULT hr, LPCTSTR s1) //Default DirectX API error message
	{
		ReportError (0x011, L"A DirectX API returned error 0x%08lx (%s).", hr, s1 ); 
		return (CheckAbort (HERE));
//		return false;
	}

	/*bool err_BADVIDEOMODE (int mode)
	{
		ReportError (0x013, L"The videomode selected (mode=%d) does not exist.\n Check the 'videomode' parameter in the ini file.", mode);
		return (CheckAbort (HERE));
//		return false;
	}
	bool err_NODIRECT3D ()
	{
		ReportError (0x014, L"Failed to create the Direct3D Device - check for proper DirectX runtime installation."); 
		return (CheckAbort (HERE));
//		return false;
	}*/

	bool err_EchoBufferResponseIsNull ()
	{
		ReportError (0x012, L"The response buffer to a host echo command is empty"); 
		return (CheckAbort (HERE)); 
	}


	bool err_HostResponseError (DWORD dwErrorCodeFromHost, LPCTSTR s1) { if (gdwIgnoreError != TRUE)
	{
		ReportError ((unsigned short)dwErrorCodeFromHost, L"The host responded with the following error message:\n%s", s1);return (CheckAbort (HERE)); } return false;
	}

		bool err_HostCommunicationError (int i1) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x013, L"iSendHost communication routine returned an error code of 0x%x", i1); return (CheckAbort (HERE)); } return false;
	}

	bool err_RecordBufferIsEmpty () { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x014, L"The measure result data buffer from the host is empty"); return (CheckAbort (HERE)); } return false;
	}
	bool err_RecordBufferIsNotCorrectLength (DWORD dw1, DWORD dw2) { if (gdwIgnoreError != TRUE)
	{
		ReportError (0x015, L"The length of the measurement of result data buffer from the host is not correct.\nExpected %ld bytes, received %ld bytes", dw1, dw2); return (CheckAbort (HERE)); } return false;
	}

/*	bool err_BadVideoParam (LPCTSTR s1, DWORD x)
	{
		ReportError (0x019, L"Failed to find configuration parameter \"%s[%lu]\"\nThis configuration parameter doesn't exist or is invalid", s1, x); 
		return (CheckAbort (HERE));
//		return false;
	}*/


	bool err_LumaResultOutOfRange (DWORD i1,double fp,DWORD i2, DWORD i3, DWORD i4)
	{
		ReportError (0x16, L"\nThe measured color bar number(%lu) for Luma IRE  is %.1f out of limit range\nThe Tektronix standard parameter is %lu\nThe upper limits is %lu\nThe lower limit is %lu", i1, fp, i2, i3, i4); 
		return (CheckAbort (HERE));
	//	return false;
	}
//	
	

	bool err_ChromaIREResultOutOfRange  (DWORD i1,double fp,DWORD i2,DWORD i3, DWORD i4)
	{
		ReportError (0x017, L"\nThe measured color bar number(%lu) for  Chroma IRE is %.1f out of limit range\nThe Tektronix standard parameter is %lu\nThe upper limits is %lu\nThe lower limit is %lu", i1, fp, i2, i3, i4); 
		return (CheckAbort (HERE));
//		return false;
	}

	bool err_ChromaPhaseResultOutOfRange (DWORD i1 ,double fp, DWORD i2,DWORD i3, DWORD i4)
	{
		ReportError (0x018, L"\nThe measured color bar number(%lu) for Chroma Phase is %.1f out of limit range\nThe Tektronix standard parameter is %lu\nThe upper limits is %lu\nThe lower limit is %lu", i1,fp, i2, i3, i4); 
		return (CheckAbort (HERE));
//		return false;
	}

bool err_MBurstResultOutOfRange (DWORD i1, double fp,int i2,int i3)
	{
		ReportError (0x019, L"\nThe measured attenuatio of amplitude at frequency packet number(%lu) is %.1f(dB) out of limit range\nThe lower limits is %d(dB)\nThe upper limit is %d(dB)",i1 ,fp, i2, i3); 
		return (CheckAbort (HERE));
//		return false;
	}

bool err_NoConnection()
	{
		ReportError(0x01A, L"\nNo video signal detected or switch video modes may not working properly");
		return (CheckAbort (HERE));
//		return false;
	}

bool err_TVTestLinearity(LPCTSTR tvmode, LPCTSTR pattern, LPCTSTR color, int line, int column, int meas, int exp, int diff, int tol)
	{
		ReportError (0x01B, L"TV Linearity Check Failed: TVMode=%s, Pattern=%s, SampleColor=%s, Line=%d, Column=%d, Meas=%d, Exp=%d, Diff=%d, Tolerance=%d\n", tvmode, pattern, color, line, column, meas, exp, diff, tol); 
		return (CheckAbort (HERE));
//		return false;
	}



};

#endif // !defined(AFX_XTV_H__68FC7951_E13F_4E1F_925A_2F29AE3E15A0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\gdfimage\cd.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Cd.h

Abstract:

    This module defines the on-disk structure of the Cdfs file system.

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

--*/

#ifndef _CDFS_
#define _CDFS_

//
//  Sector size on Cdrom disks is hard-coded to 2048
//

#ifndef SECTOR_SIZE
#define SECTOR_SIZE                 (2048)
#endif

#define RAW_SECTOR_SIZE             (2352)
#define SECTOR_MASK                 (SECTOR_SIZE - 1)
#define INVERSE_SECTOR_MASK         ~(SECTOR_SIZE - 1)

#ifndef SECTOR_SHIFT
#define SECTOR_SHIFT                (11)
#endif

#define XA_SECTOR_SIZE              (2352)

//
//  Cdfs file id is a large integer.
//

typedef LARGE_INTEGER               FILE_ID;
typedef FILE_ID                     *PFILE_ID;

//
//  The following constants are values from the disk.
//

#define FIRST_VD_SECTOR             (16)

#define VOL_ID_LEN                  (5)
#define ESC_SEQ_LEN                 (3)

#define VERSION_1                   (1)

#define VD_TERMINATOR               (255)
#define VD_PRIMARY                  (1)
#define VD_SECONDARY                (2)

#define VOLUME_ID_LENGTH            (32)

//
//  Leave the following so that CdfsBoot.c will compile
//

#define CD_SECTOR_SIZE              (2048)

#define ISO_VOL_ID                  "CD001"
#define HSG_VOL_ID                  "CDROM"

#define ISO_ATTR_MULTI              0x0080
#define ISO_ATTR_DIRECTORY          0x0002

#define MIN_DIR_REC_SIZE        (sizeof( RAW_DIR_REC ) - MAX_FILE_ID_LENGTH)

#define RVD_STD_ID( r, i )      (i ?    r->StandardId       : \
                                        ((PRAW_HSG_VD) r)->StandardId )

#define RVD_DESC_TYPE( r, i )   (i ?    r->DescType         : \
                                        ((PRAW_HSG_VD) r)->DescType )

#define RVD_VERSION( r, i )     (i ?    r->Version          : \
                                        ((PRAW_HSG_VD) r)->Version )

#define RVD_LB_SIZE( r, i )     (i ?    r->LogicalBlkSzI    : \
                                        ((PRAW_HSG_VD) r)->LogicalBlkSzI )

#define RVD_VOL_SIZE( r, i )    (i ?    r->VolSpaceI      : \
                                        ((PRAW_HSG_VD) r)->VolSpaceI )

#define RVD_ROOT_DE( r, i )     (i ?    r->RootDe           : \
                                        ((PRAW_HSG_VD) r)->RootDe )

#define DE_FILE_FLAGS( iso, de ) (iso ? de->FlagsISO : de->FlagsHSG)

//
//  Data track flag for track entries in TOC
//

#define TOC_DATA_TRACK              (0x04)
#define TOC_LAST_TRACK              (0xaa)


//
//  There is considerable rearrangement of the volume descriptors for
//  ISO and HSG.  However, within each standard the same structure can
//  be used for both the primary and secondary descriptors.
//
//  Both of these structures are aligned correctly so that no
//  special macros will be needed to unpack them.
//

//
//  Declaration of length of root directory entry in volume descriptor
//

#define LEN_ROOT_DE                 (34)

//
//  Maximum length of file ID on the disk.  We allow file size beyond the ISO 9660
//  standard.
//

#define MAX_FILE_ID_LENGTH          (255)


typedef struct _RAW_ISO_VD {

    UCHAR       DescType;           // volume type: 1 = standard, 2 = coded
    UCHAR       StandardId[5];      // volume structure standard id = CD001
    UCHAR       Version;            // volume structure version number = 1
    UCHAR       VolumeFlags;        // volume flags
    UCHAR       SystemId[32];       // system identifier
    UCHAR       VolumeId[32];       // volume identifier
    UCHAR       Reserved[8];        // reserved 8 = 0
    ULONG       VolSpaceI;          // size of the volume in LBN's Intel
    ULONG       VolSpaceM;          // size of the volume in LBN's Motorola
    UCHAR       CharSet[32];        // character set bytes 0 = ASCII
    USHORT      VolSetSizeI;        // volume set size Intel
    USHORT      VolSetSizeM;        // volume set size Motorola
    USHORT      VolSeqNumI;         // volume set sequence number Intel
    USHORT      VolSeqNumM;         // volume set sequence number Motorola
    USHORT      LogicalBlkSzI;      // logical block size Intel
    USHORT      LogicalBlkSzM;      // logical block size Motorola
    ULONG       PathTableSzI;       // path table size in bytes Intel
    ULONG       PathTableSzM;       // path table size in bytes Motorola
    ULONG       PathTabLocI[2];     // LBN of 2 path tables Intel
    ULONG       PathTabLocM[2];     // LBN of 2 path tables Motorola
    UCHAR       RootDe[LEN_ROOT_DE];// dir entry of the root directory
    UCHAR       VolSetId[128];      // volume set identifier
    UCHAR       PublId[128];        // publisher identifier
    UCHAR       PreparerId[128];    // data preparer identifier
    UCHAR       AppId[128];         // application identifier
    UCHAR       Copyright[37];      // file name of copyright notice
    UCHAR       Abstract[37];       // file name of abstract
    UCHAR       Bibliograph[37];    // file name of bibliography
    UCHAR       CreateDate[17];     // volume creation date and time
    UCHAR       ModDate[17];        // volume modification date and time
    UCHAR       ExpireDate[17];     // volume expiration date and time
    UCHAR       EffectDate[17];     // volume effective date and time
    UCHAR       FileStructVer;      // file structure version number = 1
    UCHAR       Reserved3;          // reserved
    UCHAR       ResApp[512];        // reserved for application
    UCHAR       Reserved4[653];     // remainder of 2048 bytes reserved

} RAW_ISO_VD;
typedef RAW_ISO_VD *PRAW_ISO_VD;


typedef struct _RAW_HSG_VD {

    ULONG       BlkNumI;            // logical block number Intel
    ULONG       BlkNumM;            // logical block number Motorola
    UCHAR       DescType;           // volume type: 1 = standard, 2 = coded
    UCHAR       StandardId[5];      // volume structure standard id = CDROM
    UCHAR       Version;            // volume structure version number = 1
    UCHAR       VolumeFlags;        // volume flags
    UCHAR       SystemId[32];       // system identifier
    UCHAR       VolumeId[32];       // volume identifier
    UCHAR       Reserved[8];        // reserved 8 = 0
    ULONG       VolSpaceI;          // size of the volume in LBN's Intel
    ULONG       VolSpaceM;          // size of the volume in LBN's Motorola
    UCHAR       CharSet[32];        // character set bytes 0 = ASCII
    USHORT      VolSetSizeI;        // volume set size Intel
    USHORT      VolSetSizeM;        // volume set size Motorola
    USHORT      VolSeqNumI;         // volume set sequence number Intel
    USHORT      VolSeqNumM;         // volume set sequence number Motorola
    USHORT      LogicalBlkSzI;      // logical block size Intel
    USHORT      LogicalBlkSzM;      // logical block size Motorola
    ULONG       PathTableSzI;       // path table size in bytes Intel
    ULONG       PathTableSzM;       // path table size in bytes Motorola
    ULONG       PathTabLocI[4];     // LBN of 4 path tables Intel
    ULONG       PathTabLocM[4];     // LBN of 4 path tables Motorola
    UCHAR       RootDe[LEN_ROOT_DE];// dir entry of the root directory
    UCHAR       VolSetId[128];      // volume set identifier
    UCHAR       PublId[128];        // publisher identifier
    UCHAR       PreparerId[128];    // data preparer identifier
    UCHAR       AppId[128];         // application identifier
    UCHAR       Copyright[32];      // file name of copyright notice
    UCHAR       Abstract[32];       // file name of abstract
    UCHAR       CreateDate[16];     // volume creation date and time
    UCHAR       ModDate[16];        // volume modification date and time
    UCHAR       ExpireDate[16];     // volume expiration date and time
    UCHAR       EffectDate[16];     // volume effective date and time
    UCHAR       FileStructVer;      // file structure version number
    UCHAR       Reserved3;          // reserved
    UCHAR       ResApp[512];        // reserved for application
    UCHAR       Reserved4[680];     // remainder of 2048 bytes reserved

} RAW_HSG_VD;
typedef RAW_HSG_VD *PRAW_HSG_VD;


typedef struct _RAW_JOLIET_VD {

    UCHAR       DescType;           // volume type: 2 = coded
    UCHAR       StandardId[5];      // volume structure standard id = CD001
    UCHAR       Version;            // volume structure version number = 1
    UCHAR       VolumeFlags;        // volume flags
    UCHAR       SystemId[32];       // system identifier
    UCHAR       VolumeId[32];       // volume identifier
    UCHAR       Reserved[8];        // reserved 8 = 0
    ULONG       VolSpaceI;          // size of the volume in LBN's Intel
    ULONG       VolSpaceM;          // size of the volume in LBN's Motorola
    UCHAR       CharSet[32];        // character set bytes 0 = ASCII, Joliett Seq here
    USHORT      VolSetSizeI;        // volume set size Intel
    USHORT      VolSetSizeM;        // volume set size Motorola
    USHORT      VolSeqNumI;         // volume set sequence number Intel
    USHORT      VolSeqNumM;         // volume set sequence number Motorola
    USHORT      LogicalBlkSzI;      // logical block size Intel
    USHORT      LogicalBlkSzM;      // logical block size Motorola
    ULONG       PathTableSzI;       // path table size in bytes Intel
    ULONG       PathTableSzM;       // path table size in bytes Motorola
    ULONG       PathTabLocI[2];     // LBN of 2 path tables Intel
    ULONG       PathTabLocM[2];     // LBN of 2 path tables Motorola
    UCHAR       RootDe[LEN_ROOT_DE];// dir entry of the root directory
    UCHAR       VolSetId[128];      // volume set identifier
    UCHAR       PublId[128];        // publisher identifier
    UCHAR       PreparerId[128];    // data preparer identifier
    UCHAR       AppId[128];         // application identifier
    UCHAR       Copyright[37];      // file name of copyright notice
    UCHAR       Abstract[37];       // file name of abstract
    UCHAR       Bibliograph[37];    // file name of bibliography
    UCHAR       CreateDate[17];     // volume creation date and time
    UCHAR       ModDate[17];        // volume modification date and time
    UCHAR       ExpireDate[17];     // volume expiration date and time
    UCHAR       EffectDate[17];     // volume effective date and time
    UCHAR       FileStructVer;      // file structure version number = 1
    UCHAR       Reserved3;          // reserved
    UCHAR       ResApp[512];        // reserved for application
    UCHAR       Reserved4[653];     // remainder of 2048 bytes reserved

} RAW_JOLIET_VD;
typedef RAW_JOLIET_VD *PRAW_JOLIET_VD;

//
//  Macros to access the different volume descriptors.
//

#define CdRvdId(R,F) (                  \
    FlagOn( (F), VCB_STATE_HSG ) ?      \
    ((PRAW_HSG_VD) (R))->StandardId :   \
    ((PRAW_ISO_VD) (R))->StandardId     \
)

#define CdRvdVersion(R,F) (             \
    FlagOn( (F), VCB_STATE_HSG ) ?      \
    ((PRAW_HSG_VD) (R))->Version :      \
    ((PRAW_ISO_VD) (R))->Version        \
)

#define CdRvdDescType(R,F) (            \
    FlagOn( (F), VCB_STATE_HSG ) ?      \
    ((PRAW_HSG_VD) (R))->DescType :     \
    ((PRAW_ISO_VD) (R))->DescType       \
)

#define CdRvdEsc(R,F) (                 \
    FlagOn( (F), VCB_STATE_HSG ) ?      \
    ((PRAW_HSG_VD) (R))->CharSet :      \
    ((PRAW_ISO_VD) (R))->CharSet        \
)

#define CdRvdVolId(R,F) (               \
    FlagOn( (F), VCB_STATE_HSG ) ?      \
    ((PRAW_HSG_VD) (R))->VolumeId :     \
    ((PRAW_ISO_VD) (R))->VolumeId       \
)

#define CdRvdBlkSz(R,F) (               \
    FlagOn( (F), VCB_STATE_HSG ) ?      \
    ((PRAW_HSG_VD) (R))->LogicalBlkSzI :\
    ((PRAW_ISO_VD) (R))->LogicalBlkSzI  \
)

#define CdRvdPtLoc(R,F) (               \
    FlagOn( (F), VCB_STATE_HSG ) ?      \
    ((PRAW_HSG_VD) (R))->PathTabLocI[0]:\
    ((PRAW_ISO_VD) (R))->PathTabLocI[0] \
)

#define CdRvdPtSz(R,F) (                \
    FlagOn( (F), VCB_STATE_HSG ) ?      \
    ((PRAW_HSG_VD) (R))->PathTableSzI : \
    ((PRAW_ISO_VD) (R))->PathTableSzI   \
)

#define CdRvdDirent(R,F) (              \
    FlagOn( (F), VCB_STATE_HSG ) ?      \
    ((PRAW_HSG_VD) (R))->RootDe :       \
    ((PRAW_ISO_VD) (R))->RootDe         \
)

#define CdRvdVolSz(R,F) (               \
    FlagOn( (F), VCB_STATE_HSG ) ?      \
    ((PRAW_HSG_VD) (R))->VolSpaceI :    \
    ((PRAW_ISO_VD) (R))->VolSpaceI      \
)


//
//  This structure is used to overlay a region of a disk sector
//  to retrieve a single directory entry.  There is a difference
//  in the file flags between the ISO and HSG version and a
//  additional byte in the ISO for the offset from Greenwich time.
//
//  The disk structure is aligned on a word boundary, so any 32
//  bit fields will be represented as an array of 16 bit fields.
//

typedef struct _RAW_DIRENT {

    UCHAR       DirLen;
    UCHAR       XarLen;
    UCHAR       FileLoc[4];
    UCHAR       FileLocMot[4];
    UCHAR       DataLen[4];
    UCHAR       DataLenMot[4];
    UCHAR       RecordTime[6];
    UCHAR       FlagsHSG;
    UCHAR       FlagsISO;
    UCHAR       IntLeaveSize;
    UCHAR       IntLeaveSkip;
    UCHAR       Vssn[2];
    UCHAR       VssnMot[2];
    UCHAR       FileIdLen;
    UCHAR       FileId[MAX_FILE_ID_LENGTH];

} RAW_DIRENT;
typedef RAW_DIRENT RAW_DIR_REC;
typedef RAW_DIRENT *PRAW_DIR_REC;
typedef RAW_DIRENT *PRAW_DIRENT;

#define CD_ATTRIBUTE_HIDDEN                         (0x01)
#define CD_ATTRIBUTE_DIRECTORY                      (0x02)
#define CD_ATTRIBUTE_ASSOC                          (0x04)
#define CD_ATTRIBUTE_MULTI                          (0x80)

#define CD_BASE_YEAR                                (1900)

#define MIN_RAW_DIRENT_LEN  (FIELD_OFFSET( RAW_DIRENT, FileId ) + 1)

#define BYTE_COUNT_8_DOT_3                          (24)

#define SHORT_NAME_SHIFT                            (5)

//
//  The following macro recovers the correct flag field.
//

#define CdRawDirentFlags(IC,RD) (                   \
    FlagOn( (IC)->Vcb->VcbState, VCB_STATE_HSG) ?   \
    (RD)->FlagsHSG :                                \
    (RD)->FlagsISO                                  \
)

//
//  The following macro converts from CD time to NT time.  On ISO
//  9660 media, we now pay attention to the GMT offset (integer
//  increments of 15 minutes offset from GMT).  HSG does not record
//  this field.
//
//  The restriction to the interval [-48, 52] comes from 9660 8.4.26.1
//
//  VOID
//  CdConvertCdTimeToNtTime (
//      IN PIRP_CONTEXT IrpContext,
//      IN PCHAR CdTime,
//      OUT PLARGE_INTEGER NtTime
//      );
//

#define GMT_OFFSET_TO_NT ((LONGLONG) 15 * 60 * 1000 * 1000 * 10)

#define CdConvertCdTimeToNtTime(IC,CD,NT) {                     \
    TIME_FIELDS _TimeField;                                     \
    CHAR GmtOffset;                                             \
    _TimeField.Year = (CSHORT) *((PCHAR) CD) + CD_BASE_YEAR;    \
    _TimeField.Month = (CSHORT) *(Add2Ptr( CD, 1, PCHAR ));     \
    _TimeField .Day = (CSHORT) *(Add2Ptr( CD, 2, PCHAR ));      \
    _TimeField.Hour = (CSHORT) *(Add2Ptr( CD, 3, PCHAR ));      \
    _TimeField.Minute = (CSHORT) *(Add2Ptr( CD, 4, PCHAR ));    \
    _TimeField.Second = (CSHORT) *(Add2Ptr( CD, 5, PCHAR ));    \
    _TimeField.Milliseconds = (CSHORT) 0;                       \
    RtlTimeFieldsToTime( &_TimeField, NT );                     \
    if (!FlagOn((IC)->Vcb->VcbState, VCB_STATE_HSG) &&          \
        ((GmtOffset = *(Add2Ptr( CD, 6, PCHAR ))) != 0 ) &&     \
        (GmtOffset >= -48 && GmtOffset <= 52)) {                \
            (NT)->QuadPart += -GmtOffset * GMT_OFFSET_TO_NT;     \
        }                                                       \
}


//
//  The on-disk representation of a Path Table entry differs between
//  the ISO version and the HSG version.  The fields are the same
//  and the same size, but the positions are different.
//

typedef struct _RAW_PATH_ISO {

    UCHAR           DirIdLen;
    UCHAR           XarLen;
    USHORT          DirLoc[2];
    USHORT          ParentNum;
    UCHAR           DirId[MAX_FILE_ID_LENGTH];

} RAW_PATH_ISO;
typedef RAW_PATH_ISO *PRAW_PATH_ISO;
typedef RAW_PATH_ISO RAW_PATH_ENTRY;
typedef RAW_PATH_ISO *PRAW_PATH_ENTRY;

typedef struct _RAW_PATH_HSG {

    USHORT          DirLoc[2];
    UCHAR           XarLen;
    UCHAR           DirIdLen;
    USHORT          ParentNum;
    UCHAR           DirId[MAX_FILE_ID_LENGTH];

} RAW_PATH_HSG;
typedef RAW_PATH_HSG *PRAW_PATH_HSG;

#define MIN_RAW_PATH_ENTRY_LEN      (FIELD_OFFSET( RAW_PATH_ENTRY, DirId ) + 1)

//
//  The following macros are used to recover the different fields of the
//  Path Table entries.  The macro to recover the disk location of the
//  directory must copy it into a different variable for alignment reasons.
//
//      CdRawPathIdLen - Length of directory name in bytes
//      CdRawPathXar - Number of Xar blocks
//      CdRawPathLoc - Address of unaligned ulong for disk offset in blocks
//

#define CdRawPathIdLen(IC, RP) (                    \
    FlagOn( (IC)->Vcb->VcbState, VCB_STATE_HSG ) ?  \
    ((PRAW_PATH_HSG) (RP))->DirIdLen :              \
    (RP)->DirIdLen                                  \
)

#define CdRawPathXar(IC, RP) (                      \
    FlagOn( (IC)->Vcb->VcbState, VCB_STATE_HSG ) ?  \
    ((PRAW_PATH_HSG) (RP))->XarLen :                \
    (RP)->XarLen                                    \
)

#define CdRawPathLoc(IC, RP) (                      \
    FlagOn( (IC)->Vcb->VcbState, VCB_STATE_HSG ) ?  \
    ((PRAW_PATH_HSG) (RP))->DirLoc :                \
    (RP)->DirLoc                                    \
)


//
//  System use are for XA data.  The following is the system use area for
//  directory entries on XA data disks.
//

typedef struct _SYSTEM_USE_XA {

    //
    //  Owner ID.  Not used in this version.
    //

    UCHAR OwnerId[4];

    //
    //  Extent attributes.  Only interested if mode2 form2 or digital audio.
    //  This is stored big endian.  We will define the attribute flags so
    //  we can ignore this fact.
    //

    USHORT Attributes;

    //
    //  XA signature.  This value must be 'XA'.
    //

    USHORT Signature;

    //
    //  File Number.
    //

    UCHAR FileNumber;

    //
    //  Not used in this version.
    //

    UCHAR Reserved[5];

} SYSTEM_USE_XA;
typedef SYSTEM_USE_XA *PSYSTEM_USE_XA;

#define SYSTEM_USE_XA_FORM1             (0x0008)
#define SYSTEM_USE_XA_FORM2             (0x0010)
#define SYSTEM_USE_XA_DA                (0x0040)

#define SYSTEM_XA_SIGNATURE             (0x4158)

typedef enum _XA_EXTENT_TYPE {

    Form1Data = 0,
    Mode2Form2Data,
    CDAudio

} XA_EXTENT_TYPE;
typedef XA_EXTENT_TYPE *PXA_EXTENT_TYPE;

#endif // _CDFS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xusb\xusb.h ===
#ifndef _XUSB_H
#define _XUSB_H

#include "..\parameter.h"

#pragma once
// C4512: unable to generate an assignment operator for the given class. 
#pragma warning (disable:4512)

//
// Naming of class test and module classes.
// 
// module class: CXModule<module>
// test class:   CXModule<module>Test<test>
//
// The names are important because the modules and executive are 
// all one project.  Since the classes are presented alphebetically, 
// using this naming convention makes the code easier to navigate.
//

#ifndef PASS
#define PASS 0
#endif
#ifndef	FAIL
#define FAIL 0xFFFFFFFF
#endif

#define XBOX_NOSLOT 0


// 
// XUSB Module Number for getting registered with the test executive
//
#define XUSB_MODNUM 4

class CXModuleUSB : public CTestObj//, public CXModuleUSB_Vars
{
public: // Get module number from numbers.h
	DECLARE_XMTAMODULE(CXModuleUSB, "usb", XUSB_MODNUM);	// module name and number

protected:
	//
	// Error messages can be declared here ...
	// (Note: 0x000 - 0x00f reserved for XMTA)
	//
	DWORD err_ParameterNotFound(LPCTSTR s1)
	{
		ReportError (0x010, L"Can't find Configuration Parameter \"%s\".\n", s1);
		return FAIL;
	}

	DWORD err_BadParameter(LPCTSTR s1, int i1, int i2)
	{
		ReportError (0x011, L"Configuration Parameter \"%s\" should have a non-zero value between %d and %d\n",
					 s1, i1, i2);
		return FAIL;
	}
	
	DWORD err_IncorrectValue(int i1, LPCTSTR s1, int i2, int i3)
	{
		ReportError(0x12, L"Incorrect Value of %d for Configuration Parameter \"%s\"."
					L" It should be between %d and %d\n", i1, s1, i2, i3);
		return FAIL;
	}

	DWORD err_Enumerate()
	{
		ReportError (0x013, L"Failed to enumerate the USB bus.\n");
		return FAIL;
	}
	
	DWORD err_ParameterRead(LPCTSTR string)
	{
		ReportError (0x014, L"Failed to read Parameter: %s\n", string);
		return FAIL;
	}
	
	DWORD err_ParameterWrite(LPCTSTR string)
	{
		ReportError (0x015, L"Failed to write Parameter: %s\n", string);
		return FAIL;
	}
	
	DWORD err_MismatchedDevices(LPCTSTR s1, int i1, int i2)
	{
		ReportError (0x016, L"Mismatched number of %s. Expected: %d,"
					 L" Detected: %d\n", s1, i1, i2);
		return FAIL;
	}
	
	DWORD err_InvalidHandle(DWORD d1)
	{
		ReportError (0x017, L"Unable to open file. GetLastError() returned %d\n", d1);
		return FAIL;
	}

	DWORD err_TimeOut(LPCTSTR s1)
	{
		ReportError(0x018, L"Timed out while trying to detect the %s.\n", s1);
		return FAIL;
	}

	DWORD err_WriteFile(DWORD d1)
	{
		ReportError(0x19, L"Error while writing to file. GetLastError() returned %d\n", d1);
		return FAIL;
	}

	DWORD err_ReadFile(DWORD d1)
	{
		ReportError(0x1A, L"Error while reading from file. GetLastError() returned %d\n", d1);
		return FAIL;
	}

	DWORD err_UnMountMU(int i1, LPCTSTR s1, DWORD d1)
	{
		ReportError (0x01B, L"Unable to UnMount Memory Unit on Port %d, %s Slot. Error code returned = %d\n", i1, s1, d1);
		return FAIL;
	}

	DWORD err_WriteReadMismatch(int i1, int i2)
	{
		ReportError(0x01C,(_T("Write/Read Mismatch. Wrote 0x%02X, Read 0x%02X\n")), i1, i2);
		return FAIL;
	}

	DWORD err_CouldNotAllocateBuffer(DWORD d1)
	{
		ReportError (0x01D, _T("Could not allocate a %lu byte data buffer\n"), d1); 
		return FAIL;
	}

	DWORD err_CloseHandle(DWORD d1)
	{
		ReportError (0x01E, L"Unable to close file handle. GetLastError() returned %d\n", d1);
		return FAIL;
	}

	DWORD err_SetFilePointer(DWORD d1)
	{
		ReportError(0x1F, L"Error while reseting the file pointer to the start of the file.  GetLastError() returned %d\n", d1);
		return FAIL;
	}

	// Parameters declared here ...
	int iGamePads;
	int iMemoryUnits;
	ULONG uLength;
	DWORD gdwTotalReadLoops;
	PUCHAR pucWriteBuf, pucReadBuf;

	virtual bool InitializeParameters();
	virtual ~CXModuleUSB() // Destructor
	{
		// delete the write buffer after its use
		if (pucWriteBuf != NULL)
		{
			delete [] pucWriteBuf;
			pucWriteBuf = NULL;
		}

		// delete the read buffer after its use
		if (pucReadBuf != NULL)
		{
			delete [] pucReadBuf;
			pucReadBuf = NULL;
		}
	} // end virtual ~CXModuleUSB()
	void vNewSeed(UINT *pSeed);
	DWORD random(UINT *pScratch);
};


#endif	// _XUSB_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\factory\xtest\xusb\xusb.cpp ===
///////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2000-2001 Intel Corp. All rights reserved.
//
// Title:  XUSB
//
// History:	
// 
// 10/05/00 V1.00 PHM Original release.
//
///////////////////////////////////////////////////////////////////////////////////


#include "..\stdafx.h"
#include "..\testobj.h"
#include "xusb.h"


IMPLEMENT_MODULEUNLOCKED (CXModuleUSB);

//////////////////////////////////////////////////////////////////////////////////
// Function name	: InitializeParameters
// Description	    : Tries to see if the configuration parameters were defined
//					  or not.
// Return type		: bool 
//////////////////////////////////////////////////////////////////////////////////
bool CXModuleUSB::InitializeParameters ()
{
//	TCHAR StrOut[512];
	int iPresent;

	if(!CTestObj::InitializeParameters ())
		return false;

	pucWriteBuf = NULL;
	pucReadBuf = NULL;

	//
	// Make sure that the "gamepads" parameter is there in the ini file
	//
	if((iPresent = GetCfgPresent(L"gamepads")) == 0)
		err_ParameterNotFound(L"GamePads");
	
	else
	{
		// Make sure that its a non-zero value
		iGamePads = GetCfgInt (L"gamepads", 0);

		// Make sure that its a non-zero value between 1 and 4 (there can be upto 4 gamepads
		
		if((iGamePads != 0) && ((iGamePads < 1) || (iGamePads > 4)))
			err_IncorrectValue(iGamePads, L"GamePads", 1, 4);
	
	} // end else

	// Make sure that the "memoryunits" parameter is there in the ini file
	if((iPresent = GetCfgPresent(L"memoryunits")) == 0)
		err_ParameterNotFound(L"MemoryUnits");

	else
	{
		// Make sure that its a non-zero value
		iMemoryUnits = GetCfgInt (L"memoryunits", 0);

		// Make sure that its a non-zero value between 1 and 8 (there can be upto 8 
		// memory units - 2 for each gamepad)
		if((iMemoryUnits != 0) && ((iMemoryUnits <1) || (iMemoryUnits > 8)))
			err_IncorrectValue(iMemoryUnits, L"MemoryUnits", 1, 8);

	} // end else

	// Get the "length" parameter
	uLength = GetCfgInt (L"length", 4096);

	// Get the number of reads to perform
	gdwTotalReadLoops = GetCfgUint (L"readloops", 1);

	return true;

} // end bool CXModuleUSB::InitializeParameters ()


///////////////////////////////////////////////////////////////////////////////////
// Actual XUSB tests.
///////////////////////////////////////////////////////////////////////////////////


// This test verifies that the number of Gamepads and Memory Units attached to the UUT
// (Unit Under Test) matches with what is specified by their respective configuration
// parameters.
IMPLEMENT_TESTUNLOCKED (USB, enumerationtest, 1)
{
	
	int iGamePadsFound = 0, iMemUnitsFound = 0;
	DWORD dwDeviceBitMapGamePad, dwDeviceBitMapMemUnit;
	int i, j;
	bool bFoundGamePad[4], bFoundMemUnit[8];
	
//	#ifdef _DEBUG
		static int Enum;
		Enum++;
		ReportDebug(BIT0,_T("Enumeration Test - Loop %d"), Enum);
//	#endif

	// debug
	/*static int x = 1;
	TCHAR StrOut[512];
	_stprintf(StrOut, _T("LOOPLIMIT for EnumerationTest = %d\n"), x);
	OutputDebugString(StrOut);
	x++;*/
	
	// initialize bFoundGamePad and bFoundMemUnit to false
	for(j = 0; j < 4; j++)
		bFoundGamePad[j] = false;

	for(j = 0; j < 8; j++)
		bFoundMemUnit[j] = false;


	// Trial of 5 loops for detecting gamepads and memory units that match the
	// configuration parameters.
	for(i = 0; i < 5; i++)
	{	
		// Get a bitmap for the gamepads to see how many are attached.
		dwDeviceBitMapGamePad = XGetDevices(XDEVICE_TYPE_GAMEPAD);
		
		// Get a bitmap for the memory units to see how many are attached.
		dwDeviceBitMapMemUnit = XGetDevices(XDEVICE_TYPE_MEMORY_UNIT);
	
		// Check for Gamepads on Ports 0 - 3. There could be max 4 gamepads.
		for(j = 0; j < 4; j++)
		{
			if(bFoundGamePad[j] == true)
				continue;

			else
			{
				if(dwDeviceBitMapGamePad & (1 << j))
				{
					bFoundGamePad[j] = true;
					iGamePadsFound++;

				} // end if(dwDeviceBitMapGamePad & (1 << i))

			} // end else

		} // end for(j = 0; j < 4; j++)

		// There can be max 8 memory units - 2 for each gamepad (top and bottom slot).
		// Top slots: bits 0 - 3
		// Bottom slots: bits 16 - 19
		for(j = 0; j < 8; j++)
		{
			if(bFoundMemUnit[j] == true)
				continue;
			else
			{
				if(j <=3)
				{
					if(dwDeviceBitMapMemUnit & (1 << j))
					{
						bFoundMemUnit[j] = true;
						iMemUnitsFound++;
			
					} // end if(dwDeviceBitMapMemUnit & (1 << j))
				}
				
				else
				{
					if(dwDeviceBitMapMemUnit & (1 << (j + 12)))
					{
						bFoundMemUnit[j] = true;
						iMemUnitsFound++;

					} // end if(dwDeviceBitMapMemUnit & (1 << j))
			
				}
			
			} // end else

		} // end for(j = 0; j < 8; j++)
		
		// After calling XInitDevices, it takes less than 30 seconds to detect a device.
		// So Wait for 200 ms during each trial to make sure that a device is detected.
		Sleep(200);

	} // end for(i = 0; i < 5; i++)

	// If completed the trial loop and didn't find gamepads that match the config
	// parameter, report error
	if((i == 5) && (iGamePadsFound != iGamePads))
		err_TimeOut(L"GamePads");

	// Found incorrect # of gamepads
	if(iGamePadsFound != iGamePads)
		err_MismatchedDevices(L"GamePads", iGamePads, iGamePadsFound);

	// If completed the trial loop and didn't find memory units that match the config
	// parameter, report error
	if((i == 5) && (iMemUnitsFound != iMemoryUnits))
		err_TimeOut(L"Memory Units");

	// Found incorrect # of memory units
	if(iMemUnitsFound != iMemoryUnits)
		err_MismatchedDevices(L"Memory Units", iMemoryUnits, iMemUnitsFound);
	
}	// IMPLEMENT_TESTUNLOCKED (USB, enumerationtest, 1)


// This test stresses all the memory units present on the gamepad(s). For each memory
// unit present, it creates a file on its drive, writes to the file, reads from the
// file and compares them to make sure that they're the same. This should generate 
// traffic on the USB bus.
IMPLEMENT_TESTUNLOCKED (USB, memoryunitstresstest, 2)
{
	DWORD dwBytesWritten, dwBytesRead, dwError;
	int j = 0, iMemUnitsFound = 0;
	bool bFoundMemUnit[8];
	char chDriveLetter[8];
	CHAR chDrive;
	HANDLE hFile;
	char szFileName[50];
	ULONG i;
	DWORD dwTotalErrors = 0, dwReadLoops = 0;
	UINT uiSeed, uiRandScratch;

	// debug
	//ReportDebug(BIT0,_T("In MUStressTest\n"));

//	#ifdef _DEBUG
		static int MemUnit;
		MemUnit++;
		ReportDebug(BIT0,_T("MemoryUnitStress Test - Loop %d"), MemUnit);
//	#endif

	
	// debug
	/*static int x = 1;
	TCHAR StrOut[512];	
	_stprintf(StrOut, _T("LOOPLIMIT for MemoryUnitStressTest = %d\n"), x);
	OutputDebugString(StrOut);
	//ReportDebug(BIT0,_T("LOOPLIMIT = %d\n"), x);
	x++;*/

	vNewSeed(&uiSeed);
	uiRandScratch = uiSeed;
	// Initialize the write buffer
	if(pucWriteBuf == NULL)
	{
		if ((pucWriteBuf = new UCHAR[uLength]) == NULL)
		{
			err_CouldNotAllocateBuffer((ULONG)(sizeof(UCHAR)*uLength));
			return;
		}
	}

	// Initialize the read buffer
	if(pucReadBuf == NULL)
	{
		if ((pucReadBuf = new UCHAR[uLength]) == NULL)
		{
			err_CouldNotAllocateBuffer((ULONG)(sizeof(UCHAR)*uLength));
			delete [] pucWriteBuf;
			pucWriteBuf = NULL;
			return;
		}
	}

	// debug
	//ReportDebug(BIT0,_T("after initializing buffers\n"));

	for(j = 0; j < 8; j++)
	{
		bFoundMemUnit[j] = false;
		chDriveLetter[j] = '\0';
	}

	// Try to detect a memory unit in top slot and/or bottom slot of each of the four
	// gamepads attached to the UUT. The gamepads are located on ports 1-4. Each gamepad
	// can have upto two memory units - one on the TOP SLOT and one on the BOTTOM SLOT.
	for(j = 0; j < 4; j++)
	{
		dwError = XMountMU(j, XDEVICE_TOP_SLOT, &chDrive);						
		
		// If found a memory unit, increment the count & store the drive letter for that unit.
		if(dwError == ERROR_SUCCESS)
		{
			iMemUnitsFound++;
			bFoundMemUnit[j] = true;
			chDriveLetter[j] = chDrive;
		}

		dwError = XMountMU(j, XDEVICE_BOTTOM_SLOT, &chDrive);						
		if(dwError == ERROR_SUCCESS)
		{
			iMemUnitsFound++;
			bFoundMemUnit[j + 4] = true;
			chDriveLetter[j + 4] = chDrive; 
		}

	} // end for(j = 0; j < 4; j++)

	// Verify that the memory units mounted match the number of memory units
	// specified in the iMemoryUnits configuration parameter.
	if(iMemUnitsFound != iMemoryUnits)
	{
		err_MismatchedDevices(L"Memory Units", iMemoryUnits, iMemUnitsFound);
	}
	else
	{
		// For each memory unit found create a file on the respective drive.
		// Drive letters F thru M are dedicated for the 8 memory units.
		for(j = 0; j <8; j++)
		{
			if(bFoundMemUnit[j] == true)
			{
				// Create a unique file name for each drive that is found.
				// For example, F:\\MemoryUnitStressTest0.txt
				sprintf(szFileName, "%c:\\MemoryUnitStressTest%d.txt", chDriveLetter[j], j);
			
				hFile = CreateFile(szFileName, GENERIC_READ | GENERIC_WRITE, 0, NULL, 
					    		   CREATE_ALWAYS, 0, NULL);

				if(hFile == INVALID_HANDLE_VALUE)
					err_InvalidHandle(GetLastError());
					
				// If a valid file is created, write to the file, read from the file
				// and compare the files.
				else
				{	
					// debug
					// Fill up write buffer with random values to be written to the 
					// files on the drives found on the Memory Units.
					for(i = 0; i < uLength; i++)
						pucWriteBuf[i] = (UCHAR)random(&uiRandScratch);
					
					// Rewind and write data to the file.
					if (SetFilePointer(hFile,0,NULL,FILE_BEGIN) == INVALID_SET_FILE_POINTER)
						err_SetFilePointer(GetLastError());
					else
					{
						if(!WriteFile(hFile, pucWriteBuf, uLength, &dwBytesWritten, NULL))
							err_WriteFile(GetLastError());
						else
						{
							for (dwReadLoops = 0; dwReadLoops < gdwTotalReadLoops; dwReadLoops++)
							{
								// Flush the data, rewind the file, and read the data back.
								FlushFileBuffers(hFile);
								if (SetFilePointer(hFile,0,NULL,FILE_BEGIN) == INVALID_SET_FILE_POINTER)
									err_SetFilePointer(GetLastError());
								else
								{
									memset(pucReadBuf, 0, uLength); // Clear the read buffer
									if(!ReadFile(hFile, pucReadBuf, uLength, &dwBytesRead, NULL))
										err_ReadFile(GetLastError());
									else
									{
										// Compare the data read with the data written
										for(i = 0; i < uLength; i++)
										{
											if(pucReadBuf[i] != pucWriteBuf[i])
											{
												err_WriteReadMismatch(pucReadBuf[i], pucWriteBuf[i]);
												if (CheckAbort(HERE))
													break;
												dwTotalErrors ++;
												if (dwTotalErrors > 100)
													break;
											}
										}
									}
								}
								if (CheckAbort(HERE))
									break;
							}
						}
					}
					if (!CloseHandle(hFile))
						err_CloseHandle(GetLastError());

				} // end else

			} // end if(bFoundMemUnit[j] == true)
			if (CheckAbort(HERE))
				break;
		} // end for(j = 0; j <8; j++)
	
	} // end else

	// debug
	//ReportDebug(BIT0,_T("Leaving MUStessTest\n"));
					
	for(j = 0; j < 4; j++) // Unmount all memory units
	{
		if (bFoundMemUnit[j])
		{
			if ((dwError = XUnmountMU(j, XDEVICE_TOP_SLOT)) != ERROR_SUCCESS)
				err_UnMountMU(j, L"Top", dwError); 
		}
		if (bFoundMemUnit[j+4])
		{
			if ((dwError = XUnmountMU(j, XDEVICE_BOTTOM_SLOT)) != ERROR_SUCCESS)
				err_UnMountMU(j, L"Bottom", dwError); 
		}
	}
	delete [] pucWriteBuf;
	pucWriteBuf = NULL;
	delete [] pucReadBuf;
	pucReadBuf = NULL;
} // IMPLEMENT_TESTUNLOCKED (USB, memoryunittest, 2)

void CXModuleUSB::vNewSeed(UINT *pSeed)
{
	SYSTEMTIME systimeSeed;
	FILETIME filetimeSeed;

	GetSystemTime(&systimeSeed);
	SystemTimeToFileTime(&systimeSeed, &filetimeSeed);
	*pSeed = (UINT)filetimeSeed.dwLowDateTime;

	return;
}

DWORD CXModuleUSB::random(UINT *pScratch)
{
	DWORD ret;
	ret  = (*pScratch = *pScratch * 214013L + 2531011L) >> 16;
	ret |= (*pScratch = *pScratch * 214013L + 2531011L) & 0xFFFF0000;
	return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagebld.new\imagebld.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    imagebld.cpp

Abstract:

    This module implements a utility program to build an Xbox executable image.

--*/

#include "imgbldp.h"

//
// Stores the file handle to access the input file.
//
HANDLE ImgbInputFileHandle = INVALID_HANDLE_VALUE;

//
// Stores the number of bytes in the input file.
//
ULONG ImgbInputFileSize;

//
// Stores the file mapping handle to access the input file.
//
HANDLE ImgbInputFileMappingHandle;

//
// Stores the file mapping view pointer to access the input file.
//
LPVOID ImgbInputFileMappingView;

//
// Stores the fully resolved input file path.
//
CHAR ImgbInputFileFullPath[MAX_PATH+1];

//
// Stores the pointer to the file name in the ImgbInputFileFullPath buffer.
//
LPSTR ImgbInputFileFilePart;

//
// Stores the file handle to access the output file.
//
HANDLE ImgbOutputFileHandle = INVALID_HANDLE_VALUE;

//
// Stores the pointer to the NT headers from the input file.
//
PIMAGE_NT_HEADERS ImgbNtHeader;

//
// Stores the pointer to the root XBE image header for the output file.
//
PIMGB_XBEIMAGE_HEADER ImgbXbeImageHeader;

//
// Giant transfer buffer for read/write operations.
//
BYTE ImgbTransferBuffer[128 * 1024];

//
// Stores the compressed Microsoft logo bitmap stored in every XBE image.
//
const UCHAR ImgbMicrosoftLogo[] = {
    #include "msftlogo.h"
};

//
// Signifes whether to suppress the library approval warnings
//
BOOLEAN ImgbNoWarnLibraryApproval;

DECLSPEC_NORETURN
VOID
ImgbExitProcess(
    int ExitCode
    )
{
    if (ImgbOutputFileHandle != INVALID_HANDLE_VALUE) {

        CloseHandle(ImgbOutputFileHandle);

        //
        // If an error has occurred, then delete the output file.
        //

        if (ExitCode != 0) {
            DeleteFile(ImgbOutputFilePath);
        }
    }

    exit(ExitCode);
}

VOID
ImgbOpenInputOutputFiles(
    VOID
    )
{
    //
    // Verify that the input and output file paths were specified.
    //

    if (ImgbInputFilePath == NULL) {
        ImgbResourcePrintErrorAndExit(IDS_MISSING_REQUIRED_OPTION, "/IN:");
    }

    if (ImgbOutputFilePath == NULL) {
        ImgbResourcePrintErrorAndExit(IDS_MISSING_REQUIRED_OPTION, "/OUT:");
    }

    //
    // Resolve the full path name of the input file.
    //

    if (GetFullPathName(ImgbInputFilePath, MAX_PATH, ImgbInputFileFullPath,
        &ImgbInputFileFilePart) == 0) {
        ImgbResourcePrintErrorAndExit(IDS_CANNOT_OPEN_INPUT_FILE, ImgbInputFilePath);
    }

    //
    // Create the output file.
    //

    ImgbOutputFileHandle = CreateFile(ImgbOutputFilePath, GENERIC_READ |
        GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (ImgbOutputFileHandle == INVALID_HANDLE_VALUE) {
        ImgbResourcePrintErrorAndExit(IDS_CANNOT_CREATE_OUTPUT_FILE, ImgbOutputFilePath);
    }

    //
    // Open the input file.
    //

    ImgbInputFileHandle = CreateFile(ImgbInputFileFullPath, GENERIC_READ,
        FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);

    if (ImgbInputFileHandle == INVALID_HANDLE_VALUE) {
        ImgbResourcePrintErrorAndExit(IDS_CANNOT_OPEN_INPUT_FILE, ImgbInputFilePath);
    }

    //
    // Obtain the size of the input file.
    //

    ImgbInputFileSize = GetFileSize(ImgbInputFileHandle, NULL);

    //
    // Create a copy-on-write section of the input file.
    //

    ImgbInputFileMappingHandle = CreateFileMapping(ImgbInputFileHandle, NULL,
        PAGE_WRITECOPY, 0, 0, NULL);

    if (ImgbInputFileMappingHandle == NULL) {
        ImgbResourcePrintErrorAndExit(IDS_CANNOT_READ_INPUT_FILE, ImgbInputFilePath);
    }

    //
    // Map a copy-on-write view of the input file section.
    //

    ImgbInputFileMappingView = MapViewOfFile(ImgbInputFileMappingHandle,
        FILE_MAP_COPY, 0, 0, 0);

    if (ImgbInputFileMappingView == NULL) {
        ImgbResourcePrintErrorAndExit(IDS_CANNOT_READ_INPUT_FILE, ImgbInputFilePath);
    }
}

VOID
ImgbProcessInputSectionHeaders(
    VOID
    )
{
    ULONG SectionsRemaining;
    ULONG SectionMask;
    ULONG LastVirtualAddress;
    ULONG LastEndingVirtualAddress;
    PIMAGE_SECTION_HEADER SectionHeader;
    UCHAR SectionName[IMAGE_SIZEOF_SHORT_NAME + 1];
    ULONG RelativeLoadAddress;

    //
    // Trim off all discardable sections from the end of the image.  The linker
    // may place a non-discardable section (such as .rsrc) between discardable
    // sections so we can't just stop when we hit the first discardable section.
    //

    SectionsRemaining = ImgbNtHeader->FileHeader.NumberOfSections;

    while (SectionsRemaining) {

        SectionHeader = IMAGE_FIRST_SECTION(ImgbNtHeader) +
            SectionsRemaining - 1;

        if ((SectionHeader->Characteristics & IMAGE_SCN_MEM_DISCARDABLE) == 0) {

            //
            // Compute the number of bytes that will be required to map the
            // executable sections.  Align that number up to the section
            // alignment of the executable file.
            //

            ImgbXbeImageHeader->SizeOfExecutableImage =
                SectionHeader->VirtualAddress + SectionHeader->Misc.VirtualSize -
                IMAGE_FIRST_SECTION(ImgbNtHeader)->VirtualAddress;

            SectionMask = ImgbNtHeader->OptionalHeader.SectionAlignment - 1;

            ImgbXbeImageHeader->SizeOfExecutableImage =
                (ImgbXbeImageHeader->SizeOfExecutableImage + SectionMask) & ~SectionMask;

            if (ImgbXbeImageHeader->SizeOfExecutableImage > IMGB_MAXIMUM_IMAGE_SIZE) {
                ImgbResourcePrintErrorAndExit(IDS_IMAGE_TOO_LARGE);
            }

            break;
        }

        SectionsRemaining--;
    }

    //
    // Walk through each of the image's sections and it to the section list
    // head.
    //

    LastVirtualAddress = 0;
    LastEndingVirtualAddress = 0;
    SectionHeader = IMAGE_FIRST_SECTION(ImgbNtHeader);

    while (SectionsRemaining) {

        //
        // Verify that the section headers are in increasing virtual address
        // order.
        //

        if (SectionHeader->VirtualAddress <= LastVirtualAddress) {
            ImgbResourcePrintErrorAndExit(IDS_INVALID_CORRUPT_INPUT_FILE, ImgbInputFilePath);
        }

        //
        // Verify that the file data exists in the input file.
        //

        if ((SectionHeader->PointerToRawData > ImgbInputFileSize) ||
            (SectionHeader->PointerToRawData + SectionHeader->SizeOfRawData > ImgbInputFileSize)) {
            ImgbResourcePrintErrorAndExit(IDS_INVALID_CORRUPT_INPUT_FILE, ImgbInputFilePath);
        }

        //
        // Verify that the section actually contains data.  The linker won't
        // generate a section header for a section that doesn't contribute any
        // code or data.  The below code assumes that VirtualSize will never be
        // zero.
        //

        if (SectionHeader->Misc.VirtualSize == 0) {
            ImgbResourcePrintErrorAndExit(IDS_INVALID_CORRUPT_INPUT_FILE, ImgbInputFilePath);
        }

        //
        // Build the section name on the stack.
        //

        memcpy(SectionName, SectionHeader->Name, IMAGE_SIZEOF_SHORT_NAME);
        SectionName[IMAGE_SIZEOF_SHORT_NAME] = '\0';

        //
        // Increment the number of XBE sections.
        //

        ImgbXbeImageHeader->ImageHeader.NumberOfSections++;

        //
        // Increment the number of executable sections.
        //

        ImgbXbeImageHeader->SectionHeaders.NumberOfExecutableSections++;

        //
        // Add the size of the section name to the total for the XBE section
        // header.
        //

        ImgbXbeImageHeader->SectionHeaders.SizeOfSectionNames += strlen((PSTR)SectionName) + 1;

        //
        // Check if the section is a preload section or not.
        //

        if (ImgbSearchNoPreloadList((PSTR)SectionName)) {
            SectionHeader->Characteristics &= ~IMAGE_SCN_MEM_PRELOAD;
        } else {
            SectionHeader->Characteristics |= IMAGE_SCN_MEM_PRELOAD;
        }

        //
        // Compute the load address for the section relative to the first
        // section.  The first image section will always start on a page
        // boundary.
        //

        RelativeLoadAddress = SectionHeader->VirtualAddress -
            IMAGE_FIRST_SECTION(ImgbNtHeader)->VirtualAddress;

        //
        // If this the first section or if the section does not start on the
        // same page as the last section, then we'll need another shared
        // page reference counter.
        //

        if ((RelativeLoadAddress == 0) ||
            (PAGE_ALIGN(RelativeLoadAddress) !=
                PAGE_ALIGN(LastEndingVirtualAddress -
                IMAGE_FIRST_SECTION(ImgbNtHeader)->VirtualAddress))) {
            ImgbXbeImageHeader->SectionHeaders.NumberOfSharedPageReferenceCounts++;
        }

        //
        // If the inclusive ending byte of the section isn't on the same
        // page as the starting byte of the section, then we'll need another
        // shared page reference counter.
        //

        if (PAGE_ALIGN(RelativeLoadAddress) !=
            PAGE_ALIGN(RelativeLoadAddress + SectionHeader->Misc.VirtualSize - 1)) {
            ImgbXbeImageHeader->SectionHeaders.NumberOfSharedPageReferenceCounts++;
        }

        LastVirtualAddress = SectionHeader->VirtualAddress;
        LastEndingVirtualAddress = LastVirtualAddress + SectionHeader->Misc.VirtualSize - 1;

        SectionsRemaining--;
        SectionHeader++;
    }

    //
    // Attach the import directory header to the list of headers.
    //

    InsertTailList(&ImgbXbeImageHeader->HeadersListHead,
        &ImgbXbeImageHeader->SectionHeaders.HeadersListEntry);
}

VOID
ImgbEnsureVirtualAddressIsPreload(
    ULONG VirtualAddress
    )
{
    PIMAGE_SECTION_HEADER SectionHeader;
    UCHAR SectionName[IMAGE_SIZEOF_SHORT_NAME + 1];

    SectionHeader = ImgbVirtualAddressToSectionHeader(ImgbNtHeader, VirtualAddress);

    if ((SectionHeader->Characteristics & IMAGE_SCN_MEM_PRELOAD) == 0) {

        memcpy(SectionName, SectionHeader->Name, IMAGE_SIZEOF_SHORT_NAME);
        SectionName[IMAGE_SIZEOF_SHORT_NAME] = '\0';

        ImgbResourcePrintWarning(IDS_IGNORING_NOPRELOAD, SectionName);

        SectionHeader->Characteristics |= IMAGE_SCN_MEM_PRELOAD;
    }
}

VOID
ImgbProcessInputImportDescriptors(
    VOID
    )
{
    ULONG ImportDescriptorBytesRemaining;
    PIMAGE_IMPORT_DESCRIPTOR ImportDescriptor;
    ULONG NumberOfNonKernelImports;
    ULONG SizeOfNonKernelImageNames;
    LPCSTR ImageName;
    PIMAGE_THUNK_DATA OriginalImageThunkData;
    PIMAGE_THUNK_DATA ImageThunkData;

    //
    // Verify that the image hasn't been bound, which screws up the import image
    // thunks that the XBE loader needs to use.
    //

    if (ImgbNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size != 0) {
        ImgbResourcePrintErrorAndExit(IDS_BOUND_IMAGES_UNSUPPORTED);
    }

    //
    // Walk through each of the import descriptors.
    //

    ImportDescriptorBytesRemaining =
        ImgbNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size;
    ImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)
        ImgbImageDataDirectoryToData(ImgbNtHeader, IMAGE_DIRECTORY_ENTRY_IMPORT);
    NumberOfNonKernelImports = 0;
    SizeOfNonKernelImageNames = 0;

    while (ImportDescriptorBytesRemaining >= sizeof(IMAGE_IMPORT_DESCRIPTOR)) {

        //
        // If we find the NULL import descriptor, then break out now.
        //

        if (ImportDescriptor->Characteristics == 0) {
            break;
        }

        //
        // If this is the import descriptor for the kernel, then save the RVA
        // for the thunk data in the image header.
        //
        // Otherwise, increment the number of non kernel imports and the number
        // of bytes required to hold the image names.
        //

        ImageName = (LPCSTR)ImgbVirtualAddressToData(ImgbNtHeader, ImportDescriptor->Name);

        if (_stricmp(ImageName, "xboxkrnl.exe") == 0) {
            ImgbXbeImageHeader->ImageHeader.XboxKernelThunkData =
                (PIMAGE_THUNK_DATA)ImportDescriptor->FirstThunk;
        } else {
            NumberOfNonKernelImports++;
            SizeOfNonKernelImageNames += (strlen(ImageName) + sizeof(UCHAR)) * sizeof(WCHAR);
        }

        //
        // Walk through the image thunks and verify that all entries are import
        // by ordinal.
        //

        OriginalImageThunkData = (PIMAGE_THUNK_DATA)ImgbVirtualAddressToData(ImgbNtHeader,
            ImportDescriptor->OriginalFirstThunk);
        ImageThunkData = (PIMAGE_THUNK_DATA)ImgbVirtualAddressToData(ImgbNtHeader,
            ImportDescriptor->FirstThunk);

        while (ImageThunkData->u1.Ordinal != 0) {

            //
            // Verify that the original image thunk data matches the actual
            // image thunk data.  The XBE loader will only walk throught the
            // actual image thunk data and expects that the array will be filled
            // with ordinals.
            //

            if (OriginalImageThunkData->u1.Ordinal != ImageThunkData->u1.Ordinal) {
                ImgbResourcePrintErrorAndExit(IDS_INVALID_CORRUPT_INPUT_FILE,
                    ImgbInputFilePath);
            }

            //
            // Verify that this is a ordinal import.
            //

            if (!IMAGE_SNAP_BY_ORDINAL(ImageThunkData->u1.Ordinal)) {
                ImgbResourcePrintErrorAndExit(IDS_CANNOT_IMPORT_BY_NAME, ImageName);
            }

            OriginalImageThunkData++;
            ImageThunkData++;
        }

        //
        // The XBE loader needs to access the section containing these import
        // thunks at boot time.  Ensure that the section is not marked as
        // NOPRELOAD.
        //

        ImgbEnsureVirtualAddressIsPreload(ImportDescriptor->FirstThunk);

        //
        // Advance to the next import descriptor.
        //

        ImportDescriptor++;
        ImportDescriptorBytesRemaining -= sizeof(IMAGE_IMPORT_DESCRIPTOR);
    }

    //
    // We don't need to write out any additional headers if this image doesn't
    // import from anything besides the kernel.
    //

    if (NumberOfNonKernelImports != 0) {

        ImgbXbeImageHeader->ImportDescriptorHeader.NumberOfNonKernelImports =
            NumberOfNonKernelImports;

        //
        // Compute the virtual size of the import directory header.  This is the
        // number of bytes that we'll write out for the non-kernel imports.
        //
        // Note that we need to add one descriptor in order to terminate the
        // array.
        //

        ImgbXbeImageHeader->ImportDescriptorHeader.VirtualSize =
            (NumberOfNonKernelImports + 1) * sizeof(XBEIMAGE_IMPORT_DESCRIPTOR) +
            SizeOfNonKernelImageNames;

        //
        // Attach the import directory header to the list of headers.
        //

        InsertTailList(&ImgbXbeImageHeader->HeadersListHead,
            &ImgbXbeImageHeader->ImportDescriptorHeader.HeadersListEntry);

    } else {
        ImgbXbeImageHeader->ImportDescriptorHeader.VirtualSize = 0;
    }
}

VOID
ImgbProcessInputTlsDirectory(
    VOID
    )
{
    PIMAGE_TLS_DIRECTORY TlsDirectory;
    LPBYTE RawData;
    LPBYTE EndRawData;

    //
    // There's only work to do if the TLS data directory entry is valid.
    //

    if (ImgbNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size != 0) {

        TlsDirectory = (PIMAGE_TLS_DIRECTORY)
            ImgbImageDataDirectoryToData(ImgbNtHeader, IMAGE_DIRECTORY_ENTRY_TLS);

        ImgbXbeImageHeader->TlsRawDataHeader.TlsDirectory = TlsDirectory;

        //
        // Store the RVA of the TLS directory in the image header.
        //

        ImgbXbeImageHeader->ImageHeader.TlsDirectory = (PIMAGE_TLS_DIRECTORY)
            ImgbNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress;

        //
        // Ensure that the TLS directory structure is marked as preload.  The
        // XAPI startup code will need to create a thread, so this data must be
        // around at boot.
        //

        ImgbEnsureVirtualAddressIsPreload(ImgbNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress);

        //
        // Check if there's any __declspec(thread) data for this image.  The
        // .tls section is marked as discardable so we need to make a copy of
        // the raw data in the headers if the thread data is non-zero (not
        // common).
        //

        if ((TlsDirectory->EndAddressOfRawData - TlsDirectory->StartAddressOfRawData) != 0) {

            //
            // The linker doesn't bother to fill in SizeOfZeroFill.  The common
            // case is that all of the thread data is zero, in which case we can
            // avoid storing any data in the headers for TLS.
            //

            RawData = (LPBYTE)ImgbLoadAddressToData(ImgbNtHeader,
                TlsDirectory->StartAddressOfRawData);
            EndRawData = (LPBYTE)ImgbLoadAddressToData(ImgbNtHeader,
                TlsDirectory->EndAddressOfRawData);

            while (EndRawData > RawData) {

                if (*(EndRawData - 1) != 0) {
                    break;
                }

                TlsDirectory->SizeOfZeroFill++;
                EndRawData--;
            }

            //
            // If we hit any non-zero bytes, then we'll need to add a header to
            // the image to hold this data since the .tls section will be lost
            // when we throw away discardable sections.
            //

            if (EndRawData > RawData) {

                ImgbXbeImageHeader->TlsRawDataHeader.VirtualSize = EndRawData - RawData;
                ImgbXbeImageHeader->TlsRawDataHeader.RawData = RawData;

                //
                // Attach the TLS header to the list of headers.
                //

                InsertTailList(&ImgbXbeImageHeader->HeadersListHead,
                    &ImgbXbeImageHeader->TlsRawDataHeader.HeadersListEntry);
            }
        }
    }
}

VOID
ImgbPrintUnapprovedLibraryWarning(
    PXBEIMAGE_LIBRARY_VERSION LibraryVersion,
    int ApprovalLevel
    )
{
    char LibraryName[9];
    int ids;

    switch(ApprovalLevel) {
    default:
        ids = IDS_UNAPPROVED;
        break;
    case 1:
        ids = IDS_POSSIBLY_UNAPPROVED;
        break;
    case -1:
        ids = IDS_EXPIRED;
        break;
    }

    if(ApprovalLevel >= 0)
        LibraryVersion->ApprovedLibrary = ApprovalLevel;
    if(!ImgbNoWarnLibraryApproval) {
        memcpy(LibraryName, LibraryVersion->LibraryName, 8);
        LibraryName[8] = 0;
        ImgbResourcePrintWarning(ids, LibraryName);
    }
}

VOID
ImgbProcessLibraryVersions(
    VOID
    )
{
    PIMAGE_SECTION_HEADER SectionHeader;
    ULONG SectionIndex;
    PXBEIMAGE_LIBRARY_VERSION StartingLibraryVersion;
    PXBEIMAGE_LIBRARY_VERSION EndingLibraryVersion;
    PXBEIMAGE_LIBRARY_VERSION SourceLibraryVersion;
    PXBEIMAGE_LIBRARY_VERSION LibraryVersion;
    PXBEIMAGE_LIBRARY_VERSION XapiLibraryVersion;
    int ApprovedStatus = 2;

    ImgbXbeImageHeader->LibraryVersionHeader.XboxKernelOffset = MAXULONG;
    ImgbXbeImageHeader->LibraryVersionHeader.XapiOffset = MAXULONG;
    XapiLibraryVersion = NULL;

    SectionHeader = ImgbNameToSectionHeader(ImgbNtHeader, (PUCHAR)".xbld",
        &SectionIndex);

    if (SectionHeader != NULL) {

        //
        // The .XBLD section should be marked as discardable.  We're going to
        // duplicate it in the headers section so that we don't need to worry
        // about tracking this informational section at runtime.
        //
        // Because this image may have been incrementally linked, we're going
        // to need to make a copy of the version stamps so that we can
        // compress out the empty space
        //
        
        StartingLibraryVersion = (PXBEIMAGE_LIBRARY_VERSION)
            ImgbAllocateMemory(SectionHeader->Misc.VirtualSize);
        
        //
        // Compute the starting and ending pointers to the library versions.
        //

        SourceLibraryVersion =
            (PXBEIMAGE_LIBRARY_VERSION)ImgbVirtualAddressToData(ImgbNtHeader,
            SectionHeader->VirtualAddress);
        EndingLibraryVersion = (PXBEIMAGE_LIBRARY_VERSION)
            ((PUCHAR)SourceLibraryVersion + (SectionHeader->Misc.VirtualSize));

        ImgbXbeImageHeader->LibraryVersionHeader.LibraryVersions =
            StartingLibraryVersion;

        //
        // Walk through the library versions and cache the offsets to the
        // XBOXKRNL and XAPI libraries.
        //

        LibraryVersion = StartingLibraryVersion;

        while (SourceLibraryVersion + 1 <= EndingLibraryVersion) {

            if(*(PULONG)SourceLibraryVersion == 0) {

                //
                // Filler from the ilink.  Skip one dword and try again
                //

                SourceLibraryVersion = (PXBEIMAGE_LIBRARY_VERSION)
                    ((ULONG_PTR)SourceLibraryVersion + sizeof(ULONG));
                continue;
            }

            memcpy(LibraryVersion, SourceLibraryVersion,
                sizeof(XBEIMAGE_LIBRARY_VERSION));
            ++SourceLibraryVersion;

            if (memcmp(LibraryVersion->LibraryName, "XBOXKRNL", XBEIMAGE_LIBRARY_VERSION_NAME_LENGTH) == 0) {
                ImgbXbeImageHeader->LibraryVersionHeader.XboxKernelOffset =
                    (PUCHAR)LibraryVersion - (PUCHAR)StartingLibraryVersion;
            }

            if ((memcmp(LibraryVersion->LibraryName, "XAPILIB\0", XBEIMAGE_LIBRARY_VERSION_NAME_LENGTH) == 0) ||
                (memcmp(LibraryVersion->LibraryName, "XAPILIBD", XBEIMAGE_LIBRARY_VERSION_NAME_LENGTH) == 0)) {
                ImgbXbeImageHeader->LibraryVersionHeader.XapiOffset =
                    (PUCHAR)LibraryVersion - (PUCHAR)StartingLibraryVersion;
                XapiLibraryVersion = LibraryVersion;
            }

            LibraryVersion++;
        }

        ImgbXbeImageHeader->ImageHeader.NumberOfLibraryVersions =
            LibraryVersion - StartingLibraryVersion;
        ImgbXbeImageHeader->LibraryVersionHeader.VirtualSize =
            (PUCHAR)LibraryVersion - (PUCHAR)StartingLibraryVersion;


        //
        // Check the library approval status
        //

        ApprovedStatus = CheckLibraryApprovalStatus(XapiLibraryVersion,
            StartingLibraryVersion, LibraryVersion -
            StartingLibraryVersion, ImgbPrintUnapprovedLibraryWarning);

        //
        // Attach the library version header to the list of headers.
        //

        InsertTailList(&ImgbXbeImageHeader->HeadersListHead,
            &ImgbXbeImageHeader->LibraryVersionHeader.HeadersListEntry);
    }

    //
    // If we didn't find a library version for the kernel or XAPI, then print
    // out a warning.
    //

    if (ImgbXbeImageHeader->LibraryVersionHeader.XboxKernelOffset == MAXULONG) {
        ImgbResourcePrintWarning(IDS_NO_VERSION_DETECTED, "XBOXKRNL");
    }

    if (ImgbXbeImageHeader->LibraryVersionHeader.XapiOffset == MAXULONG) {
        ImgbResourcePrintWarning(IDS_NO_VERSION_DETECTED, "XAPI");
    }

    //
    // Check to see whether we're linking to any imports other than the kernel
    //

    if(!ImgbNoWarnLibraryApproval &&
        ImgbXbeImageHeader->ImportDescriptorHeader.VirtualSize != 0)
    {
        ImgbResourcePrintWarning(IDS_UNAPPROVED, "<debug extension import>");
        ApprovedStatus = 0;
    }

    //
    // If we're linking to any unapproved libraries, the print out a warning
    //

    if(ApprovedStatus < 2 && !ImgbNoWarnLibraryApproval)
        ImgbResourcePrintWarning(IDS_APPROVAL);
}

VOID
ImgbAddDebugPaths(
    VOID
    )
{
    //
    // Compute the size of the header.  We need enough space to write out the
    // full file path as an 8-bit null-terminated string and the file name as a
    // null-terminated Unicode string.
    //

    ImgbXbeImageHeader->DebugPathsHeader.VirtualSize =
        ((strlen(ImgbInputFileFullPath) + 1) * sizeof(CHAR)) +
        ((strlen(ImgbInputFileFilePart) + 1) * sizeof(WCHAR));

    //
    // Attach the debug paths header to the list of headers.
    //

    InsertTailList(&ImgbXbeImageHeader->HeadersListHead,
        &ImgbXbeImageHeader->DebugPathsHeader.HeadersListEntry);
}

VOID
ImgbCheckDuplicateInsertFileSection(
    PIMGB_INSERTFILE CheckInsertFileLink
    )
{
    PLIST_ENTRY NextListEntry;
    PIMGB_INSERTFILE InsertFileLink;
    PIMAGE_SECTION_HEADER SectionHeader;
    ULONG SectionsRemaining;
    UCHAR SectionName[IMAGE_SIZEOF_SHORT_NAME + 1];

    //
    // Check the list of insert files for a duplicate.  Only check as far as the
    // supplied node.
    //

    NextListEntry = ImgbInsertFileList.Flink;

    while (NextListEntry != &CheckInsertFileLink->ListEntry) {

        InsertFileLink = CONTAINING_RECORD(NextListEntry, IMGB_INSERTFILE,
            ListEntry);

        if (_stricmp(InsertFileLink->SectionName, CheckInsertFileLink->SectionName) == 0) {
            ImgbResourcePrintErrorAndExit(IDS_INSERTFILE_CONFLICTING_NAME,
                CheckInsertFileLink->SectionName);
        }

        NextListEntry = InsertFileLink->ListEntry.Flink;
    }

    //
    // Check the executable sections for a duplicate.
    //

    SectionHeader = IMAGE_FIRST_SECTION(ImgbNtHeader);
    SectionsRemaining = ImgbNtHeader->FileHeader.NumberOfSections;

    while (SectionsRemaining) {

        memcpy(SectionName, SectionHeader->Name, IMAGE_SIZEOF_SHORT_NAME);
        SectionName[IMAGE_SIZEOF_SHORT_NAME] = '\0';

        if (_stricmp((PSTR)SectionName, CheckInsertFileLink->SectionName) == 0) {
            ImgbResourcePrintErrorAndExit(IDS_INSERTFILE_CONFLICTING_EXE,
                CheckInsertFileLink->SectionName);
        }

        SectionHeader++;
        SectionsRemaining--;
    }
}

VOID
ImgbProcessInsertFiles(
    VOID
    )
{
    PLIST_ENTRY NextListEntry;
    PIMGB_INSERTFILE InsertFileLink;
    ULONG RelativeLoadAddress;
    ULONG AlignedFileSize;

    //
    // Bail out early if there's no files to be inserted.
    //

    if (IsListEmpty(&ImgbInsertFileList)) {
        return;
    }

    //
    // Check for duplicate section names.  Search both the list of executable
    // sections that we're going to keep in the file and the list of files that
    // we're to insert.
    //

    NextListEntry = ImgbInsertFileList.Flink;

    while (NextListEntry != &ImgbInsertFileList) {

        InsertFileLink = CONTAINING_RECORD(NextListEntry, IMGB_INSERTFILE,
            ListEntry);

        ImgbCheckDuplicateInsertFileSection(InsertFileLink);

        NextListEntry = InsertFileLink->ListEntry.Flink;
    }

    //
    // Open each of the /INSERTFILE sections and get the size of the file.
    //

    RelativeLoadAddress = ImgbXbeImageHeader->SizeOfExecutableImage;
    NextListEntry = ImgbInsertFileList.Flink;

    while (NextListEntry != &ImgbInsertFileList) {

        InsertFileLink = CONTAINING_RECORD(NextListEntry, IMGB_INSERTFILE,
            ListEntry);

        //
        // If we don't already know that the section is a no preload section,
        // then go check the no preload list.
        //

        if (!InsertFileLink->NoPreload) {
            InsertFileLink->NoPreload = ImgbSearchNoPreloadList(InsertFileLink->SectionName);
        }

        //
        // Open the /INSERTFILE section.
        //

        InsertFileLink->FileHandle = CreateFile(InsertFileLink->FilePath,
            GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN,
            NULL);

        if (InsertFileLink->FileHandle == INVALID_HANDLE_VALUE) {
            ImgbResourcePrintErrorAndExit(IDS_CANNOT_OPEN_INPUT_FILE,
                InsertFileLink->FilePath);
        }

        //
        // Get the raw size of the /INSERTFILE section.
        //

        InsertFileLink->FileSize = GetFileSize(InsertFileLink->FileHandle, NULL);

        if (InsertFileLink->FileSize == INVALID_FILE_SIZE) {
            ImgbResourcePrintErrorAndExit(IDS_CANNOT_READ_INPUT_FILE,
                InsertFileLink->FilePath);
        }

        AlignedFileSize = (InsertFileLink->FileSize +
            IMGB_INSERTFILE_SECTION_ALIGNMENT - 1) & ~(IMGB_INSERTFILE_SECTION_ALIGNMENT - 1);

        //
        // Verify that adding this file doesn't throw us over the maximum
        // allowed size for an XBE image.
        //

        if ((ULONGLONG)RelativeLoadAddress + AlignedFileSize > IMGB_MAXIMUM_IMAGE_SIZE) {
            ImgbResourcePrintErrorAndExit(IDS_IMAGE_TOO_LARGE);
        }

        //
        // Increment the number of XBE sections.
        //

        ImgbXbeImageHeader->ImageHeader.NumberOfSections++;

        //
        // Increment the number of /INSERTFILE sections.
        //

        ImgbXbeImageHeader->SectionHeaders.NumberOfInsertFileSections++;

        //
        // Add the size of the section name to the total for the XBE section
        // header.
        //

        ImgbXbeImageHeader->SectionHeaders.SizeOfSectionNames +=
            strlen((PSTR)InsertFileLink->SectionName) + 1;

        //
        // If the section does not start on the same page as the last section,
        // then we'll need another shared page reference counter.
        //

        if (PAGE_ALIGN(RelativeLoadAddress) != PAGE_ALIGN(RelativeLoadAddress - 1)) {
            ImgbXbeImageHeader->SectionHeaders.NumberOfSharedPageReferenceCounts++;
        }

        //
        // If the inclusive ending byte of the section isn't on the same
        // page as the starting byte of the section, then we'll need another
        // shared page reference counter.
        //

        if (PAGE_ALIGN(RelativeLoadAddress) !=
            PAGE_ALIGN(RelativeLoadAddress + AlignedFileSize - 1)) {
            ImgbXbeImageHeader->SectionHeaders.NumberOfSharedPageReferenceCounts++;
        }

        RelativeLoadAddress += AlignedFileSize;

        NextListEntry = InsertFileLink->ListEntry.Flink;
    }

    ImgbXbeImageHeader->SizeOfInsertFilesImage = RelativeLoadAddress -
        ImgbXbeImageHeader->SizeOfExecutableImage;
}

VOID
ImgbLayoutOutputHeaders(
    VOID
    )
{
    ULONG SizeOfHeaders;
    PLIST_ENTRY NextListEntry;
    PIMGB_GENERIC_HEADER GenericHeader;

    //
    // Compute the size of the base image header.
    //

    SizeOfHeaders = sizeof(XBEIMAGE_HEADER);

    //
    // Walk through each of the headers and assign them base addresses.
    //

    NextListEntry = ImgbXbeImageHeader->HeadersListHead.Flink;

    while (NextListEntry != &ImgbXbeImageHeader->HeadersListHead) {

        GenericHeader = CONTAINING_RECORD(NextListEntry, IMGB_GENERIC_HEADER,
            HeadersListEntry);

        //
        // Compute how many bytes this portion of the header contributes to the
        // overall header.
        //

        if (GenericHeader->VirtualSize != 0) {

            //
            // Align the total header size up to a DWORD boundary.
            //

            SizeOfHeaders = (SizeOfHeaders + sizeof(DWORD) - 1) & (~(sizeof(DWORD) - 1));

            //
            // Assign this header its base address.
            //

            GenericHeader->VirtualAddress =
                (LPBYTE)XBEIMAGE_STANDARD_BASE_ADDRESS + SizeOfHeaders;

            //
            // Add this header's contribution to the total header size.
            //

            SizeOfHeaders += GenericHeader->VirtualSize;

        } else {
            GenericHeader->VirtualAddress = 0;
        }

        NextListEntry = GenericHeader->HeadersListEntry.Flink;
    }

    //
    // Align the total header size up to a DWORD boundary.
    //

    SizeOfHeaders = (SizeOfHeaders + sizeof(DWORD) - 1) & (~(sizeof(DWORD) - 1));

    //
    // Store the total size of the image headers back in the main image header.
    //

    ImgbXbeImageHeader->ImageHeader.SizeOfHeaders = SizeOfHeaders;

    //
    // Compute the number of bytes required to map the header, the executable
    // sections, and the /INSERTFILE sections.
    //

    ImgbXbeImageHeader->ImageHeader.SizeOfImage =
        ROUND_TO_PAGES(ImgbXbeImageHeader->ImageHeader.SizeOfHeaders) +
        ImgbXbeImageHeader->SizeOfExecutableImage +
        ImgbXbeImageHeader->SizeOfInsertFilesImage;

    if (ImgbXbeImageHeader->ImageHeader.SizeOfImage > IMGB_MAXIMUM_IMAGE_SIZE) {
        ImgbResourcePrintErrorAndExit(IDS_IMAGE_TOO_LARGE);
    }

    //
    // If there were any contributions to the secondary headers, then place the
    // virtual addresses of these headers in the main image header.
    //

    if (ImgbXbeImageHeader->CertificateHeader.VirtualSize != 0) {
        ImgbXbeImageHeader->ImageHeader.Certificate = (PXBEIMAGE_CERTIFICATE)
            ImgbXbeImageHeader->CertificateHeader.VirtualAddress;
    }

    if (ImgbXbeImageHeader->SectionHeaders.VirtualSize != 0) {
        ImgbXbeImageHeader->ImageHeader.SectionHeaders =
            (PXBEIMAGE_SECTION)ImgbXbeImageHeader->SectionHeaders.VirtualAddress;
    }

    if (ImgbXbeImageHeader->ImportDescriptorHeader.VirtualSize != 0) {
        ImgbXbeImageHeader->ImageHeader.ImportDirectory =
            (PXBEIMAGE_IMPORT_DESCRIPTOR)ImgbXbeImageHeader->ImportDescriptorHeader.VirtualAddress;
    }

    if (ImgbXbeImageHeader->LibraryVersionHeader.VirtualSize != 0) {

        ImgbXbeImageHeader->ImageHeader.LibraryVersions =
            (PXBEIMAGE_LIBRARY_VERSION)ImgbXbeImageHeader->LibraryVersionHeader.VirtualAddress;

        if (ImgbXbeImageHeader->LibraryVersionHeader.XboxKernelOffset != MAXULONG) {
            ImgbXbeImageHeader->ImageHeader.XboxKernelLibraryVersion = (PXBEIMAGE_LIBRARY_VERSION)
                ((ULONG)ImgbXbeImageHeader->LibraryVersionHeader.VirtualAddress +
                ImgbXbeImageHeader->LibraryVersionHeader.XboxKernelOffset);
        }

        if (ImgbXbeImageHeader->LibraryVersionHeader.XapiOffset != MAXULONG) {
            ImgbXbeImageHeader->ImageHeader.XapiLibraryVersion = (PXBEIMAGE_LIBRARY_VERSION)
                ((ULONG)ImgbXbeImageHeader->LibraryVersionHeader.VirtualAddress +
                ImgbXbeImageHeader->LibraryVersionHeader.XapiOffset);
        }
    }

    if (ImgbXbeImageHeader->DebugPathsHeader.VirtualSize != 0) {

        ImgbXbeImageHeader->ImageHeader.DebugUnicodeFileName = (PWCHAR)
            (PWCHAR)ImgbXbeImageHeader->DebugPathsHeader.VirtualAddress;

        ImgbXbeImageHeader->ImageHeader.DebugPathName = (PUCHAR)
            ((ULONG)ImgbXbeImageHeader->DebugPathsHeader.VirtualAddress +
            (strlen(ImgbInputFileFilePart) + 1) * sizeof(WCHAR));

        ImgbXbeImageHeader->ImageHeader.DebugFileName =
            ImgbXbeImageHeader->ImageHeader.DebugPathName +
            (ImgbInputFileFilePart - ImgbInputFileFullPath);
    }

    if (ImgbXbeImageHeader->MicrosoftLogoHeader.VirtualSize != 0) {
        ImgbXbeImageHeader->ImageHeader.MicrosoftLogo = (PVOID)
            ImgbXbeImageHeader->MicrosoftLogoHeader.VirtualAddress;
        ImgbXbeImageHeader->ImageHeader.SizeOfMicrosoftLogo =
            ImgbXbeImageHeader->MicrosoftLogoHeader.VirtualSize;
    }
}

VOID
ImgbAddPEHeader(
    VOID
    )
{
    ULONG SizeOfNtHeaders;
    ULONG AdjustedSizeOfHeaders;

    //
    // Compute the number of bytes we'll need to store in the image in order to
    // add the NT header.  The size is counted as the number of bytes to the
    // first header, not the number of bytes stored in the header itself.
    //

    SizeOfNtHeaders = IMAGE_FIRST_SECTION(ImgbNtHeader)->VirtualAddress;

    if (ImgbEmitPEHeader) {

        //
        // The first section will start on a page boundary.  Take the current size
        // of the headers, add in the number of bytes required for the PE header,
        // and round that up to the page boundary.
        //

        AdjustedSizeOfHeaders =
            ROUND_TO_PAGES(ImgbXbeImageHeader->ImageHeader.SizeOfHeaders + SizeOfNtHeaders);

        ImgbXbeImageHeader->ImageHeader.SizeOfHeaders = AdjustedSizeOfHeaders;

        //
        // Compute the virtual size of the PE headers.  These are placed
        // immediately before the first executable section's data.
        //

        ImgbXbeImageHeader->PEHeaderHeader.VirtualSize = SizeOfNtHeaders;

        //
        // Attach the PE header to the list of headers.
        //

        InsertTailList(&ImgbXbeImageHeader->HeadersListHead,
            &ImgbXbeImageHeader->PEHeaderHeader.HeadersListEntry);

        //
        // Compute the number of bytes required to map the header, the executable
        // sections, and the /INSERTFILE sections.
        //

        ImgbXbeImageHeader->ImageHeader.SizeOfImage =
            ROUND_TO_PAGES(ImgbXbeImageHeader->ImageHeader.SizeOfHeaders) +
            ImgbXbeImageHeader->SizeOfExecutableImage +
            ImgbXbeImageHeader->SizeOfInsertFilesImage;

        if (ImgbXbeImageHeader->ImageHeader.SizeOfImage > IMGB_MAXIMUM_IMAGE_SIZE) {
            ImgbResourcePrintErrorAndExit(IDS_IMAGE_TOO_LARGE);
        }

    } else {
        AdjustedSizeOfHeaders =
            ROUND_TO_PAGES(ImgbXbeImageHeader->ImageHeader.SizeOfHeaders);
    }

    //
    // Store the address of the PE headers back in the XBE headers.
    //

    ImgbXbeImageHeader->ImageHeader.NtBaseOfDll =
        ImgbXbeImageHeader->PEHeaderHeader.VirtualAddress = (PVOID)
        (XBEIMAGE_STANDARD_BASE_ADDRESS + AdjustedSizeOfHeaders -
        SizeOfNtHeaders);
}

VOID
ImgbRelocateImageAfterHeaders(
    VOID
    )
{
    ULONG SizeOfHeadersPageAligned;
    ULONG NewBaseAddress;
    ULONG RelocationBytesRemaining;
    PIMAGE_BASE_RELOCATION RelocationBlock;

    //
    // Start sections on a page aligned byte offset from the headers.
    //

    SizeOfHeadersPageAligned = ROUND_TO_PAGES(ImgbXbeImageHeader->ImageHeader.SizeOfHeaders);

    //
    // Compute the new PE base address of the image.
    //

    NewBaseAddress = XBEIMAGE_STANDARD_BASE_ADDRESS + SizeOfHeadersPageAligned -
        IMAGE_FIRST_SECTION(ImgbNtHeader)->VirtualAddress;

    //
    // Verify that the image still has its relocation records.
    //

    RelocationBytesRemaining = ImgbNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;

    if (RelocationBytesRemaining == 0) {
        ImgbResourcePrintErrorAndExit(IDS_MISSING_RELOCATIONS);
    }

    RelocationBlock = (PIMAGE_BASE_RELOCATION)ImgbImageDataDirectoryToData(ImgbNtHeader,
        IMAGE_DIRECTORY_ENTRY_BASERELOC);

    //
    // Relocate the image.
    //

    ImgbRelocateImage(ImgbNtHeader, (ULONG)ImgbNtHeader->OptionalHeader.ImageBase,
        NewBaseAddress, RelocationBlock, RelocationBytesRemaining);

    //
    // Relocate the addresses stored in the XBE image header.
    //

    if (ImgbXbeImageHeader->ImageHeader.AddressOfEntryPoint != NULL) {
        ImgbXbeImageHeader->ImageHeader.AddressOfEntryPoint = (PXBEIMAGE_ENTRY_POINT)
            ((ULONG)ImgbXbeImageHeader->ImageHeader.AddressOfEntryPoint + NewBaseAddress);
    }

    if (ImgbXbeImageHeader->ImageHeader.XboxKernelThunkData != NULL) {
        ImgbXbeImageHeader->ImageHeader.XboxKernelThunkData = (PIMAGE_THUNK_DATA)
            ((ULONG)ImgbXbeImageHeader->ImageHeader.XboxKernelThunkData + NewBaseAddress);
    }

    if (ImgbXbeImageHeader->ImageHeader.TlsDirectory != NULL) {

        ImgbXbeImageHeader->ImageHeader.TlsDirectory = (PIMAGE_TLS_DIRECTORY)
            ((ULONG)ImgbXbeImageHeader->ImageHeader.TlsDirectory + NewBaseAddress);

        //
        // Now that the image has been relocated, go back and change the
        // addresses of the raw thread data to point at the TLS raw data header.
        // Note that if all of the TLS data has been turned into zero fill, then
        // VirtualAddress and VirtualSize are zero and the following will cause
        // the pointers to be NULL.
        //

        ImgbXbeImageHeader->TlsRawDataHeader.TlsDirectory->StartAddressOfRawData =
            (ULONG)ImgbXbeImageHeader->TlsRawDataHeader.VirtualAddress;
        ImgbXbeImageHeader->TlsRawDataHeader.TlsDirectory->EndAddressOfRawData =
            (ULONG)ImgbXbeImageHeader->TlsRawDataHeader.VirtualAddress +
            ImgbXbeImageHeader->TlsRawDataHeader.VirtualSize;
    }

    //
    // Remember the base address for future fixups.
    //

    ImgbXbeImageHeader->NewBaseAddress = NewBaseAddress;
}

VOID
ImgbWriteOutputFile(
    LPCVOID lpvBuffer,
    DWORD cbNumberOfBytes
    )
{
    DWORD cbWritten;

    if (!WriteFile(ImgbOutputFileHandle, lpvBuffer, cbNumberOfBytes, &cbWritten,
        NULL) || (cbWritten != cbNumberOfBytes)) {
        ImgbResourcePrintErrorAndExit(IDS_CANNOT_WRITE_OUTPUT_FILE, ImgbOutputFilePath);
    }
}

VOID
ImgbSeekByteOutputFile(
    ULONG dwFileByteOffset
    )
{
    LARGE_INTEGER liByteOffset;

    liByteOffset.QuadPart = dwFileByteOffset;

    if (!SetFilePointerEx(ImgbOutputFileHandle, liByteOffset, NULL, FILE_BEGIN)) {
        ImgbResourcePrintErrorAndExit(IDS_CANNOT_WRITE_OUTPUT_FILE, ImgbOutputFilePath);
    }
}

VOID
ImgbReadOutputFile(
    LPVOID lpvBuffer,
    DWORD cbNumberOfBytes
    )
{
    DWORD cbRead;

    if (!ReadFile(ImgbOutputFileHandle, lpvBuffer, cbNumberOfBytes, &cbRead,
        NULL) || (cbRead != cbNumberOfBytes)) {
        ImgbResourcePrintErrorAndExit(IDS_CANNOT_WRITE_OUTPUT_FILE, ImgbOutputFilePath);
    }
}

VOID
ImgbReadInputFile(
    LPVOID lpvBuffer,
    DWORD cbNumberOfBytes
    )
{
    DWORD cbRead;

    if (!ReadFile(ImgbInputFileHandle, lpvBuffer, cbNumberOfBytes, &cbRead,
        NULL) || (cbRead != cbNumberOfBytes)) {
        ImgbResourcePrintErrorAndExit(IDS_CANNOT_READ_INPUT_FILE, ImgbInputFilePath);
    }
}

VOID
ImgbWriteZeroPadding(
    ULONG NumberOfBytes
    )
{
    BYTE Zeroes[1024];
    ULONG BytesThisPass;

    ZeroMemory(Zeroes, sizeof(Zeroes));

    while (NumberOfBytes > 0) {
        BytesThisPass = min(NumberOfBytes, sizeof(Zeroes));
        ImgbWriteOutputFile(Zeroes, BytesThisPass);
        NumberOfBytes -= BytesThisPass;
    }
}

VOID
ImgbSignImageHeaders(
    VOID
    )
{
    PUCHAR PrivateKeyData;
    PXBEIMAGE_HEADER ImageHeader;
    ULONG HeaderDigestLength;
    UCHAR HeaderDigest[XC_DIGEST_LEN];

    PrivateKeyData = ImgbPrivateKeyData;

    //
    // Allocate a buffer to hold all of the image headers.
    //

    ImageHeader = (PXBEIMAGE_HEADER)
        ImgbAllocateMemory(ImgbXbeImageHeader->ImageHeader.SizeOfHeaders);

    //
    // Read the image headers back from the output file.
    //

    ImgbSeekByteOutputFile(0);
    ImgbReadOutputFile(ImageHeader, ImgbXbeImageHeader->ImageHeader.SizeOfHeaders);

    //
    // The encrypted header digest starts at the field after the encrypted
    // header field in the main image header.
    //

    HeaderDigestLength = ImgbXbeImageHeader->ImageHeader.SizeOfHeaders -
        FIELD_OFFSET(XBEIMAGE_HEADER, BaseAddress);

    //
    // Calculate the SHA1 digest for the headers.
    //

    XCCalcDigest((PUCHAR)&ImageHeader->BaseAddress, HeaderDigestLength,
        HeaderDigest);

    ImgbFreeMemory(ImageHeader);

    //
    // Encrypt the header digest.
    //

    XCSignDigest(HeaderDigest, PrivateKeyData,
        ImgbXbeImageHeader->ImageHeader.EncryptedDigest);

    //
    // Write out the main image header with the encrypted header digest.
    //

    ImgbSeekByteOutputFile(0);
    ImgbWriteOutputFile(&ImgbXbeImageHeader->ImageHeader, sizeof(XBEIMAGE_HEADER));
}

VOID
ImgbConfoundHeaderData(
    VOID
    )
{
    ULONG *Key;

    //
    // Use part of the public key as the confounder
    //

    Key = (ULONG*)&ImgbPublicKeyData[128];

    //
    // Confound the image base address and the location of the kernel import
    // data
    //

    *(ULONG *)&ImgbXbeImageHeader->ImageHeader.AddressOfEntryPoint ^=
        Key[0] ^ Key[4];
    *(ULONG *)&ImgbXbeImageHeader->ImageHeader.XboxKernelThunkData ^=
        Key[1] ^ Key[2];
}

VOID
ImgbEmitOutputFile(
    VOID
    )
{
    PLIST_ENTRY NextListEntry;
    PIMGB_GENERIC_HEADER GenericHeader;

    //
    // Initialize the header bytes to zero.
    //

    ImgbSeekByteOutputFile(0);
    ImgbWriteZeroPadding(ImgbXbeImageHeader->ImageHeader.SizeOfHeaders);

    //
    // Walk through each of the headers and write them out.
    //

    NextListEntry = ImgbXbeImageHeader->HeadersListHead.Flink;

    while (NextListEntry != &ImgbXbeImageHeader->HeadersListHead) {

        GenericHeader = CONTAINING_RECORD(NextListEntry, IMGB_GENERIC_HEADER,
            HeadersListEntry);

        //
        // If this header is supposed to be emitted, then write it out.
        //

        if (GenericHeader->VirtualSize != 0) {
            ImgbSeekByteOutputFile((ULONG)GenericHeader->VirtualAddress -
                (ULONG)XBEIMAGE_STANDARD_BASE_ADDRESS);
            GenericHeader->Write();
        }

        NextListEntry = GenericHeader->HeadersListEntry.Flink;
    }

    //
    // Write out the main image header without the encrypted header digest.
    //

    ImgbSeekByteOutputFile(0);
    ImgbWriteOutputFile(&ImgbXbeImageHeader->ImageHeader, sizeof(XBEIMAGE_HEADER));

    //
    // Compute the digest of the image headers, encrypt the digest, and rewrite
    // the main image header with the encrypted header digest.
    //

    ImgbSignImageHeaders();
}

VOID
_IMGB_XBEIMAGE_CERTIFICATE_HEADER::Write(
    VOID
    )
{
    XBEIMAGE_CERTIFICATE Certificate;

    RtlZeroMemory(&Certificate, sizeof(Certificate));

    Certificate.OriginalSizeOfCertificate =
        Certificate.SizeOfCertificate = sizeof(XBEIMAGE_CERTIFICATE);
    Certificate.TimeDateStamp = ImgbXbeImageHeader->ImageHeader.TimeDateStamp;
    Certificate.TitleID = ImgbTestTitleID;
    Certificate.Version = ImgbVersion;
    Certificate.AllowedMediaTypes = ImgbTestAllowedMediaTypes;
    Certificate.GameRegion = ImgbTestGameRegion;
    Certificate.GameRatings = ImgbTestGameRatings;

    RtlCopyMemory(Certificate.TitleName, ImgbTestTitleName, sizeof(ImgbTestTitleName));
    RtlCopyMemory(Certificate.AlternateTitleIDs, ImgbTestAlternateTitleIDs,
        sizeof(ImgbTestAlternateTitleIDs));

    RtlCopyMemory(Certificate.LANKey, ImgbTestLANKey, XBEIMAGE_CERTIFICATE_KEY_LENGTH);
    RtlCopyMemory(Certificate.SignatureKey, ImgbTestSignatureKey, XBEIMAGE_CERTIFICATE_KEY_LENGTH);

    RtlCopyMemory(Certificate.AlternateSignatureKeys,
        ImgbTestAlternateSignatureKeys, sizeof(ImgbTestAlternateSignatureKeys));

    ImgbWriteOutputFile(&Certificate, sizeof(XBEIMAGE_CERTIFICATE));
}

VOID
_IMGB_XBEIMAGE_IMPORT_DESCRIPTOR_HEADER::Write(
    VOID
    )
{
    ULONG ImportDirectoryByteOffset;
    ULONG ImportDirectoryNameByteOffset;
    ULONG ImportDescriptorBytesRemaining;
    PIMAGE_IMPORT_DESCRIPTOR ImportDescriptor;
    LPCSTR ImageName;
    XBEIMAGE_IMPORT_DESCRIPTOR XbeImportDescriptor;
    WCHAR UnicodeImageName[MAX_PATH];

    //
    // Compute the byte offsets for the import directories and the start of the
    // import image names.
    //

    ImportDirectoryByteOffset = (ULONG)ImgbXbeImageHeader->ImportDescriptorHeader.VirtualAddress -
        XBEIMAGE_STANDARD_BASE_ADDRESS;
    ImportDirectoryNameByteOffset = ImportDirectoryByteOffset +
        (ImgbXbeImageHeader->ImportDescriptorHeader.NumberOfNonKernelImports + 1) *
        sizeof(XBEIMAGE_IMPORT_DESCRIPTOR);

    //
    // Walk through each of the import descriptors.
    //

    ImportDescriptorBytesRemaining =
        ImgbNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size;
    ImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)
        ImgbImageDataDirectoryToData(ImgbNtHeader, IMAGE_DIRECTORY_ENTRY_IMPORT);

    while (ImportDescriptorBytesRemaining >= sizeof(IMAGE_IMPORT_DESCRIPTOR)) {

        //
        // If we find the NULL import descriptor, then break out now.
        //

        if (ImportDescriptor->Characteristics == 0) {
            break;
        }

        //
        // If this isn't the kernel import, then add the import to the output
        // file.
        //

        ImageName = (LPCSTR)ImgbVirtualAddressToData(ImgbNtHeader, ImportDescriptor->Name);

        if (_stricmp(ImageName, "xboxkrnl.exe") != 0) {

            MultiByteToWideChar(CP_ACP, 0, ImageName, -1, UnicodeImageName,
                MAX_PATH);

            ImgbSeekByteOutputFile(ImportDirectoryNameByteOffset);
            ImgbWriteOutputFile(UnicodeImageName, wcslen(UnicodeImageName) * sizeof(WCHAR));

            XbeImportDescriptor.ImageThunkData =
                (PIMAGE_THUNK_DATA)(ImportDescriptor->FirstThunk +
                (ULONG)ImgbXbeImageHeader->NewBaseAddress);
            XbeImportDescriptor.ImageName = (PWCHAR)(ImportDirectoryNameByteOffset +
                XBEIMAGE_STANDARD_BASE_ADDRESS);

            ImgbSeekByteOutputFile(ImportDirectoryByteOffset);
            ImgbWriteOutputFile(&XbeImportDescriptor, sizeof(XBEIMAGE_IMPORT_DESCRIPTOR));

            ImportDirectoryByteOffset += sizeof(XBEIMAGE_IMPORT_DESCRIPTOR);
            ImportDirectoryNameByteOffset += (strlen(ImageName) + sizeof(UCHAR)) * sizeof(WCHAR);
        }

        //
        // Advance to the next import descriptor.
        //

        ImportDescriptor++;
        ImportDescriptorBytesRemaining -= sizeof(IMAGE_IMPORT_DESCRIPTOR);
    }

    //
    // Write out the terminating import descriptor.
    //

    XbeImportDescriptor.ImageThunkData = NULL;
    XbeImportDescriptor.ImageName = NULL;

    ImgbSeekByteOutputFile(ImportDirectoryByteOffset);
    ImgbWriteOutputFile(&XbeImportDescriptor, sizeof(XBEIMAGE_IMPORT_DESCRIPTOR));
}

VOID
_IMGB_TLS_RAW_DATA_HEADER::Write(
    VOID
    )
{
    ImgbWriteOutputFile(ImgbXbeImageHeader->TlsRawDataHeader.RawData,
        ImgbXbeImageHeader->TlsRawDataHeader.VirtualSize);
}

VOID
_IMGB_XBEIMAGE_LIBRARY_VERSION_HEADER::Write(
    VOID
    )
{
    ImgbWriteOutputFile(ImgbXbeImageHeader->LibraryVersionHeader.LibraryVersions,
        ImgbXbeImageHeader->LibraryVersionHeader.VirtualSize);
}

BOOLEAN
ImgbCheckForReadOnlyPage(
    PXBEIMAGE_SECTION SectionHeaders,
    ULONG VirtualAddress
    )
{
    ULONG Index;
    PXBEIMAGE_SECTION Section;
    ULONG StartingAddress;
    ULONG EndingAddress;

    //
    // Walk through the section headers and check if the virtual address is on a
    // page with contributions from a writeable section.
    //

    for (Index = 0, Section = SectionHeaders;
        Index < ImgbXbeImageHeader->ImageHeader.NumberOfSections;
        Index++, Section++) {

        //
        // Only consider sections that have bytes allocated to them and that are
        // writeable sections.
        //

        if ((Section->VirtualSize != 0) &&
            ((Section->SectionFlags & XBEIMAGE_SECTION_WRITEABLE) != 0)) {

            StartingAddress = (ULONG)PAGE_ALIGN(Section->VirtualAddress);
            EndingAddress = (ULONG)PAGE_ALIGN(Section->VirtualAddress +
                Section->VirtualSize + PAGE_SIZE - 1);

            if (StartingAddress <= VirtualAddress && VirtualAddress < EndingAddress) {
                return FALSE;
            }
        }
    }

    return TRUE;
}

VOID
ImgbPostProcessSectionHeaders(
    VOID
    )
{
    PXBEIMAGE_SECTION SectionHeaders;
    ULONG SectionHeaderByteOffset;
    ULONG Index;
    PXBEIMAGE_SECTION Section;

    SectionHeaders = (PXBEIMAGE_SECTION)
        ImgbAllocateMemory(ImgbXbeImageHeader->ImageHeader.NumberOfSections *
        sizeof(XBEIMAGE_SECTION));

    SectionHeaderByteOffset = (ULONG)ImgbXbeImageHeader->SectionHeaders.VirtualAddress -
         XBEIMAGE_STANDARD_BASE_ADDRESS;

    //
    // Read the headers that we've written already written out to the file.
    //

    ImgbSeekByteOutputFile(SectionHeaderByteOffset);
    ImgbReadOutputFile(SectionHeaders, ImgbXbeImageHeader->ImageHeader.NumberOfSections *
        sizeof(XBEIMAGE_SECTION));

    //
    // Walk through the section headers and apply the head and tail read-only
    // page flags.
    //

    for (Index = 0, Section = SectionHeaders;
        Index < ImgbXbeImageHeader->ImageHeader.NumberOfSections;
        Index++, Section++) {

        //
        // Only consider sections that have bytes allocated to them and that is
        // not a writeable section.
        //

        if ((Section->VirtualSize != 0) &&
            ((Section->SectionFlags & XBEIMAGE_SECTION_WRITEABLE) == 0)) {

            if (ImgbCheckForReadOnlyPage(SectionHeaders,
                Section->VirtualAddress)) {
                Section->SectionFlags |= XBEIMAGE_SECTION_HEAD_PAGE_READONLY;
            }

            if (ImgbCheckForReadOnlyPage(SectionHeaders,
                Section->VirtualAddress + Section->VirtualSize - 1)) {
                Section->SectionFlags |= XBEIMAGE_SECTION_TAIL_PAGE_READONLY;
            }
        }
    }

    //
    // Write the post processed headers back out to the file.
    //

    ImgbSeekByteOutputFile(SectionHeaderByteOffset);
    ImgbWriteOutputFile(SectionHeaders, ImgbXbeImageHeader->ImageHeader.NumberOfSections *
        sizeof(XBEIMAGE_SECTION));

    ImgbFreeMemory(SectionHeaders);
}

VOID
_IMGB_XBEIMAGE_SECTION_HEADERS::Write(
    VOID
    )
{
    ULONG SectionHeaderByteOffset;
    ULONG SectionHeaderNameByteOffset;
    ULONG FirstSectionBaseAddress;
    ULONG FileByteOffset;
    PULONG ImageFileByteOffsets;
    ULONG CurrentSection;
    PIMAGE_SECTION_HEADER SectionHeader;
    PVOID EndOfSectionData;
    ULONG RawDataRemaining;
    PLIST_ENTRY NextListEntry;
    PIMGB_NOPRELOAD NoPreloadLink;
    ULONG SectionIndex;
    UCHAR SectionName[IMAGE_SIZEOF_SHORT_NAME + 1];
    XBEIMAGE_SECTION XbeSection;
    PUSHORT SharedReferenceCount;
    PUSHORT EndingSharedReferenceCount;
    BOOLEAN FirstSharedReferenceCount;
    ULONG LastEndingVirtualAddress;
    PVOID SectionData;
    PIMGB_INSERTFILE InsertFileLink;
    ULONG InsertFileVirtualAddress;
    ULONG AlignedFileSize;
    ULONG FileBytesRemaining;
    ULONG FileBytesThisPass;
    A_SHA_CTX SHAHash;

    SectionHeaderByteOffset = (ULONG)ImgbXbeImageHeader->SectionHeaders.VirtualAddress -
         XBEIMAGE_STANDARD_BASE_ADDRESS;
    SectionHeaderNameByteOffset = SectionHeaderByteOffset +
        ImgbXbeImageHeader->ImageHeader.NumberOfSections * sizeof(XBEIMAGE_SECTION) +
        ImgbXbeImageHeader->SectionHeaders.NumberOfSharedPageReferenceCounts * sizeof(USHORT);

    //
    // Compute the base virtual address of the first section.
    //

    FirstSectionBaseAddress = XBEIMAGE_STANDARD_BASE_ADDRESS +
        ROUND_TO_PAGES(ImgbXbeImageHeader->ImageHeader.SizeOfHeaders) -
        IMAGE_FIRST_SECTION(ImgbNtHeader)->VirtualAddress;

    //
    // Allocate stack storage to hold the file byte offsets of each of the image
    // sections.
    //

    ImageFileByteOffsets = (PULONG)_alloca(ImgbXbeImageHeader->SectionHeaders.NumberOfExecutableSections * sizeof(ULONG));
    RtlZeroMemory(ImageFileByteOffsets, ImgbXbeImageHeader->SectionHeaders.NumberOfExecutableSections * sizeof(ULONG));

    //
    // The first image section will always start at the first page after the
    // image headers.
    //

    FileByteOffset = ROUND_TO_PAGES(ImgbXbeImageHeader->ImageHeader.SizeOfHeaders);

    //
    // Pass 1: Loop over all of the PRELOAD executable sections and assign file
    // byte offsets.
    //

    SectionHeader = IMAGE_FIRST_SECTION(ImgbNtHeader);

    for (CurrentSection = 0; CurrentSection < ImgbXbeImageHeader->SectionHeaders.NumberOfExecutableSections;
        CurrentSection++, SectionHeader++) {

        //
        // When building with a non-paged size alignment, the linker will always
        // expand a section that contains uninitialized data to its full size in
        // the PE file, so here, we try to recover the actual size of the raw
        // data by scanning backwards for the first non-zero byte.
        //

        if (SectionHeader->SizeOfRawData > 0) {

            EndOfSectionData = (PUCHAR)ImgbVirtualAddressToData(ImgbNtHeader,
                SectionHeader->VirtualAddress) + SectionHeader->SizeOfRawData;
            RawDataRemaining = SectionHeader->SizeOfRawData;

            //
            // Handle the first three misaligned bytes so that we can
            // efficiently check only DWORDs below.
            //

            while ((RawDataRemaining > 0) &&
                ((RawDataRemaining & (sizeof(ULONG) - 1)) != 0)) {

                if (*((PUCHAR)EndOfSectionData - 1) != 0) {
                    break;
                }

                EndOfSectionData = (PUCHAR)EndOfSectionData - 1;
                RawDataRemaining -= sizeof(UCHAR);
            }

            //
            // Handle the aligned DWORDs.
            //

            while (RawDataRemaining > sizeof(ULONG)) {

                if (*((PULONG)EndOfSectionData - 1) != 0) {
                    break;
                }

                EndOfSectionData = (PULONG)EndOfSectionData - 1;
                RawDataRemaining -= sizeof(ULONG);
            }

            SectionHeader->SizeOfRawData = RawDataRemaining;
        }

        if ((SectionHeader->Characteristics & IMAGE_SCN_MEM_PRELOAD) != 0) {

            ImageFileByteOffsets[CurrentSection] = FileByteOffset;
            FileByteOffset += ROUND_TO_PAGES(SectionHeader->SizeOfRawData);
        }
    }

    //
    // Pass 2: Loop over all of the PRELOAD /INSERTFILE sections and assign
    // fiel byte offsets.
    //

    NextListEntry = ImgbInsertFileList.Flink;

    while (NextListEntry != &ImgbInsertFileList) {

        InsertFileLink = CONTAINING_RECORD(NextListEntry, IMGB_INSERTFILE,
            ListEntry);

        if (!InsertFileLink->NoPreload) {

            InsertFileLink->FileByteOffset = FileByteOffset;

            FileByteOffset += ROUND_TO_PAGES(InsertFileLink->FileSize);
        }

        NextListEntry = InsertFileLink->ListEntry.Flink;
    }

    //
    // Pass 3: Loop over all of the NOPRELOAD sections and assign file byte
    // offsets.  NOPRELOAD sections are ordered in the file by the order they
    // were supplied by the user.
    //

    NextListEntry = ImgbNoPreloadList.Flink;

    while (NextListEntry != &ImgbNoPreloadList) {

        NoPreloadLink = CONTAINING_RECORD(NextListEntry, IMGB_NOPRELOAD,
            ListEntry);

        SectionHeader = ImgbNameToSectionHeader(ImgbNtHeader,
            (PUCHAR)NoPreloadLink->SectionName, &SectionIndex);

        if ((SectionHeader != NULL) &&
            (SectionIndex < ImgbXbeImageHeader->SectionHeaders.NumberOfExecutableSections) &&
            (ImageFileByteOffsets[SectionIndex] == 0)) {

            ImageFileByteOffsets[SectionIndex] = FileByteOffset;
            FileByteOffset += ROUND_TO_PAGES(SectionHeader->SizeOfRawData);
        }

        NextListEntry = NoPreloadLink->ListEntry.Flink;
    }

    //
    // Pass 4: Loop over all of the NOPRELOAD /INSERTFILE sections and assign
    // fiel byte offsets.
    //

    NextListEntry = ImgbInsertFileList.Flink;

    while (NextListEntry != &ImgbInsertFileList) {

        InsertFileLink = CONTAINING_RECORD(NextListEntry, IMGB_INSERTFILE,
            ListEntry);

        if (InsertFileLink->NoPreload) {

            InsertFileLink->FileByteOffset = FileByteOffset;

            FileByteOffset += ROUND_TO_PAGES(InsertFileLink->FileSize);
        }

        NextListEntry = InsertFileLink->ListEntry.Flink;
    }

    //
    // Compute the first pointer to the shared page reference counters.
    //

    SharedReferenceCount = (PUSHORT)((ULONG)ImgbXbeImageHeader->SectionHeaders.VirtualAddress +
        ImgbXbeImageHeader->ImageHeader.NumberOfSections * sizeof(XBEIMAGE_SECTION));
    EndingSharedReferenceCount = SharedReferenceCount +
        ImgbXbeImageHeader->SectionHeaders.NumberOfSharedPageReferenceCounts;
    FirstSharedReferenceCount = TRUE;

    //
    // Write out the executable sections.
    //

    LastEndingVirtualAddress = 0;
    SectionHeader = IMAGE_FIRST_SECTION(ImgbNtHeader);

    for (CurrentSection = 0; CurrentSection < ImgbXbeImageHeader->SectionHeaders.NumberOfExecutableSections;
        CurrentSection++, SectionHeader++) {

        if (SectionHeader->SizeOfRawData > 0) {
            SectionData = ImgbVirtualAddressToData(ImgbNtHeader, SectionHeader->VirtualAddress);
        } else {
            SectionData = NULL;
        }

        //
        // Write out the section.
        //

        ImgbSeekByteOutputFile(ImageFileByteOffsets[CurrentSection]);
        ImgbWriteOutputFile(SectionData, SectionHeader->SizeOfRawData);

        ImgbWriteZeroPadding(PAGE_SIZE - BYTE_OFFSET(SectionHeader->SizeOfRawData));

        //
        // Build the section name on the stack.
        //

        memcpy(SectionName, SectionHeader->Name, IMAGE_SIZEOF_SHORT_NAME);
        SectionName[IMAGE_SIZEOF_SHORT_NAME] = '\0';

        //
        // Write out the section name.
        //

        ImgbSeekByteOutputFile(SectionHeaderNameByteOffset);
        ImgbWriteOutputFile(SectionName, strlen((PSTR)SectionName) + 1);

        //
        // Build the section header.
        //

        XbeSection.VirtualAddress = SectionHeader->VirtualAddress +
            FirstSectionBaseAddress;
        XbeSection.VirtualSize = max(SectionHeader->SizeOfRawData,
            SectionHeader->Misc.VirtualSize);
        XbeSection.PointerToRawData = ImageFileByteOffsets[CurrentSection];
        XbeSection.SizeOfRawData = SectionHeader->SizeOfRawData;
        XbeSection.SectionName = (PUCHAR)(SectionHeaderNameByteOffset +
            XBEIMAGE_STANDARD_BASE_ADDRESS);
        XbeSection.SectionReferenceCount = 0;

        //
        // Compute the section flags.
        //

        XbeSection.SectionFlags = XBEIMAGE_SECTION_EXECUTABLE;

        if ((SectionHeader->Characteristics & IMAGE_SCN_MEM_WRITE) != 0) {
            XbeSection.SectionFlags |= XBEIMAGE_SECTION_WRITEABLE;
        }

        if ((SectionHeader->Characteristics & IMAGE_SCN_MEM_PRELOAD) != 0) {
            XbeSection.SectionFlags |= XBEIMAGE_SECTION_PRELOAD;
        }

        //
        // Compute the section digest.
        //

        XCCalcDigest((PUCHAR)SectionData, SectionHeader->SizeOfRawData, XbeSection.SectionDigest);

        //
        // Compute the pointers to the shared page reference counters for this
        // section.
        //

        if (!FirstSharedReferenceCount &&
            (PAGE_ALIGN(XbeSection.VirtualAddress) != PAGE_ALIGN(LastEndingVirtualAddress))) {
            SharedReferenceCount++;
        }

        XbeSection.HeadSharedPageReferenceCount = SharedReferenceCount;

        if (PAGE_ALIGN(XbeSection.VirtualAddress) !=
            PAGE_ALIGN(XbeSection.VirtualAddress + XbeSection.VirtualSize - 1)) {
            SharedReferenceCount++;
        }

        XbeSection.TailSharedPageReferenceCount = SharedReferenceCount;

        FirstSharedReferenceCount = FALSE;
        LastEndingVirtualAddress = XbeSection.VirtualAddress +
            XbeSection.VirtualSize - 1;

        //
        // Write out the section header.
        //

        ImgbSeekByteOutputFile(SectionHeaderByteOffset);
        ImgbWriteOutputFile(&XbeSection, sizeof(XBEIMAGE_SECTION));

        SectionHeaderByteOffset += sizeof(XBEIMAGE_SECTION);
        SectionHeaderNameByteOffset += strlen((PSTR)SectionName) + 1;
    }

    //
    // Write out the /INSERTFILE sections.
    //

    InsertFileVirtualAddress = XBEIMAGE_STANDARD_BASE_ADDRESS +
        ROUND_TO_PAGES(ImgbXbeImageHeader->ImageHeader.SizeOfHeaders) +
        ImgbXbeImageHeader->SizeOfExecutableImage;
    NextListEntry = ImgbInsertFileList.Flink;

    while (NextListEntry != &ImgbInsertFileList) {

        InsertFileLink = CONTAINING_RECORD(NextListEntry, IMGB_INSERTFILE,
            ListEntry);

        AlignedFileSize = (InsertFileLink->FileSize +
            IMGB_INSERTFILE_SECTION_ALIGNMENT - 1) & ~(IMGB_INSERTFILE_SECTION_ALIGNMENT - 1);

        //
        // Write out the section name.
        //

        ImgbSeekByteOutputFile(SectionHeaderNameByteOffset);
        ImgbWriteOutputFile(InsertFileLink->SectionName,
            strlen((PSTR)InsertFileLink->SectionName) + 1);

        //
        // Build the section header.
        //

        XbeSection.VirtualAddress = InsertFileVirtualAddress;
        XbeSection.VirtualSize = InsertFileLink->FileSize;
        XbeSection.PointerToRawData = InsertFileLink->FileByteOffset;
        XbeSection.SizeOfRawData = InsertFileLink->FileSize;
        XbeSection.SectionName = (PUCHAR)(SectionHeaderNameByteOffset +
            XBEIMAGE_STANDARD_BASE_ADDRESS);
        XbeSection.SectionReferenceCount = 0;

        //
        // Compute the section flags.
        //

        XbeSection.SectionFlags = XBEIMAGE_SECTION_INSERTFILE;

        if (!InsertFileLink->ReadOnly) {
            XbeSection.SectionFlags |= XBEIMAGE_SECTION_WRITEABLE;
        }

        if (!InsertFileLink->NoPreload) {
            XbeSection.SectionFlags |= XBEIMAGE_SECTION_PRELOAD;
        }

        //
        // Compute the pointers to the shared page reference counters for this
        // section.
        //

        if (!FirstSharedReferenceCount &&
            (PAGE_ALIGN(XbeSection.VirtualAddress) != PAGE_ALIGN(LastEndingVirtualAddress))) {
            SharedReferenceCount++;
        }

        XbeSection.HeadSharedPageReferenceCount = SharedReferenceCount;

        if (PAGE_ALIGN(XbeSection.VirtualAddress) !=
            PAGE_ALIGN(XbeSection.VirtualAddress + XbeSection.VirtualSize - 1)) {
            SharedReferenceCount++;
        }

        XbeSection.TailSharedPageReferenceCount = SharedReferenceCount;

        FirstSharedReferenceCount = FALSE;
        LastEndingVirtualAddress = XbeSection.VirtualAddress +
            XbeSection.VirtualSize - 1;

        //
        // Write out the section and compute the section digest.
        //

        ImgbSeekByteOutputFile(InsertFileLink->FileByteOffset);

        FileBytesRemaining = InsertFileLink->FileSize;

        A_SHAInit(&SHAHash);
        A_SHAUpdate(&SHAHash, (PUCHAR)&FileBytesRemaining, sizeof(ULONG));

        while (FileBytesRemaining > 0) {

            FileBytesThisPass = FileBytesRemaining >= sizeof(ImgbTransferBuffer) ?
                sizeof(ImgbTransferBuffer) : FileBytesRemaining;

            if (!ReadFile(InsertFileLink->FileHandle, ImgbTransferBuffer,
                FileBytesThisPass, &FileBytesThisPass, NULL)) {
                ImgbResourcePrintErrorAndExit(IDS_CANNOT_READ_INPUT_FILE,
                    InsertFileLink->FilePath);
            }

            A_SHAUpdate(&SHAHash, ImgbTransferBuffer, FileBytesThisPass);

            ImgbWriteOutputFile(ImgbTransferBuffer, FileBytesThisPass);

            FileBytesRemaining -= FileBytesThisPass;
        }

        ImgbWriteZeroPadding(PAGE_SIZE - BYTE_OFFSET(XbeSection.SizeOfRawData));

        A_SHAFinal(&SHAHash, XbeSection.SectionDigest);

        //
        // Write out the section header.
        //

        ImgbSeekByteOutputFile(SectionHeaderByteOffset);
        ImgbWriteOutputFile(&XbeSection, sizeof(XBEIMAGE_SECTION));

        SectionHeaderByteOffset += sizeof(XBEIMAGE_SECTION);
        SectionHeaderNameByteOffset += strlen((PSTR)InsertFileLink->SectionName) + 1;

        InsertFileVirtualAddress += AlignedFileSize;

        NextListEntry = InsertFileLink->ListEntry.Flink;
    }

    //
    // Verify that we didn't screw up the code that computed the number of
    // shared page reference counters.
    //

    if (SharedReferenceCount >= EndingSharedReferenceCount) {
        ImgbResourcePrintErrorAndExit(IDS_INTERNAL_TOOL_ERROR, __LINE__);
    }

    //
    // Apply any post processing to the section headers, such as finding
    // sections that have read-only head and tail pages.
    //

    ImgbPostProcessSectionHeaders();
}

VOID
_IMGB_DEBUG_PATHS_HEADER::Write(
    VOID
    )
{
    WCHAR FileNameUnicode[MAX_PATH];
    LPSTR pszTemp;
    LPWSTR pwszTemp;

    //
    // Convert the file name portion to "Unicode", which as far as the debugger
    // is concerned is only 16-bit wide versions of the ANSI characters.
    //

    pszTemp = ImgbInputFileFilePart;
    pwszTemp = FileNameUnicode;

    while (*pszTemp != '\0') {
        *pwszTemp++ = (WCHAR)*pszTemp++;
    }

    *pwszTemp = L'\0';

    //
    // Write out the strings.
    //

    ImgbWriteOutputFile(FileNameUnicode, (wcslen(FileNameUnicode) + 1) * sizeof(WCHAR));

    ImgbWriteOutputFile(ImgbInputFileFullPath, strlen(ImgbInputFileFullPath) + 1);
}

VOID
_IMGB_MICROSOFT_LOGO_HEADER::Write(
    VOID
    )
{
    ImgbWriteOutputFile(ImgbMicrosoftLogo, sizeof(ImgbMicrosoftLogo));
}

VOID
_IMGB_PEHEADER_HEADER::Write(
    VOID
    )
{
    PVOID OriginalNtHeader;

    //
    // The supplied NT header pointer is to a copy-on-write view of the file.
    // The headers may have been altered while preparing the XBE image, so we
    // want to go back to the original file and re-read the headers.
    //

    OriginalNtHeader = ImgbAllocateMemory(ImgbXbeImageHeader->PEHeaderHeader.VirtualSize);

    ImgbReadInputFile(OriginalNtHeader,
        ImgbXbeImageHeader->PEHeaderHeader.VirtualSize);

    ImgbWriteOutputFile(OriginalNtHeader,
        ImgbXbeImageHeader->PEHeaderHeader.VirtualSize);

    ImgbFreeMemory(OriginalNtHeader);
}

VOID
ImgbBuildOutputFile(
    VOID
    )
{
    PIMAGE_DOS_HEADER DosHeader;

    //
    // Verify that the input file is large enough to contain a DOS executable
    // header, that the DOS executable signature matches, and that the input
    // file is large enough to contain the NT headers.
    //

    DosHeader = (PIMAGE_DOS_HEADER)ImgbInputFileMappingView;

    if ((ImgbInputFileSize < sizeof(IMAGE_DOS_HEADER)) ||
        (DosHeader->e_magic != IMAGE_DOS_SIGNATURE) ||
        (ImgbInputFileSize < sizeof(IMAGE_NT_HEADERS) + (ULONG)DosHeader->e_lfanew)) {
        ImgbResourcePrintErrorAndExit(IDS_INVALID_CORRUPT_INPUT_FILE, ImgbInputFilePath);
    }

    //
    // Verify that the NT header and optional header signatures match.
    //

    ImgbNtHeader = (PIMAGE_NT_HEADERS)((LPBYTE)ImgbInputFileMappingView +
        (ULONG)DosHeader->e_lfanew);

    if ((ImgbNtHeader->Signature != IMAGE_NT_SIGNATURE) ||
        (ImgbNtHeader->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC)) {
        ImgbResourcePrintErrorAndExit(IDS_INVALID_CORRUPT_INPUT_FILE, ImgbInputFilePath);
    }

    //
    // Verify that the image was linked with /MACHINE:X86.
    //

    if (ImgbNtHeader->FileHeader.Machine != IMAGE_FILE_MACHINE_I386) {
        ImgbResourcePrintErrorAndExit(IDS_NOT_MACHINE_X86);
    }

    //
    // Verify that the image was linked with /SUBSYSTEM:XBOX.
    //

    if (ImgbNtHeader->OptionalHeader.Subsystem != IMAGE_SUBSYSTEM_XBOX) {
        ImgbResourcePrintErrorAndExit(IDS_NOT_SUBSYSTEM_XBOX);
    }

    //
    // Prepare the XBE image header.
    //

    ImgbXbeImageHeader = new IMGB_XBEIMAGE_HEADER;

    InitializeListHead(&ImgbXbeImageHeader->HeadersListHead);

    ImgbXbeImageHeader->ImageHeader.Signature = XBEIMAGE_SIGNATURE;
    ImgbXbeImageHeader->ImageHeader.BaseAddress = (PVOID)XBEIMAGE_STANDARD_BASE_ADDRESS;
    time((time_t *)&ImgbXbeImageHeader->ImageHeader.TimeDateStamp);
    ImgbXbeImageHeader->ImageHeader.SizeOfImageHeader = sizeof(XBEIMAGE_HEADER);
    ImgbXbeImageHeader->ImageHeader.AddressOfEntryPoint =
        (PXBEIMAGE_ENTRY_POINT)ImgbNtHeader->OptionalHeader.AddressOfEntryPoint;
    ImgbXbeImageHeader->ImageHeader.SizeOfStackCommit = (ImgbSizeOfStack != 0) ? ImgbSizeOfStack :
        ImgbNtHeader->OptionalHeader.SizeOfStackCommit;
    ImgbXbeImageHeader->ImageHeader.SizeOfHeapReserve = ImgbNtHeader->OptionalHeader.SizeOfHeapReserve;
    ImgbXbeImageHeader->ImageHeader.SizeOfHeapCommit = ImgbNtHeader->OptionalHeader.SizeOfHeapCommit;
    ImgbXbeImageHeader->ImageHeader.NtSizeOfImage = ImgbNtHeader->OptionalHeader.SizeOfImage;
    ImgbXbeImageHeader->ImageHeader.NtCheckSum = ImgbNtHeader->OptionalHeader.CheckSum;
    ImgbXbeImageHeader->ImageHeader.NtTimeDateStamp = ImgbNtHeader->FileHeader.TimeDateStamp;
    ImgbXbeImageHeader->ImageHeader.InitFlags = ImgbInitFlags;

    //
    // The XBE image certificate is a fixed size header.
    //

    ImgbXbeImageHeader->CertificateHeader.VirtualSize = sizeof(XBEIMAGE_CERTIFICATE);

    InsertTailList(&ImgbXbeImageHeader->HeadersListHead,
        &ImgbXbeImageHeader->CertificateHeader.HeadersListEntry);

    //
    // Process the section headers for the image.
    //

    ImgbProcessInputSectionHeaders();

    //
    // Process the import descriptors for the image.
    //

    ImgbProcessInputImportDescriptors();

    //
    // Process the thread local storage data directory entry for the image.
    //

    ImgbProcessInputTlsDirectory();

    //
    // Process the library versions section for the image.
    //

    ImgbProcessLibraryVersions();

    //
    // Add the debug paths strings to the image header.
    //

    ImgbAddDebugPaths();

    //
    // Always add the Microsoft logo to the image.
    //

    ImgbXbeImageHeader->MicrosoftLogoHeader.VirtualSize = sizeof(ImgbMicrosoftLogo);

    InsertTailList(&ImgbXbeImageHeader->HeadersListHead,
        &ImgbXbeImageHeader->MicrosoftLogoHeader.HeadersListEntry);

    //
    // Process the list of insert files for the image.
    //

    ImgbProcessInsertFiles();

    //
    // Compute the virtual size of the section headers.  No more sections may be
    // added or removed from the image.
    //

    ImgbXbeImageHeader->SectionHeaders.VirtualSize =
        ImgbXbeImageHeader->ImageHeader.NumberOfSections * sizeof(XBEIMAGE_SECTION) +
        ImgbXbeImageHeader->SectionHeaders.NumberOfSharedPageReferenceCounts * sizeof(USHORT) +
        ImgbXbeImageHeader->SectionHeaders.SizeOfSectionNames;

    //
    // Assign virtual addresses to the main image header and all of the
    // secondary headers.
    //

    ImgbLayoutOutputHeaders();

    //
    // Compute the size of the PE headers, and add them if the /PEHEADER switch
    // was explicitly set.
    //

    ImgbAddPEHeader();

    //
    // Relocate the image now that the size of all of the headers are known.
    //

    ImgbRelocateImageAfterHeaders();

    //
    // Confound basic data in the base header
    //
    
    ImgbConfoundHeaderData();

    //
    // Emit the output file.
    //

    ImgbEmitOutputFile();
}

void
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    //
    // Process the command line arguments.
    //

    ImgbProcessCommandLineOptions(argc, argv);

    //
    // Open the input and output files.
    //

    ImgbOpenInputOutputFiles();

    //
    // Build the output file.
    //

    ImgbBuildOutputFile();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagebld.new\dumpxbe.cpp ===
/*++

Copyright (c) 2001-2002  Microsoft Corporation

Module Name:

    dumpxbe.cpp

Abstract:

    This module implements a utility program to dump an Xbox executable image.

--*/

#include "imgbldp.h"

//
// Padding characters used when dumping indented lines.
//
const char ImgbDumpPadding[] = "   ";

const char *ImgbApprovedStatus[] = {
    "unapproved",
    "possibly approved",
    "approved",
    "expired"
};

LPSTR
ImgbGetDumpTimeStampString(
    PULONG TimeDateStamp
    )
{
    LPSTR pszTimeStampString;

    pszTimeStampString = ctime((time_t*)TimeDateStamp);

    if (pszTimeStampString == NULL) {
        pszTimeStampString = "invalid\n";
    }

    return pszTimeStampString;
}

LPSTR
ImgbGetDumpCertificateKeyString(
    PUCHAR CertificateKey
    )
{
    static CHAR Buffer[80];

    sprintf(Buffer, "%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X",
        CertificateKey[0], CertificateKey[1], CertificateKey[2], CertificateKey[3],
        CertificateKey[4], CertificateKey[5], CertificateKey[6], CertificateKey[7],
        CertificateKey[8], CertificateKey[9], CertificateKey[10], CertificateKey[11],
        CertificateKey[12], CertificateKey[13], CertificateKey[14], CertificateKey[15]);

    return Buffer;
}

LPVOID
ImgbGetDumpDataFromVirtualAddress(
    PXBEIMAGE_HEADER ImageHeader,
    PVOID VirtualAddress,
    ULONG NumberOfBytes
    )
{
    PXBEIMAGE_SECTION ImageSection;
    ULONG FileByteOffset;
    ULONG Index;

    //
    // Return a pointer to data in the image header if the virtual address
    // resides in the image header.
    //

    if (((ULONG)ImageHeader->BaseAddress <= (ULONG)VirtualAddress) &&
        ((ULONG)VirtualAddress + NumberOfBytes <= (ULONG)ImageHeader->BaseAddress +
            ImageHeader->SizeOfHeaders)) {

        FileByteOffset = (ULONG)VirtualAddress - (ULONG)ImageHeader->BaseAddress;

        if (FileByteOffset >= ImgbInputFileSize) {
            return NULL;
        }

        return (LPBYTE)ImageHeader + FileByteOffset;
    }

    //
    // Verify that the image has sections.
    //

    if (ImageHeader->NumberOfSections == 0) {
        return NULL;
    }

    //
    // Don't return anything if the section headers start past the end of the
    // file.
    //

    if (((ULONG)ImageHeader->SectionHeaders - (ULONG)ImageHeader->BaseAddress) >=
        ImgbInputFileSize) {
        return NULL;
    }

    //
    // Don't return anything if the section headers end past the end of the
    // file.
    //

    if (((ULONG)ImageHeader->SectionHeaders - (ULONG)ImageHeader->BaseAddress +
        (ImageHeader->NumberOfSections * sizeof(XBEIMAGE_SECTION))) >= ImgbInputFileSize) {
        return NULL;
    }

    //
    // Loop over all of the sections and return the address of the data that
    // maps the requested virtual address and size.
    //

    ImageSection = (PXBEIMAGE_SECTION)((LPBYTE)ImageHeader +
        (ULONG)ImageHeader->SectionHeaders - (ULONG)ImageHeader->BaseAddress);

    for (Index = 0; Index < ImageHeader->NumberOfSections; Index++) {

        if ((ImageSection->VirtualAddress <= (ULONG)VirtualAddress) &&
            ((ULONG)VirtualAddress + NumberOfBytes <= ImageSection->VirtualAddress +
                ImageSection->SizeOfRawData)) {

            FileByteOffset = ImageSection->PointerToRawData +
                ((ULONG)VirtualAddress - ImageSection->VirtualAddress);

            if (FileByteOffset >= ImgbInputFileSize) {
                return NULL;
            }

            return (LPBYTE)ImageHeader + FileByteOffset;
        }

        ImageSection++;
    }

    return NULL;
}

VOID
ImgbDumpXbeCertificate(
    PXBEIMAGE_HEADER ImageHeader
    )
{
    PXBEIMAGE_CERTIFICATE Certificate;
    ULONG Index;

    //
    // Verify that the image has a certificate.
    //

    if (ImageHeader->Certificate == NULL) {
        return;
    }

    //
    // Map the virtual address of the certificate to its memory mapped virtual
    // address.
    //

    Certificate = (PXBEIMAGE_CERTIFICATE)ImgbGetDumpDataFromVirtualAddress(
        ImageHeader, ImageHeader->Certificate, sizeof(XBEIMAGE_CERTIFICATE));

    if (Certificate == NULL) {
        return;
    }

    printf("CERTIFICATE\n");
    printf("%s%8X size of certificate\n", ImgbDumpPadding, Certificate->SizeOfCertificate);
    printf("%s%08X time date stamp %s", ImgbDumpPadding, Certificate->TimeDateStamp, ImgbGetDumpTimeStampString(&Certificate->TimeDateStamp));
    printf("%s%08X title id\n", ImgbDumpPadding, Certificate->TitleID);
    printf("%s%8X allowed media types\n", ImgbDumpPadding, Certificate->AllowedMediaTypes);
    printf("%s%8X game region\n", ImgbDumpPadding, Certificate->GameRegion);
    printf("%s%8X game ratings\n", ImgbDumpPadding, Certificate->GameRatings);
    printf("%s%8X disk number\n", ImgbDumpPadding, Certificate->DiskNumber);
    printf("%s%8X version\n", ImgbDumpPadding, Certificate->Version);

    if (Certificate->SizeOfCertificate > FIELD_OFFSET(XBEIMAGE_CERTIFICATE,
        OnlineServiceName)) {
        printf("%s%8X online service name\n", ImgbDumpPadding,
            Certificate->OnlineServiceName);
    }

    printf("\n");

    printf("   Title name: %ws\n\n", Certificate->TitleName);

    printf("      LAN key: %s\n", ImgbGetDumpCertificateKeyString(Certificate->LANKey));
    printf("Signature key: %s\n", ImgbGetDumpCertificateKeyString(Certificate->SignatureKey));
    printf("\n");

    if (Certificate->AlternateTitleIDs[0] != 0) {

        printf("Title alternate title ids:\n");

        for (Index = 0; Index < XBEIMAGE_ALTERNATE_TITLE_ID_COUNT; Index++) {

            if (Certificate->AlternateTitleIDs[Index] == 0) {
                break;
            }

            printf("%s%08x    Signature key: %s\n", ImgbDumpPadding, Certificate->AlternateTitleIDs[Index],
                ImgbGetDumpCertificateKeyString(Certificate->AlternateSignatureKeys[Index]));
        }

        printf("\n");
    }
}

VOID
ImgbAlterUnapprovedLibraryStatus(
    PXBEIMAGE_LIBRARY_VERSION LibraryVersion,
    int ApprovalLevel
    )
{
    LibraryVersion->ApprovedLibrary = (USHORT)ApprovalLevel;
}

VOID
ImgbDumpXbeLibraryVersions(
    PXBEIMAGE_HEADER ImageHeader
    )
{
    PXBEIMAGE_LIBRARY_VERSION LibraryVersion;
    PXBEIMAGE_LIBRARY_VERSION XapiLibraryVersion;
    ULONG Index;
    ULONG ApprovalStatus;

    //
    // Verify that the image has a library versions section.
    //

    if (ImageHeader->NumberOfLibraryVersions == 0) {
        return;
    }

    //
    // Map the virtual address of the library versions to its memory mapped
    // virtual address.
    //

    LibraryVersion = (PXBEIMAGE_LIBRARY_VERSION)ImgbGetDumpDataFromVirtualAddress(
        ImageHeader, ImageHeader->LibraryVersions,
        ImageHeader->NumberOfLibraryVersions * sizeof(XBEIMAGE_LIBRARY_VERSION));

    if (LibraryVersion == NULL) {
        return;
    }

    if (ImageHeader->XapiLibraryVersion != NULL) {
        XapiLibraryVersion = (PXBEIMAGE_LIBRARY_VERSION)ImgbGetDumpDataFromVirtualAddress(
            ImageHeader, ImageHeader->XapiLibraryVersion,
            sizeof(XBEIMAGE_LIBRARY_VERSION));
    } else {
        XapiLibraryVersion = NULL;
    }

    //
    // Use the check approval process to modify approved bits.
    //

    CheckLibraryApprovalStatus(XapiLibraryVersion, LibraryVersion,
        ImageHeader->NumberOfLibraryVersions, ImgbAlterUnapprovedLibraryStatus);

    printf("LIBRARY VERSIONS\n");

    for (Index = 0; Index < ImageHeader->NumberOfLibraryVersions; Index++) {
        ApprovalStatus = LibraryVersion->ApprovedLibrary;

        printf("%s%8.8s %d.%d.%d.%d%s [%s]\n", ImgbDumpPadding, LibraryVersion->LibraryName,
            LibraryVersion->MajorVersion, LibraryVersion->MinorVersion,
            LibraryVersion->BuildVersion, LibraryVersion->QFEVersion,
            (LibraryVersion->DebugBuild ? " [debug]" : ""),
            ImgbApprovedStatus[ApprovalStatus]);
        LibraryVersion++;
    }

    printf("\n");
}

VOID
ImgbDumpXbeImportDirectories(
    PXBEIMAGE_HEADER ImageHeader
    )
{
    PXBEIMAGE_IMPORT_DESCRIPTOR RawImportDescriptor;
    PXBEIMAGE_IMPORT_DESCRIPTOR ImportDescriptor;
    PWCHAR ImageName;

    //
    // Don't dump anything if the image doesn't import from an image other than
    // the kernel.
    //

    if (ImageHeader->ImportDirectory == NULL) {
        return;
    }

    //
    // Loop over all of the import modules and dump out the name.
    //

    printf("NON-KERNEL IMPORT MODULES\n");

    RawImportDescriptor = ImageHeader->ImportDirectory;

    for (;;) {

        ImportDescriptor = (PXBEIMAGE_IMPORT_DESCRIPTOR)ImgbGetDumpDataFromVirtualAddress(
            ImageHeader, RawImportDescriptor, sizeof(XBEIMAGE_IMPORT_DESCRIPTOR));

        if (ImportDescriptor == NULL) {
            break;
        }

        if (ImportDescriptor->ImageThunkData == NULL) {
            break;
        }

        ImageName = (PWCHAR)ImgbGetDumpDataFromVirtualAddress(ImageHeader,
            ImportDescriptor->ImageName, sizeof(WCHAR));

        if (ImageName == NULL) {
            break;
        }

        printf("%s%ws\n", ImgbDumpPadding, ImageName);

        RawImportDescriptor++;
    }

    printf("\n");
}

VOID
ImgbDumpXbeTlsDirectory(
    PXBEIMAGE_HEADER ImageHeader
    )
{
    PIMAGE_TLS_DIRECTORY TlsDirectory;

    //
    // Verify that the image has a TLS directory.
    //

    if (ImageHeader->TlsDirectory == NULL) {
        return;
    }

    //
    // Map the virtual address of the TLS directory to its memory mapped virtual
    // address.
    //

    TlsDirectory = (PIMAGE_TLS_DIRECTORY)ImgbGetDumpDataFromVirtualAddress(
        ImageHeader, ImageHeader->TlsDirectory, sizeof(IMAGE_TLS_DIRECTORY));

    if (TlsDirectory == NULL) {
        return;
    }

    printf("THREAD LOCAL STORAGE DIRECTORY\n");
    printf("%s%08X raw data start address\n", ImgbDumpPadding, TlsDirectory->StartAddressOfRawData);
    printf("%s%08X raw data end address\n", ImgbDumpPadding, TlsDirectory->EndAddressOfRawData);
    printf("%s%08X TLS index address\n", ImgbDumpPadding, TlsDirectory->AddressOfIndex);
    printf("%s%08X TLS callbacks address\n", ImgbDumpPadding, TlsDirectory->AddressOfCallBacks);
    printf("%s%8X size of zero fill\n", ImgbDumpPadding, TlsDirectory->SizeOfZeroFill);
    printf("%s%8X characteristics\n", ImgbDumpPadding, TlsDirectory->Characteristics);
    printf("\n");
}

VOID
ImgbDumpXbeSectionHeaders(
    PXBEIMAGE_HEADER ImageHeader
    )
{
    PXBEIMAGE_SECTION ImageSection;
    ULONG Index;
    LPCSTR SectionName;

    //
    // Verify that the image has sections.
    //

    if (ImageHeader->NumberOfSections == 0) {
        return;
    }

    //
    // Map the virtual address of the section headers to its memory mapped
    // virtual address.
    //

    ImageSection = (PXBEIMAGE_SECTION)ImgbGetDumpDataFromVirtualAddress(
        ImageHeader, ImageHeader->SectionHeaders,
        ImageHeader->NumberOfSections * sizeof(XBEIMAGE_SECTION));

    if (ImageSection == NULL) {
        return;
    }

    for (Index = 0; Index < ImageHeader->NumberOfSections; Index++) {

        SectionName = (LPCSTR)((LPBYTE)ImageHeader +
            (ULONG)ImageSection->SectionName - (ULONG)ImageHeader->BaseAddress);

        printf("SECTION HEADER #%d  %s\n", Index + 1, SectionName);
        printf("%s%8X virtual address\n", ImgbDumpPadding, ImageSection->VirtualAddress);
        printf("%s%8X virtual size\n", ImgbDumpPadding, ImageSection->VirtualSize);
        printf("%s%8X file pointer to raw data\n", ImgbDumpPadding, ImageSection->PointerToRawData);
        printf("%s%8X size of raw data\n", ImgbDumpPadding, ImageSection->SizeOfRawData);
        printf("%s%08X head shared page reference count address\n", ImgbDumpPadding, ImageSection->HeadSharedPageReferenceCount);
        printf("%s%08X tail shared page reference count address\n", ImgbDumpPadding, ImageSection->TailSharedPageReferenceCount);
        printf("%s%8X flags\n", ImgbDumpPadding, ImageSection->SectionFlags);

        if (ImageSection->SectionFlags & XBEIMAGE_SECTION_WRITEABLE) {
            printf("%s         Writeable\n", ImgbDumpPadding);
        }
        if (ImageSection->SectionFlags & XBEIMAGE_SECTION_PRELOAD) {
            printf("%s         Preload\n", ImgbDumpPadding);
        }
        if (ImageSection->SectionFlags & XBEIMAGE_SECTION_EXECUTABLE) {
            printf("%s         Executable\n", ImgbDumpPadding);
        }
        if (ImageSection->SectionFlags & XBEIMAGE_SECTION_INSERTFILE) {
            printf("%s         Inserted file\n", ImgbDumpPadding);
        }
        if (ImageSection->SectionFlags & XBEIMAGE_SECTION_HEAD_PAGE_READONLY) {
            printf("%s         Head page read-only\n", ImgbDumpPadding);
        }
        if (ImageSection->SectionFlags & XBEIMAGE_SECTION_TAIL_PAGE_READONLY) {
            printf("%s         Tail page read-only\n", ImgbDumpPadding);
        }

        printf("\n");

        ImageSection++;
    }
}

VOID
ImgbDumpXbeImageHeader(
    VOID
    )
{
    PXBEIMAGE_HEADER ImageHeader;

    //
    // Validate that the file is large enough to contain the base portion of the
    // image header.
    //

    if (ImgbInputFileSize < sizeof(XBEIMAGE_HEADER)) {
        ImgbResourcePrintErrorAndExit(IDS_INVALID_CORRUPT_INPUT_FILE, ImgbInputFilePath);
    }

    //
    // Validate the signature.
    //

    ImageHeader = (PXBEIMAGE_HEADER)ImgbInputFileMappingView;

    if (ImageHeader->Signature != XBEIMAGE_SIGNATURE) {
        ImgbResourcePrintErrorAndExit(IDS_INVALID_CORRUPT_INPUT_FILE, ImgbInputFilePath);
    }

    //
    // Dump the image header fields.
    //

    printf("IMAGE HEADER VALUES\n");
    printf("%s%08X base address\n", ImgbDumpPadding, ImageHeader->BaseAddress);
    printf("%s%8X size of headers\n", ImgbDumpPadding, ImageHeader->SizeOfHeaders);
    printf("%s%8X size of image\n", ImgbDumpPadding, ImageHeader->SizeOfImage);
    printf("%s%8X size of image header\n", ImgbDumpPadding, ImageHeader->SizeOfImageHeader);
    printf("%s%08X time date stamp %s", ImgbDumpPadding, ImageHeader->TimeDateStamp, ImgbGetDumpTimeStampString(&ImageHeader->TimeDateStamp));
    printf("%s%08X certificate address\n", ImgbDumpPadding, ImageHeader->Certificate);
    printf("%s%8X number of sections\n", ImgbDumpPadding, ImageHeader->NumberOfSections);
    printf("%s%08X section headers address\n", ImgbDumpPadding, ImageHeader->SectionHeaders);
    printf("%s%8X initialization flags\n", ImgbDumpPadding, ImageHeader->InitFlags);
    if (ImageHeader->InitFlags & XINIT_MOUNT_UTILITY_DRIVE) {
        printf("%s         Mount utility drive\n", ImgbDumpPadding);
    }
    if (ImageHeader->InitFlags & XINIT_FORMAT_UTILITY_DRIVE) {
        printf("%s         Format utility drive\n", ImgbDumpPadding);
    }
    if (ImageHeader->InitFlags & XINIT_LIMIT_DEVKIT_MEMORY) {
        printf("%s         Limit development kit memory\n", ImgbDumpPadding);
    }
    if (ImageHeader->InitFlags & XINIT_NO_SETUP_HARD_DISK) {
        printf("%s         Don't setup hard disk\n", ImgbDumpPadding);
    }
    if (ImageHeader->InitFlags & XINIT_DONT_MODIFY_HARD_DISK) {
        printf("%s         Don't modify hard disk\n", ImgbDumpPadding);
    }
    printf("%s         %dK utility drive cluster size\n", ImgbDumpPadding,
        (16 << ((ImageHeader->InitFlags & XINIT_UTILITY_DRIVE_CLUSTER_SIZE_MASK) >>
        XINIT_UTILITY_DRIVE_CLUSTER_SIZE_SHIFT)));
    printf("%s%08X entry point address\n", ImgbDumpPadding, ImageHeader->AddressOfEntryPoint);
    printf("%s%08X thread local storage directory address\n", ImgbDumpPadding, ImageHeader->TlsDirectory);
    printf("%s%8X size of stack commit\n", ImgbDumpPadding, ImageHeader->SizeOfStackCommit);
    printf("%s%8X size of heap commit\n", ImgbDumpPadding, ImageHeader->SizeOfHeapCommit);
    printf("%s%8X size of heap reserve\n", ImgbDumpPadding, ImageHeader->SizeOfHeapReserve);
    printf("%s%08X original base address\n", ImgbDumpPadding, ImageHeader->NtBaseOfDll);
    printf("%s%8X original size of image\n", ImgbDumpPadding, ImageHeader->NtSizeOfImage);
    printf("%s%08X original checksum\n", ImgbDumpPadding, ImageHeader->NtCheckSum);
    printf("%s%08X original time date stamp %s", ImgbDumpPadding, ImageHeader->NtTimeDateStamp, ImgbGetDumpTimeStampString(&ImageHeader->NtTimeDateStamp));
    printf("%s%08X debug path name address\n", ImgbDumpPadding, ImageHeader->DebugPathName);
    printf("%s%08X debug file name address\n", ImgbDumpPadding, ImageHeader->DebugFileName);
    printf("%s%08X debug Unicode file name address\n", ImgbDumpPadding, ImageHeader->DebugUnicodeFileName);
    printf("%s%08X kernel image thunk address\n", ImgbDumpPadding, ImageHeader->XboxKernelThunkData);
    printf("%s%08X non-kernel import directory address\n", ImgbDumpPadding, ImageHeader->ImportDirectory);
    printf("%s%8X number of library versions\n", ImgbDumpPadding, ImageHeader->NumberOfLibraryVersions);
    printf("%s%08X library versions address\n", ImgbDumpPadding, ImageHeader->LibraryVersions);
    printf("%s%08X kernel library version address\n", ImgbDumpPadding, ImageHeader->XboxKernelLibraryVersion);
    printf("%s%08X XAPI library version address\n", ImgbDumpPadding, ImageHeader->XapiLibraryVersion);
    printf("%s%08X logo bitmap address\n", ImgbDumpPadding, ImageHeader->MicrosoftLogo);
    printf("%s%8X logo bitmap size\n", ImgbDumpPadding, ImageHeader->SizeOfMicrosoftLogo);
    printf("\n");

    if (ImageHeader->DebugPathName != NULL) {
        printf("Debug path name: %s\n\n", (ULONG)ImageHeader +
            (ULONG)ImageHeader->DebugPathName - (ULONG)ImageHeader->BaseAddress);
    }

    //
    // Dump the image certificate.
    //

    ImgbDumpXbeCertificate(ImageHeader);

    //
    // Dump the library versions.
    //

    ImgbDumpXbeLibraryVersions(ImageHeader);

    //
    // Dump the import directories.
    //

    ImgbDumpXbeImportDirectories(ImageHeader);

    //
    // Dump the image TLS directory.
    //

    ImgbDumpXbeTlsDirectory(ImageHeader);

    //
    // Dump the image section header fields.
    //

    ImgbDumpXbeSectionHeaders(ImageHeader);
}

DECLSPEC_NORETURN
VOID
ImgbDumpExecutable(
    int argc,
    char *argv[]
    )
{
    //
    // Print out the logo banner.
    //

    ImgbResourcePrintLogoBanner();

    //
    // Skip past the /DUMP parameter.
    //

    argv++;
    argc--;

    //
    // If no arguments were supplied, then print out the usage text.
    //

    if (argc == 0) {
PrintUsageTextAndExit:
        ImgbResourcePrintRange(stderr, IDS_DUMPXBE_USAGE);
        ImgbExitProcess(0);
    }

    //
    // Process the command line options.
    //

    do {

        if (argv[0][0] == '-' || argv[0][0] == '/') {

            //
            // Attempt to match the help switches.
            //

            if ((_stricmp(&argv[0][1], "?") == 0) ||
                (_stricmp(&argv[0][1], "HELP") == 0)) {
                goto PrintUsageTextAndExit;
            }

            //
            // This is an unrecognized option, so error out.
            //

            ImgbResourcePrintErrorAndExit(IDS_UNRECOGNIZED_OPTION, argv[0]);

        } else {

            //
            // Ignore multiple input file names.
            //

            if (ImgbInputFilePath == NULL) {
                ImgbInputFilePath = argv[0];
            }
        }

        argv++;
        argc--;

    } while (argc > 0);

    //
    // If no file name was specified, then print out the usage text.
    //

    if (ImgbInputFilePath == NULL) {
        goto PrintUsageTextAndExit;
    }

    printf("Dump of file %s\n\n", ImgbInputFilePath);

    //
    // Open the input file.
    //

    ImgbInputFileHandle = CreateFile(ImgbInputFilePath, GENERIC_READ,
        FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);

    if (ImgbInputFileHandle == INVALID_HANDLE_VALUE) {
        ImgbResourcePrintErrorAndExit(IDS_CANNOT_OPEN_INPUT_FILE, ImgbInputFilePath);
    }

    //
    // Obtain the size of the input file.
    //

    ImgbInputFileSize = GetFileSize(ImgbInputFileHandle, NULL);

    //
    // Create a mapping of the input file.  We make it copy-on-write because
    // we may need to modify library approval bits as part of our check.
    //

    ImgbInputFileMappingHandle = CreateFileMapping(ImgbInputFileHandle, NULL,
        PAGE_WRITECOPY, 0, 0, NULL);

    if (ImgbInputFileMappingHandle == NULL) {
        ImgbResourcePrintErrorAndExit(IDS_CANNOT_READ_INPUT_FILE, ImgbInputFilePath);
    }                                                                 

    //
    // Map a copy-on-write view of the input file section.
    //

    ImgbInputFileMappingView = MapViewOfFile(ImgbInputFileMappingHandle,
        FILE_MAP_COPY, 0, 0, 0);

    if (ImgbInputFileMappingView == NULL) {
        ImgbResourcePrintErrorAndExit(IDS_CANNOT_READ_INPUT_FILE, ImgbInputFilePath);
    }

    //
    // Start dumping the file at the image header.
    //

    ImgbDumpXbeImageHeader();

    //
    // Exit the application.
    //

    ImgbExitProcess(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagebld.new\cmdline.cpp ===
/*++

Copyright (c) 2001-2002  Microsoft Corporation

Module Name:

    cmdline.cpp

Abstract:

    This module implements command line related routines for the utility program
    to build an Xbox executable image.

--*/

#include "imgbldp.h"

//
// Stores the path to the input file.
//
LPSTR ImgbInputFilePath;

//
// Stores the path to the output file.
//
LPSTR ImgbOutputFilePath;

//
// Header node for the list of NOPRELOAD sections.
//
LIST_ENTRY ImgbNoPreloadList = {
    &ImgbNoPreloadList, &ImgbNoPreloadList
};

//
// Header node for the list of INSERTFILE sections.
//
LIST_ENTRY ImgbInsertFileList = {
    &ImgbInsertFileList, &ImgbInsertFileList
};

//
// Stores whether or not a copy of the original PE header should be emitted to
// the output file.
//
BOOLEAN ImgbEmitPEHeader;

//
// Stores the number of bytes to allocate for default sized stacks.
//
ULONG ImgbSizeOfStack;

//
// Stores the initialization flags to store in the image.
//
ULONG ImgbInitFlags = XINIT_MOUNT_UTILITY_DRIVE;

//
// Stores whether or not the system memory available to the image should be
// limited to 64 megabytes (/LIMITMEM).
//
BOOLEAN ImgbLimitMemory;

//
// Stores whether or not the hard disk should be initialized by the XAPI startup
// code (/NOSETUPHD).
//
BOOLEAN ImgbNoSetupHardDisk;

//
// Stores whether or not the hard disk should be modified by the XAPI startup
// code (/DONTMODIFYHD).
//
BOOLEAN ImgbDontModifyHardDisk;

//
// Stores whether or not the utility drive should be mounted during XAPI startup
// code (/DONTMOUNTUD).
//
BOOLEAN ImgbDontMountUtilityDrive;

//
// Stores whether or not the utility drive should be formatted during XAPI
// startup code (/FORMATUD).
//
BOOLEAN ImgbFormatUtilityDrive;

//
// Stores the size of a utility drive cluster in bytes.  Initialized to zero so
// that we only touch the initialization flags if this value is explicitly set
// on the command line.
//
ULONG ImgbUtilityDriveClusterSize;

//
// Stores the version number to store in the image certificate.
//
ULONG ImgbVersion;

//
// Stores the test game region to store in the image certificate.
//
ULONG ImgbTestGameRegion = XBEIMAGE_GAME_REGION_NA | XBEIMAGE_GAME_REGION_JAPAN |
    XBEIMAGE_GAME_REGION_RESTOFWORLD | XBEIMAGE_GAME_REGION_MANUFACTURING;

//
// Stores the test allowed media types bitmask to store in the image certificate.
//
ULONG ImgbTestAllowedMediaTypes = XBEIMAGE_MEDIA_TYPE_HARD_DISK |
    XBEIMAGE_MEDIA_TYPE_DVD_CD | XBEIMAGE_MEDIA_TYPE_MEDIA_BOARD;

//
// Stores the test game ratings to store in the image certificate.
//
ULONG ImgbTestGameRatings = MAXULONG;

//
// Stores the test title identifier to store in the image certificate.
//
ULONG ImgbTestTitleID;

//
// Stores the test alternate title identifiers to store in the image certificate.
//
ULONG ImgbTestAlternateTitleIDs[XBEIMAGE_ALTERNATE_TITLE_ID_COUNT];

//
// Stores the test alternate signature keys to store in the image certificate.
//
XBEIMAGE_CERTIFICATE_KEY ImgbTestAlternateSignatureKeys[XBEIMAGE_ALTERNATE_TITLE_ID_COUNT];

//
// Stores the number of test alternate title identifiers that have been claimed.
//
ULONG ImgbNumberOfTestAlternateTitleIDs;

//
// Stores the test title name to store in the image certificate.
//
WCHAR ImgbTestTitleName[XBEIMAGE_TITLE_NAME_LENGTH];

//
// Stores the test LAN key to store in the image certificate.
//
UCHAR ImgbTestLANKey[XBEIMAGE_CERTIFICATE_KEY_LENGTH] = {
    (UCHAR)'T', (UCHAR)'E', (UCHAR)'S', (UCHAR)'T',
    (UCHAR)'T', (UCHAR)'E', (UCHAR)'S', (UCHAR)'T',
    (UCHAR)'T', (UCHAR)'E', (UCHAR)'S', (UCHAR)'T',
    (UCHAR)'T', (UCHAR)'E', (UCHAR)'S', (UCHAR)'T',
};

//
// Stores the test signature key to store in the image certificate.
//
UCHAR ImgbTestSignatureKey[XBEIMAGE_CERTIFICATE_KEY_LENGTH] = {
    (UCHAR)'T', (UCHAR)'E', (UCHAR)'S', (UCHAR)'T',
    (UCHAR)'T', (UCHAR)'E', (UCHAR)'S', (UCHAR)'T',
    (UCHAR)'T', (UCHAR)'E', (UCHAR)'S', (UCHAR)'T',
    (UCHAR)'T', (UCHAR)'E', (UCHAR)'S', (UCHAR)'T',
};

//
// Stores the file name of the title image to store in the image.
//
LPSTR ImgbTitleImage;

//
// Stores the file name of the title info to store in the image.
//
LPSTR ImgbTitleInfo;

//
// Stores the file name of the default save image to store in the image.
//
LPSTR ImgbDefaultSaveImage;

LPSTR
ImgbDuplicateString(
    LPCSTR pszString
    )
{
    LPSTR pszDuplicatedString;

    pszDuplicatedString = (LPSTR)ImgbAllocateMemory(strlen(pszString) + 1);

    strcpy(pszDuplicatedString, pszString);

    return pszDuplicatedString;
}

BOOLEAN
ImgbMatchCommandOptionStringValue(
    LPCSTR pszCommandOption,
    LPCSTR pszMatchString,
    LPSTR *ppszStringValue
    )
{
    UINT MatchStringLength;

    MatchStringLength = strlen(pszMatchString);

    //
    // Check if the string is prefixed with the match string.
    //

    if (_strnicmp(pszCommandOption, pszMatchString, MatchStringLength) != 0) {
        return FALSE;
    }

    //
    // Check if the switch is followed by a command argument.  If there isn't a
    // colon and this isn't the end of the string, then this isn't really our
    // switch, so bail out.  If there isn't a colon or the colon is followed by
    // an empty string, then the switch's argument is missing, so error out.
    //

    if (pszCommandOption[MatchStringLength] != ':') {

        if (pszCommandOption[MatchStringLength] == '\0') {
            ImgbResourcePrintErrorAndExit(IDS_MISSING_OPTION_ARGUMENT,
                pszMatchString);
        }

        return FALSE;

    } else if (pszCommandOption[MatchStringLength + 1] == '\0') {
        ImgbResourcePrintErrorAndExit(IDS_MISSING_OPTION_ARGUMENT, pszMatchString);
    }

    //
    // If we've already seen the switch, then override it with the new value.
    //

    if (*ppszStringValue != NULL) {
        ImgbFreeMemory(*ppszStringValue);
    }

    //
    // Duplicate the switch's argument.
    //

    *ppszStringValue = ImgbDuplicateString(&pszCommandOption[MatchStringLength + 1]);

    return TRUE;
}

VOID
ImgbParseInteger(
    LPCSTR pszMatchString,
    LPCSTR pszInteger,
    ULONG *pulIntegerValue
    )
{
    LPSTR pszEndParse;

    //
    // Convert the string switch to an integer.
    //

    errno = 0;

    *pulIntegerValue = strtoul(pszInteger, &pszEndParse, 0);

    //
    // Verify that the entire string was consumed; if not, then there's invalid
    // data at the end of the switch, so error out.
    //
    // Also verify that no underflow or overflow error has occurred.
    //

    if (pszEndParse != pszInteger + strlen(pszInteger) || (errno == ERANGE)) {
        ImgbResourcePrintErrorAndExit(IDS_INVALID_NUMBER_OPTION, pszMatchString);
    }
}

BOOLEAN
ImgbMatchCommandOptionIntegerValue(
    LPCSTR pszCommandOption,
    LPCSTR pszMatchString,
    ULONG *pulIntegerValue
    )
{
    LPSTR pszStringValue;

    pszStringValue = NULL;

    //
    // Attempt to parse the switch as a string.
    //

    if (!ImgbMatchCommandOptionStringValue(pszCommandOption, pszMatchString,
        &pszStringValue)) {
        return FALSE;
    }

    //
    // Parse the string as an integer.
    //

    ImgbParseInteger(pszMatchString, pszStringValue, pulIntegerValue);

    ImgbFreeMemory(pszStringValue);

    return TRUE;
}

ULONG
ImgbHexCharacterToInteger(
    CHAR Character
    )
{
    if (isdigit(Character)) {
        return Character - '0';
    } else {
        return toupper(Character) - 'A' + 10;
    }
}

VOID
ImgbParseCertificateKey(
    LPCSTR pszMatchString,
    LPCSTR pszCertificateKey,
    PUCHAR CertificateKey
    )
{
    ULONG BytesRemaining;
    LPCSTR pszParse;

    //
    // Verify that the key parameter is the correct length.
    //

    if (strlen(pszCertificateKey) != XBEIMAGE_CERTIFICATE_KEY_LENGTH * 2) {
        ImgbResourcePrintErrorAndExit(IDS_INVALID_CERTKEY_OPTION, pszMatchString);
    }

    //
    // Parse the certificate key and store the result in the supplied buffer.
    //

    BytesRemaining = XBEIMAGE_CERTIFICATE_KEY_LENGTH;
    pszParse = pszCertificateKey;

    while (BytesRemaining > 0) {

        if (!isxdigit(*pszParse) || !isxdigit(*(pszParse + 1))) {
            ImgbResourcePrintErrorAndExit(IDS_INVALID_CERTKEY_OPTION, pszMatchString);
        }

        *CertificateKey++ = (UCHAR)((ImgbHexCharacterToInteger(*pszParse) << 4) +
            ImgbHexCharacterToInteger(*(pszParse + 1)));

        BytesRemaining--;
        pszParse += 2;
    }
}

BOOLEAN
ImgbMatchCommandOptionCertificateKey(
    LPCSTR pszCommandOption,
    LPCSTR pszMatchString,
    PUCHAR CertificateKey
    )
{
    LPSTR pszStringValue;

    pszStringValue = NULL;

    //
    // Attempt to parse the switch as a string.
    //

    if (!ImgbMatchCommandOptionStringValue(pszCommandOption, pszMatchString,
        &pszStringValue)) {
        return FALSE;
    }

    //
    // Parse the string as a certificate.
    //

    ImgbParseCertificateKey(pszMatchString, pszStringValue, CertificateKey);

    ImgbFreeMemory(pszStringValue);

    return TRUE;
}

VOID
ImgbProcessCommandOption(
    LPCSTR pszCommandOption
    )
{
    LPSTR pszStringValue;
    PIMGB_NOPRELOAD NoPreloadLink;
    LPSTR pszAlternateSignatureKey;
    PIMGB_INSERTFILE InsertFileLink;
    LPSTR pszInsertFileAttributes;

    pszStringValue = NULL;

    //
    // If this isn't a switch option, then this must be the input file path.
    //

    if (*pszCommandOption != '-' && *pszCommandOption != '/') {

        if (ImgbInputFilePath != NULL) {
            ImgbFreeMemory(ImgbInputFilePath);
        }

        ImgbInputFilePath = ImgbDuplicateString(pszCommandOption);

        return;
    }

    //
    // Skip past the switch character.
    //

    pszCommandOption++;

    //
    // Attempt to match the /IN:xxxx switch.
    //

    if (ImgbMatchCommandOptionStringValue(pszCommandOption, "IN", &ImgbInputFilePath)) {
        return;
    }

    //
    // Attempt to match the /OUT:xxxx switch.
    //

    if (ImgbMatchCommandOptionStringValue(pszCommandOption, "OUT", &ImgbOutputFilePath)) {
        return;
    }

    //
    // Attempt to match the /NOPRELOAD:xxxx switch.  If found, add the section
    // name to the NOPRELOAD list.
    //

    if (ImgbMatchCommandOptionStringValue(pszCommandOption, "NOPRELOAD", &pszStringValue)) {

        NoPreloadLink = (PIMGB_NOPRELOAD)ImgbAllocateMemory(sizeof(IMGB_NOPRELOAD));

        NoPreloadLink->SectionName = pszStringValue;

        InsertTailList(&ImgbNoPreloadList, &NoPreloadLink->ListEntry);

        return;
    }

    //
    // Attempt to match the /STACK:xxxx switch.
    //

    if (ImgbMatchCommandOptionIntegerValue(pszCommandOption, "STACK", &ImgbSizeOfStack)) {
        return;
    }

    //
    // Attempt to match the /INITFLAGS:xxxx switch.
    //

    if (ImgbMatchCommandOptionIntegerValue(pszCommandOption, "INITFLAGS", &ImgbInitFlags)) {
        return;
    }

    //
    // Attempt to match the /VERSION:xxxx switch.
    //

    if (ImgbMatchCommandOptionIntegerValue(pszCommandOption, "VERSION", &ImgbVersion)) {
        return;
    }

    //
    // Attempt to match the /TESTVERSION:xxxx switch.
    //

    if (ImgbMatchCommandOptionIntegerValue(pszCommandOption, "TESTVERSION", &ImgbVersion)) {
        return;
    }

    //
    // Attempt to match the /TESTREGION:xxxx switch.
    //

    if (ImgbMatchCommandOptionIntegerValue(pszCommandOption, "TESTREGION", &ImgbTestGameRegion)) {
        return;
    }

    //
    // Attempt to match the /TESTMEDIATYPES:xxxx switch.
    //

    if (ImgbMatchCommandOptionIntegerValue(pszCommandOption, "TESTMEDIATYPES", &ImgbTestAllowedMediaTypes)) {
        return;
    }

    //
    // Attempt to match the /TESTRATINGS:xxxx switch.
    //

    if (ImgbMatchCommandOptionIntegerValue(pszCommandOption, "TESTRATINGS", &ImgbTestGameRatings)) {
        return;
    }

    //
    // Attempt to match the /TESTID:xxxx switch.
    //

    if (ImgbMatchCommandOptionIntegerValue(pszCommandOption, "TESTID", &ImgbTestTitleID)) {
        return;
    }

    //
    // Attempt to match the /TESTALTID:xxxx switch
    //

    if (ImgbMatchCommandOptionStringValue(pszCommandOption, "TESTALTID", &pszStringValue)) {

        if (ImgbNumberOfTestAlternateTitleIDs >= XBEIMAGE_ALTERNATE_TITLE_ID_COUNT) {
            ImgbResourcePrintErrorAndExit(IDS_TOO_MANY_TESTALTIDS);
        }

        ImgbParseInteger("TESTALTID", strtok(pszStringValue, ","),
            &ImgbTestAlternateTitleIDs[ImgbNumberOfTestAlternateTitleIDs]);

        pszAlternateSignatureKey = strtok(NULL, ",");

        if (pszAlternateSignatureKey != NULL) {

            ImgbParseCertificateKey("TESTALTID", pszAlternateSignatureKey,
                ImgbTestAlternateSignatureKeys[ImgbNumberOfTestAlternateTitleIDs]);

            if (strtok(NULL, ",") != NULL) {
                ImgbResourcePrintErrorAndExit(IDS_INSERTFILE_TOO_MANY_OPTIONS);
            }
        }

        ImgbNumberOfTestAlternateTitleIDs++;

        ImgbFreeMemory(pszStringValue);

        return;
    }

    //
    // Attempt to match the /TESTNAME:xxxx switch.
    //

    if (ImgbMatchCommandOptionStringValue(pszCommandOption, "TESTNAME", &pszStringValue)) {

        if (MultiByteToWideChar(CP_ACP, 0, pszStringValue, -1, ImgbTestTitleName,
            XBEIMAGE_TITLE_NAME_LENGTH) == 0) {

            if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
                ImgbResourcePrintErrorAndExit(IDS_INVALID_STRING_OPTION, "TESTNAME");
            }
        }

        ImgbFreeMemory(pszStringValue);

        return;
    }

    //
    // Attempt to match the /TESTLANKEY:xxxx switch.
    //

    if (ImgbMatchCommandOptionCertificateKey(pszCommandOption, "TESTLANKEY",
        ImgbTestLANKey)) {
        return;
    }

    //
    // Attempt to match the /TESTSIGNKEY:xxxx switch.
    //

    if (ImgbMatchCommandOptionCertificateKey(pszCommandOption, "TESTSIGNKEY",
        ImgbTestSignatureKey)) {
        return;
    }

    //
    // Attempt to match the /TITLEIMAGE:xxxx switch.
    //

    if (ImgbMatchCommandOptionStringValue(pszCommandOption, "TITLEIMAGE", &ImgbTitleImage)) {
        return;
    }

    //
    // Attempt to match the /TITLEINFO:xxxx switch.
    //

    if (ImgbMatchCommandOptionStringValue(pszCommandOption, "TITLEINFO", &ImgbTitleInfo)) {
        return;
    }

    //
    // Attempt to match the /DEFAULTSAVEIMAGE:xxxx switch.
    //

    if (ImgbMatchCommandOptionStringValue(pszCommandOption, "DEFAULTSAVEIMAGE", &ImgbDefaultSaveImage)) {
        return;
    }

    //
    // Attempt to match the /INSERTFILE:xxxx switch.
    //

    if (ImgbMatchCommandOptionStringValue(pszCommandOption, "INSERTFILE", &pszStringValue)) {

        InsertFileLink = (PIMGB_INSERTFILE)ImgbAllocateMemory(sizeof(IMGB_INSERTFILE));

        InsertFileLink->FilePath = strtok(pszStringValue, ",");
        InsertFileLink->SectionName = strtok(NULL, ",");

        if (InsertFileLink->SectionName == NULL) {
            ImgbResourcePrintErrorAndExit(IDS_INSERTFILE_MISSING_SECTION);
        }

        pszInsertFileAttributes = strtok(NULL, ",");

        if (pszInsertFileAttributes != NULL) {

            while (*pszInsertFileAttributes != '\0') {

                switch (toupper(*pszInsertFileAttributes)) {

                    case 'R':
                        InsertFileLink->ReadOnly = TRUE;
                        break;

                    case 'N':
                        InsertFileLink->NoPreload = TRUE;
                        break;

                    default:
                        ImgbResourcePrintErrorAndExit(IDS_INVALID_GENERIC_OPTION,
                            "INSERTFILE");
                }

                pszInsertFileAttributes++;
            }

            if (strtok(NULL, ",") != NULL) {
                ImgbResourcePrintErrorAndExit(IDS_INSERTFILE_TOO_MANY_OPTIONS);
            }
        }

        InsertTailList(&ImgbInsertFileList, &InsertFileLink->ListEntry);

        return;
    }

    //
    // Attempt to match the /NOLIBWARN switch.
    //

    if (_stricmp(pszCommandOption, "NOLIBWARN") == 0) {
        ImgbNoWarnLibraryApproval = TRUE;
        return;
    }

    //
    // Attempt to match the /PEHEADER switch.
    //

    if (_strnicmp(pszCommandOption, "PEHEADER", 8) == 0) {
        ImgbEmitPEHeader = TRUE;
        return;
    }

    //
    // Attempt to match the /LIMITMEM switch.
    //

    if (_stricmp(pszCommandOption, "LIMITMEM") == 0) {
        ImgbLimitMemory = TRUE;
        return;
    }

    //
    // Attempt to match the /NOSETUPHD switch.
    //

    if (_stricmp(pszCommandOption, "NOSETUPHD") == 0) {
        ImgbNoSetupHardDisk = TRUE;
        return;
    }

    //
    // Attempt to match the /DONTMODIFYHD switch.
    //

    if (_stricmp(pszCommandOption, "DONTMODIFYHD") == 0) {
        ImgbDontModifyHardDisk = TRUE;
        return;
    }

    //
    // Attempt to match the /DONTMOUNTUD switch.
    //

    if (_stricmp(pszCommandOption, "DONTMOUNTUD") == 0) {
        ImgbDontMountUtilityDrive = TRUE;

        if (ImgbFormatUtilityDrive) {
            ImgbResourcePrintErrorAndExit(IDS_FORMATUD_NOT_POSSIBLE);
        }

        return;
    }

    //
    // Attempt to match the /FORMATUD switch.
    //

    if (_stricmp(pszCommandOption, "FORMATUD") == 0) {
        ImgbFormatUtilityDrive = TRUE;

        if (ImgbDontMountUtilityDrive) {
            ImgbResourcePrintErrorAndExit(IDS_FORMATUD_NOT_POSSIBLE);
        }

        return;
    }

    //
    // Attempt to match the /UDCLUSTER switch.  Accept the integer as either
    // the number of bytes or the number of kilobytes per cluster.
    //

    if (ImgbMatchCommandOptionIntegerValue(pszCommandOption, "UDCLUSTER",
        &ImgbUtilityDriveClusterSize)) {

        switch (ImgbUtilityDriveClusterSize) {

            case 16:
            case 16384:
                ImgbUtilityDriveClusterSize = 16384;
                break;

            case 32:
            case 32768:
                ImgbUtilityDriveClusterSize = 32768;
                break;

            case 64:
            case 65536:
                ImgbUtilityDriveClusterSize = 65536;
                break;

            default:
                ImgbResourcePrintErrorAndExit(IDS_INVALID_UDCLUSTER_SIZE);
                break;
        }

        return;
    }

    //
    // Attempt to match the /NOLOGO switch.  This switch has no affect since we
    // don't display the banner unless we're displaying help text.  This switch
    // exists for compatibility with the old version of IMAGEBLD.
    //

    if (_stricmp(pszCommandOption, "NOLOGO") == 0) {
        return;
    }

    //
    // Attempt to match the /DEBUG switch.  This is equivalent to /PEHEADER.
    //

    if (_stricmp(pszCommandOption, "DEBUG") == 0) {
        ImgbEmitPEHeader = TRUE;
        return;
    }

    //
    // Attempt to match the help switches.  If a help switch is found, display
    // the tool's usage and exit the program.
    //

    if ((_stricmp(pszCommandOption, "?") == 0) ||
        (_stricmp(pszCommandOption, "HELP") == 0)) {
        ImgbResourcePrintLogoBanner();
        ImgbResourcePrintRange(stderr, IDS_IMAGEBLD_USAGE);
        ImgbExitProcess(0);
    }

    //
    // This is an unrecognized option, so error out.
    //

    ImgbResourcePrintErrorAndExit(IDS_UNRECOGNIZED_OPTION, pszCommandOption);
}

VOID
ImgbProcessCommandFile(
    LPSTR pszCommandFile
    )
{
    FILE *CommandFile;
    CHAR szLine[1024];
    LPSTR pszCurrent;
    LPSTR pszCommandOption;
    LPSTR pszCommandOptionEnd;

    //
    // Open the command file for read access.
    //

    CommandFile = fopen(pszCommandFile, "r");

    if (CommandFile == NULL) {
        ImgbResourcePrintErrorAndExit(IDS_CANNOT_OPEN_INPUT_FILE, pszCommandFile);
    }

    //
    // Process each line from the command file.
    //

    while (fgets(szLine, sizeof(szLine), CommandFile) != NULL) {

        pszCurrent = szLine;

        for (;;) {

            //
            // Advance past any whitespace and break out if we've reached the
            // end of the line.
            //

            while (isspace(*pszCurrent)) {
                pszCurrent++;
            }

            if (*pszCurrent == '\0') {
                break;
            }

            pszCommandOption = pszCurrent;
            pszCommandOptionEnd = pszCommandOption;

            while (*pszCurrent != '\0' && !isspace(*pszCurrent)) {

                if (*pszCurrent == '\"') {

                    pszCurrent++;

                    while (*pszCurrent != '\0' && *pszCurrent != '\"' && *pszCurrent != '\n') {
                        *pszCommandOptionEnd++ = *pszCurrent++;
                    }

                    if (*pszCurrent == '\"') {
                        pszCurrent++;
                    }

                } else {
                    *pszCommandOptionEnd++ = *pszCurrent++;
                }
            }

            //
            // If we hit whitespace and not the end of the line, then bump up
            // to the next character so that when we terminate the command
            // option string below, we don't think that we've reached the end of
            // the line above.
            //

            if (*pszCurrent != '\0') {
                pszCurrent++;
            }

            //
            // Terminate the command option string.
            //

            *pszCommandOptionEnd++ = '\0';

            //
            // Process the command option.
            //

            ImgbProcessCommandOption(pszCommandOption);
        }
    }

    //
    // If an error occurred when reading from the file, as opposed to reaching
    // the end of the file, then exit with an error.
    //

    if (ferror(CommandFile)) {
        ImgbResourcePrintErrorAndExit(IDS_CANNOT_READ_INPUT_FILE, pszCommandFile);
    }

    //
    // Close the command file.
    //

    fclose(CommandFile);
}

VOID
ImgbProcessCommandLineOptions(
    int argc,
    char *argv[]
    )
{
    PIMGB_INSERTFILE InsertFileLink;

    //
    // Skip past the executable file name parameter (argv[0]).
    //

    argv++;
    argc--;

    //
    // If no arguments were specified, then print out the tool's usage.
    //

    if (argc == 0) {
        ImgbResourcePrintLogoBanner();
        ImgbResourcePrintRange(stderr, IDS_IMAGEBLD_USAGE);
        ImgbExitProcess(0);
    }

    //
    // Check if the first switch is a request to run one of this tool's other
    // built-in tools.
    //

    if (argv[0][0] == '-' || argv[0][0] == '/') {

        //
        // Check if we should dump out the contents of an XBE file.
        //

        if (_stricmp(&argv[0][1], "DUMP") == 0) {
            ImgbDumpExecutable(argc, argv);
        }
    }

    //
    // Process the command line options.
    //

    do {

        if (argv[0][0] != '@') {
            ImgbProcessCommandOption(argv[0]);
        } else {
            ImgbProcessCommandFile(&argv[0][1]);
        }

        argv++;
        argc--;

    } while (argc > 0);

    //
    // If the /LIMITMEM switch was specified, then add the flag to the
    // initialization flags.
    //

    if (ImgbLimitMemory) {
        ImgbInitFlags |= XINIT_LIMIT_DEVKIT_MEMORY;
    }

    //
    // If the /NOSETUPHD switch was specified, then add the flag to the
    // initialization flags.
    //

    if (ImgbNoSetupHardDisk) {
        ImgbInitFlags |= XINIT_NO_SETUP_HARD_DISK;
    }

    //
    // If the /DONTMODIFYHD switch was specified, then add the flag to the
    // initialization flags.
    //

    if (ImgbDontModifyHardDisk) {
        ImgbInitFlags |= XINIT_DONT_MODIFY_HARD_DISK;
    }

    //
    // If the /FORMATUD switch was specified, then add the flag to the
    // initialization flags.
    //

    if (ImgbFormatUtilityDrive) {
        ImgbInitFlags |= XINIT_FORMAT_UTILITY_DRIVE;
    }

    //
    // If the /DONTMOUNTUD switch was specified, then remove the flag from the
    // initialization flags.
    //

    if (ImgbDontMountUtilityDrive) {
        ImgbInitFlags &= ~XINIT_MOUNT_UTILITY_DRIVE;
    }

    //
    // If the /UDCLUSTER switch was specified, then add the flag for desired
    // cluster size.  Note that if no cluster size was specified, then we'll
    // either use the default value of 16K or the value specified via the
    // /INITFLAGS switch.
    //

    switch (ImgbUtilityDriveClusterSize) {

        case 16384:
            ImgbInitFlags &= ~XINIT_UTILITY_DRIVE_CLUSTER_SIZE_MASK;
            ImgbInitFlags |= XINIT_UTILITY_DRIVE_16K_CLUSTER_SIZE;
            break;

        case 32768:
            ImgbInitFlags &= ~XINIT_UTILITY_DRIVE_CLUSTER_SIZE_MASK;
            ImgbInitFlags |= XINIT_UTILITY_DRIVE_32K_CLUSTER_SIZE;
            break;

        case 65536:
            ImgbInitFlags &= ~XINIT_UTILITY_DRIVE_CLUSTER_SIZE_MASK;
            ImgbInitFlags |= XINIT_UTILITY_DRIVE_64K_CLUSTER_SIZE;
            break;
    }

    //
    // If the /DEFAULTSAVEIMAGE switch was specified, then add an insert file
    // node for the file.
    //

    if (ImgbDefaultSaveImage != NULL) {

        InsertFileLink = (PIMGB_INSERTFILE)ImgbAllocateMemory(sizeof(IMGB_INSERTFILE));

        InsertFileLink->FilePath = ImgbDefaultSaveImage;
        InsertFileLink->SectionName = "$$XSIMAGE";
        InsertFileLink->NoPreload = TRUE;
        InsertFileLink->ReadOnly = TRUE;

        InsertHeadList(&ImgbInsertFileList, &InsertFileLink->ListEntry);
    }

    //
    // If the /TITLEIMAGE switch was specified, then add an insert file node for
    // the file.
    //

    if (ImgbTitleImage != NULL) {

        InsertFileLink = (PIMGB_INSERTFILE)ImgbAllocateMemory(sizeof(IMGB_INSERTFILE));

        InsertFileLink->FilePath = ImgbTitleImage;
        InsertFileLink->SectionName = "$$XTIMAGE";
        InsertFileLink->NoPreload = TRUE;
        InsertFileLink->ReadOnly = TRUE;

        InsertHeadList(&ImgbInsertFileList, &InsertFileLink->ListEntry);
    }

    //
    // If a /TITLEINFO switch was specified, then add an insert file node for
    // the file.
    //

    if (ImgbTitleInfo != NULL) {

        InsertFileLink = (PIMGB_INSERTFILE)ImgbAllocateMemory(sizeof(IMGB_INSERTFILE));

        InsertFileLink->FilePath = ImgbTitleInfo;
        InsertFileLink->SectionName = "$$XTINFO";
        InsertFileLink->NoPreload = TRUE;
        InsertFileLink->ReadOnly = TRUE;

        InsertHeadList(&ImgbInsertFileList, &InsertFileLink->ListEntry);
    }
}

BOOLEAN
ImgbSearchNoPreloadList(
    LPCSTR pszSectionName
    )
{
    PLIST_ENTRY NextListEntry;
    PIMGB_NOPRELOAD NoPreloadLink;

    NextListEntry = ImgbNoPreloadList.Flink;

    while (NextListEntry != &ImgbNoPreloadList) {

        NoPreloadLink = CONTAINING_RECORD(NextListEntry, IMGB_NOPRELOAD,
            ListEntry);

        if (_stricmp(NoPreloadLink->SectionName, pszSectionName) == 0) {
            return TRUE;
        }

        NextListEntry = NoPreloadLink->ListEntry.Flink;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagebld.new\imgbldrc.h ===
/*++

Copyright (c) 1989-2002  Microsoft Corporation

Module Name:

    imgbldrc.h

Abstract:

    This module contains the resource compiler constants for the utility program
    to build an Xbox executable image.

--*/

#ifndef _IMGBLDRC_
#define _IMGBLDRC_

#include <xboxverp.h>

#define IDS_CANNOT_OPEN_INPUT_FILE                      1000
#define IDS_CANNOT_READ_INPUT_FILE                      1001
#define IDS_NO_MEMORY                                   1002
#define IDS_MISSING_OPTION_ARGUMENT                     1003
#define IDS_UNRECOGNIZED_OPTION                         1004
#define IDS_MISSING_REQUIRED_OPTION                     1005
#define IDS_INVALID_NUMBER_OPTION                       1006
#define IDS_INVALID_STRING_OPTION                       1007
#define IDS_CANNOT_CREATE_OUTPUT_FILE                   1008
#define IDS_CANNOT_WRITE_OUTPUT_FILE                    1009
#define IDS_INVALID_CORRUPT_INPUT_FILE                  1010
#define IDS_NOT_MACHINE_X86                             1011
#define IDS_NOT_SUBSYSTEM_XBOX                          1012
#define IDS_CANNOT_IMPORT_BY_NAME                       1013
#define IDS_BOUND_IMAGES_UNSUPPORTED                    1014
#define IDS_IGNORING_NOPRELOAD                          1015
#define IDS_MISSING_RELOCATIONS                         1016
#define IDS_NO_VERSION_DETECTED                         1017
#define IDS_TOO_MANY_TESTALTIDS                         1018
#define IDS_INSERTFILE_MISSING_SECTION                  1019
#define IDS_INSERTFILE_TOO_MANY_OPTIONS                 1020
#define IDS_INSERTFILE_CONFLICTING_NAME                 1021
#define IDS_INSERTFILE_CONFLICTING_EXE                  1022
#define IDS_IMAGE_TOO_LARGE                             1023
#define IDS_INTERNAL_TOOL_ERROR                         1024
#define IDS_INVALID_CERTKEY_OPTION                      1025
#define IDS_INVALID_GENERIC_OPTION                      1026
#define IDS_TESTALTIDS_TOO_MANY_OPTIONS                 1027
#define IDS_POSSIBLY_UNAPPROVED                         1028
#define IDS_UNAPPROVED                                  1029
#define IDS_APPROVAL                                    1030
#define IDS_FORMATUD_NOT_POSSIBLE                       1031
#define IDS_EXPIRED                                     1032
#define IDS_INVALID_UDCLUSTER_SIZE                      1033

#define IDS_LOGO_NAME_AND_VERSION                       2000
#define IDS_LOGO_COPYRIGHT                              2001

#define IDS_IMAGEBLD_USAGE                              2200
#define IDS_DUMPXBE_USAGE                               2400

#endif // IMGBLDRC
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagebld.new\keydata.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    keydata.cpp

Abstract:

    This module contains the key data used to sign an Xbox executable image.

--*/

#include "imgbldp.h"

UCHAR ImgbPrivateKeyData[] = {
    0x52,0x53,0x41,0x32,0x08,0x01,0x00,0x00,
    0x00,0x08,0x00,0x00,0xFF,0x00,0x00,0x00,
    0x01,0x00,0x01,0x00,0x9B,0x83,0xD4,0xD5,
    0xDE,0x16,0x25,0x8E,0xE5,0x15,0xF2,0x18,
    0x9D,0x19,0x1C,0xF8,0xFE,0x91,0xA5,0x83,
    0xAE,0xA5,0xA8,0x95,0x3F,0x01,0xB2,0xC9,
    0x34,0xFB,0xC7,0x51,0x2D,0xAC,0xFF,0x38,
    0xE6,0xB6,0x7B,0x08,0x4A,0xDF,0x98,0xA3,
    0xFD,0x31,0x81,0xBF,0xAA,0xD1,0x62,0x58,
    0xC0,0x6C,0x8F,0x8E,0xCD,0x96,0xCE,0x6D,
    0x03,0x44,0x59,0x93,0xCE,0xEA,0x8D,0xF4,
    0xD4,0x6F,0x6F,0x34,0x5D,0x50,0xF1,0xAE,
    0x99,0x7F,0x1D,0x92,0x15,0xF3,0x6B,0xDB,
    0xF9,0x95,0x8B,0x3F,0x54,0xAD,0x37,0xB5,
    0x4F,0x0A,0x58,0x7B,0x48,0xA2,0x9F,0x9E,
    0xA3,0x16,0xC8,0xBD,0x37,0xDA,0x9A,0x37,
    0xE6,0x3F,0x10,0x1B,0xA8,0x4F,0xA3,0x14,
    0xFA,0xBE,0x12,0xFB,0xD7,0x19,0x4C,0xED,
    0xAD,0xA2,0x95,0x8F,0x39,0x8C,0xC4,0x69,
    0x0F,0x7D,0xB8,0x84,0x0A,0x99,0x5C,0x53,
    0x2F,0xDE,0xF2,0x1B,0xC5,0x1D,0x4C,0x43,
    0x3C,0x97,0xA7,0xBA,0x8F,0xC3,0x22,0x67,
    0x39,0xC2,0x62,0x74,0x3A,0x0C,0xB5,0x57,
    0x01,0x3A,0x67,0xC6,0xDE,0x0C,0x0B,0xF6,
    0x08,0x01,0x64,0xDB,0xBD,0x81,0xE4,0xDC,
    0x09,0x2E,0xD0,0xF1,0xD0,0xD6,0x1E,0xBA,
    0x38,0x36,0xF4,0x4A,0xDD,0xCA,0x39,0xEB,
    0x76,0xCF,0x95,0xDC,0x48,0x4C,0xF2,0x43,
    0x8C,0xD9,0x44,0x26,0x7A,0x9E,0xEB,0x99,
    0xA3,0xD8,0xFB,0x30,0xA8,0x14,0x42,0x82,
    0x8D,0xB4,0x31,0xB3,0x1A,0xD5,0x2B,0xF6,
    0x32,0xBC,0x62,0xC0,0xFE,0x81,0x20,0x49,
    0xE7,0xF7,0x58,0x2F,0x2D,0xA6,0x1B,0x41,
    0x62,0xC7,0xE0,0x32,0x02,0x5D,0x82,0xEC,
    0xA3,0xE4,0x6C,0x9B,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0xCD,0xE1,0xAD,0xFB,
    0x97,0x2B,0x02,0xF8,0xC9,0xB4,0xFF,0xF7,
    0x81,0x6C,0xC1,0x91,0x11,0xB8,0x44,0x5A,
    0xF9,0x18,0x6C,0x20,0xB5,0xBC,0xA9,0x17,
    0xD7,0x21,0x76,0x50,0x65,0xA0,0xB5,0x7B,
    0x70,0x57,0x19,0x3C,0xA0,0x03,0x59,0x27,
    0x5D,0xBA,0xE1,0x66,0xEE,0xAF,0xB1,0xFE,
    0x59,0xCE,0x9A,0x80,0x96,0xA8,0x8A,0x0A,
    0x96,0x05,0x92,0x1D,0x43,0xF9,0xB5,0x10,
    0x22,0xE8,0xB7,0xFC,0x93,0x40,0x85,0x63,
    0xF9,0x96,0xEC,0x24,0xE8,0xDE,0xAC,0x65,
    0x17,0xA7,0xD7,0x6C,0xFB,0x0A,0x6E,0x0C,
    0xFA,0xCC,0xF3,0xB1,0xC9,0x13,0x6A,0xB0,
    0x99,0x10,0x1B,0x69,0x7B,0xB0,0x1E,0x36,
    0x9E,0xDD,0x67,0xD4,0xD2,0xE3,0xB1,0x11,
    0xE7,0xEB,0x8C,0x14,0x6F,0xCC,0xCE,0x71,
    0xA5,0x29,0xA2,0xCE,0x00,0x00,0x00,0x00,
    0x07,0xB3,0xF5,0x5E,0x12,0x32,0x0D,0x07,
    0x28,0x09,0x10,0xCB,0x78,0xFD,0xDA,0x92,
    0xB3,0xCB,0x54,0xBF,0x66,0x5F,0x0E,0xCB,
    0x0B,0x66,0x94,0xDA,0x03,0xCB,0xBA,0x05,
    0xA5,0xE6,0x4B,0xBD,0x28,0xC8,0x12,0xB1,
    0x6C,0x6B,0x2A,0x9D,0x86,0xE1,0x57,0xAC,
    0xC1,0x8F,0x1B,0xF7,0x26,0x39,0x3E,0x44,
    0x9E,0x53,0x12,0x25,0x88,0x0A,0x3F,0xE0,
    0xF7,0xA5,0xB8,0xCD,0xF7,0xE3,0x63,0xA8,
    0xF3,0xBD,0x78,0xFE,0x5C,0xB2,0x73,0x84,
    0xE3,0x25,0x9A,0x28,0xE2,0x35,0x55,0xC3,
    0x4B,0xD4,0x17,0x96,0xBE,0xC8,0xC6,0x26,
    0x40,0x2C,0xEC,0x2E,0x54,0x28,0x0E,0xBC,
    0x6B,0xE0,0x0F,0x58,0xB7,0xAB,0x93,0x84,
    0x78,0x47,0x53,0x06,0xD1,0x84,0xBE,0x79,
    0x35,0x13,0xA6,0x75,0x76,0xCF,0x8E,0xC0,
    0x00,0x00,0x00,0x00,0x95,0xAE,0xEA,0x78,
    0x33,0xBB,0x54,0x92,0x45,0xE4,0xA6,0xD1,
    0xFA,0x5E,0xE0,0x94,0x1E,0xAC,0xFA,0x4D,
    0x06,0x48,0xEE,0x92,0x4F,0x19,0x2A,0xD3,
    0xE6,0x45,0x75,0x4E,0x24,0x6B,0xDB,0x18,
    0xF0,0xD0,0x42,0xEA,0x8E,0x2D,0x3F,0xC8,
    0x40,0xB1,0x30,0x59,0x0B,0x3C,0x94,0x6A,
    0x91,0xD8,0x3C,0xDC,0xC5,0xE7,0x84,0xB1,
    0x1D,0x01,0x38,0x62,0x38,0x0E,0x23,0x1E,
    0xCF,0x69,0x7C,0xAD,0xC5,0xA3,0xE2,0x97,
    0x57,0x72,0x65,0x66,0xD2,0x76,0x74,0x58,
    0x1C,0x58,0x6D,0x70,0x18,0x43,0x8D,0x83,
    0x45,0x29,0x23,0xC6,0xA0,0xB8,0x06,0x96,
    0x0E,0xCA,0x2B,0x16,0xF4,0x62,0x48,0x77,
    0x0B,0x1A,0x89,0xA8,0x41,0xB8,0xD6,0xFF,
    0x3A,0x76,0x4B,0xF4,0x2D,0x52,0x96,0xF8,
    0xC6,0x69,0xA9,0x31,0x00,0x00,0x00,0x00,
    0xB3,0xC9,0x4D,0xCE,0x69,0xEF,0x44,0x70,
    0x7E,0x77,0x52,0x14,0x0E,0x71,0x52,0xED,
    0x48,0x6D,0x2C,0xFA,0x77,0x6A,0xA0,0x78,
    0xC8,0x05,0x24,0xB7,0xD3,0x00,0x2E,0x44,
    0x36,0x73,0xE1,0x87,0x1A,0x75,0x4D,0x7F,
    0x62,0xA4,0x0D,0xB2,0x6C,0xB9,0x07,0x5E,
    0xF7,0x9E,0x21,0x42,0xDD,0xC9,0xA2,0x6A,
    0x62,0x96,0xD6,0x4B,0xF2,0x25,0x87,0x75,
    0x4B,0xE4,0x21,0x5F,0x59,0xCD,0x76,0x40,
    0x6D,0x35,0xC1,0xBD,0x6A,0x12,0xED,0x12,
    0x89,0xB5,0xA8,0x58,0xF4,0x15,0x95,0x47,
    0x84,0xFA,0xF1,0xD8,0xE2,0x85,0x9C,0x52,
    0x81,0xDD,0x0B,0x64,0x48,0xF0,0xFC,0x1F,
    0x9A,0x31,0x12,0xA1,0x08,0xD8,0x0C,0xF9,
    0x64,0xAE,0x36,0x04,0x2E,0x1D,0xCE,0xBD,
    0x3F,0xFC,0xEE,0x62,0xB2,0x8B,0x4E,0x4C,
    0x00,0x00,0x00,0x00,0xA3,0x67,0xDF,0xAE,
    0xF0,0x4B,0x5F,0xF5,0x46,0xB1,0x67,0x39,
    0x24,0x29,0xD6,0xE2,0xDF,0x78,0xB1,0x05,
    0x63,0x3F,0x03,0xB0,0xEF,0x01,0x14,0xD8,
    0x42,0x69,0x4D,0x1D,0x87,0xB2,0x4C,0x3B,
    0x21,0xD6,0xA2,0xA1,0xBD,0x5E,0xCB,0xB2,
    0x97,0xBB,0x23,0xD8,0xB6,0x0B,0x68,0x94,
    0x25,0x6F,0x2B,0xFD,0xAD,0x6F,0x33,0x58,
    0xB1,0x77,0x1E,0x77,0x0D,0xF3,0xFC,0xCE,
    0x32,0x58,0x9A,0x15,0xC7,0xCE,0x29,0x5A,
    0x8A,0x0F,0x94,0xF9,0xBD,0x3C,0xAC,0x45,
    0xC3,0x6E,0x3C,0x72,0x95,0x2D,0xDD,0x16,
    0x30,0x5F,0x9D,0xD7,0x1C,0x76,0xA2,0x6C,
    0xCE,0xF0,0x7B,0x35,0xDC,0xD4,0x7E,0xEF,
    0x8E,0x01,0x53,0xE8,0x43,0xF8,0x18,0xDF,
    0xBD,0x25,0x6C,0xBC,0x5E,0x42,0x5D,0xA1,
    0x75,0xC9,0x76,0x7E,0x00,0x00,0x00,0x00,
    0xA9,0x91,0x2B,0xBF,0x27,0x08,0x55,0xC3,
    0xDE,0xC9,0x11,0xF1,0x37,0xCC,0xAA,0xC9,
    0x81,0xC8,0x1D,0xD1,0x12,0xA4,0xB0,0xD6,
    0x65,0xAB,0xBB,0x92,0xD5,0x37,0x6F,0x70,
    0x8C,0xAC,0x30,0xF7,0xA7,0x79,0x10,0xEC,
    0x46,0xA3,0x08,0x2A,0xC4,0x9A,0xD0,0x49,
    0x3A,0x77,0x23,0xF2,0x86,0xEF,0x82,0xE5,
    0xE5,0x7B,0x50,0xED,0xD5,0x43,0xA7,0x33,
    0xED,0xD7,0xA4,0x7A,0xB6,0x35,0x60,0x9D,
    0xB9,0xAD,0x93,0xB4,0xD6,0x3C,0x3D,0xCE,
    0xDF,0x43,0x00,0xC2,0xFC,0xE1,0x5A,0x98,
    0x3A,0x07,0x7B,0xCE,0xA1,0x2F,0xEE,0x01,
    0x70,0x83,0x8B,0xC1,0x3F,0xB7,0x79,0x5E,
    0x3D,0x2F,0xBD,0x9F,0x7D,0xD9,0xBE,0x66,
    0xE2,0x32,0xD4,0x92,0x3D,0xD5,0xE1,0x9F,
    0xE7,0x2F,0x22,0x52,0xCA,0xD1,0xFB,0xBC,
    0x6F,0x80,0x82,0x34,0x1D,0x13,0x07,0x39,
    0x24,0xC7,0x83,0x7D,0x61,0x9A,0x73,0x84,
    0x6B,0x30,0x79,0x10,0xE6,0x1F,0xC7,0xC1,
    0x0F,0x22,0x09,0xAA,0x15,0xB7,0x00,0x1D,
    0x6E,0x1A,0x93,0x4D,0x34,0xC7,0x1B,0x75,
    0x56,0xAF,0x48,0x14,0x6D,0x66,0x9A,0xB6,
    0x8E,0x69,0xFA,0x67,0x95,0x78,0xEC,0xE6,
    0x9E,0xAF,0x43,0xA0,0x3D,0x43,0x6F,0xD1,
    0x49,0x4F,0x35,0x6A,0x9C,0x83,0xB3,0x03,
    0x50,0x40,0x2C,0x4A,0x63,0x2B,0x15,0x43,
    0x6C,0x1E,0xDD,0x9D,0x61,0xA3,0x04,0xBB,
    0x87,0xB6,0x35,0x1A,0x32,0x48,0x0F,0x87,
    0xF3,0xE9,0x32,0x38,0x8B,0x7A,0x5F,0x74,
    0x87,0x47,0x5A,0xEE,0x65,0x5C,0xBC,0x9F,
    0xAF,0xB5,0x88,0xA6,0x77,0x5B,0xA5,0x3A,
    0xB7,0xDB,0x54,0xB4,0xF5,0x78,0x32,0x1E,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00
};

UCHAR ImgbPublicKeyData[] = {
    0x52,0x53,0x41,0x31,0x08,0x01,0x00,0x00,
    0x00,0x08,0x00,0x00,0xFF,0x00,0x00,0x00,
    0x01,0x00,0x01,0x00,0x9B,0x83,0xD4,0xD5,
    0xDE,0x16,0x25,0x8E,0xE5,0x15,0xF2,0x18,
    0x9D,0x19,0x1C,0xF8,0xFE,0x91,0xA5,0x83,
    0xAE,0xA5,0xA8,0x95,0x3F,0x01,0xB2,0xC9,
    0x34,0xFB,0xC7,0x51,0x2D,0xAC,0xFF,0x38,
    0xE6,0xB6,0x7B,0x08,0x4A,0xDF,0x98,0xA3,
    0xFD,0x31,0x81,0xBF,0xAA,0xD1,0x62,0x58,
    0xC0,0x6C,0x8F,0x8E,0xCD,0x96,0xCE,0x6D,
    0x03,0x44,0x59,0x93,0xCE,0xEA,0x8D,0xF4,
    0xD4,0x6F,0x6F,0x34,0x5D,0x50,0xF1,0xAE,
    0x99,0x7F,0x1D,0x92,0x15,0xF3,0x6B,0xDB,
    0xF9,0x95,0x8B,0x3F,0x54,0xAD,0x37,0xB5,
    0x4F,0x0A,0x58,0x7B,0x48,0xA2,0x9F,0x9E,
    0xA3,0x16,0xC8,0xBD,0x37,0xDA,0x9A,0x37,
    0xE6,0x3F,0x10,0x1B,0xA8,0x4F,0xA3,0x14,
    0xFA,0xBE,0x12,0xFB,0xD7,0x19,0x4C,0xED,
    0xAD,0xA2,0x95,0x8F,0x39,0x8C,0xC4,0x69,
    0x0F,0x7D,0xB8,0x84,0x0A,0x99,0x5C,0x53,
    0x2F,0xDE,0xF2,0x1B,0xC5,0x1D,0x4C,0x43,
    0x3C,0x97,0xA7,0xBA,0x8F,0xC3,0x22,0x67,
    0x39,0xC2,0x62,0x74,0x3A,0x0C,0xB5,0x57,
    0x01,0x3A,0x67,0xC6,0xDE,0x0C,0x0B,0xF6,
    0x08,0x01,0x64,0xDB,0xBD,0x81,0xE4,0xDC,
    0x09,0x2E,0xD0,0xF1,0xD0,0xD6,0x1E,0xBA,
    0x38,0x36,0xF4,0x4A,0xDD,0xCA,0x39,0xEB,
    0x76,0xCF,0x95,0xDC,0x48,0x4C,0xF2,0x43,
    0x8C,0xD9,0x44,0x26,0x7A,0x9E,0xEB,0x99,
    0xA3,0xD8,0xFB,0x30,0xA8,0x14,0x42,0x82,
    0x8D,0xB4,0x31,0xB3,0x1A,0xD5,0x2B,0xF6,
    0x32,0xBC,0x62,0xC0,0xFE,0x81,0x20,0x49,
    0xE7,0xF7,0x58,0x2F,0x2D,0xA6,0x1B,0x41,
    0x62,0xC7,0xE0,0x32,0x02,0x5D,0x82,0xEC,
    0xA3,0xE4,0x6C,0x9B,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\gdfimage\gdfimage.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    gdfimage.c

Abstract:

    This module implements a utility program to create a GDF disc image.

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <gdformat.h>
#include <xboxverp.h>
#include "cd.h"

typedef struct _GDF_FILE_NODE {
    struct _GDF_FILE_NODE *Link;
    ULONG DirectoryByteOffset;
    ULONG FirstSector;
    ULONG FileSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    WCHAR FileName[MAX_PATH];
} GDF_FILE_NODE, *PGDF_FILE_NODE;

typedef struct _FST_FILE_ITEM {
    struct _FST_FILE_ITEM *Link;
    ULONG FirstSector;
    ULONG LastSector;
    ULONG DirectoryIndex;
    ULONG FileIndex;
    ULONG FileOffset;
} FST_FILE_ITEM, *PFST_FILE_ITEM;

typedef struct _FST_STRING_ITEM {
    struct _FST_STRING_ITEM *Link;
    LPSTR String;
    int cch;
} FST_STRING_ITEM, *PFST_STRING_ITEM;

//
// Define the upper case table used for file name comparisons.  This matches the
// case table used by the file system.
//
const UCHAR GdfUpperCaseTable[256] = {
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
    0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,
    0x60,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
    0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x7b,0x7c,0x7d,0x7e,0x7f,
    0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,
    0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,
    0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,
    0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
    0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,
    0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,
    0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,
    0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xf7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0x3f
};

//
// Define the first sector that we'll start allocating data sectors from.  This
// is chosen so that we're past the starting sector number for a UDF volume
// descriptor sequence.
//
#define GDF_STARTING_DATA_SECTOR            (256 + 8)

#define GDF_ELTORITO_BOOT_CATALOG_SECTOR    24
#define GDF_ELTORITO_BOOT_SECTOR            25

//
// Stores the path to the source directory as supplied by the user.
//
LPWSTR GdfSourceDirectoryPath;

//
// Stores the path to the target file as supplied by the user.
//
LPWSTR GdfTargetFilePath;

//
// Stores the file handle to access the target file.
//
HANDLE GdfTargetFileHandle = INVALID_HANDLE_VALUE;

//
// Indicates whether we're making an emulation image
//
BOOLEAN GdfCreateFST;

//
// Stores the file handle to the FST file
//
HANDLE GdfFSTFileHandle = INVALID_HANDLE_VALUE;

//
// Stores the last sector that has been allocated.
//
ULONG GdfEndOfMedia = GDF_STARTING_DATA_SECTOR;

//
// Stores the current block number offset in the output file
//
ULONG GdfCurrentMediaPosition;

//
// Giant transfer buffer for read/write operations.
//
BYTE GdfTransferBuffer[128 * 1024];

//
// Buffer to hold the boot sector to create a PC bootable media.
//
BYTE GdfBootSector[SECTOR_SIZE];

//
// Flag to indicate whether or not we're creating a PC bootable media.
//
BOOLEAN GdfHaveBootSector;

//
// Stores the FST table information for generating a file for DVD emulation
//
PFST_FILE_ITEM GdfFSTFileList;
PFST_FILE_ITEM *GdfFSTFileListEnd;
PFST_STRING_ITEM GdfFSTStringList;
PFST_STRING_ITEM *GdfFSTStringListEnd;
ULONG GdfStringTableSize;
ULONG GdfDirectoryDirectoryIndex;
ULONG GdfDirectoryFileIndex;

//
// Caches the first sector and file size of XBOXROM.BIN from the root directory
// of the target media.  Used when creating a PC bootable media.
//
ULONG GdfXBOXROMFirstSector;
ULONG GdfXBOXROMFileSize;

//
// Flag to indicate whether or not we've seen a signal that we should abnormally
// terminate.
//
BOOLEAN GdfAbnormalTermination;

ULONG
GdfByteSwap32(
    DWORD dwValue
    )
{
    __asm {
        mov     eax, dwValue
        bswap   eax
    }
}

USHORT
GdfByteSwap16(
    WORD wValue
    )
{
    __asm {
        mov     ax, wValue
        xchg    al, ah
    }
}

DECLSPEC_NORETURN
VOID
GdfExitProcess(
    int ExitCode
    )
{
    if (GdfTargetFileHandle != INVALID_HANDLE_VALUE) {

        CloseHandle(GdfTargetFileHandle);

        //
        // If an error has occurred, then delete the output file.
        //

        if (ExitCode != 0) {
            DeleteFileW(GdfTargetFilePath);
        }
    }

    ExitProcess(ExitCode);
}

VOID
GdfAppendUnicodeToAnsi(
    LPSTR psz,
    LPCWSTR pwsz
    )
{
    int cch = lstrlenA(psz);

    if(!WideCharToMultiByte(CP_ACP, 0, pwsz, -1, psz + cch, MAX_PATH - cch, NULL,
        NULL)) {
        fprintf(stderr, "GDFIMAGE: internal error\n");
        GdfExitProcess(1);
    }
}

PFST_STRING_ITEM
GdfAllocateFSTStringA(
    LPCSTR psz,
    PULONG StringIndex
    )
{
    PFST_STRING_ITEM StringItem;
    int cch;

    //
    // Allocate a string
    //

    cch = lstrlenA(psz);
    StringItem = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
        sizeof(FST_STRING_ITEM) + cch + 1);

    if(!StringItem) {
        fprintf(stderr, "GDFIMAGE: Out of memory.\n");
        GdfExitProcess(1);
    }

    //
    // Fill in the string
    //

    StringItem->String = (LPSTR)(StringItem + 1);
    memcpy(StringItem->String, psz, cch);
    StringItem->String[cch] = 0;
    StringItem->cch = cch;

    //
    // Add it to the list
    //

    if(!GdfFSTStringListEnd)
        GdfFSTStringListEnd = &GdfFSTStringList;
    StringItem->Link = *GdfFSTStringListEnd;
    *GdfFSTStringListEnd = StringItem;
    GdfFSTStringListEnd = &StringItem->Link;

    //
    // Adjust the character count
    //

    *StringIndex = GdfStringTableSize;
    GdfStringTableSize += cch + 1;

    return StringItem;
}

PFST_STRING_ITEM
GdfAllocateFSTStringW(
    LPCWSTR pwsz,
    PULONG StringIndex
    )
{
    char sz[MAX_PATH];

    sz[0] = 0;
    GdfAppendUnicodeToAnsi(sz, pwsz);
    return GdfAllocateFSTStringA(sz, StringIndex);
}

PFST_FILE_ITEM
GdfCreateFSTEntry(
    ULONG FirstSector,
    ULONG FileSize,
    BOOL InsertAtEnd
    )
{
    PFST_FILE_ITEM FileItem;
    PFST_FILE_ITEM *InsertLocation;

    //
    // Allocate an entry
    //

    FileItem = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
        sizeof(FST_FILE_ITEM));

    if(!FileItem) {
        fprintf(stderr, "GDFIMAGE: Out of memory.\n");
        GdfExitProcess(1);
    }

    //
    // Fill it in
    //

    FileItem->FirstSector = FirstSector;
    FileItem->LastSector = FirstSector + ((FileSize + ((1 << SECTOR_SHIFT)
        - 1)) >> SECTOR_SHIFT) - 1;

    //
    // Add it to the list
    //

    if(InsertAtEnd) {
        InsertLocation = GdfFSTFileListEnd;
        if(!InsertLocation)
            InsertLocation = GdfFSTFileListEnd = &GdfFSTFileList;
    } else {
        InsertLocation = &GdfFSTFileList;
        while(*InsertLocation && FirstSector > (*InsertLocation)->FirstSector)
            InsertLocation = &(*InsertLocation)->Link;
    }

    FileItem->Link = *InsertLocation;
    *InsertLocation = FileItem;
    if(InsertLocation == GdfFSTFileListEnd)
        GdfFSTFileListEnd = &FileItem->Link;

    return FileItem;
}

VOID
GdfFillRootDirectoryName(
    LPSTR psz,
    LPCWSTR pwsz
    )
{
    WCHAR Drive[_MAX_DRIVE];
    WCHAR Dir[_MAX_DIR];
    WCHAR Name[_MAX_FNAME];
    WCHAR Ext[_MAX_EXT];
    WCHAR Path[_MAX_PATH];

    //
    // Strip out the drive letter
    //

    _wfullpath(Path, pwsz, _MAX_PATH - 1);
    _wsplitpath(Path, Drive, Dir, Name, Ext);
    _wmakepath(Path, NULL, Dir, Name, Ext);

    //
    // Convert to ANSI
    //

    psz[0] = 0;
    GdfAppendUnicodeToAnsi(psz, Path);
}

VOID
GdfReadBootSectorFile(
    LPCWSTR pwszBootSectorPath
    )
{
    HANDLE hFile;
    LARGE_INTEGER FileSize;
    DWORD cbRead;
    PULONG BootSectorXBOXROMFirstSector;
    PULONG BootSectorXBOXROMFileSize;

    //
    // Open the boot sector file.
    //

    hFile = CreateFileW(pwszBootSectorPath, GENERIC_READ, FILE_SHARE_READ |
        FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        fprintf(stderr, "GDFIMAGE: Unable to open boot sector file.\n");
        GdfExitProcess(1);
    }

    //
    // Get the size of the boot sector file and verify that it's exactly one
    // sector in size.
    //

    if (!GetFileSizeEx(hFile, &FileSize)) {
        fprintf(stderr, "GDFIMAGE: Failed to access boot sector file.\n");
        GdfExitProcess(1);
    }

    if (FileSize.QuadPart != sizeof(GdfBootSector)) {
        fprintf(stderr, "GDFIMAGE: Boot sector size is not 2048 bytes.\n");
        GdfExitProcess(1);
    }

    //
    // Read in the boot sector file.
    //

    if (!ReadFile(hFile, GdfBootSector, sizeof(GdfBootSector), &cbRead, NULL) ||
        (cbRead != sizeof(GdfBootSector))) {
        fprintf(stderr, "GDFIMAGE: Failed to read boot sector file.\n");
        GdfExitProcess(1);
    }

    //
    // Validate that the boot sector has the two magic entries to store the
    // first sector and file size of XBOXROM.BIN.
    //

    BootSectorXBOXROMFirstSector = (PULONG)(GdfBootSector + SECTOR_SIZE - 10);
    BootSectorXBOXROMFileSize = (PULONG)(GdfBootSector + SECTOR_SIZE - 6);

    if ((*BootSectorXBOXROMFirstSector != 0xCDCDCDCD) ||
        (*BootSectorXBOXROMFileSize != 0xDCDCDCDC)) {
        fprintf(stderr, "GDFIMAGE: Invalid boot sector file.\n");
        GdfExitProcess(1);
    }

    //
    // Indicate that we are creating a bootable media.
    //

    GdfHaveBootSector = TRUE;

    CloseHandle(hFile);
}

VOID
GdfProcessCommandLineOptions(
    int argc,
    wchar_t *argv[]
    )
{
    ULONG SourceDirectoryPathLength;

    //
    // Skip past the executable file name parameter (argv[0]).
    //

    argv++;
    argc--;

    //
    // If no arguments were specified, then print out the tool's usage.
    //

    if (argc == 0) {
PrintUsage:
        printf("Usage: GDFIMAGE [options] sourceroot targetfile\n\n"
            "  /B[file]      Specifies the boot sector file\n"
            "  /FST          Creates a file for DVD emulation rather than for DVD\n");
        GdfExitProcess(0);
    }

    //
    // Process the command line options.
    //

    do {

        if (argv[0][0] == L'-' || argv[0][0] == L'/') {

            switch (argv[0][1]) {

                case L'?':
                    goto PrintUsage;

                case L'b':
                case L'B':
                    GdfReadBootSectorFile(&argv[0][2]);
                    break;

                case L'F':
                case L'f':
                    if(0 != lstrcmpiW(&argv[0][2], L"ST"))
                        goto PrintUsage;
                    GdfCreateFST = TRUE;
                    break;

                default:
                    fprintf(stderr, "GDFIMAGE: Invalid command line.\n");
                    GdfExitProcess(1);
            }

            argv++;
            argc--;

        } else {
            break;
        }

    } while (argc > 0);

    //
    // There should be exactly two arguments remaining.
    //

    if (argc != 2) {
        fprintf(stderr, "GDFIMAGE: Invalid command line.\n");
        GdfExitProcess(1);
    }

    GdfSourceDirectoryPath = argv[0];
    GdfTargetFilePath = argv[1];

    //
    // If the user gives us a source path with a trailing slash, remove it.
    //

    SourceDirectoryPathLength = lstrlenW(GdfSourceDirectoryPath);

    if ((SourceDirectoryPathLength > 0) &&
        ((GdfSourceDirectoryPath[SourceDirectoryPathLength - 1] == L'\\') ||
        (GdfSourceDirectoryPath[SourceDirectoryPathLength - 1] == L'/'))) {
        GdfSourceDirectoryPath[SourceDirectoryPathLength - 1] = L'\0';
    }
}

VOID
GdfCheckSourceDirectoryExists(
    VOID
    )
{
    DWORD dwFileAttributes;

    dwFileAttributes = GetFileAttributesW(GdfSourceDirectoryPath);

    if (dwFileAttributes == 0xFFFFFFFF) {
        fprintf(stderr, "GDFIMAGE: Source path does not exist.\n");
        GdfExitProcess(1);
    }

    if ((dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {
        fprintf(stderr, "GDFIMAGE: Source path is not a directory.\n");
        GdfExitProcess(1);
    }
}

VOID
GdfOpenTargetFile(
    VOID
    )
{
    WCHAR SourceDrive[_MAX_DRIVE];
    WCHAR FSTDrive[_MAX_DRIVE];
    WCHAR FSTDir[_MAX_DIR];
    WCHAR FSTName[_MAX_FNAME];
    WCHAR FSTExt[_MAX_EXT];
    WCHAR BINPath[_MAX_PATH];
    int cch;

    if(GdfCreateFST) {

        //
        // First we have to ensure that the target file and the source
        // directory tree are on the same drive
        //

        _wfullpath(BINPath, GdfSourceDirectoryPath, _MAX_PATH - 1);
        _wsplitpath(BINPath, SourceDrive, NULL, NULL, NULL);
        _wfullpath(BINPath, GdfTargetFilePath, _MAX_PATH - 1);
        _wsplitpath(BINPath, FSTDrive, FSTDir, FSTName, FSTExt);
        if(SourceDrive[0] && FSTDrive[0] && 0 != lstrcmpiW(SourceDrive,
            FSTDrive))
        {
            fprintf(stderr, "GDFIMAGE: Source directory and target file must be on the same drive.\n");
            GdfExitProcess(1);
        }

        //
        // Now we create the FST file
        //

        GdfFSTFileHandle = CreateFileW(GdfTargetFilePath, GENERIC_READ |
            GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

        if (GdfFSTFileHandle == INVALID_HANDLE_VALUE) {
            fprintf(stderr, "GDFIMAGE: Unable to open target file.\n");
            GdfExitProcess(1);
        }

        //
        // Construct a file name for the directory BIN file and add it to the
        // string table
        //

        _wmakepath(BINPath, NULL, FSTDir, NULL, NULL);
        cch = lstrlenW(BINPath);
        if(cch > 0 && BINPath[cch - 1] == '\\')
            BINPath[--cch] = 0;
        GdfAllocateFSTStringW(BINPath, &GdfDirectoryDirectoryIndex);
        if(0 == lstrcmpiW(FSTExt, L"BIN")) {
            _wmakepath(BINPath, NULL, NULL, FSTName, L"FST.BIN");
            GdfAllocateFSTStringW(BINPath, &GdfDirectoryFileIndex);
            _wmakepath(BINPath, FSTDrive, FSTDir, FSTName, L"FST.BIN");
        } else {
            _wmakepath(BINPath, NULL, NULL, FSTName, L"BIN");
            GdfAllocateFSTStringW(BINPath, &GdfDirectoryFileIndex);
            _wmakepath(BINPath, FSTDrive, FSTDir, FSTName, L"BIN");
        }

        //
        // Now create the BIN file
        //

        GdfTargetFileHandle = CreateFileW(BINPath, GENERIC_READ |
            GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

        if (GdfTargetFileHandle == INVALID_HANDLE_VALUE) {
            fprintf(stderr, "GDFIMAGE: Unable to open target file.\n");
            GdfExitProcess(1);
        }
    } else {
        GdfTargetFileHandle = CreateFileW(GdfTargetFilePath, GENERIC_READ |
            GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

        if (GdfTargetFileHandle == INVALID_HANDLE_VALUE) {
            fprintf(stderr, "GDFIMAGE: Unable to open target file.\n");
            GdfExitProcess(1);
        }
    }
}

VOID
GdfWriteTargetFile(
    LPVOID lpvBuffer,
    DWORD cbNumberOfBytes
    )
{
    DWORD cbWritten;

    if (GdfAbnormalTermination) {
        GdfExitProcess(1);
    }

    if (!WriteFile(GdfTargetFileHandle, lpvBuffer, cbNumberOfBytes, &cbWritten,
        NULL) || (cbWritten != cbNumberOfBytes)) {
        fprintf(stderr, "GDFIMAGE: Failed to write to target file.\n");
        GdfExitProcess(1);
    }
}

VOID
GdfSeekByteTargetFile(
    PULARGE_INTEGER puliByteOffset
    )
{
    if (INVALID_SET_FILE_POINTER == SetFilePointer(GdfTargetFileHandle,
        (LONG)puliByteOffset->LowPart, (LPLONG)&(puliByteOffset->HighPart),
        FILE_BEGIN) && GetLastError() != NO_ERROR) {
        fprintf(stderr, "GDFIMAGE: Failed to access target file.\n");
        GdfExitProcess(1);
    }
}

VOID
GdfSeekSectorTargetFile(
    DWORD dwSectorNumber
    )
{
    ULARGE_INTEGER uliByteOffset;

    uliByteOffset.QuadPart = ((ULONGLONG)dwSectorNumber << SECTOR_SHIFT);

    GdfSeekByteTargetFile(&uliByteOffset);
}

VOID
GdfWriteFilledSectors(
    DWORD dwNumberOfSectors,
    BYTE Fill
    )
{
    BYTE SectorOfZeroes[SECTOR_SIZE];

    FillMemory(SectorOfZeroes, sizeof(SectorOfZeroes), Fill);

    while (dwNumberOfSectors--) {
        GdfWriteTargetFile(SectorOfZeroes, sizeof(SectorOfZeroes));
    }
}

VOID
GdfWriteFSTFile(
    VOID
    )
{
    ULONG Temp;
    char StringTemp[32];
    ULARGE_INTEGER Offset;
    PFST_FILE_ITEM FileItem;
    PFST_STRING_ITEM StringItem;

    //
    // Close the target file and switch to the FST
    //

    CloseHandle(GdfTargetFileHandle);
    GdfTargetFileHandle = GdfFSTFileHandle;

    //
    // First write out a header
    //

    memset(StringTemp, 0, sizeof StringTemp);
    strcpy(StringTemp, "AMC Virtual Media");
    GdfWriteTargetFile(StringTemp, sizeof StringTemp);
    memset(StringTemp, 0, sizeof StringTemp);
    strcpy(StringTemp, "Xbox DVD-ROM");
    GdfWriteTargetFile(StringTemp, sizeof StringTemp);
    Temp = 1715632;
    GdfWriteTargetFile(&Temp, 4);
    GdfWriteTargetFile(&Temp, 4);
    Offset.QuadPart = 192;
    GdfSeekByteTargetFile(&Offset);
    Temp = 0xABCD;
    GdfWriteTargetFile(&Temp, 2);
    Temp = time(NULL);
    GdfWriteTargetFile(&Temp, 4);

    //
    // Count up the number of file entries we have
    //

    Temp = 0;
    FileItem = GdfFSTFileList;
    while(FileItem != NULL) {
        ++Temp;
        FileItem = FileItem->Link;
    }

    //
    // Write out the size of the entry list and the size of the string table
    //

    GdfWriteTargetFile(&Temp, 4);
    GdfWriteTargetFile(&GdfStringTableSize, 4);

    //
    // Write out the file entries
    //

    FileItem = GdfFSTFileList;
    while(FileItem != NULL) {
        GdfWriteTargetFile(&FileItem->FirstSector, 20);
        FileItem = FileItem->Link;
    }

    //
    // Write out the string table
    //

    StringItem = GdfFSTStringList;
    while(StringItem != NULL) {
        GdfWriteTargetFile(StringItem->String, StringItem->cch + 1);
        StringItem = StringItem->Link;
    }
}

ULONG
GdfAllocateSectors(
    ULONG NumberOfBytes
    )
{
    ULONG FirstSector;

    FirstSector = GdfEndOfMedia;

    GdfEndOfMedia += (((NumberOfBytes + SECTOR_SIZE - 1) & ~SECTOR_MASK) >> SECTOR_SHIFT);

    return FirstSector;
}

int
GdfCompareFileNames(
    LPCWSTR pwszFileName1,
    LPCWSTR pwszFileName2
    )
{
    LONG n1, n2;
    LPCWSTR Limit;
    UCHAR c1, c2;

    //
    // The following code is adapted from RtlCompareString in ntos\rtl\string.c.
    //

    n1 = (LONG)lstrlenW(pwszFileName1);
    n2 = (LONG)lstrlenW(pwszFileName2);
    Limit = pwszFileName1 + (n1 <= n2 ? n1 : n2);
    while (pwszFileName1 < Limit) {
        c1 = (UCHAR)(*pwszFileName1++);
        c2 = (UCHAR)(*pwszFileName2++);
        if (c1 != c2) {
            c1 = GdfUpperCaseTable[c1];
            c2 = GdfUpperCaseTable[c2];
            if (c1 != c2) {
                return (LONG)c1 - (LONG)c2;
            }
        }
    }
    return n1 - n2;
}

VOID
GdfBuildSourceDirectoryList(
    LPCWSTR pwszSourceDirectoryPath,
    PGDF_FILE_NODE *ReturnedFileNodeList
    )
{
    HANDLE hFind;
    WCHAR wszPathName[MAX_PATH + 16];
    WIN32_FIND_DATAW FindFileData;
    PGDF_FILE_NODE FileNodeList;
    LPWSTR pwszTemp;
    PGDF_FILE_NODE NewFileNode;
    PGDF_FILE_NODE *PreviousFileNode;
    PGDF_FILE_NODE FileNode;

    //
    // Loop over the directory and allocate a GDF_FILE_NODE for each entry that
    // we want to store.  Build an unordered linked list of these nodes.
    //

    FileNodeList = NULL;

    lstrcpyW(wszPathName, pwszSourceDirectoryPath);
    lstrcatW(wszPathName, L"\\*");

    hFind = FindFirstFileW(wszPathName, &FindFileData);

    if (hFind == INVALID_HANDLE_VALUE) {

        if (GetLastError() != ERROR_FILE_NOT_FOUND) {
            fprintf(stderr, "GDFIMAGE: Failed to enumerate files.\n");
            GdfExitProcess(1);
        }

        *ReturnedFileNodeList = NULL;
        return;
    }

    do {

        //
        // Skip the "." and ".." special directory entries.
        //

        if ((lstrcmpW(FindFileData.cFileName, L".") == 0) ||
            (lstrcmpW(FindFileData.cFileName, L"..") == 0)) {
            continue;
        }

        //
        // Files sizes are limited to 32-bits.
        //

        if (FindFileData.nFileSizeHigh != 0) {
            fprintf(stderr, "GDFIMAGE: Source file '%ws' too large.\n",
                FindFileData.cFileName);
            GdfExitProcess(1);
        }

        //
        // File names must use only the lower 256 characters of Unicode.
        //

        for (pwszTemp = FindFileData.cFileName; *pwszTemp != L'\0'; *pwszTemp++) {
            if (*pwszTemp >= 256) {
                fprintf(stderr, "GDFIMAGE: Source file '%ws' contains unsupported characters.\n",
                    FindFileData.cFileName);
                GdfExitProcess(1);
            }
        }

        //
        // Allocate a new file node and initialize its contents.
        //

        NewFileNode = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
            sizeof(GDF_FILE_NODE));

        if (NewFileNode == NULL) {
            fprintf(stderr, "GDFIMAGE: Out of memory.\n");
            GdfExitProcess(1);
        }

        NewFileNode->FileSize = FindFileData.nFileSizeLow;
        NewFileNode->FileAttributes = FindFileData.dwFileAttributes;
        NewFileNode->FileNameLength = lstrlenW(FindFileData.cFileName);
        lstrcpyW(NewFileNode->FileName, FindFileData.cFileName);

        //
        // Insert the node in sorted order by name.
        //

        PreviousFileNode = &FileNodeList;
        FileNode = FileNodeList;

        while (FileNode != NULL) {

            if (GdfCompareFileNames(NewFileNode->FileName, FileNode->FileName) <= 0) {
                break;
            }

            PreviousFileNode = &FileNode->Link;
            FileNode = FileNode->Link;
        }

        *PreviousFileNode = NewFileNode;
        NewFileNode->Link = FileNode;

    } while (FindNextFileW(hFind, &FindFileData));

    if (GetLastError() != ERROR_NO_MORE_FILES) {
        fprintf(stderr, "GDFIMAGE: Failed to enumerate files.\n");
        GdfExitProcess(1);
    }

    FindClose(hFind);

    //
    // Return the list to the caller.
    //

    *ReturnedFileNodeList = FileNodeList;
}

VOID
GdfLayoutSourceDirectoryList(
    PGDF_FILE_NODE FileNodeList,
    PULONG ReturnedDirectoryFileSize
    )
{
    PGDF_FILE_NODE FileNode;
    ULONG DirectoryByteOffset;
    ULONG EntryBytesRequired;

    //
    // Layout the directory entries.  For now, we store the entries as a simple
    // alphabetized list.
    //

    FileNode = FileNodeList;
    DirectoryByteOffset = 0;

    while (FileNode != NULL) {

        //
        // Compute the number of bytes required to hold the directory entry.
        //

        EntryBytesRequired = FIELD_OFFSET(GDF_DIRECTORY_ENTRY, FileName) +
            FileNode->FileNameLength;
        EntryBytesRequired = (EntryBytesRequired + sizeof(ULONG) - 1) & ~(sizeof(ULONG) - 1);

        //
        // If there aren't enough bytes in the sector to hold this directory
        // entry, then skip ahead to the next sector.
        //

        if ((SECTOR_SIZE - (DirectoryByteOffset & SECTOR_MASK)) < EntryBytesRequired) {
            DirectoryByteOffset = (DirectoryByteOffset + SECTOR_SIZE - 1) & ~SECTOR_MASK;
        }

        FileNode->DirectoryByteOffset = DirectoryByteOffset;

        DirectoryByteOffset += EntryBytesRequired;
        FileNode = FileNode->Link;
    }

    *ReturnedDirectoryFileSize = DirectoryByteOffset;
}

VOID
GdfWriteSourceDirectoryList(
    PGDF_FILE_NODE FileNodeList,
    ULONG DirectoryFirstSector,
    ULONG DirectoryFileSize
    )
{
    ULONG NumberOfSectors;
    PGDF_FILE_NODE FileNode;
    ULARGE_INTEGER uliByteOffset;
    GDF_DIRECTORY_ENTRY DirectoryEntry;
    UCHAR FileName[MAX_PATH];
    PWSTR pwszTemp;
    PUCHAR pszTemp;

    //
    // Fill the area that the directory will occupy with negative ones so that
    // the stream is set up properly for the padding needed for incomplete
    // sectors.
    //

    NumberOfSectors = (((DirectoryFileSize + SECTOR_SIZE - 1) & ~SECTOR_MASK) >> SECTOR_SHIFT);
    GdfSeekSectorTargetFile(DirectoryFirstSector);
    GdfWriteFilledSectors(NumberOfSectors, 0xFF);

    //
    // Loop over the file node list and write out each directory entry.
    //

    FileNode = FileNodeList;

    while (FileNode != NULL) {

        //
        // Fill in the directory entry.
        //

        ZeroMemory(&DirectoryEntry, sizeof(DirectoryEntry));

        DirectoryEntry.FirstSector = FileNode->FirstSector;
        DirectoryEntry.FileSize = FileNode->FileSize;
        DirectoryEntry.FileAttributes = (UCHAR)FileNode->FileAttributes;
        DirectoryEntry.FileNameLength = (UCHAR)FileNode->FileNameLength;

        if (FileNode->Link != NULL) {
            DirectoryEntry.RightEntryIndex = (USHORT)((FileNode->Link->DirectoryByteOffset >> 2));
        }

        //
        // Build the 8-bit version of the file name.
        //

        pwszTemp = FileNode->FileName;
        pszTemp = FileName;

        while (*pwszTemp != L'\0') {
            *pszTemp++ = (UCHAR)(*pwszTemp++);
        }

        //
        // Seek to the directory entry's byte offset and write out the entry.
        //

        uliByteOffset.QuadPart = ((ULONGLONG)DirectoryFirstSector << SECTOR_SHIFT) +
            FileNode->DirectoryByteOffset;
        GdfSeekByteTargetFile(&uliByteOffset);
        GdfWriteTargetFile(&DirectoryEntry, FIELD_OFFSET(GDF_DIRECTORY_ENTRY, FileName));
        GdfWriteTargetFile(FileName, DirectoryEntry.FileNameLength);

        //
        // Advance to the next node.
        //

        FileNode = FileNode->Link;
    }
}

VOID
GdfFreeSourceDirectoryList(
    PGDF_FILE_NODE FileNodeList
    )
{
    PGDF_FILE_NODE NextLink;

    while (FileNodeList != NULL) {
        NextLink = FileNodeList->Link;
        HeapFree(GetProcessHeap(), 0, FileNodeList);
        FileNodeList = NextLink;
    }
}

VOID
GdfProcessSourceFileForFST(
    PULONG ReturnedFileFirstSector,
    ULONG FileSize,
    LPCWSTR FileName,
    ULONG DirectoryStringIndex
    )
{
    PFST_FILE_ITEM FSTEntry;
    ULONG FirstSector;

    //
    // Trivial case.  If the file is empty, then we don't need to allocate any
    // sectors for the file.
    //

    if (FileSize == 0) {
        *ReturnedFileFirstSector = 0;
        return;
    }

    //
    // Allocate space for this file
    //

    FirstSector = GdfAllocateSectors(FileSize);

    //
    // Create an entry in the FST
    //

    FSTEntry = GdfCreateFSTEntry(FirstSector, FileSize, TRUE);
    FSTEntry->FileOffset = 0;
    FSTEntry->DirectoryIndex = DirectoryStringIndex;

    //
    // Create a string table entry for this file name
    //

    GdfAllocateFSTStringW(FileName, &FSTEntry->FileIndex);

    *ReturnedFileFirstSector = FirstSector;
}

VOID
GdfProcessSourceFile(
    LPCWSTR pwszSourceFilePath,
    PULONG ReturnedFileFirstSector,
    ULONG FileSize
    )
{
    HANDLE hFile;
    ULONG FileFirstSector;
    DWORD cbBytesRemaining;
    DWORD cbRead;
    DWORD cbZeroPadding;

    //
    // Trivial case.  If the file is empty, then we don't need to allocate any
    // sectors for the file.
    //

    if (FileSize == 0) {
        *ReturnedFileFirstSector = 0;
        return;
    }

    //
    // Open the source file.
    //

    hFile = CreateFileW(pwszSourceFilePath, GENERIC_READ, FILE_SHARE_READ |
        FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL |
        FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_NO_BUFFERING, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        fprintf(stderr, "GDFIMAGE: Unable to open source file.\n");
        GdfExitProcess(1);
    }

    //
    // Allocate the sectors for the file.
    //

    FileFirstSector = GdfAllocateSectors(FileSize);
    GdfSeekSectorTargetFile(FileFirstSector);

    //
    // Copy the source file to the target file.
    //

    cbBytesRemaining = FileSize;

    do {

        if (!ReadFile(hFile, GdfTransferBuffer, sizeof(GdfTransferBuffer),
            &cbRead, NULL)) {
            fprintf(stderr, "GDFIMAGE: Unable to read source file.\n");
            GdfExitProcess(1);
        }

        GdfWriteTargetFile(GdfTransferBuffer, cbRead);

        cbBytesRemaining -= cbRead;

    } while (cbBytesRemaining > 0);

    //
    // Pad the rest of the last sector with zeroes.
    //

    cbZeroPadding = SECTOR_SIZE - (FileSize & SECTOR_MASK);

    if (cbZeroPadding != SECTOR_SIZE) {
        FillMemory(GdfTransferBuffer, cbZeroPadding, 0);
        GdfWriteTargetFile(GdfTransferBuffer, cbZeroPadding);
    }

    CloseHandle(hFile);

    *ReturnedFileFirstSector = FileFirstSector;
}

VOID
GdfProcessSourceDirectory(
    LPCWSTR pwszSourceDirectoryPath,
    LPCSTR pszSourceDirectoryAnsiPath,
    PULONG ReturnedDirectoryFirstSector,
    PULONG ReturnedDirectoryFileSize
    )
{
    PGDF_FILE_NODE FileNodeList;
    ULONG DirectoryFileSize;
    ULONG DirectoryFirstSector;
    PGDF_FILE_NODE FileNode;
    WCHAR wszSourceFileName[MAX_PATH];
    char szChildDirectoryAnsiName[MAX_PATH];
    ULONG DirectoryStringIndex;
    PFST_FILE_ITEM DirectoryFSTEntry = NULL;

    printf("Processing directory %ws.\n", pwszSourceDirectoryPath);

    //
    // Build the list of files in this directory.
    //

    GdfBuildSourceDirectoryList(pwszSourceDirectoryPath, &FileNodeList);

    //
    // Check if this is a non-empty directory.
    //

    if (FileNodeList != NULL) {

        //
        // If we're making an FST file, allocate a string for this
        // directory
        //

        GdfAllocateFSTStringA(pszSourceDirectoryAnsiPath,
            &DirectoryStringIndex);

        //
        // Determine the byte offsets for all of the directory's files.
        //

        GdfLayoutSourceDirectoryList(FileNodeList, &DirectoryFileSize);

        //
        // Allocate the sectors for the directory stream.
        //

        DirectoryFirstSector = GdfAllocateSectors(DirectoryFileSize);
        if(GdfCreateFST) {
            DirectoryFSTEntry = GdfCreateFSTEntry(DirectoryFirstSector,
                DirectoryFileSize, TRUE);
            DirectoryFSTEntry->DirectoryIndex = GdfDirectoryDirectoryIndex;
            DirectoryFSTEntry->FileIndex = GdfDirectoryFileIndex;
        }


        //
        // Write out all of the files in this directory.
        //

        FileNode = FileNodeList;

        do {

            if ((FileNode->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {

                if(GdfCreateFST) {
                    GdfProcessSourceFileForFST(&FileNode->FirstSector,
                        FileNode->FileSize, FileNode->FileName,
                        DirectoryStringIndex);
                } else {
                    lstrcpyW(wszSourceFileName, pwszSourceDirectoryPath);
                    lstrcatW(wszSourceFileName, L"\\");
                    lstrcatW(wszSourceFileName, FileNode->FileName);

                    GdfProcessSourceFile(wszSourceFileName,
                        &FileNode->FirstSector, FileNode->FileSize);
                }

                //
                // If this is the root directory and we've found XBOXROM.BIN,
                // then remember where the file is located so that we can later
                // build the boot sector if necessary.
                //

                if ((pwszSourceDirectoryPath == GdfSourceDirectoryPath) &&
                    (lstrcmpiW(FileNode->FileName, L"XBOXROM.BIN") == 0)) {
                    GdfXBOXROMFirstSector = FileNode->FirstSector;
                    GdfXBOXROMFileSize = FileNode->FileSize;
                }
            }

            FileNode = FileNode->Link;

        } while (FileNode != NULL);

        //
        // Write out all of the files in this directory.
        //

        FileNode = FileNodeList;

        do {

            if ((FileNode->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0) {

                lstrcpyW(wszSourceFileName, pwszSourceDirectoryPath);
                lstrcatW(wszSourceFileName, L"\\");
                lstrcatW(wszSourceFileName, FileNode->FileName);

                lstrcpyA(szChildDirectoryAnsiName, pszSourceDirectoryAnsiPath);
                lstrcatA(szChildDirectoryAnsiName, "\\");
                GdfAppendUnicodeToAnsi(szChildDirectoryAnsiName,
                    FileNode->FileName);

                GdfProcessSourceDirectory(wszSourceFileName,
                    szChildDirectoryAnsiName, &FileNode->FirstSector,
                    &FileNode->FileSize);
            }

            FileNode = FileNode->Link;

        } while (FileNode != NULL);

        //
        // Write out the directory stream.
        //

        if(GdfCreateFST) {
            DirectoryFSTEntry->FileOffset = GdfCurrentMediaPosition <<
                SECTOR_SHIFT;
            GdfWriteSourceDirectoryList(FileNodeList, GdfCurrentMediaPosition,
                DirectoryFileSize);
            GdfCurrentMediaPosition += (DirectoryFileSize +
                ((1 << SECTOR_SHIFT) - 1)) >> SECTOR_SHIFT;
        } else {
            GdfWriteSourceDirectoryList(FileNodeList, DirectoryFirstSector,
                DirectoryFileSize);
        }

        //
        // Free the list of files in the directory.
        //

        GdfFreeSourceDirectoryList(FileNodeList);

    } else {

        //
        // The directory is empty.  Return a zero starting sector and size to
        // the caller.
        //

        DirectoryFirstSector = 0;
        DirectoryFileSize = 0;
    }

    *ReturnedDirectoryFirstSector = DirectoryFirstSector;
    *ReturnedDirectoryFileSize = DirectoryFileSize;
}

VOID
GdfWriteEndOfMediaPadding(
    VOID
    )
{
    ULONG OldEndOfMedia;

    OldEndOfMedia = GdfEndOfMedia;

    //
    // The media needs to be padded up to a 64K block boundary.
    //

    GdfEndOfMedia = (GdfEndOfMedia + 1 + (65536 / SECTOR_SIZE)) & ~((65536 / SECTOR_SIZE) - 1);

    //
    // Fill the padding sectors with zeroes.
    //

    GdfSeekSectorTargetFile(OldEndOfMedia);
    GdfWriteFilledSectors(GdfEndOfMedia - OldEndOfMedia, 0);
}

VOID
GdfFinalizeBootSector(
    VOID
    )
{
    PULONG BootSectorXBOXROMFirstSector;
    PULONG BootSectorXBOXROMFileSize;

    //
    // Verify that we placed an XBOXROM.BIN in the root of the image.
    //

    if (GdfXBOXROMFirstSector == 0) {
        fprintf(stderr, "GDFIMAGE: XBOXROM.BIN is required in order to a create bootable disc.\n");
        GdfExitProcess(1);
    }

    //
    // Store the first sector and file size of XBOXROM.BIN in the boot sector.
    //

    BootSectorXBOXROMFirstSector = (PULONG)(GdfBootSector + SECTOR_SIZE - 10);
    BootSectorXBOXROMFileSize = (PULONG)(GdfBootSector + SECTOR_SIZE - 6);

    *BootSectorXBOXROMFirstSector = GdfXBOXROMFirstSector;
    *BootSectorXBOXROMFileSize = GdfXBOXROMFileSize;
}

VOID
GdfWriteGdfVolumeDescriptor(
    ULONG RootDirectoryFirstSector,
    ULONG RootDirectoryFileSize
    )
{
    GDF_VOLUME_DESCRIPTOR VolumeDescriptor;

    //
    // Fill in the volume descriptor.
    //

    ZeroMemory(&VolumeDescriptor, sizeof(VolumeDescriptor));

    CopyMemory(VolumeDescriptor.HeadSignature, GDF_VOLUME_DESCRIPTOR_SIGNATURE,
        sizeof(VolumeDescriptor.HeadSignature));

    VolumeDescriptor.RootDirectoryFirstSector = RootDirectoryFirstSector;
    VolumeDescriptor.RootDirectoryFileSize = RootDirectoryFileSize;

    GetSystemTimeAsFileTime((LPFILETIME)&VolumeDescriptor.TimeStamp);

    CopyMemory(VolumeDescriptor.TailSignature, GDF_VOLUME_DESCRIPTOR_SIGNATURE,
        sizeof(VolumeDescriptor.TailSignature));

    //
    // Write out the GDF volume descriptor.
    //

    GdfWriteTargetFile(&VolumeDescriptor, sizeof(VolumeDescriptor));
}

VOID
GdfWriteIso9960PrimaryVolumeDescriptor(
    VOID
    )
{
    RAW_ISO_VD VolumeDescriptor;

    //
    // Fill in the volume descriptor.
    //

    ZeroMemory(&VolumeDescriptor, sizeof(VolumeDescriptor));

    VolumeDescriptor.DescType = VD_PRIMARY;
    CopyMemory(VolumeDescriptor.StandardId, ISO_VOL_ID, sizeof(VolumeDescriptor.StandardId));
    VolumeDescriptor.Version = VERSION_1;
    VolumeDescriptor.VolSpaceI = GdfEndOfMedia;
    VolumeDescriptor.VolSpaceM = GdfByteSwap32(GdfEndOfMedia);
    VolumeDescriptor.VolSetSizeI = 1;
    VolumeDescriptor.VolSetSizeM = GdfByteSwap16(1);
    VolumeDescriptor.VolSeqNumI = 1;
    VolumeDescriptor.VolSeqNumM = GdfByteSwap16(1);
    VolumeDescriptor.LogicalBlkSzI = SECTOR_SIZE;
    VolumeDescriptor.LogicalBlkSzM = GdfByteSwap16(SECTOR_SIZE);
    FillMemory(VolumeDescriptor.VolSetId, sizeof(VolumeDescriptor.VolSetId), ' ');
    FillMemory(VolumeDescriptor.PublId, sizeof(VolumeDescriptor.PublId), ' ');
    FillMemory(VolumeDescriptor.PreparerId, sizeof(VolumeDescriptor.PreparerId), ' ');
    FillMemory(VolumeDescriptor.AppId, sizeof(VolumeDescriptor.AppId), ' ');
    FillMemory(VolumeDescriptor.Copyright, sizeof(VolumeDescriptor.Copyright), ' ');
    FillMemory(VolumeDescriptor.Abstract, sizeof(VolumeDescriptor.Abstract), ' ');
    FillMemory(VolumeDescriptor.Bibliograph, sizeof(VolumeDescriptor.Bibliograph), ' ');
    strcpy((LPSTR)VolumeDescriptor.CreateDate, "0000000000000000");
    strcpy((LPSTR)VolumeDescriptor.ModDate, "0000000000000000");
    strcpy((LPSTR)VolumeDescriptor.ExpireDate, "0000000000000000");
    strcpy((LPSTR)VolumeDescriptor.EffectDate, "0000000000000000");
    VolumeDescriptor.FileStructVer = VERSION_1;

    //
    // Write out the ISO-9960 primary volume descriptor.
    //

    GdfWriteTargetFile(&VolumeDescriptor, sizeof(VolumeDescriptor));
}

VOID
GdfWriteElToritoBootVolumeDescriptor(
    VOID
    )
{
    UCHAR BootVolumeDescriptor[SECTOR_SIZE];

    //
    // The following code is adapted from CDIMAGE.EXE.
    //

    ZeroMemory(BootVolumeDescriptor, sizeof(BootVolumeDescriptor));

    BootVolumeDescriptor[ 0 ] = 0x00;        // boot volume descriptor
    BootVolumeDescriptor[ 6 ] = 0x01;        // volume descriptor version

    memcpy( BootVolumeDescriptor + 1, "CD001", 5 );
    memcpy( BootVolumeDescriptor + 7, "EL TORITO SPECIFICATION", 23 );

    *(UNALIGNED DWORD*)( BootVolumeDescriptor + 0x47 ) = GDF_ELTORITO_BOOT_CATALOG_SECTOR;

    //
    // Write out the El Torito boot volume descriptor.
    //

    GdfWriteTargetFile(BootVolumeDescriptor, sizeof(BootVolumeDescriptor));
}

VOID
GdfWriteIso9960TerminatingDescriptor(
    VOID
    )
{
    RAW_ISO_VD VolumeDescriptor;

    //
    // Fill in the volume descriptor.
    //

    ZeroMemory(&VolumeDescriptor, sizeof(VolumeDescriptor));

    VolumeDescriptor.DescType = VD_TERMINATOR;
    CopyMemory(VolumeDescriptor.StandardId, ISO_VOL_ID, sizeof(VolumeDescriptor.StandardId));
    VolumeDescriptor.Version = VERSION_1;

    //
    // Write out the ISO-9960 terminating descriptor.
    //

    GdfWriteTargetFile(&VolumeDescriptor, sizeof(VolumeDescriptor));
}

VOID
GdfWriteElToritoBootCatalog(
    VOID
    )
{
    UCHAR BootCatalog[SECTOR_SIZE];
    DWORD CheckSum;
    DWORD i;

    //
    // The following code is adapted from CDIMAGE.EXE.
    //

    //
    // First 0x20 bytes is the validation entry
    //

    BootCatalog[ 0x00 ] = 0x01;     // Validation Entry Header ID
    BootCatalog[ 0x01 ] = 0x00;     // Platform ID = 80x86

    memcpy( BootCatalog + 4, "Microsoft Corporation", 21 );

    BootCatalog[ 0x1E ] = 0x55;     // key byte
    BootCatalog[ 0x1F ] = 0xAA;     // key byte

    for ( CheckSum = 0, i = 0; i < 0x20; i += 2 ) {
        CheckSum += *(UNALIGNED WORD*)( BootCatalog + i );
        }

    CheckSum = ( 0x10000 - ( CheckSum & 0xFFFF ));

    *(UNALIGNED WORD*)( BootCatalog + 0x1C ) = (WORD)CheckSum;

    //
    // Second 0x20 bytes is the initial/default entry.
    //

    BootCatalog[ 0x20 ] = 0x88;             // Initial/Default Entry Boot Indicator
    BootCatalog[ 0x21 ] = 0;                // "no emulation" mode

    // Load Segment (where to load in DOS memory).  If zero, loads at 0x07C0.

    *(UNALIGNED WORD*)(BootCatalog + 0x22) = 0;

    // Sector Count (number of 512-byte "virtual sectors" to load from CD):

    *(UNALIGNED WORD*)( BootCatalog + 0x26 ) = (SECTOR_SIZE / 512);

    // Load address (CD sector number) of boot sector file:

    *(UNALIGNED DWORD*)( BootCatalog + 0x28 ) = GDF_ELTORITO_BOOT_SECTOR;

    //
    // Write out the El Torito boot catalog.
    //

    GdfWriteTargetFile(BootCatalog, sizeof(BootCatalog));
}

BOOL
WINAPI
GdfConsoleCtrlHandler(
    DWORD dwCtrlType
    )
{
    switch (dwCtrlType) {

        case CTRL_C_EVENT:
        case CTRL_BREAK_EVENT:
        case CTRL_CLOSE_EVENT:
        case CTRL_LOGOFF_EVENT:
        case CTRL_SHUTDOWN_EVENT:
            GdfAbnormalTermination = TRUE;
            return TRUE;

        default:
            return FALSE;
    }
}

int
__cdecl
wmain(
    int argc,
    wchar_t *argv[]
    )
{
    ULONG RootDirectoryFirstSector;
    ULONG RootDirectoryFileSize;
    PFST_FILE_ITEM VolumeDescriptorFSTEntry;
    char szRootDirectoryName[MAX_PATH];

    //
    // Print the banner.
    //

    fprintf(stderr, "Microsoft (R) Xbox Game Disc Premastering Utility %s\n", VER_PRODUCTVERSION_STR);
    fprintf(stderr, "Copyright (C) Microsoft Corporation 2001. All rights reserved.\n\n");

    //
    // Process the command line arguments.
    //

    GdfProcessCommandLineOptions(argc, argv);

    //
    // Check if the source path exists and that it is a directory.
    //

    GdfCheckSourceDirectoryExists();

    //
    // Set a console control handler to watch for break events so that we can
    // delete the output file.
    //

    SetConsoleCtrlHandler(GdfConsoleCtrlHandler, TRUE);

    //
    // Open the target output file.
    //

    GdfOpenTargetFile();

    //
    // Zero fill the data from the start of the volume to the first data sector.
    //

    if(!GdfCreateFST)
        GdfWriteFilledSectors(GDF_STARTING_DATA_SECTOR, 0);

    //
    // Start adding all of the files from the specified root directory.
    //

    if(GdfCreateFST)
        GdfFillRootDirectoryName(szRootDirectoryName, GdfSourceDirectoryPath);
    else
        szRootDirectoryName[0] = 0;
    GdfProcessSourceDirectory(GdfSourceDirectoryPath, szRootDirectoryName,
        &RootDirectoryFirstSector, &RootDirectoryFileSize);

    if(!GdfCreateFST) {

        //
        // Add padding sectors to the end of the media.
        //

        GdfWriteEndOfMediaPadding();

        //
        // If we're creating a PC bootable media, finalize the boot sector's
        // contents.
        //

        if (GdfHaveBootSector) {
            GdfFinalizeBootSector();
        }
    }

    //
    // Write out the GDF volume descriptor.
    //

    if(GdfCreateFST) {
        VolumeDescriptorFSTEntry =
            GdfCreateFSTEntry(GDF_VOLUME_DESCRIPTOR_SECTOR, 1 << SECTOR_SHIFT,
            FALSE);
        VolumeDescriptorFSTEntry->DirectoryIndex = GdfDirectoryDirectoryIndex;
        VolumeDescriptorFSTEntry->FileIndex = GdfDirectoryFileIndex;
        VolumeDescriptorFSTEntry->FileOffset = GdfCurrentMediaPosition << SECTOR_SHIFT;
        GdfSeekSectorTargetFile(GdfCurrentMediaPosition);
    } else
        GdfSeekSectorTargetFile(GDF_VOLUME_DESCRIPTOR_SECTOR);
    GdfWriteGdfVolumeDescriptor(RootDirectoryFirstSector, RootDirectoryFileSize);

    if(!GdfCreateFST) {

        //
        // Write out the ISO-9960 volume descriptor sequence.  Note that this is
        // only required in order to use tools such as CD burning software that
        // import .ISO images.
        //

        GdfSeekSectorTargetFile(FIRST_VD_SECTOR);

        GdfWriteIso9960PrimaryVolumeDescriptor();

        if (GdfHaveBootSector) {
            GdfWriteElToritoBootVolumeDescriptor();
        }

        GdfWriteIso9960TerminatingDescriptor();

        //
        // Write out the boot sector code.
        //

        if (GdfHaveBootSector) {
            GdfSeekSectorTargetFile(GDF_ELTORITO_BOOT_CATALOG_SECTOR);
            GdfWriteElToritoBootCatalog();
            GdfWriteTargetFile(GdfBootSector, sizeof(GdfBootSector));
        }
    }

    //
    // Write out the FST file
    //

    if(GdfCreateFST)
        GdfWriteFSTFile();

    GdfExitProcess(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagebld.new\memory.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    memory.cpp

Abstract:

    This module implements memory allocation related routines for the utility
    program to build an Xbox executable image.

--*/

#include "imgbldp.h"

LPVOID
ImgbAllocateMemory(
    SIZE_T cbBytes
    )
{
    LPVOID lpvMemory;

    lpvMemory = (LPVOID)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cbBytes);

    if (lpvMemory == NULL) {
        ImgbResourcePrintErrorAndExit(IDS_NO_MEMORY);
    }

    return lpvMemory;
}

VOID
ImgbFreeMemory(
    LPVOID lpMemory
    )
{
    LocalFree((HLOCAL)lpMemory);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagebld.new\imgbldp.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    imgbldp.h

Abstract:

    This module contains the private data structures and procedure prototypes
    for the utility program to build an Xbox executable image.

--*/

#ifndef _IMGBLDP_
#define _IMGBLDP_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <time.h>
#include <errno.h>
#include <xbeimage.h>
#include <cklibver.h>
#include <sha.h>
#include "imgbldrc.h"

//
// Define the size of a processor page.
//

#define PAGE_SIZE                               0x1000

//
// Define a macro to align a virtual address to a page boundary.
//

#define PAGE_ALIGN(Va) ((PVOID)((ULONG_PTR)(Va) & ~(PAGE_SIZE - 1)))

//
// Define a macro to obtain the byte offset within a page for a virtual address.
//

#define BYTE_OFFSET(Va) ((ULONG)((LONG_PTR)(Va) & (PAGE_SIZE - 1)))

//
// Define a macro to round a number of bytes to the nearest page boundary.
//

#define ROUND_TO_PAGES(Size) (((ULONG_PTR)(Size) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1))

//
// Define the structure to track sections that should not be preloaded.
//

typedef struct _IMGB_NOPRELOAD {
    LIST_ENTRY ListEntry;
    LPSTR SectionName;
} IMGB_NOPRELOAD, *PIMGB_NOPRELOAD;

//
// Define the structure to track files that should be inserted into the image as
// sections.
//

typedef struct _IMGB_INSERTFILE {
    LIST_ENTRY ListEntry;
    HANDLE FileHandle;
    ULONG FileSize;
    LPSTR FilePath;
    LPSTR SectionName;
    ULONG FileByteOffset;
    BOOLEAN NoPreload;
    BOOLEAN ReadOnly;
} IMGB_INSERTFILE, *PIMGB_INSERTFILE;

//
// Define the default alignment of /INSERTFILE sections.
//

#define IMGB_INSERTFILE_SECTION_ALIGNMENT       32

//
// Define the maximum number of bytes that may be mapped by an XBE image.
//

#define IMGB_MAXIMUM_IMAGE_SIZE                 0x80000000

//
// Define the structures to track data associated with the various subheaders of
// an XBE image.
//

typedef struct _IMGB_GENERIC_HEADER {
    LIST_ENTRY HeadersListEntry;
    PVOID VirtualAddress;
    ULONG VirtualSize;
    virtual VOID Write() = 0;
} IMGB_GENERIC_HEADER, *PIMGB_GENERIC_HEADER;

typedef struct _IMGB_XBEIMAGE_CERTIFICATE_HEADER: public IMGB_GENERIC_HEADER {
    VOID Write();
} IMGB_XBEIMAGE_CERTIFICATE_HEADER, *PIMGB_XBEIMAGE_CERTIFICATE_HEADER;

typedef struct _IMGB_XBEIMAGE_IMPORT_DESCRIPTOR_HEADER: public IMGB_GENERIC_HEADER {
    ULONG NumberOfNonKernelImports;
    ULONG SizeOfNonKernelImageNames;
    VOID Write();
} IMGB_XBEIMAGE_IMPORT_DESCRIPTOR_HEADER, *PIMGB_XBEIMAGE_IMPORT_DESCRIPTOR_HEADER;

typedef struct _IMGB_TLS_RAW_DATA_HEADER: public IMGB_GENERIC_HEADER {
    PIMAGE_TLS_DIRECTORY TlsDirectory;
    LPBYTE RawData;
    VOID Write();
} IMGB_TLS_RAW_DATA_HEADER, *PIMGB_TLS_RAW_DATA_HEADER;

typedef struct _IMGB_XBEIMAGE_LIBRARY_VERSION_HEADER: public IMGB_GENERIC_HEADER {
    PXBEIMAGE_LIBRARY_VERSION LibraryVersions;
    ULONG XboxKernelOffset;
    ULONG XapiOffset;
    VOID Write();
} IMGB_XBEIMAGE_LIBRARY_VERSION_HEADER, *PIMGB_XBEIMAGE_LIBRARY_VERSION_HEADER;

typedef struct _IMGB_XBEIMAGE_SECTION_HEADERS: public IMGB_GENERIC_HEADER {
    ULONG NumberOfExecutableSections;
    ULONG NumberOfInsertFileSections;
    ULONG SizeOfSectionNames;
    ULONG NumberOfSharedPageReferenceCounts;
    VOID Write();
} IMGB_XBEIMAGE_SECTION_HEADERS, *PIMGB_XBEIMAGE_SECTION_HEADERS;

typedef struct _IMGB_DEBUG_PATHS_HEADER: public IMGB_GENERIC_HEADER {
    VOID Write();
} IMGB_DEBUG_PATHS_HEADER, *PIMGB_DEBUG_PATHS_HEADER;

typedef struct _IMGB_MICROSOFT_LOGO_HEADER: public IMGB_GENERIC_HEADER {
    VOID Write();
} IMGB_MICROSOFT_LOGO_HEADER, *PIMGB_MICROSOFT_LOGO_HEADER;

typedef struct _IMGB_PEHEADER_HEADER: public IMGB_GENERIC_HEADER {
    VOID Write();
} IMGB_PEHEADER_HEADER, *PIMGB_PEHEADER_HEADER;

//
// Define the structure to track all of the contributions to an XBE image.
//

typedef struct _IMGB_XBEIMAGE_HEADER {
    LIST_ENTRY HeadersListHead;
    XBEIMAGE_HEADER ImageHeader;
    IMGB_XBEIMAGE_CERTIFICATE_HEADER CertificateHeader;
    IMGB_XBEIMAGE_IMPORT_DESCRIPTOR_HEADER ImportDescriptorHeader;
    IMGB_TLS_RAW_DATA_HEADER TlsRawDataHeader;
    IMGB_XBEIMAGE_LIBRARY_VERSION_HEADER LibraryVersionHeader;
    IMGB_XBEIMAGE_SECTION_HEADERS SectionHeaders;
    IMGB_DEBUG_PATHS_HEADER DebugPathsHeader;
    IMGB_MICROSOFT_LOGO_HEADER MicrosoftLogoHeader;
    IMGB_PEHEADER_HEADER PEHeaderHeader;
    ULONG NewBaseAddress;
    ULONG SizeOfExecutableImage;
    ULONG SizeOfInsertFilesImage;
} IMGB_XBEIMAGE_HEADER, *PIMGB_XBEIMAGE_HEADER;

//
// Sub-utility programs.
//

DECLSPEC_NORETURN
VOID
ImgbDumpExecutable(
    int argc,
    char *argv[]
    );

//
// General support functions.
//

DECLSPEC_NORETURN
VOID
ImgbExitProcess(
    int ExitCode
    );

LPVOID
ImgbAllocateMemory(
    SIZE_T cbBytes
    );

VOID
ImgbFreeMemory(
    LPVOID lpMemory
    );

//
// Command line support functions.
//

VOID
ImgbProcessCommandLineOptions(
    int argc,
    char *argv[]
    );

BOOLEAN
ImgbSearchNoPreloadList(
    LPCSTR pszSectionName
    );

//
// Portable Executable (PE) module support functions.
//

PIMAGE_SECTION_HEADER
ImgbNameToSectionHeader(
    PIMAGE_NT_HEADERS NtHeader,
    PUCHAR SearchName,
    PULONG SectionIndex
    );

PIMAGE_SECTION_HEADER
ImgbVirtualAddressToSectionHeader(
    PIMAGE_NT_HEADERS NtHeader,
    ULONG VirtualAddress
    );

LPVOID
ImgbVirtualAddressToData(
    PIMAGE_NT_HEADERS NtHeader,
    ULONG VirtualAddress
    );

LPVOID
ImgbImageDataDirectoryToData(
    PIMAGE_NT_HEADERS NtHeader,
    ULONG DataDirectoryIndex
    );

LPVOID
ImgbLoadAddressToData(
    PIMAGE_NT_HEADERS NtHeader,
    ULONG LoadAddress
    );

VOID
ImgbRelocateImage(
    PIMAGE_NT_HEADERS NtHeader,
    ULONG OldBaseAddress,
    ULONG NewBaseAddress,
    PIMAGE_BASE_RELOCATION NextBlock,
    ULONG TotalCountBytes
    );

//
// String resource support functions.
//

VOID
ImgbResourcePrintfV(
    FILE *file,
    UINT uStringID,
    va_list args
    );

VOID
ImgbResourcePrintf(
    FILE *file,
    UINT uStringID,
    ...
    );

VOID
ImgbResourcePrintErrorAndExit(
    UINT uStringID,
    ...
    );

VOID
ImgbResourcePrintWarning(
    UINT uStringID,
    ...
    );

VOID
ImgbResourcePrintRange(
    FILE *file,
    UINT uStartingStringID
    );

VOID
ImgbResourcePrintLogoBanner(
    VOID
    );

//
// C++ default operator overrides.
//

__inline LPVOID __cdecl operator new(size_t cbBytes)
{
    return ImgbAllocateMemory(cbBytes);
}

__inline VOID __cdecl operator delete(LPVOID lpMemory)
{
    ImgbFreeMemory(lpMemory);
}

//
// External symbols.
//

extern LPSTR ImgbInputFilePath;
extern LPSTR ImgbOutputFilePath;
extern LIST_ENTRY ImgbNoPreloadList;
extern LIST_ENTRY ImgbInsertFileList;
extern BOOLEAN ImgbEmitPEHeader;
extern ULONG ImgbSizeOfStack;
extern ULONG ImgbInitFlags;
extern ULONG ImgbVersion;
extern ULONG ImgbTestGameRegion;
extern ULONG ImgbTestAllowedMediaTypes;
extern ULONG ImgbTestGameRatings;
extern ULONG ImgbTestTitleID;
extern ULONG ImgbTestAlternateTitleIDs[XBEIMAGE_ALTERNATE_TITLE_ID_COUNT];
extern XBEIMAGE_CERTIFICATE_KEY ImgbTestAlternateSignatureKeys[XBEIMAGE_ALTERNATE_TITLE_ID_COUNT];
extern WCHAR ImgbTestTitleName[XBEIMAGE_TITLE_NAME_LENGTH];
extern UCHAR ImgbTestLANKey[XBEIMAGE_CERTIFICATE_KEY_LENGTH];
extern UCHAR ImgbTestSignatureKey[XBEIMAGE_CERTIFICATE_KEY_LENGTH];
extern HANDLE ImgbInputFileHandle;
extern ULONG ImgbInputFileSize;
extern HANDLE ImgbInputFileMappingHandle;
extern LPVOID ImgbInputFileMappingView;
extern UCHAR ImgbPrivateKeyData[];
extern UCHAR ImgbPublicKeyData[];
extern BOOLEAN ImgbNoWarnLibraryApproval;

#endif // IMGBLDP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagebld.new\pemodule.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    pemodule.cpp

Abstract:

    This module implements Portable Executable (PE) module related routines for
    the utility program to build an Xbox executable image.

--*/

#include "imgbldp.h"

PIMAGE_SECTION_HEADER
ImgbNameToSectionHeader(
    PIMAGE_NT_HEADERS NtHeader,
    PUCHAR SearchName,
    PULONG SectionIndex
    )
{
    ULONG SectionsRemaining;
    PIMAGE_SECTION_HEADER SectionHeader;
    UCHAR SectionName[IMAGE_SIZEOF_SHORT_NAME + 1];

    //
    // Walk through each of the image's sections and find the section that has
    // the requested section name.
    //

    SectionsRemaining = NtHeader->FileHeader.NumberOfSections;
    SectionHeader = IMAGE_FIRST_SECTION(NtHeader);

    while (SectionsRemaining) {

        memcpy(SectionName, SectionHeader->Name, IMAGE_SIZEOF_SHORT_NAME);
        SectionName[IMAGE_SIZEOF_SHORT_NAME] = '\0';

        if (_stricmp((PSTR)SectionName, (PSTR)SearchName) == 0) {
            *SectionIndex = SectionHeader - IMAGE_FIRST_SECTION(NtHeader);
            return SectionHeader;
        }

        SectionsRemaining--;
        SectionHeader++;
    }

    return NULL;
}

PIMAGE_SECTION_HEADER
ImgbVirtualAddressToSectionHeader(
    PIMAGE_NT_HEADERS NtHeader,
    ULONG VirtualAddress
    )
{
    ULONG SectionsRemaining;
    PIMAGE_SECTION_HEADER SectionHeader;

    //
    // Walk through each of the image's sections and find the section that
    // contains the requested virtual address.
    //

    SectionsRemaining = NtHeader->FileHeader.NumberOfSections;
    SectionHeader = IMAGE_FIRST_SECTION(NtHeader);

    while (SectionsRemaining) {

        if ((VirtualAddress >= SectionHeader->VirtualAddress) &&
            (VirtualAddress < SectionHeader->VirtualAddress + SectionHeader->SizeOfRawData)) {
            return SectionHeader;
        }

        SectionsRemaining--;
        SectionHeader++;
    }

    //
    // If the section mapping the requested virtual address cannot be found,
    // then the input file must be corrupt.
    //

    ImgbResourcePrintErrorAndExit(IDS_INVALID_CORRUPT_INPUT_FILE, ImgbInputFilePath);
    return NULL;
}

LPVOID
ImgbVirtualAddressToData(
    PIMAGE_NT_HEADERS NtHeader,
    ULONG VirtualAddress
    )
{
    PIMAGE_SECTION_HEADER SectionHeader;

    SectionHeader = ImgbVirtualAddressToSectionHeader(NtHeader, VirtualAddress);

    return (LPBYTE)ImgbInputFileMappingView + SectionHeader->PointerToRawData +
        (VirtualAddress - SectionHeader->VirtualAddress);
}

LPVOID
ImgbImageDataDirectoryToData(
    PIMAGE_NT_HEADERS NtHeader,
    ULONG DataDirectoryIndex
    )
{
    return ImgbVirtualAddressToData(NtHeader,
        NtHeader->OptionalHeader.DataDirectory[DataDirectoryIndex].VirtualAddress);
}

LPVOID
ImgbLoadAddressToData(
    PIMAGE_NT_HEADERS NtHeader,
    ULONG LoadAddress
    )
{
    ULONG VirtualAddress;

    VirtualAddress = LoadAddress - NtHeader->OptionalHeader.ImageBase;

    return ImgbVirtualAddressToData(NtHeader, VirtualAddress);
}

PIMAGE_BASE_RELOCATION
ImgbProcessRelocationBlock(
    PIMAGE_NT_HEADERS NtHeader,
    IN ULONG VA,
    IN ULONG SizeOfBlock,
    IN PUSHORT NextOffset,
    IN LONG_PTR Diff
    )
{
    PUCHAR FixupVA;
    USHORT Offset;
    LONG Temp;

    while (SizeOfBlock--) {

       FixupVA = NULL;
       Offset = (USHORT)(*NextOffset & (USHORT)0xfff);

       //
       // Apply the fixups.
       //

       switch ((*NextOffset) >> 12) {

            case IMAGE_REL_BASED_HIGHLOW :
                //
                // HighLow - (32-bits) relocate the high and low half
                //      of an address.
                //
                FixupVA = (PUCHAR)ImgbVirtualAddressToData(NtHeader, VA + Offset);
                *(LONG UNALIGNED *)FixupVA += (ULONG) Diff;
                break;

            case IMAGE_REL_BASED_HIGH :
                //
                // High - (16-bits) relocate the high half of an address.
                //
                FixupVA = (PUCHAR)ImgbVirtualAddressToData(NtHeader, VA + Offset);
                Temp = *(PUSHORT)FixupVA << 16;
                Temp += (ULONG) Diff;
                *(PUSHORT)FixupVA = (USHORT)(Temp >> 16);
                break;

            case IMAGE_REL_BASED_HIGHADJ :
                //
                // Adjust high - (16-bits) relocate the high half of an
                //      address and adjust for sign extension of low half.
                //
                FixupVA = (PUCHAR)ImgbVirtualAddressToData(NtHeader, VA + Offset);
                Temp = *(PUSHORT)FixupVA << 16;
                ++NextOffset;
                --SizeOfBlock;
                Temp += (LONG)(*(PSHORT)NextOffset);
                Temp += (ULONG) Diff;
                Temp += 0x8000;
                *(PUSHORT)FixupVA = (USHORT)(Temp >> 16);

                break;

            case IMAGE_REL_BASED_LOW :
                //
                // Low - (16-bit) relocate the low half of an address.
                //
                FixupVA = (PUCHAR)ImgbVirtualAddressToData(NtHeader, VA + Offset);
                Temp = *(PSHORT)FixupVA;
                Temp += (ULONG) Diff;
                *(PUSHORT)FixupVA = (USHORT)Temp;
                break;

            case IMAGE_REL_BASED_ABSOLUTE :
                //
                // Absolute - no fixup required.
                //
                break;

            case IMAGE_REL_BASED_SECTION :
                //
                // Section Relative reloc.  Ignore for now.
                //
                break;

            case IMAGE_REL_BASED_REL32 :
                //
                // Relative intrasection. Ignore for now.
                //
                break;

            default :
                //
                // Illegal - illegal relocation type.
                //

                return (PIMAGE_BASE_RELOCATION)NULL;
       }
       ++NextOffset;
    }
    return (PIMAGE_BASE_RELOCATION)NextOffset;
}

VOID
ImgbRelocateImage(
    PIMAGE_NT_HEADERS NtHeader,
    ULONG OldBaseAddress,
    ULONG NewBaseAddress,
    PIMAGE_BASE_RELOCATION NextBlock,
    ULONG TotalCountBytes
    )
{
    LONG_PTR Diff;
    ULONG SizeOfBlock;
    PUSHORT NextOffset;

    //
    // If the image has a relocation table, then apply the specified fixup
    // information to the image.
    //

    while (TotalCountBytes) {
        SizeOfBlock = NextBlock->SizeOfBlock;
        TotalCountBytes -= SizeOfBlock;
        SizeOfBlock -= sizeof(IMAGE_BASE_RELOCATION);
        SizeOfBlock /= sizeof(USHORT);
        NextOffset = (PUSHORT)((PCHAR)NextBlock + sizeof(IMAGE_BASE_RELOCATION));

        Diff = NewBaseAddress - OldBaseAddress;

        if ( (NextBlock = ImgbProcessRelocationBlock(NtHeader,NextBlock->VirtualAddress,SizeOfBlock,NextOffset,Diff)) == NULL ) {
            ImgbResourcePrintErrorAndExit(IDS_INVALID_CORRUPT_INPUT_FILE, ImgbInputFilePath);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagebld.new\msftlogo.h ===
0x07, 0x33, 0xAD, 0x03, 0x07, 0x53, 0xAD, 0x03, 0xA9, 0x03, 0xEA, 0x00, 
0x03, 0x73, 0xA7, 0x03, 0x32, 0x00, 0xB3, 0xFD, 0x03, 0x05, 0x03, 0xFD, 
0xD3, 0x43, 0xF9, 0xEA, 0x00, 0x03, 0xE3, 0xF9, 0x33, 0x47, 0x33, 0x22, 
0x00, 0xFF, 0x03, 0x05, 0x73, 0xFD, 0x73, 0x73, 0xA7, 0x73, 0xEA, 0x00, 
0x73, 0xF7, 0xD3, 0x73, 0xE3, 0xF7, 0x43, 0x0F, 0x03, 0xFF, 0x03, 0x05, 
0xFF, 0x33, 0x2E, 0x00, 0x03, 0x7A, 0x00, 0x03, 0x52, 0x00, 0xF9, 0x33, 
0x03, 0xF9, 0x03, 0x0F, 0x33, 0xFF, 0x03, 0x03, 0x43, 0xFF, 0x13, 0xF9, 
0x13, 0x05, 0x03, 0x93, 0xA3, 0xF7, 0x73, 0x07, 0x73, 0xA7, 0x63, 0x23, 
0x53, 0xA3, 0x05, 0x13, 0xA3, 0xD3, 0xF7, 0x73, 0x03, 0x07, 0x13, 0x73, 
0xE3, 0xF7, 0xE3, 0xA3, 0x13, 0x09, 0x03, 0xA3, 0xF7, 0xE3, 0x93, 0x13, 
0x05, 0x43, 0x53, 0xF9, 0x53, 0x73, 0xF9, 0xB3, 0x33, 0x03, 0x23, 0x63, 
0x03, 0x05, 0x93, 0xFF, 0x43, 0x03, 0xE3, 0xFF, 0x33, 0xF9, 0x03, 0x03, 
0x43, 0xE3, 0xFD, 0xB3, 0x05, 0xF9, 0xD3, 0xF5, 0xD3, 0x03, 0xA3, 0xFF, 
0xE3, 0x03, 0x03, 0x73, 0x26, 0xF0, 0x13, 0x05, 0x23, 0xE3, 0xFF, 0x63, 
0x03, 0x36, 0xF0, 0x13, 0x23, 0x33, 0xC3, 0x63, 0x05, 0xD3, 0xFF, 0x45, 
0xFF, 0xA3, 0x93, 0xF7, 0xE3, 0x03, 0x63, 0x26, 0xF0, 0x43, 0x03, 0xFF, 
0x73, 0xD3, 0xF9, 0xB3, 0xF9, 0x73, 0x13, 0xF9, 0x53, 0x13, 0xE3, 0xF7, 
0x93, 0x03, 0x23, 0xF9, 0xE3, 0xD3, 0xF9, 0xD3, 0x36, 0xF0, 0x03, 0x23, 
0x63, 0x83, 0x63, 0x03, 0x03, 0x22, 0xF0, 0x43, 0xE3, 0xFF, 0x43, 0xD3, 
0xF7, 0x93, 0x23, 0xF9, 0xA3, 0x03, 0x23, 0xF7, 0xB3, 0x33, 0x32, 0xF0, 
0x13, 0x03, 0x53, 0xF7, 0xE3, 0x43, 0xF7, 0xE3, 0x05, 0xA3, 0xF7, 0xA3, 
0x03, 0xE3, 0xF7, 0xD3, 0x05, 0xD3, 0xF7, 0xC3, 0x03, 0xD3, 0xF7, 0x53, 
0x03, 0xF9, 0x13, 0x07, 0x13, 0x33, 0x03, 0x03, 0x13, 0xF9, 0xD3, 0xF7, 
0xA3, 0xF7, 0xD3, 0xF9, 0x13, 0xF9, 0x43, 0xD3, 0xF9, 0x03, 0x03, 0x03, 
0xF9, 0x93, 0xF9, 0xE3, 0x23, 0x23, 0xF9, 0x73, 0x05, 0x03, 0xF9, 0x63, 
0xF9, 0xD3, 0x43, 0x13, 0x03, 0x07, 0x73, 0xF9, 0x23, 0x05, 0xA3, 0xF9, 
0x03, 0xF9, 0x23, 0x03, 0xF9, 0x03, 0x0F, 0x53, 0xF9, 0x73, 0xFD, 0xE3, 
0xB3, 0xF9, 0x13, 0xF9, 0x23, 0xF9, 0x73, 0x0F, 0xD3, 0xF7, 0xE3, 0x03, 
0x03, 0x93, 0xF9, 0x03, 0x05, 0x33, 0xF9, 0x13, 0xE3, 0xFF, 0xD3, 0x03, 
0x03, 0xE3, 0xF7, 0xD3, 0x07, 0xA3, 0xF9, 0x13, 0xF9, 0x03, 0x43, 0xF7, 
0xD3, 0x22, 0x00, 0xA3, 0xF9, 0x23, 0xFD, 0x43, 0xE3, 0xF7, 0xD3, 0x43, 
0xF9, 0x43, 0xF9, 0x03, 0x0D, 0x03, 0xF9, 0x53, 0x05, 0xF9, 0xE3, 0x07, 
0x43, 0xF9, 0x03, 0x03, 0xB3, 0xFF, 0xE3, 0x03, 0xF9, 0xA3, 0x07, 0xD3, 
0xF9, 0x53, 0xF7, 0xE3, 0x03, 0x93, 0xF7, 0x93, 0x22, 0x00, 0xFB, 0x03, 
0xFB, 0xE3, 0x03, 0xF9, 0x73, 0xA3, 0xF7, 0xD3, 0x43, 0xF9, 0x03, 0x05, 
0x03, 0x07, 0x23, 0xF9, 0x03, 0x05, 0xF9, 0xA3, 0x07, 0xD3, 0xF3, 0x93, 
0x23, 0x09, 0x03, 0x33, 0xD3, 0xFB, 0x23, 0xF9, 0x43, 0x05, 0x13, 0xF9, 
0x73, 0xB3, 0xF7, 0x93, 0x03, 0xE3, 0xF7, 0x33, 0x0F, 0x03, 0xF9, 0xD3, 
0x03, 0xFB, 0x43, 0x23, 0xF9, 0x33, 0xE3, 0xF7, 0x93, 0x43, 0xF9, 0x05, 
0x13, 0xF9, 0x63, 0xF9, 0x07, 0xF9, 0xB3, 0x05, 0x43, 0x22, 0xF0, 0x43, 
0x05, 0x73, 0xF9, 0x23, 0xF9, 0x73, 0x05, 0xA3, 0xF9, 0x13, 0xF9, 0x43, 
0x03, 0xF9, 0x03, 0x0F, 0x33, 0xF9, 0x73, 0x03, 0xF9, 0xE3, 0x03, 0x53, 
0xF9, 0x13, 0xF9, 0x43, 0x13, 0xF9, 0x73, 0x43, 0xE3, 0xF7, 0x73, 0xB3, 
0xF7, 0xB3, 0x07, 0x93, 0xF9, 0x63, 0x23, 0xE3, 0xF7, 0xD3, 0xF9, 0xA3, 
0x03, 0x03, 0xA3, 0xF9, 0x03, 0xD3, 0xF7, 0xE3, 0x23, 0x73, 0xF9, 0x63, 
0x03, 0xF9, 0x03, 0x13, 0xF9, 0xB3, 0xA3, 0x0D, 0x73, 0xF9, 0x23, 0x03, 
0xF9, 0x43, 0x03, 0xB3, 0xF9, 0x23, 0xF9, 0x03, 0x03, 0xD3, 0x22, 0xF0, 
0xB3, 0x03, 0xF9, 0x73, 0x07, 0x13, 0x26, 0xF0, 0xE3, 0x03, 0xD3, 0x2A, 
0xF0, 0x73, 0x03, 0x23, 0x26, 0xF0, 0xA3, 0x03, 0x43, 0xF9, 0x03, 0x43, 
0xFB, 0x93, 0x0D, 0xD3, 0xF9, 0x03, 0x03, 0xF7, 0xE3, 0x05, 0xF9, 0xA3, 
0x53, 0xF9, 0x05, 0x03, 0xE3, 0xFD, 0xB3, 0x03, 0x03, 0xF9, 0x33, 0x09, 
0x23, 0xFF, 0x73, 0x03, 0x03, 0x03, 0xE3, 0x22, 0xF0, 0x63, 0x07, 0x63, 
0xFD, 0xE3, 0x43, 0x05, 0xA3, 0xF7, 0xB3, 0x05, 0xD3, 0xF9, 0x33, 0x0D, 
0x4B, 0x05, 0x47, 0x13, 0x03, 0x03, 0x49, 0x13, 0x73, 0xA7, 0x93, 0x07, 
0x03, 0x43, 0xA3, 0xC3, 0xA3, 0x73, 0x13, 0x05, 0x13, 0x49, 0x03, 0x0B, 
0x03, 0x53, 0xD3, 0xF3, 0xE3, 0x73, 0x13, 0x09, 0x03, 0x43, 0x73, 0xA3, 
0xD3, 0xF3, 0xE3, 0x73, 0x13, 0x0B, 0x03, 0x23, 0x53, 0x47, 0x03, 0x07, 
0x49, 0x13, 0x07, 0x49, 0x03, 0x0D,
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\bindi.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    bindi.c

Abstract:
    Implementation for the BindImage API

Author:

Revision History:

--*/

#include <private.h>

typedef struct _BOUND_FORWARDER_REFS {
    struct _BOUND_FORWARDER_REFS *Next;
    ULONG TimeDateStamp;
    LPSTR ModuleName;
} BOUND_FORWARDER_REFS, *PBOUND_FORWARDER_REFS;

typedef struct _IMPORT_DESCRIPTOR {
    struct _IMPORT_DESCRIPTOR *Next;
    LPSTR ModuleName;
    ULONG TimeDateStamp;
    USHORT NumberOfModuleForwarderRefs;
    PBOUND_FORWARDER_REFS Forwarders;
} IMPORT_DESCRIPTOR, *PIMPORT_DESCRIPTOR;

typedef struct _BINDP_PARAMETERS {
    DWORD Flags;
    BOOLEAN fNoUpdate;
    BOOLEAN fNewImports;
    LPSTR ImageName;
    LPSTR DllPath;
    LPSTR SymbolPath;
    PIMAGEHLP_STATUS_ROUTINE StatusRoutine;
} BINDP_PARAMETERS, *PBINDP_PARAMETERS;

BOOL
BindpLookupThunk(
    PBINDP_PARAMETERS Parms,
    PIMAGE_THUNK_DATA ThunkName,
    PLOADED_IMAGE Image,
    PIMAGE_THUNK_DATA SnappedThunks,
    PIMAGE_THUNK_DATA FunctionAddress,
    PLOADED_IMAGE Dll,
    PIMAGE_EXPORT_DIRECTORY Exports,
    PIMPORT_DESCRIPTOR NewImport,
    LPSTR DllPath,
    PULONG *ForwarderChain
    );

PVOID
BindpRvaToVa(
    PBINDP_PARAMETERS Parms,
    ULONG Rva,
    PLOADED_IMAGE Image
    );

VOID
BindpWalkAndProcessImports(
    PBINDP_PARAMETERS Parms,
    PLOADED_IMAGE Image,
    LPSTR DllPath,
    PBOOL ImageModified
    );

BOOL
BindImage(
    IN LPSTR ImageName,
    IN LPSTR DllPath,
    IN LPSTR SymbolPath
    )
{
    return BindImageEx( 0,
                        ImageName,
                        DllPath,
                        SymbolPath,
                        NULL
                      );
}

UCHAR BindpCapturedModuleNames[4096];
LPSTR BindpEndCapturedModuleNames;

LPSTR
BindpCaptureImportModuleName(
    LPSTR DllName
    )
{
    LPSTR s;

    s = (LPSTR) BindpCapturedModuleNames;
    if (BindpEndCapturedModuleNames == NULL) {
        *s = '\0';
        BindpEndCapturedModuleNames = s;
        }

    while (*s) {
        if (!_stricmp(s, DllName)) {
            return s;
            }

        s += strlen(s)+1;
        }

    strcpy(s, DllName);
    BindpEndCapturedModuleNames = s + strlen(s) + 1;
    *BindpEndCapturedModuleNames = '\0';
    return s;
}

PIMPORT_DESCRIPTOR
BindpAddImportDescriptor(
    PBINDP_PARAMETERS Parms,
    PIMPORT_DESCRIPTOR *NewImportDescriptor,
    PIMAGE_IMPORT_DESCRIPTOR ImportDescriptor,
    LPSTR ModuleName,
    PLOADED_IMAGE Dll
    )
{
    PIMPORT_DESCRIPTOR p, *pp;

    if (!Parms->fNewImports) {
        return NULL;
        }

    pp = NewImportDescriptor;
    while (p = *pp) {
        if (!_stricmp( p->ModuleName, ModuleName )) {
            return p;
            }

        pp = &p->Next;
        }

    p = (PIMPORT_DESCRIPTOR) MemAlloc( sizeof( *p ) );
    if (p != NULL) {
        if (Dll != NULL) {
            p->TimeDateStamp = ((PIMAGE_NT_HEADERS32)Dll->FileHeader)->FileHeader.TimeDateStamp;
            }
        p->ModuleName = BindpCaptureImportModuleName( ModuleName );
        *pp = p;
        }
    else
    if (Parms->StatusRoutine != NULL) {
        (Parms->StatusRoutine)( BindOutOfMemory, NULL, NULL, 0, sizeof( *p ) );
        }

    return p;
}


PUCHAR
BindpAddForwarderReference(
    PBINDP_PARAMETERS Parms,
    LPSTR ImageName,
    LPSTR ImportName,
    PIMPORT_DESCRIPTOR NewImportDescriptor,
    LPSTR DllPath,
    PUCHAR ForwarderString,
    PBOOL BoundForwarder
    )
{
    CHAR DllName[ MAX_PATH ];
    PUCHAR s;
    PLOADED_IMAGE Dll;
    ULONG cb;
    USHORT OrdinalNumber;
    USHORT HintIndex;
    ULONG ExportSize;
    PIMAGE_EXPORT_DIRECTORY Exports;
    PULONG NameTableBase;
    PUSHORT NameOrdinalTableBase;
    PULONG FunctionTableBase;
    LPSTR NameTableName;
    ULONG64 ForwardedAddress;
    PBOUND_FORWARDER_REFS p, *pp;
    PIMAGE_OPTIONAL_HEADER32 OptionalHeader32 = NULL;
    PIMAGE_OPTIONAL_HEADER64 OptionalHeader64 = NULL;
    PIMAGE_FILE_HEADER FileHeader;

    *BoundForwarder = FALSE;
BindAnotherForwarder:
    s = ForwarderString;
    while (*s && *s != '.') {
        s++;
        }
    if (*s != '.') {
        return ForwarderString;
        }
    cb = (ULONG) (s - ForwarderString);
    if (cb >= MAX_PATH) {
        return ForwarderString;
        }
    strncpy( DllName, (LPSTR) ForwarderString, cb );
    DllName[ cb ] = '\0';
    strcat( DllName, ".DLL" );

    Dll = ImageLoad( DllName, DllPath );
    if (!Dll) {
        return ForwarderString;
        }
    s += 1;

    Exports = (PIMAGE_EXPORT_DIRECTORY)ImageDirectoryEntryToData(
                                         (PVOID)Dll->MappedAddress,
                                         FALSE,
                                         IMAGE_DIRECTORY_ENTRY_EXPORT,
                                         &ExportSize
                                         );
    if (!Exports) {
        return ForwarderString;
    }

    FileHeader = &((PIMAGE_NT_HEADERS32)Dll->FileHeader)->FileHeader;
    OptionalHeadersFromNtHeaders((PIMAGE_NT_HEADERS32)Dll->FileHeader,
                                 &OptionalHeader32,
                                 &OptionalHeader64);

    if ( *s == '#' ) {
        // Binding for ordinal forwarders

        OrdinalNumber = (atoi((PCHAR)s + 1)) - (USHORT)Exports->Base;

        if (OrdinalNumber >= Exports->NumberOfFunctions) {
            return ForwarderString;
        }
    } else {
        // Regular binding for named forwarders

        OrdinalNumber = 0xFFFF;
    }

    NameTableBase = (PULONG) BindpRvaToVa( Parms, Exports->AddressOfNames, Dll );
    NameOrdinalTableBase = (PUSHORT) BindpRvaToVa( Parms, Exports->AddressOfNameOrdinals, Dll );
    FunctionTableBase = (PULONG) BindpRvaToVa( Parms, Exports->AddressOfFunctions, Dll );

    if (OrdinalNumber == 0xFFFF) {
        for ( HintIndex = 0; HintIndex < Exports->NumberOfNames; HintIndex++){
            NameTableName = (LPSTR) BindpRvaToVa( Parms, NameTableBase[HintIndex], Dll );
            if ( NameTableName ) {
                OrdinalNumber = NameOrdinalTableBase[HintIndex];

                if (!strcmp((PCHAR)s, NameTableName)) {
                    break;
                }
            }
        }

        if (HintIndex >= Exports->NumberOfNames) {
            return ForwarderString;
        }
    }

    do {
       ForwardedAddress = FunctionTableBase[OrdinalNumber] +
           OPTIONALHEADER(ImageBase);

       pp = &NewImportDescriptor->Forwarders;
       while (p = *pp) {
           if (!_stricmp(DllName, p->ModuleName)) {
               break;
           }

           pp = &p->Next;
       }

       if (p == NULL) {
           p = (PBOUND_FORWARDER_REFS) MemAlloc( sizeof( *p ) );
           if (p == NULL) {
               if (Parms->StatusRoutine != NULL) {
                   (Parms->StatusRoutine)( BindOutOfMemory, NULL, NULL, 0, sizeof( *p ) );
               }

               break;
           }

           p->ModuleName = BindpCaptureImportModuleName( DllName );
           *pp = p;
           NewImportDescriptor->NumberOfModuleForwarderRefs += 1;
       }

       p->TimeDateStamp = FileHeader->TimeDateStamp;
       if (Parms->StatusRoutine != NULL)
       {
           (Parms->StatusRoutine)( BindForwarder,
                                   ImageName,
                                   ImportName,
                                   (ULONG_PTR)ForwardedAddress,    //BUGBUG
                                   (ULONG_PTR)ForwarderString
                                 );
       }

       Exports = (PIMAGE_EXPORT_DIRECTORY)ImageDirectoryEntryToData(
                                            (PVOID)Dll->MappedAddress,
                                            TRUE,
                                            IMAGE_DIRECTORY_ENTRY_EXPORT,
                                            &ExportSize
                                            );

       Exports = (PIMAGE_EXPORT_DIRECTORY) ((ULONG_PTR)Exports -
                     (ULONG_PTR) Dll->MappedAddress +
                     OPTIONALHEADER(ImageBase));

       if ((ForwardedAddress >= (ULONG_PTR)Exports) &&
           (ForwardedAddress <= ((ULONG_PTR)Exports + ExportSize)))
       {
           ForwarderString = BindpRvaToVa(Parms,
                                          FunctionTableBase[OrdinalNumber],
                                          Dll);
           goto BindAnotherForwarder;
       } else {
           ForwarderString = (PUCHAR)ForwardedAddress;
           *BoundForwarder = TRUE;
           break;
       }
    }
    while (0);

    return ForwarderString;
}

PIMAGE_BOUND_IMPORT_DESCRIPTOR
BindpCreateNewImportSection(
    PBINDP_PARAMETERS Parms,
    PIMPORT_DESCRIPTOR *NewImportDescriptor,
    PULONG NewImportsSize
    )
{
    ULONG cbString, cbStruct;
    PIMPORT_DESCRIPTOR p, *pp;
    PBOUND_FORWARDER_REFS p1, *pp1;
    LPSTR CapturedStrings;
    PIMAGE_BOUND_IMPORT_DESCRIPTOR NewImports, NewImport;
    PIMAGE_BOUND_FORWARDER_REF NewForwarder;


    *NewImportsSize = 0;
    cbString = 0;
    cbStruct = 0;
    pp = NewImportDescriptor;
    while (p = *pp) {
        cbStruct += sizeof( IMAGE_BOUND_IMPORT_DESCRIPTOR );
        pp1 = &p->Forwarders;
        while (p1 = *pp1) {
            cbStruct += sizeof( IMAGE_BOUND_FORWARDER_REF );
            pp1 = &p1->Next;
            }

        pp = &p->Next;
        }
    if (cbStruct == 0) {
        BindpEndCapturedModuleNames = NULL;
        return NULL;
        }
    cbStruct += sizeof(IMAGE_BOUND_IMPORT_DESCRIPTOR);    // Room for terminating zero entry
    cbString = (ULONG) (BindpEndCapturedModuleNames - (LPSTR) BindpCapturedModuleNames);
    BindpEndCapturedModuleNames = NULL;
    *NewImportsSize = cbStruct+((cbString + sizeof(ULONG) - 1) & ~(sizeof(ULONG)-1));
    NewImports = (PIMAGE_BOUND_IMPORT_DESCRIPTOR) MemAlloc( *NewImportsSize );
    if (NewImports != NULL) {
        CapturedStrings = (LPSTR)NewImports + cbStruct;
        memcpy(CapturedStrings, BindpCapturedModuleNames, cbString);

        NewImport = NewImports;
        pp = NewImportDescriptor;
        while (p = *pp) {
            NewImport->TimeDateStamp = p->TimeDateStamp;
            NewImport->OffsetModuleName = (USHORT)(cbStruct + (p->ModuleName - (LPSTR) BindpCapturedModuleNames));
            NewImport->NumberOfModuleForwarderRefs = p->NumberOfModuleForwarderRefs;

            NewForwarder = (PIMAGE_BOUND_FORWARDER_REF)(NewImport+1);
            pp1 = &p->Forwarders;
            while (p1 = *pp1) {
                NewForwarder->TimeDateStamp = p1->TimeDateStamp;
                NewForwarder->OffsetModuleName = (USHORT)(cbStruct + (p1->ModuleName - (LPSTR) BindpCapturedModuleNames));
                NewForwarder += 1;
                pp1 = &p1->Next;
                }
            NewImport = (PIMAGE_BOUND_IMPORT_DESCRIPTOR)NewForwarder;

            pp = &p->Next;
            }
        }
    else
    if (Parms->StatusRoutine != NULL) {
        (Parms->StatusRoutine)( BindOutOfMemory, NULL, NULL, 0, *NewImportsSize );
        }

    pp = NewImportDescriptor;
    while ((p = *pp) != NULL) {
        *pp = p->Next;
        pp1 = &p->Forwarders;
        while ((p1 = *pp1) != NULL) {
            *pp1 = p1->Next;
            MemFree(p1);
            }

        MemFree(p);
        }

    return NewImports;
}

BOOL
BindpExpandImageFileHeaders(
    PBINDP_PARAMETERS Parms,
    PLOADED_IMAGE Dll,
    ULONG NewSizeOfHeaders
    )
{
    HANDLE hMappedFile;
    LPVOID lpMappedAddress;
    DWORD dwFileSizeLow, dwOldFileSize;
    DWORD dwFileSizeHigh;
    DWORD dwSizeDelta;
    PIMAGE_SECTION_HEADER Section;
    ULONG SectionNumber;
    PIMAGE_DEBUG_DIRECTORY DebugDirectories;
    ULONG DebugDirectoriesSize;
    ULONG OldSizeOfHeaders;
    PIMAGE_OPTIONAL_HEADER32 OptionalHeader32 = NULL;
    PIMAGE_OPTIONAL_HEADER64 OptionalHeader64 = NULL;
    PIMAGE_FILE_HEADER FileHeader;

    dwFileSizeLow = GetFileSize( Dll->hFile, &dwFileSizeHigh );
    if (dwFileSizeLow == 0xFFFFFFFF || dwFileSizeHigh != 0) {
        return FALSE;
    }

    FileHeader = &((PIMAGE_NT_HEADERS32)Dll->FileHeader)->FileHeader;
    OptionalHeadersFromNtHeaders((PIMAGE_NT_HEADERS32)Dll->FileHeader,
                                 &OptionalHeader32,
                                 &OptionalHeader64);

    OldSizeOfHeaders = OPTIONALHEADER(SizeOfHeaders);
    dwOldFileSize = dwFileSizeLow;
    dwSizeDelta = NewSizeOfHeaders - OldSizeOfHeaders;
    dwFileSizeLow += dwSizeDelta;

    hMappedFile = CreateFileMapping(Dll->hFile,
                                    NULL,
                                    PAGE_READWRITE,
                                    dwFileSizeHigh,
                                    dwFileSizeLow,
                                    NULL
                                   );
    if (!hMappedFile) {
        return FALSE;
    }


    FlushViewOfFile(Dll->MappedAddress, Dll->SizeOfImage);
    UnmapViewOfFile(Dll->MappedAddress);
    lpMappedAddress = MapViewOfFileEx(hMappedFile,
                                      FILE_MAP_WRITE,
                                      0,
                                      0,
                                      0,
                                      Dll->MappedAddress
                                     );
    if (!lpMappedAddress) {
        lpMappedAddress = MapViewOfFileEx(hMappedFile,
                                          FILE_MAP_WRITE,
                                          0,
                                          0,
                                          0,
                                          0
                                         );
    }

    CloseHandle(hMappedFile);

    if (lpMappedAddress != Dll->MappedAddress) {
        Dll->MappedAddress = (PUCHAR) lpMappedAddress;
        CalculateImagePtrs(Dll);
        FileHeader = &((PIMAGE_NT_HEADERS32)Dll->FileHeader)->FileHeader;
        OptionalHeadersFromNtHeaders((PIMAGE_NT_HEADERS32)Dll->FileHeader,
                                     &OptionalHeader32,
                                     &OptionalHeader64);
    }

    if (Dll->SizeOfImage != dwFileSizeLow) {
        Dll->SizeOfImage = dwFileSizeLow;
    }

    DebugDirectories = (PIMAGE_DEBUG_DIRECTORY)ImageDirectoryEntryToData(
                                            (PVOID)Dll->MappedAddress,
                                            FALSE,
                                            IMAGE_DIRECTORY_ENTRY_DEBUG,
                                            &DebugDirectoriesSize
                                            );

    if (DebugDirectoryIsUseful(DebugDirectories, DebugDirectoriesSize)) {
        while (DebugDirectoriesSize != 0) {
            DebugDirectories->PointerToRawData += dwSizeDelta;
            DebugDirectories += 1;
            DebugDirectoriesSize -= sizeof( *DebugDirectories );
        }
    }

    OPTIONALHEADER_LV(SizeOfHeaders) = NewSizeOfHeaders;
    if (FileHeader->PointerToSymbolTable != 0) {
        // Only adjust if it's already set

        FileHeader->PointerToSymbolTable += dwSizeDelta;
    }
    Section = Dll->Sections;
    for (SectionNumber=0; SectionNumber<FileHeader->NumberOfSections; SectionNumber++) {
        if (Section->PointerToRawData != 0) {
            Section->PointerToRawData += dwSizeDelta;
        }
        if (Section->PointerToRelocations != 0) {
            Section->PointerToRelocations += dwSizeDelta;
        }
        if (Section->PointerToLinenumbers != 0) {
            Section->PointerToLinenumbers += dwSizeDelta;
        }
        Section += 1;
    }

    memmove((LPSTR)lpMappedAddress + NewSizeOfHeaders,
            (LPSTR)lpMappedAddress + OldSizeOfHeaders,
            dwOldFileSize - OldSizeOfHeaders
           );

    if (Parms->StatusRoutine != NULL) {
        (Parms->StatusRoutine)( BindExpandFileHeaders, Dll->ModuleName, NULL, 0, NewSizeOfHeaders );
    }

    return TRUE;
}

BOOL
BindImageEx(
    IN DWORD Flags,
    IN LPSTR ImageName,
    IN LPSTR DllPath,
    IN LPSTR SymbolPath,
    IN PIMAGEHLP_STATUS_ROUTINE StatusRoutine
    )
{
    BINDP_PARAMETERS Parms;
    LOADED_IMAGE LoadedImageBuffer;
    PLOADED_IMAGE LoadedImage;
    ULONG CheckSum;
    ULONG HeaderSum;
    BOOL fSymbolsAlreadySplit, fRC;
    SYSTEMTIME SystemTime;
    FILETIME LastWriteTime;
    BOOL ImageModified;
    DWORD OldChecksum;
    CHAR DebugFileName[ MAX_PATH ];
    CHAR DebugFilePath[ MAX_PATH ];
    PIMAGE_OPTIONAL_HEADER32 OptionalHeader32 = NULL;
    PIMAGE_OPTIONAL_HEADER64 OptionalHeader64 = NULL;
    PIMAGE_FILE_HEADER FileHeader;

    Parms.Flags         = Flags;
    if (Flags & BIND_NO_BOUND_IMPORTS) {
        Parms.fNewImports = FALSE;
    } else {
        Parms.fNewImports = TRUE;
    }
    if (Flags & BIND_NO_UPDATE) {
        Parms.fNoUpdate = TRUE;
    } else {
        Parms.fNoUpdate = FALSE;
    }
    Parms.ImageName     = ImageName;
    Parms.DllPath       = DllPath;
    Parms.SymbolPath    = SymbolPath;
    Parms.StatusRoutine = StatusRoutine;

    fRC = FALSE;            // Assume we'll fail to bind

    __try {

        // Map and load the image

        LoadedImage = &LoadedImageBuffer;
        memset( LoadedImage, 0, sizeof( *LoadedImage ) );
        if (MapAndLoad( ImageName, DllPath, LoadedImage, TRUE, Parms.fNoUpdate )) {
            LoadedImage->ModuleName = ImageName;

            //
            // Now locate and walk through and process the images imports
            //
            if (LoadedImage->FileHeader != NULL &&
                ((Flags & BIND_ALL_IMAGES) || (!LoadedImage->fSystemImage)) ) {

                FileHeader = &((PIMAGE_NT_HEADERS32)LoadedImage->FileHeader)->FileHeader;
                OptionalHeadersFromNtHeaders((PIMAGE_NT_HEADERS32)LoadedImage->FileHeader,
                                             &OptionalHeader32,
                                             &OptionalHeader64);

                if (OPTIONALHEADER(DllCharacteristics) & IMAGE_DLLCHARACTERISTICS_NO_BIND) {
                    goto NoBind;
                }

                {
                    DWORD dwCertificateSize;
                    PVOID pCertificates = ImageDirectoryEntryToData(
                                                        LoadedImage->MappedAddress,
                                                        FALSE,
                                                        IMAGE_DIRECTORY_ENTRY_SECURITY,
                                                        &dwCertificateSize
                                                        );

                    if (pCertificates || dwCertificateSize) {
                        goto NoBind;
                    }
                }


                BindpWalkAndProcessImports(
                                &Parms,
                                LoadedImage,
                                DllPath,
                                &ImageModified
                                );

                //
                // If the file is being updated, then recompute the checksum.
                // and update image and possibly stripped symbol file.
                //

                if (!Parms.fNoUpdate && ImageModified &&
                    (LoadedImage->hFile != INVALID_HANDLE_VALUE)) {
                    if ( (FileHeader->Characteristics & IMAGE_FILE_DEBUG_STRIPPED) &&
                         (SymbolPath != NULL) ) {
                        PIMAGE_DEBUG_DIRECTORY DebugDirectories;
                        ULONG DebugDirectoriesSize;
                        PIMAGE_DEBUG_MISC MiscDebug;

                        fSymbolsAlreadySplit = TRUE;
                        strcpy( DebugFileName, ImageName );
                        DebugDirectories = (PIMAGE_DEBUG_DIRECTORY)ImageDirectoryEntryToData(
                                                                LoadedImage->MappedAddress,
                                                                FALSE,
                                                                IMAGE_DIRECTORY_ENTRY_DEBUG,
                                                                &DebugDirectoriesSize
                                                                );
                        if (DebugDirectoryIsUseful(DebugDirectories, DebugDirectoriesSize)) {
                            while (DebugDirectoriesSize != 0) {
                                if (DebugDirectories->Type == IMAGE_DEBUG_TYPE_MISC) {
                                    MiscDebug = (PIMAGE_DEBUG_MISC)
                                        ((PCHAR)LoadedImage->MappedAddress +
                                         DebugDirectories->PointerToRawData
                                        );
                                    strcpy( DebugFileName, (PCHAR) MiscDebug->Data );
                                    break;
                                } else {
                                    DebugDirectories += 1;
                                    DebugDirectoriesSize -= sizeof( *DebugDirectories );
                                }
                            }
                        }
                    } else {
                        fSymbolsAlreadySplit = FALSE;
                    }

                    OldChecksum = OPTIONALHEADER(CheckSum);
                    CheckSumMappedFile(
                                (PVOID)LoadedImage->MappedAddress,
                                GetFileSize(LoadedImage->hFile, NULL),
                                &HeaderSum,
                                &CheckSum
                                );

                    OPTIONALHEADER_LV(CheckSum) = CheckSum;
                    FlushViewOfFile(LoadedImage->MappedAddress, LoadedImage->SizeOfImage);

                    if (fSymbolsAlreadySplit) {
                        if ( UpdateDebugInfoFileEx(ImageName,
                                                   SymbolPath,
                                                   DebugFilePath,
                                                   (PIMAGE_NT_HEADERS32)(LoadedImage->FileHeader),
                                                   OldChecksum)) {
                            if (GetLastError() == ERROR_INVALID_DATA) {
                                if (Parms.StatusRoutine != NULL) {
                                    (Parms.StatusRoutine)( BindMismatchedSymbols,
                                                           LoadedImage->ModuleName,
                                                           NULL,
                                                           0,
                                                           (ULONG_PTR)DebugFileName
                                                         );
                                }
                            }
                        } else {
                            if (Parms.StatusRoutine != NULL) {
                                (Parms.StatusRoutine)( BindSymbolsNotUpdated,
                                                       LoadedImage->ModuleName,
                                                       NULL,
                                                       0,
                                                       (ULONG_PTR)DebugFileName
                                                     );
                            }
                        }
                    }

                    GetSystemTime(&SystemTime);
                    if (SystemTimeToFileTime( &SystemTime, &LastWriteTime )) {
                        SetFileTime( LoadedImage->hFile, NULL, NULL, &LastWriteTime );
                    }
                }
            }

NoBind:
            UnmapViewOfFile( LoadedImage->MappedAddress );
            if (LoadedImage->hFile != INVALID_HANDLE_VALUE) {
                CloseHandle( LoadedImage->hFile );
            }

            fRC = TRUE;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        // Nothing to do...
    }

    if (!(Flags & BIND_CACHE_IMPORT_DLLS)) {
        UnloadAllImages();
    }

    return (fRC);
}


BOOL
BindpLookupThunk(
    PBINDP_PARAMETERS Parms,
    PIMAGE_THUNK_DATA ThunkName,
    PLOADED_IMAGE Image,
    PIMAGE_THUNK_DATA SnappedThunks,
    PIMAGE_THUNK_DATA FunctionAddress,
    PLOADED_IMAGE Dll,
    PIMAGE_EXPORT_DIRECTORY Exports,
    PIMPORT_DESCRIPTOR NewImport,
    LPSTR DllPath,
    PULONG *ForwarderChain
    )
{
    BOOL Ordinal;
    USHORT OrdinalNumber;
    PULONG NameTableBase;
    PUSHORT NameOrdinalTableBase;
    PULONG FunctionTableBase;
    PIMAGE_IMPORT_BY_NAME ImportName;
    USHORT HintIndex;
    LPSTR NameTableName;
    ULONG64 ExportsBase;
    ULONG ExportSize;
    UCHAR NameBuffer[ 32 ];
    PIMAGE_OPTIONAL_HEADER32 OptionalHeader32 = NULL;
    PIMAGE_OPTIONAL_HEADER64 OptionalHeader64 = NULL;
    PIMAGE_OPTIONAL_HEADER32 DllOptionalHeader32 = NULL;
    PIMAGE_OPTIONAL_HEADER64 DllOptionalHeader64 = NULL;

    NameTableBase = (PULONG) BindpRvaToVa( Parms, Exports->AddressOfNames, Dll );
    NameOrdinalTableBase = (PUSHORT) BindpRvaToVa( Parms, Exports->AddressOfNameOrdinals, Dll );
    FunctionTableBase = (PULONG) BindpRvaToVa( Parms, Exports->AddressOfFunctions, Dll );

    OptionalHeadersFromNtHeaders((PIMAGE_NT_HEADERS32)Image->FileHeader,
                                 &OptionalHeader32,
                                 &OptionalHeader64);

    OptionalHeadersFromNtHeaders((PIMAGE_NT_HEADERS32)Dll->FileHeader,
                                 &DllOptionalHeader32,
                                 &DllOptionalHeader64);
    //
    // Determine if snap is by name, or by ordinal
    //

    Ordinal = (BOOL)IMAGE_SNAP_BY_ORDINAL(ThunkName->u1.Ordinal);

    if (Ordinal) {
        UCHAR szOrdinal[8];
        OrdinalNumber = (USHORT)(IMAGE_ORDINAL(ThunkName->u1.Ordinal) - Exports->Base);
        if ( (ULONG)OrdinalNumber >= Exports->NumberOfFunctions ) {
            return FALSE;
            }
        ImportName = (PIMAGE_IMPORT_BY_NAME)NameBuffer;
        // Can't use sprintf w/o dragging in more CRT support than we want...  Must run on Win95.
        strcpy((PCHAR) ImportName->Name, "Ordinal");
        strcat((PCHAR) ImportName->Name, _ultoa((ULONG) OrdinalNumber, (LPSTR) szOrdinal, 16));
        }
    else {
        ImportName = (PIMAGE_IMPORT_BY_NAME)BindpRvaToVa(
                                                Parms,
                                                (ULONG)(ULONG_PTR)(ThunkName->u1.AddressOfData),
                                                Image
                                                );
        if (!ImportName) {
            return FALSE;
            }

        //
        // now check to see if the hint index is in range. If it
        // is, then check to see if it matches the function at
        // the hint. If all of this is true, then we can snap
        // by hint. Otherwise need to scan the name ordinal table
        //

        OrdinalNumber = (USHORT)(Exports->NumberOfFunctions+1);
        HintIndex = ImportName->Hint;
        if ((ULONG)HintIndex < Exports->NumberOfNames ) {
            NameTableName = (LPSTR) BindpRvaToVa( Parms, NameTableBase[HintIndex], Dll );
            if ( NameTableName ) {
                if ( !strcmp((PCHAR)ImportName->Name, NameTableName) ) {
                    OrdinalNumber = NameOrdinalTableBase[HintIndex];
                    }
                }
            }

        if ((ULONG)OrdinalNumber >= Exports->NumberOfFunctions) {
            for (HintIndex = 0; HintIndex < Exports->NumberOfNames; HintIndex++) {
                NameTableName = (LPSTR) BindpRvaToVa( Parms, NameTableBase[HintIndex], Dll );
                if (NameTableName) {
                    if (!strcmp( (PCHAR)ImportName->Name, NameTableName )) {
                        OrdinalNumber = NameOrdinalTableBase[HintIndex];
                        break;
                        }
                    }
                }

            if ((ULONG)OrdinalNumber >= Exports->NumberOfFunctions) {
                return FALSE;
                }
            }
        }

    (PULONG)(FunctionAddress->u1.Function) = (PULONG)(FunctionTableBase[OrdinalNumber] +
                                            (DllOptionalHeader32 ?
                                               DllOptionalHeader32->ImageBase :
                                               DllOptionalHeader64->ImageBase)
                                           );
    ExportsBase = (ULONG64)ImageDirectoryEntryToData(
                          (PVOID)Dll->MappedAddress,
                          TRUE,
                          IMAGE_DIRECTORY_ENTRY_EXPORT,
                          &ExportSize
                          ) - (ULONG_PTR)Dll->MappedAddress;
    ExportsBase += (DllOptionalHeader32 ?
                      DllOptionalHeader32->ImageBase :
                      DllOptionalHeader64->ImageBase);

    if ((ULONG64)FunctionAddress->u1.Function > (ULONG64)ExportsBase &&
        (ULONG64)FunctionAddress->u1.Function < ((ULONG64)ExportsBase + ExportSize)
       ) {
        BOOL BoundForwarder;

        BoundForwarder = FALSE;
        if (NewImport != NULL) {
            (PUCHAR)(FunctionAddress->u1.ForwarderString) = BindpAddForwarderReference(Parms,
                                           Image->ModuleName,
                                           (LPSTR) ImportName->Name,
                                           NewImport,
                                           DllPath,
                                           (PUCHAR) BindpRvaToVa( Parms, FunctionTableBase[OrdinalNumber], Dll ),
                                           &BoundForwarder
                                          );
            }

        if (!BoundForwarder) {
            **ForwarderChain = (ULONG) (FunctionAddress - SnappedThunks);
            *ForwarderChain = (ULONG *)&FunctionAddress->u1.Ordinal;

            if (Parms->StatusRoutine != NULL) {
                (Parms->StatusRoutine)( BindForwarderNOT,
                                        Image->ModuleName,
                                        Dll->ModuleName,
                                        (ULONG_PTR)FunctionAddress->u1.Function,
                                        (ULONG_PTR)(ImportName->Name)
                                      );
                }
            }
        }
    else {
        if (Parms->StatusRoutine != NULL) {
            (Parms->StatusRoutine)( BindImportProcedure,
                                    Image->ModuleName,
                                    Dll->ModuleName,
                                    (ULONG_PTR)FunctionAddress->u1.Function,
                                    (ULONG_PTR)(ImportName->Name)
                                  );
            }
        }

    return TRUE;
}

PVOID
BindpRvaToVa(
    PBINDP_PARAMETERS Parms,
    ULONG Rva,
    PLOADED_IMAGE Image
    )
{
    PVOID Va;

    Va = ImageRvaToVa( Image->FileHeader,
                       Image->MappedAddress,
                       Rva,
                       &Image->LastRvaSection
                     );
    if (!Va && Parms->StatusRoutine != NULL) {
        (Parms->StatusRoutine)( BindRvaToVaFailed,
                                Image->ModuleName,
                                NULL,
                                (ULONG)Rva,
                                0
                              );
        }

    return Va;
}

VOID
SetIdataToRo(
    PLOADED_IMAGE Image
    )
{
    PIMAGE_SECTION_HEADER Section;
    ULONG i;

    for(Section = Image->Sections,i=0; i<Image->NumberOfSections; i++,Section++) {
        if (!_stricmp((PCHAR) Section->Name, ".idata")) {
            if (Section->Characteristics & IMAGE_SCN_MEM_WRITE) {
                Section->Characteristics &= ~IMAGE_SCN_MEM_WRITE;
                Section->Characteristics |= IMAGE_SCN_MEM_READ;
                }

            break;
            }
        }
}

VOID
BindpWalkAndProcessImports(
    PBINDP_PARAMETERS Parms,
    PLOADED_IMAGE Image,
    LPSTR DllPath,
    PBOOL ImageModified
    )
{

    ULONG  ForwarderChainHead;
    PULONG ForwarderChain;
    ULONG ImportSize;
    ULONG ExportSize;
    PIMPORT_DESCRIPTOR NewImportDescriptorHead, NewImportDescriptor;
    PIMAGE_BOUND_IMPORT_DESCRIPTOR PrevNewImports, NewImports;
    ULONG PrevNewImportsSize, NewImportsSize;
    PIMAGE_IMPORT_DESCRIPTOR Imports;
    PIMAGE_EXPORT_DIRECTORY Exports;
    LPSTR ImportModule;
    PLOADED_IMAGE Dll;
    PIMAGE_THUNK_DATA tname,tsnap;
    PIMAGE_THUNK_DATA ThunkNames;
    PIMAGE_THUNK_DATA SnappedThunks;
    PIMAGE_IMPORT_BY_NAME ImportName;
    ULONG NumberOfThunks;
    ULONG i, cb;
    BOOL Ordinal, BindThunkFailed, NoErrors;
    USHORT OrdinalNumber;
    UCHAR NameBuffer[ 32 ];
    PIMAGE_OPTIONAL_HEADER32 OptionalHeader32 = NULL;
    PIMAGE_OPTIONAL_HEADER64 OptionalHeader64 = NULL;
    PIMAGE_FILE_HEADER FileHeader;

    *ImageModified = FALSE;

    //
    // Locate the import array for this image/dll
    //

    NewImportDescriptorHead = NULL;
    Imports = (PIMAGE_IMPORT_DESCRIPTOR)ImageDirectoryEntryToData(
                                            (PVOID)Image->MappedAddress,
                                            FALSE,
                                            IMAGE_DIRECTORY_ENTRY_IMPORT,
                                            &ImportSize
                                            );
    if (Imports == NULL) {
        //
        // Nothing to bind if no imports
        //

        return;
    }

    FileHeader = &((PIMAGE_NT_HEADERS32)Image->FileHeader)->FileHeader;
    OptionalHeadersFromNtHeaders((PIMAGE_NT_HEADERS32)Image->FileHeader,
                                 &OptionalHeader32,
                                 &OptionalHeader64);

    PrevNewImports = (PIMAGE_BOUND_IMPORT_DESCRIPTOR)ImageDirectoryEntryToData(
                                                (PVOID)Image->MappedAddress,
                                                FALSE,
                                                IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT,
                                                &PrevNewImportsSize
                                                );

    // If the user asked for an old style bind and there are new style bind records
    // already in the image, zero them out first.  This is the fix the problem where
    // you bind on NT (creating new import descriptors), boot Win95 and bind there
    // (creating old bind format), and then reboot to NT (the loader will only check
    // the BOUND_IMPORT array.

    if (PrevNewImports &&
        (Parms->fNewImports == FALSE) &&
        (Parms->fNoUpdate == FALSE ))
    {
        OPTIONALHEADER_LV(DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ].VirtualAddress) = 0;
        OPTIONALHEADER_LV(DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ].Size) = 0;
        PrevNewImports = 0;
        PrevNewImportsSize = 0;
        *ImageModified = TRUE;
    }

    //
    // For each import record
    //

    for(;Imports;Imports++) {
        if ( !Imports->Name ) {
            break;
        }

        //
        // Locate the module being imported and load the dll
        //

        ImportModule = (LPSTR)BindpRvaToVa( Parms, Imports->Name, Image );

        if (ImportModule) {
            Dll = ImageLoad( ImportModule, DllPath );
            if (!Dll) {
                if (Parms->StatusRoutine != NULL) {
                    (Parms->StatusRoutine)( BindImportModuleFailed,
                                            Image->ModuleName,
                                            ImportModule,
                                            0,
                                            0
                                          );
                }
                //
                // Unless specifically told not to, generate the new style
                // import descriptor.
                //

                BindpAddImportDescriptor(Parms,
                                         &NewImportDescriptorHead,
                                         Imports,
                                         ImportModule,
                                         Dll
                                        );
                continue;
            }

            if (Parms->StatusRoutine != NULL) {
                (Parms->StatusRoutine)( BindImportModule,
                                        Image->ModuleName,
                                        ImportModule,
                                        0,
                                        0
                                      );
            }
            //
            // If we can load the DLL, locate the export section and
            // start snapping the thunks
            //

            Exports = (PIMAGE_EXPORT_DIRECTORY)ImageDirectoryEntryToData(
                                                    (PVOID)Dll->MappedAddress,
                                                    FALSE,
                                                    IMAGE_DIRECTORY_ENTRY_EXPORT,
                                                    &ExportSize
                                                    );
            if ( !Exports ) {
                continue;
            }

            //
            // assert that the export directory addresses can be translated
            //

            if ( !BindpRvaToVa( Parms, Exports->AddressOfNames, Dll ) ) {
                continue;
            }

            if ( !BindpRvaToVa( Parms, Exports->AddressOfNameOrdinals, Dll ) ) {
                continue;
            }

            if ( !BindpRvaToVa( Parms, Exports->AddressOfFunctions, Dll ) ) {
                continue;
            }

            //
            // For old style bind, bypass the bind if it's already bound.
            // New style binds s/b looked up in PrevNewImport.
            //

            if ( Parms->fNewImports == FALSE &&
                 Imports->TimeDateStamp &&
                 Imports->TimeDateStamp == FileHeader->TimeDateStamp ) {
                    continue;
            }

            //
            // Now we need to size our thunk table and
            // allocate a buffer to hold snapped thunks. This is
            // done instead of writting to the mapped view so that
            // thunks are only updated if we find all the entry points
            //

            ThunkNames = (PIMAGE_THUNK_DATA) BindpRvaToVa( Parms, Imports->OriginalFirstThunk, Image );

            if (!ThunkNames || ThunkNames->u1.Function == 0) {
                //
                // Skip this one if no thunks or first thunk is the terminating null thunk
                //
                continue;
            }

            //
            // Unless specifically told not to, generate the new style
            // import descriptor.
            //

            NewImportDescriptor = BindpAddImportDescriptor(Parms,
                                                           &NewImportDescriptorHead,
                                                           Imports,
                                                           ImportModule,
                                                           Dll
                                                          );
            NumberOfThunks = 0;
            tname = ThunkNames;
            while (tname->u1.AddressOfData) {
                NumberOfThunks++;
                tname++;
            }
            SnappedThunks = (PIMAGE_THUNK_DATA) MemAlloc( NumberOfThunks*sizeof(*SnappedThunks) );
            if ( !SnappedThunks ) {
                continue;
            }

            tname = ThunkNames;
            tsnap = SnappedThunks;
            NoErrors = TRUE;
            ForwarderChainHead = (ULONG)-1;
            ForwarderChain = &ForwarderChainHead;
            for(i=0;i<NumberOfThunks;i++) {
                BindThunkFailed = FALSE;
                __try {
                    if (!BindpLookupThunk( Parms,
                                           tname,
                                           Image,
                                           SnappedThunks,
                                           tsnap,
                                           Dll,
                                           Exports,
                                           NewImportDescriptor,
                                           DllPath,
                                           &ForwarderChain
                                         )
                       ) {
                        BindThunkFailed = TRUE;
                    }
                } __except ( EXCEPTION_EXECUTE_HANDLER ) {
                    BindThunkFailed = TRUE;
                }

                if (BindThunkFailed) {
                    if (NewImportDescriptor != NULL) {
                        NewImportDescriptor->TimeDateStamp = 0;
                    }

                    if (Parms->StatusRoutine != NULL) {
                        Ordinal = (BOOL)IMAGE_SNAP_BY_ORDINAL(tname->u1.Ordinal);
                        if (Ordinal) {
                            UCHAR szOrdinal[8];

                            OrdinalNumber = (USHORT)(IMAGE_ORDINAL(tname->u1.Ordinal) - Exports->Base);
                            ImportName = (PIMAGE_IMPORT_BY_NAME)NameBuffer;
                            // Can't use sprintf w/o dragging in more CRT support than we want...  Must run on Win95.
                            strcpy((PCHAR) ImportName->Name, "Ordinal");
                            strcat((PCHAR) ImportName->Name, _ultoa((ULONG) OrdinalNumber, (LPSTR)szOrdinal, 16));
                        }
                        else {
                            ImportName = (PIMAGE_IMPORT_BY_NAME)BindpRvaToVa(
                                                                    Parms,
                                                                    (ULONG)(ULONG_PTR)(tname->u1.AddressOfData),
                                                                    Image
                                                                    );
                        }

                        (Parms->StatusRoutine)( BindImportProcedureFailed,
                                                Image->ModuleName,
                                                Dll->ModuleName,
                                                (ULONG_PTR)tsnap->u1.Function,
                                                (ULONG_PTR)(ImportName->Name)
                                              );
                    }

                    break;
                }

                tname++;
                tsnap++;
            }

            tname = (PIMAGE_THUNK_DATA) BindpRvaToVa( Parms, Imports->FirstThunk, Image );
            if ( !tname ) {
                NoErrors = FALSE;
            }

            //
            // If we were able to locate all of the entrypoints in the
            // target dll, then copy the snapped thunks into the image,
            // update the time and date stamp, and flush the image to
            // disk
            //

            if ( NoErrors && Parms->fNoUpdate == FALSE ) {
                if (ForwarderChainHead != -1) {
                    *ImageModified = TRUE;
                    *ForwarderChain = -1;
                }
                if (Imports->ForwarderChain != ForwarderChainHead) {
                    Imports->ForwarderChain = ForwarderChainHead;
                    *ImageModified = TRUE;
                }
                cb = NumberOfThunks*sizeof(*SnappedThunks);
                if (memcmp(tname,SnappedThunks,cb)) {
                    MoveMemory(tname,SnappedThunks,cb);
                    *ImageModified = TRUE;
                }
                if (NewImportDescriptorHead == NULL) {
                    if (Imports->TimeDateStamp != FileHeader->TimeDateStamp) {
                        Imports->TimeDateStamp = FileHeader->TimeDateStamp;
                        *ImageModified = TRUE;
                    }
                }
                else
                if (Imports->TimeDateStamp != 0xFFFFFFFF) {
                    Imports->TimeDateStamp = 0xFFFFFFFF;
                    *ImageModified = TRUE;
                }
            }

            MemFree(SnappedThunks);
        }
    }

    NewImports = BindpCreateNewImportSection(Parms, &NewImportDescriptorHead, &NewImportsSize);
    if (PrevNewImportsSize != NewImportsSize ||
        memcmp( PrevNewImports, NewImports, NewImportsSize )
       ) {
        *ImageModified = TRUE;
    }

    if (!*ImageModified) {
        return;
    }

    if (Parms->StatusRoutine != NULL) {
        (Parms->StatusRoutine)( BindImageModified,
                                Image->ModuleName,
                                NULL,
                                0,
                                0
                              );
    }

    if (NewImports != NULL) {
        ULONG cbFreeFile, cbFreeHeaders, OffsetHeaderFreeSpace, cbFreeSpaceOnDisk;

        if (NoErrors && Parms->fNoUpdate == FALSE) {
            OPTIONALHEADER_LV(DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ].VirtualAddress) = 0;
            OPTIONALHEADER_LV(DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ].Size) = 0;
        }
        OffsetHeaderFreeSpace = GetImageUnusedHeaderBytes( Image, &cbFreeFile );
        cbFreeHeaders = Image->Sections->VirtualAddress -
                        OPTIONALHEADER(SizeOfHeaders) +
                        cbFreeFile;

        // FreeSpace on Disk may be larger that FreeHeaders in the headers (the linker
        // can start the first section on a page boundary already)

        cbFreeSpaceOnDisk = Image->Sections->PointerToRawData -
                            OPTIONALHEADER(SizeOfHeaders) +
                            cbFreeFile;

        if (NewImportsSize > cbFreeFile) {
            if (NewImportsSize > cbFreeHeaders) {
                if (Parms->StatusRoutine != NULL) {
                    (Parms->StatusRoutine)( BindNoRoomInImage,
                                            Image->ModuleName,
                                            NULL,
                                            0,
                                            0
                                          );
                }
                NoErrors = FALSE;
            }
            else
            if (NoErrors && (Parms->fNoUpdate == FALSE)) {
                if (NewImportsSize <= cbFreeSpaceOnDisk) {

                    // There's already space on disk.  Just adjust the header size.

                    OPTIONALHEADER_LV(SizeOfHeaders) =
                        (OPTIONALHEADER(SizeOfHeaders) -
                         cbFreeFile + NewImportsSize + (OPTIONALHEADER(FileAlignment)-1)
                        ) & ~(OPTIONALHEADER(FileAlignment)-1);

                } else  {

                    NoErrors = BindpExpandImageFileHeaders( Parms,
                                                            Image,
                                                           (OPTIONALHEADER(SizeOfHeaders) -
                                                             cbFreeFile +
                                                             NewImportsSize +
                                                             (OPTIONALHEADER(FileAlignment)-1)
                                                            ) &
                                                             ~(OPTIONALHEADER(FileAlignment)-1)
                                                          );
                    // Expand may have remapped the image.  Recalc the header ptrs.
                    FileHeader = &((PIMAGE_NT_HEADERS32)Image->FileHeader)->FileHeader;
                    OptionalHeadersFromNtHeaders((PIMAGE_NT_HEADERS32)Image->FileHeader,
                                                 &OptionalHeader32,
                                                 &OptionalHeader64);

                }
            }
        }

        if (Parms->StatusRoutine != NULL) {
            (Parms->StatusRoutine)( BindImageComplete,
                                    Image->ModuleName,
                                    NULL,
                                    (ULONG_PTR)NewImports,
                                    NoErrors
                                  );
        }

        if (NoErrors && Parms->fNoUpdate == FALSE) {
            OPTIONALHEADER_LV(DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ].VirtualAddress) = OffsetHeaderFreeSpace;
            OPTIONALHEADER_LV(DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ].Size) = NewImportsSize;
            memcpy( (LPSTR)(Image->MappedAddress) + OffsetHeaderFreeSpace,
                    NewImports,
                    NewImportsSize
                  );
        }

        MemFree(NewImports);
    }

    if (NoErrors && Parms->fNoUpdate == FALSE) {
        SetIdataToRo( Image );
    }
}


DWORD
GetImageUnusedHeaderBytes(
    PLOADED_IMAGE LoadedImage,
    LPDWORD SizeUnusedHeaderBytes
    )
{
    DWORD OffsetFirstUnusedHeaderByte;
    DWORD i;
    DWORD OffsetHeader;
    PIMAGE_OPTIONAL_HEADER32 OptionalHeader32 = NULL;
    PIMAGE_OPTIONAL_HEADER64 OptionalHeader64 = NULL;
    PIMAGE_NT_HEADERS32 NtHeaders;

    NtHeaders = (PIMAGE_NT_HEADERS32)LoadedImage->FileHeader;

    //
    // this calculates an offset, not an address, so DWORD is correct
    //
    OffsetFirstUnusedHeaderByte = (DWORD)
       (((LPSTR)NtHeaders - (LPSTR)LoadedImage->MappedAddress) +
        (FIELD_OFFSET( IMAGE_NT_HEADERS32, OptionalHeader ) +
         NtHeaders->FileHeader.SizeOfOptionalHeader +
         (NtHeaders->FileHeader.NumberOfSections *
          sizeof(IMAGE_SECTION_HEADER)
         )
        )
       );

    OptionalHeadersFromNtHeaders(NtHeaders,
                                 &OptionalHeader32,
                                 &OptionalHeader64);

    for ( i=0; i<OPTIONALHEADER(NumberOfRvaAndSizes); i++ ) {
        OffsetHeader = OPTIONALHEADER(DataDirectory[i].VirtualAddress);
        if (OffsetHeader < OPTIONALHEADER(SizeOfHeaders)) {
            if (OffsetHeader >= OffsetFirstUnusedHeaderByte) {
                OffsetFirstUnusedHeaderByte = OffsetHeader +
                    OPTIONALHEADER(DataDirectory[i].Size);
                }
            }
        }

    *SizeUnusedHeaderBytes = OPTIONALHEADER(SizeOfHeaders) -
                             OffsetFirstUnusedHeaderByte;

    return OffsetFirstUnusedHeaderByte;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagebld.new\stringrc.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    stringrc.cpp

Abstract:

    This module implements miscellaneous utility routines for the utility
    program to build an Xbox executable image.

--*/

#include "imgbldp.h"

VOID
ImgbResourcePrintfV(
    FILE *file,
    UINT uStringID,
    va_list args
    )
{
    CHAR szResource[256];
    CHAR szMessage[1024];

    if (LoadString(NULL, uStringID, szResource, sizeof(szResource)) > 0) {

        FormatMessage(FORMAT_MESSAGE_FROM_STRING, szResource, 0, 0, szMessage,
            sizeof(szMessage), &args);

        fputs(szMessage, file);
    }
}

VOID
ImgbResourcePrintf(
    FILE *file,
    UINT uStringID,
    ...
    )
{
    va_list args;

    va_start(args, uStringID);

    ImgbResourcePrintfV(file, uStringID, args);

    va_end(args);
}

VOID
ImgbResourcePrintLogoBanner(
    VOID
    )
{
    ImgbResourcePrintf(stderr, IDS_LOGO_NAME_AND_VERSION, VER_PRODUCTVERSION_STR);
    fputs("\n", stderr);
    ImgbResourcePrintf(stderr, IDS_LOGO_COPYRIGHT);
    fputs("\n\n", stderr);
}

VOID
ImgbResourcePrintErrorAndExit(
    UINT uStringID,
    ...
    )
{
    va_list args;

    fprintf(stderr, "IMAGEBLD : error IM%04d: ", uStringID);

    va_start(args, uStringID);

    ImgbResourcePrintfV(stderr, uStringID, args);
    fputs("\n", stderr);

    va_end(args);

    ImgbExitProcess(1);
}

VOID
ImgbResourcePrintWarning(
    UINT uStringID,
    ...
    )
{
    va_list args;

    fprintf(stderr, "IMAGEBLD : warning IM%04d: ", uStringID);

    va_start(args, uStringID);

    ImgbResourcePrintfV(stderr, uStringID, args);
    fputs("\n", stderr);

    va_end(args);
}

VOID
ImgbResourcePrintRange(
    FILE *file,
    UINT uStartingStringID
    )
{
    UINT uStringID;
    CHAR szResource[256];

    uStringID = uStartingStringID;

    for (;;) {

        if (LoadString(NULL, uStringID, szResource, sizeof(szResource)) == 0) {
            break;
        }

        if (szResource[0] == '~') {
            break;
        }

        fputs(szResource, file);
        fputs("\n", file);

        uStringID++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\bind.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    bind.c

Abstract:

Author:

Revision History:

--*/

#include <private.h>

BOOL
Match(
    char *Pattern,
    char *Text
    )
{
    switch (*Pattern) {
       case '\0':
            return *Text == '\0';

        case '?':
            return *Text != '\0' && Match( Pattern + 1, Text + 1 );

        case '*':
            do {
                if (Match( Pattern + 1, Text ))
                    return TRUE;
                    }
            while (*Text++);
            return FALSE;

        default:
            return toupper( *Text ) == toupper( *Pattern ) && Match( Pattern + 1, Text + 1 );
        }
}


BOOL
AnyMatches(
    char *Name,
    int  *NumList,
    int  Length,
    char **StringList
    )
{
    if (Length == 0) {
        return FALSE;
        }

    return (Match( StringList[ NumList[ 0 ] ], Name ) ||
            AnyMatches( Name, NumList + 1, Length - 1, StringList )
           );
}

BOOL
BindStatusRoutine(
    IMAGEHLP_STATUS_REASON Reason,
    LPSTR ImageName,
    LPSTR DllName,
    PVOID Va,
    ULONG_PTR Parameter
    );

#define BIND_ERR 99
#define BIND_OK  0

PCHAR SymbolPath;

BOOL fVerbose;
BOOL fNoUpdate = TRUE;
BOOL fDisableNewImports;
BOOL fNoCacheImportDlls;
BOOL fBindSysImages;
DWORD BindFlags;

int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    char c, *p;
    int ExcludeList[256];
    int ExcludeListLength = 0;

    BOOL fUsage = FALSE;
    LPSTR DllPath;
    LPSTR CurrentImageName;

    int ArgNumber = argc;
    char **ArgList = argv;

    envp;

    DllPath = NULL;
    CurrentImageName = NULL;

    if (argc < 2) {
        goto usage;
    }

    while (--argc) {
        p = *++argv;
        if (*p == '/' || *p == '-') {
            while (c = *++p)
            switch (toupper( c )) {
                case '?':
                    fUsage = TRUE;
                    break;

                case 'C':
                    fNoCacheImportDlls = TRUE;
                    break;

                case 'O':
                    fDisableNewImports = TRUE;
                    break;

                case 'P':
                    if (--argc) {
                        DllPath = *++argv;
                    } else {
                        fprintf( stderr, "BIND: Parameter missing for /%c\n", c );
                        fUsage = TRUE;
                    }
                    break;

                case 'S':
                    if (--argc) {
                        SymbolPath = *++argv;
                    } else {
                        fprintf( stderr, "BIND: Parameter missing for /%c\n", c );
                        fUsage = TRUE;
                    }
                    break;

                case 'U':
                    fNoUpdate = FALSE;
                    break;

                case 'V':
                    fVerbose = TRUE;
                    break;

                case 'X' :
                    if (--argc) {
                        ++argv;
                        ExcludeList[ExcludeListLength] = ArgNumber - argc;
                        ExcludeListLength++;
                    } else {
                        fprintf( stderr, "BIND: Parameter missing for /%c\n", c );
                        fUsage = TRUE;
                    }
                    break;

                case 'Y':
                    fBindSysImages = TRUE;
                    break;

                default:
                    fprintf( stderr, "BIND: Invalid switch - /%c\n", c );
                    fUsage = TRUE;
                    break;
                }
            if (fUsage) {
usage:
                fputs("usage: BIND [switches] image-names... \n"
                      "            [-?] display this message\n"
                      "            [-c] no caching of import dlls\n"
                      "            [-o] disable new import descriptors\n"
                      "            [-p dll search path]\n"
                      "            [-s Symbol directory] update any associated .DBG file\n"
                      "            [-u] update the image\n"
                      "            [-v] verbose output\n"
                      "            [-x image name] exclude this image from binding\n"
                      "            [-y] allow binding on images located above 2G",
                      stderr
                     );
                return BIND_ERR;
            }
        } else {
            CurrentImageName = p;
            if (fVerbose) {
                fprintf( stdout,
                         "BIND: binding %s using DllPath %s\n",
                         CurrentImageName,
                         DllPath ? DllPath : "Default"
                       );
            }

            if (AnyMatches( CurrentImageName, ExcludeList, ExcludeListLength, ArgList )) {
                if (fVerbose) {
                    fprintf( stdout, "BIND: skipping %s\n", CurrentImageName );
                }
            } else {
                BindFlags = 0;

                if (!fNoCacheImportDlls) {
                    // Always cache across calls unless the user indicates otherwise.
                    BindFlags |= BIND_CACHE_IMPORT_DLLS;
                }
                if (fNoUpdate) {
                    BindFlags |= BIND_NO_UPDATE;
                }
                if (fDisableNewImports) {
                    BindFlags |= BIND_NO_BOUND_IMPORTS;
                }
                if (fBindSysImages) {
                    BindFlags |= BIND_ALL_IMAGES;
                }

                BindImageEx( BindFlags,
                             CurrentImageName,
                             DllPath,
                             SymbolPath,
                             (PIMAGEHLP_STATUS_ROUTINE)BindStatusRoutine
                           );
            }
        }
    }

    return BIND_OK;
}


BOOL
BindStatusRoutine(
    IMAGEHLP_STATUS_REASON Reason,
    LPSTR ImageName,
    LPSTR DllName,
    PVOID Va,
    ULONG_PTR Parameter
    )
{
    PIMAGE_BOUND_IMPORT_DESCRIPTOR NewImports, NewImport;
    PIMAGE_BOUND_FORWARDER_REF NewForwarder;
    UINT i;

    switch( Reason ) {
        case BindOutOfMemory:
            fprintf( stderr, "BIND: Out of memory - needed %u bytes.\n", Parameter );
            ExitProcess( 1 );

        case BindRvaToVaFailed:
            fprintf( stderr, "BIND: %s contains invalid Rva - %p\n", ImageName, Va );
            break;

        case BindNoRoomInImage:
            fprintf( stderr,
                     "BIND: Not enough room for new format import table.  Defaulting to unbound image.\n"
                   );
            break;

        case BindImportModuleFailed:
            fprintf( stderr,"BIND: %s - Unable to find %s\n", ImageName, DllName );
            break;

        case BindImportProcedureFailed:
            fprintf( stderr,
                     "BIND: %s - %s entry point not found in %s\n",
                     ImageName,
                     Parameter,
                     DllName
                   );
            break;

        case BindImportModule:
            if (fVerbose) {
                fprintf( stderr,"BIND: %s - Imports from %s\n", ImageName, DllName );
                }
            break;

        case BindImportProcedure:
            if (fVerbose) {
                fprintf( stderr,
                         "BIND: %s - %s Bound to %p\n",
                         ImageName,
                         Parameter,
                         Va
                       );
                }
            break;

        case BindForwarder:
            if (fVerbose) {
                fprintf( stderr, "BIND: %s - %s forwarded to %s [%p]\n",
                         ImageName,
                         DllName,
                         Parameter,
                         Va
                       );
            }
            break;

        case BindForwarderNOT:
            if (fVerbose) {
                fprintf( stderr,
                         "BIND: %s - Forwarder %s not snapped [%p]\n",
                         ImageName,
                         Parameter,
                         Va
                       );
                }
            break;

        case BindImageModified:
            fprintf( stdout, "BIND: binding %s\n", ImageName );
            break;


        case BindExpandFileHeaders:
            if (fVerbose) {
                fprintf( stderr,
                         "    Expanded %s file headers to %x\n",
                         ImageName,
                         Parameter
                       );
                }
            break;

        case BindMismatchedSymbols:
            fprintf(stderr, "BIND: Warning: %s checksum did not match %s\n",
                            ImageName,
                            (LPSTR)Parameter);
            break;

        case BindSymbolsNotUpdated:
            fprintf(stderr, "BIND: Warning: symbol file %s not updated.\n",
                            (LPSTR)Parameter);
            break;

        case BindImageComplete:
            if (fVerbose) {
                fprintf(stderr, "BIND: Details of binding of %s\n", ImageName );
                NewImports = (PIMAGE_BOUND_IMPORT_DESCRIPTOR)Va;
                NewImport = NewImports;
                while (NewImport->OffsetModuleName) {
                    fprintf( stderr, "    Import from %s [%x]",
                             (LPSTR)NewImports + NewImport->OffsetModuleName,
                             NewImport->TimeDateStamp
                           );
                    if (NewImport->NumberOfModuleForwarderRefs != 0) {
                        fprintf( stderr, " with %u forwarders", NewImport->NumberOfModuleForwarderRefs );
                    }
                    fprintf( stderr, "\n" );
                    NewForwarder = (PIMAGE_BOUND_FORWARDER_REF)(NewImport+1);
                    for ( i=0; i<NewImport->NumberOfModuleForwarderRefs; i++ ) {
                        fprintf( stderr, "        Forward to %s [%x]\n",
                                 (LPSTR)NewImports + NewForwarder->OffsetModuleName,
                                 NewForwarder->TimeDateStamp
                               );
                        NewForwarder += 1;
                    }
                    NewImport = (PIMAGE_BOUND_IMPORT_DESCRIPTOR)NewForwarder;
                }
            }
            break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\binplace.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <private.h>
#include <io.h>
#include <share.h>
#include <time.h>
#include <setupapi.h>
#include "rsa.h"
#include "md5.h"
#include "symutil.h"

#ifndef MOVEFILE_CREATE_HARDLINK
    #define MOVEFILE_CREATE_HARDLINK  0x00000010
#endif

#define BINPLACE_ERR 77
#define BINPLACE_OK 0

BOOL fUpDriver;
BOOL fUsage;
BOOL fVerbose;
BOOL fSymChecking;
BOOL fTestMode;
BOOL fSplitSymbols;
BOOL fSetupMode;
BOOL fSetupModeAllFiles;
BOOL fSetupModeScriptFile;
BOOL fPatheticOS;
BOOL fLiveSystem;
BOOL fKeepAttributes;
BOOL fDigitalSign;
BOOL fHardLinks;
BOOL fIgnoreHardLinks;
BOOL fDontLog;
BOOL fPlaceWin95SymFile;
BOOL fNoClassInSymbolsDir;
BOOL fMakeErrorOnDumpCopy;
BOOL fDontExit;
BOOL fForcePlace;
BOOL fSignCode;
BOOL fVerifyLc;
BOOL fWarnOnMissingVersionResource;

HINSTANCE hSetupApi;
HINSTANCE hLcManager;
HRESULT (WINAPI * pVerifyLocConstraintA) (IN PCSTR FileName, IN PCSTR LcFileName);
BOOL (WINAPI * pSetupGetIntField) (IN PINFCONTEXT Context, IN DWORD FieldIndex, OUT PINT IntegerValue);
BOOL (WINAPI * pSetupFindFirstLineA) (IN HINF InfHandle, IN PCSTR Section, IN PCSTR Key, OPTIONAL OUT PINFCONTEXT Context );
BOOL (WINAPI * pSetupGetStringFieldA) (IN PINFCONTEXT Context, IN DWORD FieldIndex, OUT PSTR ReturnBuffer, OPTIONAL IN DWORD ReturnBufferSize, OUT PDWORD RequiredSize);
HINF (WINAPI * pSetupOpenInfFileA) ( IN PCSTR FileName, IN PCSTR InfClass, OPTIONAL IN DWORD InfStyle, OUT PUINT ErrorLine OPTIONAL );
HINF (WINAPI * pSetupOpenMasterInf) (VOID);

ULONG SplitFlags = 0;

LPSTR CurrentImageName;
LPSTR PlaceFileName;
LPSTR PlaceRootName;
LPSTR ExcludeFileName;
LPSTR DumpOverride;
LPSTR LayoutInfName;
LPSTR NormalPlaceSubdir;
LPSTR CommandScriptName;
LPSTR SymbolFilePath;
LPSTR PrivateSymbolFilePath;
LPSTR BinplaceLcDir;
LPSTR LcFilePart;

HINF LayoutInf;

FILE *PlaceFile;
FILE *LogFile;
FILE *CommandScriptFile;
CHAR gFullFileName[MAX_PATH+1];
UCHAR SetupFilePath[ MAX_PATH+1 ];
UCHAR DebugFilePath[ MAX_PATH+1 ];
UCHAR PlaceFilePath[ MAX_PATH+1 ];
UCHAR ExcludeFilePath[ MAX_PATH+1 ];
UCHAR DefaultSymbolFilePath[ MAX_PATH+1 ];
UCHAR szAltPlaceRoot[ MAX_PATH+1 ];
UCHAR LcFullFileName[ MAX_PATH+1 ];
UCHAR szExtraInfo[4096];

PEXCLUDE_LIST ExcludeList;

#define DEFAULT_PLACE_FILE    "\\public\\sdk\\lib\\placefil.txt"
#define DEFAULT_NTROOT        "\\nt"
#define DEFAULT_NTDRIVE       "c:"
#define DEFAULT_DUMP          "dump"
#define DEFAULT_LCDIR         "LcINF"
#define DEFAULT_EXCLUDE_FILE  "\\public\\tools\\symbad.txt"

typedef struct _CLASS_TABLE {
    LPSTR ClassName;
    LPSTR ClassLocation;
} CLASS_TABLE, *PCLASS_TABLE;

BOOL
PlaceTheFile();

typedef
BOOL
(WINAPI *PCREATEHARDLINKA)(
                          LPCSTR lpFileName,
                          LPCSTR lpExistingFileName,
                          LPSECURITY_ATTRIBUTES lpSecurityAttributes
                          );

PCREATEHARDLINKA pCreateHardLinkA;

BOOL
CopyTheFile(
           LPSTR SourceFileName,
           LPSTR SourceFilePart,
           LPSTR DestinationSubdir,
           LPSTR DestinationFilePart
           );

BOOL
BinplaceCopyPdb (
                LPSTR DestinationFile,
                LPSTR SourceFileName,       // Used for redist case
                BOOL  CopyFromSourceOnly,
                BOOL  StripPrivate
                );

BOOL
VerifyFinalImage(
                IN  PCHAR FileName,
                IN  BOOL  fRetail,
                OUT PBOOL BinplaceLc
                );

BOOL
SourceIsNewer(
             IN LPSTR SourceFile,
             IN LPSTR TargetFile
             );

BOOL
SetupModeRetailFile(
                   IN  LPSTR FullFileName,
                   IN  LPSTR FileNamePart,
                   OUT PBOOL PutInDump
                   );

__inline BOOL
SearchOneDirectory(
                  IN  LPSTR Directory,
                  IN  LPSTR FileToFind,
                  IN  LPSTR SourceFullName,
                  IN  LPSTR SourceFilePart,
                  OUT PBOOL FoundInTree
                  )
{
    //
    // This was way too slow. Just say we didn't find the file.
    //
    *FoundInTree = FALSE;
    return(TRUE);
}

BOOL
FileExists(
          IN  LPCSTR FileName,
          OUT PWIN32_FIND_DATA FindData
          );

BOOL
SignWithIDWKey(
              IN  LPCSTR  FileName);


CLASS_TABLE CommonClassTable[] = {
    {"retail",  "."},
    {"system",  "system32"},
    {"system16","system"},
    {"windows", "."},
    {"drivers", "system32\\drivers"},
    {"drvetc",  "system32\\drivers\\etc"},
    {"config",  "system32\\config"},
    {NULL,NULL}
};

CLASS_TABLE i386SpecificClassTable[] = {
    {"hal","system32"},
    {"printer","system32\\spool\\drivers\\w32x86"},
    {"prtprocs","system32\\spool\\prtprocs\\w32x86"},
    {NULL,NULL}
};

CLASS_TABLE Axp64SpecificClassTable[] = {
    {"hal",".."},
    {"printer","system32\\spool\\drivers\\w32axp64"},
    {"prtprocs","system32\\spool\\prtprocs\\w32axp64"},
    {NULL,NULL}
};

CLASS_TABLE AlphaSpecificClassTable[] = {
    {"hal",".."},
    {"printer","system32\\spool\\drivers\\w32alpha"},
    {"prtprocs","system32\\spool\\prtprocs\\w32alpha"},
    {NULL,NULL}
};

CLASS_TABLE ia64SpecificClassTable[] = {
    {"hal",".."},
    {"printer","system32\\spool\\drivers\\w32ia64"},
    {"prtprocs","system32\\spool\\prtprocs\\w32ia64"},
    {NULL,NULL}
    };

//
// Names of sections in layout.inx
//
LPCSTR szSourceDisksFiles = "SourceDisksFiles";
LPCSTR szSourceDisksAxp64 = "SourceDisksFiles.axp64";
LPCSTR szSourceDisksAlpha = "SourceDisksFiles.alpha";
LPCSTR szSourceDisksX86   = "SourceDisksFiles.x86";
LPCSTR szSourceDisksIA64  = "SourceDisksFiles.ia64";

typedef struct _PLACE_FILE_RECORD {
    LPSTR FileNameEntry;
    LPSTR FileClass;
} PLACE_FILE_RECORD, *PPLACE_FILE_RECORD;

int MaxNumberOfRecords;
int NumberOfRecords;
PPLACE_FILE_RECORD PlaceFileRecords;

int __cdecl
pfcomp(
      const void *e1,
      const void *e2
      )
{
    PPLACE_FILE_RECORD p1;
    PPLACE_FILE_RECORD p2;

    p1 = (PPLACE_FILE_RECORD)e1;
    p2 = (PPLACE_FILE_RECORD)e2;

    return (strcmp(p1->FileNameEntry,p2->FileNameEntry));
}

CHAR PlaceFileDir[4096];
CHAR PlaceFileClass[4096];
CHAR PlaceFileEntry[4096];

BOOL
SortPlaceFileRecord()
{
    int cfield;
    PPLACE_FILE_RECORD NewRecords;

    NumberOfRecords = 0;
    MaxNumberOfRecords = 0;

    //
    // get space for 6k records. Grow if need to.
    //
    PlaceFileRecords = (PPLACE_FILE_RECORD) malloc( sizeof(*PlaceFileRecords)*7000 );
    if ( !PlaceFileRecords ) {
        return FALSE;
    }
    MaxNumberOfRecords = 7000;

    fseek(PlaceFile,0,SEEK_SET);
    while (fgets(PlaceFileDir,sizeof(PlaceFileDir),PlaceFile)) {

        PlaceFileEntry[0] = '\0';
        PlaceFileClass[0] = '\0';

        cfield = sscanf(
                       PlaceFileDir,
//                       "%s %[A-Za-z0-9.,_!@#\\$+=%^&()~ -]s",
                       "%s %s",
                       PlaceFileEntry,
                       PlaceFileClass
                       );

        if (cfield <= 0 || PlaceFileEntry[0] == ';') {
            continue;
        }

#ifdef _AXP64_
{
    char *volatile p = PlaceFileEntry;
    PlaceFileRecords[NumberOfRecords].FileNameEntry = (LPSTR) malloc( strlen(p)+1 );
    p = PlaceFileClass;
    PlaceFileRecords[NumberOfRecords].FileClass = (LPSTR) malloc( strlen(p)+1 );
}
#else
        PlaceFileRecords[NumberOfRecords].FileNameEntry = (LPSTR) malloc( strlen(PlaceFileEntry)+1 );
        PlaceFileRecords[NumberOfRecords].FileClass = (LPSTR) malloc( strlen(PlaceFileClass)+1 );
#endif
        if (!PlaceFileRecords[NumberOfRecords].FileClass || !PlaceFileRecords[NumberOfRecords].FileNameEntry) {
            free(PlaceFileRecords);
            PlaceFileRecords = NULL;
            return FALSE;
        }
        strcpy(PlaceFileRecords[NumberOfRecords].FileNameEntry,PlaceFileEntry);
        strcpy(PlaceFileRecords[NumberOfRecords].FileClass,PlaceFileClass);
        NumberOfRecords++;
        if ( NumberOfRecords >= MaxNumberOfRecords ) {
            MaxNumberOfRecords += 200;
            NewRecords = (PPLACE_FILE_RECORD) realloc(
                                                     PlaceFileRecords,
                                                     sizeof(*PlaceFileRecords)*MaxNumberOfRecords
                                                     );
            if ( !NewRecords ) {
                PlaceFileRecords = NULL;
                return FALSE;
            }
            PlaceFileRecords = NewRecords;
        }
    }
    qsort((void *)PlaceFileRecords,(size_t)NumberOfRecords,(size_t)sizeof(*PlaceFileRecords),pfcomp);
    return TRUE;
}

PPLACE_FILE_RECORD
LookupPlaceFileRecord(
                     LPSTR FileName
                     )
{
    LONG High;
    LONG Low;
    LONG Middle;
    LONG Result;

    //
    // Lookup the name using a binary search.
    //

    if ( !PlaceFileRecords ) {
        return NULL;
    }

    Low = 0;
    High = NumberOfRecords - 1;
    while (High >= Low) {

        //
        // Compute the next probe index and compare the import name
        // with the export name entry.
        //

        Middle = (Low + High) >> 1;
        Result = _stricmp(FileName, PlaceFileRecords[Middle].FileNameEntry);

        if (Result < 0) {
            High = Middle - 1;

        } else if (Result > 0) {
            Low = Middle + 1;

        } else {
            break;
        }
    }

    if (High < Low) {
        return NULL;
    } else {
        return &PlaceFileRecords[Middle];
    }
}

int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    char c, *p, *OverrideFlags, *s, **newargv;
    LPSTR LogFileName = NULL;
    LPSTR LcFileName  = NULL;
    int len = 0;
    int i, n;
    BOOL NoPrivateSplit = FALSE;
    OSVERSIONINFO VersionInformation;
    LPTSTR platform;

    //
    // Win 95 can't compare file times very well, this hack neuters the SourceIsNewer function
    // on Win 95
    //
    VersionInformation.dwOSVersionInfoSize = sizeof( VersionInformation );
    if (GetVersionEx( &VersionInformation ) && VersionInformation.dwPlatformId != VER_PLATFORM_WIN32_NT) {
        fPatheticOS = TRUE;
    }

    envp;
    fUpDriver = FALSE;
    fUsage = FALSE;
    fVerbose = FALSE;
    fSymChecking = FALSE;
    fTestMode = FALSE;
    fSplitSymbols = FALSE;
    fSetupMode = FALSE;
    fSetupModeAllFiles = FALSE;
    fSetupModeScriptFile = FALSE;
    fLiveSystem = FALSE;
    fKeepAttributes = FALSE;
    fDigitalSign = FALSE;
    fHardLinks = FALSE;
    fIgnoreHardLinks = FALSE;
    fDontExit = FALSE;
    fForcePlace = FALSE;
    fSignCode = FALSE;
    fVerifyLc = FALSE;
    fWarnOnMissingVersionResource = FALSE;
    NormalPlaceSubdir = NULL;
    pVerifyLocConstraintA = NULL;

    if (argc < 2) {
        goto showUsage;
    }

    LayoutInfName = NULL;

    setvbuf(stderr, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    if (!(PlaceFileName = getenv( "BINPLACE_PLACEFILE" ))) {
        if ((PlaceFileName = getenv("_NTDRIVE")) == NULL) {
            PlaceFileName = DEFAULT_NTDRIVE;
        }
        strcpy((PCHAR) PlaceFilePath, PlaceFileName);
        if ((PlaceFileName = getenv("_NTROOT")) == NULL) {
            PlaceFileName = DEFAULT_NTROOT;
        }
        strcat((PCHAR) PlaceFilePath, PlaceFileName);
        strcat((PCHAR) PlaceFilePath, DEFAULT_PLACE_FILE);
        PlaceFileName = (PCHAR) PlaceFilePath;
    }

    if (!(ExcludeFileName = getenv( "BINPLACE_EXCLUDE_FILE" ))) {
        if ((ExcludeFileName = getenv("_NTDRIVE")) == NULL) {
            ExcludeFileName = DEFAULT_NTDRIVE;
        }
        strcpy((PCHAR) ExcludeFilePath, ExcludeFileName);
        if ((ExcludeFileName = getenv("_NTROOT")) == NULL) {
            ExcludeFileName = DEFAULT_NTROOT;
        }
        strcat((PCHAR) ExcludeFilePath, ExcludeFileName);
        strcat((PCHAR) ExcludeFilePath, DEFAULT_EXCLUDE_FILE);
        ExcludeFileName = (PCHAR) ExcludeFilePath;
    }

    if (!(BinplaceLcDir = getenv( "BINPLACE_LCDIR" ))) {
        BinplaceLcDir = DEFAULT_LCDIR;
    }

    if ( getenv("NT_SIGNCODE") != NULL ) {
        fSignCode=TRUE;
    }

    //
    // Support Cross compile as well
    //
#if defined(_AXP64_)
    PlaceRootName = getenv( "_NTAXP64TREE" );
#elif defined(_ALPHA_)
    PlaceRootName = getenv( "_NTALPHATREE" );
    if ((platform = getenv("AXP64")) != NULL) {
        PlaceRootName = getenv( "_NTAXP64TREE" );
    }
#elif defined(_IA64_)
    PlaceRootName = getenv( "_NTIA64TREE" );
#else // defined(_X86_)
    PlaceRootName = getenv( "_NT386TREE" );
    if ((platform = getenv("IA64")) != NULL) {
        PlaceRootName = getenv( "_NTIA64TREE" );
    }
#endif

    CurrentImageName = NULL;

    OverrideFlags = getenv( "BINPLACE_OVERRIDE_FLAGS" );
    if (OverrideFlags != NULL) {
        s = OverrideFlags;
        n = 0;
        while (*s) {
            while (*s && *s <= ' ')
                s += 1;
            if (*s) {
                n += 1;
                while (*s > ' ')
                    s += 1;

                if (*s)
                    *s++ = '\0';
            }
        }

        if (n) {
            newargv = malloc( (argc + n + 1) * sizeof( char * ) );
            memcpy( &newargv[n], argv, argc * sizeof( char * ) );
            argv = newargv;
            argv[ 0 ] = argv[ n ];
            argc += n;
            s = OverrideFlags;
            for (i=1; i<=n; i++) {
                while (*s && *s <= ' ')
                    s += 1;
                argv[ i ] = s;
                while (*s++)
                    ;
            }
        }
    }

    while (--argc) {
        p = *++argv;
        if (*p == '/' || *p == '-') {
            while (c = *++p)
                switch (toupper( c )) {
                    case '?':
                        fUsage = TRUE;
                        break;

                    case 'A':
                        SplitFlags |= SPLITSYM_EXTRACT_ALL;
                        break;

                    case 'B':
                        argc--, argv++;
                        NormalPlaceSubdir = *argv;
                        break;

                    case 'C':
                        fDigitalSign = TRUE;
                        break;

                    case 'D':
                        argc--, argv++;
                        DumpOverride = *argv;
                        break;

                    case 'E':
                        fDontExit = TRUE;
                        break;

                    case 'F':
                        fForcePlace = TRUE;
                        break;

                    case 'G':
                        argc--, argv++;
                        LcFileName = *argv;
                        break;

                    case 'H':
                        if ((VersionInformation.dwPlatformId != VER_PLATFORM_WIN32_NT) ||
                            (VersionInformation.dwMajorVersion < 5) ||
                            (pCreateHardLinkA = (PCREATEHARDLINKA)GetProcAddress( GetModuleHandle( "KERNEL32" ),
                                                                                  "CreateHardLinkA"
                                                                                )
                            ) == NULL
                           ) {
                            fprintf( stderr, "BINPLACE: Hard links not supported.  Defaulting to CopyFile\n" );
                            fHardLinks = FALSE;
                        } else {
                            fHardLinks = TRUE;
                        }

                        break;

                    case 'I':
                        argc--, argv++;
                        LayoutInfName = *argv;
                        break;

                    case 'J':
                        fSymChecking = TRUE;
                        break;

                    case 'K':
                        fKeepAttributes = TRUE;
                        break;

                    case 'L':
                        fLiveSystem++;
                        break;

                    case 'M':
                        fMakeErrorOnDumpCopy = TRUE;
                        break;

                    case 'N':
                        argc--, argv++;
                        PrivateSymbolFilePath = *argv;
                        break;

                    case 'O':
                        argc--, argv++;
                        if (PlaceRootName != NULL) {
                            strcpy(szAltPlaceRoot,PlaceRootName);
                            strcat(szAltPlaceRoot,"\\");
                            strcat(szAltPlaceRoot,*argv);
                            PlaceRootName = szAltPlaceRoot;
                        }
                        break;

                    case 'P':
                        argc--, argv++;
                        PlaceFileName = *argv;
                        break;

                    case 'Q':
                        fDontLog = TRUE;
                        break;

                    case 'R':
                        argc--, argv++;
                        PlaceRootName = *argv;
                        break;

                    case 'S':
                        argc--, argv++;
                        SymbolFilePath = *argv;
                        fSplitSymbols = TRUE;
                        fIgnoreHardLinks = TRUE;
                        break;

                    case 'T':
                        fTestMode = TRUE;
                        break;

                    case 'U':
                        fUpDriver = TRUE;
                        break;

                    case 'V':
                        fVerbose = TRUE;
                        break;

                    case 'W':
                        //
                        // NOTE: xbox binplace has -w and -W
                        //
                        if (c == 'W')
                        {
                            fWarnOnMissingVersionResource = TRUE;
                        }
                        else
                        {
                            fPlaceWin95SymFile = TRUE;
                        }
                        break;

                    case 'X':
                        SplitFlags |= SPLITSYM_REMOVE_PRIVATE;
                        break;

                    case 'Y':
                        fNoClassInSymbolsDir = TRUE;
                        break;

                    case 'Z':
                        NoPrivateSplit = TRUE;
                        break;

                    case '!':
                        hSetupApi = LoadLibrary("setupapi.dll");
                        if (hSetupApi) {
                            (VOID *) pSetupGetIntField     = GetProcAddress(hSetupApi, "SetupGetIntField");
                            (VOID *) pSetupFindFirstLineA  = GetProcAddress(hSetupApi, "SetupFindFirstLineA");
                            (VOID *) pSetupGetStringFieldA = GetProcAddress(hSetupApi, "SetupGetStringFieldA");
                            (VOID *) pSetupOpenInfFileA    = GetProcAddress(hSetupApi, "SetupOpenInfFileA");
                            (VOID *) pSetupOpenMasterInf   = GetProcAddress(hSetupApi, "SetupOpenMasterInf");

                            if (pSetupGetIntField     &&
                                pSetupFindFirstLineA  &&
                                pSetupGetStringFieldA &&
                                pSetupOpenInfFileA    &&
                                pSetupOpenMasterInf) {
                                fSetupMode = TRUE;
                            } else {
                                printf("Unable to bind to the necessary SETUPAPI.DLL functions... Ignoring setup mode switch\n");
                            }
                        }

                        if (*(p+1) == '!') {
                            p++;
                            if (fSetupMode)
                                fSetupModeAllFiles = TRUE;

                            if (*(p+1) == '!') {
                                p++;
                                argc--, argv++;
                                CommandScriptName = *argv;
                                if (fSetupMode) {
                                    fSetupModeScriptFile = TRUE;
                                    CommandScriptFile = fopen(CommandScriptName, "a");
                                    if (!CommandScriptFile) {
                                        fprintf(stderr,"BINPLACE : fatal error BNP0000: fopen of script file %s failed %d\n",CommandScriptName,GetLastError());
                                        exit(BINPLACE_ERR);
                                    }
                                }
                            } else {
                                fIgnoreHardLinks = TRUE;
                            }
                        } else {
                            fIgnoreHardLinks = TRUE;
                        }
                        break;

                    default:
                        fprintf( stderr, "BINPLACE : error BNP0000: Invalid switch - /%c\n", c );
                        fUsage = TRUE;
                        break;
                }

            if ( fUsage ) {
                showUsage:
                fputs(
                     "usage: binplace [switches] image-names... \n"
                     "where: [-?] display this message\n"
                     "       [-a] Used with -s, extract all symbols\n"
                     "       [-b subdir] put file in subdirectory of normal place\n"
                     "       [-c] digitally sign image with IDW key\n"
                     "       [-d dump-override]\n"
                     "       [-e] don't exit if a file in list could not be binplaced\n"
                     "       [-f] force placement by disregarding file timestamps\n"
                     "       [-g lc-file] verify image with localization constraint file\n"
                     "       [-h] modifies behavior to use hard links instead of CopyFile.\n"
                     "            (ignored if -s, -! or -!! is present)\n"
                     "       [-i layout-inf] Used with -!, -!! or -!!!, override master inf location\n"
                     "       [-j] verify proper symbols exist before copying\n"
                     "       [-k] keep attributes (don't turn off archive)\n"
                     "       [-l] operate over a live system\n"
                     "       [-n <Path>] Used with -x - Private pdb symbol path\n"
                     "       [-o place-root-subdir] alternate project subdirectory\n"
                     "       [-p place-file]\n"
                     "       [-q] suppress writing to log file %BINPLACE_LOG%\n"
                     "       [-r place-root]\n"
                     "       [-s Symbol file path] split symbols from image files\n"
                     "       [-t] test mode\n"
                     "       [-u] UP driver\n"
                     "       [-v] verbose output\n"
                     "       [-w] copy the Win95 Sym file to the symbols tree\n"
                     "       [-W] warn if executable image does not have version resource\n"
                     "       [-x] Used with -s, delete private symbolic when splitting\n"
                     "       [-y] Used with -s, don't create class subdirs in the symbols tree\n"
                     "       [-z] ignore -x if present\n"
                     "       [-!] setup mode (ignore optional files)\n"
                     "       [-!!] setup mode (copy optional files)\n"
                     "       [-!!! script-file] setup mode with command script\n"
                     "\n"
                     "BINPLACE looks for the following environment variable names:\n"
                     "   BINPLACE_OVERRIDE_FLAGS - may contain additional switches\n"
                     "   BINPLACE_PLACEFILE - default value for -p flag\n"
                     "   _NT386TREE - default value for -r flag on x86 platform\n"
                     "   _NTALPHATREE - default value for -r flag on Alpha platform\n"
                     "   _NTAXP64TREE - default value for -r flag on Axp64 platform\n"
                     "   _NTIA64TREE - default value for -r flag on IA64 platform\n"
                     "\n"
                     ,stderr
                     );

                exit(BINPLACE_ERR);
            }
        } else {
            WIN32_FIND_DATA FindData;
            HANDLE h;

            if (!PlaceRootName) {
                // If there's no root, just exit.
                exit(BINPLACE_OK);
            }

            //
            // Workaround for bogus setargv: ignore directories
            //
            if (NoPrivateSplit) {
                SplitFlags &= ~SPLITSYM_REMOVE_PRIVATE;
            }

            h = FindFirstFile(p,&FindData);
            if (h != INVALID_HANDLE_VALUE) {
                FindClose(h);
                if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                    if ( fVerbose ) {
                        fprintf(stdout,"BINPLACE : warning BNP0000: ignoring directory %s\n",p);
                    }
                    continue;
                }
            }

            CurrentImageName = p;

            //
            // If the master place file has not been opened, open
            // it up.
            //

            if ( !PlaceFile ) {
                PlaceFile = fopen(PlaceFileName, "rt");
                if (!PlaceFile) {
                    fprintf(stderr,"BINPLACE : fatal error BNP0000: fopen of placefile %s failed %d\n",PlaceFileName,GetLastError());
                    exit(BINPLACE_ERR);
                }
                if (fSetupMode && !fSetupModeScriptFile) {
                    SortPlaceFileRecord();
                }
            }

            //
            // Check for bogus -g lc-file switch
            //
            if ( LcFileName != NULL ) {
                h = FindFirstFile(LcFileName, &FindData);
                if (h == INVALID_HANDLE_VALUE ||
                    (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                    if (fVerbose ) {
                        fprintf(stdout,"BINPLACE : warning BNP0000: invalid file %s. Ignoring -G switch.\n", LcFileName);
                    }
                    LcFileName = NULL;
                }
                if (h != INVALID_HANDLE_VALUE) {
                    FindClose(h);
                }
            }
            if ( LcFileName != NULL ) {
                DWORD cb = GetFullPathName(LcFileName,MAX_PATH+1,LcFullFileName,&LcFilePart);
                if (!cb || cb > MAX_PATH+1) {
                    fprintf(stderr,"BINPLACE : fatal error BNP0000: GetFullPathName %s failed %d\n",LcFileName, GetLastError());
                    exit(BINPLACE_ERR);
                }

                hLcManager = LoadLibraryA("lcman.DLL");
                if (hLcManager != NULL) {
                    (VOID *) pVerifyLocConstraintA = GetProcAddress(hLcManager, "VerifyLocConstraintA");
                }
                if (pVerifyLocConstraintA != NULL) {
                    fVerifyLc = TRUE;
                } else {
                    fprintf(stdout,"BINPLACE : warning BNP0000: Unable to bind to the necessary LCMAN.DLL functions... Ignoring -G switch\n");
                }
            }

            // Get the Exclude List

            ExcludeList = GetExcludeList( ExcludeFileName );

            //
            // If the log file has not been opened,
            // and we haven't suppressed logging, open it up
            //

            if ( !LogFile && !fDontLog) {
                if ((LogFileName = getenv("BINPLACE_LOG")) != NULL) {
                    LogFile = _fsopen(LogFileName, "a", _SH_DENYNO);
                    if ( !LogFile ) {
                        fprintf(stderr,"BINPLACE : error BNP0000: fopen of log file %s failed %d\n", LogFileName,GetLastError());
                    } else {
                        time_t Time;
                        FILE *fSlmIni;
                        UCHAR szProject[MAX_PATH];
                        UCHAR szSlmServer[MAX_PATH];
                        UCHAR szEnlistment[MAX_PATH];
                        UCHAR szSlmDir[MAX_PATH];
                        UCHAR *szTime="";
                        // Get some other interesting info.
                        fSlmIni = fopen("slm.ini", "r");
                        if (fSlmIni) {
                            fgets(szProject, sizeof(szProject), fSlmIni);
                            fgets(szSlmServer, sizeof(szSlmServer), fSlmIni);
                            fgets(szEnlistment, sizeof(szEnlistment), fSlmIni);
                            fgets(szSlmDir, sizeof(szSlmDir), fSlmIni);
                            // Get rid of the trailing newlines
                            szProject[strlen(szProject)-1] = '\0';
                            szSlmServer[strlen(szSlmServer)-1] = '\0';
                            szSlmDir[strlen(szSlmDir)-1] = '\0';
                            fclose(fSlmIni);
                        } else {
                            szSlmServer[0] = '\0';
                            szProject[0] = '\0';
                            szSlmDir[0] = '\0';
                        }
                        Time = time(NULL);
                        szTime = ctime(&Time);
                        sprintf(szExtraInfo,
                                "%s\t%s\t%s\t%s",
                                szSlmServer,
                                szProject,
                                szSlmDir,
                                szTime);
                    }
                }
            }

            if (PlaceRootName == NULL) {
                fprintf(stderr,"BINPLACE : fatal error BNP0000: Place Root not defined - exiting.\n");
                exit(BINPLACE_ERR);
            }

            // If the SymbolFilePath has not been set, make a default value.
            if (!SymbolFilePath) {
                strcpy(DefaultSymbolFilePath, PlaceRootName);
                strcat(DefaultSymbolFilePath, "\\symbols");
                SymbolFilePath = DefaultSymbolFilePath;
            }

            if ( !PlaceTheFile() ) {
                if (fDontExit) {
                    fprintf(stderr,"BINPLACE : error BNP0000: Unable to place file %s.\n",CurrentImageName);
                } else {
                    fprintf(stderr,"BINPLACE : fatal error BNP0000: Unable to place file %s - exiting.\n",CurrentImageName);
                    exit(BINPLACE_ERR);
                }
            } else {
                if ( LogFile ) {
                    len = fprintf(LogFile,"%s\t%s",gFullFileName,szExtraInfo);
                    if ( len < 0 ) {
                        fprintf(stderr,"BINPLACE : error BNP0000: write to log file %s failed %d\n", LogFileName, GetLastError());
                    }
                }
            }
        }
    }
    exit(BINPLACE_OK);
    return BINPLACE_OK;
}

BOOL
PlaceTheFile()
{
    CHAR FullFileName[MAX_PATH+1];
    LPSTR PlaceFileNewName;
    LPSTR FilePart;
    LPSTR Separator;
    LPSTR PlaceFileClassPart;
    DWORD cb;
    int cfield;
    PCLASS_TABLE ClassTablePointer;
    BOOLEAN ClassMatch;
    BOOL    fCopyResult;
    LPSTR Extension;
    BOOL PutInDump;
    BOOL PutInDebug = FALSE;
    BOOL PutInLcDir = FALSE;

    cb = GetFullPathName(CurrentImageName,MAX_PATH+1,FullFileName,&FilePart);

    if (!cb || cb > MAX_PATH+1) {
        fprintf(stderr,"BINPLACE : fatal error BNP0000: GetFullPathName failed %d\n",GetLastError());
        return FALSE;
    }

    if (LogFile) {
        strcpy(gFullFileName,FullFileName);
    }

    if (fVerbose) {
        fprintf(stdout,"BINPLACE : warning BNP0000: Looking at file %s\n",FilePart);
    }

    Extension = strrchr(FilePart,'.');
    if (Extension) {
        if (!_stricmp(Extension,".DBG")) {
            PutInDebug = TRUE;
        }
        else if (!_stricmp(Extension,".LC")) {
            PutInLcDir = TRUE;
        }
    }

    if (!DumpOverride) {

        if (fSetupMode && !fSetupModeScriptFile) {
            PPLACE_FILE_RECORD PfRec;

            PfRec = LookupPlaceFileRecord(FilePart);

            if ( PfRec ) {
                strncpy(PlaceFileEntry,PfRec->FileNameEntry, sizeof(PlaceFileEntry));
                strncpy(PlaceFileClass,PfRec->FileClass, sizeof(PlaceFileClass));
                PlaceFileNewName = NULL;
                goto fastfound;
            }
        }
        fseek(PlaceFile,0,SEEK_SET);
        while (fgets(PlaceFileDir,sizeof(PlaceFileDir),PlaceFile)) {

            PlaceFileEntry[0] = '\0';
            PlaceFileClass[0] = '\0';

            cfield = sscanf(
                           PlaceFileDir,
//                           "%s %[A-Za-z0-9.,_!@#\\$+=%^&()~ -]s",
                           "%s %s",
                           PlaceFileEntry,
                           PlaceFileClass
                           );

            if (cfield <= 0 || PlaceFileEntry[0] == ';') {
                continue;
            }

            if (PlaceFileNewName = strchr(PlaceFileEntry,'!')) {
                *PlaceFileNewName++ = '\0';
            }

            if (!_stricmp(FilePart,PlaceFileEntry)) {
                fastfound:
                //
                // now that we have the file and class, search the
                // class tables for the directory.
                //
                Separator = PlaceFileClass - 1;
                while (Separator) {

                    PlaceFileClassPart = Separator+1;
                    Separator = strchr(PlaceFileClassPart,':');
                    if (Separator) {
                        *Separator = '\0';
                    }

                    //
                    // If the class is "retail" and we're in Setup mode,
                    // handle this file specially. Setup mode is used to
                    // incrementally binplace files into an existing installation.
                    //
                    SetupFilePath[0] = '\0';
                    if (fSetupMode && !_stricmp(PlaceFileClassPart,"retail")) {
                        if (SetupModeRetailFile(FullFileName,FilePart,&PutInDump)) {
                            //
                            // No error. Either the file was handled or we need to
                            // put it in the dump directory.
                            //
                            if (PutInDump) {
                                fCopyResult = CopyTheFile(
                                                         FullFileName,
                                                         FilePart,
                                                         (DumpOverride ? DumpOverride : DEFAULT_DUMP),
                                                         NULL
                                                         );
                            } else {
                                fCopyResult = TRUE;
                            }
                        } else {
                            //
                            // Got an error, return error status.
                            //
                            fCopyResult = FALSE;
                        }

                        if (!fSetupModeScriptFile) {
                            return(fCopyResult);
                        }
                    }

                    PlaceFileDir[0]='\0';
                    ClassMatch = FALSE;
                    ClassTablePointer = &CommonClassTable[0];
                    while (ClassTablePointer->ClassName) {
                        if (!_stricmp(ClassTablePointer->ClassName,PlaceFileClassPart)) {
                            strcpy(PlaceFileDir,ClassTablePointer->ClassLocation);
                            ClassMatch = TRUE;

                            //
                            // If the class is a driver and a UP driver is
                            // specified, then put the driver in the UP
                            // subdirectory.
                            //
                            // Do the same for retail. We assume the -u switch is passed
                            // only when actually needed.
                            //
                            if (fUpDriver
                                && (   !_stricmp(PlaceFileClass,"drivers")
                                       || !_stricmp(PlaceFileClass,"retail"))) {
                                strcat(PlaceFileDir,"\\up");
                            }
                            break;
                        }

                        ClassTablePointer++;
                    }

                    if (!ClassMatch) {
                        //
                        // Search Specific classes
                        //
                        // We need to support cross compiling here.
                        LPTSTR platform;

#if   defined(_AXP64_)
                        ClassTablePointer = &Axp64SpecificClassTable[0];
#elif defined(_ALPHA_)
                        ClassTablePointer = &AlphaSpecificClassTable[0];
                        if ((platform = getenv("AXP64")) != NULL) {
                            ClassTablePointer = &Axp64SpecificClassTable[0];
                        }
#elif defined(_IA64_)
                        ClassTablePointer = &ia64SpecificClassTable[0];
#else // defined(_X86_)
                        ClassTablePointer = &i386SpecificClassTable[0];
                        if ((platform = getenv("IA64")) != NULL) {
                            ClassTablePointer = &ia64SpecificClassTable[0];
                        }
#endif
                        while (ClassTablePointer->ClassName) {

                            if (!_stricmp(ClassTablePointer->ClassName,PlaceFileClassPart)) {
                                strcpy(PlaceFileDir,ClassTablePointer->ClassLocation);
                                ClassMatch = TRUE;
                                break;
                            }

                            ClassTablePointer++;
                        }
                    }

                    if (!ClassMatch) {

                        char * asterisk;

                        //
                        // Still not found in class table. Use the class as the
                        // directory
                        //

                        if ( fVerbose ) {
                            fprintf(stderr,"BINPLACE : warning BNP0000: Class %s Not found in Class Tables\n",PlaceFileClassPart);
                        }
                        if ( asterisk = strchr( PlaceFileClassPart, '*')) {
                            //
                            // Expand * to platform
                            //
                            LPTSTR platform;
                            ULONG PlatformSize;
                            LPTSTR PlatformPath;

#if   defined(_AXP64_)
                            PlatformSize = 5;
                            PlatformPath = TEXT("axp64");
#elif defined(_ALPHA_)
                            PlatformSize = 5;
                            PlatformPath = TEXT("alpha");
                            if ((platform = getenv("AXP64")) != NULL) {
                                PlatformPath = TEXT("axp64");
                            }
#elif defined(_IA64_)
                            PlatformSize = 4;
                            PlatformPath = TEXT("ia64");
#else // defined(_X86_)
                            PlatformSize = 4;
                            PlatformPath = TEXT("i386");
                            if ((platform = getenv("IA64")) != NULL) {
                                PlatformPath = TEXT("ia64");
                            }
#endif

                            strncpy(PlaceFileDir,PlaceFileClassPart, (int)(asterisk - PlaceFileClassPart));
                            strcpy(PlaceFileDir + (asterisk - PlaceFileClassPart), PlatformPath);
                            strcpy(PlaceFileDir + (asterisk - PlaceFileClassPart) + PlatformSize, asterisk + 1);

                        } else {
                            strcpy(PlaceFileDir,PlaceFileClassPart);
                        }
                    }

                    if (SetupFilePath[0] == '\0') {
                        lstrcpy(SetupFilePath, PlaceFileDir);
                        lstrcat(SetupFilePath, "\\");
                        lstrcat(SetupFilePath, FilePart);
                    }

                    if (NormalPlaceSubdir) {
                        strcat(PlaceFileDir,"\\");
                        strcat(PlaceFileDir,NormalPlaceSubdir);
                    }

                    fCopyResult = CopyTheFile(FullFileName,FilePart,PlaceFileDir,PlaceFileNewName);
                    if (!fCopyResult) {
                        break;
                    }
                }

                return(fCopyResult);
            }
        }
    }

    if (fMakeErrorOnDumpCopy) {
        fprintf(stderr, "BINPLACE : error BNP0000: File '%s' is not listed in '%s'. Copying to dump.\n", FullFileName, PlaceFileName);
    }

    return CopyTheFile(
               FullFileName,
               FilePart,
               PutInDebug ? "Symbols" : (PutInLcDir ? BinplaceLcDir : (DumpOverride ? DumpOverride : DEFAULT_DUMP)),
               NULL
               );

}

BOOL
CopyTheFile(
           LPSTR SourceFileName,
           LPSTR SourceFilePart,
           LPSTR DestinationSubdir,
           LPSTR DestinationFilePart
           )
{
    CHAR DestinationFile[MAX_PATH+1];
    CHAR TmpDestinationFile[MAX_PATH];
    CHAR TmpDestinationDir[MAX_PATH];
    CHAR DestinationLcFile[MAX_PATH+1];
    char Drive[_MAX_DRIVE];
    char Dir[_MAX_DIR];
    char Ext[_MAX_EXT];
    char Name[_MAX_FNAME];
    char TmpName[_MAX_FNAME];
    char TmpPath[_MAX_PATH];
    char FileSystemType[8];
    char DriveRoot[4];
    CHAR *TmpSymbolFilePath;
    DWORD dwFileSystemFlags;
    DWORD dwMaxCompLength;
    CHAR ErrMsg[MAX_SYM_ERR];
    BOOL fBinplaceLc;

    if ( !PlaceRootName ) {
        fprintf(stderr,"BINPLACE : warning BNP0000: PlaceRoot is not specified\n");
        return FALSE;
    }

    //
    // We also neuter SourceIsNewer on FAT partitions since they have a 2 second
    // file time granularity
    //
    _splitpath(SourceFileName, DriveRoot, Dir, NULL, NULL);
    lstrcat(DriveRoot, "\\");
    GetVolumeInformation(DriveRoot, NULL, 0, NULL, &dwMaxCompLength, &dwFileSystemFlags, FileSystemType, 7);
    if (lstrcmpi(FileSystemType, "FAT") == 0 || lstrcmpi(FileSystemType, "FAT32") == 0)
        fPatheticOS = TRUE;

    strcpy(DestinationFile,PlaceRootName);
    strcat(DestinationFile,"\\");
    strcat(DestinationFile,DestinationSubdir);
    strcat(DestinationFile,"\\");

    strcpy (TmpDestinationDir, DestinationFile);


    if (!MakeSureDirectoryPathExists(DestinationFile)) {
        fprintf(stderr, "BINPLACE : error BNP0000: Unable to create directory path '%s' (%u)\n",
                DestinationFile, GetLastError()
               );
    }

    if (DestinationFilePart) {
        strcat(DestinationFile,DestinationFilePart);
    } else {
        strcat(DestinationFile,SourceFilePart);
    }

    if (!fSetupMode && (fVerbose || fTestMode)) {
        fprintf(stdout,"BINPLACE : warning BNP0000: place %s in %s\n",SourceFileName,DestinationFile);
    }

    if (!fSetupMode) {
        BOOL fRetail = (*DestinationSubdir == '.') && (*(DestinationSubdir+1) == '\0');
        if (SourceIsNewer(SourceFileName,DestinationFile)) {
            fprintf(stdout, "binplace %s\n", SourceFileName);
            if (!VerifyFinalImage(SourceFileName, fRetail, &fBinplaceLc))
                return FALSE;

            // Verify Symbols
            if (fRetail && fSymChecking && !fSignCode) {
                _splitpath(SourceFileName,Drive, Dir, Name, Ext );
                strcpy(TmpName,Name);
                strcat(TmpName,Ext);
                strcpy(TmpPath,Drive);
                strcat(TmpPath,Dir);
                if (!CheckSymbols(ErrMsg, TmpPath,SourceFileName, NULL,
                                  IGNORE_IF_SPLIT,FALSE) ) {
                    if ( !InExcludeList(TmpName,ExcludeList) ) {
                        fprintf(stderr,"BINPLACE : error BNP0000: %s",ErrMsg);
                        return FALSE;
                    } else {
                        fprintf(stdout,"BINPLACE : warning BNP0000: %s",ErrMsg);
                    }
                }
            }
        }
    }

    if (!fTestMode) {
        //
        // In Setup mode, copy the file only if it's newer than
        // the one that's already there.
        //
        if (!fSetupModeScriptFile) {
            if (SourceIsNewer(SourceFileName,DestinationFile)) {
                if (fVerbose) {
                    fprintf(stdout,"BINPLACE : warning BNP0000: copy %s to %s\n",SourceFileName,DestinationFile);
                }
            } else {
                return(TRUE);
            }
        }

        SetFileAttributes(DestinationFile,FILE_ATTRIBUTE_NORMAL);

        if (fSetupModeScriptFile) {
            fprintf( CommandScriptFile, "%s %s\n", DestinationFile, SetupFilePath );
        }

        if (!fIgnoreHardLinks && fHardLinks) {
            if ((*pCreateHardLinkA)(SourceFileName, DestinationFile, NULL)) {
                if (!fKeepAttributes)
                    SetFileAttributes(DestinationFile,FILE_ATTRIBUTE_NORMAL);
                return(TRUE);
            }
        }

        if ( !CopyFile(SourceFileName,DestinationFile, FALSE)) {
            fprintf(stderr,"BINPLACE : warning BNP0000: CopyFile(%s,%s) failed %d\n",SourceFileName,DestinationFile,GetLastError());

            if (!fLiveSystem) {
                return FALSE;
            }

            //  If CopyFile failed and we are instructed to do this over a live
            //  system, attempt to do a safe copy

            if (GetTempFileName (TmpDestinationDir, "bin", 0, TmpDestinationFile) == 0) {
                fprintf (stderr, "BINPLACE : error BNP0000: GetTempFileName (%s, %s) failed - %d\n",
                         DestinationSubdir, TmpDestinationFile, GetLastError ());
                return FALSE;
            }

            if (fVerbose) {
                fprintf (stdout, "BINPLACE : warning BNP0000: temp file name is %s\n", TmpDestinationFile);
            }

            //  rename target file to temp file
            if (!MoveFileEx (DestinationFile, TmpDestinationFile, MOVEFILE_REPLACE_EXISTING)) {
                //  Move failed, get rid of temp file
                ULONG error = GetLastError ();
                if (fVerbose) {
                    fprintf (stdout, "BINPLACE : error BNP0000: MoveFileEx (%s, %s) failed %d",
                             DestinationFile, TmpDestinationFile, error);
                }
                DeleteFile (TmpDestinationFile);
                SetLastError (error);
                return FALSE;
            }

            //  copy again
            if (!CopyFile (SourceFileName, DestinationFile, TRUE)) {
                //  Copy failed.  Delete the destination (perhaps due to out of space
                //  and replace original destination)
                ULONG error = GetLastError ();
                if (fVerbose) {
                    fprintf (stdout, "BINPLACE : error BNP0000: CopyFile (%s, %s) failed %d",
                             SourceFileName, DestinationFile, error);
                }
                DeleteFile (DestinationFile);
                MoveFile (TmpDestinationFile, DestinationFile);
                SetLastError (error);
                return FALSE;
            }

            //  mark temp for delete
            if (!MoveFileEx (TmpDestinationFile, NULL, MOVEFILE_DELAY_UNTIL_REBOOT)) {
                //  Could not make old file for deletion.  Delete destination
                //  and replace original destination)
                ULONG error = GetLastError ();
                if (fVerbose) {
                    fprintf (stdout, "BINPLACE : error BNP0000: MoveFileEx (%s, NULL) failed %d",
                             TmpDestinationFile, error);
                }
                DeleteFile (DestinationFile);
                MoveFile (TmpDestinationFile, DestinationFile);
                return FALSE;
            }
        }
        if (fSetupMode && !fSetupModeScriptFile) {
            fprintf(stdout,"%s ==> %s\n",SourceFileName,DestinationFile);
        }

        if (!fKeepAttributes)
            SetFileAttributes(DestinationFile,FILE_ATTRIBUTE_NORMAL);

        if (!fNoClassInSymbolsDir) {
            strcpy(TmpDestinationDir, SymbolFilePath);
            if ((DestinationSubdir[0] == '.') && (DestinationSubdir[1] == '\0')) {
                strcat(TmpDestinationDir, "\\retail");
            } else {
                char * pSubdir;
                char * pTmp;
                strcat(TmpDestinationDir, "\\");

                pSubdir = DestinationSubdir;
		if (pSubdir[0] == '.' && pSubdir[1] == '\\')
		{
		    pSubdir += 2;
		}

                // Put the root dir only on the path
                pTmp = strchr(pSubdir, '\\');
                if (pTmp) {
                    strcpy(TmpDestinationFile, pSubdir);
                    TmpDestinationFile[pTmp - pSubdir] = '\0';
                    strcat(TmpDestinationDir, TmpDestinationFile);
                } else {
                    strcat(TmpDestinationDir, pSubdir);
                }
            }
            TmpSymbolFilePath = TmpDestinationDir;
        } else {
            TmpSymbolFilePath = SymbolFilePath;
        }

        if (fSplitSymbols && !fUpDriver) {
            _splitpath(SourceFileName, Drive, Dir, NULL, Ext);
            _makepath(DebugFilePath, Drive, Dir, NULL, NULL);
            SplitFlags |= SPLITSYM_SYMBOLPATH_IS_SRC;
            if (SplitSymbols( DestinationFile, TmpSymbolFilePath, (PCHAR) DebugFilePath, SplitFlags )) {
                if (fVerbose)
                    fprintf( stdout, "BINPLACE : warning BNP0000: Symbols stripped from %s into %s\n", DestinationFile, DebugFilePath );

                if ((SplitFlags & SPLITSYM_REMOVE_PRIVATE) && (PrivateSymbolFilePath != NULL)) {
                    CHAR Dir1[_MAX_PATH];
                    CHAR Dir2[_MAX_PATH];
                    _splitpath(DebugFilePath, Drive, Dir, NULL, NULL);
                    _makepath(Dir1, Drive, Dir, NULL, NULL);
                    strcpy(Dir2, PrivateSymbolFilePath);
                    strcat(Dir2, Dir1+strlen(SymbolFilePath));
                    MakeSureDirectoryPathExists(Dir2);
                    BinplaceCopyPdb(Dir2, SourceFileName, TRUE, FALSE);
                }
            } else {
                if (fVerbose)
                    fprintf( stdout, "BINPLACE : warning BNP0000: No symbols to strip from %s\n", DestinationFile );
                strcpy(DebugFilePath, TmpSymbolFilePath);
                strcat(DebugFilePath, "\\");
                strcat(DebugFilePath, &Ext[1]);
                strcat(DebugFilePath, "\\");
                BinplaceCopyPdb(DebugFilePath, SourceFileName, TRUE, SplitFlags & SPLITSYM_REMOVE_PRIVATE);
            }

            if ((SplitFlags & SPLITSYM_REMOVE_PRIVATE) && (PrivateSymbolFilePath != NULL)) {
                CHAR Dir1[_MAX_PATH];
                CHAR Dir2[_MAX_PATH];
                _splitpath(DebugFilePath, Drive, Dir, NULL, NULL);
                _makepath(Dir1, Drive, Dir, NULL, NULL);
                strcpy(Dir2, PrivateSymbolFilePath);
                strcat(Dir2, Dir1+strlen(SymbolFilePath));
                MakeSureDirectoryPathExists(Dir2);
                BinplaceCopyPdb(Dir2, SourceFileName, TRUE, FALSE);
            }

        } else {
            BinplaceCopyPdb(DestinationFile, SourceFileName, FALSE, fSplitSymbols ? (SplitFlags & SPLITSYM_REMOVE_PRIVATE) : FALSE);
        }

        if (fPlaceWin95SymFile) {
            char DestSymPath[_MAX_PATH];
            char SrcSymPath[_MAX_PATH];

            _splitpath(CurrentImageName, Drive, Dir, Name, Ext);
            _makepath(SrcSymPath, Drive, Dir, Name, ".sym");

            if (!_access(SrcSymPath, 0)) {
                if (fSplitSymbols) {
                    strcpy(DestSymPath, TmpSymbolFilePath);
                    strcat(DestSymPath, "\\");
                    strcat(DestSymPath, Ext[0] == '.' ? &Ext[1] : Ext);
                    strcat(DestSymPath, "\\");
                    strcat(DestSymPath, Name);
                    strcat(DestSymPath, ".sym");
                } else {
                    _splitpath(DestinationFile, Drive, Dir, NULL, NULL);
                    _makepath(DestSymPath, Drive, Dir, Name, ".sym");
                }

                SetFileAttributes(DestSymPath, FILE_ATTRIBUTE_NORMAL);

                if (SourceIsNewer(SrcSymPath, SourceFileName)) {
                    // Only binplace the .sym file if it was built AFTER the image itself.
                    if (!CopyFile(SrcSymPath, DestSymPath, FALSE)) {
                        fprintf(stderr,"BINPLACE : warning BNP0000: CopyFile(%s,%s) failed %d\n", SrcSymPath, DestSymPath ,GetLastError());
                    }
                }

                if (!fKeepAttributes)
                    SetFileAttributes(DestinationFile,FILE_ATTRIBUTE_NORMAL);
            } else {
                if (fVerbose) {
                    fprintf( stdout, "BINPLACE : warning BNP0000: Unable to locate \"%s\" for \"%s\"\n", SrcSymPath, CurrentImageName );
                }
            }

        }

        if (fDigitalSign) {
            SignWithIDWKey( DestinationFile );
        }

        if (!fSetupMode && fBinplaceLc) {
            strcpy(DestinationLcFile,PlaceRootName);
            strcat(DestinationLcFile,"\\");
            strcat(DestinationLcFile,BinplaceLcDir);
            strcat(DestinationLcFile,"\\");
            strcat(DestinationLcFile,DestinationSubdir);
            strcat(DestinationLcFile,"\\");

            if (!MakeSureDirectoryPathExists(DestinationLcFile)) {
                fprintf(stderr, "BINPLACE : error BNP0000: Unable to create directory path '%s' (%u)\n",
                        DestinationLcFile, GetLastError()
                       );
            }

            strcat(DestinationLcFile, LcFilePart);

            if (!CopyFile(LcFullFileName, DestinationLcFile, FALSE)) {
               fprintf(stderr,"BINPLACE : warning BNP0000: CopyFile(%s,%s) failed %d\n",
                       LcFullFileName,DestinationLcFile,GetLastError());
            }
        }

    } else {
        if (fSetupMode) {
            if (SourceIsNewer(SourceFileName,DestinationFile)) {
                if (fVerbose) {
                    fprintf(stdout,"BINPLACE : warning BNP0000: copy %s to %s\n",SourceFileName,DestinationFile);
                }
            } else {
                return(TRUE);
            }
        }

        if ( fSetupMode ) {
            fprintf(stdout,"%s ==> %s\n",SourceFileName,DestinationFile);
        }
    }

    return TRUE;
}


BOOL VerifyLc(
             PCHAR FileName,
             BOOL  fRetail
             )
{
    HRESULT hr = (*pVerifyLocConstraintA)(FileName, LcFullFileName);

    if (FAILED(hr)) {
        if (hr == HRESULT_FROM_WIN32(ERROR_NO_MATCH)) {
            fprintf(stderr,
                "BINPLACE : %s BNP0000: resource conflicts with localization constraint \"%s\"\n",
                fRetail ? "error" : "warning",
                FileName);
        }
        else {
            fprintf(stderr,
                "BINPLACE : %s BNP0000: VerifyLc %s failed 0x%lX\n",
                fRetail ? "error" : "warning", FileName, hr);
        }
        return FALSE;
    }

    return TRUE;
}


typedef DWORD (WINAPI *PFNGVS)(LPSTR, LPDWORD);

BOOL
VerifyFinalImage(
                IN  PCHAR FileName,
                IN  BOOL  fRetail,
                OUT PBOOL BinplaceLc
                )
{
    HINSTANCE hVersion;
    PFNGVS pfnGetFileVersionInfoSize;
    DWORD dwSize;
    DWORD dwReturn;
    BOOL  fRC = TRUE;

    *BinplaceLc = FALSE;

    if (fVerifyLc) {
        if (!VerifyLc(FileName, fRetail)) {
            fRC = fRetail ? FALSE : TRUE;
            goto End1;
        }
        *BinplaceLc = TRUE;
    }

    if (fWarnOnMissingVersionResource)
    {
        hVersion = LoadLibraryA("VERSION.DLL");
        if (hVersion == NULL) {
            goto End1;
        }

        pfnGetFileVersionInfoSize = (PFNGVS) GetProcAddress(hVersion, "GetFileVersionInfoSizeA");
        if (pfnGetFileVersionInfoSize == NULL) {
            goto End2;
        }

        if ((dwReturn = pfnGetFileVersionInfoSize(FileName, &dwSize)) == 0) {

            // See if this is even a binary
                LOADED_IMAGE LoadedImage;
                if (MapAndLoad(FileName, NULL, &LoadedImage, FALSE, TRUE) == FALSE) {
                    // Not a binary.  See if it's one of the other types we care about (like typelibs)

                    CHAR szExt[_MAX_EXT];

                    _splitpath(FileName, NULL, NULL, NULL, szExt);

                    if (_stricmp(szExt, ".tlb")) {
                        goto End2;
                    }
                } else if ((LoadedImage.FileHeader->FileHeader.Machine != IMAGE_FILE_MACHINE_I386) &&
                    (LoadedImage.FileHeader->FileHeader.Machine != IMAGE_FILE_MACHINE_ALPHA)) {
                    goto End2;
                }

                fRC = fRetail ? FALSE : TRUE;
                fprintf(stderr,
                        "BINPLACE : %s BNP0000: no version resource detected for \"%s\"\n",
                        fRetail ? "error" : "warning",
                        FileName);

                UnMapAndLoad(&LoadedImage);
        }

End2:
        FreeLibrary(hVersion);
    }
    
End1:
    return fRC;
}


BOOL
SourceIsNewer(
             IN LPSTR SourceFile,
             IN LPSTR TargetFile
             )
{
    BOOL Newer;
    WIN32_FIND_DATA TargetInfo;
    WIN32_FIND_DATA SourceInfo;

    //
    // If force placement (-f option) was specified, just return TRUE
    // If the target file doesn't exist, then the source is newer.
    // If the source file doesn't exist, just return TRUE and hope
    // the caller will catch it.
    if ((fForcePlace == FALSE) && (FileExists(TargetFile,&TargetInfo) && FileExists(SourceFile,&SourceInfo))) {

        Newer = (fLiveSystem || !fPatheticOS)
                ? (CompareFileTime(&SourceInfo.ftLastWriteTime,&TargetInfo.ftLastWriteTime) > 0)
                : (CompareFileTime(&SourceInfo.ftLastWriteTime,&TargetInfo.ftLastWriteTime) >= 0);

    } else {

        Newer = TRUE;
    }

    return(Newer);
}


BOOL
SetupModeRetailFile(
                   IN  LPSTR FullFileName,
                   IN  LPSTR FileNamePart,
                   OUT PBOOL PutInDump
                   )
{
    BOOL FoundInTree;
    INFCONTEXT InfContext;
    DWORD DontCare;
    INT IntVal;
    CHAR DirSpec[24];
    CHAR Directory[MAX_PATH];
    CHAR Rename[MAX_PATH];
    LPSTR p;

    //
    // Find and update all instances of the file in the target tree.
    //
    *PutInDump = FALSE;
    FoundInTree = FALSE;
    if (!SearchOneDirectory(PlaceRootName,FileNamePart,FullFileName,FileNamePart,&FoundInTree)) {
        return(FALSE);
    }

    if (!FoundInTree) {
        //
        // OK, now things get tricky. Load master layout inf if
        // not already loaded.
        //
        if (!LayoutInf) {
            if (LayoutInfName) {
                //
                // Use GetFullPathName(). Otherwise a name without a dir spec
                // will be assumed to be in %sysroot%\inf, which is probably not
                // what people would expect.
                //
                GetFullPathName(LayoutInfName,MAX_PATH,Directory,&p);
                LayoutInf = (*pSetupOpenInfFileA)(Directory,NULL,INF_STYLE_WIN4,NULL);
            } else {
                LayoutInf = (*pSetupOpenMasterInf)();
            }
            if (LayoutInf == INVALID_HANDLE_VALUE) {

                LayoutInf = NULL;

                fprintf(
                       stderr,
                       "BINPLACE : error BNP0000: Unable to load %s\n",
                       LayoutInfName ? LayoutInfName : "%%sysroot%%\\inf\\layout.inf"
                       );

                return(FALSE);
            }
        }

        //
        // Look up the file in the master inf.
        //
        if (!(*pSetupFindFirstLineA)(LayoutInf,szSourceDisksFiles,FileNamePart,&InfContext)) {

            LPTSTR platform;
            LPCTSTR szSourceDisksFPlat;

#if   defined(_AXP64_)

            szSourceDisksFPlat = &szSourceDisksAxp64[0];

#elif defined(_ALPHA_)

            szSourceDisksFPlat = &szSourceDisksAlpha[0];
            if ((platform = getenv("AXP64")) != NULL) {
                szSourceDisksFPlat = &szSourceDisksAxp64[0];
            }

#elif defined(_IA64_)

            szSourceDisksFPlat = &szSourceDisksIA64[0];

#else // defined(_X86_)

            szSourceDisksFPlat = &szSourceDisksX86[0];
            if ((platform = getenv("IA64")) != NULL) {
                szSourceDisksFPlat = &szSourceDisksIA64[0];
            }
#endif

            if (!(*pSetupFindFirstLineA)(LayoutInf,szSourceDisksFPlat,FileNamePart,&InfContext)) {

                if ( fVerbose ) {
                    fprintf(stderr,"BINPLACE : warning BNP0000: warning: unknown retail file %s\n",FileNamePart);
                }
                *PutInDump = TRUE;
                return(TRUE);
            }
        }

        //
        // See if the file gets renamed in the target tree.
        // If so, try to find the renamed version in the target.
        //
        if ((*pSetupGetStringFieldA)(&InfContext,11,Rename,MAX_PATH,&DontCare)
            && lstrcmpi(Rename,FileNamePart)) {
            FoundInTree = FALSE;
            if (!SearchOneDirectory(PlaceRootName,Rename,FullFileName,FileNamePart,&FoundInTree)) {
                return(FALSE);
            }

            //
            // If we found the renamed file in the target tree, we're done.
            //
            if (FoundInTree) {
                return(TRUE);
            }
        } else {
            //
            // Assume name in target is same as name in source.
            //
            strcpy(Rename,FileNamePart);
        }

        //
        // We couldn't find the file in the target tree.
        // The file might be new. Check the copy disposition for
        // non-upgrades -- if the file is marked "copy always" then we want
        // to copy it. Otherwise ignore the file. This way someone who
        // uses this tool to 'upgrade' a build doesn't get a pile of files
        // they don't need placed into their nt tree.
        //
        // This behavior is overrideable by using -!! instead of -!.
        //
        if (!fSetupModeAllFiles && (!(*pSetupGetIntField)(&InfContext,10,&IntVal) || IntVal)) {
            //
            // File is not marked "copy always" so ignore it, assuming it's
            // configuration-specific and the user doesn't need it.
            //
            return(TRUE);
        }

        //
        // File needs to be copied into the target tree.
        // Get the directory spec.
        //
        DirSpec[0] = 0;
        (*pSetupGetStringFieldA)(&InfContext,8,DirSpec,sizeof(DirSpec),&DontCare);

        if (!(*pSetupFindFirstLineA)(LayoutInf,"WinntDirectories",DirSpec,&InfContext)
            || !(*pSetupGetStringFieldA)(&InfContext,1,Directory,MAX_PATH,&DontCare)) {
            if (strlen(DirSpec)) {
                fprintf(stderr,"BINPLACE : error BNP0000: unknown directory spec %s in layout.inf for file %s\n",DirSpec,FileNamePart);
                return(FALSE);
            } else {
                return(TRUE);
            }
        }

        //
        // If the spec begins with a slash, then for root dir, replace with .
        // otherwise, skip over leading slash in the non-root case.
        //
        if ((Directory[0] == '\\')) {
            if (!Directory[1]) {
                Directory[0] = '.';
            } else {
                lstrcpy(Directory, Directory+1);
            }
        }

        if (fSetupModeScriptFile) {
            lstrcpy(SetupFilePath, Directory);
            lstrcat(SetupFilePath, "\\");
            lstrcat(SetupFilePath, Rename);
            return FALSE;
        }

        //
        // Got what we need -- copy the file.
        //
        return CopyTheFile(
                          FullFileName,
                          FileNamePart,
                          Directory,
                          Rename
                          );
    }

    return(TRUE);
}


BOOL
BinplaceCopyPdb (
                LPSTR DestinationFile,
                LPSTR SourceFileName,
                BOOL CopyFromSourceOnly,
                BOOL StripPrivate
                )
{
    LOADED_IMAGE LoadedImage;
    DWORD DirCnt;
    PIMAGE_DEBUG_DIRECTORY DebugDirs, CvDebugDir;

    if (MapAndLoad(
                   CopyFromSourceOnly ? SourceFileName : DestinationFile,
                   NULL,
                   &LoadedImage,
                   FALSE,
                   CopyFromSourceOnly ? TRUE : FALSE) == FALSE) {
        return (FALSE);
    }

    DebugDirs = (PIMAGE_DEBUG_DIRECTORY) ImageDirectoryEntryToData(
                                                                  LoadedImage.MappedAddress,
                                                                  FALSE,
                                                                  IMAGE_DIRECTORY_ENTRY_DEBUG,
                                                                  &DirCnt
                                                                  );

    if (!DebugDirectoryIsUseful(DebugDirs, DirCnt)) {
        UnMapAndLoad(&LoadedImage);
        return(FALSE);
    }

    DirCnt /= sizeof(IMAGE_DEBUG_DIRECTORY);
    CvDebugDir = NULL;

    while (DirCnt) {
        DirCnt--;
        if (DebugDirs[DirCnt].Type == IMAGE_DEBUG_TYPE_CODEVIEW) {
            CvDebugDir = &DebugDirs[DirCnt];
            break;
        }
    }

    if (!CvDebugDir) {
        // Didn't find any CV debug dir.  Bail.
        UnMapAndLoad(&LoadedImage);
        return(FALSE);
    }

    if (CvDebugDir->PointerToRawData != 0) {

        // If there's a .pdb, copy it to the same location as the referencing file.
        typedef struct NB10I {                 // NB10 debug info
            DWORD   nb10;                      // NB10
            DWORD   off;                       // offset, always 0
            DWORD   sig;
            DWORD   age;
        } NB10I;

        NB10I *pNB10Info;

        pNB10Info = (NB10I *) (CvDebugDir->PointerToRawData + (PCHAR)LoadedImage.MappedAddress);
        if (pNB10Info->nb10 == '01BN') {
            // Got a PDB.  The name immediately follows the signature.

            CHAR PdbName[_MAX_PATH];
            CHAR NewPdbName[_MAX_PATH];
            CHAR Drive[_MAX_DRIVE];
            CHAR Dir[_MAX_DIR];
            CHAR Filename[_MAX_FNAME];
            CHAR FileExt[_MAX_EXT];

            memset(PdbName, 0, sizeof(PdbName));
            memcpy(PdbName, ((PCHAR)pNB10Info) + sizeof(NB10I), CvDebugDir->SizeOfData - sizeof(NB10I));

            _splitpath(PdbName, NULL, NULL, Filename, FileExt);
            _splitpath(DestinationFile, Drive, Dir, NULL, NULL);
            _makepath(NewPdbName, Drive, Dir, Filename, FileExt);

            if (!fSetupMode && (fVerbose || fTestMode)) {
                fprintf(stdout,"BINPLACE : warning BNP0000: place %s in %s\n", PdbName, NewPdbName);
            }

            if (!MakeSureDirectoryPathExists(NewPdbName)) {
                fprintf(stderr, "BINPLACE : error BNP0000: Unable to create directory path '%s' (%u)\n",
                        NewPdbName, GetLastError());
            }

            SetFileAttributes(NewPdbName,FILE_ATTRIBUTE_NORMAL);

            if ( !CopyPdb(PdbName, NewPdbName, StripPrivate)) {
                if (!fSetupMode && (fVerbose || fTestMode)) {
                    fprintf(stderr,"BINPLACE : warning BNP0000: Unable to copy (%s,%s) %d\n", PdbName, NewPdbName, GetLastError());
                }
                // It's possible the name in the pdb isn't in the same location as it was when built.  See if we can
                //  find it in the same dir as the image...
                _splitpath(SourceFileName, Drive, Dir, NULL, NULL);
                _makepath(PdbName, Drive, Dir, Filename, FileExt);
                if (!fSetupMode && (fVerbose || fTestMode)) {
                    fprintf(stdout,"BINPLACE : warning BNP0000: place %s in %s\n", PdbName, NewPdbName);
                }

                if ( !CopyPdb(PdbName, NewPdbName, StripPrivate)) {
                    fprintf(stderr,"BINPLACE : warning BNP0000: CopyPdb(%s,%s) failed %d\n", PdbName, NewPdbName, GetLastError());
                }
            }

            if (!fKeepAttributes)
                SetFileAttributes(NewPdbName, FILE_ATTRIBUTE_NORMAL);

            if (!CopyFromSourceOnly) {
                PVOID pCertificates = ImageDirectoryEntryToData(LoadedImage.MappedAddress,
                                                          FALSE,
                                                          IMAGE_DIRECTORY_ENTRY_SECURITY,
                                                          &DirCnt
                                                          );

                if (!pCertificates && !DirCnt) {
                    // Only change the data in the image if it hasn't been signed (otherwise the sig is invalidated).
                    strcpy(((char *)pNB10Info) + sizeof(NB10I), Filename);
                    strcat(((char *)pNB10Info) + sizeof(NB10I), FileExt);
                    CvDebugDir->SizeOfData = sizeof(NB10I) + strlen(Filename) + strlen(FileExt) + 1;
                }
            }
        }
        UnMapAndLoad(&LoadedImage);
        return(TRUE);
    }

    UnMapAndLoad(&LoadedImage);
    return(FALSE);
}


BOOL
FileExists(
          IN  LPCSTR FileName,
          OUT PWIN32_FIND_DATA FindData
          )
{
    UINT OldMode;
    BOOL Found;
    HANDLE FindHandle;

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    FindHandle = FindFirstFile(FileName,FindData);
    if (FindHandle == INVALID_HANDLE_VALUE) {
        Found = FALSE;
    } else {
        FindClose(FindHandle);
        Found = TRUE;
    }

    SetErrorMode(OldMode);
    return(Found);
}


//////////////////////////////////////////////////////////////////////
//                                                                  //
//  Digital Signature Stuff                                         //
//                                                                  //
//////////////////////////////////////////////////////////////////////

LPBSAFE_PUB_KEY         PUB;
LPBSAFE_PRV_KEY         PRV;

unsigned char pubmodulus[] =
{
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x3d, 0x3a, 0x5e, 0xbd, 0x72, 0x43, 0x3e, 0xc9,
    0x4d, 0xbb, 0xc1, 0x1e, 0x4a, 0xba, 0x5f, 0xcb,
    0x3e, 0x88, 0x20, 0x87, 0xef, 0xf5, 0xc1, 0xe2,
    0xd7, 0xb7, 0x6b, 0x9a, 0xf2, 0x52, 0x45, 0x95,
    0xce, 0x63, 0x65, 0x6b, 0x58, 0x3a, 0xfe, 0xef,
    0x7c, 0xe7, 0xbf, 0xfe, 0x3d, 0xf6, 0x5c, 0x7d,
    0x6c, 0x5e, 0x06, 0x09, 0x1a, 0xf5, 0x61, 0xbb,
    0x20, 0x93, 0x09, 0x5f, 0x05, 0x6d, 0xea, 0x87,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

unsigned char prvmodulus[] =
{
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x3d, 0x3a, 0x5e, 0xbd,
    0x72, 0x43, 0x3e, 0xc9, 0x4d, 0xbb, 0xc1, 0x1e,
    0x4a, 0xba, 0x5f, 0xcb, 0x3e, 0x88, 0x20, 0x87,
    0xef, 0xf5, 0xc1, 0xe2, 0xd7, 0xb7, 0x6b, 0x9a,
    0xf2, 0x52, 0x45, 0x95, 0xce, 0x63, 0x65, 0x6b,
    0x58, 0x3a, 0xfe, 0xef, 0x7c, 0xe7, 0xbf, 0xfe,
    0x3d, 0xf6, 0x5c, 0x7d, 0x6c, 0x5e, 0x06, 0x09,
    0x1a, 0xf5, 0x61, 0xbb, 0x20, 0x93, 0x09, 0x5f,
    0x05, 0x6d, 0xea, 0x87, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x3f, 0xbd, 0x29, 0x20,
    0x57, 0xd2, 0x3b, 0xf1, 0x07, 0xfa, 0xdf, 0xc1,
    0x16, 0x31, 0xe4, 0x95, 0xea, 0xc1, 0x2a, 0x46,
    0x2b, 0xad, 0x88, 0x57, 0x55, 0xf0, 0x57, 0x58,
    0xc6, 0x6f, 0x95, 0xeb, 0x00, 0x00, 0x00, 0x00,
    0x83, 0xdd, 0x9d, 0xd0, 0x03, 0xb1, 0x5a, 0x9b,
    0x9e, 0xb4, 0x63, 0x02, 0x43, 0x3e, 0xdf, 0xb0,
    0x52, 0x83, 0x5f, 0x6a, 0x03, 0xe7, 0xd6, 0x78,
    0x45, 0x83, 0x6a, 0x5b, 0xc4, 0xcb, 0xb1, 0x93,
    0x00, 0x00, 0x00, 0x00, 0x65, 0x9d, 0x43, 0xe8,
    0x48, 0x17, 0xcd, 0x29, 0x7e, 0xb9, 0x26, 0x5c,
    0x79, 0x66, 0x58, 0x61, 0x72, 0x86, 0x6a, 0xa3,
    0x63, 0xad, 0x63, 0xb8, 0xe1, 0x80, 0x4c, 0x0f,
    0x36, 0x7d, 0xd9, 0xa6, 0x00, 0x00, 0x00, 0x00,
    0x75, 0x3f, 0xef, 0x5a, 0x01, 0x5f, 0xf6, 0x0e,
    0xd7, 0xcd, 0x59, 0x1c, 0xc6, 0xec, 0xde, 0xf3,
    0x5a, 0x03, 0x09, 0xff, 0xf5, 0x23, 0xcc, 0x90,
    0x27, 0x1d, 0xaa, 0x29, 0x60, 0xde, 0x05, 0x6e,
    0x00, 0x00, 0x00, 0x00, 0xc0, 0x17, 0x0e, 0x57,
    0xf8, 0x9e, 0xd9, 0x5c, 0xf5, 0xb9, 0x3a, 0xfc,
    0x0e, 0xe2, 0x33, 0x27, 0x59, 0x1d, 0xd0, 0x97,
    0x4a, 0xb1, 0xb1, 0x1f, 0xc3, 0x37, 0xd1, 0xd6,
    0xe6, 0x9b, 0x35, 0xab, 0x00, 0x00, 0x00, 0x00,
    0x87, 0xa7, 0x19, 0x32, 0xda, 0x11, 0x87, 0x55,
    0x58, 0x00, 0x16, 0x16, 0x25, 0x65, 0x68, 0xf8,
    0x24, 0x3e, 0xe6, 0xfa, 0xe9, 0x67, 0x49, 0x94,
    0xcf, 0x92, 0xcc, 0x33, 0x99, 0xe8, 0x08, 0x60,
    0x17, 0x9a, 0x12, 0x9f, 0x24, 0xdd, 0xb1, 0x24,
    0x99, 0xc7, 0x3a, 0xb8, 0x0a, 0x7b, 0x0d, 0xdd,
    0x35, 0x07, 0x79, 0x17, 0x0b, 0x51, 0x9b, 0xb3,
    0xc7, 0x10, 0x01, 0x13, 0xe7, 0x3f, 0xf3, 0x5f,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00
};

BOOL initkey(void)
{
    DWORD       bits;

    PUB = (LPBSAFE_PUB_KEY)pubmodulus;

    PUB->magic = RSA1;
    PUB->keylen = 0x48;
    PUB->bitlen = 0x0200;
    PUB->datalen = 0x3f;
    PUB->pubexp = 0xc0887b5b;

    PRV = (LPBSAFE_PRV_KEY)prvmodulus;
    PRV->magic = RSA2;
    PRV->keylen = 0x48;
    PRV->bitlen = 0x0200;
    PRV->datalen = 0x3f;
    PRV->pubexp = 0xc0887b5b;

    bits = PRV->bitlen;

    return TRUE;
}


BOOL
SignWithIDWKey(
              IN  LPCSTR  FileName)
{

    HANDLE  hFile;
    HANDLE  hMapping;
    PUCHAR  pMap;
    HANDLE  hSigFile;
    DWORD   Size;
    MD5_CTX HashState;
    BYTE    SigHash[ 0x48 ];
    BYTE    Signature[ 0x48 ];
    CHAR    SigFilePath[ MAX_PATH ];
    PSTR    pszDot;

    BOOL    Return = FALSE;

    if (!initkey()) {
        return( FALSE );
    }

    hFile = CreateFile( FileName, GENERIC_READ,
                        FILE_SHARE_READ, NULL,
                        OPEN_EXISTING, 0, NULL );

    if (hFile != INVALID_HANDLE_VALUE) {
        hMapping = CreateFileMapping(   hFile,
                                        NULL,
                                        PAGE_READONLY,
                                        0, 0, NULL );

        if (hMapping) {
            pMap = MapViewOfFileEx( hMapping,
                                    FILE_MAP_READ,
                                    0, 0, 0, NULL );

            if (pMap) {
                Size = GetFileSize( hFile, NULL );

                MD5Init( &HashState );

                MD5Update( &HashState, pMap, Size );

                MD5Final( &HashState );

                memset(SigHash, 0xff, 0x40);

                SigHash[0x40-1] = 0;
                SigHash[0x40-2] = 1;
                SigHash[16] = 0;

                memcpy(SigHash, HashState.digest, 16);

                //
                // Encrypt the signature data
                //

                BSafeDecPrivate(PRV, SigHash, Signature );;

                //
                // Create and store it in a .sig file
                //

                strcpy( SigFilePath, FileName );

                pszDot = strrchr( SigFilePath, '.' );

                if (!pszDot) {
                    pszDot = SigFilePath + strlen( SigFilePath );
                }

                strcpy( pszDot, ".sig");

                hSigFile = CreateFile( SigFilePath, GENERIC_WRITE,
                                       0, NULL,
                                       CREATE_ALWAYS, 0, NULL );

                if (hSigFile != INVALID_HANDLE_VALUE) {
                    WriteFile(  hSigFile,
                                Signature,
                                sizeof( Signature ),
                                &Size, NULL );

                    CloseHandle( hSigFile );

                    Return = TRUE ;

                    if (fVerbose)
                        fprintf( stdout, "BINPLACE : warning BNP0000: Signature file generated in %s\n", SigFilePath);

                } else {
                    fprintf( stderr, "BINPLACE : error BNP0000: Unable to create file %s, %d\n",
                             SigFilePath, GetLastError() );
                }

                UnmapViewOfFile( pMap );

            } else {
                fprintf(stderr, "BINPLACE : error BNP0000: unable to map view, %d\n", GetLastError());
            }

            CloseHandle( hMapping );

        } else {
            fprintf(stderr, "BINPLACE : error BNP0000: CreateFileMapping of %s failed, %d\n",
                    FileName, GetLastError() );

        }

        CloseHandle( hFile );
    } else {
        fprintf( stderr, "BINPLACE : error BNP0000: could not open %s, %d\n",
                 FileName, GetLastError() );
    }

    return( Return );
}

BOOL                            // Keep as BOOL for the future (used by rsa code)
GenRandom (ULONG huid, BYTE *pbBuffer, size_t dwLength)
{
    return( FALSE );
}

#include <copypdb.c>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\checkfix.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    checkfix.c

Abstract:

    This module recomputes the checksum for an image file.

Author:

    Steven R. Wood (stevewo) 4-May-1993

Revision History:

--*/

#include <private.h>


void Usage()
{
    fprintf( stderr, "usage: CHECKFIX [-?] [-v] [-q] image-names...\n" );
    fprintf( stderr, "              [-?] display this message\n" );
    fprintf( stderr, "              [-v] verbose output\n" );
    fprintf( stderr, "              [-q] quiet on failure\n" );
    exit( 1 );
}

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    HANDLE FileHandle;
    HANDLE MappingHandle;
    PIMAGE_NT_HEADERS NtHeaders;
    PVOID BaseAddress;
    ULONG CheckSum;
    ULONG FileLength;
    ULONG HeaderSum;
    ULONG OldCheckSum;
    LPSTR ImageName;
    BOOLEAN fVerbose = FALSE;
    BOOLEAN fQuiet = FALSE;
    LPSTR s;
    UCHAR c;

    if (argc <= 1) {
        Usage();
        }

    while (--argc) {
        s = *++argv;
        if ( *s == '-' ) {
            while (c=*++s) {
                switch (c) {
                    case 'q':
                    case 'Q':
                        fQuiet = TRUE;
                        break;

                    case 'v':
                    case 'V':
                        fVerbose=TRUE;
                        break;

                    case 'h':
                    case 'H':
                    case '?':
                        Usage();

                    default:
                        fprintf( stderr, "VERFIX: illegal option /%c\n", c );
                        Usage();
                    }
                }
            }
        else {
            ImageName = s;
            FileHandle = CreateFile( ImageName,
                                     GENERIC_READ | GENERIC_WRITE,
                                     FILE_SHARE_READ,
                                     NULL,
                                     OPEN_EXISTING,
                                     0,
                                     NULL
                                   );
            if (FileHandle == INVALID_HANDLE_VALUE) {
                if (!fQuiet) {
                    fprintf( stderr, "VERFIX: Unable to open %s (%u) - skipping\n", ImageName, GetLastError() );
                    }
                }
            else {
                }

        MappingHandle = CreateFileMapping( FileHandle,
                                           NULL,
                                           PAGE_READWRITE,
                                           0,
                                           0,
                                           NULL
                                         );
        if (MappingHandle == NULL) {
            CloseHandle( FileHandle );
            if (!fQuiet) {
                fprintf( stderr, "VERFIX: Unable to create mapping object for file %s (%u) - skipping\n", ImageName, GetLastError() );
                }
            }
        else {
            BaseAddress = MapViewOfFile( MappingHandle,
                                         FILE_MAP_READ | FILE_MAP_WRITE,
                                         0,
                                         0,
                                         0
                                       );
            CloseHandle( MappingHandle );
            if (BaseAddress == NULL) {
                CloseHandle( FileHandle );
                if (!fQuiet ) {
                    fprintf( stderr, "VERFIX: Unable to map view of file %s (%u) - skipping\n", ImageName, GetLastError() );
                    }
                }
            else {
                //
                // Get the length of the file in bytes and compute the checksum.
                //

                FileLength = GetFileSize( FileHandle, NULL );

                //
                // Obtain a pointer to the header information.
                //

                NtHeaders = ImageNtHeader( BaseAddress );
                if (NtHeaders == NULL) {
                    CloseHandle( FileHandle );
                    UnmapViewOfFile( BaseAddress );
                    if (!fQuiet) {
                        fprintf( stderr, "VERFIX: %s is not a valid image file - skipping\n", ImageName, GetLastError() );
                        }
                    }
                else {
                    //
                    // Recompute and reset the checksum of the modified file.
                    //

                    OldCheckSum = NtHeaders->OptionalHeader.CheckSum;

                    (VOID) CheckSumMappedFile( BaseAddress,
                                               FileLength,
                                               &HeaderSum,
                                               &CheckSum
                                             );

                    NtHeaders->OptionalHeader.CheckSum = CheckSum;

                    if (!FlushViewOfFile( BaseAddress, FileLength )) {
                        if (!fQuiet) {
                            fprintf( stderr,
                                     "VERFIX: Flush of %s failed (%u)\n",
                                     ImageName,
                                     GetLastError()
                                   );
                            }
                        }

                    if (NtHeaders->OptionalHeader.CheckSum != OldCheckSum) {
                        if (!TouchFileTimes( FileHandle, NULL )) {
                            if (!fQuiet) {
                                fprintf( stderr, "VERFIX: Unable to touch file %s (%u)\n", ImageName, GetLastError() );
                                }
                            }
                        else
                        if (fVerbose) {
                            printf( "%s - Old Checksum: %x", ImageName, OldCheckSum );
                            printf( "  New Checksum: %x\n", NtHeaders->OptionalHeader.CheckSum );
                            }
                        }

                    UnmapViewOfFile( BaseAddress );
                    CloseHandle( FileHandle );
                    }
                }
            }
        }
    }

    exit( 0 );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\checksum.h ===
#define CHECKSUM_OPEN_FAILURE       1
#define CHECKSUM_MAP_FAILURE        2
#define CHECKSUM_MAPVIEW_FAILURE    3

ULONG CheckSum(FILE *, PUCHAR, BOOLEAN, PULONG);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\certify.cxx ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:

    certify.cxx

Abstract:

    This is the command line tool to manipulate certificates on an executable image.

Author:

Revision History:

--*/

#define UNICODE 1
#define _UNICODE 1

#include <private.h>

#if 1
#define TEST 1
#else
#define TEST 0
#endif

void
PrintUsage(
    VOID)
{
    fputs("usage: CERTIFY [switches] image-names... \n"
          "            [-?] display this message\n"
          "            [-l] list the certificates in an image\n"
          "            [-a:<Filename>] add a certificate file to an image\n"
          "            [-r:<index>]    remove certificate <index> from an image\n"
          "            [-g:<Filename>] update any associated .DBG file\n"
          "            [-s:<Filename>] used with -r to save the removed certificate\n",
          stderr
         );
    exit(-1);
}

#if TEST
// Test routine
BOOL  fAllDataReturned;
PVOID pvDataRefTest;
DWORD FileSize;
DWORD DataRead;

BOOL
WINAPI
DigestRoutine (
    DIGEST_HANDLE   DataReference,
    PBYTE           pData,
    DWORD           dwLength
    )
{
    if (DataReference != pvDataRefTest) {
        return(FALSE);
    }

    // Attempt to read the range

    if (IsBadReadPtr(pData, dwLength)) {
        return(FALSE);
    }

    DataRead += dwLength;
    if (DataRead > FileSize) {
        return(FALSE);
    }

    return(TRUE);
}

#endif


int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    char c, *p;

    if (argc < 2) {
        PrintUsage();
    }

    while (--argc) {
        p = *++argv;
        if (*p == '/' || *p == '-') {
            while (c = *++p)
            switch (toupper( c )) {
                case '?':
                    PrintUsage();
                    break;

                case 'A':
                    c = *++p;
                    if (c != ':') {
                        PrintUsage();
                    } else {

                        // Add a certificate file to an image.
#if TEST
                        // Test code

                        WIN_CERTIFICATE wc;
                        HANDLE  Handle;
                        DWORD   Index;

                        wc.dwLength = sizeof(WIN_CERTIFICATE);
                        wc.wCertificateType = WIN_CERT_TYPE_X509;

                        if ((Handle = CreateFile(TEXT("test.exe"),
                                    GENERIC_WRITE | GENERIC_READ,
                                    0,
                                    0,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL)) == INVALID_HANDLE_VALUE)
                        {
                            fputs("Unable to open test.exe", stderr);
                            exit(1);
                        }

                        printf("ImageAddCertificate on test.exe returned: %d\n",
                                ImageAddCertificate(Handle, &wc, &Index));

                        printf("Index #: %d\n", Index);

                        CloseHandle(Handle);

                        exit(0);
#else
                    // The real code
#endif
                    }
                    break;

                case 'L':
                    // List the certificates in an image.
#if TEST
                    // Test code
                    WIN_CERTIFICATE wc;
                    HANDLE  Handle;
                    DWORD   Index;

                    if ((Handle = CreateFile(TEXT("test.exe"),
                                GENERIC_READ,
                                0,
                                0,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL)) == INVALID_HANDLE_VALUE)
                    {
                        fputs("Unable to open test.exe", stderr);
                        exit(1);
                    }

                    ImageEnumerateCertificates(Handle, CERT_SECTION_TYPE_ANY, &Index, NULL, 0);

                    printf("Enumerate lists: %d\n", Index);

                    Index--;

                    while (ImageGetCertificateHeader(Handle, Index, &wc)) {
                        printf("Index: %d\n", Index);
                        Index--;
                    }

                    CloseHandle(Handle);

                    exit(0);

#else
                    // The real code
#endif
                    break;

                case 'R':
                    c = *++p;
                    if (c != ':') {
                        PrintUsage();
                    } else {
                        // Remove a specific certificate from an image.
#if TEST
                        // Test code

                        HANDLE  Handle;

                        if ((Handle = CreateFile(TEXT("test.exe"),
                                    GENERIC_WRITE | GENERIC_READ,
                                    0,
                                    0,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL)) == INVALID_HANDLE_VALUE)
                        {
                            fputs("Unable to open test.exe", stderr);
                            exit(1);
                        }

                        printf("ImageRemoveCertificate(0) on test.exe returned: %d\n",
                            ImageRemoveCertificate(Handle, 0));
                        exit(0);
#else
                        // The real code
#endif
                    }
                    break;

                case 'G':
                    c = *++p;
                    if (c != ':') {
                        PrintUsage();
                    } else {
                        // Generate a certificate from an image.
#if TEST
                        // Test code

                        HANDLE  Handle;

                        if ((Handle = CreateFile(TEXT("test.exe"),
                                    GENERIC_READ,
                                    0,
                                    0,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL)) == INVALID_HANDLE_VALUE)
                        {
                            fputs("Unable to open test.exe", stderr);
                            exit(1);
                        }

                        FileSize = GetFileSize(Handle, NULL);
                        DataRead = 0;

                        pvDataRefTest = (PVOID) 1;
                        printf("ImageGetDigestStream debug w/o resources on test.exe returned: %s\tGetLastError(): %d\n",
                            ImageGetDigestStream(Handle,
                                                 CERT_PE_IMAGE_DIGEST_DEBUG_INFO,
                                                 DigestRoutine, pvDataRefTest) ? "TRUE" : "FALSE",
                            GetLastError());
                        printf("Message Stream Size: %d\n", DataRead);

                        DataRead = 0;
                        pvDataRefTest = (PVOID) 2;
                        printf("ImageGetDigestStream debug w/ resources test.exe returned: %s\tGetLastError(): %d\n",
                            ImageGetDigestStream(Handle,
                                                 CERT_PE_IMAGE_DIGEST_DEBUG_INFO | CERT_PE_IMAGE_DIGEST_RESOURCES,
                                                 DigestRoutine, pvDataRefTest) ? "TRUE" : "FALSE",
                            GetLastError());
                        printf("Message Stream Size: %d\n", DataRead);

                        DataRead = 0;
                        pvDataRefTest = (PVOID) 3;
                        printf("ImageGetDigestStream w/o debug w/o resources on test.exe returned: %s\tGetLastError(): %d\n",
                            ImageGetDigestStream(Handle,
                                                 0,
                                                 DigestRoutine, pvDataRefTest) ? "TRUE" : "FALSE",
                            GetLastError());
                        printf("Message Stream Size: %d\n", DataRead);

                        DataRead = 0;
                        pvDataRefTest = (PVOID) 4;
                        printf("ImageGetDigestStream w/o debug w/ resources test.exe returned: %s\tGetLastError(): %d\n",
                            ImageGetDigestStream(Handle,
                                                 CERT_PE_IMAGE_DIGEST_RESOURCES,
                                                 DigestRoutine, pvDataRefTest) ? "TRUE" : "FALSE",
                            GetLastError());
                        printf("Message Stream Size: %d\n", DataRead);

                        exit(0);

#else
                        // Real code
#endif
                    }
                    break;

                case 'S':
                    c = *++p;
                    if (c != ':') {
                        PrintUsage();
                    } else {
                        // Save the certificate in some file.
                    }
                    break;

                default:
                    fprintf( stderr, "CERTIFY: Invalid switch - /%c\n", c );
                    PrintUsage();
                    break;
            }
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\crt.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    crt.c

Abstract:

    This file implements certain crt apis that are not present in
    libcntpr.lib. This implementation is NOT multi-thread safe.

Author:

    Wesley Witt (wesw) 23-May-1994

Environment:

    User Mode

--*/

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <time.h>
#include <stdio.h>


void * __cdecl
malloc(
    size_t sz
    )
{

    return RtlAllocateHeap( RtlProcessHeap(), 0, sz );

}

void __cdecl
free(
    void * ptr
    )
{

    RtlFreeHeap( RtlProcessHeap(), 0, ptr );

}


char * __cdecl
ctime(
    const time_t *timp
    )
{
    static char    mnames[] = { "JanFebMarAprMayJunJulAugSepOctNovDec" };
    static char    buf[32];

    LARGE_INTEGER  MyTime;
    TIME_FIELDS    TimeFields;


    RtlSecondsSince1970ToTime( (ULONG)*timp, &MyTime );
    RtlSystemTimeToLocalTime( &MyTime, &MyTime );
    RtlTimeToTimeFields( &MyTime, &TimeFields );

    strncpy( buf, &mnames[(TimeFields.Month - 1) * 3], 3 );
    sprintf( &buf[3], " %02d %02d:%02d:%02d %04d",
             TimeFields.Day, TimeFields.Hour, TimeFields.Minute,
             TimeFields.Second, TimeFields.Year );

    return buf;
}


time_t __cdecl
time(
    time_t *timp
    )
{
    time_t         tm;
    LARGE_INTEGER  MyTime;


    NtQuerySystemTime( &MyTime );
    RtlTimeToSecondsSince1970( &MyTime, (PULONG)&tm );

    if (timp) {
        *timp = tm;
    }

    return tm;
}

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\dbgdump.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dbgdump.c

Abstract:

    This is the main source file for the DBGDUMP utility program.  This
    program can be used to dump out symbolic debugging information for an
    image.

Author:

    Steve Wood (stevewo) 03-May-1993

Revision History:

--*/

#include <private.h>


BOOL fVerbose;
BOOL fRemote;

UCHAR CurrentImageName[ MAX_PATH ];
UCHAR SymbolPath[ MAX_PATH ];

void
Usage( void )
{
    fputs("usage: DBGDUMP [-?] [-v] [-r] image-names...\n"
          "              [-?] display this message\n"
          "              [-v] verbose output\n"
          "              [-r symbol path] assume image names are from remote system.\n",
          stderr);
    exit( 1 );
}

void
ShowDebugInfo(
    PIMAGE_DEBUG_INFORMATION64 DebugInfo
    );

VOID
DumpSectionHeader(
    IN ULONG i,
    IN PIMAGE_SECTION_HEADER Sh
    );


int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    char c, *s;
    LPSTR FilePart;
    HANDLE FileHandle;
    PIMAGE_DEBUG_INFORMATION64 DebugInfo;

    if (argc <= 1) {
        Usage();
        }

    while (--argc) {
        s = *++argv;
        if (*s == '/' || *s == '-') {
            while (c = *++s)
                switch (toupper( c )) {
                case '?':
                    Usage();
                    break;

                case 'V':
                    fVerbose = TRUE;
                    break;

                case 'R':
                    if (--argc) {
                        strcpy( (PCHAR) SymbolPath, *++argv );
                        fRemote = TRUE;
                        }
                    else {
                        fprintf( stderr, "DBGDUMP: Argument to /%c switch missing\n", c );
                        Usage();
                        }
                    break;

                default:
                    fprintf( stderr, "DBGDUMP: Invalid switch - /%c\n", c );
                    Usage();
                    break;
                }
            }
        else {
            DebugInfo = NULL;
            if (!fRemote) {
                if (!GetFullPathNameA( s, sizeof( CurrentImageName ), (PCHAR) CurrentImageName, &FilePart )) {
                    fprintf( stderr, "DBGDUMP: invalid file name - %s (%u)\n", s, GetLastError() );
                    }
                else {
                    FileHandle = CreateFileA( (PCHAR)CurrentImageName,
                                             GENERIC_READ,
                                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                                             NULL,
                                             OPEN_EXISTING,
                                             0,
                                             NULL
                                           );
                    if (FileHandle == INVALID_HANDLE_VALUE) {
                        fprintf( stderr, "DBGDUMP: unable to open - %s (%u)\n", CurrentImageName, GetLastError() );
                        }
                    else {
                        DebugInfo = MapDebugInformation64( FileHandle, NULL, NULL, 0 );
                        }
                    }
                }
            else {
                strcpy( (PCHAR) CurrentImageName, s );
                DebugInfo = MapDebugInformation64( NULL, (PCHAR) CurrentImageName, (PCHAR) SymbolPath, 0 );
                }

            if (DebugInfo != NULL) {
                ShowDebugInfo( DebugInfo );
                UnmapDebugInformation64( DebugInfo );
                }
            }
        }

    exit( 0 );
    return 0;
}


VOID
DumpSectionHeader(
    IN ULONG i,
    IN PIMAGE_SECTION_HEADER Sh
    )
{
    PCHAR name;
    ULONG li, lj;
    USHORT memFlags, alignFlags;

    printf( "\nSECTION HEADER #%hX\n% 8.8s name\n", i, Sh->Name );

    printf( "% 8lX physical address\n% 8lX virtual address\n% 8lX size of raw data\n% 8lX file pointer to raw data\n% 8lX file pointer to relocation table\n",
           Sh->Misc.PhysicalAddress,
           Sh->VirtualAddress,
           Sh->SizeOfRawData,
           Sh->PointerToRawData,
           Sh->PointerToRelocations );

    printf( "% 8lX file pointer to line numbers\n% 8hX number of relocations\n% 8hX number of line numbers\n% 8lX flags\n",
           Sh->PointerToLinenumbers,
           Sh->NumberOfRelocations,
           Sh->NumberOfLinenumbers,
           Sh->Characteristics );

    memFlags = alignFlags = 0;
    for (li=Sh->Characteristics, lj=0L; li; li=li>>1, lj++) {
        if (li & 1) {
            switch((li & 1) << lj) {
                case IMAGE_SCN_TYPE_NO_PAD    : name = (PCHAR) "No Pad"; break;


                case IMAGE_SCN_CNT_CODE       : name = (PCHAR) "Code"; break;
                case IMAGE_SCN_CNT_INITIALIZED_DATA : name = (PCHAR) "Initialized Data"; break;
                case IMAGE_SCN_CNT_UNINITIALIZED_DATA : name = (PCHAR) "Uninitialized Data"; break;

                case IMAGE_SCN_LNK_OTHER      : name = (PCHAR) "Other"; break;
                case IMAGE_SCN_LNK_INFO       : name = (PCHAR) "Info"; break;
                case IMAGE_SCN_LNK_REMOVE     : name = (PCHAR) "Remove"; break;
                case IMAGE_SCN_LNK_COMDAT     : name = (PCHAR) "Communal"; break;

                case IMAGE_SCN_ALIGN_1BYTES   :
                case IMAGE_SCN_ALIGN_2BYTES   :
                case IMAGE_SCN_ALIGN_4BYTES   :
                case IMAGE_SCN_ALIGN_8BYTES   :
                case IMAGE_SCN_ALIGN_16BYTES  :
                case IMAGE_SCN_ALIGN_32BYTES  :
                case IMAGE_SCN_ALIGN_64BYTES  : name = (PCHAR) ""; break;

                case IMAGE_SCN_MEM_DISCARDABLE: name = (PCHAR) "Discardable"; break;
                case IMAGE_SCN_MEM_NOT_CACHED : name = (PCHAR) "Not Cached"; break;
                case IMAGE_SCN_MEM_NOT_PAGED  : name = (PCHAR) "Not Paged"; break;
                case IMAGE_SCN_MEM_SHARED     : name = (PCHAR) "Shared"; break;
                case IMAGE_SCN_MEM_EXECUTE    : name = (PCHAR) ""; memFlags |= 1; break;
                case IMAGE_SCN_MEM_READ       : name = (PCHAR) ""; memFlags |= 2; break;
                case IMAGE_SCN_MEM_WRITE      : name = (PCHAR) ""; memFlags |= 4; break;


                default : name = (PCHAR) "RESERVED - UNKNOWN";
            }
            if (*name) {
                printf( "         %s\n", name );
            }
        }
    }

    if (Sh->Characteristics & IMAGE_SCN_ALIGN_64BYTES) {
        switch(Sh->Characteristics & IMAGE_SCN_ALIGN_64BYTES) {
            case IMAGE_SCN_ALIGN_1BYTES  : name = (PCHAR) "Align1";  break;
            case IMAGE_SCN_ALIGN_2BYTES  : name = (PCHAR) "Align2";  break;
            case IMAGE_SCN_ALIGN_4BYTES  : name = (PCHAR) "Align4";  break;
            case IMAGE_SCN_ALIGN_8BYTES  : name = (PCHAR) "Align8";  break;
            case IMAGE_SCN_ALIGN_16BYTES : name = (PCHAR) "Align16"; break;
            case IMAGE_SCN_ALIGN_32BYTES : name = (PCHAR) "Align32"; break;
            case IMAGE_SCN_ALIGN_64BYTES : name = (PCHAR) "Align64"; break;
        }
        printf( "         %s\n", name );
    }

    if (memFlags) {
        switch(memFlags) {
            case 1 : name = (PCHAR) "Execute Only"; break;
            case 2 : name = (PCHAR) "Read Only"; break;
            case 3 : name = (PCHAR) "Execute Read"; break;
            case 4 : name = (PCHAR) "Write Only"; break;
            case 5 : name = (PCHAR) "Execute Write"; break;
            case 6 : name = (PCHAR) "Read Write"; break;
            case 7 : name = (PCHAR) "Execute Read Write"; break;
            default : name = (PCHAR) "Unknown Memory Flags"; break;
        }
        printf( "         %s\n", name );
    }
}


char *FrameType[] = {
    "FRAME_FPO",
    "FRAME_TRAP",
    "FRAME_TSS",
    "FRAME_NONFPO",
    "FRAME_UNKNOWN"
};

void
ShowDebugInfo(
    PIMAGE_DEBUG_INFORMATION64 DebugInfo
    )
{
    ULONG i;
    PIMAGE_SECTION_HEADER Section;
    PIMAGE_FUNCTION_ENTRY FunctionEntry;
    PFPO_DATA FpoEntry;
    LPSTR s;


    printf( "Debug information at % p\n", DebugInfo );
    printf( "    Size             % 8lx\n", DebugInfo->Size );
    printf( "    Mapped at        % p\n", DebugInfo->MappedBase );
    printf( "    Machine          % 8hx\n", DebugInfo->Machine );
    printf( "    Characteristics  % 8hx\n", DebugInfo->Characteristics );
    printf( "    Time/Date stamp  % 8lx",   DebugInfo->TimeDateStamp );
    if (DebugInfo->TimeDateStamp && (s = ctime( (time_t *)&DebugInfo->TimeDateStamp ))) {
        printf( " %s", s );
        }
    else {
        putchar( '\n' );
        }
    printf( "    CheckSum         % 8lx\n", DebugInfo->CheckSum );
    printf( "    ImageBase        % 8lx\n", DebugInfo->ImageBase );
    printf( "    SizeOfImage      % 8lx\n", DebugInfo->SizeOfImage );
    printf( "    NumberOfSections % 8lx\n", DebugInfo->NumberOfSections );
    printf( "    ExportedNamesSize% 8lx\n", DebugInfo->ExportedNamesSize );
    printf( "    #Function Entries% 8lx\n", DebugInfo->NumberOfFunctionTableEntries );
    printf( "    #FPO Entries     % 8lx\n", DebugInfo->NumberOfFpoTableEntries );
    printf( "    Coff Symbol Size % 8lx\n", DebugInfo->SizeOfCoffSymbols );
    printf( "    CV Symbol Size   % 8lx\n", DebugInfo->SizeOfCodeViewSymbols );
    printf( "    Image Path               %s\n", DebugInfo->ImageFilePath );
    printf( "    Image Name               %s\n", DebugInfo->ImageFileName );
    printf( "    Debug Path               %s\n", DebugInfo->DebugFilePath );
    printf( "\n" );

    if (DebugInfo->NumberOfSections != 0) {
        printf( "Section Headers:\n" );
        Section = DebugInfo->Sections;
        for (i=0; i<DebugInfo->NumberOfSections; i++) {
            DumpSectionHeader( i, Section++ );
            }
        printf( "\n" );
        }

    if (DebugInfo->ExportedNamesSize != 0) {
        printf( "Exported Names:\n" );
        s = DebugInfo->ExportedNames;
        while (*s) {
            printf( "    %s\n", s );
            while (*s++) {
                }
            }
        printf( "\n" );
        }

    if (DebugInfo->NumberOfFunctionTableEntries != 0) {
        printf( "Function Table:\n" );
        FunctionEntry = DebugInfo->FunctionTableEntries;
        for (i=0; i<DebugInfo->NumberOfFunctionTableEntries; i++) {
            printf( "    % 4x: % 8x % 8x % 8x\n",
                    i,
                    FunctionEntry->StartingAddress,
                    FunctionEntry->EndingAddress,
                    FunctionEntry->EndOfPrologue
                  );

            FunctionEntry += 1;
            }
        printf( "\n" );
        }

    if (DebugInfo->NumberOfFpoTableEntries != 0) {
        printf( "FPO Table:\n" );
        FpoEntry = DebugInfo->FpoTableEntries;
        for (i=0; i<DebugInfo->NumberOfFpoTableEntries; i++) {
            printf( "    % 4x: % 8x % 8x % 8x [%02x %1x%s%s %s]\n",
                    i,
                    FpoEntry->ulOffStart,
                    FpoEntry->cbProcSize,
                    FpoEntry->cdwParams,
                    FpoEntry->cbProlog,
                    FpoEntry->cbRegs,
                    FpoEntry->fHasSEH ? " SEH" : "",
                    FpoEntry->fUseBP ? " EBP" : "",
                    FrameType[ FpoEntry->cbFrame ]
                  );

            FpoEntry += 1;
            }

        printf( "\n" );
        }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\checksum.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    checksum.c

Abstract:

    This module implements a function for computing the checksum of an
    image file. It will also compute the checksum of other files as well.

Author:

    David N. Cutler (davec) 21-Mar-1993

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <private.h>

//
// Define checksum routine prototype.
//
#ifdef __cplusplus
extern "C"
#endif
USHORT
ChkSum(
    DWORD PartialSum,
    PUSHORT Source,
    DWORD Length
    );

PIMAGE_NT_HEADERS
CheckSumMappedFile (
    LPVOID BaseAddress,
    DWORD FileLength,
    LPDWORD HeaderSum,
    LPDWORD CheckSum
    )

/*++

Routine Description:

    This functions computes the checksum of a mapped file.

Arguments:

    BaseAddress - Supplies a pointer to the base of the mapped file.

    FileLength - Supplies the length of the file in bytes.

    HeaderSum - Suppllies a pointer to a variable that receives the checksum
        from the image file, or zero if the file is not an image file.

    CheckSum - Supplies a pointer to the variable that receive the computed
        checksum.

Return Value:

    None.

--*/

{

    PUSHORT AdjustSum;
    PIMAGE_NT_HEADERS NtHeaders;
    USHORT PartialSum;

    //
    // Compute the checksum of the file and zero the header checksum value.
    //

    *HeaderSum = 0;
    PartialSum = ChkSum(0, (PUSHORT)BaseAddress, (FileLength + 1) >> 1);

    //
    // If the file is an image file, then subtract the two checksum words
    // in the optional header from the computed checksum before adding
    // the file length, and set the value of the header checksum.
    //

    __try {
        NtHeaders = RtlpImageNtHeader(BaseAddress);

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        NtHeaders = NULL;
    }

    if ((NtHeaders != NULL) && (NtHeaders != BaseAddress)) {
        if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            *HeaderSum = ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.CheckSum;
            AdjustSum = (PUSHORT)(&((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.CheckSum);
        } else
        if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
            *HeaderSum = ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.CheckSum;
            AdjustSum = (PUSHORT)(&((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.CheckSum);
        } else {
            return(NULL);
        }
        PartialSum -= (PartialSum < AdjustSum[0]);
        PartialSum -= AdjustSum[0];
        PartialSum -= (PartialSum < AdjustSum[1]);
        PartialSum -= AdjustSum[1];
    }

    //
    // Compute the final checksum value as the sum of the paritial checksum
    // and the file length.
    //

    *CheckSum = (DWORD)PartialSum + FileLength;
    return NtHeaders;
}

DWORD
MapFileAndCheckSumW(
    PWSTR Filename,
    LPDWORD HeaderSum,
    LPDWORD CheckSum
    )

/*++

Routine Description:

    This functions maps the specified file and computes the checksum of
    the file.

Arguments:

    Filename - Supplies a pointer to the name of the file whose checksum
        is computed.

    HeaderSum - Supplies a pointer to a variable that receives the checksum
        from the image file, or zero if the file is not an image file.

    CheckSum - Supplies a pointer to the variable that receive the computed
        checksum.

Return Value:

    0 if successful, else error number.

--*/

{
#ifndef UNICODE_RULES
    CHAR   FileNameA[ MAX_PATH ];

    //  Convert the file name to Ansi and call the Ansi version
    //  of this function.

    if (WideCharToMultiByte(
                    CP_ACP,
                    0,
                    Filename,
                    -1,
                    FileNameA,
                    MAX_PATH,
                    NULL,
                    NULL ) ) {

        return MapFileAndCheckSumA(FileNameA, HeaderSum, CheckSum);
    }

    return CHECKSUM_UNICODE_FAILURE;

#else  // UNICODE_RULES

    HANDLE FileHandle, MappingHandle;
    LPVOID BaseAddress;
    DWORD FileLength;

    //
    // Open the file for read access
    //

    FileHandle = CreateFileW(
                        Filename,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

    if (FileHandle == INVALID_HANDLE_VALUE) {
        return CHECKSUM_OPEN_FAILURE;
    }

    //
    //  Create a file mapping, map a view of the file into memory,
    //  and close the file mapping handle.
    //

    MappingHandle = CreateFileMapping(FileHandle,
                                      NULL,
                                      PAGE_READONLY,
                                      0,
                                      0,
                                      NULL);

    if (!MappingHandle) {
        CloseHandle( FileHandle );
        return CHECKSUM_MAP_FAILURE;
    }

    //
    // Map a view of the file
    //

    BaseAddress = MapViewOfFile(MappingHandle, FILE_MAP_READ, 0, 0, 0);
    CloseHandle(MappingHandle);
    if (BaseAddress == NULL) {
        CloseHandle( FileHandle );
        return CHECKSUM_MAPVIEW_FAILURE;
    }

    //
    // Get the length of the file in bytes and compute the checksum.
    //
    FileLength = GetFileSize( FileHandle, NULL );
    CheckSumMappedFile(BaseAddress, FileLength, HeaderSum, CheckSum);

    //
    // Unmap the view of the file and close file handle.
    //

    UnmapViewOfFile(BaseAddress);
    CloseHandle( FileHandle );
    return CHECKSUM_SUCCESS;

#endif  // UNICODE_RULES
}


ULONG
MapFileAndCheckSumA (
    LPSTR Filename,
    LPDWORD HeaderSum,
    LPDWORD CheckSum
    )

/*++

Routine Description:

    This functions maps the specified file and computes the checksum of
    the file.

Arguments:

    Filename - Supplies a pointer to the name of the file whose checksum
        is computed.

    HeaderSum - Supplies a pointer to a variable that receives the checksum
        from the image file, or zero if the file is not an image file.

    CheckSum - Supplies a pointer to the variable that receive the computed
        checksum.

Return Value:

    0 if successful, else error number.

--*/

{
#ifdef UNICODE_RULES
    WCHAR   FileNameW[ MAX_PATH ];

    //
    //  Convert the file name to unicode and call the unicode version
    //  of this function.
    //

    if (MultiByteToWideChar(
                    CP_ACP,
                    MB_PRECOMPOSED,
                    Filename,
                    -1,
                    FileNameW,
                    MAX_PATH ) ) {

        return MapFileAndCheckSumW(FileNameW, HeaderSum, CheckSum);

    }

    return CHECKSUM_UNICODE_FAILURE;

#else   // UNICODE_RULES

    HANDLE FileHandle, MappingHandle;
    LPVOID BaseAddress;
    DWORD FileLength;

    //
    // Open the file for read access
    //

    FileHandle = CreateFileA(
                        Filename,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

    if (FileHandle == INVALID_HANDLE_VALUE) {
        return CHECKSUM_OPEN_FAILURE;
    }

    //
    //  Create a file mapping, map a view of the file into memory,
    //  and close the file mapping handle.
    //

    MappingHandle = CreateFileMapping(FileHandle,
                                      NULL,
                                      PAGE_READONLY,
                                      0,
                                      0,
                                      NULL);

    if (!MappingHandle) {
        CloseHandle( FileHandle );
        return CHECKSUM_MAP_FAILURE;
    }

    //
    // Map a view of the file
    //

    BaseAddress = MapViewOfFile(MappingHandle, FILE_MAP_READ, 0, 0, 0);
    CloseHandle(MappingHandle);
    if (BaseAddress == NULL) {
        CloseHandle( FileHandle );
        return CHECKSUM_MAPVIEW_FAILURE;
    }

    //
    // Get the length of the file in bytes and compute the checksum.
    //
    FileLength = GetFileSize( FileHandle, NULL );
    CheckSumMappedFile(BaseAddress, FileLength, HeaderSum, CheckSum);

    //
    // Unmap the view of the file and close file handle.
    //

    UnmapViewOfFile(BaseAddress);
    CloseHandle( FileHandle );
    return CHECKSUM_SUCCESS;

#endif   // UNICODE_RULES
}


BOOL
TouchFileTimes(
    HANDLE FileHandle,
    LPSYSTEMTIME lpSystemTime
    )
{
    SYSTEMTIME SystemTime;
    FILETIME SystemFileTime;

    if (lpSystemTime == NULL) {
        lpSystemTime = &SystemTime;
        GetSystemTime( lpSystemTime );
        }

    if (SystemTimeToFileTime( lpSystemTime, &SystemFileTime )) {
        return SetFileTime( FileHandle, NULL, NULL, &SystemFileTime );
        }
    else {
        return FALSE;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\copypdb.c ===
BOOL
CopyPdb(
    CHAR const * szSrcPdb,
    CHAR const * szDestPdb,
    BOOL StripPrivate
    )
{
    LONG ErrorCode;
    ULONG Sig = 0;
    char ErrorString[1024];
    BOOL rc;
    PDB * pSrcPdb;
    HINSTANCE hMsPdb;

    // Add a short circut.  PdbCopy fails miserably if the source and destination are the same.
    // If StripPrivate isn't set, check for this case and just return.  If StripPrivate is set,
    // bummer.

    if (!StripPrivate) {
        if (!_stricmp(szSrcPdb, szDestPdb)) {
            rc = TRUE;
        } else {
            rc = CopyFile(szSrcPdb, szDestPdb, FALSE);
        }
    } else {
        rc = PDBOpen((char *)szSrcPdb, "r", Sig, &ErrorCode, ErrorString, &pSrcPdb);
        if (rc) {
            rc = DeleteFile(szDestPdb);
            if (rc || (GetLastError() == ERROR_FILE_NOT_FOUND)) {
                rc = PDBCopyTo(pSrcPdb, szDestPdb, StripPrivate ? 0x00000001 : 0x0000000, 0);
            }
            if (!rc) {
                // PdbCopyTo doesn't cleanup on failure.  Do it here.
                DeleteFile(szDestPdb);
            }
            PDBClose(pSrcPdb);
        }
    }

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\dbgexts.c ===
#include "private.h"

#include <ntsdexts.h>


#ifdef __cplusplus
#define CPPMOD extern "C"
#else
#define CPPMOD
#endif

#define DECLARE_API(s)                          \
    CPPMOD VOID                                 \
    s(                                          \
        HANDLE hCurrentProcess,                 \
        HANDLE hCurrentThread,                  \
        DWORD dwCurrentPc,                      \
        PNTSD_EXTENSION_APIS lpExtensionApis,   \
        LPSTR lpArgumentString                  \
     )

#define INIT_API() {                            \
    ExtensionApis = *lpExtensionApis;           \
    ExtensionCurrentProcess = hCurrentProcess;  \
    }

#define dprintf                 (ExtensionApis.lpOutputRoutine)
#define GetExpression           (ExtensionApis.lpGetExpressionRoutine)
#define GetSymbol               (ExtensionApis.lpGetSymbolRoutine)
#define Disassm                 (ExtensionApis.lpDisasmRoutine)
#define CheckControlC           (ExtensionApis.lpCheckControlCRoutine)
#define ReadMemory(a,b,c,d)     ReadProcessMemory( ExtensionCurrentProcess, (LPCVOID)(a), (b), (c), (d) )
#define WriteMemory(a,b,c,d)    WriteProcessMemory( ExtensionCurrentProcess, (LPVOID)(a), (LPVOID)(b), (c), (d) )

NTSD_EXTENSION_APIS ExtensionApis;
HANDLE ExtensionCurrentProcess;

#ifdef IMAGEHLP_HEAP_DEBUG
DECLARE_API( allocs )
{
    PLIST_ENTRY                 Next;
    HEAP_BLOCK                  HeapBlock;
    ULONG                       Address;
    ULONG                       r;
    ULONG                       cb;

    LIST_ENTRY                  LocalHeapHeader;
    ULONG                       LocalTotalAllocs;
    ULONG                       LocalTotalMemory;
    HANDLE                      LocalhHeap;


    INIT_API();

    Address = GetExpression("imagehlp!TotalAllocs");
    r = ReadMemory(Address,
                   &LocalTotalAllocs,
                   sizeof(LocalTotalAllocs),
                   &cb
                   );
    if (!r || cb != sizeof(LocalTotalAllocs)) {
        dprintf("*** TotalAllocs unreadable\n");
        return;
    }

    Address = GetExpression("imagehlp!TotalMemory");
    r = ReadMemory(Address,
                   &LocalTotalMemory,
                   sizeof(LocalTotalMemory),
                   &cb
                   );
    if (!r || cb != sizeof(LocalTotalMemory)) {
        dprintf("*** TotalMemory unreadable\n");
        return;
    }

    Address = GetExpression("imagehlp!hHeap");
    r = ReadMemory(Address,
                   &LocalhHeap,
                   sizeof(LocalhHeap),
                   &cb
                   );
    if (!r || cb != sizeof(LocalhHeap)) {
        dprintf("*** hHeap unreadable\n");
        return;
    }


    Address = GetExpression("imagehlp!HeapHeader");
    r = ReadMemory(Address,
                   &LocalHeapHeader,
                   sizeof(LocalHeapHeader),
                   &cb
                   );
    if (!r || cb != sizeof(LocalHeapHeader)) {
        dprintf("*** HeapHeader unreadable\n");
        return;
    }
    Next = LocalHeapHeader.Flink;
    if (!Next) {
        return;
    }

    dprintf( "-----------------------------------------------------------------------------\n" );
    dprintf( "Memory Allocations for Heap 0x%08x, Allocs=%d, TotalMem=%d\n",
                     LocalhHeap, LocalTotalAllocs, LocalTotalMemory );
    dprintf( "-----------------------------------------------------------------------------\n" );
    dprintf( "*\n" );

    while ((ULONG)Next != Address) {
        r = ReadMemory( CONTAINING_RECORD( Next, HEAP_BLOCK, ListEntry ),
                        &HeapBlock,
                        sizeof(HeapBlock),
                        &cb
                        );
        if (!r || cb != sizeof(HeapBlock)) {
            dprintf("*** list broken\n");
            return;
        }
        Next = HeapBlock.ListEntry.Flink;
        dprintf( "%8d %16s @ %5d\n", HeapBlock.Size, HeapBlock.File, HeapBlock.Line );
    }

    return;

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\dice.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dice.cxx

Abstract:

    This file implements the Image Integrity API's.

Author:

    Bryan Tuttle (bryant) 7-Dec-1995

Environment:

    User Mode

--*/

#include <private.h>

BOOL
FindCertificate(
    IN PLOADED_IMAGE    LoadedImage,
    IN DWORD            Index,
    LPWIN_CERTIFICATE * Certificate
    )
{
    PIMAGE_DATA_DIRECTORY pDataDir;
    DWORD_PTR CurrentCert;
    BOOL rc;

    if (LoadedImage->fDOSImage) {
        // No way this could have a certificate;
        return(FALSE);
    }

    rc = FALSE;

    __try {
        if (LoadedImage->FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            pDataDir = &((PIMAGE_NT_HEADERS32)(LoadedImage->FileHeader))->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
        } else if (LoadedImage->FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
            pDataDir = &((PIMAGE_NT_HEADERS64)(LoadedImage->FileHeader))->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
        } else {
            __leave;     // Not an interesting file type.
        }

        // Check if the cert pointer is at least reasonable.
        if (!pDataDir->VirtualAddress ||
            !pDataDir->Size ||
            (pDataDir->VirtualAddress + pDataDir->Size > LoadedImage->SizeOfImage))
        {
            __leave;
        }

        // We're not looking at an empty security slot or an invalid (past the image boundary) value.
        // Let's see if we can find it.

        DWORD CurrentIdx = 0;
        DWORD_PTR LastCert;

        CurrentCert = (DWORD_PTR)(LoadedImage->MappedAddress) + pDataDir->VirtualAddress;
        LastCert = CurrentCert + pDataDir->Size;

        while (CurrentCert < LastCert ) {
            if (CurrentIdx == Index) {
                rc = TRUE;
                __leave;
            }
            CurrentIdx++;
            CurrentCert += ((LPWIN_CERTIFICATE)CurrentCert)->dwLength;
            CurrentCert = (CurrentCert + 7) & ~7;   // align it.
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) { }

    if (rc == TRUE) {
        *Certificate = (LPWIN_CERTIFICATE)CurrentCert;
    }

    return(rc);
}

typedef struct _EXCLUDE_RANGE {
    PBYTE Offset;
    DWORD Size;
    struct _EXCLUDE_RANGE *Next;
} EXCLUDE_RANGE;

typedef enum {
    Raw,
    Virtual
} ADDRTYPE;

class EXCLUDE_LIST
{
    public:
        EXCLUDE_LIST() {
            m_Image = NULL;
            m_ExRange = (EXCLUDE_RANGE *)MemAlloc(sizeof(EXCLUDE_RANGE));
        }

        ~EXCLUDE_LIST() {
            EXCLUDE_RANGE *pTmp;
            pTmp = m_ExRange->Next;
            while (pTmp) {
                MemFree(m_ExRange);
                m_ExRange = pTmp;
                pTmp = m_ExRange->Next;
            }
            MemFree(m_ExRange);
        }

        void Init(LOADED_IMAGE * Image, DIGEST_FUNCTION pFunc, DIGEST_HANDLE dh) {
            m_Image = Image;
            m_ExRange->Offset = NULL;
            m_ExRange->Size = 0;
            m_pFunc = pFunc;
            m_dh = dh;
            return;
        }

        void Add(DWORD_PTR Offset, DWORD Size, ADDRTYPE AddrType);

        BOOL Emit(PBYTE Offset, DWORD Size);

    private:
        LOADED_IMAGE  * m_Image;
        EXCLUDE_RANGE * m_ExRange;
        DIGEST_FUNCTION m_pFunc;
        DIGEST_HANDLE m_dh;
};

void
EXCLUDE_LIST::Add(
    DWORD_PTR Offset,
    DWORD Size,
    ADDRTYPE AddrType
    )
{
    if (AddrType == Virtual) {
        // Always save raw offsets
        DWORD_PTR RawOffset;

        // Note: it's O.K. to cast down to a dword here.  Offset is really a Rva from the start
        // of the image (always limited to 4G).

        RawOffset = (DWORD_PTR)ImageRvaToVa((PIMAGE_NT_HEADERS)m_Image->FileHeader, m_Image->MappedAddress, (DWORD)Offset, NULL);
        Offset = RawOffset;
    }

    EXCLUDE_RANGE *pTmp, *pExRange;

    pExRange = m_ExRange;

    while (pExRange->Next && (pExRange->Next->Offset < (PBYTE)Offset)) {
        pExRange = pExRange->Next;
    }

    pTmp = (EXCLUDE_RANGE *) MemAlloc(sizeof(EXCLUDE_RANGE));
    pTmp->Next = pExRange->Next;
    pTmp->Offset = (PBYTE)Offset;
    pTmp->Size = Size;
    pExRange->Next = pTmp;

    return;
}


BOOL
EXCLUDE_LIST::Emit(
    PBYTE Offset,
    DWORD Size
    )
{
    BOOL rc;

    EXCLUDE_RANGE *pExRange;
    DWORD EmitSize, ExcludeSize;

    pExRange = m_ExRange->Next;

    while (pExRange && (Size > 0)) {
        if (pExRange->Offset >= Offset) {
            // Emit what's before the exclude list.
            EmitSize = __min((DWORD)(pExRange->Offset - Offset), Size);
            if (EmitSize) {
                rc = (*m_pFunc)(m_dh, Offset, EmitSize);
                Size -= EmitSize;
                Offset += EmitSize;
            }
        }

        if (Size) {
            if (pExRange->Offset + pExRange->Size >= Offset) {
                // Skip over what's in the exclude list.
                ExcludeSize = __min(Size, (DWORD)(pExRange->Offset + pExRange->Size - Offset));
                Size -= ExcludeSize;
                Offset += ExcludeSize;
            }
        }

        pExRange = pExRange->Next;
    }

    // Emit what's left.
    if (Size) {
        rc = (*m_pFunc)(m_dh, Offset, Size);
    }
    return rc;
}


BOOL
IMAGEAPI
ImageGetDigestStream(
    IN HANDLE           FileHandle,
    IN DWORD            DigestLevel,
    IN DIGEST_FUNCTION  DigestFunction,
    IN DIGEST_HANDLE    DigestHandle
    )

/*++

Routine Description:

    Given an image, return the bytes necessary to construct a certificate.
    Only PE images are supported at this time.

Arguments:

    FileHandle  -   Handle to the file in question.  The file should be opened
                    with at least GENERIC_READ access.

    DigestLevel -   Indicates what data will be included in the returned buffer.
                    Valid values are:

                        CERT_PE_IMAGE_DIGEST_DEBUG_INFO - Include Debug symbolic (if mapped)
                        CERT_PE_IMAGE_DIGEST_RESOURCES  - Include Resource info
                        CERT_PE_IMAGE_DIGEST_ALL_IMPORT_INFO - Include ALL the import information

                    By default, neither Debug Symbolic, Resources, nor import information affected
                    by binding are returned.

    DigestFunction - User supplied routine that will process the data.

    DigestHandle -  User supplied handle to identify the digest.  Passed as the first
                    argument to the DigestFunction.

Return Value:

    TRUE         - Success.

    FALSE        - There was some error.  Call GetLastError for more information.  Possible
                   values are ERROR_INVALID_PARAMETER or ERROR_OPERATION_ABORTED.

--*/

{
    LOADED_IMAGE    LoadedImage;
    BOOL            rc, fAddThisSection, fDebugAdded;
    DWORD           i;
    EXCLUDE_LIST    ExList;
    PIMAGE_SECTION_HEADER SectionHeaders;
    ULONG ResourceOffset, ResourceSize, DebugOffset, DebugSize, RelocOffset, RelocSize, SectionHeaderSize;
    PIMAGE_FILE_HEADER FileHeader;
    PIMAGE_DATA_DIRECTORY pDataDir;
    INT RelocHdr;
    union {
        IMAGE_NT_HEADERS32 PE32;
        IMAGE_NT_HEADERS64 PE64;
    }Hdr;
    BOOL f32;

    if (MapIt(FileHandle, &LoadedImage, MAP_READONLY) == FALSE) {
        // Unable to map the image.
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    rc = ERROR_INVALID_PARAMETER;

    __try {

        if (LoadedImage.fDOSImage) {
            __leave;
        }

        if (LoadedImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            f32 = TRUE;
        } else if (LoadedImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
            f32 = FALSE;
        } else {
            __leave;
        }

        ExList.Init(&LoadedImage, DigestFunction, DigestHandle);

        // Return all the interesting stuff from the image.  First, the common stuff.

        // 1. Add the DOS stub (if it exists).

        if ((ULONG_PTR)LoadedImage.FileHeader - (ULONG_PTR) LoadedImage.MappedAddress) {
            if (!ExList.Emit((PBYTE) LoadedImage.MappedAddress,
                             (DWORD)((ULONG_PTR) LoadedImage.FileHeader - (ULONG_PTR) LoadedImage.MappedAddress)))
            {
                rc = ERROR_OPERATION_ABORTED;
                __leave;
            }
        }

        // Add the headers, but not the checksum and not the security Data directory entry.

        if (f32) {
            Hdr.PE32 = *((PIMAGE_NT_HEADERS32)LoadedImage.FileHeader);
            pDataDir = &Hdr.PE32.OptionalHeader.DataDirectory[0];
            Hdr.PE32.OptionalHeader.CheckSum = 0;
        } else {
            Hdr.PE64 = *((PIMAGE_NT_HEADERS64)LoadedImage.FileHeader);
            pDataDir = &Hdr.PE64.OptionalHeader.DataDirectory[0];
            Hdr.PE64.OptionalHeader.CheckSum = 0;
        }

        pDataDir[IMAGE_DIRECTORY_ENTRY_SECURITY].Size = 0;
        pDataDir[IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress = 0;

        SectionHeaderSize = sizeof(IMAGE_SECTION_HEADER) * LoadedImage.NumberOfSections;
        SectionHeaders = (PIMAGE_SECTION_HEADER) MemAlloc(SectionHeaderSize);

        ResourceOffset = pDataDir[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress;
        ResourceSize = pDataDir[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size;
        RelocOffset = pDataDir[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
        RelocSize = pDataDir[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;

        fDebugAdded = TRUE;
        DebugOffset = 0xFFFFFFFF;
        RelocHdr = -1;

        for (i = 0; i < LoadedImage.NumberOfSections; i++) {
            SectionHeaders[i] = LoadedImage.Sections[i];

            // Keep track of the reloc section header.  We may need to adjust it later.

            if (RelocSize &&
                ((LoadedImage.Sections[i].VirtualAddress <= RelocOffset) &&
                 (LoadedImage.Sections[i].VirtualAddress +
                    LoadedImage.Sections[i].Misc.VirtualSize >= RelocOffset + RelocSize))
                )
            {
                RelocHdr = i;
            }

            // If resources aren't in the digest, we need to clear the resource section header

            if (ResourceSize && !(DigestLevel & CERT_PE_IMAGE_DIGEST_RESOURCES)) {

                if (((LoadedImage.Sections[i].VirtualAddress <= ResourceOffset) &&
                     (LoadedImage.Sections[i].VirtualAddress +
                        LoadedImage.Sections[i].Misc.VirtualSize >= ResourceOffset + ResourceSize))
                    )
                {
                    // Found the resource section header.  Zero it out.
                    SectionHeaders[i].Misc.VirtualSize = 0;
                    SectionHeaders[i].VirtualAddress = 0;
                    SectionHeaders[i].SizeOfRawData = 0;
                    SectionHeaders[i].PointerToRawData = 0;
                }
            }

            if (!(DigestLevel & CERT_PE_IMAGE_DIGEST_DEBUG_INFO)) {
                // Same with mapped debug info.
                if (!strncmp((char *)LoadedImage.Sections[i].Name, ".debug", sizeof(".debug"))) {

                    DebugOffset = SectionHeaders[i].VirtualAddress;
                    DebugSize = SectionHeaders[i].SizeOfRawData;
                    ExList.Add(SectionHeaders[i].PointerToRawData + (DWORD_PTR) LoadedImage.MappedAddress, DebugSize, Raw);

                    SectionHeaders[i].Misc.VirtualSize = 0;
                    SectionHeaders[i].VirtualAddress = 0;
                    SectionHeaders[i].SizeOfRawData = 0;
                    SectionHeaders[i].PointerToRawData = 0;
                    fDebugAdded = FALSE;
                }
            }
        }

        // The first pass on the section headers is finished.  See it we need to adjust the
        // reloc dir or the image headers.

        if (!(DigestLevel & CERT_PE_IMAGE_DIGEST_RESOURCES)) {
            // If the resources aren't in the digest, don't add the base reloc address or the
            // resource address/size to the digest.  This allows subsequent tools to add/subtract
            // resource info w/o effecting the digest.

            if ((ResourceOffset < RelocOffset) && (RelocHdr != -1))
            {
                pDataDir[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = 0;
                SectionHeaders[RelocHdr].PointerToRawData = 0;
                SectionHeaders[RelocHdr].VirtualAddress = 0;
            }
            pDataDir[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size = 0;
            pDataDir[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress = 0;
            if (f32) {
                Hdr.PE32.OptionalHeader.SizeOfImage = 0;
                Hdr.PE32.OptionalHeader.SizeOfInitializedData = 0;
            } else {
                Hdr.PE64.OptionalHeader.SizeOfImage = 0;
                Hdr.PE64.OptionalHeader.SizeOfInitializedData = 0;
            }
            ExList.Add(ResourceOffset, ResourceSize, Virtual);
        }

        if (!(DigestLevel & CERT_PE_IMAGE_DIGEST_DEBUG_INFO) &&
            (fDebugAdded == FALSE))
        {
            // Debug wasn't added to the image and IS mapped in.  Allow these to grow also.
            if (f32) {
                Hdr.PE32.OptionalHeader.SizeOfImage = 0;
                Hdr.PE32.OptionalHeader.SizeOfInitializedData = 0;
            } else {
                Hdr.PE64.OptionalHeader.SizeOfImage = 0;
                Hdr.PE64.OptionalHeader.SizeOfInitializedData = 0;
            }
            if ((DebugOffset < RelocOffset) && (RelocHdr != -1))
            {
                pDataDir[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = 0;
                SectionHeaders[RelocHdr].PointerToRawData = 0;
                SectionHeaders[RelocHdr].VirtualAddress = 0;
            }
        }

        // Looks good.  Send the headers to the digest function.

        if (f32) {
            if (!ExList.Emit((PBYTE) &Hdr.PE32, sizeof(Hdr.PE32))) {
                rc = ERROR_OPERATION_ABORTED;
                __leave;
            }
        } else {
            if (!ExList.Emit((PBYTE) &Hdr.PE64, sizeof(Hdr.PE64))) {
                rc = ERROR_OPERATION_ABORTED;
                __leave;
            }
        }

        // Then the section headers.

        if (!ExList.Emit((PBYTE) SectionHeaders, SectionHeaderSize)) {
            rc = ERROR_OPERATION_ABORTED;
            __leave;
        }

        MemFree(SectionHeaders);

        // The headers are done.  Now let's see what we need to do with the import information.

        if (!(DigestLevel & CERT_PE_IMAGE_DIGEST_ALL_IMPORT_INFO)) {
            // The user didn't explicitly ask for all import info.
            // Add the info modified by bind to the exclude list.

            PIMAGE_IMPORT_DESCRIPTOR ImportDesc;
            DWORD ImportDescSize, IATSize;
            PVOID IAT;

            ImportDesc = (PIMAGE_IMPORT_DESCRIPTOR) ImageDirectoryEntryToData(
                                LoadedImage.MappedAddress,
                                FALSE,
                                IMAGE_DIRECTORY_ENTRY_IMPORT,
                                &ImportDescSize);
            if (ImportDescSize) {

                IAT = ImageDirectoryEntryToData(LoadedImage.MappedAddress,
                                                FALSE,
                                                IMAGE_DIRECTORY_ENTRY_IAT,
                                                &IATSize);

                if (IAT) {
                    // Easy case.  All the IATs are grouped together.
                    ExList.Add((DWORD_PTR) IAT, IATSize, Raw);

                    // Add the TimeDateStamp and ForwarderChain fields in the Import Descriptors

                    while (ImportDesc->Characteristics) {
                        ExList.Add((DWORD_PTR) &ImportDesc->TimeDateStamp, 8, Raw);
                        ImportDesc++;
                    }

                } else {
                    // Not so easy.  Need to walk each Import descriptor to find the bounds of the IAT
                    //  (note, there's no requirement that all the IAT's for all descriptors be contiguous).


                    while (ImportDesc->Characteristics) {
                        PIMAGE_THUNK_DATA ThunkStart;
                        ExList.Add((DWORD_PTR)&ImportDesc->TimeDateStamp, 8, Raw);
                        ThunkStart = (PIMAGE_THUNK_DATA) ImageRvaToVa((PIMAGE_NT_HEADERS)LoadedImage.FileHeader,
                                                                      LoadedImage.MappedAddress,
                                                                      (ULONG) ImportDesc->OriginalFirstThunk,
                                                                      NULL);
                        if (f32) {
                            PIMAGE_THUNK_DATA32 Thunk = (PIMAGE_THUNK_DATA32)ThunkStart;
                            while (Thunk->u1.AddressOfData) {
                                Thunk++;
                            }
                            ExList.Add( (DWORD)ImportDesc->FirstThunk,
                                        (DWORD)((DWORD_PTR)Thunk - (DWORD_PTR) ThunkStart + sizeof(IMAGE_THUNK_DATA32)), Virtual);
                        } else {
                            PIMAGE_THUNK_DATA64 Thunk = (PIMAGE_THUNK_DATA64)ThunkStart;
                            while (Thunk->u1.AddressOfData) {
                                Thunk++;
                            }
                            ExList.Add( (DWORD)ImportDesc->FirstThunk,
                                        (DWORD)((DWORD_PTR)Thunk - (DWORD_PTR) ThunkStart + sizeof(IMAGE_THUNK_DATA64)), Virtual);
                        }
                        ImportDesc++;
                    }
                }
            }
        }

        // Add each section header followed by the data from that section.

        for (i = 0; i < LoadedImage.NumberOfSections; i++) {
            if (!ExList.Emit((PBYTE) (LoadedImage.MappedAddress + LoadedImage.Sections[i].PointerToRawData),
                             LoadedImage.Sections[i].SizeOfRawData))
            {
                rc = ERROR_OPERATION_ABORTED;
                __leave;
            }
        }
        rc = ERROR_SUCCESS;

    } __except(EXCEPTION_EXECUTE_HANDLER) { }

    UnMapIt(&LoadedImage);

    SetLastError(rc);

    return(rc == ERROR_SUCCESS ? TRUE : FALSE);
}



BOOL
IMAGEAPI
ImageAddCertificate(
    IN HANDLE               FileHandle,
    IN LPWIN_CERTIFICATE    Certificate,
    OUT PDWORD              Index
    )

/*++

Routine Description:
    Add a certificate to the image.  There is no checking to ensure there are no
    duplicate types.

Arguments:

    FileHandle      -   Handle to the file in question.  The file should be opened
                        with at least GENERIC_WRITE access.

    Certificate     -   Pointer to a WIN_CERTIFICATE structure.

    Index           -   After adding the Certificate to the image, this is the index
                        you can use for later references to that certificate.

Return Value:

    TRUE    - Success
    FALSE   - There was some error.  Call GetLastError() for more information.

--*/

{
    LOADED_IMAGE        LoadedImage;
    DWORD               rc;
    LPWIN_CERTIFICATE   pCert;
    DWORD               OnDiskCertLength;
    DWORD_PTR           NewCertLocation;
    DWORD               OriginalImageSize;
    PIMAGE_DATA_DIRECTORY  pDataDir;
    BOOL                f32;

    if (MapIt(FileHandle, &LoadedImage, MAP_READWRITE) == FALSE) {
        // Unable to map the image.
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    rc = ERROR_INVALID_PARAMETER;

    __try {

        if (LoadedImage.fDOSImage) {
            __leave;
        }

        if (LoadedImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            f32 = TRUE;
            pDataDir = &((PIMAGE_NT_HEADERS32)(LoadedImage.FileHeader))->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
        } else if (LoadedImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
            f32 = FALSE;
            pDataDir = &((PIMAGE_NT_HEADERS64)(LoadedImage.FileHeader))->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
        } else {
            __leave;
        }

        pCert = (LPWIN_CERTIFICATE) Certificate;

        // Test the output parameter and the the cert.

        *Index = (DWORD) -1;
        OnDiskCertLength = pCert->dwLength;
        OnDiskCertLength = (OnDiskCertLength + 7) & ~7;        // Round the size of cert.

        // Grow the image.

        OriginalImageSize = LoadedImage.SizeOfImage;
        OriginalImageSize = (OriginalImageSize + 7) & ~7;      // Round the size of Image.

        // Check if the cert pointer is at least reasonable.
        if (pDataDir->VirtualAddress &&
            (pDataDir->VirtualAddress + pDataDir->Size) > LoadedImage.SizeOfImage)
        {
            __leave;
        }

        // Looks good now.

        *Index = 0;
        if (pDataDir->VirtualAddress == 0) {
            pDataDir->VirtualAddress = OriginalImageSize;
            pDataDir->Size = 0;
            NewCertLocation = OriginalImageSize;
        } else {
            LPWIN_CERTIFICATE CurrentCert;

            NewCertLocation = pDataDir->VirtualAddress + pDataDir->Size + (DWORD_PTR) LoadedImage.MappedAddress;
            CurrentCert = (LPWIN_CERTIFICATE) (LoadedImage.MappedAddress + pDataDir->VirtualAddress);
            while (((DWORD_PTR)CurrentCert) < NewCertLocation) {
                if (CurrentCert->dwLength == 0) {
                    __leave;
                }
                CurrentCert = (LPWIN_CERTIFICATE)(((DWORD_PTR)CurrentCert + CurrentCert->dwLength + 7) & ~7);
                (*Index)++;
            }
            NewCertLocation -= (DWORD_PTR) LoadedImage.MappedAddress;
        }

        if (!GrowMap (&LoadedImage, OnDiskCertLength + (OriginalImageSize - LoadedImage.SizeOfImage))) {
             __leave;
        }

        if (NewCertLocation < OriginalImageSize) {
            // There's data after the current security data.  Move it down.
            memmove(LoadedImage.MappedAddress + NewCertLocation + pCert->dwLength,
                    LoadedImage.MappedAddress + NewCertLocation,
                    (unsigned) (OriginalImageSize - NewCertLocation));
        }

        memmove(LoadedImage.MappedAddress + NewCertLocation,
                pCert,
                pCert->dwLength);

        // GrowMap may have moved the dirs.
        if (f32) {
            pDataDir = &((PIMAGE_NT_HEADERS32)(LoadedImage.FileHeader))->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
        } else {
            pDataDir = &((PIMAGE_NT_HEADERS64)(LoadedImage.FileHeader))->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
        }

        pDataDir->Size += OnDiskCertLength;
        rc = ERROR_SUCCESS;

    } __except(EXCEPTION_EXECUTE_HANDLER) { }

    UnMapIt(&LoadedImage);

    SetLastError(rc);

    return(rc == ERROR_SUCCESS ? TRUE : FALSE);
}


BOOL
IMAGEAPI
ImageRemoveCertificate(
    IN HANDLE       FileHandle,
    IN DWORD        Index
    )

/*++

Routine Description:

    Remove a certificate from an image.

Arguments:

    FileHandle  -   Handle to the file in question.  The file should be opened
                    with at least GENERIC_WRITE access.

    Index       -   The index to remove from the image.

Return Value:

    TRUE    - Successful

    FALSE   - There was some error.  Call GetLastError() for more information.

--*/

{
    LOADED_IMAGE    LoadedImage;
    LPWIN_CERTIFICATE CurrentCert;
    DWORD           rc;
    DWORD           OldCertLength;

    if (MapIt(FileHandle, &LoadedImage, MAP_READWRITE) == FALSE) {
        // Unable to map the image.
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    rc = ERROR_INVALID_PARAMETER;

    __try {

        if (FindCertificate(&LoadedImage, Index, &CurrentCert) == FALSE) {
            __leave;
        }

        OldCertLength = CurrentCert->dwLength;
        OldCertLength = (OldCertLength + 7) & ~7;           // The disk size is actually a multiple of 8

        memmove(CurrentCert,
                ((PCHAR)CurrentCert) + OldCertLength,
                (size_t)(LoadedImage.SizeOfImage - (((DWORD_PTR)CurrentCert) - (DWORD_PTR)LoadedImage.MappedAddress) - OldCertLength));

        if (LoadedImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            ((PIMAGE_NT_HEADERS32)LoadedImage.FileHeader)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size -= OldCertLength;
        } else {
            ((PIMAGE_NT_HEADERS64)LoadedImage.FileHeader)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size -= OldCertLength;
        }

        LoadedImage.SizeOfImage -= OldCertLength;

        rc = ERROR_SUCCESS;

    } __except(EXCEPTION_EXECUTE_HANDLER) { }

    UnMapIt(&LoadedImage);

    SetLastError(rc);

    return(rc == ERROR_SUCCESS ? TRUE : FALSE);
}


BOOL
IMAGEAPI
ImageEnumerateCertificates(
    IN  HANDLE      FileHandle,
    IN  WORD        TypeFilter,
    OUT PDWORD      CertificateCount,
    IN OUT PDWORD   Indices OPTIONAL,
    IN  DWORD       IndexCount  OPTIONAL
    )

/*++

Routine Description:

    Enumerate the certificates in an image.

Arguments:

    FileHandle          -   Handle to the file in question.  The file should be opened
                            with at least GENERIC_READ access.

    TypeFilter          -   The filter to apply when enumertating the certificates.
                            Valid values are:

                                CERT_SECTION_TYPE_ANY - Enumerate all certificate types
                                                        in the image.

    CertificateCount    -   How many certificates are in the image.

    Indices             -   An array of indexes that match the filter type.

    IndexCount          -   The number of indexes in the indices array.

Return Value:

    TRUE    - Successful

    FALSE   - There was some error.  Call GetLastError() for more information.

--*/

{
    LOADED_IMAGE LoadedImage;
    BOOL    rc;
    PIMAGE_DATA_DIRECTORY pDataDir;
    LPWIN_CERTIFICATE CurrentCert, LastCert;
    PIMAGE_OPTIONAL_HEADER32 OptionalHeader32 = NULL;
    PIMAGE_OPTIONAL_HEADER64 OptionalHeader64 = NULL;

    if (MapIt(FileHandle, &LoadedImage, MAP_READONLY) == FALSE) {
        // Unable to map the image.
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    rc = ERROR_INVALID_PARAMETER;
    __try {
        if (LoadedImage.fDOSImage) {
            __leave;
        }

        if (LoadedImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            pDataDir = &((PIMAGE_NT_HEADERS32)(LoadedImage.FileHeader))->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
        } else if (LoadedImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
            pDataDir = &((PIMAGE_NT_HEADERS64)(LoadedImage.FileHeader))->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
        } else {
            __leave;
        }

        if ((pDataDir->VirtualAddress + pDataDir->Size) > LoadedImage.SizeOfImage) {
            *CertificateCount = 0;
            __leave;
        }

        if (!pDataDir->VirtualAddress || !pDataDir->Size) {
            *CertificateCount = 0;
        } else {

            DWORD MatchedIndex = 0;
            DWORD ActualIndex = 0;

            CurrentCert = (LPWIN_CERTIFICATE)((DWORD_PTR)LoadedImage.MappedAddress + pDataDir->VirtualAddress);
            LastCert = (LPWIN_CERTIFICATE)((DWORD_PTR)CurrentCert + pDataDir->Size);

            while (CurrentCert < LastCert ) {
                if ((TypeFilter == CERT_SECTION_TYPE_ANY) || (TypeFilter == CurrentCert->wCertificateType)) {
                    if (Indices && (MatchedIndex < IndexCount)) {
                        Indices[MatchedIndex] = ActualIndex;
                    }
                    MatchedIndex++;
                }

                ActualIndex++;
                CurrentCert = (LPWIN_CERTIFICATE)((((DWORD_PTR)CurrentCert + CurrentCert->dwLength) +7) & ~7);
            }

            *CertificateCount = MatchedIndex;
        }

        rc = ERROR_SUCCESS;

    } __except(EXCEPTION_EXECUTE_HANDLER) { }

    UnMapIt(&LoadedImage);

    SetLastError(rc);

    return(rc == ERROR_SUCCESS ? TRUE : FALSE);
}


BOOL
IMAGEAPI
ImageGetCertificateData(
    IN  HANDLE              FileHandle,
    IN  DWORD               CertificateIndex,
    OUT LPWIN_CERTIFICATE   Certificate,
    IN OUT PDWORD           RequiredLength
    )

/*++

Routine Description:

    Given a specific certificate index, retrieve the certificate data.

Arguments:

    FileHandle          -   Handle to the file in question.  The file should be opened
                            with at least GENERIC_READ access.

    CertificateIndex    -   Index to retrieve

    Certificate         -   Output buffer where the certificate is to be stored.

    RequiredLength      -   Size of the certificate buffer (input).  On return, is
                            set to the actual certificate length.  NULL can be used
                            to determine the size of a certificate.

Return Value:

    TRUE    - Successful

    FALSE   - There was some error.  Call GetLastError() for more information.

--*/

{
    LOADED_IMAGE LoadedImage;
    DWORD   ErrorCode;

    LPWIN_CERTIFICATE ImageCert;

    if (MapIt(FileHandle, &LoadedImage, MAP_READONLY) == FALSE) {
        // Unable to map the image.
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    ErrorCode = ERROR_INVALID_PARAMETER;
    __try {
        if (FindCertificate(&LoadedImage, CertificateIndex, &ImageCert) == FALSE) {
            __leave;
        }

        if (*RequiredLength < ImageCert->dwLength) {
            *RequiredLength = ImageCert->dwLength;
            ErrorCode = ERROR_INSUFFICIENT_BUFFER;
        } else {
            memcpy(Certificate, (PUCHAR)ImageCert, ImageCert->dwLength);
            ErrorCode = ERROR_SUCCESS;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) { }

    UnMapIt(&LoadedImage);

    SetLastError(ErrorCode);
    return(ErrorCode == ERROR_SUCCESS ? TRUE: FALSE);
}


BOOL
IMAGEAPI
ImageGetCertificateHeader(
    IN      HANDLE              FileHandle,
    IN      DWORD               CertificateIndex,
    IN OUT  LPWIN_CERTIFICATE   CertificateHeader
    )

/*++

Routine Description:

    Given a specific certificate index, retrieve the certificate data.

Arguments:

    FileHandle          -   Handle to the file in question.  The file should be opened
                            with at least GENERIC_READ access.

    CertificateIndex    -   Index to retrieve.

    CertificateHeader   -   Pointer to a WIN_CERTIFICATE to fill in.

Return Value:

    TRUE    - Success

    FALSE   - There was some error.  Call GetLastError() for more information.

--*/

{
    LOADED_IMAGE LoadedImage;
    LPWIN_CERTIFICATE ImageCert;
    BOOL    rc;

    if (MapIt(FileHandle, &LoadedImage, MAP_READONLY) == FALSE) {
        // Unable to map the image.
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (FindCertificate(&LoadedImage, CertificateIndex, &ImageCert) == FALSE) {
        rc = FALSE;
        goto Exit;
    }

    __try {
        memcpy(CertificateHeader, ImageCert, sizeof(WIN_CERTIFICATE));
        rc = TRUE;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        rc = FALSE;
    }
Exit:

    UnMapIt(&LoadedImage);

    if (rc == FALSE) {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\debug.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    checksum.c

Abstract:

    This module implements functions for splitting debugging information
    out of an image file and into a separate .DBG file.

Author:

    Steven R. Wood (stevewo) 4-May-1993

Revision History:

--*/

#include <private.h>
#include <symbols.h>

API_VERSION ApiVersion = { (VER_PRODUCTVERSION_W >> 8), (VER_PRODUCTVERSION_W & 0xff), API_VERSION_NUMBER, 0 };

///////////////////////////////////////////////////////////////////////
//
// DON'T UPDATE THIS VERSION NUMBER!!!!
//
// If the app does not call ImagehlpApiVersionEx, always assume
// that it is for NT 4.0.
//
API_VERSION AppVersion = { 4, 0, 5, 0 };
///////////////////////////////////////////////////////////////////////

#define ROUNDUP(x, y) ((x + (y-1)) & ~(y-1))

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#if !defined(_WIN64)

PIMAGE_DEBUG_INFORMATION
IMAGEAPI
MapDebugInformation(
    HANDLE FileHandle,
    LPSTR FileName,
    LPSTR SymbolPath,
    ULONG ImageBase
    )

// Here's what we're going to try.  MapDebugInformation was only
// documented as returning COFF symbolic and every user I can find
// in the tree uses COFF exclusively.  Rather than try to make this
// api do everything possible, let's just leave it as a COFF only thing.

// The new debug info api (ImgHlpFindDebugInfo) will be internal only.

{
    PIMAGE_DEBUG_INFORMATION pIDI;
    CHAR szName[_MAX_FNAME];
    CHAR szExt[_MAX_EXT];
    PIMGHLP_DEBUG_DATA pIDD;
    PPIDI              pPIDI;
    DWORD sections;
    MODULE_ENTRY       mi;
    BOOL               SymbolsLoaded;
    HANDLE             hProcess;
    LPSTR sz;
    HANDLE hdb;
    DWORD dw;
    hProcess = GetCurrentProcess();

    pIDD = ImgHlpFindDebugInfo(NULL, FileHandle, FileName, SymbolPath, ImageBase, NO_PE64_IMAGES);
    if (!pIDD)
        return NULL;

    pPIDI = MemAlloc(sizeof(PIDI));
    ZeroMemory(pPIDI, sizeof(PIDI));
    if (!pPIDI)
        return NULL;
    pIDI = &pPIDI->idi;
    pPIDI->hdr.pIDD = pIDD;

    pIDI->ReservedSize            = sizeof(IMAGE_DEBUG_INFORMATION);
    pIDI->ReservedMachine         = pIDD->Machine;
    pIDI->ReservedCharacteristics = (USHORT)pIDD->Characteristics;
    pIDI->ReservedCheckSum        = pIDD->CheckSum;
    pIDI->ReservedTimeDateStamp   = pIDD->TimeDateStamp;
    pIDI->ReservedRomImage        = pIDD->fROM;

    // read info

    InitializeListHead( &pIDI->List );
    pIDI->ImageBase = (ULONG)pIDD->ImageBaseFromImage;

    pIDI->ImageFilePath = MemAlloc(strlen(pIDD->ImageFilePath)+1);
    if (pIDI->ImageFilePath) {
        strcpy( pIDI->ImageFilePath, pIDD->ImageFilePath );
    }

    pIDI->ImageFileName = MemAlloc(strlen(pIDD->OriginalImageFileName)+1);
    if (pIDI->ImageFileName) {
        strcpy(pIDI->ImageFileName, pIDD->OriginalImageFileName);
    }

    if (pIDD->pMappedCoff) {
        pIDI->CoffSymbols = MemAlloc(pIDD->cMappedCoff);
        if (pIDI->CoffSymbols) {
            memcpy(pIDI->CoffSymbols, pIDD->pMappedCoff, pIDD->cMappedCoff);
        }
        pIDI->SizeOfCoffSymbols = pIDD->cMappedCoff;
    }

    if (pIDD->pFpo) {
        pIDI->ReservedNumberOfFpoTableEntries = pIDD->cFpo;
        pIDI->ReservedFpoTableEntries = (PFPO_DATA)pIDD->pFpo;
    }

    pIDI->SizeOfImage = pIDD->SizeOfImage;

    if (pIDD->DbgFilePath && *pIDD->DbgFilePath) {
        pIDI->ReservedDebugFilePath = MemAlloc(strlen(pIDD->DbgFilePath)+1);
        if (pIDI->ReservedDebugFilePath) {
            strcpy(pIDI->ReservedDebugFilePath, pIDD->DbgFilePath);
        }
    }

    if (pIDD->pMappedCv) {
        pIDI->ReservedCodeViewSymbols       = pIDD->pMappedCv;
        pIDI->ReservedSizeOfCodeViewSymbols = pIDD->cMappedCv;
    }

    // for backwards compatibility
    if (pIDD->ImageMap) {
        sections = (DWORD)((char *)pIDD->pCurrentSections - (char *)pIDD->ImageMap);
        pIDI->ReservedMappedBase = MapItRO(pIDD->ImageFileHandle);
        if (pIDI->ReservedMappedBase) {
            pIDI->ReservedSections = (PIMAGE_SECTION_HEADER)pIDD->pCurrentSections;
            pIDI->ReservedNumberOfSections = pIDD->cCurrentSections;
            if (pIDD->ddva) {
                pIDI->ReservedDebugDirectory = (PIMAGE_DEBUG_DIRECTORY)((PCHAR)pIDI->ReservedMappedBase + pIDD->ddva);
                pIDI->ReservedNumberOfDebugDirectories = pIDD->cdd;
            }
        }
    }

    return pIDI;
}

BOOL
UnmapDebugInformation(
    PIMAGE_DEBUG_INFORMATION pIDI
    )
{
    PPIDI pPIDI;

    if (!pIDI)
        return TRUE;

    if (pIDI->ImageFileName){
        MemFree(pIDI->ImageFileName);
    }

    if (pIDI->ImageFilePath) {
        MemFree(pIDI->ImageFilePath);
    }

    if (pIDI->ReservedDebugFilePath) {
        MemFree(pIDI->ReservedDebugFilePath);
    }

    if (pIDI->CoffSymbols) {
        MemFree(pIDI->CoffSymbols);
    }

    if (pIDI->ReservedMappedBase) {
        UnmapViewOfFile(pIDI->ReservedMappedBase);
    }

    pPIDI = (PPIDI)(PCHAR)((PCHAR)pIDI - sizeof(PIDI_HEADER));
    ImgHlpReleaseDebugInfo(pPIDI->hdr.pIDD, IMGHLP_FREE_ALL);
    MemFree(pPIDI);

    return TRUE;
}

#endif


LPSTR
ExpandPath(
    LPSTR lpPath
    )
{
    LPSTR   p, newpath, p1, p2, p3;
    CHAR    envvar[MAX_PATH];
    CHAR    envstr[MAX_PATH];
    ULONG   i, PathMax;

    if (!lpPath) {
        return(NULL);
    }

    p = lpPath;
    PathMax = strlen(lpPath) + MAX_PATH + 1;
    p2 = newpath = (LPSTR) MemAlloc( PathMax );

    if (!newpath) {
        return(NULL);
    }

    while( p && *p) {
        if (*p == '%') {
            i = 0;
            p++;
            while (p && *p && *p != '%') {
                envvar[i++] = *p++;
            }
            p++;
            envvar[i] = '\0';
            p1 = envstr;
            *p1 = 0;
            GetEnvironmentVariable( envvar, p1, MAX_PATH );
            while (p1 && *p1) {
                *p2++ = *p1++;
                if (p2 >= newpath + PathMax) {
                    PathMax += MAX_PATH;
                    p3 = MemReAlloc(newpath, PathMax);
                    if (!p3) {
                        MemFree(newpath);
                        return(NULL);
                    } else {
                        p2 = p3 + (p2 - newpath);
                        newpath = p3;
                    }
                }
            }
        }
        *p2++ = *p++;
        if (p2 >= newpath + PathMax) {
            PathMax += MAX_PATH;
            p3 = MemReAlloc(newpath, PathMax);
            if (!p3) {
                MemFree(newpath);
                return(NULL);
            } else {
                p2 = p3 + (p2 - newpath);
                newpath = p3;
            }
        }
    }
    *p2 = '\0';

    return newpath;
}


BOOL
IMAGEAPI
FindFileInSearchPath(
    HANDLE hprocess,
    LPSTR  SearchPath,
    LPSTR  FileName,
    DWORD  one,
    DWORD  two,
    DWORD  three,
    LPSTR  FilePath
    )
{
    PPROCESS_ENTRY  ProcessEntry;
    char path[MAX_PATH];
    char szpath[MAX_PATH * 4];
    LPSTR emark;
    LPSTR spath;

    *FilePath = 0;

    // setup local copy of the symbol path

    *szpath = 0;

    if (!SearchPath & !*SearchPath) {
        if (hprocess) {
            ProcessEntry = FindProcessEntry(hprocess);
            if (ProcessEntry && ProcessEntry->SymbolSearchPath) {
                strcpy(szpath, ProcessEntry->SymbolSearchPath);
            }
        }
    } else {
        strcpy(szpath, SearchPath);
    }

    if (!*szpath) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    spath = szpath;

    // for each node in the search path, look
    // for the file, or for it's symsrv entry

    do {
        emark = strchr(spath, ';');
        
        if (emark) {
            *emark = 0;
        }
 
        if (!_strnicmp(spath, "SYMSRV*", 7)) {

            GetSymbolFileFromServer(spath, 
                                    FileName,
                                    one,
                                    two,
                                    three,
                                    FilePath);
            if (*FilePath) 
                break;
                
        } else {

            strcpy(path, spath);
            EnsureTrailingBackslash(path);
            strcat(path, FileName);
            if (GetFileAttributes(path) != 0xFFFFFFFF) {
                strcpy(FilePath, path);
                break;
            }
        }

        if (emark) {
            *emark = ';';
             emark++;
        }
        spath = emark;
    } while (emark);

    return (*FilePath) ? TRUE : FALSE;
}


HANDLE
IMAGEAPI
FindExecutableImage(
    LPSTR FileName,
    LPSTR SymbolPath,
    LPSTR ImageFilePath
    )
{
    return FindExecutableImageEx(FileName, SymbolPath, ImageFilePath, NULL, NULL);
}


HANDLE
IMAGEAPI
FindExecutableImageEx(
    LPSTR FileName,
    LPSTR SymbolPath,
    LPSTR ImageFilePath,
    PFIND_EXE_FILE_CALLBACK Callback,
    PVOID CallerData
    )
{
    LPSTR Start, End;
    HANDLE FileHandle = NULL;
    UCHAR DirectoryPath[ MAX_PATH ];
    LPSTR NewSymbolPath = NULL;

    __try {
        __try {
            NewSymbolPath = ExpandPath(SymbolPath);

            if (GetFullPathName( FileName, MAX_PATH, ImageFilePath, &Start )) {
                DPRINTF(NULL, "FindExecutableImageEx-> Looking for %s... ", ImageFilePath);
                FileHandle = CreateFile( ImageFilePath,
                                         GENERIC_READ,
                                         OSVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT ? (FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE) : (FILE_SHARE_READ | FILE_SHARE_WRITE),
                                         NULL,
                                         OPEN_EXISTING,
                                         0,
                                         NULL
                                       );

                if (FileHandle != INVALID_HANDLE_VALUE) {
                    if (Callback) {
                        if (!Callback(FileHandle, ImageFilePath, CallerData)) {
                            EPRINTF(NULL, "mismatched timestamp\n");
                            CloseHandle(FileHandle);
                            FileHandle = INVALID_HANDLE_VALUE;
                        }
                    }
                    if (FileHandle != INVALID_HANDLE_VALUE) {
                        EPRINTF(NULL, "OK\n");
                        MemFree( NewSymbolPath );
                        return FileHandle;
                    }
                } else {
                    EPRINTF(NULL, "no file\n");
                }
            }

            Start = NewSymbolPath;
            while (Start && *Start != '\0') {
                if (End = strchr( Start, ';' )) {
                    int Len = (int)(End - Start);
                    Len = min(Len, sizeof(DirectoryPath)-1);

                    strncpy( (PCHAR) DirectoryPath, Start, Len );
                    DirectoryPath[ Len ] = '\0';
                    End += 1;
                } else {
                    strcpy( (PCHAR) DirectoryPath, Start );
                }

                if (!_strnicmp(DirectoryPath, "SYMSRV*", 7)) {
                    goto next;
                }

                DPRINTF(NULL, "FindExecutableImageEx-> Searching %s for %s... ", DirectoryPath, FileName);
                if (SearchTreeForFile( (PCHAR) DirectoryPath, FileName, ImageFilePath )) {
                    EPRINTF(NULL, "found\n");
                    DPRINTF(NULL, "FindExecutableImageEx-> Opening %s... ", ImageFilePath);
                    FileHandle = CreateFile( ImageFilePath,
                                             GENERIC_READ,
                                             OSVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT ? (FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE) : (FILE_SHARE_READ | FILE_SHARE_WRITE),
                                             NULL,
                                             OPEN_EXISTING,
                                             0,
                                             NULL
                                           );

                    if (FileHandle != INVALID_HANDLE_VALUE) {
                        if (Callback) {
                            if (!Callback(FileHandle, ImageFilePath, CallerData)) {
                                EPRINTF(NULL, "mismatched timestamp\n");
                                CloseHandle(FileHandle);
                                FileHandle = INVALID_HANDLE_VALUE;
                            }
                        }
                        if (FileHandle != INVALID_HANDLE_VALUE) {
                            EPRINTF(NULL, "OK\n");
                            MemFree( NewSymbolPath );
                            return FileHandle;
                        }
                    } else {
                        EPRINTF(NULL, "no file\n");
                    }
                } else {
                    EPRINTF(NULL, "no file\n");
                }

next:
                Start = End;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            SetLastError(ERROR_INVALID_PARAMETER);
        }

        ImageFilePath[0] = '\0';

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    if (FileHandle) {
        CloseHandle(FileHandle);
    }

    if (NewSymbolPath) {
        MemFree( NewSymbolPath );
    }

    return NULL;
}


HANDLE
IMAGEAPI
FindDebugInfoFile(
    LPSTR FileName,
    LPSTR SymbolPath,
    LPSTR DebugFilePath
    )
{
    return FindDebugInfoFileEx(FileName, SymbolPath, DebugFilePath, NULL, NULL);
}


HANDLE
IMAGEAPI
FindDebugInfoFileEx(
    IN  LPSTR FileName,
    IN  LPSTR SymbolPath,
    OUT LPSTR DebugFilePath,
    IN  PFIND_DEBUG_FILE_CALLBACK Callback,
    IN  PVOID CallerData
    )
{
    return fnFindDebugInfoFileEx(FileName,
                                 SymbolPath,
                                 DebugFilePath,
                                 Callback,
                                 CallerData,
                                 0);
}


HANDLE
IMAGEAPI
fnFindDebugInfoFileEx(
    IN  LPSTR FileName,
    IN  LPSTR SymbolPath,
    OUT LPSTR DebugFilePath,
    IN  PFIND_DEBUG_FILE_CALLBACK Callback,
    IN  PVOID CallerData,
    IN  DWORD flag
    )
/*++

Routine Description:

 The rules are:
   Look for
     1. <SymbolPath>\Symbols\<ext>\<filename>.dbg
     3. <SymbolPath>\<ext>\<filename>.dbg
     5. <SymbolPath>\<filename>.dbg
     7. <FileNamePath>\<filename>.dbg

Arguments:
    FileName - Supplies a file name in one of three forms: fully qualified,
                <ext>\<filename>.dbg, or just filename.dbg
    SymbolPath - semi-colon delimited

    DebugFilePath -

    Callback - May be NULL. Callback that indicates whether the Symbol file is valid, or whether
        the function should continue searching for another Symbol file.
        The callback returns TRUE if the Symbol file is valid, or FALSE if the function should
        continue searching.

    CallerData - May be NULL. Data passed to the callback.

    Flag - indicates that PDBs shouldn't be searched for

Return Value:

  The name of the Symbol file (either .dbg or .sym) and a handle to that file.

--*/
{
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    LPSTR ExpSymbolPath = NULL, SymPathStart, PathEnd;
    DWORD ShareAttributes, cnt;
    LPSTR InitialPath, Sub1, Sub2, FileExt;
    CHAR FilePath[_MAX_PATH + 1];
    CHAR Drive[_MAX_DRIVE], Dir[_MAX_DIR], SubDirPart[_MAX_DIR], FilePart[_MAX_FNAME], Ext[_MAX_EXT];
    CHAR *ExtDir;
    DWORD i;
    PIMGHLP_DEBUG_DATA pIDD;
    BOOL  found = FALSE;
    BOOL  symsrv = TRUE;
    DWORD err = 0;

    if (OSVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        ShareAttributes = (FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE);
    } else {
        ShareAttributes = (FILE_SHARE_READ | FILE_SHARE_WRITE);
    }

    __try {
        *DebugFilePath = '\0';

        // Step 1.  What do we have?
        _splitpath(FileName, Drive, Dir, FilePart, Ext);

        if (!_stricmp(Ext, ".dbg")) {
            // We got a filename of the form: ext\filename.dbg.  Dir holds the extension already.
            ExtDir = Dir;
        } else {
            // Otherwise, skip the period and null out the Dir.
            ExtDir = CharNext(Ext);
        }

        ExpSymbolPath = ExpandPath(SymbolPath);
        SymPathStart = ExpSymbolPath;
        cnt = 0;

        do {
            if (PathEnd = strchr( SymPathStart, ';' )) {
                *PathEnd = '\0';
            }

            if (!_strnicmp(SymPathStart, "SYMSRV*", 7)) {

                *DebugFilePath = 0;
                if (symsrv && CallerData) {
                    strcpy(FilePath, FilePart);
                    strcat(FilePath, ".dbg");
                    pIDD = (PIMGHLP_DEBUG_DATA)CallerData;
                    GetSymbolFileFromServer(SymPathStart,
                                            FilePath,
                                            pIDD->TimeDateStamp,
                                            pIDD->SizeOfImage,
                                            0,
                                            DebugFilePath);
                    symsrv = FALSE;
                }

            } else {

                switch (cnt) {

                case 0: // <SymbolPath>\symbols\<ext>\<filename>.ext
                    InitialPath = SymPathStart;
                    Sub1 = "symbols";
                    Sub2 = ExtDir;
                    break;

                case 1: // <SymbolPath>\<ext>\<filename>.ext
                    InitialPath = SymPathStart;
                    Sub1 = "";
                    Sub2 = ExtDir;
                    break;

                case 2: // <SymbolPath>\<filename>.ext
                    InitialPath = SymPathStart;
                    Sub1 = "";
                    Sub2 = "";
                    break;

                case 3: // <FileNamePath>\<filename>.ext - A.K.A. what was passed to us
                    InitialPath = Drive;
                    Sub1 = "";
                    Sub2 = Dir;
                    // this stops us from checking out everything in the sympath
                    cnt++;
                    break;
                }

               // build fully-qualified filepath to look for

                strcpy(FilePath, InitialPath);
                EnsureTrailingBackslash(FilePath);
                strcat(FilePath, Sub1);
                EnsureTrailingBackslash(FilePath);
                strcat(FilePath, Sub2);
                EnsureTrailingBackslash(FilePath);
                strcat(FilePath, FilePart);

                strcpy(DebugFilePath, FilePath);
                strcat(DebugFilePath, ".dbg");
            }

            // try to open the file

            if (*DebugFilePath) {
                DPRINTF(NULL, "FindDebugInfoFileEx-> Looking for %s... ", DebugFilePath);
                FileHandle = CreateFile(DebugFilePath,
                                        GENERIC_READ,
                                        ShareAttributes,
                                        NULL,
                                        OPEN_EXISTING,
                                        0,
                                        NULL);

                // if the file opens, bail from this loop

                if (FileHandle != INVALID_HANDLE_VALUE) {
                    found = TRUE;
                    if (!Callback) {
                        break;
                    } else if (Callback(FileHandle, DebugFilePath, CallerData)) {
                        break;
                    } else {
                        EPRINTF(NULL, "mismatched timestamp\n");
                        CloseHandle(FileHandle);
                        FileHandle = INVALID_HANDLE_VALUE;
                    }
                } else {
                    err = GetLastError();
                    switch (err)
                    {
                    case ERROR_FILE_NOT_FOUND:
                        EPRINTF(NULL, "file not found\n");
                        break;
                    case ERROR_PATH_NOT_FOUND:
                        EPRINTF(NULL, "path not found\n");
                        break;
                    default:
                        EPRINTF(NULL, "file error 0x%x\n", err);
                        break;
                    }
                }
                // if file is open, bail from this loop too - else continue

                if (FileHandle != INVALID_HANDLE_VALUE)
                    break;
            }

            // go to next item in the sympath

            if (PathEnd) {
                *PathEnd = ';';
                SymPathStart = PathEnd + 1;
                symsrv = TRUE;
            } else {
                SymPathStart = ExpSymbolPath;
                cnt++;
            }
        } while (cnt < 4);

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        if (FileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle(FileHandle);
        }
        FileHandle = INVALID_HANDLE_VALUE;
    }

    if (ExpSymbolPath) {
        MemFree(ExpSymbolPath);
    }

    if (FileHandle == INVALID_HANDLE_VALUE) {
        FileHandle = NULL;
        DebugFilePath[0] = '\0';
    } else {
        EPRINTF(NULL, "OK\n");
    }

    if (!FileHandle                 // if we didn't get the right file...
        && found                    // but we found some file...
        && (flag & fdifRECURSIVE))  // and we were told to run recursively...
    {
        // try again without timestamp checking
        FileHandle = fnFindDebugInfoFileEx(FileName,
                                           SymbolPath,
                                           FilePath,
                                           NULL,
                                           0,
                                           flag);
        if (FileHandle && FileHandle != INVALID_HANDLE_VALUE)
            strcpy(DebugFilePath, FilePath);
    }

    return FileHandle;
}


BOOL
GetImageNameFromMiscDebugData(
    IN  HANDLE FileHandle,
    IN  PVOID MappedBase,
    IN  PIMAGE_NT_HEADERS32 NtHeaders,
    IN  PIMAGE_DEBUG_DIRECTORY DebugDirectories,
    IN  ULONG NumberOfDebugDirectories,
    OUT LPSTR ImageFilePath
    )
{
    IMAGE_DEBUG_MISC TempMiscData;
    PIMAGE_DEBUG_MISC DebugMiscData;
    ULONG BytesToRead, BytesRead;
    BOOLEAN FoundImageName;
    LPSTR ImageName;
    PIMAGE_OPTIONAL_HEADER32 OptionalHeader32 = NULL;
    PIMAGE_OPTIONAL_HEADER64 OptionalHeader64 = NULL;

    while (NumberOfDebugDirectories) {
        if (DebugDirectories->Type == IMAGE_DEBUG_TYPE_MISC) {
            break;
        } else {
            DebugDirectories += 1;
            NumberOfDebugDirectories -= 1;
        }
    }

    if (NumberOfDebugDirectories == 0) {
        return FALSE;
    }

    OptionalHeadersFromNtHeaders(NtHeaders, &OptionalHeader32, &OptionalHeader64);

    if ((OPTIONALHEADER(MajorLinkerVersion) < 3) &&
        (OPTIONALHEADER(MinorLinkerVersion) < 36) ) {
        BytesToRead = FIELD_OFFSET( IMAGE_DEBUG_MISC, Reserved );
    } else {
        BytesToRead = FIELD_OFFSET( IMAGE_DEBUG_MISC, Data );
    }

    DebugMiscData = NULL;
    FoundImageName = FALSE;
    if (MappedBase == 0) {
        if (SetFilePointer( FileHandle,
                            DebugDirectories->PointerToRawData,
                            NULL,
                            FILE_BEGIN
                          ) == DebugDirectories->PointerToRawData
           ) {
            if (ReadFile( FileHandle,
                          &TempMiscData,
                          BytesToRead,
                          &BytesRead,
                          NULL
                        ) &&
                BytesRead == BytesToRead
               ) {
                DebugMiscData = &TempMiscData;
                if (DebugMiscData->DataType == IMAGE_DEBUG_MISC_EXENAME) {
                    BytesToRead = DebugMiscData->Length - BytesToRead;
                    BytesToRead = BytesToRead > MAX_PATH ? MAX_PATH : BytesToRead;
                    if (ReadFile( FileHandle,
                                  ImageFilePath,
                                  BytesToRead,
                                  &BytesRead,
                                  NULL
                                ) &&
                        BytesRead == BytesToRead
                       ) {
                            FoundImageName = TRUE;
                    }
                }
            }
        }
    } else {
        DebugMiscData = (PIMAGE_DEBUG_MISC)((PCHAR)MappedBase +
                                            DebugDirectories->PointerToRawData );
        if (DebugMiscData->DataType == IMAGE_DEBUG_MISC_EXENAME) {
            ImageName = (PCHAR)DebugMiscData + BytesToRead;
            BytesToRead = DebugMiscData->Length - BytesToRead;
            BytesToRead = BytesToRead > MAX_PATH ? MAX_PATH : BytesToRead;
            if (*ImageName != '\0' ) {
                memcpy( ImageFilePath, ImageName, BytesToRead );
                FoundImageName = TRUE;
            }
        }
    }

    return FoundImageName;
}



#define MAX_DEPTH 32

BOOL
IMAGEAPI
SearchTreeForFile(
    LPSTR RootPath,
    LPSTR InputPathName,
    LPSTR OutputPathBuffer
    )
{
    // UnSafe...

    PCHAR FileName;
    PUCHAR Prefix = (PUCHAR) "";
    CHAR PathBuffer[ MAX_PATH ];
    ULONG Depth;
    PCHAR PathTail[ MAX_DEPTH ];
    PCHAR FindHandle[ MAX_DEPTH ];
    LPWIN32_FIND_DATA FindFileData;
    UCHAR FindFileBuffer[ MAX_PATH + sizeof( WIN32_FIND_DATA ) ];
    BOOL Result;

    strcpy( PathBuffer, RootPath );
    FileName = InputPathName;
    while (*InputPathName) {
        if (*InputPathName == ':' || *InputPathName == '\\' || *InputPathName == '/') {
            FileName = ++InputPathName;
        } else {
            InputPathName = CharNext(InputPathName);
        }
    }
    FindFileData = (LPWIN32_FIND_DATA)FindFileBuffer;
    Depth = 0;
    Result = FALSE;
    while (TRUE) {
startDirectorySearch:
        PathTail[ Depth ] = strchr( PathBuffer, '\0' );
        if (PathTail[ Depth ] > PathBuffer
            && *CharPrev(PathBuffer, PathTail[ Depth ]) != '\\') {
            *(PathTail[ Depth ])++ = '\\';
        }

        strcpy( PathTail[ Depth ], "*.*" );
        FindHandle[ Depth ] = (PCHAR) FindFirstFile( PathBuffer, FindFileData );

        if (FindHandle[ Depth ] == INVALID_HANDLE_VALUE) {
            return FALSE;
        }

        do {
            if (FindFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                if (strcmp( FindFileData->cFileName, "." ) &&
                    strcmp( FindFileData->cFileName, ".." ) &&
                    Depth < MAX_DEPTH
                   ) {
                        strcpy(PathTail[ Depth ], FindFileData->cFileName);
                        strcat(PathTail[ Depth ], "\\");

                        Depth++;
                        goto startDirectorySearch;
                }
            } else
            if (!_stricmp( FindFileData->cFileName, FileName )) {
                strcpy( PathTail[ Depth ], FindFileData->cFileName );
                strcpy( OutputPathBuffer, PathBuffer );
                Result = TRUE;
            }

restartDirectorySearch:
            if (Result) {
                break;
            }
        }
        while (FindNextFile( FindHandle[ Depth ], FindFileData ));
        FindClose( FindHandle[ Depth ] );

        if (Depth == 0) {
            break;
        }

        Depth--;
        goto restartDirectorySearch;
    }

    return Result;
}


BOOL
IMAGEAPI
MakeSureDirectoryPathExists(
    LPCSTR DirPath
    )
{
    LPSTR p, DirCopy;
    DWORD dw;

    // Make a copy of the string for editing.

    __try {
        DirCopy = (LPSTR) MemAlloc(strlen(DirPath) + 1);

        if (!DirCopy) {
            return FALSE;
        }

        strcpy(DirCopy, DirPath);

        p = DirCopy;

        //  If the second character in the path is "\", then this is a UNC
        //  path, and we should skip forward until we reach the 2nd \ in the path.

        if ((*p == '\\') && (*(p+1) == '\\')) {
            p++;            // Skip over the first \ in the name.
            p++;            // Skip over the second \ in the name.

            //  Skip until we hit the first "\" (\\Server\).

            while (*p && *p != '\\') {
                p = CharNext(p);
            }

            // Advance over it.

            if (*p) {
                p++;
            }

            //  Skip until we hit the second "\" (\\Server\Share\).

            while (*p && *p != '\\') {
                p = CharNext(p);
            }

            // Advance over it also.

            if (*p) {
                p++;
            }

        } else
        // Not a UNC.  See if it's <drive>:
        if (*(p+1) == ':' ) {

            p++;
            p++;

            // If it exists, skip over the root specifier

            if (*p && (*p == '\\')) {
                p++;
            }
        }

        while( *p ) {
            if ( *p == '\\' ) {
                *p = '\0';
                dw = GetFileAttributes(DirCopy);
                // Nothing exists with this name.  Try to make the directory name and error if unable to.
                if ( dw == 0xffffffff ) {
                    if ( !CreateDirectory(DirCopy,NULL) ) {
                        if( GetLastError() != ERROR_ALREADY_EXISTS ) {
                            MemFree(DirCopy);
                            return FALSE;
                        }
                    }
                } else {
                    if ( (dw & FILE_ATTRIBUTE_DIRECTORY) != FILE_ATTRIBUTE_DIRECTORY ) {
                        // Something exists with this name, but it's not a directory... Error
                        MemFree(DirCopy);
                        return FALSE;
                    }
                }

                *p = '\\';
            }
            p = CharNext(p);
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        MemFree(DirCopy);
        return(FALSE);
    }

    MemFree(DirCopy);
    return TRUE;
}

LPAPI_VERSION
IMAGEAPI
ImagehlpApiVersion(
    VOID
    )
{
    //
    // don't tell old apps about the new version.  It will
    // just scare them.
    //
    return &AppVersion;
}

LPAPI_VERSION
IMAGEAPI
ImagehlpApiVersionEx(
    LPAPI_VERSION av
    )
{
    __try {
        AppVersion = *av;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
    }

    if (AppVersion.Revision < 6) {
        //
        // For older debuggers, just tell them what they want to hear.
        //
        ApiVersion = AppVersion;
    }
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\dload.c ===
#include <private.h>
#include <delayimp.h>

#ifdef BUILD_DBGHELP

HINSTANCE
MostRecentVersion(
    HINSTANCE hDllOne,
    HINSTANCE hDllTwo
);

BOOL
GetDllVersionInfo(
    HINSTANCE hinst,
    LPVOID *lpVersionInfo
    );

#define FreeLib(hDll)   \
    {if (hDll && hDll != INVALID_HANDLE_VALUE) FreeLibrary(hDll);}

#endif // #ifdef BUILD_DBGHELP

typedef struct
{
    PCHAR Name;
    FARPROC Function;
} FUNCPTRS;

#if DBG
void
OutputDBString(
    CHAR *text
    );
#endif

extern HINSTANCE hImagehlp;

#ifdef BUILD_IMAGEHLP

BOOL  IMAGEAPI FailEnumerateLoadedModules(
    IN HANDLE                         hProcess,
    IN PENUMLOADED_MODULES_CALLBACK   EnumLoadedModulesCallback,
    IN PVOID                          UserContext
    )
{ return FALSE; }

BOOL IMAGEAPI FailEnumerateLoadedModules64(
    IN HANDLE                           hProcess,
    IN PENUMLOADED_MODULES_CALLBACK64   EnumLoadedModulesCallback,
    IN PVOID                            UserContext
    )
{ return FALSE; }

HANDLE IMAGEAPI FailFindDebugInfoFile (
    PSTR FileName,
    PSTR SymbolPath,
    PSTR DebugFilePath
    )
{return NULL;}

HANDLE IMAGEAPI FailFindDebugInfoFileEx (
    PSTR FileName,
    PSTR SymbolPath,
    PSTR DebugFilePath,
    PFIND_DEBUG_FILE_CALLBACK Callback,
    PVOID CallerData
    )
{ return NULL; }

HANDLE IMAGEAPI FailFindExecutableImage(
    PSTR FileName,
    PSTR SymbolPath,
    PSTR ImageFilePath
    )
{ return NULL; }

LPAPI_VERSION IMAGEAPI FailImagehlpApiVersion(
    VOID
    )
{ return NULL; }

LPAPI_VERSION IMAGEAPI FailImagehlpApiVersionEx(
    LPAPI_VERSION AppVersion
    )
{ return NULL; }

BOOL IMAGEAPI FailMakeSureDirectoryPathExists(
    PCSTR DirPath
    )
{ return FALSE; }

#ifndef _WIN64
PIMAGE_DEBUG_INFORMATION IMAGEAPI FailMapDebugInformation(
    HANDLE FileHandle,
    PSTR FileName,
    PSTR SymbolPath,
    DWORD ImageBase
    )
{ return NULL; }
#endif

BOOL IMAGEAPI FailSearchTreeForFile(
    PSTR RootPath,
    PSTR InputPathName,
    PSTR OutputPathBuffer
    )
{ return FALSE; }

BOOL IMAGEAPI FailStackWalk(
    DWORD                             MachineType,
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME                      StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE      ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE    FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE          GetModuleBaseRoutine,
    PTRANSLATE_ADDRESS_ROUTINE        TranslateAddress
    )
{ return FALSE; }

BOOL IMAGEAPI FailStackWalk64(
    DWORD                             MachineType,
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME64                    StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBaseRoutine,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymCleanup(
    IN HANDLE hProcess
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymEnumerateModules(
    IN HANDLE                     hProcess,
    IN PSYM_ENUMMODULES_CALLBACK  EnumModulesCallback,
    IN PVOID                      UserContext
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymEnumerateModules64(
    IN HANDLE                       hProcess,
    IN PSYM_ENUMMODULES_CALLBACK64  EnumModulesCallback,
    IN PVOID                        UserContext
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymEnumerateSymbols(
    IN HANDLE                     hProcess,
    IN DWORD                      BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACK  EnumSymbolsCallback,
    IN PVOID                      UserContext
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymEnumerateSymbolsW(
    IN HANDLE                       hProcess,
    IN DWORD                        BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACKW   EnumSymbolsCallback,
    IN PVOID                        UserContext
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymEnumerateSymbols64(
    IN HANDLE                       hProcess,
    IN DWORD64                      BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACK64  EnumSymbolsCallback,
    IN PVOID                        UserContext
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymEnumerateSymbolsW64(
    IN HANDLE                       hProcess,
    IN DWORD64                      BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACK64W EnumSymbolsCallback,
    IN PVOID                        UserContext
    )
{ return FALSE; }

PVOID IMAGEAPI FailSymFunctionTableAccess(
    HANDLE  hProcess,
    DWORD   AddrBase
    )
{ return NULL; }

PVOID IMAGEAPI FailSymFunctionTableAccess64(
    HANDLE  hProcess,
    DWORD64 AddrBase
    )
{ return NULL; }

BOOL IMAGEAPI FailSymGetLineFromAddr(
    IN  HANDLE                hProcess,
    IN  DWORD                 dwAddr,
    OUT PDWORD                pdwDisplacement,
    OUT PIMAGEHLP_LINE        Line
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetLineFromAddr64(
    IN  HANDLE                  hProcess,
    IN  DWORD64                 qwAddr,
    OUT PDWORD                  pdwDisplacement,
    OUT PIMAGEHLP_LINE64        Line
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetLineFromName(
    IN     HANDLE             hProcess,
    IN     PSTR               ModuleName,
    IN     PSTR               FileName,
    IN     DWORD              dwLineNumber,
       OUT PLONG              plDisplacement,
    IN OUT PIMAGEHLP_LINE     Line
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetLineFromName64(
    IN     HANDLE               hProcess,
    IN     PSTR                 ModuleName,
    IN     PSTR                 FileName,
    IN     DWORD                dwLineNumber,
       OUT PLONG                plDisplacement,
    IN OUT PIMAGEHLP_LINE64     Line
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetLineNext(
    IN     HANDLE             hProcess,
    IN OUT PIMAGEHLP_LINE     Line
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetLineNext64(
    IN     HANDLE               hProcess,
    IN OUT PIMAGEHLP_LINE64     Line
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetLinePrev(
    IN     HANDLE             hProcess,
    IN OUT PIMAGEHLP_LINE     Line
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetLinePrev64(
    IN     HANDLE               hProcess,
    IN OUT PIMAGEHLP_LINE64     Line
    )
{ return FALSE; }

DWORD IMAGEAPI FailSymGetModuleBase(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr
    )
{ return 0; }

DWORD64 IMAGEAPI FailSymGetModuleBase64(
    IN  HANDLE              hProcess,
    IN  DWORD64             qwAddr
    )
{ return 0; }

BOOL IMAGEAPI FailSymGetModuleInfo(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr,
    OUT PIMAGEHLP_MODULE  ModuleInfo
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetModuleInfoW(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr,
    OUT PIMAGEHLP_MODULEW  ModuleInfo
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetModuleInfo64(
    IN  HANDLE                  hProcess,
    IN  DWORD64                 qwAddr,
    OUT PIMAGEHLP_MODULE64      ModuleInfo
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetModuleInfoW64(
    IN  HANDLE                  hProcess,
    IN  DWORD64                 qwAddr,
    OUT PIMAGEHLP_MODULEW64     ModuleInfo
    )
{ return FALSE; }

DWORD IMAGEAPI FailSymGetOptions(
    VOID
    )
{ return 0; }

BOOL IMAGEAPI FailSymGetSearchPath(
    IN  HANDLE          hProcess,
    OUT PSTR            SearchPath,
    IN  DWORD           SearchPathLength
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetSymFromAddr(
    IN  HANDLE            hProcess,
    IN  DWORD             dwAddr,
    OUT PDWORD            pdwDisplacement,
    OUT PIMAGEHLP_SYMBOL  Symbol
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetSymFromAddr64(
    IN  HANDLE              hProcess,
    IN  DWORD64             qwAddr,
    OUT PDWORD64            pdwDisplacement,
    OUT PIMAGEHLP_SYMBOL64  Symbol
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetSymFromName(
    IN  HANDLE            hProcess,
    IN  PSTR              Name,
    OUT PIMAGEHLP_SYMBOL  Symbol
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetSymFromName64(
    IN  HANDLE              hProcess,
    IN  PSTR                Name,
    OUT PIMAGEHLP_SYMBOL64  Symbol
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetSymNext(
    IN     HANDLE            hProcess,
    IN OUT PIMAGEHLP_SYMBOL  Symbol
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetSymNext64(
    IN     HANDLE              hProcess,
    IN OUT PIMAGEHLP_SYMBOL64  Symbol
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetSymPrev(
    IN     HANDLE            hProcess,
    IN OUT PIMAGEHLP_SYMBOL  Symbol
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymGetSymPrev64(
    IN     HANDLE              hProcess,
    IN OUT PIMAGEHLP_SYMBOL64  Symbol
    )
{ return FALSE; }

BOOL
IMAGEAPI
FailSymGetModuleInfoEx64(
   IN  HANDLE          hProcess,
   IN  DWORD64         Address,
   IN  IMAGEHLP_TYPES  TypeIn,
   IN  PBYTE           DataIn,
   IN  IMAGEHLP_TYPES  TypeOut,
   IN  OUT PULONG      SizeOut,
   IN  OUT PBYTE       DataOut
   )
{ return FALSE; }

BOOL
IMAGEAPI
FailSymGetModuleInfoEx(
   IN  HANDLE          hProcess,
   IN  DWORD           Address,
   IN  IMAGEHLP_TYPES  TypeIn,
   IN  PBYTE           DataIn,
   IN  IMAGEHLP_TYPES  TypeOut,
   IN  OUT PULONG      SizeOut,
   IN  OUT PBYTE       DataOut
   )
{ return FALSE; }

BOOL 
IMAGEAPI
FailSymGetSymbolInfo64(
   IN  HANDLE          hProcess,
   IN  DWORD64         Address,
   IN  IMAGEHLP_TYPES  TypeIn,
   IN  PBYTE           DataIn,
   IN  IMAGEHLP_TYPES  TypeOut,
   IN  OUT PULONG      SizeOut,
   IN  OUT PBYTE       DataOut
   )
{ return FALSE; }

BOOL 
IMAGEAPI
FailSymGetSymbolInfo(
   IN  HANDLE          hProcess,
   IN  DWORD           Address,
   IN  IMAGEHLP_TYPES  TypeIn,
   IN  PBYTE           DataIn,
   IN  IMAGEHLP_TYPES  TypeOut,
   IN  OUT PULONG      SizeOut,
   IN  OUT PBYTE       DataOut
   )
{ return FALSE; }

BOOL IMAGEAPI FailSymInitialize(
    IN HANDLE   hProcess,
    IN PSTR     UserSearchPath,
    IN BOOL     fInvadeProcess
    )
{ return FALSE; }

DWORD IMAGEAPI FailSymLoadModule(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD           BaseOfDll,
    IN  DWORD           SizeOfDll
    )
{ return 0; }

DWORD64 IMAGEAPI FailSymLoadModule64(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD64         BaseOfDll,
    IN  DWORD           SizeOfDll
    )
{ return 0; }

BOOL IMAGEAPI FailSymMatchFileName(
    IN  PSTR  FileName,
    IN  PSTR  Match,
    OUT PSTR *FileNameStop,
    OUT PSTR *MatchStop
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymRegisterCallback(
    IN HANDLE                      hProcess,
    IN PSYMBOL_REGISTERED_CALLBACK CallbackFunction,
    IN PVOID                       UserContext
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymRegisterCallback64(
    IN HANDLE                        hProcess,
    IN PSYMBOL_REGISTERED_CALLBACK64 CallbackFunction,
    IN ULONG64                       UserContext
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymRegisterFunctionEntryCallback(
    IN HANDLE                     hProcess,
    IN PSYMBOL_FUNCENTRY_CALLBACK CallbackFunction,
    IN PVOID                      UserContext
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymRegisterFunctionEntryCallback64(
    IN HANDLE                       hProcess,
    IN PSYMBOL_FUNCENTRY_CALLBACK64 CallbackFunction,
    IN ULONG64                      UserContext
    )
{ return FALSE; }

DWORD IMAGEAPI FailSymSetOptions(
    IN DWORD   SymOptions
    )
{ return 0; }

BOOL IMAGEAPI FailSymSetSearchPath(
    IN HANDLE           hProcess,
    IN PSTR             SearchPath
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymUnDName(
    IN  PIMAGEHLP_SYMBOL sym,               // Symbol to undecorate
    OUT PSTR             UnDecName,         // Buffer to store undecorated name in
    IN  DWORD            UnDecNameLength    // Size of the buffer
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymUnDName64(
    IN  PIMAGEHLP_SYMBOL64 sym,               // Symbol to undecorate
    OUT PSTR               UnDecName,         // Buffer to store undecorated name in
    IN  DWORD              UnDecNameLength    // Size of the buffer
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymUnloadModule(
    IN  HANDLE          hProcess,
    IN  DWORD           BaseOfDll
    )
{ return FALSE; }

BOOL IMAGEAPI FailSymUnloadModule64(
    IN  HANDLE          hProcess,
    IN  DWORD64         BaseOfDll
    )
{ return FALSE; }

#ifndef _WIN64
BOOL IMAGEAPI FailUnmapDebugInformation(
    PIMAGE_DEBUG_INFORMATION DebugInfo
    )
{ return FALSE; }
#endif

FUNCPTRS DbgHelpFailPtrs[] = {
    {"EnumerateLoadedModules",       (FARPROC)FailEnumerateLoadedModules},
    {"EnumerateLoadedModules64",     (FARPROC)FailEnumerateLoadedModules64},
    {"FindDebugInfoFile",            (FARPROC)FailFindDebugInfoFile},
    {"FindDebugInfoFileEx",          (FARPROC)FailFindDebugInfoFileEx},
    {"FindExecutableImage",          (FARPROC)FailFindExecutableImage},
    {"ImagehlpApiVersion",           (FARPROC)FailImagehlpApiVersion},
    {"ImagehlpApiVersionEx",         (FARPROC)FailImagehlpApiVersionEx},
    {"MakeSureDirectoryPathExists",  (FARPROC)FailMakeSureDirectoryPathExists},
#ifndef _WIN64
    {"MapDebugInformation",          (FARPROC)FailMapDebugInformation},
#endif
    {"SearchTreeForFile",            (FARPROC)FailSearchTreeForFile},
    {"StackWalk",                    (FARPROC)FailStackWalk},
    {"StackWalk64",                  (FARPROC)FailStackWalk64},
    {"SymCleanup",                   (FARPROC)FailSymCleanup},
    {"SymEnumerateModules",          (FARPROC)FailSymEnumerateModules},
    {"SymEnumerateModules64",        (FARPROC)FailSymEnumerateModules64},
    {"SymEnumerateSymbols",          (FARPROC)FailSymEnumerateSymbols},
    {"SymEnumerateSymbols64",        (FARPROC)FailSymEnumerateSymbols64},
    {"SymEnumerateSymbolsW",         (FARPROC)FailSymEnumerateSymbolsW},
    {"SymEnumerateSymbolsW64",       (FARPROC)FailSymEnumerateSymbolsW64},
    {"SymFunctionTableAccess",       (FARPROC)FailSymFunctionTableAccess},
    {"SymFunctionTableAccess64",     (FARPROC)FailSymFunctionTableAccess64},
    {"SymGetLineFromAddr",           (FARPROC)FailSymGetLineFromAddr},
    {"SymGetLineFromAddr64",         (FARPROC)FailSymGetLineFromAddr64},
    {"SymGetLineFromName",           (FARPROC)FailSymGetLineFromName},
    {"SymGetLineFromName64",         (FARPROC)FailSymGetLineFromName64},
    {"SymGetLineNext",               (FARPROC)FailSymGetLineNext},
    {"SymGetLineNext64",             (FARPROC)FailSymGetLineNext64},
    {"SymGetLinePrev",               (FARPROC)FailSymGetLinePrev},
    {"SymGetLinePrev64",             (FARPROC)FailSymGetLinePrev64},
    {"SymGetModuleBase",             (FARPROC)FailSymGetModuleBase},
    {"SymGetModuleBase64",           (FARPROC)FailSymGetModuleBase64},
    {"SymGetModuleInfo",             (FARPROC)FailSymGetModuleInfo},
    {"SymGetModuleInfo64",           (FARPROC)FailSymGetModuleInfo64},
    {"SymGetModuleInfoW",            (FARPROC)FailSymGetModuleInfoW},
    {"SymGetModuleInfoW64",          (FARPROC)FailSymGetModuleInfoW64},
    {"SymGetModuleInfoEx",           (FARPROC)FailSymGetModuleInfoEx},    
    {"SymGetModuleInfoEx64",         (FARPROC)FailSymGetModuleInfoEx64},    
    {"SymGetOptions",                (FARPROC)FailSymGetOptions},
    {"SymGetSearchPath",             (FARPROC)FailSymGetSearchPath},
    {"SymGetSymFromAddr",            (FARPROC)FailSymGetSymFromAddr},
    {"SymGetSymFromAddr64",          (FARPROC)FailSymGetSymFromAddr64},
    {"SymGetSymFromName",            (FARPROC)FailSymGetSymFromName},
    {"SymGetSymFromName64",          (FARPROC)FailSymGetSymFromName64},
    {"SymGetSymNext",                (FARPROC)FailSymGetSymNext},
    {"SymGetSymNext64",              (FARPROC)FailSymGetSymNext64},
    {"SymGetSymPrev",                (FARPROC)FailSymGetSymPrev},
    {"SymGetSymPrev64",              (FARPROC)FailSymGetSymPrev64},
    {"SymGetSymbolInfo",             (FARPROC)FailSymGetSymbolInfo},
    {"SymGetSymbolInfo64",           (FARPROC)FailSymGetSymbolInfo64},
    {"SymInitialize",                (FARPROC)FailSymInitialize},
    {"SymLoadModule",                (FARPROC)FailSymLoadModule},
    {"SymLoadModule64",              (FARPROC)FailSymLoadModule64},
    {"SymMatchFileName",             (FARPROC)FailSymMatchFileName},
    {"SymRegisterCallback",          (FARPROC)FailSymRegisterCallback},
    {"SymRegisterCallback64",        (FARPROC)FailSymRegisterCallback64},
    {"SymRegisterFunctionEntryCallback",   (FARPROC)FailSymRegisterFunctionEntryCallback},
    {"SymRegisterFunctionEntryCallback64", (FARPROC)FailSymRegisterFunctionEntryCallback64},
    {"SymSetOptions",                (FARPROC)FailSymSetOptions},
    {"SymSetSearchPath",             (FARPROC)FailSymSetSearchPath},
    {"SymUnDName",                   (FARPROC)FailSymUnDName},
    {"SymUnDName64",                 (FARPROC)FailSymUnDName64},
    {"SymUnloadModule",              (FARPROC)FailSymUnloadModule},
    {"SymUnloadModule64",            (FARPROC)FailSymUnloadModule64},
#ifndef _WIN64
    {"UnmapDebugInformation",        (FARPROC)FailUnmapDebugInformation},
#endif
    {NULL, NULL}
};

#endif      // BUILD_IMAGEHLP

#ifdef BUILD_IMAGEHLP
FUNCPTRS *FailFunctions[2] = {NULL, DbgHelpFailPtrs}; // {MsDbiFailPtrs, DbgHelpFailPtrs};
HINSTANCE hDelayLoadDll[2];
#else
FUNCPTRS *FailFunctions[1] = {MsDbiFailPtrs};
HINSTANCE hDelayLoadDll[1];
#endif

FARPROC
FindFailureProc(
                UINT Index,
                const char *szProcName
                )
{
    FUNCPTRS *fp = FailFunctions[Index];
    UINT x = 0;

    while (fp[x].Name) {
        if (!lstrcmpi(fp[x].Name, szProcName)) {
            return fp[x].Function;
        }
        x++;
    }
    return NULL;
}

/*
 * this function exists to prevent us from calling msvcrt!splitpath
 */

VOID
ParsePath(
    CHAR *fullpath,
    CHAR *path,
    CHAR *file
    )
{
    CHAR *c;
    CHAR sz[_MAX_PATH];

    assert(fullpath);

    if (path)
        *path = 0;
    if (file)
        *file = 0;

    lstrcpy(sz, fullpath);
    for (c = sz + lstrlen(sz); c > sz; c--) {
        if (*c == '\\') {
            c++;
            if (file)
                lstrcpy(file, c);
            *c = 0;
            if (path)
                lstrcpy(path, sz);
            return;
        }
    }

    if (file)
        lstrcpy(file, fullpath);
}

FARPROC
WINAPI
ImagehlpDelayLoadHook (
    UINT            unReason,
    PDelayLoadInfo  pDelayInfo
    )
{
    FARPROC ReturnValue = NULL;

    if (dliStartProcessing == unReason)
    {
        DWORD iDll = 0;
#ifdef BUILD_IMAGEHLP
        if (!lstrcmpi(pDelayInfo->szDll, "dbghelp.dll")) {
            iDll = 2;
        }
#endif

        if (iDll) {

            iDll--;

            // If the dll isn't loaded and isn't inproc already, attempt to load
            // from the same dir as imagehlp lives...

            if (!hDelayLoadDll[iDll] &&
                !(hDelayLoadDll[iDll] = GetModuleHandle(pDelayInfo->szDll)) &&
                hImagehlp)
            {
                CHAR szImageName[_MAX_PATH];
                CHAR szPath[_MAX_DIR];
                CHAR szDll[_MAX_PATH];

                // Only load if dbghelp/msdbi are in the same dir as imagehlp

                GetModuleFileName(hImagehlp, szImageName, sizeof(szImageName));
                ParsePath(szImageName, szPath, szDll);
                lstrcpy(szImageName, szPath);
                lstrcat(szImageName, pDelayInfo->szDll);
                hDelayLoadDll[iDll] = LoadLibrary(szImageName);
                if (!hDelayLoadDll[iDll]) {
                    hDelayLoadDll[iDll] = INVALID_HANDLE_VALUE;
                }
            }

            if (INVALID_HANDLE_VALUE != hDelayLoadDll[iDll] && hImagehlp) {
                ReturnValue = GetProcAddress(hDelayLoadDll[iDll], pDelayInfo->dlp.szProcName);
            }

            if (!ReturnValue) {
                ReturnValue = FindFailureProc(iDll, pDelayInfo->dlp.szProcName);
            }
#if DBG
            if (!ReturnValue) {
                OutputDBString("BogusDelayLoad function encountered...\n");
            }
        } else {
            OutputDBString("BogusDelayLoad function encountered...\n");
#endif
        }
    }

    if (ReturnValue && hImagehlp) {
        *pDelayInfo->ppfn = ReturnValue;
    }
    return ReturnValue;
}


#ifdef BUILD_DBGHELP

typedef struct tagVERHEAD {
    WORD wTotLen;
    WORD wValLen;
    WORD wType;         /* always 0 */
    WCHAR szKey[(sizeof("VS_VERSION_INFO")+3)&~03];
    VS_FIXEDFILEINFO vsf;
} VERHEAD ;


HINSTANCE
MostRecentVersion(
    HINSTANCE hDllOne,
    HINSTANCE hDllTwo
)
{
    // BUGBUG - not implemented.  Wait for API from DanS

    return hDllOne;
}

BOOL
GetDllVersionInfo(
    HINSTANCE hinst,
    LPVOID *lpVersionInfo
    )
{
    VS_FIXEDFILEINFO  *pvsFFI = NULL;
    HRSRC             hVerRes;
    VERHEAD           *pVerHead;
    BOOL              rc = FALSE;

    assert(lpVersionInfo && hinst);

    *lpVersionInfo = NULL;

    hVerRes = FindResource(hinst, MAKEINTRESOURCE(VS_VERSION_INFO), VS_FILE_INFO);

    pVerHead = (VERHEAD*)LoadResource(hinst, hVerRes);
    if (pVerHead == NULL)
        goto Cleanup;

    *lpVersionInfo = MemAlloc(pVerHead->wTotLen + pVerHead->wTotLen/2);
    if (*lpVersionInfo == NULL)
        goto Cleanup;

    memcpy(*lpVersionInfo, (PVOID)pVerHead, pVerHead->wTotLen);
    rc = TRUE;

Cleanup:
    if (*lpVersionInfo && rc == FALSE)
        MemFree(*lpVersionInfo);

    return rc;
}

#endif // #ifdef BUILD_DBGHELP


PfnDliHook __pfnDliNotifyHook = ImagehlpDelayLoadHook;
PfnDliHook __pfnDliFailureHook = NULL;


#if DBG

void
OutputDBString(
    CHAR *text
    )
{
    CHAR sz[256];

    sprintf(sz, "%s: %s", MOD_FILENAME, text);
    OutputDebugString(sz);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\ext.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    imagehlp.c

Abstract:

    This function implements a generic simple symbol handler.

Author:

    Wesley Witt (wesw) 1-Sep-1994

Environment:

    User Mode

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntverp.h>
#include "private.h"
#include <symbols.h>

#define NOEXTAPI
#include <wdbgexts.h>
#undef DECLARE_API

#define DECLARE_API(s)                          \
    CPPMOD VOID                                 \
    s(                                          \
        HANDLE hCurrentProcess,                 \
        HANDLE hCurrentThread,                  \
        DWORD_PTR dwCurrentPc,                  \
        PWINDBG_EXTENSION_APIS lpExtensionApis, \
        LPSTR lpArgumentString                  \
     )

#define dprintf                 (ExtensionApis.lpOutputRoutine)
#define GetExpression           (ExtensionApis.lpGetExpressionRoutine)
#define GetSymbol               (ExtensionApis.lpGetSymbolRoutine)
#define Disasm                  (ExtensionApis.lpDisasmRoutine)
#define CheckControlC           (ExtensionApis.lpCheckControlCRoutine)
#define ReadMemory(a,b,c,d) \
    ((ExtensionApis.nSize == sizeof(WINDBG_OLD_EXTENSION_APIS)) ? \
    ReadProcessMemory( ExtensionCurrentProcess, (LPCVOID)(a), (b), (c), (d) ) \
  : ExtensionApis.lpReadProcessMemoryRoutine( (ULONG_PTR)(a), (b), (c), (d) ))

#define WriteMemory(a,b,c,d) \
    ((ExtensionApis.nSize == sizeof(WINDBG_OLD_EXTENSION_APIS)) ? \
    WriteProcessMemory( ExtensionCurrentProcess, (LPVOID)(a), (LPVOID)(b), (c), (d) ) \
  : ExtensionApis.lpWriteProcessMemoryRoutine( (ULONG_PTR)(a), (LPVOID)(b), (c), (d) ))

EXT_API_VERSION        ExtApiVersion = { (VER_PRODUCTVERSION_W >> 8), (VER_PRODUCTVERSION_W & 0xff), EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
ULONG                  STeip;
ULONG                  STebp;
ULONG                  STesp;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;
HANDLE                 ExtensionCurrentProcess;
BOOL                   fWinDbgExtension = FALSE;

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    fWinDbgExtension = TRUE;
}

#if 0
VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}
#endif

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ExtApiVersion;
}


/*++

Routine Description:

    This function is called as an NTSD extension to mimic the !handle
    kd command.  This will walk through the debuggee's handle table
    and duplicate the handle into the ntsd process, then call NtQueryobjectInfo
    to find out what it is.

    Called as:

        !handle [handle [flags [Type]]]

    If the handle is 0 or -1, all handles are scanned.  If the handle is not
    zero, that particular handle is examined.  The flags are as follows
    (corresponding to secexts.c):
        1   - Get type information (default)
        2   - Get basic information
        4   - Get name information
        8   - Get object specific info (where available)

    If Type is specified, only object of that type are scanned.  Type is a
    standard NT type name, e.g. Event, Semaphore, etc.  Case sensitive, of
    course.

    Examples:

        !handle     -- dumps the types of all the handles, and a summary table
        !handle 0 0 -- dumps a summary table of all the open handles
        !handle 0 f -- dumps everything we can find about a handle.
        !handle 0 f Event
                    -- dumps everything we can find about open events

--*/
DECLARE_API( sym )
{

    PWINDBG_EXTENSION_ROUTINE
    ExtensionCurrentProcess = hCurrentProcess;  

    if (!fWinDbgExtension && lpExtensionApis)
        ExtensionApis = *lpExtensionApis;

    SymParseArgs(lpArgumentString);
}

void
SymParseArgs(
    LPCSTR args
    )
{
    char argstr[1024];

    lstrcpy(argstr, args);
    _strlwr(argstr);

    if (strstr(argstr, "noisy") && !(SymOptions & SYMOPT_DEBUG)) {
        SymOptions |= SYMOPT_DEBUG;
        CPRINTF(NULL, ((SymOptions & SYMOPT_DEBUG) ? "Noisy mode on.\n" : "Quiet mode on.\n"));
    }

    if (strstr(argstr, "quiet") && (SymOptions & SYMOPT_DEBUG)) {
        SymOptions &= ~SYMOPT_DEBUG;
        CPRINTF(NULL, ((SymOptions & SYMOPT_DEBUG) ? "Noisy mode on.\n" : "Quiet mode on.\n"));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\imagecfg.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    imagecfg.c

Abstract:

    This function change the image loader configuration information in an image file.

Author:

    Steve Wood (stevewo)   8-Nov-1994

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <private.h>

//
// Applications should include the following declaration in their
// global data to create an IMAGE_LOAD_CONFIG_DIRECTORY entry for
// their image.  Non-zero entries override defaults.
//

#if 0

IMAGE_LOAD_CONFIG_DIRECTORY _load_config_used = {
    0,              // Characteristics;
    0,              // TimeDateStamp;
    4,              // MajorVersion;
    0,              // MinorVersion;
    0,              // GlobalFlagsClear;
    0,              // GlobalFlagsSet;
    0,              // CriticalSectionDefaultTimeout;
    0,              // DeCommitFreeBlockThreshold;
    0,              // DeCommitTotalFreeThreshold;
    0,              // LockPrefixTable;
    0,              // MaximumAllocationSize;
    0,              // VirtualMemoryThreshold;
    0,              // ProcessHeapFlags;
    0,              // ProcessAffinityMask;
    0, 0, 0         // Reserved[ 3 ];
};

#endif


struct {
    DWORD Flag;
    LPSTR ClearPrefix;
    LPSTR SetPrefix;
    LPSTR Description;
} NtGlobalFlagNames[] = {
    {FLG_STOP_ON_EXCEPTION,             "Don't ", "", "Stop on exception"},
    {FLG_SHOW_LDR_SNAPS,                "Don't ", "", "Show Loader Debugging Information"},
    {FLG_DEBUG_INITIAL_COMMAND,         "Don't ", "", "Debug Initial Command (WINLOGON)"},
    {FLG_STOP_ON_HUNG_GUI,              "Don't ", "", "Stop on Hung GUI"},
    {FLG_HEAP_ENABLE_TAIL_CHECK,        "Disable", "Enable", " Heap Tail Checking"},
    {FLG_HEAP_ENABLE_FREE_CHECK,        "Disable", "Enable", " Heap Free Checking"},
    {FLG_HEAP_VALIDATE_PARAMETERS,      "Disable", "Enable", " Heap Parameter Validation"},
    {FLG_HEAP_VALIDATE_ALL,             "Disable", "Enable", " Heap Validate on Call"},
    {FLG_POOL_ENABLE_TAGGING,           "Disable", "Enable", " Pool Tagging"},
    {FLG_HEAP_ENABLE_TAGGING,           "Disable", "Enable", " Heap Tagging"},
    {FLG_USER_STACK_TRACE_DB,           "Disable", "Enable", " User Mode Stack Backtrace DB (x86 checked only)"},
    {FLG_KERNEL_STACK_TRACE_DB,         "Disable", "Enable", " Kernel Mode Stack Backtrace DB (x86 checked only)"},
    {FLG_MAINTAIN_OBJECT_TYPELIST,      "Don't ", "", "Maintain list of kernel mode objects by type"},
    {FLG_HEAP_ENABLE_TAG_BY_DLL,        "Disable", "Enable", " Heap DLL Tagging"},
    {FLG_ENABLE_CSRDEBUG,               "Disable", "Enable", " Debugging of CSRSS"},
    {FLG_ENABLE_KDEBUG_SYMBOL_LOAD,     "Disable", "Enable", " Kernel Debugger Symbol load"},
    {FLG_DISABLE_PAGE_KERNEL_STACKS,    "Enable", "Disable", " Paging of Kernel Stacks"},
    {FLG_HEAP_DISABLE_COALESCING,       "Enable", "Disable", " Heap Coalescing on Free"},
    {FLG_ENABLE_CLOSE_EXCEPTIONS,       "Disable", "Enable", " Close Exceptions"},
    {FLG_ENABLE_EXCEPTION_LOGGING,      "Disable", "Enable", " Exception Logging"},
    {FLG_ENABLE_HANDLE_TYPE_TAGGING,    "Disable", "Enable", " Handle type tagging"},
    {FLG_HEAP_PAGE_ALLOCS,              "Disable", "Enable", " Heap page allocs"},
    {FLG_DEBUG_INITIAL_COMMAND_EX,      "Disable", "Enable", " Extended debug initial command"},
    {FLG_DISABLE_DBGPRINT,              "Enable",  "Disable"," DbgPrint to debugger"},
    {0, NULL}
};

void
DisplayGlobalFlags(
    LPSTR IndentString,
    DWORD NtGlobalFlags,
    BOOLEAN Set
    )
{
    ULONG i;

    for (i=0; NtGlobalFlagNames[i].Description; i++) {
        if (NtGlobalFlagNames[i].Flag & NtGlobalFlags) {
            printf( "%s%s%s\n",
                    IndentString,
                    Set ? NtGlobalFlagNames[i].SetPrefix :
                    NtGlobalFlagNames[i].ClearPrefix,
                    NtGlobalFlagNames[i].Description
                  );
        }
    }

    return;
}

BOOL fVerbose;
BOOL fUsage;

BOOL fConfigInfoChanged;
BOOL fImageHasConfigInfo;
BOOL fImageHeaderChanged;

LPSTR CurrentImageName;
PIMAGE_OPTIONAL_HEADER32 OptionalHeader32;
PIMAGE_OPTIONAL_HEADER64 OptionalHeader64;
PIMAGE_FILE_HEADER FileHeader;
LOADED_IMAGE CurrentImage;
IMAGE_LOAD_CONFIG_DIRECTORY ConfigInfo;
CHAR DebugFilePath[_MAX_PATH];
LPSTR SymbolPath;
ULONG GlobalFlagsClear;
ULONG GlobalFlagsSet;
ULONG CriticalSectionDefaultTimeout;
ULONG DeCommitFreeBlockThreshold;
ULONG DeCommitTotalFreeThreshold;
ULONG MaximumAllocationSize;
ULONG VirtualMemoryThreshold;
ULONG ProcessHeapFlags;
ULONG MajorSubsystemVersion;
ULONG MinorSubsystemVersion;
ULONG BuildNumber;
ULONG SizeOfStackReserve;
ULONG SizeOfStackCommit;
PULONG pBuildNumber;
ULONG Win32VersionValue;
ULONG Win32CSDVerValue;
BOOLEAN fUniprocessorOnly;
BOOLEAN fRestrictedWorkingSet;
BOOLEAN fEnableLargeAddresses;
BOOLEAN fNoBind;
BOOLEAN fEnableTerminalServerAware;
BOOLEAN fDisableTerminalServerAware;
BOOLEAN fSwapRunNet;
BOOLEAN fSwapRunCD;
BOOLEAN fQuiet;
DWORD ImageProcessAffinityMask;

VOID
DisplayImageInfo(
                BOOL HasConfigInfo
                );

PVOID
GetAddressOfExportedData(
                        PLOADED_IMAGE Dll,
                        LPSTR ExportedName
                        );

ULONG
ConvertNum(
          char *s
          )
{
    ULONG n, Result;

    if (!_strnicmp( s, "0x", 2 )) {
        n = sscanf( s+2, "%x", &Result );
    } else {
        n = sscanf( s, "%u", &Result );
    }

    if (n != 1) {
        return 0;
    } else {
        return Result;
    }
}

int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    UCHAR c;
    LPSTR p, sMajor, sMinor, sReserve, sCommit;
    ULONG HeaderSum;
    SYSTEMTIME SystemTime;
    FILETIME LastWriteTime;
    DWORD OldChecksum;

    fUsage = FALSE;
    fVerbose = FALSE;

    _tzset();

    if (argc <= 1) {
        goto showUsage;
    }

    while (--argc) {
        p = *++argv;
        if (*p == '/' || *p == '-') {
            while (c = *++p)
                switch (toupper( c )) {
                    case '?':
                        fUsage = TRUE;
                        break;

                    case 'A':
                        if (--argc) {
                            ImageProcessAffinityMask = ConvertNum( *++argv );
                            if (ImageProcessAffinityMask == 0) {
                                fprintf( stderr, "IMAGECFG: invalid affinity mask specified to /a switch.\n" );
                                fUsage = TRUE;
                            }
                        } else {
                            fprintf( stderr, "IMAGECFG: /a switch missing argument.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'B':
                        if (--argc) {
                            BuildNumber = ConvertNum( *++argv );
                            if (BuildNumber == 0) {
                                fprintf( stderr, "IMAGECFG: invalid build number specified to /b switch.\n" );
                                fUsage = TRUE;
                            }
                        } else {
                            fprintf( stderr, "IMAGECFG: /b switch missing argument.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'C':
                        if (--argc) {
                            if (sscanf( *++argv, "%x", &Win32CSDVerValue ) != 1) {
                                fprintf( stderr, "IMAGECFG: invalid version string specified to /c switch.\n" );
                                fUsage = TRUE;
                            }
                        } else {
                            fprintf( stderr, "IMAGECFG: /c switch missing argument.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'D':
                        if (argc >= 2) {
                            argc -= 2;
                            DeCommitFreeBlockThreshold = ConvertNum( *++argv );
                            DeCommitTotalFreeThreshold = ConvertNum( *++argv );
                        } else {
                            fprintf( stderr, "IMAGECFG: /d switch missing arguments.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'G':
                        if (argc >= 2) {
                            argc -= 2;
                            GlobalFlagsClear = ConvertNum( *++argv );
                            GlobalFlagsSet = ConvertNum( *++argv );
                        } else {
                            fprintf( stderr, "IMAGECFG: /g switch missing arguments.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'H':
                        if (argc > 2) {

                            INT flag = -1;

                            if (sscanf( *++argv, "%d", &flag ) != 1) {
                                fprintf( stderr, "IMAGECFG: invalid option string specified to /h switch.\n" );
                                fUsage = TRUE;
                            } else {

                                --argc;

                                if (flag == 0) {
                                    fDisableTerminalServerAware = TRUE;
                                } else if (flag == 1) {
                                    fEnableTerminalServerAware = TRUE;
                                } else {
                                    fprintf( stderr, "IMAGECFG: /h switch invalid argument.\n" );
                                    fUsage = TRUE;
                                }

                            }
                        } else {
                            fprintf( stderr, "IMAGECFG: /h switch missing argument.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'K':
                        if (--argc) {
                            sReserve = *++argv;
                            sCommit = strchr( sReserve, '.' );
                            if (sCommit != NULL) {
                                *sCommit++ = '\0';
                                SizeOfStackCommit = ConvertNum( sCommit );
                                SizeOfStackCommit = ((SizeOfStackCommit + 0xFFF) & ~0xFFF);
                                if (SizeOfStackCommit == 0) {
                                    fprintf( stderr, "IMAGECFG: invalid stack commit size specified to /k switch.\n" );
                                    fUsage = TRUE;
                                }
                            }

                            SizeOfStackReserve = ConvertNum( sReserve );
                            SizeOfStackReserve = ((SizeOfStackReserve + 0xFFFF) & ~0xFFFF);
                            if (SizeOfStackReserve == 0) {
                                fprintf( stderr, "IMAGECFG: invalid stack reserve size specified to /k switch.\n" );
                                fUsage = TRUE;
                            }
                        } else {
                            fprintf( stderr, "IMAGECFG: /w switch missing argument.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'L':
                        fEnableLargeAddresses = TRUE;
                        break;

                    case 'M':
                        if (--argc) {
                            MaximumAllocationSize = ConvertNum( *++argv );
                        } else {
                            fprintf( stderr, "IMAGECFG: /m switch missing argument.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'N':
                        fNoBind = TRUE;
                        break;

                    case 'O':
                        if (--argc) {
                            CriticalSectionDefaultTimeout = ConvertNum( *++argv );
                        } else {
                            fprintf( stderr, "IMAGECFG: /o switch missing argument.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'P':
                        if (--argc) {
                            ProcessHeapFlags = ConvertNum( *++argv );
                        } else {
                            fprintf( stderr, "IMAGECFG: /p switch missing argument.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'Q':
                        fQuiet = TRUE;
                        break;

                    case 'R':
                        fRestrictedWorkingSet = TRUE;
                        break;

                    case 'S':
                        if (--argc) {
                            SymbolPath = *++argv;
                        } else {
                            fprintf( stderr, "IMAGECFG: /s switch missing path argument.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'T':
                        if (--argc) {
                            VirtualMemoryThreshold = ConvertNum( *++argv );
                        } else {
                            fprintf( stderr, "IMAGECFG: /t switch missing argument.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'U':
                        fUniprocessorOnly = TRUE;
                        break;

                    case 'V':
                        if (--argc) {
                            sMajor = *++argv;
                            sMinor = strchr( sMajor, '.' );
                            if (sMinor != NULL) {
                                *sMinor++ = '\0';
                                MinorSubsystemVersion = ConvertNum( sMinor );
                            }
                            MajorSubsystemVersion = ConvertNum( sMajor );

                            if (MajorSubsystemVersion == 0) {
                                fprintf( stderr, "IMAGECFG: invalid version string specified to /v switch.\n" );
                                fUsage = TRUE;
                            }
                        } else {
                            fprintf( stderr, "IMAGECFG: /v switch missing argument.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'W':
                        if (--argc) {
                            if (sscanf( *++argv, "%x", &Win32VersionValue ) != 1) {
                                fprintf( stderr, "IMAGECFG: invalid version string specified to /w switch.\n" );
                                fUsage = TRUE;
                            }
                        } else {
                            fprintf( stderr, "IMAGECFG: /w switch missing argument.\n" );
                            fUsage = TRUE;
                        }
                        break;

                    case 'X':
                        fSwapRunNet = TRUE;
                        break;

                    case 'Y':
                        fSwapRunCD = TRUE;
                        break;

                    default:
                        fprintf( stderr, "IMAGECFG: Invalid switch - /%c\n", c );
                        fUsage = TRUE;
                        break;
                }

            if ( fUsage ) {
                showUsage:
                fprintf( stderr,
                         "usage: IMAGECFG [switches] image-names... \n"
                         "              [-?] display this message\n"
                         "              [-a Process Affinity mask value in hex]\n"
                         "              [-b BuildNumber]\n"
                         "              [-c Win32 GetVersionEx Service Pack return value in hex]\n"
                         "              [-d decommit thresholds]\n"
                         "              [-g bitsToClear bitsToSet]\n"
                         "              [-h 1|0 (Enable/Disable Terminal Server Compatible bit)\n"
                         "              [-k StackReserve[.StackCommit]\n"
                         "              [-l enable large (>2GB) addresses\n"
                         "              [-m maximum allocation size]\n"
                         "              [-n bind no longer allowed on this image\n"
                         "              [-o default critical section timeout\n"
                         "              [-p process heap flags]\n"
                         "              [-q only print config info if changed\n"
                         "              [-r run with restricted working set]\n"
                         "              [-s path to symbol files]\n"
                         "              [-t VirtualAlloc threshold]\n"
                         "              [-u Marks image as uniprocessor only]\n"
                         "              [-v MajorVersion.MinorVersion]\n"
                         "              [-w Win32 GetVersion return value in hex]\n"
                         "              [-x Mark image as Net - Run From Swapfile\n"
                         "              [-y Mark image as Removable - Run From Swapfile\n"
                       );
                exit( 1 );
            }
        } else {
            //
            // Map and load the current image
            //

            OptionalHeader32 = NULL;
            OptionalHeader64 = NULL;
            FileHeader = NULL;
            CurrentImageName = p;
            if (MapAndLoad( CurrentImageName,
                            NULL,
                            &CurrentImage,
                            FALSE,
                            TRUE
                          )
               ) {
                if (BuildNumber != 0) {
                    pBuildNumber = (PULONG) GetAddressOfExportedData( &CurrentImage, "NtBuildNumber" );
                    if (pBuildNumber == NULL) {
                        fprintf( stderr,
                                 "IMAGECFG: Unable to find exported NtBuildNumber image %s\n",
                                 CurrentImageName
                               );
                    }
                }

                FileHeader = &((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader)->FileHeader;
                OptionalHeadersFromNtHeaders((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader,
                                             &OptionalHeader32,
                                             &OptionalHeader64);

                //
                // make sure the image has correct configuration information,
                // and that the LockPrefixTable is set up properly
                //

                fConfigInfoChanged = FALSE;
                fImageHeaderChanged = FALSE;
                ZeroMemory(&ConfigInfo, sizeof(ConfigInfo));
                fImageHasConfigInfo = GetImageConfigInformation( &CurrentImage, &ConfigInfo );
                if (!fQuiet) {
                    DisplayImageInfo( fImageHasConfigInfo );
                }
                UnMapAndLoad( &CurrentImage );
                OptionalHeader32 = NULL;
                OptionalHeader64 = NULL;
                FileHeader = NULL;
                if (fConfigInfoChanged || fImageHeaderChanged) {
                    if (!MapAndLoad( CurrentImageName,
                                     NULL,
                                     &CurrentImage,
                                     FALSE,
                                     FALSE
                                   )
                       ) {
                        if (!CurrentImage.fDOSImage) {
                            fprintf( stderr, "IMAGECFG: unable to map and load %s\n", CurrentImageName );
                        } else {
                            fprintf( stderr,
                                     "IMAGECFG: unable to modify DOS or Windows image file - %s\n",
                                     CurrentImageName
                                   );
                        }
                    } else {
                        FileHeader = &((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader)->FileHeader;

                        OptionalHeadersFromNtHeaders((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader,
                                                     &OptionalHeader32,
                                                     &OptionalHeader64);

                        if (GlobalFlagsClear) {
                            ConfigInfo.GlobalFlagsClear = GlobalFlagsClear;
                        }

                        if (GlobalFlagsSet) {
                            ConfigInfo.GlobalFlagsSet = GlobalFlagsSet;
                        }

                        if (CriticalSectionDefaultTimeout) {
                            ConfigInfo.CriticalSectionDefaultTimeout = CriticalSectionDefaultTimeout;
                        }

                        if (ProcessHeapFlags) {
                            ConfigInfo.ProcessHeapFlags = ProcessHeapFlags;
                        }

                        if (DeCommitFreeBlockThreshold) {
                            ConfigInfo.DeCommitFreeBlockThreshold = DeCommitFreeBlockThreshold;
                        }

                        if (DeCommitTotalFreeThreshold) {
                            ConfigInfo.DeCommitTotalFreeThreshold = DeCommitTotalFreeThreshold;
                        }

                        if (MaximumAllocationSize) {
                            ConfigInfo.MaximumAllocationSize = MaximumAllocationSize;
                        }

                        if (VirtualMemoryThreshold) {
                            ConfigInfo.VirtualMemoryThreshold = VirtualMemoryThreshold;
                        }

                        if (ImageProcessAffinityMask) {
                            ConfigInfo.ProcessAffinityMask = ImageProcessAffinityMask;
                        }

                        if (fEnableLargeAddresses) {
                            FileHeader->Characteristics |= IMAGE_FILE_LARGE_ADDRESS_AWARE;
                        }

                        if (fNoBind) {
                            OPTIONALHEADER_SET_FLAG(DllCharacteristics,IMAGE_DLLCHARACTERISTICS_NO_BIND);
                        }

                        if (fEnableTerminalServerAware) {
                            OPTIONALHEADER_SET_FLAG(DllCharacteristics,IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE);
                        }

                        if (fDisableTerminalServerAware) {
                            OPTIONALHEADER_CLEAR_FLAG(DllCharacteristics,IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE);
                        }

                        if (fSwapRunNet) {
                            FileHeader->Characteristics |= IMAGE_FILE_NET_RUN_FROM_SWAP;
                        }

                        if (fSwapRunCD) {
                            FileHeader->Characteristics |= IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP;
                        }

                        if (fUniprocessorOnly) {
                            FileHeader->Characteristics |= IMAGE_FILE_UP_SYSTEM_ONLY;
                        }

                        if (fRestrictedWorkingSet) {
                            FileHeader->Characteristics |= IMAGE_FILE_AGGRESIVE_WS_TRIM;
                        }

                        if (MajorSubsystemVersion != 0) {
                            OPTIONALHEADER_ASSIGN(MajorSubsystemVersion, (USHORT)MajorSubsystemVersion);
                            OPTIONALHEADER_ASSIGN(MinorSubsystemVersion, (USHORT)MinorSubsystemVersion);
                        }

                        if (Win32VersionValue != 0) {
                            OPTIONALHEADER_ASSIGN(Win32VersionValue, Win32VersionValue);
                        }

                        if (Win32CSDVerValue != 0) {
                            ConfigInfo.CSDVersion = (USHORT)Win32CSDVerValue;
                        }

                        if (SizeOfStackReserve) {
                            OPTIONALHEADER_ASSIGN(SizeOfStackReserve, SizeOfStackReserve);
                        }

                        if (SizeOfStackCommit) {
                            OPTIONALHEADER_ASSIGN(SizeOfStackCommit, SizeOfStackCommit);
                        }

                        if (BuildNumber != 0) {
                            pBuildNumber = (PULONG) GetAddressOfExportedData( &CurrentImage, "NtBuildNumber" );
                            if (pBuildNumber == NULL) {
                                fprintf( stderr,
                                         "IMAGECFG: Unable to find exported NtBuildNumber image %s\n",
                                         CurrentImageName
                                       );
                            } else {
                                if (BuildNumber & 0xFFFF0000) {
                                    *pBuildNumber = BuildNumber;
                                } else {
                                    *(PUSHORT)pBuildNumber = (USHORT)BuildNumber;
                                }
                            }
                        }

                        if (fConfigInfoChanged) {
                            if (SetImageConfigInformation( &CurrentImage, &ConfigInfo )) {
                                if (!fQuiet) {
                                    printf( "%s updated with the following configuration information:\n", CurrentImageName );
                                    DisplayImageInfo( fImageHasConfigInfo );
                                }
                            } else {
                                fprintf( stderr, "IMAGECFG: Unable to update configuration information in image.\n" );

                            }
                        }

                        //
                        // recompute the checksum.
                        //

                        OldChecksum = OPTIONALHEADER(CheckSum);
                        OPTIONALHEADER_LV(CheckSum) = 0;
                        CheckSumMappedFile(
                                          (PVOID)CurrentImage.MappedAddress,
                                          CurrentImage.SizeOfImage,
                                          &HeaderSum,
                                          &OPTIONALHEADER_LV(CheckSum)
                                          );

                        // And update the .dbg file (if requested)
                        if (SymbolPath &&
                            FileHeader->Characteristics & IMAGE_FILE_DEBUG_STRIPPED) {
                            if (UpdateDebugInfoFileEx( CurrentImageName,
                                                       SymbolPath,
                                                       DebugFilePath,
                                                       (PIMAGE_NT_HEADERS32)CurrentImage.FileHeader,
                                                       OldChecksum
                                                     )
                               ) {
                                if (GetLastError() == ERROR_INVALID_DATA) {
                                    printf( "Warning: Old checksum did not match for %s\n", DebugFilePath);
                                }
                                printf( "Updated symbols for %s\n", DebugFilePath );
                            } else {
                                printf( "Unable to update symbols: %s\n", DebugFilePath );
                            }
                        }

                        GetSystemTime( &SystemTime );
                        if (SystemTimeToFileTime( &SystemTime, &LastWriteTime )) {
                            SetFileTime( CurrentImage.hFile, NULL, NULL, &LastWriteTime );
                        }

                        UnMapAndLoad( &CurrentImage );
                    }
                }
            } else
                if (!CurrentImage.fDOSImage) {
                fprintf( stderr, "IMAGECFG: unable to map and load %s  GetLastError= %d\n", CurrentImageName, GetLastError() );

            } else {
                fprintf( stderr,
                         "IMAGECFG: unable to modify DOS or Windows image file - %s\n",
                         CurrentImageName
                       );
            }
        }
    }

    exit( 1 );
    return 1;
}

__inline PVOID
GetVaForRva(
           PLOADED_IMAGE Image,
           ULONG Rva
           )
{
    PVOID Va;

    Va = ImageRvaToVa( Image->FileHeader,
                       Image->MappedAddress,
                       Rva,
                       &Image->LastRvaSection
                     );
    return Va;
}


PVOID
GetAddressOfExportedData(
                        PLOADED_IMAGE Dll,
                        LPSTR ExportedName
                        )
{
    PIMAGE_EXPORT_DIRECTORY Exports;
    ULONG ExportSize;
    USHORT HintIndex;
    USHORT OrdinalNumber;
    PULONG NameTableBase;
    PUSHORT NameOrdinalTableBase;
    PULONG FunctionTableBase;
    LPSTR NameTableName;

    Exports = (PIMAGE_EXPORT_DIRECTORY)ImageDirectoryEntryToData( (PVOID)Dll->MappedAddress,
                                                                  FALSE,
                                                                  IMAGE_DIRECTORY_ENTRY_EXPORT,
                                                                  &ExportSize
                                                                );
    if (Exports) {
        NameTableBase = (PULONG)GetVaForRva( Dll, Exports->AddressOfNames );
        NameOrdinalTableBase = (PUSHORT)GetVaForRva( Dll, Exports->AddressOfNameOrdinals );
        FunctionTableBase = (PULONG)GetVaForRva( Dll, Exports->AddressOfFunctions );
        if (NameTableBase != NULL &&
            NameOrdinalTableBase != NULL &&
            FunctionTableBase != NULL
           ) {
            for (HintIndex = 0; HintIndex < Exports->NumberOfNames; HintIndex++) {
                NameTableName = (LPSTR)GetVaForRva( Dll, NameTableBase[ HintIndex ] );
                if (NameTableName) {
                    if (!strcmp( ExportedName, NameTableName )) {
                        OrdinalNumber = NameOrdinalTableBase[ HintIndex ];
                        return FunctionTableBase[ OrdinalNumber ] + Dll->MappedAddress;
                    }
                }
            }
        }
    }

    return NULL;
}


VOID
DisplayImageInfo(
                BOOL HasConfigInfo
                )
{
    printf( "%s contains the following configuration information:\n", CurrentImageName );
//    if (HasConfigInfo) {
        if (ConfigInfo.GlobalFlagsClear != 0) {
            printf( "    NtGlobalFlags to clear: %08x\n",
                    ConfigInfo.GlobalFlagsClear
                  );
            DisplayGlobalFlags( "        ", ConfigInfo.GlobalFlagsClear, FALSE );
        }
        if (GlobalFlagsClear && ConfigInfo.GlobalFlagsClear != GlobalFlagsClear) {
            fConfigInfoChanged = TRUE;
        }

        if (ConfigInfo.GlobalFlagsSet != 0) {
            printf( "    NtGlobalFlags to set:   %08x\n",
                    ConfigInfo.GlobalFlagsSet
                  );
            DisplayGlobalFlags( "        ", ConfigInfo.GlobalFlagsSet, TRUE );
        }
        if (GlobalFlagsSet && ConfigInfo.GlobalFlagsSet != GlobalFlagsSet) {
            fConfigInfoChanged = TRUE;
        }


        if (ConfigInfo.CriticalSectionDefaultTimeout != 0) {
            printf( "    Default Critical Section Timeout: %u milliseconds\n",
                    ConfigInfo.CriticalSectionDefaultTimeout
                  );
        }
        if (CriticalSectionDefaultTimeout &&
            ConfigInfo.CriticalSectionDefaultTimeout != CriticalSectionDefaultTimeout
           ) {
            fConfigInfoChanged = TRUE;
        }

        if (ConfigInfo.ProcessHeapFlags != 0) {
            printf( "    Process Heap Flags: %08x\n",
                    ConfigInfo.ProcessHeapFlags
                  );
        }
        if (ProcessHeapFlags && ConfigInfo.ProcessHeapFlags != ProcessHeapFlags) {
            fConfigInfoChanged = TRUE;
        }

        if (ConfigInfo.DeCommitFreeBlockThreshold != 0) {
            printf( "    Process Heap DeCommit Free Block threshold: %08x\n",
                    ConfigInfo.DeCommitFreeBlockThreshold
                  );
        }
        if (DeCommitFreeBlockThreshold &&
            ConfigInfo.DeCommitFreeBlockThreshold != DeCommitFreeBlockThreshold
           ) {
            fConfigInfoChanged = TRUE;
        }

        if (ConfigInfo.DeCommitTotalFreeThreshold != 0) {
            printf( "    Process Heap DeCommit Total Free threshold: %08x\n",
                    ConfigInfo.DeCommitTotalFreeThreshold
                  );
        }
        if (DeCommitTotalFreeThreshold &&
            ConfigInfo.DeCommitTotalFreeThreshold != DeCommitTotalFreeThreshold
           ) {
            fConfigInfoChanged = TRUE;
        }

        if (ConfigInfo.MaximumAllocationSize != 0) {
            printf( "    Process Heap Maximum Allocation Size: %08x\n",
                    ConfigInfo.MaximumAllocationSize
                  );
        }
        if (MaximumAllocationSize && ConfigInfo.MaximumAllocationSize != MaximumAllocationSize) {
            fConfigInfoChanged = TRUE;
        }

        if (ConfigInfo.VirtualMemoryThreshold != 0) {
            printf( "    Process Heap VirtualAlloc Threshold: %08x\n",
                    ConfigInfo.VirtualMemoryThreshold
                  );
        }
        if (VirtualMemoryThreshold &&
            ConfigInfo.VirtualMemoryThreshold != VirtualMemoryThreshold
           ) {
            fConfigInfoChanged = TRUE;
        }

        if (ConfigInfo.ProcessAffinityMask != 0) {
            printf( "    Process Affinity Mask: %08x\n",
                    ConfigInfo.ProcessAffinityMask
                  );
        }
        if (ImageProcessAffinityMask &&
            ConfigInfo.ProcessAffinityMask != ImageProcessAffinityMask
           ) {
            fConfigInfoChanged = TRUE;
        }
//    } else {
//        memset( &ConfigInfo, 0, sizeof( ConfigInfo ) );
//    }

    printf( "    Subsystem Version of %u.%u\n",
            OPTIONALHEADER(MajorSubsystemVersion),
            OPTIONALHEADER(MinorSubsystemVersion)
          );
    if (MajorSubsystemVersion != 0) {
        if (OPTIONALHEADER(MajorSubsystemVersion) != (USHORT)MajorSubsystemVersion ||
            OPTIONALHEADER(MinorSubsystemVersion) != (USHORT)MinorSubsystemVersion
           ) {
            fImageHeaderChanged = TRUE;
        }
    }

    if (pBuildNumber != NULL) {
        printf( "    Build Number of %08x\n", *pBuildNumber );
        if (BuildNumber != 0) {
            if (BuildNumber & 0xFFFF0000) {
                if (*pBuildNumber != BuildNumber) {
                    fImageHeaderChanged = TRUE;
                }
            } else {
                if (*(PUSHORT)pBuildNumber != (USHORT)BuildNumber) {
                    fImageHeaderChanged = TRUE;
                }
            }
        }
    }

    if (OPTIONALHEADER(Win32VersionValue) != 0) {
        printf( "    Win32 GetVersion return value: %08x\n",
                OPTIONALHEADER(Win32VersionValue)
              );
    }
    if (Win32VersionValue != 0 &&
        OPTIONALHEADER(Win32VersionValue) != Win32VersionValue
       ) {
        fImageHeaderChanged = TRUE;
    }

    if (FileHeader->Characteristics & IMAGE_FILE_LARGE_ADDRESS_AWARE) {
        printf( "    Image can handle large (>2GB) addresses\n" );
    }

    if (OPTIONALHEADER(DllCharacteristics) & IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE) {
        printf( "    Image is Terminal Server aware\n" );
    }

    if (fEnableLargeAddresses &&
        !(FileHeader->Characteristics & IMAGE_FILE_LARGE_ADDRESS_AWARE)
       ) {
        fImageHeaderChanged = TRUE;
        printf( "    Image is Large Address aware\n" );
    }

    if (fNoBind) {
        fImageHeaderChanged = TRUE;
        printf( "    Image will no longer support binding\n" );
    }

    if (fEnableTerminalServerAware || fDisableTerminalServerAware) {
        printf( "    Image %s Terminal Server Aware\n", fEnableTerminalServerAware ? "is" : "is not");
        fImageHeaderChanged = TRUE;
    }

    if (FileHeader->Characteristics & IMAGE_FILE_NET_RUN_FROM_SWAP) {
        printf( "    Image will run from swapfile if located on net\n" );
    }
    if (fSwapRunNet &&
        !(FileHeader->Characteristics & IMAGE_FILE_NET_RUN_FROM_SWAP)
       ) {
        fImageHeaderChanged = TRUE;
    }

    if (FileHeader->Characteristics & IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP) {
        printf( "    Image will run from swapfile if located on removable media\n" );
    }
    if (fSwapRunCD &&
        !(FileHeader->Characteristics & IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP)
       ) {
        fImageHeaderChanged = TRUE;
    }

    if (FileHeader->Characteristics & IMAGE_FILE_UP_SYSTEM_ONLY) {
        printf( "    Image can only run in uni-processor mode on multi-processor systems\n" );
    }
    if (fUniprocessorOnly &&
        !(FileHeader->Characteristics & IMAGE_FILE_UP_SYSTEM_ONLY)
       ) {
        fImageHeaderChanged = TRUE;
    }

    if (FileHeader->Characteristics & IMAGE_FILE_AGGRESIVE_WS_TRIM) {
        printf( "    Image working set trimmed aggressively on small memory systems\n" );
    }
    if (fRestrictedWorkingSet &&
        !(FileHeader->Characteristics & IMAGE_FILE_AGGRESIVE_WS_TRIM)
       ) {
        fImageHeaderChanged = TRUE;
    }

    if (OPTIONALHEADER(SizeOfStackReserve)) {
        printf( "    Stack Reserve Size: 0x%x\n", OPTIONALHEADER(SizeOfStackReserve) );
    }
    if (SizeOfStackReserve &&
        OPTIONALHEADER(SizeOfStackReserve) != SizeOfStackReserve
       ) {
        fImageHeaderChanged = TRUE;
    }

    if (OPTIONALHEADER(SizeOfStackCommit)) {
        printf( "    Stack Commit Size: 0x%x\n", OPTIONALHEADER(SizeOfStackCommit) );
    }
    if (SizeOfStackCommit &&
        OPTIONALHEADER(SizeOfStackCommit) != SizeOfStackCommit
       ) {
        fImageHeaderChanged = TRUE;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\imagechk.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    imagechk.c

Abstract:

    this module implements a sanity check of certain image characteristics

Author:

    NT Base

Revision History:


Notes:


--*/

#ifdef __cplusplus
extern "C" {
#endif
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#ifdef __cplusplus
}
#endif

#include <errno.h>
#include <direct.h>
#include <cvinfo.h>
#include <private.h>

typedef struct _SYMMODLIST{
    char *ModName;
    void *ModBase;
    struct _SYMMODLIST *Next;
} SYMMODLIST, *PSYMMODLIST;

typedef struct List {
    char            Name[40];
    unsigned long   Attributes;
} List, *pList;

typedef struct _LogListItem {
    char *LogLine;
    struct _LogListItem *Next;
} LogListItem, *pLogListItem;

//
// decarations
//

VOID
FindFiles();

VOID
Imagechk(
    List *rgpList,
    TCHAR *szDirectory
    );

VOID
ParseArgs(
    int *pargc,
    char **argv
    );

int
__cdecl
CompFileAndDir(
    const void *elem1,
    const void *elem2
    );

int
__cdecl
CompName(
    const void *elem1,
    const void *elem2
    );

VOID
Usage(
    VOID
    );

int
_cdecl
_cwild(
    VOID
    );

PSYMMODLIST
MakeModList(
    HANDLE
    );

void
FreeModList(
    PSYMMODLIST
    );

BOOL
CALLBACK
SymEnumerateModulesCallback(
    LPSTR,
    ULONG64,
    PVOID
    );

void *
GetModAddrFromName(
    PSYMMODLIST,
    char *
    );

BOOL
VerifyVersionResource(
    PCHAR FileName,
    BOOL fSelfRegister
    );

BOOL
ValidatePdata(
    PIMAGE_DOS_HEADER DosHeader
    );

BOOL
ImageNeedsOleSelfRegister(
    PIMAGE_DOS_HEADER DosHeader
    );

NTSTATUS
MiVerifyImageHeader (
    IN PIMAGE_NT_HEADERS NtHeader,
    IN PIMAGE_DOS_HEADER DosHeader,
    IN DWORD NtHeaderSize
    );

pLogListItem
LogAppend(
    char *,
    pLogListItem
    );

void
LogOutAndClean(
    BOOL
    );

void
LogPrintf(
    const char *format,
    ...
    );

#define X64K (64*1024)

#define MM_SIZE_OF_LARGEST_IMAGE ((ULONG)0x10000000)

#define MM_MAXIMUM_IMAGE_HEADER (2 * PageSize)

#define MM_MAXIMUM_IMAGE_SECTIONS                       \
     ((MM_MAXIMUM_IMAGE_HEADER - (4096 + sizeof(IMAGE_NT_HEADERS))) /  \
            sizeof(IMAGE_SECTION_HEADER))

#define MMSECTOR_SHIFT 9  //MUST BE LESS THAN OR EQUAL TO PageShift

#define MMSECTOR_MASK 0x1ff

#define MI_ROUND_TO_SIZE(LENGTH,ALIGNMENT)     \
                    (((ULONG)LENGTH + ALIGNMENT - 1) & ~(ALIGNMENT - 1))

#define BYTES_TO_PAGES(Size)  (((ULONG)(Size) >> PageShift) + \
                               (((ULONG)(Size) & (PageSize - 1)) != 0))

#define ArgFlag_OK      1
#define ArgFlag_CKMZ    2
#define ArgFlag_SymCK   4
#define ArgFlag_OLESelf 8
#define ArgFlag_CKBase  16

//
// file global data
//

BOOL fRecurse;
BOOL fFileOut;
BOOL fNotCurrent;
BOOL fPattern;
BOOL fSingleFile;
BOOL fPathOverride;
BOOL fSingleSlash;
BOOL fDebugMapped;
FILE* fout;
CHAR *szFileName = {"*.*"};
CHAR *pszRootDir;
CHAR *pszFileOut;
CHAR szDirectory[MAX_PATH] = {"."};
CHAR szSympath[MAX_PATH] = {0};
CHAR *szPattern;
int endpath, DirNum=1, ProcessedFiles;
ULONG PageSize;
ULONG PageShift;
PVOID HighestUserAddress;
USHORT ValidMachineIDMin;
USHORT ValidMachineIDMax;
DWORD ArgFlag;

//
// logging support
//

pLogListItem pLogList = NULL;
pLogListItem pLogListTmp = NULL;

typedef
NTSTATUS
(NTAPI *LPLDRVERIFYIMAGECHKSUM)(
    IN HANDLE ImageFileHandle
    );

LPLDRVERIFYIMAGECHKSUM lpOldLdrVerifyImageMatchesChecksum;

typedef
NTSTATUS
(NTAPI *LPLDRVERIFYIMAGEMATCHESCHECKSUM) (
    IN HANDLE ImageFileHandle,
    IN PLDR_IMPORT_MODULE_CALLBACK ImportCallbackRoutine OPTIONAL,
    IN PVOID ImportCallbackParameter,
    OUT PUSHORT ImageCharacteristics OPTIONAL
    );

LPLDRVERIFYIMAGEMATCHESCHECKSUM lpNewLdrVerifyImageMatchesChecksum;

typedef
NTSTATUS
(NTAPI *LPNTQUERYSYSTEMINFORMATION) (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

LPNTQUERYSYSTEMINFORMATION lpNtQuerySystemInformation;


OSVERSIONINFO VersionInformation;

//
// function definitions
//

VOID __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
/*++

Routine Description:

    program entry

Arguments:

    int     argc,
    char    *argv[]
    char    *envp[]

Return Value:

    none

Notes:


--*/
{
    TCHAR CWD[MAX_PATH];
    int dirlen=0;

    if (argc < 2) {
        Usage();
    }

    ParseArgs(&argc, argv);

    GetCurrentDirectory(MAX_PATH, CWD);

    VersionInformation.dwOSVersionInfoSize = sizeof(VersionInformation);
    if (!GetVersionEx( &VersionInformation )) {
        fprintf(stderr, "Unable to detect OS version.  Terminating.\n" );
        exit(1);
    }
    if ((VersionInformation.dwPlatformId != VER_PLATFORM_WIN32_NT) ||
        (VersionInformation.dwBuildNumber < 1230))
    {
        lpOldLdrVerifyImageMatchesChecksum = (LPLDRVERIFYIMAGECHKSUM)
            GetProcAddress(GetModuleHandle(TEXT("NTDLL.DLL")), TEXT("LdrVerifyImageMatchesChecksum"));
        if (lpOldLdrVerifyImageMatchesChecksum == NULL) {
            fprintf(stderr, "Incorrect operating system version.\n" );
            exit(1);
        }
    } else {
        lpOldLdrVerifyImageMatchesChecksum = NULL;
        if ((VersionInformation.dwPlatformId == VER_PLATFORM_WIN32_NT) &&
            (VersionInformation.dwBuildNumber >= 1230))
        {
            lpNewLdrVerifyImageMatchesChecksum = (LPLDRVERIFYIMAGEMATCHESCHECKSUM)
                GetProcAddress(GetModuleHandle(TEXT("NTDLL.DLL")), TEXT("LdrVerifyImageMatchesChecksum"));
            if (lpNewLdrVerifyImageMatchesChecksum == NULL) {
                fprintf(stderr, "OS is screwed up.  NTDLL doesn't export LdrVerifyImageMatchesChecksum.\n" );
                exit(1);
            }
        }
    }

    if (VersionInformation.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        SYSTEM_BASIC_INFORMATION SystemInformation;

        if (VersionInformation.dwBuildNumber <= 1465) {
            goto UseWin9x;
        }

        ValidMachineIDMin = USER_SHARED_DATA->ImageNumberLow;
        ValidMachineIDMax = USER_SHARED_DATA->ImageNumberHigh;
        lpNtQuerySystemInformation = (LPNTQUERYSYSTEMINFORMATION)
            GetProcAddress(GetModuleHandle(TEXT("NTDLL.DLL")), TEXT("NtQuerySystemInformation"));
        if (!lpNtQuerySystemInformation) {
            fprintf(stderr, "Incorrect operation system version.\n");
            exit(1);
        }
        if (!NT_SUCCESS((*lpNtQuerySystemInformation)(SystemBasicInformation,
                                                     &SystemInformation,
                                                     sizeof(SystemInformation),
                                                     NULL))) {
            fprintf(stderr, "OS is screwed up.  NtQuerySystemInformation failed.\n");
            exit(1);
        }
        HighestUserAddress = (PVOID)SystemInformation.MaximumUserModeAddress;
    } else {
UseWin9x:
        HighestUserAddress = (PVOID) 0x7FFE0000;
#ifdef _M_IX86
        ValidMachineIDMin = IMAGE_FILE_MACHINE_I386;
        ValidMachineIDMax = IMAGE_FILE_MACHINE_I386;
#elif defined(_M_ALPHA)
        ValidMachineIDMin = IMAGE_FILE_MACHINE_ALPHA;
        ValidMachineIDMax = IMAGE_FILE_MACHINE_ALPHA;
#elif defined(_M_IA64)
        ValidMachineIDMin = IMAGE_FILE_MACHINE_IA64;
        ValidMachineIDMax = IMAGE_FILE_MACHINE_IA64;
#elif defined(_M_AXP64)
        ValidMachineIDMin = IMAGE_FILE_MACHINE_AXP64;
        ValidMachineIDMax = IMAGE_FILE_MACHINE_AXP64;
#else
#error("Unknown machine type")
#endif
    }

    if (fPathOverride) {
        if (_chdir(szDirectory) == -1){   // cd to dir
            fprintf(stderr, "Path not found: %s\n", szDirectory);
            Usage();
        }
    }
    // remove trailing '\' needed only for above chdir, not for output formatting
    if (fSingleSlash) {
        dirlen = strlen(szDirectory);
        szDirectory[dirlen-1] = '\0';
    }

    FindFiles();

    fprintf(stdout, "%d files processed in %d directories\n", ProcessedFiles, DirNum);
}

VOID
FindFiles()
/*++

Routine Description:

    make list of files to check, then check them

Arguments:

    none

Return Value:

    none

Notes:


--*/
{

    HANDLE fh;
    TCHAR CWD[MAX_PATH];
    char *q;
    WIN32_FIND_DATA *pfdata;
    BOOL fFilesInDir=FALSE;
    BOOL fDirsFound=FALSE;
    int dnCounter=0, cNumDir=0, i=0, Length=0, NameSize=0, total=0, cNumFiles=0;

    pList rgpList[5000];

    pfdata = (WIN32_FIND_DATA*)malloc(sizeof(WIN32_FIND_DATA));
    if (!pfdata) {
        fprintf(stderr, "Not enough memory.\n");
        return;
    }

    if (!fRecurse) {
        fh = FindFirstFile(szFileName, pfdata);  // find only filename (pattern) if not recursive
    } else {
        fh = FindFirstFile("*.*", pfdata);       // find all if recursive in order to determine subdirectory names
    }

    if (fh == INVALID_HANDLE_VALUE) {
        fprintf(fout==NULL? stderr : fout , "File not found: %s\n", szFileName);
        return;
    }

    // loop to find all files and directories in current directory
    // and copy pertinent data to individual List structures.
    do {
        if (strcmp(pfdata->cFileName, ".") && strcmp(pfdata->cFileName, "..")) {  // skip . and ..
            rgpList[dnCounter] = (pList)malloc(sizeof(List));  // allocate the memory
            if (!rgpList[dnCounter]) {
                fprintf(stderr, "Not enough memory.\n");
                return;
            }

            if (!(pfdata->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {   // if file

                fFilesInDir=TRUE;

                // see if given pattern wildcard extension matches pfdata->cFileName extension
                if (fPattern) {
                    q = strchr(pfdata->cFileName, '.');    // find first instance of "." in filename
                    if (q == NULL) goto blah;             // "." not found
                    _strlwr(q);                            // lowercase before compare
                    if (strcmp(q, szPattern)) goto blah;  // if pattern and name doesn't match goto
                }                                        // OK, I used a goto, get over it.

                if (fSingleFile) {
                    _strlwr(pfdata->cFileName);
                    _strlwr(szFileName);
                    if (strcmp(pfdata->cFileName, szFileName)) goto blah;
                }

                // if pattern && match || no pattern
                strcpy(rgpList[dnCounter]->Name, pfdata->cFileName);
                _strlwr(rgpList[dnCounter]->Name);  // all lowercase for strcmp in CompName

                memcpy(&(rgpList[dnCounter]->Attributes), &pfdata->dwFileAttributes, 4);
                dnCounter++;
                cNumFiles++;
            } else {
                if (pfdata->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {   // if dir

                    fDirsFound=TRUE;
                    //cNumDir++;

                    if (fRecurse) {
                        strcpy(rgpList[dnCounter]->Name, pfdata->cFileName);
                        _strlwr(rgpList[dnCounter]->Name);  // all lowercase for strcmp in CompName
                        memcpy(&(rgpList[dnCounter]->Attributes), &pfdata->dwFileAttributes, 4);
                        cNumDir++;
                        dnCounter++;
                    }
                }
            }
        }
blah: ;

    } while (FindNextFile(fh, pfdata));

    FindClose(fh); // close the file handle

    // Sort Array arranging FILE entries at top
    qsort( (void *)rgpList, dnCounter, sizeof(List *), CompFileAndDir);

    // Sort Array alphabetizing only FILE names
    qsort( (void *)rgpList, dnCounter-cNumDir, sizeof(List *), CompName);

    // Sort Array alphabetizing only DIRectory names
    if (fRecurse) {
        qsort( (void *)&rgpList[dnCounter-cNumDir], cNumDir, sizeof(List *), CompName);
    }

    // Process newly sorted structures.
    for (i=0; i < dnCounter; ++i) {

        if (rgpList[i]->Attributes & FILE_ATTRIBUTE_DIRECTORY) {  // if Dir
            if (fRecurse) {

                if (_chdir(rgpList[i]->Name) == -1){   // cd into subdir and check for error
                    fprintf(stderr, "Unable to change directory: %s\n", rgpList[i]->Name);

                } else {

                    NameSize = strlen(rgpList[i]->Name);
                    strcat(szDirectory, "\\");
                    strcat(szDirectory, rgpList[i]->Name); //append name to directory path
                    total = strlen(szDirectory);
                    DirNum++;      // directory counter

                    // start another iteration of FindFiles
                    FindFiles();

                    // get back to previous directory when above iteration returns
                    _chdir("..");

                    // cut off previously appended directory name - for output only
                    szDirectory[total-(NameSize+1)]='\0';
                }
            }
        } else {
            if (!(rgpList[i]->Attributes & FILE_ATTRIBUTE_DIRECTORY))   // check image if not dir
                Imagechk(rgpList[i], szDirectory);
        }
    }
} // end FindFiles

VOID
Imagechk(
    List *rgpList,
    TCHAR *szDirectory
    )
/*++

Routine Description:

    check various things, including:
        image type, header alignment, image size, machine type
        alignment, some properties of various sections, checksum integrity
        symbol / image file checksum agreement, existence of symbols, etc

Arguments:

    List *  rgpList,
    TCHAR * szDirectory

Return Value:

    none

Notes:


--*/
{

    HANDLE File;
    HANDLE MemMap;
    PIMAGE_DOS_HEADER DosHeader;
    PIMAGE_NT_HEADERS NtHeader;
    NTSTATUS Status;
    BY_HANDLE_FILE_INFORMATION FileInfo;
    ULONG NumberOfPtes;
    ULONG SectionVirtualSize = 0;
    ULONG i;
    PIMAGE_SECTION_HEADER SectionTableEntry;
    ULONG NumberOfSubsections;
    PCHAR ExtendedHeader = NULL;
    ULONG_PTR PreferredImageBase;
    ULONG_PTR NextVa;
    ULONG ImageFileSize;
    ULONG OffsetToSectionTable;
    ULONG ImageAlignment;
    ULONG PtesInSubsection;
    ULONG StartingSector;
    ULONG EndingSector;
    LPSTR ImageName;
    LPSTR MachineType = "Unknown";
    BOOL MachineTypeMismatch;
    BOOL ImageOk;
    BOOL fHasPdata;
    OSVERSIONINFO OSVerInfo;

    ImageName = rgpList->Name;
    OSVerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&OSVerInfo);

    LogPrintf("ImageChk: %s\\%s \n", szDirectory, ImageName);

    ProcessedFiles++;

    DosHeader = NULL;
    ImageOk = TRUE;
    File = CreateFile (ImageName,
                        GENERIC_READ | FILE_EXECUTE,
                        OSVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT ? (FILE_SHARE_READ | FILE_SHARE_DELETE) : FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (File == INVALID_HANDLE_VALUE) {
        LogPrintf("Error, CreateFile() %d\n", GetLastError());
        ImageOk = FALSE;
        goto NextImage;
    }

    MemMap = CreateFileMapping (File,
                        NULL,           // default security.
                        PAGE_READONLY,  // file protection.
                        0,              // high-order file size.
                        0,
                        NULL);

    if (!GetFileInformationByHandle(File, &FileInfo)) {
        fprintf(stderr,"Error, GetFileInfo() %d\n", GetLastError());
        CloseHandle(File);
        ImageOk = FALSE; goto NextImage;
    }

    DosHeader = (PIMAGE_DOS_HEADER) MapViewOfFile(MemMap,
                              FILE_MAP_READ,
                              0,  // high
                              0,  // low
                              0   // whole file
                              );

    CloseHandle(MemMap);
    if (!DosHeader) {
        fprintf(stderr,"Error, MapViewOfFile() %d\n", GetLastError());
        ImageOk = FALSE; goto NextImage;
    }

    //
    // Check to determine if this is an NT image (PE format) or
    // a DOS image, Win-16 image, or OS/2 image.  If the image is
    // not NT format, return an error indicating which image it
    // appears to be.
    //

    if (DosHeader->e_magic != IMAGE_DOS_SIGNATURE) {

        if (ArgFlag & ArgFlag_CKMZ) {
            LogPrintf("MZ header not found\n");
            ImageOk = FALSE;
        }
        goto NeImage;
    }


    if (((ULONG)DosHeader->e_lfanew & 3) != 0) {

        //
        // The image header is not aligned on a long boundary.
        // Report this as an invalid protect mode image.
        //

        LogPrintf("Image header not on Long boundary\n");
        ImageOk = FALSE;
        goto NeImage;
    }


    if ((ULONG)DosHeader->e_lfanew > FileInfo.nFileSizeLow) {
        LogPrintf("Image size bigger than size of file\n");
        ImageOk = FALSE;
        goto NeImage;
    }

    NtHeader = (PIMAGE_NT_HEADERS)((PCHAR)DosHeader + (ULONG)DosHeader->e_lfanew);

    if (NtHeader->Signature != IMAGE_NT_SIGNATURE) { //if not PE image

        LogPrintf("Non 32-bit image");
        ImageOk = TRUE;
        goto NeImage;
    }

    //
    // Check to see if this is an NT image or a DOS or OS/2 image.
    //

    Status = MiVerifyImageHeader (NtHeader, DosHeader, 50000);
    if (Status != STATUS_SUCCESS) {
        ImageOk = FALSE;            //continue checking the image but don't print "OK"
    }

    //
    // Verify machine type.
    //

    fHasPdata = TRUE;       // Most do

    switch (NtHeader->FileHeader.Machine) {
        case IMAGE_FILE_MACHINE_I386:
            MachineType = "x86";
            PageSize = 4096;
            PageShift = 12;
            fHasPdata = FALSE;
            break;

        case IMAGE_FILE_MACHINE_ALPHA:
            MachineType = "Alpha";
            PageSize = 8192;
            PageShift = 13;
            break;

        case IMAGE_FILE_MACHINE_IA64:
            MachineType = "Intel64";
            PageSize = 8192;
            PageShift = 13;
            break;

        case IMAGE_FILE_MACHINE_ALPHA64:
            MachineType = "Alpha64";
            PageSize = 8192;
            PageShift = 13;
            break;

        default:
            LogPrintf("Unrecognized machine type x%lx\n",
                NtHeader->FileHeader.Machine);
            ImageOk = FALSE;
            break;
        }

    if ((NtHeader->FileHeader.Machine < ValidMachineIDMin) ||
        (NtHeader->FileHeader.Machine > ValidMachineIDMax)) {
        MachineTypeMismatch = TRUE;
    } else {
        MachineTypeMismatch = FALSE;
    }

    ImageAlignment = NtHeader->OptionalHeader.SectionAlignment;

    NumberOfPtes = BYTES_TO_PAGES (NtHeader->OptionalHeader.SizeOfImage);

    NextVa = NtHeader->OptionalHeader.ImageBase;

    if ((NextVa & (X64K - 1)) != 0) {

        //
        // Image header is not aligned on a 64k boundary.
        //

        LogPrintf("image base not on 64k boundary %lx\n",NextVa);

        ImageOk = FALSE;
        goto BadPeImageSegment;
    }

    //BasedAddress = (PVOID)NextVa;
    PtesInSubsection = MI_ROUND_TO_SIZE (
                                       NtHeader->OptionalHeader.SizeOfHeaders,
                                       ImageAlignment
                                   ) >> PageShift;

    if (ImageAlignment >= PageSize) {

        //
        // Aligmment is PageSize of greater.
        //

        if (PtesInSubsection > NumberOfPtes) {

            //
            // Inconsistent image, size does not agree with header.
            //

            LogPrintf("Image size in header (%ld.) not consistent with sections (%ld.)\n",
                    NumberOfPtes, PtesInSubsection);
            ImageOk = FALSE;
            goto BadPeImageSegment;
        }

        NumberOfPtes -= PtesInSubsection;

        EndingSector = NtHeader->OptionalHeader.SizeOfHeaders >> MMSECTOR_SHIFT;

        for (i = 0; i < PtesInSubsection; i++) {

            NextVa += PageSize;
        }
    }

    //
    // Build the next subsections.
    //

    NumberOfSubsections = NtHeader->FileHeader.NumberOfSections;
    PreferredImageBase = NtHeader->OptionalHeader.ImageBase;

    //
    // At this point the object table is read in (if it was not
    // already read in) and may displace the image header.
    //

    OffsetToSectionTable = sizeof(ULONG) +
                              sizeof(IMAGE_FILE_HEADER) +
                              NtHeader->FileHeader.SizeOfOptionalHeader;

    SectionTableEntry = (PIMAGE_SECTION_HEADER)((PCHAR)NtHeader + OffsetToSectionTable);

    if (ImageAlignment < PageSize) {

        // The image header is no longer valid, TempPte is
        // used to indicate that this image alignment is
        // less than a PageSize.

        //
        // Loop through all sections and make sure there is no
        // unitialized data.
        //

        while (NumberOfSubsections > 0) {
            if (SectionTableEntry->Misc.VirtualSize == 0) {
                SectionVirtualSize = SectionTableEntry->SizeOfRawData;
            } else {
                SectionVirtualSize = SectionTableEntry->Misc.VirtualSize;
            }

            //
            // If the pointer to raw data is zero and the virtual size
            // is zero, OR, the section goes past the end of file, OR
            // the virtual size does not match the size of raw data, then
            // return an error.
            //

            if (((SectionTableEntry->PointerToRawData !=
                  SectionTableEntry->VirtualAddress))
                        ||
                ((SectionTableEntry->SizeOfRawData +
                        SectionTableEntry->PointerToRawData) >
                     FileInfo.nFileSizeLow)
                        ||
               (SectionVirtualSize > SectionTableEntry->SizeOfRawData)) {

                LogPrintf("invalid BSS/Trailingzero section/file size\n");

                ImageOk = FALSE;
                goto NeImage;
            }
            SectionTableEntry += 1;
            NumberOfSubsections -= 1;
        }
        goto PeReturnSuccess;
    }

    while (NumberOfSubsections > 0) {

        //
        // Handle case where virtual size is 0.
        //

        if (SectionTableEntry->Misc.VirtualSize == 0) {
            SectionVirtualSize = SectionTableEntry->SizeOfRawData;
        } else {
            SectionVirtualSize = SectionTableEntry->Misc.VirtualSize;
        }

        if (!strcmp(SectionTableEntry->Name, ".debug")) {
            fDebugMapped = TRUE;
        }

        if (SectionVirtualSize == 0) {
            //
            // The specified virtual address does not align
            // with the next prototype PTE.
            //

            LogPrintf("Section virtual size is 0, NextVa for section %lx %lx\n",
                    SectionTableEntry->VirtualAddress, NextVa);
            ImageOk = FALSE;
            goto BadPeImageSegment;
        }

        if (NextVa !=
                (PreferredImageBase + SectionTableEntry->VirtualAddress)) {

            //
            // The specified virtual address does not align
            // with the next prototype PTE.
            //

            LogPrintf("Section Va not set to alignment, NextVa for section %lx %lx\n",
                    SectionTableEntry->VirtualAddress, NextVa);
            ImageOk = FALSE;
            goto BadPeImageSegment;
        }

        PtesInSubsection =
            MI_ROUND_TO_SIZE (SectionVirtualSize, ImageAlignment) >> PageShift;

        if (PtesInSubsection > NumberOfPtes) {

            //
            // Inconsistent image, size does not agree with object tables.
            //
            LogPrintf("Image size in header not consistent with sections, needs %ld. pages\n",
                PtesInSubsection - NumberOfPtes);
            LogPrintf("va of bad section %lx\n",SectionTableEntry->VirtualAddress);

            ImageOk = FALSE;
            goto BadPeImageSegment;
        }
        NumberOfPtes -= PtesInSubsection;

        StartingSector = SectionTableEntry->PointerToRawData >> MMSECTOR_SHIFT;
        EndingSector =
                         (SectionTableEntry->PointerToRawData +
                                     SectionVirtualSize);
        EndingSector = EndingSector >> MMSECTOR_SHIFT;

        ImageFileSize = SectionTableEntry->PointerToRawData +
                                    SectionTableEntry->SizeOfRawData;

        for (i = 0; i < PtesInSubsection; i++) {

            //
            // Set all the prototype PTEs to refer to the control section.
            //

            NextVa += PageSize;
        }

        SectionTableEntry += 1;
        NumberOfSubsections -= 1;
    }

    //
    // If the file size is not as big as the image claimed to be,
    // return an error.
    //

    if (ImageFileSize > FileInfo.nFileSizeLow) {

        //
        // Invalid image size.
        //

        LogPrintf("invalid image size - file size %lx - image size %lx\n",
            FileInfo.nFileSizeLow, ImageFileSize);
        ImageOk = FALSE;
        goto BadPeImageSegment;
    }

    {
        // Validate the debug information (as much as we can).
        PVOID ImageBase;
        ULONG DebugDirectorySize, NumberOfDebugDirectories, i;
        PIMAGE_DEBUG_DIRECTORY DebugDirectory;

        ImageBase = (PVOID) DosHeader;

        DebugDirectory = (PIMAGE_DEBUG_DIRECTORY)
            ImageDirectoryEntryToData(
                ImageBase,
                FALSE,
                IMAGE_DIRECTORY_ENTRY_DEBUG,
                &DebugDirectorySize );

        if (!DebugDirectoryIsUseful(DebugDirectory, DebugDirectorySize)) {

            // Not useful.  Are they valid? (both s/b zero)

            if (DebugDirectory || DebugDirectorySize) {
                LogPrintf("Debug directory values [%x, %x] are invalid\n",
                        DebugDirectory,
                        DebugDirectorySize);
                ImageOk = FALSE;
            }

            goto DebugDirsDone;
        }

        NumberOfDebugDirectories = DebugDirectorySize / sizeof( IMAGE_DEBUG_DIRECTORY );

        for (i=0; i < NumberOfDebugDirectories; i++) {
            if (DebugDirectory->PointerToRawData > FileInfo.nFileSizeLow) {
                LogPrintf("Invalid debug directory entry[%d] - File Offset %x is beyond the end of the file\n",
                        i,
                        DebugDirectory->PointerToRawData
                       );
                ImageOk = FALSE;
                goto BadPeImageSegment;
            }

            if ((DebugDirectory->PointerToRawData + DebugDirectory->SizeOfData) > FileInfo.nFileSizeLow) {
                LogPrintf("Invalid debug directory entry[%d] - File Offset (%X) + Size (%X) is beyond the end of the file (filesize: %X)\n",
                        i,
                        DebugDirectory->PointerToRawData,
                        DebugDirectory->SizeOfData,
                        FileInfo.nFileSizeLow
                       );
                ImageOk = FALSE;
                goto BadPeImageSegment;
            }

            if (DebugDirectory->AddressOfRawData != 0) {
                if (!fDebugMapped) {
                    LogPrintf("Invalid debug directory entry[%d] - VA is non-zero (%X), but no .debug section exists\n",
                            i,
                            DebugDirectory->AddressOfRawData);
                    ImageOk = FALSE;
                    goto BadPeImageSegment;
                }
                if (DebugDirectory->AddressOfRawData > ImageFileSize){
                    LogPrintf("Invalid debug directory entry[%d] - VA (%X) is beyond the end of the image VA (%X)\n",
                            i,
                            DebugDirectory->AddressOfRawData,
                            ImageFileSize);
                    ImageOk = FALSE;
                    goto BadPeImageSegment;
                }

                if ((DebugDirectory->AddressOfRawData + DebugDirectory->SizeOfData )> ImageFileSize){
                    LogPrintf("Invalid debug directory entry[%d] - VA (%X) + size (%X) is beyond the end of the image VA (%X)\n",
                            i,
                            DebugDirectory->AddressOfRawData,
                            DebugDirectory->SizeOfData,
                            ImageFileSize);
                    ImageOk = FALSE;
                    goto BadPeImageSegment;
                }
            }

            if (DebugDirectory->Type <= 0x7fffffff) {
                switch (DebugDirectory->Type) {
                    case IMAGE_DEBUG_TYPE_MISC:
                        {
                            PIMAGE_DEBUG_MISC pDebugMisc;
                            // MISC should point to an IMAGE_DEBUG_MISC structure
                            pDebugMisc = (PIMAGE_DEBUG_MISC)((PCHAR)ImageBase + DebugDirectory->PointerToRawData);
                            if (pDebugMisc->DataType != IMAGE_DEBUG_MISC_EXENAME) {
                                LogPrintf("MISC Debug has an invalid DataType\n");
                                ImageOk = FALSE;
                                goto BadPeImageSegment;
                            }
                            if (pDebugMisc->Length != DebugDirectory->SizeOfData) {
                                LogPrintf("MISC Debug has an invalid size.\n");
                                ImageOk = FALSE;
                                goto BadPeImageSegment;
                            }

                            if (!pDebugMisc->Unicode) {
                                i= 0;
                                while (i < pDebugMisc->Length - sizeof(IMAGE_DEBUG_MISC)) {
                                    if (!isprint(pDebugMisc->Data[i]) &&
                                        (pDebugMisc->Data[i] != '\0') )
                                    {
                                        LogPrintf("MISC Debug has unprintable characters... Possibly corrupt\n");
                                        ImageOk = FALSE;
                                        goto BadPeImageSegment;
                                    }
                                    i++;
                                }

                                // The data must be a null terminated string.
                                if (strlen(pDebugMisc->Data) > (pDebugMisc->Length - sizeof(IMAGE_DEBUG_MISC))) {
                                    LogPrintf("MISC Debug has invalid data... Possibly corrupt\n");
                                    ImageOk = FALSE;
                                    goto BadPeImageSegment;
                                }
                            }
                        }
                        break;

                    case IMAGE_DEBUG_TYPE_CODEVIEW:
                        // CV will point to either a NB09 or an NB10 signature.  Make sure it does.
                        {
                            OMFSignature * CVDebug;
                            CVDebug = (OMFSignature *)((PCHAR)ImageBase + DebugDirectory->PointerToRawData);
                            if (((*(PULONG)(CVDebug->Signature)) != '90BN') &&
                                ((*(PULONG)(CVDebug->Signature)) != '01BN'))
                            {
                                LogPrintf("CV Debug has an invalid signature\n");
                                ImageOk = FALSE;
                                goto BadPeImageSegment;
                            }
                        }
                        break;

                    case IMAGE_DEBUG_TYPE_COFF:
                    case IMAGE_DEBUG_TYPE_FPO:
                    case IMAGE_DEBUG_TYPE_EXCEPTION:
                    case IMAGE_DEBUG_TYPE_FIXUP:
                    case IMAGE_DEBUG_TYPE_OMAP_TO_SRC:
                    case IMAGE_DEBUG_TYPE_OMAP_FROM_SRC:
                        // Not much we can do about these now.
                        break;

                    default:
                        LogPrintf("Invalid debug directory type: %d\n", DebugDirectory->Type);
                        ImageOk = FALSE;
                        goto BadPeImageSegment;
                        break;
                }
            }
        }

    }

DebugDirsDone:

    //
    // The total number of PTEs was decremented as sections were built,
    // make sure that there are less than 64ks worth at this point.
    //

    if (NumberOfPtes >= (ImageAlignment >> PageShift)) {

        //
        // Inconsistent image, size does not agree with object tables.
        //

        LogPrintf("invalid image - PTEs left %lx\n",
            NumberOfPtes);

        ImageOk = FALSE;
        goto BadPeImageSegment;
    }

    //
    // check checksum.
    //

PeReturnSuccess:
    if (NtHeader->OptionalHeader.CheckSum == 0) {
        LogPrintf("(checksum is zero)\n");
    } else {
        __try {
            if (lpOldLdrVerifyImageMatchesChecksum == NULL) {
                if (lpNewLdrVerifyImageMatchesChecksum == NULL) {
                    Status = STATUS_SUCCESS;
                    LogPrintf("Unable to validate checksum\n");
                } else {
                    Status = (*lpNewLdrVerifyImageMatchesChecksum)(File, NULL, NULL, NULL);
                }
            } else {
                Status = (*lpOldLdrVerifyImageMatchesChecksum)(File);
            }

            if (NT_ERROR(Status)) {
                LogPrintf("checksum mismatch\n");
                ImageOk = FALSE;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            ImageOk = FALSE;
            LogPrintf("checksum mismatch\n");
        }
    }

    if (fHasPdata && ImageOk) {
        ImageOk = ValidatePdata(DosHeader);
    }

    if (ImageOk) {
        ImageOk = VerifyVersionResource(ImageName, ImageNeedsOleSelfRegister(DosHeader));
    }

    //
    // sanity test for symbols
    // basically : if this does not work, debugging probably will not either
    // these high-level debugging api's will also call a pdb validation routine
    //

    if(ArgFlag & ArgFlag_SymCK)
    {
        HANDLE hProcess = 0;
        char Target[MAX_PATH] = {0};
        char drive[_MAX_DRIVE];
        char dir[_MAX_DIR];
        char fname[_MAX_FNAME];
        char ext[_MAX_EXT];
        IMAGEHLP_MODULE64 ModuleInfo = {0};
        PSYMMODLIST ModList = 0;
        void *vpAddr;
        PLOADED_IMAGE pLImage = NULL;
        DWORD64 symLMflag;

        strcpy(Target, szDirectory);
        strcat(Target, "\\");
        strcat(Target, ImageName);

        //
        // set up for debugging
        //

        hProcess = GetCurrentProcess();

        if(!SymInitialize(hProcess, szSympath, FALSE))
        {
            LogPrintf("ERROR:SymInitialize failed!\n");
            hProcess = 0;
            goto symckend;
        }

        //
        // attempt to use symbols
        //

        _splitpath(Target, drive, dir, fname, ext );

        symLMflag = SymLoadModule64(hProcess, NULL, Target, fname, 0, 0);
        if(!symLMflag)
        {
            LogPrintf("ERROR:SymLoadModule failed! last error:0x%x\n", GetLastError());
            goto symckend;
        }

        //
        // identify module type
        // find module, symgetmoduleinfo, check dbg type
        //

        ModuleInfo.SizeOfStruct = sizeof(ModuleInfo);
        ModList = MakeModList(hProcess);
        vpAddr = GetModAddrFromName(ModList, fname);

        if(!SymGetModuleInfo64(hProcess, (DWORD64)vpAddr, &ModuleInfo))
        {
            LogPrintf("ERROR:SymGetModuleInfo failed! last error:0x%x\n", GetLastError());
            goto symckend;
        }

        if(ModuleInfo.SymType != SymPdb)
        {
            LogPrintf("WARNING: No pdb info for file!\n");
            switch(ModuleInfo.SymType){
                case SymNone:
                    LogPrintf("symtype: SymNone\n");
                    break;
                case SymCoff:
                    LogPrintf("symtype: SymCoff\n");
                    break;
                case SymCv:
                    LogPrintf("symtype: SymCv\n");
                    break;
                case SymPdb:
                    LogPrintf("symtype: SymPdb\n");
                    break;
                case SymExport:
                    LogPrintf("symtype: SymExport\n");
                    break;
                case SymDeferred:
                    LogPrintf("symtype: SymDeferred\n");
                    break;
                case SymSym:
                    LogPrintf("symtype: SymSym\n");
                    break;
            }
        }

        //
        // get image, symbol checksum, compare
        //

        pLImage = ImageLoad(Target, NULL);

        {
            CHAR szDbgPath[_MAX_PATH];
            HANDLE DbgFileHandle;

            DbgFileHandle = FindDebugInfoFile(Target, szSympath, szDbgPath);
            if (DbgFileHandle != INVALID_HANDLE_VALUE) {
                IMAGE_SEPARATE_DEBUG_HEADER DbgHeader;
                DWORD BytesRead;
                BOOL ReadSuccess;

                SetFilePointer(DbgFileHandle, 0, 0, FILE_BEGIN);
                ReadSuccess = ReadFile(DbgFileHandle, &DbgHeader, sizeof(DbgHeader), &BytesRead, NULL);

                if (ReadSuccess && (BytesRead == sizeof(DbgHeader))) {
                    // Got enough to check if it's a valid dbg file.
                    if(((PIMAGE_NT_HEADERS)pLImage->FileHeader)->OptionalHeader.CheckSum != DbgHeader.CheckSum) {
                        LogPrintf("ERROR! image / debug file checksum not equal\n");
                        ImageOk = FALSE;
                    }
                }
                CloseHandle(DbgFileHandle);
            }
        }

        //
        // cleanup
        //

symckend:
        if(ModList)
        {
            FreeModList(ModList);
        }
        if(pLImage)
        {
            ImageUnload(pLImage);
        }
        if(symLMflag)
        {
            SymUnloadModule64(hProcess, (DWORD)symLMflag);
        }
        if(hProcess)
        {
            SymCleanup(hProcess);
        }
    }

NextImage:
BadPeImageSegment:
NeImage:
    if ( ImageOk && (ArgFlag & ArgFlag_OK)) {
        if (MachineTypeMismatch) {
            LogPrintf(" OK [%s]\n", MachineType);
        } else {
            LogPrintf(" OK\n");
        }
    }

    //
    // print out results
    //

    if (ImageOk)
    {
        LogOutAndClean((ArgFlag & ArgFlag_OK) ? TRUE : FALSE);
    } else {
        LogOutAndClean(TRUE);
    }

    if ( File != INVALID_HANDLE_VALUE ) {
        CloseHandle(File);
    }
    if ( DosHeader ) {
        UnmapViewOfFile(DosHeader);
    }
}

NTSTATUS
MiVerifyImageHeader (
    IN PIMAGE_NT_HEADERS NtHeader,
    IN PIMAGE_DOS_HEADER DosHeader,
    IN ULONG NtHeaderSize
    )
/*++

Routine Description:

    Checks image header for consistency.

Arguments:

    IN PIMAGE_NT_HEADERS    NtHeader
    IN PIMAGE_DOS_HEADER    DosHeader
    IN ULONG                NtHeaderSize

Return Value:

    Returns the status value.

    TBS

--*/
{

    if ((NtHeader->FileHeader.Machine == 0) &&
        (NtHeader->FileHeader.SizeOfOptionalHeader == 0)) {

        //
        // This is a bogus DOS app which has a 32-bit portion
        // mascarading as a PE image.
        //

        LogPrintf("Image machine type and size of optional header bad\n");
        return STATUS_INVALID_IMAGE_PROTECT;
    }

    if (!(NtHeader->FileHeader.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE)) {
        LogPrintf("Characteristics not image file executable\n");
        return STATUS_INVALID_IMAGE_FORMAT;
    }

#ifdef i386

    //
    // Make sure the image header is aligned on a Long word boundary.
    //

    if (((ULONG)NtHeader & 3) != 0) {
        LogPrintf("NtHeader is not aligned on longword boundary\n");
        return STATUS_INVALID_IMAGE_FORMAT;
    }
#endif

    // Non-driver code must have file alignment set to a multiple of 512

    if (((NtHeader->OptionalHeader.FileAlignment & 511) != 0) &&
        (NtHeader->OptionalHeader.FileAlignment !=
         NtHeader->OptionalHeader.SectionAlignment)) {
        LogPrintf("file alignment is not multiple of 512 and power of 2\n");
        return STATUS_INVALID_IMAGE_FORMAT;
    }

    //
    // File aligment must be power of 2.
    //

    if ((((NtHeader->OptionalHeader.FileAlignment << 1) - 1) &
        NtHeader->OptionalHeader.FileAlignment) !=
        NtHeader->OptionalHeader.FileAlignment) {
        LogPrintf("file alignment not power of 2\n");
        return STATUS_INVALID_IMAGE_FORMAT;
    }

    if (NtHeader->OptionalHeader.SectionAlignment < NtHeader->OptionalHeader.FileAlignment) {
        LogPrintf("SectionAlignment < FileAlignment\n");
        return STATUS_INVALID_IMAGE_FORMAT;
    }

    if (NtHeader->OptionalHeader.SizeOfImage > MM_SIZE_OF_LARGEST_IMAGE) {
        LogPrintf("Image too big %lx\n",NtHeader->OptionalHeader.SizeOfImage);
        return STATUS_INVALID_IMAGE_FORMAT;
    }

    if (NtHeader->FileHeader.NumberOfSections > MM_MAXIMUM_IMAGE_SECTIONS) {
        LogPrintf("Too many image sections %ld.\n",
                NtHeader->FileHeader.NumberOfSections);
        return STATUS_INVALID_IMAGE_FORMAT;
    }

    if (ArgFlag & ArgFlag_CKBase) {
       if ((PVOID)NtHeader->OptionalHeader.ImageBase >= HighestUserAddress) {
          LogPrintf("Image base (%lx) is invalid on this machine\n",
                NtHeader->OptionalHeader.ImageBase);
          return STATUS_SUCCESS;
       }
    }

    return STATUS_SUCCESS;
}


VOID
ParseArgs(
    int *pargc,
    char **argv
    )
/*++

Routine Description:

    parse arguments to this program

Arguments:

    int *pargc
    char **argv

Return Value:

    none

Notes:

    command line args:
    (original)
    case '?': call usage and exit
    case 'b': check whether base address of image is in user space for this machine
    case 's': /s <sympath> check symbols
    case 'p': PE Errors only
    case 'r': recurse subdirectories
    (new)
    case 'v': verbose - output "OK"
    case 'o': output "OleSelfRegister not set"

--*/
{
    CHAR cswitch, c, *p;
    CHAR sztmp[MAX_PATH];
    int argnum = 1, i=0, len=0, count=0;
    BOOL fslashfound = FALSE;

    //
    // set default flags here
    //

    ArgFlag |= ArgFlag_CKBase;

    while ( argnum < *pargc ) {
        _strlwr(argv[argnum]);
        cswitch = *(argv[argnum]);
        if (cswitch == '/' || cswitch == '-') {
            c = *(argv[argnum]+1);

            switch (c) {
                case 'o':
                    ArgFlag |= ArgFlag_OLESelf;
                    break;

                case 'v':
                    ArgFlag |= ArgFlag_OK | ArgFlag_CKMZ | ArgFlag_OLESelf;
                    break;

                case '?':
                    Usage();
                    break;

                case 'b':
                    ArgFlag ^= ArgFlag_CKBase;
                    break;

                case 's':
                    if (argv[argnum+1]) {
                        strcpy(szSympath, (argv[argnum+1]));
                        ArgFlag |= ArgFlag_SymCK;
                        argnum++;
                    }
                    break;

                case 'p':
                    ArgFlag |= ArgFlag_CKMZ;
                    break;

                case 'r':
                    fRecurse = TRUE;
                    if (argv[argnum+1]) {
                        fPathOverride=TRUE;
                        strcpy(szDirectory, (argv[argnum+1]));
                        if (!(strcmp(szDirectory, "\\"))) {  // if just '\'
                            fSingleSlash=TRUE;
                        }
                        //LogPrintf("dir %s\n", szDirectory);
                        argnum++;
                    }

                    break;

                default:
                    fprintf(stderr, "Invalid argument.\n");
                    Usage();
            }
        } else {
            // Check for path\filename or wildcards

            // Search for '\' in string
            strcpy(sztmp, (argv[argnum]));
            len = strlen(sztmp);
            for (i=0; i < len; i++) {
                if (sztmp[i]=='\\') {
                    count++;
                    endpath=i;         // mark last '\' char found
                    fslashfound=TRUE;  // found backslash, so must be a path\filename combination
                }
            }

            if (fslashfound && !fRecurse) { // if backslash found and not a recursive operation
                                            // seperate the directory and filename into two strings
                fPathOverride=TRUE;
                strcpy(szDirectory, sztmp);

                if (!(strcmp(szDirectory, "\\"))) {
                    Usage();
                }

                szFileName = _strdup(&(sztmp[endpath+1]));


                if (count == 1) { //&& szDirectory[1] == ':') { // if only one '\' char and drive letter indicated
                    fSingleSlash=TRUE;
                    szDirectory[endpath+1]='\0';  // keep trailing '\' in order to chdir properly
                }  else {
                    szDirectory[endpath]='\0';
                }

                if (szFileName[0] == '*' && szFileName[1] == '.' && szFileName[2] != '*') {
                    _strlwr(szFileName);
                    szPattern = strchr(szFileName, '.'); //search for '.'
                    fPattern = TRUE;
                }
            } else {  // no backslash found, assume filename without preceeding path

                szFileName = _strdup(argv[argnum]);
                //
                // filename or wildcard
                //
                if ( (*(argv[argnum]) == '*') && (*(argv[argnum]+1) == '.') && (*(argv[argnum]+2) != '*') ){
                    // *.xxx
                    _strlwr(szFileName);
                    szPattern = strchr(szFileName, '.'); //search for '.'
                    fPattern = TRUE;
                } else if ( (*(argv[argnum]) == '*') && (*(argv[argnum]+1) == '.') && (*(argv[argnum]+2) == '*') ) {
                    // *.*
                } else {
                    // probably a single filename
                    _strlwr(szFileName);
                    fSingleFile = TRUE;
                }

                if (fRecurse && strchr(szFileName, '\\') ) { // don't want path\filename when recursing
                    Usage();
                }

            }
            //fprintf(stdout, "dir %s\nfile %s\n", szDirectory, szFileName);
        }
        ++argnum;
    }
    if (szFileName[0] == '\0') {
        Usage();
    }
} // parseargs


int
__cdecl
CompFileAndDir(
    const void *elem1,
    const void *elem2
    )
/*++

Routine Description:

    Purpose: a comparision routine passed to QSort.  It compares elem1 and elem2
    based upon their attribute, i.e., is it a file or directory.

Arguments:

    const void *elem1,
    const void *elem2

Return Value:

    result of comparison function

Notes:


--*/
{
    pList p1, p2;
    // qsort passes a void universal pointer.  Use a typecast (List**)
    // so the compiler recognizes the data as a List structure.
    // Typecast pointer-to-pointer-to-List and dereference ONCE
    // leaving a pList.  I don't dereference the remaining pointer
    // in the p1 and p2 definitions to avoid copying the structure.

    p1 = (*(List**)elem1);
    p2 = (*(List**)elem2);

    if ( (p1->Attributes & FILE_ATTRIBUTE_DIRECTORY) &&  (p2->Attributes & FILE_ATTRIBUTE_DIRECTORY))
        return 0;
    //both dirs
    if (!(p1->Attributes & FILE_ATTRIBUTE_DIRECTORY) && !(p2->Attributes & FILE_ATTRIBUTE_DIRECTORY))
        return 0;
    //both files
    if ( (p1->Attributes & FILE_ATTRIBUTE_DIRECTORY) && !(p2->Attributes & FILE_ATTRIBUTE_DIRECTORY))
        return 1;
    // elem1 is dir and elem2 is file
    if (!(p1->Attributes & FILE_ATTRIBUTE_DIRECTORY) &&  (p2->Attributes & FILE_ATTRIBUTE_DIRECTORY))
        return -1;
    // elem1 is file and elem2 is dir

    return 0; // if none of the above
}

int
__cdecl
CompName(
    const void *elem1,
    const void *elem2
    )
/*++

Routine Description:

    another compare routine passed to QSort that compares the two Name strings

Arguments:

    const void *elem1,
    const void *elem2

Return Value:

    result of comparison function

Notes:

    this uses a noignore-case strcmp

--*/
{
   return strcmp( (*(List**)elem1)->Name, (*(List**)elem2)->Name );
}


VOID
Usage(
    VOID
    )
/*++

Routine Description:


Arguments:


Return Value:


Notes:


--*/
{
   fputs("Usage: imagechk  [/?] displays this message\n"
         "                 [/r dir] recurse from directory dir\n"
         "                 [/b] don't check image base address\n"
         "                 [/v] verbose - output everything\n"
         "                 [/o] output \"OleSelfRegister not set\" warning\n"
         "                 [/p] output \"MZ header not found\"\n"
         "                 [/s <sympath>] check pdb symbols\n"
         "                 [filename] file to check\n"
         " Accepts wildcard extensions such as *.exe\n"
         " imagechk /r . \"*.exe\"   check all *.exe recursing on current directory\n"
         " imagechk /r \\ \"*.exe\"  check all *.exe recursing from root of current drive\n"
         " imagechk \"*.exe\"        check all *.exe in current directory\n"
         " imagechk c:\\bar.exe      check c:\\bar.exe only\n",
         stderr);
   exit(1);
}

int
__cdecl
_cwild()
/*++

Routine Description:


Arguments:


Return Value:


Notes:


--*/
{
   return(0);
}

typedef DWORD (WINAPI *PFNGVS)(LPSTR, LPDWORD);
typedef BOOL (WINAPI *PFNGVI)(LPTSTR, DWORD, DWORD, LPVOID);
typedef BOOL (WINAPI *PFNVQV)(const LPVOID, LPTSTR, LPVOID *, PUINT);

BOOL
VerifyVersionResource(
    PCHAR FileName,
    BOOL fSelfRegister
    )
/*++

Routine Description:

    validate the version resource in a file

Arguments:

    PCHAR FileName
    BOOL fSelfRegister

Return Value:

    TRUE    if: no version.dll found
    FALSE   if: version resource missing


Notes:


--*/
{
    static HINSTANCE hVersion = NULL;
    static PFNGVS pfnGetFileVersionInfoSize = NULL;
    static PFNGVI pfnGetFileVersionInfo = NULL;
    static PFNVQV pfnVerQueryValue = NULL;
    DWORD dwSize;
    DWORD lpInfoSize;
    LPVOID lpData = NULL, lpInfo;
    BOOL rc = FALSE;
    DWORD dwDefLang = 0x00000409;
    DWORD *pdwTranslation, uLen;
    CHAR buf[60];

    CHAR szVersionDll[_MAX_PATH];

    if (GetSystemDirectory(szVersionDll, sizeof(szVersionDll))) {
        strcat(szVersionDll, "\\version.dll");
    } else {
        strcpy(szVersionDll, "version.dll");
    }

    if (!hVersion) {
        hVersion = LoadLibraryA(szVersionDll);
        if (hVersion == NULL) {
            return TRUE;
        }

        pfnGetFileVersionInfoSize = (PFNGVS) GetProcAddress(hVersion, "GetFileVersionInfoSizeA");
        pfnGetFileVersionInfo = (PFNGVI) GetProcAddress(hVersion, "GetFileVersionInfoA");
        pfnVerQueryValue = (PFNVQV) GetProcAddress(hVersion, "VerQueryValueA");
    }

    if (!pfnGetFileVersionInfoSize || !pfnGetFileVersionInfo || !pfnVerQueryValue) {
        rc = TRUE;
        goto cleanup;
    }

    if ((dwSize = (*pfnGetFileVersionInfoSize)(FileName, &dwSize)) == 0){
        LogPrintf("No version resource detected\n");
        goto cleanup;
    }

    if (!fSelfRegister) {
        // All we need to do is see if the version resource exists.  Ole Self Register not necessary.
        rc = TRUE;
        goto cleanup;
    }

    if ((lpData = malloc(dwSize)) == NULL) {
        LogPrintf("Out of memory\n");
        goto cleanup;
    }

    if (!(*pfnGetFileVersionInfo)(FileName, 0, dwSize, lpData)) {
        LogPrintf("Unable to read version info\n - %d", GetLastError());
        goto cleanup;
    }

    if(!pfnVerQueryValue(lpData, "\\VarFileInfo\\Translation", &pdwTranslation, &uLen)) {
        pdwTranslation = &dwDefLang;
        uLen = sizeof(DWORD);
    }

    sprintf(buf, "\\StringFileInfo\\%04x%04x\\OleSelfRegister", LOWORD(*pdwTranslation), HIWORD(*pdwTranslation));

    if (!pfnVerQueryValue(lpData, buf, &lpInfo, &lpInfoSize) && (ArgFlag & ArgFlag_OLESelf )) {
        LogPrintf("OleSelfRegister not set\n");
    } else {
        rc = TRUE;
    }

cleanup:
    if (lpData) {
        free(lpData);
    }

    // No need to free the hVersion
    return(rc);
}

BOOL
ValidatePdata(
    PIMAGE_DOS_HEADER DosHeader
    )
/*++

Routine Description:

    validates the PIMAGE_RUNTIME_FUNCTION_ENTRY in the executable

Arguments:

    PIMAGE_DOS_HEADER   DosHeader

Return Value:

    TRUE    if:
    FALSE   if: no exception data
                exception table size incorrect
                exception table corrupt

Notes:


--*/
{
    // The machine type indicates this image should have pdata (an exception table).
    // Ensure it looks reasonable.

    // Todo: Add a range check for exception handler and data

    PIMAGE_RUNTIME_FUNCTION_ENTRY ExceptionTable;
    DWORD ExceptionTableSize, i;
    DWORD_PTR LastEnd;
    BOOL fRc;
    PIMAGE_NT_HEADERS NtHeader = (PIMAGE_NT_HEADERS)((PCHAR)DosHeader + (ULONG)DosHeader->e_lfanew);
    ULONG_PTR ImageBase = NtHeader->OptionalHeader.ImageBase;
    DWORD PDataStart = NtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress;
    DWORD PDataSize = NtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].Size;


    ExceptionTable = (PIMAGE_RUNTIME_FUNCTION_ENTRY)
        ImageDirectoryEntryToData(
            DosHeader,
            FALSE,
            IMAGE_DIRECTORY_ENTRY_EXCEPTION,
            &ExceptionTableSize );

    if (!ExceptionTable ||
        (ExceptionTable && (ExceptionTableSize == 0)))
    {
        // No Exception table.
        return(TRUE);
    }

    if (ExceptionTableSize % sizeof(IMAGE_RUNTIME_FUNCTION_ENTRY)) {
        // The size isn't an even multiple.
        LogPrintf("exception table size is not correct\n");
        return(FALSE);
    }

    LastEnd = 0;
    fRc = TRUE;
    for (i=0; i < (ExceptionTableSize / sizeof(IMAGE_RUNTIME_FUNCTION_ENTRY)); i++) {

        if (!ExceptionTable[i].BeginAddress) {
            if (fRc != FALSE) {
                LogPrintf("exception table is corrupt.\n");
            }
            LogPrintf("PDATA Entry[%d]: zero value for BeginAddress\n",
                    i);
            fRc = FALSE;
        }
        if (!ExceptionTable[i].EndAddress) {
            if (fRc != FALSE) {
                LogPrintf("exception table is corrupt.\n");
            }
            LogPrintf("PDATA Entry[%d]: zero value for EndAddress\n",
                    i);
            fRc = FALSE;
        }
#if defined(_IA64_)
        if (!ExceptionTable[i].UnwindInfoAddress) {
            if (fRc != FALSE) {
                LogPrintf("exception table is corrupt.\n");
            }
            LogPrintf("PDATA Entry[%d]: zero value for UnwindInfoAddress\n",
                    i);
            fRc = FALSE;
        }
#else
        if (!ExceptionTable[i].PrologEndAddress) {
            if (fRc != FALSE) {
                LogPrintf("exception table is corrupt.\n");
            }
            LogPrintf("PDATA Entry[%d]: zero value for PrologEndAddress\n",
                    i);
            fRc = FALSE;
        }

#endif // defined(_IA64_)

        if (ExceptionTable[i].BeginAddress < LastEnd) {
            if (fRc != FALSE) {
                LogPrintf("exception table is corrupt.\n");
            }
            LogPrintf("PDATA Entry[%d]: the begin address [%8.8x] is out of sequence.  Prior end was [%8.8x]\n",
                    i,
                    ExceptionTable[i].BeginAddress,
                    LastEnd);
            fRc = FALSE;
        }

        if (ExceptionTable[i].EndAddress < ExceptionTable[i].BeginAddress) {
            if (fRc != FALSE) {
                LogPrintf("exception table is corrupt.\n");
            }
            LogPrintf("PDATA Entry[%d]: the end address [%8.8x] is before the begin address[%8.8X]\n",
                    i,
                    ExceptionTable[i].EndAddress,
                    ExceptionTable[i].BeginAddress);
            fRc = FALSE;
        }

#if !defined(_IA64_)
        if (!((ExceptionTable[i].PrologEndAddress >= ExceptionTable[i].BeginAddress) &&
              (ExceptionTable[i].PrologEndAddress <= ExceptionTable[i].EndAddress)))
        {
            if (NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_ALPHA) {
                // Change this test.  On Alpha, the PrologEndAddress is allowed to be
                // outside the Function Start/End range.  If this is true, the PrologEnd
                // - ImageBase - pdata section VA s/b divisible by sizeof IMAGE_RUNTIME_FUNCTION_ENTRY
                // AND within the bounds of the PdataSize.  It's supposed to be an index into the
                // pdata data that descibes the real scoping function.

                LONG PrologAddress;
                PrologAddress = (LONG) (ExceptionTable[i].PrologEndAddress - ImageBase - PDataStart);
                if (PrologAddress % sizeof(IMAGE_RUNTIME_FUNCTION_ENTRY)) {
                    if (fRc != FALSE) {
                        LogPrintf("exception table is corrupt.\n");
                    }
                    LogPrintf("PDATA Entry[%d]: the secondary prolog end address[%8.8x] does not evenly index into the exception table.\n",
                            i,
                            ExceptionTable[i].PrologEndAddress,
                            ExceptionTable[i].BeginAddress,
                            ExceptionTable[i].EndAddress
                            );
                    fRc = FALSE;
                } else {
                    if ((PrologAddress < 0) || (PrologAddress > (LONG)(PDataStart - sizeof(IMAGE_RUNTIME_FUNCTION_ENTRY)))) {
                        if (fRc != FALSE) {
                            LogPrintf("exception table is corrupt.\n");
                        }
                        LogPrintf("PDATA Entry[%d]: the secondary prolog end address[%8.8x] does not index into the exception table.\n",
                                i,
                                ExceptionTable[i].PrologEndAddress,
                                ExceptionTable[i].BeginAddress,
                                ExceptionTable[i].EndAddress
                                );
                        fRc = FALSE;
                    }
                }
            } else {
                if (fRc != FALSE) {
                    LogPrintf("exception table is corrupt.\n");
                }
                LogPrintf("PDATA Entry[%d]: the prolog end address[%8.8x] is not within the bounds of the frame [%8.8X] - [%8.8X]\n",
                        i,
                        ExceptionTable[i].PrologEndAddress,
                        ExceptionTable[i].BeginAddress,
                        ExceptionTable[i].EndAddress
                        );
                fRc = FALSE;
            }
        }
#endif // !defined(_IA64_)

        LastEnd = ExceptionTable[i].EndAddress;
    }

    return(fRc);
}

BOOL
ImageNeedsOleSelfRegister(
    PIMAGE_DOS_HEADER DosHeader
    )
/*++

Routine Description:


Arguments:

    PIMAGE_DOS_HEADER   DosHeader

Return Value:

    TRUE if DllRegisterServer or DllUnRegisterServer is exported

--*/
{
    PIMAGE_EXPORT_DIRECTORY ExportDirectory;
    PIMAGE_NT_HEADERS NtHeader;
    PIMAGE_SECTION_HEADER SectionHeader;
    DWORD ExportDirectorySize, i;
    USHORT x;
    PCHAR  rvaDelta;
    PULONG NameTable;

    ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)
        ImageDirectoryEntryToData(
            DosHeader,
            FALSE,
            IMAGE_DIRECTORY_ENTRY_EXPORT,
            &ExportDirectorySize );

    if (!ExportDirectory ||
        !ExportDirectorySize ||
        !ExportDirectory->NumberOfNames)
    {
        // No exports (no directory, no size, or no names).
        return(FALSE);
    }

    // Walk the section headers and find the va/raw offsets.

    NtHeader = (PIMAGE_NT_HEADERS)((PCHAR)DosHeader + (ULONG)DosHeader->e_lfanew);
    SectionHeader = IMAGE_FIRST_SECTION(NtHeader);

    for (x = 0; x < NtHeader->FileHeader.NumberOfSections; x++) {
        if (((ULONG)((PCHAR)ExportDirectory - (PCHAR)DosHeader) >= SectionHeader->PointerToRawData) &&
            ((ULONG)((PCHAR)ExportDirectory - (PCHAR)DosHeader) <
                   (SectionHeader->PointerToRawData + SectionHeader->SizeOfRawData))) {
            break;
        } else {
            SectionHeader++;
        }
    }

    if (x == NtHeader->FileHeader.NumberOfSections) {
        // We didn't find the section that contained the export table.  Assume it's not there.
        return(FALSE);
    }

    rvaDelta = (PCHAR)DosHeader + SectionHeader->PointerToRawData - SectionHeader->VirtualAddress;

    NameTable = (PULONG)(rvaDelta + ExportDirectory->AddressOfNames);

    for (i = 0; i < ExportDirectory->NumberOfNames; i++) {
        if (!strcmp("DllRegisterServer", rvaDelta + NameTable[i]) ||
            !strcmp("DllUnRegisterServer", rvaDelta + NameTable[i]))
        {
            return(TRUE);
        }
    }

    return(FALSE);
}

//
// support routines for symbol checker - could all
// be done without this using lower-level internal api's
//

PSYMMODLIST
MakeModList(
    HANDLE hProcess
    )
/*++

Routine Description:

    build a list of loaded symbol modules and addresses

Arguments:

    HANDLE hProcess

Return Value:

    PSYMMODLIST

Notes:


--*/
{
    PSYMMODLIST ModList;

    ModList = (PSYMMODLIST)calloc(1, sizeof(SYMMODLIST));
    SymEnumerateModules64(hProcess, SymEnumerateModulesCallback, ModList);

    return(ModList);
}

BOOL
CALLBACK
SymEnumerateModulesCallback(
    LPSTR ModuleName,
    ULONG64 BaseOfDll,
    PVOID UserContext
    )
/*++

Routine Description:

    callback routine for SymEnumerateModules
    in this case, UserContext is a pointer to a head of a _SYMMODLIST struct
    that will have a new item appended
    We are avoiding global state for these lists so we can use several at once,
    they will be short, so we will find the end each time we want to add
    runs slower, simpler to maintain

Arguments:

    LPSTR   ModuleName
    ULONG64 BaseOfDll
    PVOID   UserContext

Return Value:

    TRUE

Notes:


--*/
{
    PSYMMODLIST pSymModList;

    //
    // find end of list, key on pSymModList->ModBase
    //

    pSymModList = (PSYMMODLIST)UserContext;
    while (pSymModList->ModBase)
    {
        pSymModList = pSymModList->Next;
    }

    //
    // append entry
    //

    pSymModList->ModName = malloc(strlen(ModuleName) + 1);
    strcpy(pSymModList->ModName, ModuleName);
    pSymModList->ModBase = (void *)BaseOfDll;
    pSymModList->Next = (PSYMMODLIST)calloc(1, sizeof(SYMMODLIST));

    return(TRUE);
}

void *
GetModAddrFromName(
    PSYMMODLIST ModList,
    char *ModName
    )
/*++

Routine Description:

    gets module address from a SYMMODLIST given module base name

Arguments:

    PSYMMODLIST ModList
    char *      ModName

Return Value:

    module address

--*/
{
    while (ModList->Next != 0)
    {
        if (strcmp(ModList->ModName, ModName) == 0)
        {
            break;
        }
        ModList = ModList->Next;
    }

    return(ModList->ModBase);
}

void
FreeModList(
    PSYMMODLIST ModList
    )
/*++

Routine Description:

    free a list of loaded symbol modules and addresses

Arguments:

    PSYMMODLIST ModList

Return Value:

    none

--*/
{
    PSYMMODLIST ModListNext;

    while (ModList)
    {
        if(ModList->ModName)
        {
            free(ModList->ModName);
        }
        ModListNext = ModList->Next;
        free(ModList);
        ModList = ModListNext;
    }
}

pLogListItem LogAppend(
    char *logitem,
    pLogListItem plog
    )
/*++

Routine Description:

    add a log line to the linked list of log lines

Arguments:

    char *  logitem     - a formatted line of text to be logged
    pLogListItem plog   - pointer to LogListItem

Return Value:

    a pointer to the LogListItem allocated
    the first call to this function should save this pointer and use
    it for the head of the list, and it should be used when calling
    LogOutAndClean() to print the list and free all the memory

    you can call this with plog == head of list, or == to last item
    if plog == 0, this means that the item being allocated is the head
    of the list.
    If plog == head of list, search for end of list
    if plog == last item allocated, then the search is much faster

--*/
{
    pLogListItem ptemp;

    ptemp = plog;
    if(plog)
    {
        while(ptemp->Next)
        {
            ptemp = ptemp->Next;
        }
    }

    if(!ptemp)
    {
        ptemp = (pLogListItem)calloc(sizeof(LogListItem), 1);
    } else {
        ptemp->Next = (pLogListItem)calloc(sizeof(LogListItem), 1);
        ptemp = ptemp->Next;
    }

    ptemp->LogLine = (char *)malloc(strlen(logitem) + 1);
    strcpy(ptemp->LogLine, logitem);
    return (ptemp);
}

void LogOutAndClean(
    BOOL print
    )
/*++

Routine Description:

    output the log output, and free all the items in the list

Arguments:

    none

Return Value:

    none

--*/
{
    pLogListItem ptemp;
    pLogListItem plog = pLogList;

    while(plog)
    {
        ptemp = plog;
        if(print)
        {
            fprintf(stderr, plog->LogLine);
        }
        plog = plog->Next;
        free(ptemp->LogLine);
        free(ptemp);
    }
    if(print)
    {
        fprintf(stderr, "\n");
    }

    pLogListTmp = pLogList = NULL;

}

void
LogPrintf(
    const char *format,
    ...
    )
/*++

Routine Description:

    logging wrapper for fprintf

Arguments:

    none

Return Value:

    none

--*/
{
    va_list arglist;
    char LogStr[1024];

    va_start(arglist, format);
    vsprintf(LogStr, format, arglist);

    if(pLogList == NULL)
    {
        //
        // initialize log
        //

        pLogListTmp = pLogList = LogAppend(LogStr, NULL);

    } else {

        //
        // append to log
        //

        pLogListTmp = LogAppend(LogStr, pLogListTmp);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\editsym.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    editsym.c

Abstract:

    This is the main source file for the EDITSYM utility program.  This
    program can be used to extract the debugging information contained in
    a separate .DBG file and put it back to the original image file.

Author:

    HonWah Chan 21-March-1994

Revision History:

--*/

#include <private.h>


BOOL fVerbose;

LPSTR FilePart;

UCHAR CurrentImageName[ MAX_PATH ];

UCHAR DbgFileName[ MAX_PATH ];


void
Usage( void )
{
    fputs( "Function: Extract debugging information contained in .dbg file\n"
           "\tand put it back in the original image file\n\n"
           "Usage: EDITSYM [-?] [-s symbol-filename] image-name\n"
           "\t\t[-?] display this message\n"
           "\t\t[-s symbol-filename] - name of the .DBG file.  Default is the same\n"
           "\t\t                        name and location as the image file.\n\n"
           "\tE.G.  EditSym -s Perfmon.dbg Perfmon.exe\n", stderr );
    exit( 1 );
}

BOOL EditSymbols(
    LPSTR pImageName,
    LPSTR pDbgFileName
    )
{
    PIMAGE_NT_HEADERS NtHeaders;
    HANDLE FileHandle, SymbolFileHandle;
    HANDLE hMappedFile;
    LPVOID ImageBase;
    PIMAGE_DEBUG_DIRECTORY DebugDirectories;
    PIMAGE_DEBUG_DIRECTORY DebugDirectoriesSave;
    DWORD DebugDirectorySize, NumberOfDebugDirectories;
    DWORD SavedErrorCode;
    PIMAGE_DEBUG_DIRECTORY DebugDirectory;
    DWORD i;
    DWORD NewFileSize, HeaderSum, CheckSum;
    DWORD DebugDataSize;
    LPBYTE DebugData;
    IMAGE_SEPARATE_DEBUG_HEADER DbgFileHeader;

    ImageBase = NULL;
    hMappedFile = 0;
    FileHandle = SymbolFileHandle = 0;
    DebugDirectoriesSave = NULL;

    //
    // open and map the file.
    //
    FileHandle = CreateFile( pImageName,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             0,
                             NULL
                           );

    if (FileHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
        }


    hMappedFile = CreateFileMapping( FileHandle,
                                     NULL,
                                     PAGE_READWRITE,
                                     0,
                                     0,
                                     NULL
                                   );
    if (!hMappedFile) {
        CloseHandle( FileHandle );
        return FALSE;
        }

    ImageBase = MapViewOfFile( hMappedFile,
                               FILE_MAP_WRITE,
                               0,
                               0,
                               0
                             );
    if (!ImageBase) {
        CloseHandle( hMappedFile );
        CloseHandle( FileHandle );
        return FALSE;
        }

    //
    // Everything is mapped. Now check the image and find nt image headers
    //

    NtHeaders = ImageNtHeader( ImageBase );
    if (NtHeaders == NULL) {
        SetLastError( ERROR_BAD_EXE_FORMAT );
        goto nosyms;
        }

    if ((NtHeaders->OptionalHeader.MajorLinkerVersion < 3) &&
        (NtHeaders->OptionalHeader.MinorLinkerVersion < 5)
       ) {
        SetLastError( ERROR_BAD_EXE_FORMAT );
        goto nosyms;
        }

    if (!(NtHeaders->FileHeader.Characteristics & IMAGE_FILE_DEBUG_STRIPPED)) {
        SetLastError( ERROR_ALREADY_ASSIGNED );
        goto nosyms;
        }

    DebugDirectories = (PIMAGE_DEBUG_DIRECTORY) ImageDirectoryEntryToData( ImageBase,
                                                  FALSE,
                                                  IMAGE_DIRECTORY_ENTRY_DEBUG,
                                                  &DebugDirectorySize
                                                );
    if (!DebugDirectoryIsUseful(DebugDirectories, DebugDirectorySize)) {
        SetLastError( ERROR_BAD_EXE_FORMAT );
        goto nosyms;
    }

    NumberOfDebugDirectories = DebugDirectorySize / sizeof( IMAGE_DEBUG_DIRECTORY );

    SymbolFileHandle = CreateFile( pDbgFileName,
                                   GENERIC_READ | GENERIC_WRITE,
                                   FILE_SHARE_READ,
                                   NULL,
                                   OPEN_EXISTING,
                                   0,
                                   NULL
                                 );
    if (SymbolFileHandle == INVALID_HANDLE_VALUE)
        goto nosyms;

    if (!ReadFile( SymbolFileHandle,
            &DbgFileHeader,
            sizeof(DbgFileHeader),
            &DebugDataSize,
            NULL) ||
        DebugDataSize != sizeof(DbgFileHeader)) {
        SetLastError( ERROR_BAD_EXE_FORMAT );
        goto nosyms;
        }

    if (DbgFileHeader.Signature != IMAGE_SEPARATE_DEBUG_SIGNATURE ||
        (DbgFileHeader.Flags & ~IMAGE_SEPARATE_DEBUG_FLAGS_MASK) != 0 ||
        DbgFileHeader.Machine != NtHeaders->FileHeader.Machine ||
        DbgFileHeader.Characteristics != NtHeaders->FileHeader.Characteristics ||
        DbgFileHeader.TimeDateStamp != NtHeaders->FileHeader.TimeDateStamp ||
        DbgFileHeader.CheckSum != NtHeaders->OptionalHeader.CheckSum ||
        DbgFileHeader.ImageBase != NtHeaders->OptionalHeader.ImageBase ||
        DbgFileHeader.SizeOfImage != NtHeaders->OptionalHeader.SizeOfImage) {
        SetLastError( ERROR_BAD_EXE_FORMAT );
        goto nosyms;
        }

    if (DbgFileHeader.Flags & IMAGE_SEPARATE_DEBUG_MISMATCH) {
        fprintf(stderr, "Warning: %s updated unsafely; symbols may be wrong\n",
                pDbgFileName);
    }


    // check if this is the right dbg file

    // save the DebugDirectory and get ready to write the
    // debug data to the image file.
    DebugDirectoriesSave = (PIMAGE_DEBUG_DIRECTORY) malloc( DebugDirectorySize );
    if (DebugDirectoriesSave == NULL)
        goto nosyms;

    RtlMoveMemory( DebugDirectoriesSave,
                   DebugDirectories,
                   DebugDirectorySize);

    DebugDirectory = DebugDirectoriesSave;
    NewFileSize = SetFilePointer( FileHandle, 0, NULL, FILE_END );
    NewFileSize = (NewFileSize + 3) & ~3;

    for (i=0; i<NumberOfDebugDirectories; i++) {
        // Is it one of the debug sections we need to special case?
        if (DebugDirectory->Type == IMAGE_DEBUG_TYPE_MISC) {
            // fix the mage name

            RtlCopyMemory(((PCHAR) ImageBase +
                                DebugDirectory->PointerToRawData +
                                FIELD_OFFSET( IMAGE_DEBUG_MISC, Data )),
                          FilePart,
                          strlen(FilePart) + 1);

        }
        else if (DebugDirectory->Type != IMAGE_DEBUG_TYPE_FPO) {
            DebugData = (LPBYTE) malloc( DebugDirectory->SizeOfData );
            if (SetFilePointer( SymbolFileHandle,
                    DebugDirectory->PointerToRawData,
                    NULL,
                    FILE_BEGIN ) != DebugDirectory->PointerToRawData) {
                SetLastError( ERROR_BAD_EXE_FORMAT );
                goto nosyms;
                }

            if (ReadFile( SymbolFileHandle,
                          DebugData,
                          DebugDirectory->SizeOfData,
                          &DebugDataSize,
                          NULL) &&
                DebugDataSize == DebugDirectory->SizeOfData) {
                if (WriteFile( FileHandle,
                               DebugData,
                               DebugDirectory->SizeOfData,
                               &DebugDataSize,
                               NULL) &&
                    DebugDataSize == DebugDirectory->SizeOfData) {
                    DebugDirectory->PointerToRawData = NewFileSize;
                    NewFileSize += DebugDataSize;
                    NewFileSize = (NewFileSize + 3) & ~3;
                }
                else {
                    SetLastError( ERROR_WRITE_FAULT );
                    free( DebugData );
                    goto nosyms;
                }
            }
            else {
                SetLastError( ERROR_BAD_EXE_FORMAT );
                free( DebugData );
                goto nosyms;
            }
            free( DebugData );
        }
        DebugDirectory += 1;
    }


    // somehow I needed to close the file and re-open it again.
    // otherwise it would AV inside CheckSumMappedFile.
    UnmapViewOfFile( ImageBase );
    CloseHandle( hMappedFile );
    ImageBase = NULL;
    hMappedFile = 0;

    SetFilePointer( FileHandle, NewFileSize, NULL, FILE_BEGIN );
    SetEndOfFile( FileHandle );
    CloseHandle( FileHandle );


    //
    // re-open and map the file.
    //
    FileHandle = CreateFile( pImageName,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             0,
                             NULL
                           );


    hMappedFile = CreateFileMapping( FileHandle,
                                     NULL,
                                     PAGE_READWRITE,
                                     0,
                                     0,
                                     NULL
                                   );
    if (!hMappedFile) {
        goto nosyms;
        }

    ImageBase = MapViewOfFile( hMappedFile,
                               FILE_MAP_WRITE,
                               0,
                               0,
                               0
                             );
    if (!ImageBase) {
        goto nosyms;
        }

    NtHeaders = ImageNtHeader( ImageBase );
    if (NtHeaders == NULL) {
        SetLastError( ERROR_BAD_EXE_FORMAT );
        goto nosyms;
        }

    DebugDirectories = (PIMAGE_DEBUG_DIRECTORY) ImageDirectoryEntryToData( ImageBase,
                                                  FALSE,
                                                  IMAGE_DIRECTORY_ENTRY_DEBUG,
                                                  &DebugDirectorySize
                                                );

    if (DebugDirectories == NULL || DebugDirectorySize == 0) {
        SetLastError( ERROR_BAD_EXE_FORMAT );
        goto nosyms;
        }


    RtlMoveMemory( DebugDirectories,
                   DebugDirectoriesSave,
                   DebugDirectorySize);

    free( DebugDirectoriesSave );

    NtHeaders->FileHeader.Characteristics &= ~IMAGE_FILE_DEBUG_STRIPPED;

    CheckSumMappedFile( ImageBase,
                        NewFileSize,
                        &HeaderSum,
                        &CheckSum
                      );

    NtHeaders->OptionalHeader.CheckSum = CheckSum;


    CloseHandle( SymbolFileHandle );

    UnmapViewOfFile( ImageBase );
    CloseHandle( hMappedFile );
    CloseHandle( FileHandle );

    return TRUE;

nosyms:
    SavedErrorCode = GetLastError();

    if (DebugDirectoriesSave)
        free( DebugDirectoriesSave );

    if (SymbolFileHandle && SymbolFileHandle != INVALID_HANDLE_VALUE) {
        CloseHandle( SymbolFileHandle );
    }

    if (ImageBase)
        UnmapViewOfFile( ImageBase );

    if (hMappedFile)
        CloseHandle( hMappedFile );

    if (FileHandle && FileHandle != INVALID_HANDLE_VALUE) {
        CloseHandle( FileHandle );
    }

    SetLastError( SavedErrorCode );
    return FALSE;
}

int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    char c, *s;
    LPSTR DbgFilePart;

    if (argc <= 1) {
        Usage();
        }

    DbgFileName[ 0 ] = '\0';
    while (--argc) {
        s = *++argv;
        if (*s == '/' || *s == '-') {
            while (c = *++s)
                switch (toupper( c )) {
                case '?':
                    Usage();
                    break;

                case 'V':
                    fVerbose = TRUE;
                    break;

                case 'S':
                    if (--argc) {
                        strcpy( (PCHAR) DbgFileName, *++argv );
                        }
                    else {
                        fprintf( stderr, "EDITSYM: Argument to /%c switch missing\n", c );
                        Usage();
                        }
                    break;

                default:
                    fprintf( stderr, "EDITSYM: Invalid switch - /%c\n", c );
                    Usage();
                    break;
                }
            }
        else {
            FilePart = (PCHAR) CurrentImageName;
            if (!GetFullPathNameA( s, sizeof( CurrentImageName ), (PCHAR) CurrentImageName, &FilePart )) {
                fprintf( stderr, "EDITSYM: invalid file name - %s (%u)\n", s, GetLastError() );
                }
            else {
                if (DbgFileName[0] == '\0') {
                    PCHAR  pDbgName;

                    RtlCopyMemory(DbgFileName,
                          CurrentImageName,
                          strlen((PCHAR) CurrentImageName) + 1);
                    pDbgName = (PCHAR) DbgFileName + strlen ((PCHAR) DbgFileName);
                    while (pDbgName > (PCHAR) DbgFileName) {
                        if (*pDbgName == '.') {
                            break;
                        }
                        pDbgName --;
                    }
                    if (*pDbgName != '.') {
                        fprintf( stderr, "EDITSYM: invalid exe file name - %s\n", CurrentImageName );
                    }
                    strcpy (pDbgName, ".DBG");
                }
                else if (!GetFullPathNameA( (PCHAR) DbgFileName, sizeof( DbgFileName ), (PCHAR) DbgFileName, &DbgFilePart )) {
                    fprintf( stderr, "EDITSYM: invalid Dbg file name - %s (%u)\n", s, GetLastError() );
                }

                if (EditSymbols( (PCHAR) CurrentImageName, (PCHAR) DbgFileName )) {
                    if (fVerbose) {
                        fprintf( stdout,
                                 "EDITSYM: %s symbols restored into %s\n",
                                 DbgFileName,
                                 FilePart
                               );
                        }
                    }
                else
                    fprintf( stderr, "EDITSYM: Unable to restore symbols from '%s' into '%s' (%u)\n",
                             CurrentImageName,
                             DbgFileName,
                             GetLastError()
                           );
                }
            }
        }

    exit( 0 );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\imagedir.c ===
/*++

Copyright (c) 1991-1995 Microsoft Corporation

Module Name:

    imagedir.c

Abstract:

    The module contains the code to translate an image directory type to
    the address of the data for that entry.

Environment:

    User Mode or Kernel Mode

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <private.h>

PVOID
ImageDirectoryEntryToData (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size
    );

PIMAGE_NT_HEADERS
ImageNtHeader (
    IN PVOID Base
    )

/*++

Routine Description:

    This function returns the address of the NT Header.

Arguments:

    Base - Supplies the base of the image.

Return Value:

    Returns the address of the NT Header.

--*/

{
    return RtlpImageNtHeader( Base );
}


PVOID
ImageDirectoryEntryToDataRom (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size,
    OUT PIMAGE_SECTION_HEADER *FoundSection OPTIONAL,
    IN PIMAGE_FILE_HEADER FileHeader,
    IN PIMAGE_ROM_OPTIONAL_HEADER OptionalHeader
    )
{
    ULONG i;
    PIMAGE_SECTION_HEADER NtSection;

    //
    // There's not much we can get from ROM images.  See if the info requested
    // is one of the known ones (debug/exception data)
    //

    NtSection = (PIMAGE_SECTION_HEADER)((ULONG_PTR)OptionalHeader +
                      FileHeader->SizeOfOptionalHeader);

    for (i = 0; i < FileHeader->NumberOfSections; i++, NtSection++) {

        if ( DirectoryEntry == IMAGE_DIRECTORY_ENTRY_DEBUG ) {
            if (!_stricmp((char *)NtSection->Name, ".rdata")) {
                PIMAGE_DEBUG_DIRECTORY DebugDirectory;
                *Size = 0;
                DebugDirectory = (PVOID)((ULONG_PTR)NtSection->PointerToRawData + (ULONG_PTR)Base);
                while (DebugDirectory->Type != 0) {
                    *Size += sizeof(IMAGE_DEBUG_DIRECTORY);
                    DebugDirectory++;
                }
                if (FoundSection) {
                    *FoundSection = NtSection;
                }
                return (PVOID)((ULONG_PTR)NtSection->PointerToRawData + (ULONG_PTR)Base);
            }
        } else
        if ( DirectoryEntry == IMAGE_DIRECTORY_ENTRY_EXCEPTION ) {
            if (!_stricmp((char *)NtSection->Name, ".pdata")) {
                if (FoundSection) {
                    *FoundSection = NtSection;
                }
                return (PVOID)((ULONG_PTR)NtSection->PointerToRawData + (ULONG_PTR)Base);
            }
        }
    }
    // Not one of the known sections.  Return error.
    *Size = 0;
    return( NULL );
}

PVOID
ImageDirectoryEntryToData64 (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size,
    OUT PIMAGE_SECTION_HEADER *FoundSection OPTIONAL,
    IN PIMAGE_FILE_HEADER FileHeader,
    IN PIMAGE_OPTIONAL_HEADER64 OptionalHeader
    )
{
    ULONG i;
    PIMAGE_SECTION_HEADER NtSection;
    ULONG DirectoryAddress;

    if (DirectoryEntry >= OptionalHeader->NumberOfRvaAndSizes) {
        *Size = 0;
        return( NULL );
    }

    if (!(DirectoryAddress = OptionalHeader->DataDirectory[ DirectoryEntry ].VirtualAddress)) {
        *Size = 0;
        return( NULL );
    }
    *Size = OptionalHeader->DataDirectory[ DirectoryEntry ].Size;
    if (MappedAsImage || DirectoryAddress < OptionalHeader->SizeOfHeaders) {
        if (FoundSection) {
            *FoundSection = NULL;
        }
        return( (PVOID)((ULONG_PTR)Base + DirectoryAddress) );
    }

    NtSection = (PIMAGE_SECTION_HEADER)((ULONG_PTR)OptionalHeader +
                        FileHeader->SizeOfOptionalHeader);

    for (i=0; i<FileHeader->NumberOfSections; i++) {
        if (DirectoryAddress >= NtSection->VirtualAddress &&
           DirectoryAddress < NtSection->VirtualAddress + NtSection->SizeOfRawData) {
            if (FoundSection) {
                *FoundSection = NtSection;
            }
            return( (PVOID)((ULONG_PTR)Base + (DirectoryAddress - NtSection->VirtualAddress) + NtSection->PointerToRawData) );
        }
        ++NtSection;
    }
    return( NULL );
}

PVOID
ImageDirectoryEntryToData32 (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size,
    OUT PIMAGE_SECTION_HEADER *FoundSection OPTIONAL,
    IN PIMAGE_FILE_HEADER FileHeader,
    IN PIMAGE_OPTIONAL_HEADER32 OptionalHeader
    )
{
    ULONG i;
    PIMAGE_SECTION_HEADER NtSection;
    ULONG DirectoryAddress;

    if (DirectoryEntry >= OptionalHeader->NumberOfRvaAndSizes) {
        *Size = 0;
        return( NULL );
    }

    if (!(DirectoryAddress = OptionalHeader->DataDirectory[ DirectoryEntry ].VirtualAddress)) {
        *Size = 0;
        return( NULL );
    }
    *Size = OptionalHeader->DataDirectory[ DirectoryEntry ].Size;
    if (MappedAsImage || DirectoryAddress < OptionalHeader->SizeOfHeaders) {
        if (FoundSection) {
            *FoundSection = NULL;
        }
        return( (PVOID)((ULONG_PTR)Base + DirectoryAddress) );
    }

    NtSection = (PIMAGE_SECTION_HEADER)((ULONG_PTR)OptionalHeader +
                        FileHeader->SizeOfOptionalHeader);

    for (i=0; i<FileHeader->NumberOfSections; i++) {
        if (DirectoryAddress >= NtSection->VirtualAddress &&
           DirectoryAddress < NtSection->VirtualAddress + NtSection->SizeOfRawData) {
            if (FoundSection) {
                *FoundSection = NtSection;
            }
            return( (PVOID)((ULONG_PTR)Base + (DirectoryAddress - NtSection->VirtualAddress) + NtSection->PointerToRawData) );
        }
        ++NtSection;
    }
    return( NULL );
}

PVOID
ImageDirectoryEntryToDataEx (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size,
    OUT PIMAGE_SECTION_HEADER *FoundSection OPTIONAL
    )

/*++

Routine Description:

    This function locates a Directory Entry within the image header
    and returns either the virtual address or seek address of the
    data the Directory describes.  It may optionally return the
    section header, if any, for the found data.

Arguments:

    Base - Supplies the base of the image or data file.

    MappedAsImage - FALSE if the file is mapped as a data file.
                  - TRUE if the file is mapped as an image.

    DirectoryEntry - Supplies the directory entry to locate.

    Size - Return the size of the directory.

    FoundSection - Returns the section header, if any, for the data

Return Value:

    NULL - The file does not contain data for the specified directory entry.

    NON-NULL - Returns the address of the raw data the directory describes.

--*/

{
    PIMAGE_NT_HEADERS NtHeader;
    PIMAGE_FILE_HEADER FileHeader;
    PIMAGE_OPTIONAL_HEADER OptionalHeader;

    if ((ULONG_PTR)Base & 0x00000001) {
        Base = (PVOID)((ULONG_PTR)Base & ~0x1);
        MappedAsImage = FALSE;
        }

    NtHeader = ImageNtHeader(Base);

    if (NtHeader) {
        FileHeader = &NtHeader->FileHeader;
        OptionalHeader = &NtHeader->OptionalHeader;
    } else {
        // Handle case where Image passed in doesn't have a dos stub (ROM images for instance);
        FileHeader = (PIMAGE_FILE_HEADER)Base;
        OptionalHeader = (PIMAGE_OPTIONAL_HEADER) ((ULONG_PTR)Base + IMAGE_SIZEOF_FILE_HEADER);
    }

    if (OptionalHeader->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
        return (ImageDirectoryEntryToData32 ( Base,
                                              MappedAsImage,
                                              DirectoryEntry,
                                              Size,
                                              FoundSection,
                                              FileHeader,
                                              (PIMAGE_OPTIONAL_HEADER32)OptionalHeader));
    } else if (OptionalHeader->Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
        return (ImageDirectoryEntryToData64 ( Base,
                                               MappedAsImage,
                                               DirectoryEntry,
                                               Size,
                                               FoundSection,
                                               FileHeader,
                                               (PIMAGE_OPTIONAL_HEADER64)OptionalHeader));
    } else if (OptionalHeader->Magic == IMAGE_ROM_OPTIONAL_HDR_MAGIC) {
        return (ImageDirectoryEntryToDataRom ( Base,
                                               MappedAsImage,
                                               DirectoryEntry,
                                               Size,
                                               FoundSection,
                                               FileHeader,
                                               (PIMAGE_ROM_OPTIONAL_HEADER)OptionalHeader));
    } else
        return NULL;
}


PVOID
ImageDirectoryEntryToData (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size
    )

/*++

Routine Description:

    This function locates a Directory Entry within the image header
    and returns either the virtual address or seek address of the
    data the Directory describes.

    This just calls ImageDirectoryToDataEx without a FoundSection arg.

Arguments:

    Base - Supplies the base of the image or data file.

    MappedAsImage - FALSE if the file is mapped as a data file.
                  - TRUE if the file is mapped as an image.

    DirectoryEntry - Supplies the directory entry to locate.

    Size - Return the size of the directory.

Return Value:

    NULL - The file does not contain data for the specified directory entry.

    NON-NULL - Returns the address of the raw data the directory describes.

--*/

{
    return ImageDirectoryEntryToDataEx(Base, MappedAsImage, DirectoryEntry, Size, NULL);
}


PIMAGE_SECTION_HEADER
ImageRvaToSection(
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Rva
    )

/*++

Routine Description:

    This function locates an RVA within the image header of a file
    that is mapped as a file and returns a pointer to the section
    table entry for that virtual address

Arguments:

    NtHeaders - Supplies the pointer to the image or data file.

    Base - Supplies the base of the image or data file.

    Rva - Supplies the relative virtual address (RVA) to locate.

Return Value:

    NULL - The file does not contain data for the specified directory entry.

    NON-NULL - Returns the pointer of the section entry containing the data.

--*/

{
    ULONG i;
    PIMAGE_SECTION_HEADER NtSection;

    NtSection = IMAGE_FIRST_SECTION( NtHeaders );
    for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++) {
        if (Rva >= NtSection->VirtualAddress &&
            Rva < NtSection->VirtualAddress + NtSection->SizeOfRawData
           ) {
            return NtSection;
            }
        ++NtSection;
        }

    return NULL;
}


PVOID
ImageRvaToVa(
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Rva,
    IN OUT PIMAGE_SECTION_HEADER *LastRvaSection OPTIONAL
    )

/*++

Routine Description:

    This function locates an RVA within the image header of a file that
    is mapped as a file and returns the virtual addrees of the
    corresponding byte in the file.


Arguments:

    NtHeaders - Supplies the pointer to the image or data file.

    Base - Supplies the base of the image or data file.

    Rva - Supplies the relative virtual address (RVA) to locate.

    LastRvaSection - Optional parameter that if specified, points
        to a variable that contains the last section value used for
        the specified image to translate and RVA to a VA.

Return Value:

    NULL - The file does not contain the specified RVA

    NON-NULL - Returns the virtual addrees in the mapped file.

--*/

{
    PIMAGE_SECTION_HEADER NtSection;

    if (LastRvaSection == NULL ||
        (NtSection = *LastRvaSection) == NULL ||
        NtSection == NULL ||
        Rva < NtSection->VirtualAddress ||
        Rva >= NtSection->VirtualAddress + NtSection->SizeOfRawData
       ) {
        NtSection = ImageRvaToSection( NtHeaders,
                                       Base,
                                       Rva
                                     );
        }

    if (NtSection != NULL) {
        if (LastRvaSection != NULL) {
            *LastRvaSection = NtSection;
            }

        return (PVOID)((ULONG_PTR)Base +
                       (Rva - NtSection->VirtualAddress) +
                       NtSection->PointerToRawData
                      );
        }
    else {
        return NULL;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\imhlptst.c ===
#include <windows.h>
#include <imagehlp.h>
#include <stdio.h>
#include <stdlib.h>

void __cdecl main(void);
void foo (void);
void foo1(void);
void foo2(void);
void foo3(void);
void WalkTheStack(void);

void TestFindExecutableImage( void );

void __cdecl
main(void)
{
    puts("Entering main");
    foo();

    TestFindExecutableImage();

    puts("Ending main");
}

void
TestFindExecutableImage(
    void
    )
{
    HANDLE Handle;
    CHAR szCorrectName[MAX_PATH];
    CHAR szActualName [MAX_PATH];
    CHAR szTestPath[MAX_PATH];
    CHAR szDrive[_MAX_DRIVE];
    CHAR szDir[_MAX_DIR];
    CHAR *FilePart;
    DWORD ErrorCount = 0;

    _splitpath(_pgmptr, szDrive, szDir, NULL, NULL);

    strcpy(szTestPath, szDrive);
    strcat(szTestPath, szDir);

    GetFullPathName(_pgmptr, MAX_PATH, szCorrectName, &FilePart);

    __try {
        Handle = FindExecutableImage(FilePart, szTestPath, szActualName);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Handle = NULL;
        printf("ERROR: FindExecutableImage GPF (test %d)\n", 1);
        ErrorCount++;
    }

    if (Handle == NULL) {
        printf("ERROR: FindExecutableImage (test %d) failed\n", 1);
        ErrorCount++;
    } else {
        CloseHandle(Handle);
        if (strcmp(szCorrectName, szActualName)) {
            printf("ERROR: FindExecutableImage() (test %d) found wrong image.\nExpected: %s\nFound: %s\n", 1, szCorrectName, szActualName);
            ErrorCount++;
        }
    }

    // Test long paths to ExpandPath()
    strcat(szTestPath, ";%path%;%path%;%path%;%path%;%path%;%path%;%path%;%path%");

    __try {
        Handle = FindExecutableImage(FilePart, szTestPath, szActualName);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Handle = NULL;
        printf("ERROR: FindExecutableImage GPF (test %d)\n", 2);
        ErrorCount++;
    }

    if (Handle == NULL) {
        printf("ERROR: FindExecutableImage (test %d) failed\n", 2);
        ErrorCount++;
    } else {
        CloseHandle(Handle);
        if (strcmp(szCorrectName, szActualName)) {
            printf("ERROR: FindExecutableImage() (test %d) found wrong image.\nExpected: %s\nFound: %s\n", 2, szCorrectName, szActualName);
            ErrorCount++;
        }
    }

    // Test invalid paths (should return failure)
    szTestPath[0] = '\0';

    __try {
        Handle = FindExecutableImage(FilePart, szTestPath, szActualName);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Handle = NULL;
        printf("ERROR: FindExecutableImage GPF (test %d)\n", 3);
        ErrorCount++;
    }

    if (Handle != NULL) {
        CloseHandle(Handle);
        printf("ERROR: FindExecutableImage (test %d) failed - Expected: <nothing>\nFound: %s\n", 3, szActualName);
        ErrorCount++;
    } else {
        if (strlen(szActualName)) {
            printf("ERROR: FindExecutableImage() (test %d) failed to clear ImageName on failure\n", 3);
            ErrorCount++;
        }
    }

    // Test NULL name (should return failure)

    __try {
        Handle = FindExecutableImage(NULL, szTestPath, szActualName);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Handle = NULL;
        printf("ERROR: FindExecutableImage GPF (test %d)\n", 4);
        ErrorCount++;
    }

    if (Handle != NULL) {
        CloseHandle(Handle);
        printf("ERROR: FindExecutableImage (test %d) failed - Expected: <nothing>\nFound: %s\n", 4, szActualName);
        ErrorCount++;
    } else {
        if (strlen(szActualName)) {
            printf("ERROR: FindExecutableImage() (test %d) failed to clear ImageName on failure\n", 4);
            ErrorCount++;
        }
    }

    // Valid name and path, invalid end result.

    strcpy(szTestPath, szDrive);
    strcat(szTestPath, szDir);

    __try {
        Handle = FindExecutableImage(FilePart, szTestPath, NULL);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Handle = NULL;
        printf("ERROR: FindExecutableImage GPF (test %d)\n", 5);
        ErrorCount++;
    }

    if (Handle != NULL) {
        CloseHandle(Handle);
        printf("ERROR: FindExecutableImage (test %d) failed - Supposed to fail if filepath is invalid\n", 5);
        ErrorCount++;
    }

    printf("FindExecutableImage - %s\n", ErrorCount ? "Failed" : "Passed");

    return;
}


void foo(void) {
    puts("Entering foo");
    foo1();
    puts("Ending foo");
}

void foo1(void) {
    puts("Entering foo1");
    foo2();
    puts("Ending foo1");
}

void foo2(void) {
    puts("Entering foo2");
    foo3();
    puts("Ending foo2");
}

void foo3(void) {
    puts("Entering foo3");
    WalkTheStack();
    puts("Ending foo2");
}

void
WalkTheStack(){

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\imagehlp.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    imagehlp.c

Abstract:

    This function implements a generic simple symbol handler.

Author:

    Wesley Witt (wesw) 1-Sep-1994

Environment:

    User Mode

--*/
#ifdef __cplusplus
extern "C" {
#endif
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#ifdef __cplusplus
}
#endif

#include "private.h"

HANDLE hHeap;
OSVERSIONINFO OSVerInfo;

#ifdef IMAGEHLP_HEAP_DEBUG
LIST_ENTRY HeapHeader;
ULONG TotalMemory;
VOID PrintAllocations(VOID);
ULONG TotalAllocs;
#endif

HINSTANCE hImagehlp;


DWORD
DllMain(
    HINSTANCE hInstance,
    DWORD     Reason,
    LPVOID    Context
    )

/*++

Routine Description:

    DLL initialization function.

Arguments:

    hInstance   - Instance handle
    Reason      - Reason for the entrypoint being called
    Context     - Context record

Return Value:

    TRUE        - Initialization succeeded
    FALSE       - Initialization failed

--*/

{
    if (Reason == DLL_PROCESS_ATTACH) {
        hImagehlp = hInstance;
        OSVerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        GetVersionEx(&OSVerInfo);
        DisableThreadLibraryCalls( hInstance );
#ifdef IMAGEHLP_HEAP_DEBUG
        InitializeListHead( &HeapHeader );
#endif
        hHeap = HeapCreate( 0,
#ifdef IMAGEHLP_BUILD
                           0,
#else
                           1024*1024,
#endif
                           0 );
        if (!hHeap) {
            return FALSE;
        } else {
            return TRUE;
        }
    }

    if (Reason == DLL_PROCESS_DETACH) {
#ifdef IMAGEHLP_HEAP_DEBUG
        PrintAllocations();
#endif
        // If this is a process shutdown, don't bother to
        // kill the heap.  The OS will do it for us.  This
        // allows us to be called from other DLLs' DLLMain
        // DLL_PROCESS_DETACH handler.
        if ( !Context && hHeap ) {
            HeapDestroy( hHeap );
        }
    }

    return TRUE;
}

#ifdef IMAGEHLP_HEAP_DEBUG
VOID
pCheckHeap(
    PVOID MemPtr,
    ULONG Line,
    LPSTR File
    )
{
    CHAR buf[256];
    CHAR ext[4];

    if (!HeapValidate( hHeap, 0, MemPtr )) {
        wsprintf( buf, "IMAGEHLP: heap corruption 0x%08x " );
        _splitpath( File, NULL, NULL, &buf[strlen(buf)], ext );
        strcat( buf, ext );
        wsprintf( &buf[strlen(buf)], " @ %d\n", Line );
        OutputDebugString( buf );
        PrintAllocations();
        DebugBreak();
    }
}
#endif

PVOID
pMemReAlloc(
    PVOID OldAlloc,
    ULONG_PTR AllocSize
    )
{
#ifdef IMAGEHLP_HEAP_DEBUG
#error DEBUG MemReAlloc NYI
#else
    return(HeapReAlloc(hHeap, HEAP_ZERO_MEMORY, OldAlloc, AllocSize));
#endif
}

PVOID
pMemAlloc(
    ULONG_PTR AllocSize
#ifdef IMAGEHLP_HEAP_DEBUG
    , ULONG Line,
    LPSTR File
#endif
    )
{
#ifdef IMAGEHLP_HEAP_DEBUG
    PHEAP_BLOCK hb;
    CHAR ext[4];
    hb = (PHEAP_BLOCK) HeapAlloc( hHeap, HEAP_ZERO_MEMORY, AllocSize + sizeof(HEAP_BLOCK) );
    if (hb) {
        TotalMemory += AllocSize;
        TotalAllocs += 1;
        InsertTailList( &HeapHeader, &hb->ListEntry );
        hb->Signature = HEAP_SIG;
        hb->Size = AllocSize;
        hb->Line = Line;
        _splitpath( File, NULL, NULL, hb->File, ext );
        strcat( hb->File, ext );
        return (PVOID) ((PUCHAR)hb + sizeof(HEAP_BLOCK));
    }
    return NULL;
#else
    return HeapAlloc( hHeap, HEAP_ZERO_MEMORY, AllocSize );
#endif
}

VOID
pMemFree(
    PVOID MemPtr
#ifdef IMAGEHLP_HEAP_DEBUG
    , ULONG Line,
    LPSTR File
#endif
    )
{
#ifdef IMAGEHLP_HEAP_DEBUG
    PHEAP_BLOCK hb;
    if (!MemPtr) {
        return;
    }
    hb = (PHEAP_BLOCK) ((PUCHAR)MemPtr - sizeof(HEAP_BLOCK));
    if (hb->Signature != HEAP_SIG) {
        OutputDebugString( "IMAGEHLP: Corrupt heap block\n" );
        DebugBreak();
    }
    RemoveEntryList( &hb->ListEntry );
    TotalMemory -= hb->Size;
    TotalAllocs -= 1;
    HeapFree( hHeap, 0, (PVOID) hb );
#else
    if (!MemPtr) {
        return;
    }
    HeapFree( hHeap, 0, MemPtr );
#endif
}

ULONG_PTR
pMemSize(
    PVOID MemPtr
    )
{
    return HeapSize(hHeap, 0, MemPtr);
}


#ifdef IMAGEHLP_HEAP_DEBUG
VOID
PrintAllocations(
    VOID
    )
{
    PLIST_ENTRY                 Next;
    PHEAP_BLOCK                 hb;
    CHAR                        buf[256];
    LARGE_INTEGER               PerfFreq;


    Next = HeapHeader.Flink;
    if (!Next) {
        return;
    }

    OutputDebugString( "-----------------------------------------------------------------------------\n" );
    wsprintf( buf, "Memory Allocations for Heap 0x%08x, Allocs=%d, TotalMem=%d\n", hHeap, TotalAllocs, TotalMemory );
    OutputDebugString( buf );
    OutputDebugString( "-----------------------------------------------------------------------------\n" );
    OutputDebugString( "*\n" );

    while ((ULONG)Next != (ULONG)&HeapHeader) {
        hb = CONTAINING_RECORD( Next, HEAP_BLOCK, ListEntry );
        Next = hb->ListEntry.Flink;
        wsprintf( buf, "%8d %16s @ %5d\n", hb->Size, hb->File, hb->Line );
        OutputDebugString( buf );
    }

    OutputDebugString( "*\n" );

    return;
}
#endif

DWORD
ImagepSetLastErrorFromStatus(
    IN DWORD Status
    )
{
    DWORD dwErrorCode;

//    dwErrorCode = RtlNtStatusToDosError( Status );
    dwErrorCode =  Status;
    SetLastError( dwErrorCode );
    return( dwErrorCode );
}


//
// BUGBUG - kcarlos - These functions are in the wrong place, the new owner can place these wherever.
//
PWSTR
AnsiToUnicode(
    PSTR pszAnsi
    )
{
    UINT uSizeUnicode;
    PWSTR pwszUnicode;

    if (!pszAnsi) {
        return NULL;
    }

    uSizeUnicode = (strlen(pszAnsi) + 1) * sizeof(wchar_t);
    pwszUnicode = calloc(uSizeUnicode, 1);

    if (*pszAnsi && pwszUnicode) {

        if (!MultiByteToWideChar(CP_ACP, MB_COMPOSITE,
            pszAnsi, strlen(pszAnsi),
            pwszUnicode, uSizeUnicode)) {

            // Error. Free the string, return NULL.
            free(pwszUnicode);
            pwszUnicode = NULL;
        }
    }

    return pwszUnicode;
}

PSTR
UnicodeToAnsi(
    PWSTR pwszUnicode
    )
{
    UINT uSizeAnsi;
    PSTR pszAnsi;

    if (!pwszUnicode) {
        return NULL;
    }

    uSizeAnsi = wcslen(pwszUnicode) + 1;
    pszAnsi = calloc(uSizeAnsi, 1);

    if (*pwszUnicode && pszAnsi) {

        if (!WideCharToMultiByte(CP_ACP, WC_SEPCHARS | WC_COMPOSITECHECK,
            pwszUnicode, wcslen(pwszUnicode),
            pszAnsi, uSizeAnsi, NULL, NULL)) {

            // Error. Free the string, return NULL.
            free(pszAnsi);
            pszAnsi = NULL;
        }
    }

    return pszAnsi;
}


BOOL
CopyAnsiToUnicode(
    PWSTR pszDest,
    PSTR pszSrc,
    DWORD dwCharCountSizeOfDest
    )
{
    PWSTR pszTmp = AnsiToUnicode(pszSrc);

    if (!pszTmp) {
        return FALSE;
    } else {
        wcsncpy(pszDest, pszTmp, dwCharCountSizeOfDest);
        return TRUE;
    }
}

BOOL
CopyUnicodeToAnsi(
    PSTR pszDest,
    PWSTR pszSrc,
    DWORD dwCharCountSizeOfDest
    )
{
    PSTR pszTmp = UnicodeToAnsi(pszSrc);

    if (!pszTmp) {
        return FALSE;
    } else {
        strncpy(pszDest, pszTmp, dwCharCountSizeOfDest);
        return TRUE;
    }
}

/////////////////////////////////////////////////////////////////////////////
/*
******************************************************************************
On a Hydra System, we don't want imaghlp.dll to load user32.dll since it
prevents CSRSS from exiting when running a under a debugger.
The following two functions have been copied from user32.dll so that we don't
link to user32.dll.
******************************************************************************
*/
////////////////////////////////////////////////////////////////////////////


LPSTR CharNext(
    LPCSTR lpCurrentChar)
{
    if (IsDBCSLeadByte(*lpCurrentChar)) {
        lpCurrentChar++;
    }
    /*
     * if we have only DBCS LeadingByte, we will point string-terminaler.
     */

    if (*lpCurrentChar) {
        lpCurrentChar++;
    }
    return (LPSTR)lpCurrentChar;
}

LPSTR CharPrev(
    LPCSTR lpStart,
    LPCSTR lpCurrentChar)
{
    if (lpCurrentChar > lpStart) {
        LPCSTR lpChar;
        BOOL bDBC = FALSE;

        for (lpChar = --lpCurrentChar - 1 ; lpChar >= lpStart ; lpChar--) {
            if (!IsDBCSLeadByte(*lpChar))
                break;
            bDBC = !bDBC;
        }

        if (bDBC)
            lpCurrentChar--;
    }
    return (LPSTR)lpCurrentChar;
}

HMODULE hMsvcrt;
PUNDNAME pfUnDname;
BOOL fLoadMsvcrtDLL;

void * __cdecl AllocIt(unsigned int cb)
{
    return (MemAlloc(cb));
}

void __cdecl FreeIt(void * p)
{
    MemFree(p);
}

DWORD
IMAGEAPI
WINAPI
UnDecorateSymbolName(
    LPCSTR name,
    LPSTR outputString,
    DWORD maxStringLength,
    DWORD flags
    )
{
    DWORD rc;

    // this prevents an AV in __unDName
    
    if (!name) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }
        
    //
    // can't undecorate into a zero length buffer
    //
    if (maxStringLength < 2) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    if (!fLoadMsvcrtDLL) {
        // The first time we run, see if we can find the system undname.  Use
        // GetModuleHandle to avoid any additionally overhead.

        hMsvcrt = GetModuleHandle("msvcrt.dll");

        if (hMsvcrt) {
            pfUnDname = (PUNDNAME) GetProcAddress(hMsvcrt, "__unDName");
        }
        fLoadMsvcrtDLL = TRUE;
    }

    rc = 0;     // Assume failure

    __try {
        if (pfUnDname) {
            if (flags & UNDNAME_NO_ARGUMENTS) {
                flags |= UNDNAME_NAME_ONLY;
                flags &= ~UNDNAME_NO_ARGUMENTS;
            }

            if (flags & UNDNAME_NO_SPECIAL_SYMS) {
                flags &= ~UNDNAME_NO_SPECIAL_SYMS;
            }
            if (pfUnDname(outputString, name, maxStringLength-1, AllocIt, FreeIt, (USHORT)flags)) {
                rc = strlen(outputString);
            }
        } else {
            rc = strlen(strncpy(outputString, "Unable to load msvcrt!__unDName", maxStringLength));
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) { }

    if (!rc) {
        SetLastError(ERROR_INVALID_PARAMETER);
    }
    return rc;
}

DWORD
IMAGEAPI
GetTimestampForLoadedLibrary(
    HMODULE Module
    )
{
    PIMAGE_DOS_HEADER DosHdr;
    DWORD dwTimeStamp;

    __try {
        DosHdr = (PIMAGE_DOS_HEADER) Module;
        if (DosHdr->e_magic == IMAGE_DOS_SIGNATURE) {
            dwTimeStamp = ((PIMAGE_NT_HEADERS32) ((LPBYTE)Module + DosHdr->e_lfanew))->FileHeader.TimeDateStamp;
        } else if (DosHdr->e_magic == IMAGE_NT_SIGNATURE) {
            dwTimeStamp = ((PIMAGE_NT_HEADERS32) DosHdr)->FileHeader.TimeDateStamp;
        } else {
            dwTimeStamp = 0;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        dwTimeStamp = 0;
    }

    return dwTimeStamp;
}


VOID
EnsureTrailingBackslash(
    LPSTR sz
    )
{
    int i;

    assert(sz);

    i = lstrlen(sz);
    if (!i)
        return;

    if (sz[i - 1] == '\\') 
        return;

    sz[i] = '\\';
    sz[i + 1] = '\0';
}


#if DBG

VOID
dbPrint(
    LPCSTR fmt,
    ...
    )

/*++

    This function replaces ntdll!DbgPrint().  We need this to keep from linking to
    ntdll so that this library will run on Windows.

--*/

{
    CHAR  text[_MAX_PATH];

    va_list vaList;

    assert(fmt);

    va_start(vaList, fmt);
    vsprintf(text, fmt, vaList);
    va_end(vaList);

    OutputDebugString(text);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\makefile.inc ===
OBJECTS = $(OBJECTS) $(BASEDIR)\private\ntos\rtl\user\obj\$(TARGET_DIRECTORY)\imagedir.obj

debug.c undname.c: $(BASEDIR)\public\sdk\inc\ntverp.h

obj\$(TARGET_DIRECTORY)\bind.res: bind.rc

obj\$(TARGET_DIRECTORY)\binplace.res: binplace.rc

obj\$(TARGET_DIRECTORY)\checkfix.res: checkfix.rc

obj\$(TARGET_DIRECTORY)\dbgdump.res: dbgdump.rc

obj\$(TARGET_DIRECTORY)\editsym.res: binplace.rc

obj\$(TARGET_DIRECTORY)\imagecfg.res: imagecfg.rc

obj\$(TARGET_DIRECTORY)\imagechk.res: imagechk.rc

obj\$(TARGET_DIRECTORY)\imagehlp.res: imagehlp.rc

obj\$(TARGET_DIRECTORY)\impchk.res: impchk.rc

obj\$(TARGET_DIRECTORY)\rebase.res: rebase.rc

obj\$(TARGET_DIRECTORY)\smashlck.res: smashlck.rc

obj\$(TARGET_DIRECTORY)\splitsym.res: splitsym.rc

obj\$(TARGET_DIRECTORY)\stripcv.res: stripcv.rc

obj\$(TARGET_DIRECTORY)\undname.res: undname.rc

obj\$(TARGET_DIRECTORY)\verfix.res: verfix.rc

obj\$(TARGET_DIRECTORY)\editsym.res: editsym.rc

obj\$(TARGET_DIRECTORY)\upddbg.res: upddbg.rc

obj\$(TARGET_DIRECTORY)\certify.res: certify.rc

obj\$(TARGET_DIRECTORY)\imhlptst.res: imhlptst.rc

$(O)\pimagehlp.def : imagehlp.src
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tcimagehlp.src > $@
$(CPPXX: =
)
-DPRIVATE=
<<NOKEEP

$(O)\pimagehlp.lib : $(O)\pimagehlp.def $(IMPLIB_DEPEND)
    -$(LIB_NAME) -out:$@ @<<
$(LIBRARIAN_FLAGS: =
)
-def:$(O)\pimagehlp.def
$(LIBRARY_OBJS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\linesym.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    linesym.c

Abstract:

    Source file and line support.

Author:

    Drew Bliss (drewb) 07-07-1997

Environment:

    User Mode

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntldr.h>

#include "private.h"
#include "symbols.h"

int
__cdecl
CompareLineAddresses(
    const void *v1,
    const void *v2
    )
{
    PSOURCE_LINE Line1 = (PSOURCE_LINE)v1;
    PSOURCE_LINE Line2 = (PSOURCE_LINE)v2;

    if (Line1->Addr < Line2->Addr) {
        return -1;
    } else if (Line1->Addr > Line2->Addr) {
        return 1;
    } else {
        return 0;
    }
}

VOID
AddSourceEntry(
    PMODULE_ENTRY mi,
    PSOURCE_ENTRY Src
    )
{
    PSOURCE_ENTRY SrcPrev, SrcCur;

    // Overlap is currently permitted.
#if 0
    // Check for overlap between SOURCE_ENTRY address ranges.
    for (SrcCur = mi->SourceFiles;
         SrcCur != NULL;
         SrcCur = SrcCur->Next)
    {
        if (!(SrcCur->MinAddr > Src->MaxAddr ||
              SrcCur->MaxAddr < Src->MinAddr))
        {
            DbgPrint("SOURCE_ENTRY overlap between %08X:%08X and %08X:%08X\n",
                     Src->MinAddr, Src->MaxAddr,
                     SrcCur->MinAddr, SrcCur->MaxAddr);
        }
    }
#endif

    // Sort line info by address.
    qsort((PVOID)Src->LineInfo, Src->Lines, sizeof(Src->LineInfo[0]),
          CompareLineAddresses);

    // Link new source information into list, sorted by address
    // range covered by information.

    SrcPrev = NULL;
    for (SrcCur = mi->SourceFiles;
         SrcCur != NULL;
         SrcPrev = SrcCur, SrcCur = SrcCur->Next)
    {
        if (SrcCur->MinAddr > Src->MinAddr) {
            break;
        }
    }

    Src->Next = SrcCur;
    if (SrcPrev != NULL) {
        SrcPrev->Next = Src;
    } else {
        mi->SourceFiles = Src;
    }

#if 0
    DbgPrint("%08X %08X: %5d lines, '%s'\n",
             Src->MinAddr, Src->MaxAddr, Src->Lines, Src->File);
#endif
}

// #define DBG_COFF_LINES

#define IS_SECTION_SYM(Sym) \
    ((Sym)->StorageClass == IMAGE_SYM_CLASS_STATIC && \
     (Sym)->Type == IMAGE_SYM_TYPE_NULL && \
     (Sym)->NumberOfAuxSymbols == 1)

BOOL
AddLinesForCoff(
    PMODULE_ENTRY mi,
    PIMAGE_SYMBOL allSymbols,
    DWORD numberOfSymbols,
    PIMAGE_LINENUMBER LineNumbers
    )
{
    PIMAGE_LINENUMBER *SecLines;
    BOOL Ret;
    PIMAGE_SECTION_HEADER sh;
    ULONG i;
    PIMAGE_SYMBOL Symbol;
    ULONG LowestPointer;

    // Allocate some space for per-section data.
    SecLines = MemAlloc(sizeof(PIMAGE_LINENUMBER)*mi->NumSections);
    if (SecLines == NULL) {
        return FALSE;
    }

    //
    // Add line number information for file groups if such
    // groups exist.
    //

    // First locate the lowest file offset for linenumbers.  This
    // is necessary to be able to compute relative linenumber pointers
    // in split images because currently the pointers aren't updated
    // during stripping.
    sh = mi->SectionHdrs;
    LowestPointer = 0xffffffff;
    for (i = 0; i < mi->NumSections; i++, sh++) {
        if (sh->NumberOfLinenumbers > 0 &&
            sh->PointerToLinenumbers != 0 &&
            sh->PointerToLinenumbers < LowestPointer)
        {
            LowestPointer = sh->PointerToLinenumbers;
        }
    }

    if (LowestPointer == 0xffffffff) {
        goto EH_FreeSecLines;
    }

    sh = mi->SectionHdrs;
    for (i = 0; i < mi->NumSections; i++, sh++) {
        if (sh->NumberOfLinenumbers > 0 &&
            sh->PointerToLinenumbers != 0)
        {
            SecLines[i] = (PIMAGE_LINENUMBER)
                (sh->PointerToLinenumbers - LowestPointer + (DWORD_PTR)LineNumbers);

#ifdef DBG_COFF_LINES
            //DbgPrint("Section %d: %d lines at %08X\n",
                     //i, sh->NumberOfLinenumbers, SecLines[i]);
#endif
        } else {
            SecLines[i] = NULL;
        }
    }

    // Look for a file symbol.
    Symbol = allSymbols;
    for (i = 0; i < numberOfSymbols; i++) {
        if (Symbol->StorageClass == IMAGE_SYM_CLASS_FILE) {
            break;
        }

        i += Symbol->NumberOfAuxSymbols;
        Symbol += 1+Symbol->NumberOfAuxSymbols;
    }

    // If no file symbols were found, don't attempt to add line
    // number information.  Something could be done with the raw
    // linenumber info in the image (if it exists) but this probably
    // isn't an important enough case to worry about.

    while (i < numberOfSymbols) {
        ULONG iNextFile, iAfterFile;
        ULONG iCur, iSym;
        PIMAGE_SYMBOL SymAfterFile, CurSym;
        PIMAGE_AUX_SYMBOL AuxSym;
        ULONG Lines;
        ULONG MinAddr, MaxAddr;
        LPSTR FileName;
        ULONG FileNameLen;

#ifdef DBG_COFF_LINES
        //DbgPrint("%3X: '%s', %X\n", i, Symbol+1, Symbol->Value);
#endif

        // A file symbol's Value is the index of the next file symbol.
        // In between the two file symbols there may be static
        // section symbols which give line number counts for all
        // the line numbers in the file.
        // The file chain can be NULL terminated or a circular list,
        // in which case this code assumes the end comes when the
        // list wraps around.

        if (Symbol->Value == 0 || Symbol->Value <= i) {
            iNextFile = numberOfSymbols;
        } else {
            iNextFile = Symbol->Value;
        }

        // Compute the index of the first symbol after the current file
        // symbol.
        iAfterFile = i+1+Symbol->NumberOfAuxSymbols;
        SymAfterFile = Symbol+1+Symbol->NumberOfAuxSymbols;

        // Look for section symbols and count up the number of linenumber
        // references, the min address and the max address.
        CurSym = SymAfterFile;
        iCur = iAfterFile;
        Lines = 0;
        MinAddr = 0xffffffff;
        MaxAddr = 0;
        while (iCur < iNextFile) {
            DWORD Addr;

            if (IS_SECTION_SYM(CurSym) &&
                SecLines[CurSym->SectionNumber-1] != NULL)
            {
                AuxSym = (PIMAGE_AUX_SYMBOL)(CurSym+1);

                Lines += AuxSym->Section.NumberOfLinenumbers;

                Addr = (ULONG)(CurSym->Value+mi->BaseOfDll);

#ifdef DBG_COFF_LINES
                //DbgPrint("    Range %08X %08X, min %08X max %08X\n",
                         //Addr, Addr+AuxSym->Section.Length-1,
                         //MinAddr, MaxAddr);
#endif

                if (Addr < MinAddr) {
                    MinAddr = Addr;
                }
                Addr += AuxSym->Section.Length-1;
                if (Addr > MaxAddr) {
                    MaxAddr = Addr;
                }
            }

            iCur += 1+CurSym->NumberOfAuxSymbols;
            CurSym += 1+CurSym->NumberOfAuxSymbols;
        }

        if (Lines > 0) {
            PSOURCE_ENTRY Src;
            PSOURCE_LINE SrcLine;
            ULONG iLine;

            // We have a filename and some linenumber information,
            // so create a SOURCE_ENTRY and fill it in.

            FileName = (LPSTR)(Symbol+1);
            FileNameLen = strlen(FileName);

            Src = MemAlloc(sizeof(SOURCE_ENTRY)+
                           sizeof(SOURCE_LINE)*Lines+
                           FileNameLen+1);
            if (Src == NULL) {
                goto EH_FreeSecLines;
            }

            Src->PdbModule = NULL;
            Src->MinAddr = MinAddr;
            Src->MaxAddr = MaxAddr;
            Src->Lines = Lines;

            SrcLine = (PSOURCE_LINE)(Src+1);
            Src->LineInfo = SrcLine;

            // Now that we've got a place to put linenumber information,
            // retraverse the section symbols and grab COFF linenumbers
            // from the appropriate sections and format them into
            // the generic format.
            CurSym = SymAfterFile;
            iCur = iAfterFile;
            while (iCur < iNextFile) {
                if (IS_SECTION_SYM(CurSym) &&
                    SecLines[CurSym->SectionNumber-1] != NULL) {
                    PIMAGE_LINENUMBER CoffLine;

                    AuxSym = (PIMAGE_AUX_SYMBOL)(CurSym+1);
                    CoffLine = SecLines[CurSym->SectionNumber-1];

#ifdef DBG_COFF_LINES
                    //DbgPrint("    %d lines at %08X\n",
                             //AuxSym->Section.NumberOfLinenumbers,
                             //CoffLine);
#endif

                    for (iLine = 0;
                         iLine < AuxSym->Section.NumberOfLinenumbers;
                         iLine++)
                    {
                        SrcLine->Addr = CoffLine->Type.VirtualAddress+
                            mi->BaseOfDll;
                        SrcLine->Line = CoffLine->Linenumber;
                        CoffLine++;
                        SrcLine++;
                    }

                    SecLines[CurSym->SectionNumber-1] = CoffLine;
                }

                iCur += 1+CurSym->NumberOfAuxSymbols;
                CurSym += 1+CurSym->NumberOfAuxSymbols;
            }

            // Stick file name at the very end of the data block so
            // it doesn't interfere with alignment.
            Src->File = (LPSTR)SrcLine;
            memcpy(Src->File, FileName, FileNameLen+1);

            AddSourceEntry(mi, Src);

            // This routine is successful as long as it adds at least
            // one new source entry.
            Ret = TRUE;
        }

        // After the loops above iCur and CurSym refer to the next
        // file symbol, so update the loop counters from them.
        i = iCur;
        Symbol = CurSym;
    }

 EH_FreeSecLines:
    MemFree(SecLines);

    return Ret;
}

BOOL
AddLinesForOmfSourceModule(
    PMODULE_ENTRY mi,
    BYTE *Base,
    OMFSourceModule *OmfSrcMod,
    PVOID PdbModule
    )
{
    BOOL Ret;
    ULONG iFile;

    Ret = FALSE;

    for (iFile = 0; iFile < (ULONG)OmfSrcMod->cFile; iFile++) {
        OMFSourceFile *OmfSrcFile;
        BYTE OmfFileNameLen;
        LPSTR OmfFileName;
        PULONG OmfAddrRanges;
        OMFSourceLine *OmfSrcLine;
        ULONG iSeg;
        PSOURCE_ENTRY Src;
        PSOURCE_ENTRY Seg0Src;
        PSOURCE_LINE SrcLine;
        ULONG NameAllocLen;

        OmfSrcFile = (OMFSourceFile *)(Base+OmfSrcMod->baseSrcFile[iFile]);

        // The baseSrcLn array of offsets is immediately followed by
        // SVA pairs which define the address ranges for the segments.
        OmfAddrRanges = &OmfSrcFile->baseSrcLn[OmfSrcFile->cSeg];

        // The name length and data immediately follows the address
        // range information.
        OmfFileName = (LPSTR)(OmfAddrRanges+2*OmfSrcFile->cSeg)+1;
        OmfFileNameLen = *(BYTE *)(OmfFileName-1);

        // The compiler can potentially generate a lot of segments
        // per file.  The segments within a file have disjoint
        // address ranges as long as they are treated as separate
        // SOURCE_ENTRYs.  If all segments for a particular file get
        // combined into one SOURCE_ENTRY it leads to address range overlap
        // because of combining non-contiguous segments.  Allocating
        // a SOURCE_ENTRY per segment isn't that bad, particularly since
        // the name information only needs to be allocated in the first
        // entry for a file and the rest can share it.

        NameAllocLen = OmfFileNameLen+1;

        for (iSeg = 0; iSeg < (ULONG)OmfSrcFile->cSeg; iSeg++) {
            PULONG Off;
            PUSHORT Ln;
            ULONG iLine;
            PIMAGE_SECTION_HEADER sh;

            OmfSrcLine = (OMFSourceLine *)(Base+OmfSrcFile->baseSrcLn[iSeg]);

            Src = MemAlloc(sizeof(SOURCE_ENTRY)+
                           sizeof(SOURCE_LINE)*OmfSrcLine->cLnOff+
                           NameAllocLen);
            if (Src == NULL) {
                return Ret;
            }

            Src->PdbModule = PdbModule;
            Src->Lines = OmfSrcLine->cLnOff;

            sh = &mi->SectionHdrs[OmfSrcLine->Seg-1];

            // Process raw segment limits into current addresses.
            Src->MinAddr = mi->BaseOfDll+sh->VirtualAddress+(*OmfAddrRanges++);
            Src->MaxAddr = mi->BaseOfDll+sh->VirtualAddress+(*OmfAddrRanges++);

            // Retrieve line numbers and offsets from raw data and
            // process them into current pointers.

            SrcLine = (SOURCE_LINE *)(Src+1);
            Src->LineInfo = SrcLine;

            Off = (ULONG *)&OmfSrcLine->offset[0];
            Ln = (USHORT *)(Off+OmfSrcLine->cLnOff);

            for (iLine = 0; iLine < OmfSrcLine->cLnOff; iLine++) {
                SrcLine->Line = *Ln++;
                SrcLine->Addr = (*Off++)+mi->BaseOfDll+sh->VirtualAddress;
                SrcLine++;
            }

            if (iSeg == 0) {
                // Stick file name at the very end of the data block so
                // it doesn't interfere with alignment.
                Src->File = (LPSTR)SrcLine;
                memcpy(Src->File, OmfFileName, OmfFileNameLen);
                Src->File[OmfFileNameLen] = 0;

                // Later segments will share this initial name storage
                // space so they don't need to alloc their own.
                NameAllocLen = 0;
                Seg0Src = Src;
            } else {
                Src->File = Seg0Src->File;
            }

            AddSourceEntry(mi, Src);

            // This routine is successful as long as it adds at least
            // one new source entry.
            Ret = TRUE;
        }
    }

    return Ret;
}

BOOL
AddLinesForPdbMod(
    PMODULE_ENTRY mi,
    PVOID Module
    )
{
    LONG Size;
    PBYTE Buf;
    BOOL Ret;
    PSOURCE_ENTRY Src;
    USHORT ModIdx;

    if (!ModQueryImod(Module, &ModIdx)) {
        return FALSE;
    }

    // Check and see if we've loaded this information already.
    for (Src = mi->SourceFiles; Src != NULL; Src = Src->Next) {
        // Check module index instead of pointer since there's
        // no guarantee the pointer would be the same for different
        // lookups.
        if (Src->PdbModule == (PVOID)ModIdx) {
            return TRUE;
        }
    }

    if (!ModQueryLines(Module, NULL, &Size) || Size < 0) {
        return FALSE;
    }

    // Occasionally ModQueryLines will succeed but indicate no data.
    // Ignore this.
    if (Size == 0) {
        return TRUE;
    }

    Buf = MemAlloc(Size);
    if (Buf == NULL) {
        return FALSE;
    }

    ModQueryLines(Module, Buf, &Size);

    Ret = AddLinesForOmfSourceModule(mi, Buf, (OMFSourceModule *)Buf,
                                     (PVOID)ModIdx);

    MemFree(Buf);

    return Ret;
}

BOOL
AddLinesForPdbModAtAddr(
    PMODULE_ENTRY mi,
    DWORD64 Addr
    )
{
    BOOL Ret;
    DWORD Bias;
    PIMAGE_SECTION_HEADER sh;
    DWORD i;
    Mod * Module;

    Addr = ConvertOmapToSrc( mi, Addr, &Bias, FALSE );

    if (Addr == 0) {
        //
        // No equivalent address
        //
        return FALSE;
    }

    //
    // We have successfully converted
    //
    Addr += Bias;

    //
    // locate the section that the address resides in
    //
    for (i = 0, sh = mi->SectionHdrs; i < mi->NumSections; i++, sh++) {
        if (Addr >= (mi->BaseOfDll + sh->VirtualAddress) &&
            Addr <  (mi->BaseOfDll + sh->VirtualAddress +
                     sh->Misc.VirtualSize)) {
            //
            // found the section
            //
            break;
        }
    }

    if (i == mi->NumSections) {
        return FALSE;
    }

    // Find the DBI module that the address is in.
    if (!DBIQueryModFromAddr(mi->dbi,
                             (USHORT)(i+1),
                             (ULONG)(Addr - sh->VirtualAddress - mi->BaseOfDll),
                             &Module,
                             NULL,
                             NULL,
                             NULL)) {
        return FALSE;
    }

    Ret = AddLinesForPdbMod(mi, Module);

    ModClose(Module);

    return Ret;
}

BOOL
AddLinesForAllPdbMod(
    PMODULE_ENTRY mi
    )
{
    Mod * Module;
    Mod * PrevModule;
    BOOL Ret;

    Ret = FALSE;

    PrevModule = NULL;
    while (DBIQueryNextMod(mi->dbi, PrevModule, &Module) && Module != NULL) {
        if (PrevModule != NULL) {
            ModClose(PrevModule);
        }

        Ret = AddLinesForPdbMod(mi, Module);

        PrevModule = Module;

        if (!Ret) {
            break;
        }
    }

    if (PrevModule != NULL) {
        ModClose(PrevModule);
    }

    return Ret;
}

VOID
FillLineInfo(
    PSOURCE_ENTRY Src,
    PSOURCE_LINE SrcLine,
    PIMAGEHLP_LINE64 Line
    )
{
    Line->Key = (PVOID)SrcLine;
    Line->LineNumber = SrcLine->Line;
    Line->FileName = Src->File;
    Line->Address = SrcLine->Addr;
}

PSOURCE_LINE
FindLineInSource(
    PSOURCE_ENTRY Src,
    DWORD64 Addr
    )
{
    ULONG Low, Middle, High;
    PSOURCE_LINE SrcLine;

    Low = 0;
    High = Src->Lines-1;

    while (High >= Low) {
        Middle = (Low+High) >> 1;
        SrcLine = &Src->LineInfo[Middle];

#ifdef DBG_ADDR_SEARCH
        //DbgPrint("    Checking %4d:%x`%08X\n", Middle, (ULONG)(SrcLine->Addr>>32), (ULONG)SrcLine->Addr);
#endif

        if (Addr < SrcLine->Addr) {
            High = Middle-1;
        }
        else if (Middle < Src->Lines-1 &&
                 Addr >= (SrcLine+1)->Addr) {
            Low = Middle+1;
        } else {
            return SrcLine;
        }
    }

    return NULL;
}

PSOURCE_ENTRY
FindSourceEntryForAddr(
    PMODULE_ENTRY mi,
    DWORD64 Addr,
    PSOURCE_ENTRY SearchFrom
    )
{
    PSOURCE_ENTRY Src;

    Src = SearchFrom != NULL ? SearchFrom->Next : mi->SourceFiles;
    while (Src != NULL) {
        if (Addr < Src->MinAddr) {
            // Source files are kept sorted by increasing address so this
            // means that the address will not be found later and
            // we can stop checking.
            return NULL;
        } else if (Addr <= Src->MaxAddr) {
            // Found one.
            return Src;
        }

        Src = Src->Next;
    }

    return NULL;
}

BOOL
GetLineFromAddr(
    PMODULE_ENTRY mi,
    DWORD64 Addr,
    PDWORD Displacement,
    PIMAGEHLP_LINE64 Line
    )
{
    PSOURCE_ENTRY Src;
    BOOL TryLoad;

    if (mi == NULL) {
        return FALSE;
    }

    // We only lazy load here for PDB symbols, and only if we're allowed to.
    TryLoad = mi->SymType == SymPdb &&
        (SymOptions & SYMOPT_LOAD_LINES) != 0;

    for (;;) {
        PSOURCE_ENTRY BestSrc;
        PSOURCE_LINE BestSrcLine;
        DWORD64 BestDisp;

        // Search through all the source entries that contain the given
        // address, looking for the line with the smallest displacement.

        BestDisp = 0xffffffffffffffff;
        BestSrc = NULL;
        Src = NULL;
        while (Src = FindSourceEntryForAddr(mi, Addr, Src)) {
            PSOURCE_LINE SrcLine;

#ifdef DBG_ADDR_SEARCH
            //DbgPrint("Found '%s' %08X %08X for %08X\n",
                     //Src->File, Src->MinAddr, Src->MaxAddr, Addr);
#endif

            // Found a matching source entry, so look up the line
            // information.
            SrcLine = FindLineInSource(Src, Addr);
            if (SrcLine != NULL &&
                Addr-SrcLine->Addr < BestDisp) {
                BestDisp = Addr-SrcLine->Addr;

#ifdef DBG_ADDR_SEARCH
                //DbgPrint("  Best disp %X\n", BestDisp);
#endif

                BestSrc = Src;
                BestSrcLine = SrcLine;
                if (BestDisp == 0) {
                    break;
                }
            }
        }

        // Only accept displaced answers if there's no more symbol
        // information to load.
        if (BestSrc != NULL && (BestDisp == 0 || !TryLoad)) {
            FillLineInfo(BestSrc, BestSrcLine, Line);
            *Displacement = (ULONG)BestDisp;
            return TRUE;
        }

        if (!TryLoad) {
            // There's no more line information to try and load so
            // we're out of luck.
            return FALSE;
        }

        TryLoad = FALSE;

        if (!AddLinesForPdbModAtAddr(mi, Addr)) {
            return FALSE;
        }
    }

    return FALSE;
}

PSOURCE_ENTRY
FindSourceEntryForFile(
    PMODULE_ENTRY mi,
    LPSTR FileStr,
    PSOURCE_ENTRY SearchFrom
    )
{
    PSOURCE_ENTRY Src;

    Src = SearchFrom != NULL ? SearchFrom->Next : mi->SourceFiles;
    while (Src != NULL)
    {
        if (SymMatchFileName(Src->File, FileStr, NULL, NULL))
        {
            return Src;
        }

        Src = Src->Next;
    }

    return NULL;
}

BOOL
FindLineByName(
    PMODULE_ENTRY mi,
    LPSTR FileName,
    DWORD LineNumber,
    PLONG Displacement,
    PIMAGEHLP_LINE64 Line
    )
{
    PSOURCE_ENTRY Src;
    BOOL TryLoad;

    if (mi == NULL)
    {
        return FALSE;
    }

    if (FileName == NULL)
    {
        // If no file was given then it's assumed that the file
        // is the same as for the line information passed in.
        FileName = Line->FileName;
    }

    // We only lazy load here for PDB symbols, and only if we're allowed to.
    TryLoad = mi->SymType == SymPdb &&
        (SymOptions & SYMOPT_LOAD_LINES) != 0;

    for (;;)
    {
        ULONG Disp;
        ULONG BestDisp;
        PSOURCE_ENTRY BestSrc;
        PSOURCE_LINE BestSrcLine;

        //
        // Search existing source information for a filename match.
        // There can be multiple SOURCE_ENTRYs with the same filename,
        // so make sure and search them all for an exact match
        // before settling on an approximate match.
        //

        Src = NULL;
        BestDisp = 0x7fffffff;
        BestSrcLine = NULL;
        while (Src = FindSourceEntryForFile(mi, FileName, Src))
        {
            PSOURCE_LINE SrcLine;
            ULONG i;

            // Found a matching source entry, so look up the closest
            // line.  Line number info is sorted by address so the actual
            // line numbers can be in any order so we can't optimize
            // this linear search.

            SrcLine = Src->LineInfo;
            for (i = 0; i < Src->Lines; i++)
            {
                if (LineNumber > SrcLine->Line)
                {
                    Disp = LineNumber-SrcLine->Line;
                }
                else
                {
                    Disp = SrcLine->Line-LineNumber;
                }

                if (Disp < BestDisp)
                {
                    BestDisp = Disp;
                    BestSrc = Src;
                    BestSrcLine = SrcLine;
                    if (Disp == 0)
                    {
                        break;
                    }
                }

                SrcLine++;
            }

            // If we found an exact match we can stop.
            if (BestDisp == 0)
            {
                break;
            }
        }

        // Only accept displaced answers if there's no more symbol
        // information to load.
        if (BestSrcLine != NULL && (BestDisp == 0 || !TryLoad))
        {
            FillLineInfo(BestSrc, BestSrcLine, Line);
            *Displacement = (LONG)(LineNumber-BestSrcLine->Line);
            return TRUE;
        }

        if (!TryLoad)
        {
            // There's no more line information to try and load so
            // we're out of luck.
            return FALSE;
        }

        TryLoad = FALSE;

        // There doesn't seem to be an easy way to look up a module by
        // filename.  It's possible to query by object filename, but
        // that can be much different from the source filename.
        // Just load the info all PDB modules.

        if (!AddLinesForAllPdbMod(mi))
        {
            return FALSE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\impchk.cxx ===
#include <windows.h>
#include <winnt.h>
#include <imagehlp.h>
#include <stdio.h>
#include <stdlib.h>

LOADED_IMAGE Image;

int __cdecl CompareNames (const void *pv1, const void *pv2)
{
    return(strcmp((const char *)pv1, *(const char **)pv2));
}

char *rgszBetaAPIs[] = {
    "ABProviderInit",
    "AddInksetInterval",
    "AddPenDataHRC",
    "AddPenInputHRC",
    "AddPointsPenData",
    "AddPropertySheet",
    "AddWordsHWL",
    "AnimateProc",
    "AssociateProperties",
    "AtomicVirtualEvent",
    "BeginEnumStrokes",
    "BoundingRectFromPoints",
    "BroadcastSystemMessage",
    "BrowseCallbackProc",
    "BuildDisplayTable",
    "CallWndRetProc",
    "CascadeWindows",
    "ChangeIdleRoutine",
    "CharacterToSymbol",
    "CheckColorsInGamut",
    "CheckMenuRadioItem",
    "CheckParameters",
    "CloseIMsgSession",
    "CloseProperties",
    "ColorMatchToTarget",
    "CommConfigDialog",
    "CompactPenData",
    "CompressPenData",
    "ConfigHREC",
    "ConfigRecognizer",
    "CopyImage",
    "CorrectWriting",
    "CorrectWritingEx",
    "CreateColorSpace",
    "CreateCompatibleHRC",
    "CreateHWL",
    "CreateIProp",
    "CreateIconFromResourceEx",
    "CreateInkset",
    "CreateInksetHRCRESULT",
    "CreatePenData",
    "CreatePenDataEx",
    "CreatePenDataHRC",
    "CreatePenDataRegion",
    "CreateTable",
    "CreateToolhelp32Snapshot",
    "DPtoTP",
    "DeleteColorSpace",
    "DeregisterIdleRoutine",
    "DestroyHRC",
    "DestroyHRCRESULT",
    "DestroyHWL",
    "DestroyInkset",
    "DestroyPenData",
    "DictionarySearch",
    "DisplayGuesses",
    "DoDefaultPenInput",
    "DrawAnimatedRects",
    "DrawArrow",
    "DrawCaption",
    "DrawMirrorImage",
    "DrawPenData",
    "DrawPenDataEx",
    "DrawPenDataFmt",
    "DrawState",
    "DrawStateProc",
    "DrawTextEx",
    "DuplicatePenData",
    "EditProperties",
    "EmulatePen",
    "EnableGestureSetHRC",
    "EnableIdleRoutine",
    "EnableSystemDictionaryHRC",
    "EndEnumStrokes",
    "EndPenInputHRC",
    "EnumFontFamExProc",
    "EnumFontFamiliesEx",
    "EnumICMProfiles",
    "EnumICMProfilesProc",
    "EnumProperties",
    "EnumPropertyLibs",
    "EnumPropertySheets",
    "EnumRegisterWordProc",
    "EnumSymbols",
    "EnumSymbolsCallback",
    "ExtractPenDataPoints",
    "ExtractPenDataStrokes",
    "FAbsTimeInInterval",
    "FBadColumnSet",
    "FBadEntryList",
    "FBadProp",
    "FBadPropTag",
    "FBadRestriction",
    "FBadRglpNameID",
    "FBadRglpszW",
    "FBadRow",
    "FBadRowSet",
    "FBadSortOrderSet",
    "FBinFromHex",
    "FEQAbsTime",
    "FEqualNames",
    "FIntervalInInterval",
    "FIntervalXInterval",
    "FLEAbsTime",
    "FLTAbsTime",
    "FPropCompareProp",
    "FPropContainsProp",
    "FPropExists",
    "FindWindowEx",
    "FirstSymbolFromGraph",
    "FlushProperties",
    "FreeImageColorMatcher",
    "FreePadrlist",
    "FreePropertyLib",
    "FreePropertySheets",
    "FreeProws",
    "FtAddFt",
    "FtMulDw",
    "FtMulDwDw",
    "FtNegFt",
    "FtSubFt",
    "FtgRegisterIdleRoutine",
    "GetAlphabetHRC",
    "GetAlphabetPriorityHRC",
    "GetAlternateWordsHRCRESULT",
    "GetAttribIMsgOnIStg",
    "GetBoxMappingHRCRESULT",
    "GetBoxResultsHRC",
    "GetCharacterPlacement",
    "GetClassInfoEx",
    "GetColorSpace",
    "GetCommConfig",
    "GetDefaultCommConfig",
    "GetDeviceGammaRamp",
    "GetFontLanguageInfo",
    "GetGlobalRC",
    "GetGuideHRC",
    "GetHRECFromHRC",
    "GetHotspotsHRCRESULT",
    "GetICMProfile",
    "GetInksetInterval",
    "GetInksetIntervalCount",
    "GetInstance",
    "GetInternationalHRC",
    "GetKeyboardLayout",
    "GetKeyboardLayoutList",
    "GetLogColorSpace",
    "GetMaxResultsHRC",
    "GetMenuDefaultItem",
    "GetMenuItemInfo",
    "GetMenuItemRect",
    "GetPenAppFlags",
    "GetPenAsyncState",
    "GetPenDataAttributes",
    "GetPenDataInfo",
    "GetPenDataStroke",
    "GetPenHwEventData",
    "GetPenInput",
    "GetPenMiscInfo",
    "GetPenResource",
    "GetPointsFromPenData",
    "GetProperties",
    "GetResultsHRC",
    "GetStrokeAttributes",
    "GetStrokeTableAttributes",
    "GetSymbolCount",
    "GetSymbolCountHRCRESULT",
    "GetSymbolMaxLength",
    "GetSymbolsHRCRESULT",
    "GetSysColorBrush",
    "GetSystemPowerStatus",
    "GetTextCharsetInfo",
    "GetVersionPenWin",
    "GetWordlistCoercionHRC",
    "GetWordlistHRC",
    "HPProviderInit",
    "Heap32First",
    "Heap32ListFirst",
    "Heap32ListNext",
    "Heap32Next",
    "HexFromBin",
    "HitTestPenData",
    "HrAddColumnsEx",
    "HrAllocAdviseSink",
    "HrComposeEID",
    "HrComposeMsgID",
    "HrDecomposeEID",
    "HrDecomposeMsgID",
    "HrEntryIDFromSz",
    "HrGetOneProp",
    "HrIStorageFromStream",
    "HrQueryAllRows",
    "HrSetOneProp",
    "HrSzFromEntryID",
    "HrThisThreadAdviseSink",
    "HrValidateIPMSubtree",
    "ImmAssociateContext",
    "ImmConfigureIME",
    "ImmCreateContext",
    "ImmDestroyContext",
    "ImmEnumRegisterWord",
    "ImmEscape",
    "ImmGetCandidateList",
    "ImmGetCandidateListCount",
    "ImmGetCandidateWindow",
    "ImmGetCompositionFont",
    "ImmGetCompositionString",
    "ImmGetCompositionWindow",
    "ImmGetContext",
    "ImmGetConversionList",
    "ImmGetConversionStatus",
    "ImmGetDefaultIMEWnd",
    "ImmGetDescription",
    "ImmGetGuideLine",
    "ImmGetIMEFileName",
    "ImmGetOpenStatus",
    "ImmGetProperty",
    "ImmGetRegisterWordStyle",
    "ImmGetStatusWindowPos",
    "ImmGetVirtualKey",
    "ImmInstallIME",
    "ImmIsIME",
    "ImmIsUIMessage",
    "ImmNotifyIME",
    "ImmRegisterWord",
    "ImmReleaseContext",
    "ImmSetCandidateWindow",
    "ImmSetCompositionFont",
    "ImmSetCompositionString",
    "ImmSetCompositionWindow",
    "ImmSetConversionStatus",
    "ImmSetOpenStatus",
    "ImmSetStatusWindowPos",
    "ImmSimulateHotKey",
    "ImmUnregisterWord",
    "InfoWndProc",
    "InitRC",
    "InputWndProc",
    "InsertMenuItem",
    "InsertPenData",
    "InsertPenDataPoints",
    "InsertPenDataStroke",
    "InstallRecognizer",
    "IsPenAware",
    "IsPenEvent",
    "KKConvert",
    "LPropCompareProp",
    "LaunchWizard",
    "LoadImage",
    "LoadImageColorMatcher",
    "LoadPropertyLib",
    "LoadPropertySheets",
    "LookupIconIdFromDirectoryEx",
    "MAPIAddress",
    "MAPIAdminProfiles",
    "MAPIAllocateBuffer",
    "MAPIAllocateMore",
    "MAPIDeInitIdle",
    "MAPIDeleteMail",
    "MAPIDetails",
    "MAPIFindNext",
    "MAPIFreeBuffer",
    "MAPIGetDefaultMalloc",
    "MAPIInitIdle",
    "MAPIInitialize",
    "MAPILogoff",
    "MAPILogon",
    "MAPILogonEx",
    "MAPIMessage",
    "MAPIOpenFormMgr",
    "MAPIOpenLocalFormContainer",
    "MAPIReadMail",
    "MAPIRecip",
    "MAPIResolveName",
    "MAPISaveMail",
    "MAPISendDocuments",
    "MAPISendMail",
    "MAPIUnintialize",
    "MSProviderInit",
    "MakeAbsTime",
    "MapStorageSCode",
    "MapVirtualKeyEx",
    "MapiFile",
    "MapiFileDesc",
    "MapiFileTagExt",
    "MapiMessage",
    "MapiRecipDesc",
    "MenuItemFromPoint",
    "MessageBoxIndirect",
    "MetricScalePenData",
    "Module32First",
    "Module32Next",
    "OffsetPenData",
    "OpenIMsgOnIStg",
    "OpenIMsgOnIStorage",
    "OpenIMsgSession",
    "OpenProperties",
    "OpenStreamOnFile",
    "OpenTnefStream",
    "OpenTnefStreamEx",
    "PPChangePassword",
    "PPGetPasswordStatus",
    "PaintDesktop",
    "PeekPenInput",
    "PenDataFromBuffer",
    "PenDataToBuffer",
    "PostVirtualKeyEvent",
    "PostVirtualMouseEvent",
    "PpropFindProp",
    "PreprocessMessage",
    "Process32First",
    "Process32Next",
    "ProcessHRC",
    "ProcessWriting",
    "PropCopyMore",
    "PwdChangePassword",
    "PwdGetPasswordStatus",
    "PwdSetPasswordStatus",
    "RTFSync",
    "RawWndProc",
    "ReadHWL",
    "Recognize",
    "RecognizeData",
    "RedisplayPenData",
    "RegisterClassEx",
    "RegisterPenApp",
    "RemovePenDataStrokes",
    "RemovePreprocessInfo",
    "RemovePropertySheet",
    "ResizePenData",
    "ResultsHookHREC",
    "SAVEOPTS",
    "SAndRestriction",
    "SAppTimeArray",
    "SBinary",
    "SBinaryArray",
    "SBitMaskRestriction",
    "SCommentRestriction",
    "SComparePropsRestriction",
    "SContentRestriction",
    "SCurrencyArray",
    "SDateTimeArray",
    "SDoubleArray",
    "SExistRestriction",
    "SGuidArray",
    "SHAddToRecentDocs",
    "SHAppBarMessage",
    "SHBrowseForFolder",
    "SHChangeNotify",
    "SHFileOperation",
    "SHFreeNameMappings",
    "SHGetDesktopFolder",
    "SHGetFileInfo",
    "SHGetInstanceExplorer",
    "SHGetMalloc",
    "SHGetNameMappingCount",
    "SHGetNameMappingPtr",
    "SHGetPathFromIDList",
    "SHGetSpecialFolderLocation",
    "SHLoadInProc",
    "SLPSTRArray",
    "SLargeIntegerArray",
    "SLongArray",
    "SMAPIFormInfoArray",
    "SMAPIFormProp",
    "SMAPIFormPropArray",
    "SMAPIFormPropEnumVal",
    "SMAPIVerb",
    "SMAPIVerbArray",
    "SMessageClassArray",
    "SNotRestriction",
    "SOBailOut",
    "SOBeginTable",
    "SOEndColumnInfo",
    "SOEndFieldInfo",
    "SOEndFontTable",
    "SOEndPalette",
    "SOEndTabStops",
    "SOEndTable",
    "SOGetInfo",
    "SOGetScanLineBuffer",
    "SOPutBitmapHeader",
    "SOPutBreak",
    "SOPutChar",
    "SOPutCharAttr",
    "SOPutCharFontById",
    "SOPutCharFontByName",
    "SOPutCharHeight",
    "SOPutCharX",
    "SOPutColumnInfo",
    "SOPutDataCell",
    "SOPutEmbeddedObject",
    "SOPutField",
    "SOPutFieldInfo",
    "SOPutFontTableEntry",
    "SOPutHdrEntry",
    "SOPutMoreText",
    "SOPutMoreVarField",
    "SOPutPaletteEntry",
    "SOPutParaAlign",
    "SOPutParaIndents",
    "SOPutParaMargins",
    "SOPutParaSpacing",
    "SOPutScanLineData",
    "SOPutSectionName",
    "SOPutSectionType",
    "SOPutSpecialCharX",
    "SOPutSubdocInfo",
    "SOPutTabStop",
    "SOPutTableCellInfo",
    "SOPutTableRowFormat",
    "SOPutTextCell",
    "SOPutVarField",
    "SOPutVectorHeader",
    "SOSetDateBase",
    "SOStartColumnInfo",
    "SOStartFieldInfo",
    "SOStartFontTable",
    "SOStartPalette",
    "SOStartTabStops",
    "SOVectorAttr",
    "SOVectorObject",
    "SOrRestriction",
    "SPropAttrArray",
    "SPropProblem",
    "SPropProblemArray",
    "SPropTagArray",
    "SPropValue",
    "SPropertyRestriction",
    "SRealArray",
    "SRestriction",
    "SRow",
    "SRowSet",
    "SShortArray",
    "SSizeRestriction",
    "SSortOrder",
    "SSortOrderSet",
    "SSubRestriction",
    "STnefProblem",
    "STnefProblemArray",
    "SUUserPopData",
    "SUUserPushData",
    "SUUserRetrieveData",
    "SUUserSaveData",
    "SWStringArray",
    "ScBinFromHexBounded",
    "ScCopyNotifications",
    "ScCopyProps",
    "ScCountNotifications",
    "ScCountProps",
    "ScDupPropset",
    "ScLocalPathFromUNC",
    "ScRelocNotifications",
    "ScRelocProps",
    "ScUNCFromLocalPath",
    "SetAlphabetHRC",
    "SetAlphabetPriorityHRC",
    "SetAttribIMsgOnIStg",
    "SetBoxAlphabetHRC",
    "SetColorSpace",
    "SetCommConfig",
    "SetDefaultCommConfig",
    "SetDeviceGammaRamp",
    "SetGlobalRC",
    "SetGuideHRC",
    "SetICMMode",
    "SetICMProfile",
    "SetInternationalHRC",
    "SetMaxResultsHRC",
    "SetMenuDefaultItem",
    "SetMenuItemInfo",
    "SetMessageExtraInfo",
    "SetPenAppFlags",
    "SetPenHook",
    "SetPenHookCallback",
    "SetPenMiscInfo",
    "SetProperties",
    "SetRecogHook",
    "SetResultsHookHREC",
    "SetStrokeAttributes",
    "SetStrokeTableAttributes",
    "SetSystemPowerState",
    "SetWordlistCoercionHRC",
    "SetWordlistHRC",
    "Shell_NotifyIcon",
    "ShowKeyboard",
    "ShowWindowAsync",
    "StartInking",
    "StartPenInput",
    "StopInking",
    "StopPenInput",
    "SymbolToCharacter",
    "TPtoDP",
    "TargetPoints",
    "Thread32First",
    "Thread32Next",
    "TileWindows",
    "ToAsciiEx",
    "Toolhelp32ReadProcessMemory",
    "TrackPopupMenuEx",
    "TrainContext",
    "TrainHREC",
    "TrainInk",
    "TranslateCharsetInfo",
    "TrimPenData",
    "UnhookResultsHookHREC",
    "UninstallRecognizer",
    "UpdatePenInfo",
    "ValidateParameters",
    "VkKeyScanEx",
    "VwStreamCloseFunc",
    "VwStreamOpenFunc",
    "VwStreamReadFunc",
    "VwStreamReadRecordFunc",
    "VwStreamSectionFunc",
    "VwStreamSeekFunc",
    "VwStreamTellFunc",
    "WrapCompressedRTFStream",
    "WrapStoreEntryID",
    "WriteHWL",
    "XPProviderInit",
    "attAttachRenddata",
    "attConversationID",
    "attFrom",
    "attMAPIProps",
    "attMessageStatus",
    "attOriginalMessageClass",
    "attOwner",
    "attParentID",
    "attPriority",
    "attRecipTable",
    "attSentFor",
    "dwDiffAT",
    "dwDurInterval",
    "lineAccept",
    "lineAddProvider",
    "lineAddToConference",
    "lineAnswer",
    "lineBlindTransfer",
    "lineCallbackFunc",
    "lineClose",
    "lineCompleteCall",
    "lineCompleteTransfer",
    "lineConfigDialog",
    "lineConfigDialogEdit",
    "lineConfigProvider",
    "lineDeallocateCall",
    "lineDevSpecific",
    "lineDevSpecificFeature",
    "lineDial",
    "lineDrop",
    "lineForward",
    "lineGatherDigits",
    "lineGenerateDigits",
    "lineGenerateTone",
    "lineGetAddressCaps",
    "lineGetAddressID",
    "lineGetAddressStatus",
    "lineGetAppPriority",
    "lineGetCallInfo",
    "lineGetCallStatus",
    "lineGetConfRelatedCalls",
    "lineGetCountry",
    "lineGetDevCaps",
    "lineGetDevConfig",
    "lineGetID",
    "lineGetIcon",
    "lineGetLineDevStatus",
    "lineGetNewCalls",
    "lineGetNumRings",
    "lineGetProviderList",
    "lineGetRequest",
    "lineGetStatusMessages",
    "lineGetTranslateCaps",
    "lineHandoff",
    "lineHold",
    "lineInitialize",
    "lineMakeCall",
    "lineMonitorDigits",
    "lineMonitorMedia",
    "lineMonitorTones",
    "lineNegotiateAPIVersion",
    "lineNegotiateExtVersion",
    "lineOpen",
    "linePark",
    "linePickup",
    "linePrepareAddToConference",
    "lineRedirect",
    "lineRegisterRequestRecipient",
    "lineReleaseUserUserInfo",
    "lineRemoveFromConference",
    "lineRemoveProvider",
    "lineSecureCall",
    "lineSendUserUserInfo",
    "lineSetAppPriority",
    "lineSetAppSpecific",
    "lineSetCallParams",
    "lineSetCallPrivilege",
    "lineSetCurrentLocation",
    "lineSetDevConfig",
    "lineSetMediaControl",
    "lineSetMediaMode",
    "lineSetNumRings",
    "lineSetStatusMessages",
    "lineSetTerminal",
    "lineSetTollList",
    "lineSetupConference",
    "lineSetupTransfer",
    "lineShutdown",
    "lineSwapHold",
    "lineTranslateAddress",
    "lineTranslateDialog",
    "lineUncompleteCall",
    "lineUnhold",
    "lineUnpark",
    "phoneCallbackFunc",
    "phoneClose",
    "phoneConfigDialog",
    "phoneDevSpecific",
    "phoneGetButtonInfo",
    "phoneGetData",
    "phoneGetDevCaps",
    "phoneGetDisplay",
    "phoneGetGain",
    "phoneGetHookSwitch",
    "phoneGetID",
    "phoneGetIcon",
    "phoneGetLamp",
    "phoneGetRing",
    "phoneGetStatus",
    "phoneGetStatusMessages",
    "phoneGetVolume",
    "phoneInitialize",
    "phoneNegotiateAPIVersion",
    "phoneNegotiateExtVersion",
    "phoneOpen",
    "phoneSetButtonInfo",
    "phoneSetData",
    "phoneSetDisplay",
    "phoneSetGain",
    "phoneSetHookSwitch",
    "phoneSetLamp",
    "phoneSetRing",
    "phoneSetStatusMessages",
    "phoneSetVolume",
    "phoneShutdown",
    "tapiGetLocationInfo",
    "tapiRequestDrop",
    "tapiRequestMakeCall",
    "tapiRequestMediaCall",
    "ulValidateParameters"
};

BOOL
VerifyImageImports(
    char *ImageName
    );

void __cdecl
main(
    int argc,
    char *argv[]
    )
{
    int i;
    if (argc < 2 ||
        (((argv[1][0] == '/') || (argv[1][0] == '-')) &&
         (argv[1][1] == '?'))) {
        puts("Usage: impchk <imagename>\n"
             "   where <imagename> is the image you want to check for beta API's");
    } else {
        i = 0;
        while (argc > 1) {
            argc--;
            i++;
            printf("Image: \"%s\" should %s marked as Beta\n",
                    argv[i],
                    VerifyImageImports(argv[i]) ? "be" : "not be");
        }
    }
}

BOOL
VerifyImageImports(
    char *ImageName
    )
{
    PIMAGE_IMPORT_DESCRIPTOR Imports;
    PIMAGE_THUNK_DATA tname;
    PIMAGE_THUNK_DATA ThunkNames;
    PIMAGE_IMPORT_BY_NAME ImportName;
    ULONG NumberOfThunks;
    ULONG i, cb;
    UCHAR NameBuffer[ 32 ];
    PIMAGE_NT_HEADERS NtHeaders;
    ULONG ImportSize;
    LPSTR ImportModule;
    BOOL rc = FALSE;

    if (MapAndLoad(ImageName, ".", &Image, TRUE, TRUE)) {
        Image.ModuleName = ImageName;

        //
        // Now locate and walk through and process the images imports
        //

        NtHeaders = ImageNtHeader( (PVOID)Image.MappedAddress );
        if (NtHeaders != NULL) {

            Imports = (PIMAGE_IMPORT_DESCRIPTOR)ImageDirectoryEntryToData(
                                                    (PVOID)Image.MappedAddress,
                                                    FALSE,
                                                    IMAGE_DIRECTORY_ENTRY_IMPORT,
                                                    &ImportSize
                                                    );
            for(;Imports;Imports++) {
                if (!Imports->Name) {
                    break;
                }

                ImportModule = (LPSTR) ImageRvaToVa( (PIMAGE_NT_HEADERS) Image.FileHeader,
                                            Image.MappedAddress,
                                            (ULONG) Imports->Name,
                                            &Image.LastRvaSection);

                if (ImportModule) {

                    ThunkNames = (PIMAGE_THUNK_DATA) ImageRvaToVa(
                                    (PIMAGE_NT_HEADERS)Image.FileHeader,
                                    Image.MappedAddress,
                                    (ULONG) Imports->OriginalFirstThunk,
                                    &Image.LastRvaSection);

                    if (!ThunkNames || ThunkNames->u1.Function == 0) {
                        //
                        // Skip this one if no thunks or first thunk is the terminating null thunk
                        //
                        continue;
                    }

                    //
                    NumberOfThunks = 0;
                    tname = ThunkNames;
                    while (tname->u1.AddressOfData) {
                        NumberOfThunks++;
                        tname++;
                    }

                    tname = ThunkNames;
                    for(i=0;i<NumberOfThunks;i++) {
                        if (!(BOOL)IMAGE_SNAP_BY_ORDINAL(tname->u1.Ordinal)) {
                            ImportName = (PIMAGE_IMPORT_BY_NAME)
                                    ImageRvaToVa((PIMAGE_NT_HEADERS)Image.FileHeader,
                                                 Image.MappedAddress,
                                                 (ULONG)(ULONG_PTR) tname->u1.AddressOfData,
                                                 &Image.LastRvaSection);
                            if (bsearch(ImportName->Name,
                                        rgszBetaAPIs,
                                        sizeof(rgszBetaAPIs) / sizeof(char *),
                                        sizeof(char *),
                                        CompareNames
                                       )) {
                                printf("%s: Imports \"%s\" from \"%s\"\n",
                                        ImageName,
                                        ImportName->Name,
                                        ImportModule);
                                rc = TRUE;
                            }
                        }

                        tname++;
                    }
                }
            }
        }

        UnMapAndLoad(&Image);
    }

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\pdbp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pdb.h

Abstract:

    This header file contains typedefs and prototypes
    necessary for accessing pdb files thru the msvc pdb dll.

Revision History:

--*/

#ifdef __cplusplus
extern "C" {
#endif

__inline
unsigned char *
DataSymNameStart(
    DATASYM32 *dataSym
    )
{
    switch (dataSym->rectyp) {
        case S_LDATA32_16t:
        case S_GDATA32_16t:
        case S_PUB32_16t:
            return(&((DATASYM32_16t *)dataSym)->name[1]);

        case S_LDATA32:
        case S_GDATA32:
        case S_PUB32:
        default:
            return(&((DATASYM32 *)dataSym)->name[1]);
    }
}


__inline
unsigned char
DataSymNameLength(
    DATASYM32 *dataSym
    )
{
    switch (dataSym->rectyp) {
        case S_LDATA32_16t:
        case S_GDATA32_16t:
        case S_PUB32_16t:
            return(((DATASYM32_16t *)dataSym)->name[0]);

        case S_LDATA32:
        case S_GDATA32:
        case S_PUB32:
        default:
            return(((DATASYM32 *)dataSym)->name[0]);
    }
}


__inline
unsigned short
DataSymSeg(
    DATASYM32 *dataSym
    )
{
    switch (dataSym->rectyp) {
        case S_LDATA32_16t:
        case S_GDATA32_16t:
        case S_PUB32_16t:
            return(((DATASYM32_16t *)dataSym)->seg);

        case S_LDATA32:
        case S_GDATA32:
        case S_PUB32:
        default:
            return(((DATASYM32 *)dataSym)->seg);
    }
}


__inline
unsigned long
DataSymOffset(
    DATASYM32 *dataSym
    )
{
    switch (dataSym->rectyp) {
        case S_LDATA32_16t:
        case S_GDATA32_16t:
        case S_PUB32_16t:
            return(((DATASYM32_16t *)dataSym)->off);

        case S_LDATA32:
        case S_GDATA32:
        case S_PUB32:
        default:
            return(((DATASYM32 *)dataSym)->off);
    }
}

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\mapdebugtst.c ===
#define MAP_DEBUG_TEST
#include "mapdebug.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\private.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    imagehlp.h

Abstract:

    This is a private header file for imagehlp.

Revision History:

--*/

#ifndef _IMAGEHLP_PRV_
#define _IMAGEHLP_PRV_

#define _IMAGEHLP_SOURCE_
#define _IA64REG_
#include <windows.h>
#include <imagehlp.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <memory.h>
#include <malloc.h>
#include <assert.h>
#include <string.h>
#include <time.h>
#include <ntverp.h>
#include <cvexefmt.h>
#define PDB_LIBRARY
#include <pdb.h>
#include "pdbp.h"
                                                             
#ifdef __cplusplus
extern "C" {
#endif


//
// BUGBUG - kcarlos - Place these functions in the correct files.
//
PWSTR AnsiToUnicode(PSTR);
PSTR UnicodeToAnsi(PWSTR);
BOOL CopyAnsiToUnicode(PWSTR, PSTR, DWORD);
BOOL CopyUnicodeToAnsi(PSTR, PWSTR, DWORD);
   
// used for delayloading the pdb handler

#define REGKEY_DBGHELP    "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\dbgHelp"
#define REGVAL_PDBHANDLER "PDBHandler"

// define the module

#ifdef BUILD_DBGHELP
 #define MOD_FILENAME "dbghelp.dll"
 #define MOD_NAME     "dbghelp"
#else
 #define MOD_FILENAME "imagehlp.dll"
 #define MOD_NAME     "imagehlp"
#endif 

/******************************************************************************
On a Hydra System, we don't want imaghlp.dll to load user32.dll since it
prevents CSRSS from exiting when running a under a debugger.
The following two functions have been copied from user32.dll so that we don't
link to user32.dll.
******************************************************************************/
#undef CharNext
#undef CharPrev

LPSTR CharNext(
    LPCSTR lpCurrentChar);

LPSTR CharPrev(
    LPCSTR lpStart,
    LPCSTR lpCurrentChar);


// Define some list prototypes

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
// some helpers for PE32/PE64 issues
//

#define OPTIONALHEADER(field) (OptionalHeader32 ? (OptionalHeader32->field) : (OptionalHeader64->field))
#define OPTIONALHEADER_LV(field) (*(OptionalHeader32 ? &(OptionalHeader32->field) : &(OptionalHeader64->field)))
#define OPTIONALHEADER_ASSIGN(field,value) (OptionalHeader32 ? (OptionalHeader32->field=(value)) : (OptionalHeader64->field=(value)))
#define OPTIONALHEADER_SET_FLAG(field,flag) (OptionalHeader32 ? (OptionalHeader32->field |=(flag)) : (OptionalHeader64->field|=(flag)))
#define OPTIONALHEADER_CLEAR_FLAG(field,flag) (OptionalHeader32 ? (OptionalHeader32->field &=(~flag)) : (OptionalHeader64->field&=(~flag)))

__inline
void
OptionalHeadersFromNtHeaders(
    PIMAGE_NT_HEADERS32 NtHeaders,
    PIMAGE_OPTIONAL_HEADER32 *OptionalHeader32,
    PIMAGE_OPTIONAL_HEADER64 *OptionalHeader64
    )
{
    if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
        *OptionalHeader32 = (PIMAGE_OPTIONAL_HEADER32)&NtHeaders->OptionalHeader;
        *OptionalHeader64 = NULL;
    } else
    if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
        *OptionalHeader64 = (PIMAGE_OPTIONAL_HEADER64)&NtHeaders->OptionalHeader;
        *OptionalHeader32 = NULL;
    }
}

#define DebugDirectoryIsUseful(Pointer, Size) (    \
    (Pointer != NULL) &&                          \
    (Size >= sizeof(IMAGE_DEBUG_DIRECTORY)) &&    \
    ((Size % sizeof(IMAGE_DEBUG_DIRECTORY)) == 0) \
    )

BOOL
CalculateImagePtrs(
    PLOADED_IMAGE LoadedImage
    );

typedef void * ( __cdecl * Alloc_t )( unsigned int );
typedef void   ( __cdecl * Free_t  )( void * );

typedef BOOL  (__stdcall *PINTERNAL_GET_MODULE)(HANDLE,LPSTR,DWORD64,DWORD,PVOID);
typedef PCHAR (__cdecl *PUNDNAME)( char *, const char *, int, Alloc_t, Free_t, unsigned short);

extern PUNDNAME pfUnDname;

extern API_VERSION AppVersion;
extern OSVERSIONINFO OSVerInfo;

#ifdef IMAGEHLP_HEAP_DEBUG

#define HEAP_SIG 0x69696969
typedef struct _HEAP_BLOCK {
    LIST_ENTRY  ListEntry;
    ULONG       Signature;
    ULONG       Size;
    ULONG       Line;
    CHAR        File[16];
} HEAP_BLOCK, *PHEAP_BLOCK;

#define MemAlloc(s)     pMemAlloc(s,__LINE__,__FILE__)
#define MemReAlloc(s)   pMemReAlloc(s,__LINE__,__FILE__)
#define MemFree(p)      pMemFree(p,__LINE__,__FILE__)
#define CheckHeap(p)    pCheckHeap(p,__LINE__,__FILE__)
#define MemSize(p)      pMemSize(p)
#else
#define MemAlloc(s)     pMemAlloc(s)
#define MemReAlloc(s,n) pMemReAlloc(s,n)
#define MemFree(p)      pMemFree(p)
#define CheckHeap(p)
#define MemSize(p)      pMemSize(p)
#endif

#ifdef IMAGEHLP_HEAP_DEBUG
VOID
pCheckHeap(
    PVOID MemPtr,
    ULONG Line,
    LPSTR File
    );
#endif

PVOID
pMemAlloc(
    ULONG_PTR AllocSize
#ifdef IMAGEHLP_HEAP_DEBUG
    ,ULONG Line
    ,LPSTR File
#endif
    );

PVOID
pMemReAlloc(
    PVOID OldAlloc,
    ULONG_PTR AllocSize
#ifdef IMAGEHLP_HEAP_DEBUG
    ,ULONG Line
    ,LPSTR File
#endif
    );

VOID
pMemFree(
    PVOID MemPtr
#ifdef IMAGEHLP_HEAP_DEBUG
    ,ULONG Line
    ,LPSTR File
#endif
    );

ULONG_PTR
pMemSize(
    PVOID MemPtr
    );

#define MAP_READONLY  TRUE
#define MAP_READWRITE FALSE


BOOL
MapIt(
    HANDLE FileHandle,
    PLOADED_IMAGE LoadedImage,
    BOOL ReadOnly
    );

VOID
UnMapIt(
    PLOADED_IMAGE LoadedImage
    );

BOOL
GrowMap(
    PLOADED_IMAGE   LoadedImage,
    LONG            lSizeOfDelta
    );

DWORD
ImagepSetLastErrorFromStatus(
    IN DWORD Status
    );

BOOL
UnloadAllImages(
    void
    );

BOOL
WalkX86(
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME64                    StackFrame,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    );

BOOL
WalkIa64(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    );

BOOL
WalkAlpha(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PVOID                             ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccessRoutine,
    BOOL                              Use64
    );

PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY
LookupFunctionEntry(
    HANDLE                            hProcess,
    ULONG64                           ControlPc,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccessRoutine,
    BOOL                              Use64
    );

void
ConvertAlphaRf32To64(
    PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY rf32,
    PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY rf64
    );

void
SymParseArgs(
    LPCSTR args
    );

VOID
EnsureTrailingBackslash(
    LPSTR sz
    );

enum {
    dsNone,
    dsInProc,
    dsImage,
    dsDbg,
    dsPdb
};

typedef struct {
    PCHAR   SymbolPath;
    ULONG64 InProcImageBase;
    ULONG64 ImageBaseFromImage;
    DWORD   SizeOfImage;
    DWORD   CheckSum;
    DWORD   TimeDateStamp;
    DWORD   Characteristics;
    USHORT  Machine;
    CHAR    ImageFilePath[_MAX_PATH];
    CHAR    OriginalImageFileName[_MAX_PATH];           // Retrieved from the .dbg file for cases when we only have a file handle...
    HANDLE  ImageFileHandle;
    PVOID   ImageMap;
    USHORT  iohMagic;
    CHAR    DbgFilePath[_MAX_PATH];
    CHAR    OriginalDbgFileName[_MAX_PATH];
    HANDLE  DbgFileHandle;
    PVOID   DbgFileMap;
    DWORD   PdbAge;
    DWORD   PdbSignature;
    CHAR    PdbFileName[_MAX_PATH];
    CHAR    PdbReferencePath[_MAX_PATH];
    PCHAR   pMappedCv;
    PCHAR   pMappedCoff;
    PCHAR   pMappedExportDirectory;
    PCHAR   pMappedDbgFunction;     // PIMAGE_FUNCTION_ENTRY from the .dbg file
    PVOID   pFpo;
    PVOID   pImageFunction;         // PIMAGE_RUNTIME_FUNCTION_ENTRY from the image.
    PVOID   pOmapTo;
    PVOID   pOmapFrom;
    PVOID   pOriginalSections;
    PVOID   pCurrentSections;
    DWORD   ddva;                   // only used by MapDebugInformation - virtual addr of debug dirs
    DWORD   cdd;                    // only used by MapDebugInformation - number of debug dirs
    PDB    *pPdb;
    DBI    *pDbi;
    GSI    *pGsi;
//  ULONG   NumberOfPdataFunctionEntries;
    ULONG   cFpo;
    ULONG   cOmapTo;
    ULONG   cOmapFrom;
    ULONG   cOriginalSections;
    ULONG   cCurrentSections;
    ULONG   cMappedCv;
    ULONG   cMappedCoff;
    ULONG   ImageAlign;
    BOOL    fPE64;
    BOOL    fROM;
    BOOL    fCoffMapped;
    BOOL    fCvMapped;
    BOOL    fFpoMapped;
    BOOL    fPdataMapped;
    BOOL    fOmapToMapped;
    BOOL    fOmapFromMapped;
    BOOL    fImageFunctionMapped;
    BOOL    fCurrentSectionsMapped;
    BOOL    fInProcHeader;
    HANDLE  hProcess;
    CHAR    ImageName[_MAX_PATH];
    DWORD   dsExports;
    DWORD   dsCoff;
    DWORD   dsCV;
    DWORD   dsMisc;
    DWORD   dsFPO;
    DWORD   dsOmapTo;
    DWORD   dsOmapFrom;
    DWORD   dsExceptions;
    IMAGE_EXPORT_DIRECTORY expdir;
    DWORD   fNeedImage;
} IMGHLP_DEBUG_DATA, *PIMGHLP_DEBUG_DATA;

typedef struct {
    DWORD rvaBeginAddress;
    DWORD rvaEndAddress;
    DWORD rvaPrologEndAddress;
    DWORD rvaExceptionHandler;
    DWORD rvaHandlerData;
} IMGHLP_RVA_FUNCTION_DATA;

#ifndef _WIN64

typedef struct {
    PIMGHLP_DEBUG_DATA pIDD;
} PIDI_HEADER, *PPIDI_HEADER;

typedef struct {
    PIDI_HEADER             hdr;
    IMAGE_DEBUG_INFORMATION idi;
} PIDI, *PPIDI;

#endif

PIMGHLP_DEBUG_DATA
ImgHlpFindDebugInfo(
    HANDLE  hProcess,
    HANDLE  FileHandle,
    LPSTR   FileName,
    LPSTR   SymbolPath,
    ULONG64 ImageBase,
    ULONG   dwFlag
    );

BOOL
CopyPdb(
    CHAR const * SrcPdb,
    CHAR const * DestPdb,
    BOOL StripPrivate
    );

BOOL
IMAGEAPI
RemovePrivateCvSymbolic(
    PCHAR   DebugData,
    PCHAR * NewDebugData,
    ULONG * NewDebugSize
    );

BOOL
IMAGEAPI
RemovePrivateCvSymbolicEx(
    PCHAR   DebugData,
    ULONG   DebugSize,
    PCHAR * NewDebugData,
    ULONG * NewDebugSize
    );


#define NO_PE64_IMAGES  0x01000

#define IMGHLP_FREE_ALL     0xffffffff
#define IMGHLP_FREE_FPO     0x00000001
#define IMGHLP_FREE_PDATA   0x00000002
#define IMGHLP_FREE_OMAPT   0x00000004
#define IMGHLP_FREE_OMAPF   0x00000008
#define IMGHLP_FREE_PDB     0x00000010
#define IMGHLP_FREE_SYMPATH 0x00000020
#define IMGHLP_FREE_OSECT   0x00000040
#define IMGHLP_FREE_CSECT   0x00000080

void
ImgHlpReleaseDebugInfo(
    PIMGHLP_DEBUG_DATA,
    DWORD
    );

ULONG
ReadImageData(
    IN  HANDLE  hprocess,
    IN  ULONG64 ul,
    IN  ULONG64 addr,
    OUT LPVOID  buffer,
    IN  ULONG   size
    );

#if DBG

VOID 
dbPrint(
    LPCSTR fmt, 
    ... 
    );

#else

 #define dbPrint

#endif

__inline
BOOL
IsPE64(PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER) OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC ? TRUE : FALSE;
}

__inline
UCHAR *
OHMajorLinkerVersion(PVOID OptHeader)
{
    return &(((PIMAGE_OPTIONAL_HEADER) OptHeader)->MajorLinkerVersion);
}

__inline
UCHAR *
OHMinorLinkerVersion(PVOID OptHeader)
{
    return &(((PIMAGE_OPTIONAL_HEADER) OptHeader)->MinorLinkerVersion);
}

__inline
ULONG  *
OHSizeOfCode (PVOID OptHeader)
{
    return &(((PIMAGE_OPTIONAL_HEADER) OptHeader)->SizeOfCode);
}

__inline
ULONG  *
OHSizeOfInitializedData (PVOID OptHeader)
{
    return &(((PIMAGE_OPTIONAL_HEADER) OptHeader)->SizeOfInitializedData);
}

__inline
ULONG  *
OHSizeOfUninitializedData (PVOID OptHeader)
{
    return &(((PIMAGE_OPTIONAL_HEADER) OptHeader)->SizeOfUninitializedData);
}

__inline
ULONG  *
OHAddressOfEntryPoint (PVOID OptHeader)
{
    return &(((PIMAGE_OPTIONAL_HEADER) OptHeader)->AddressOfEntryPoint);
}

__inline
ULONG  *
OHBaseOfCode (PVOID OptHeader)
{
    return &(((PIMAGE_OPTIONAL_HEADER) OptHeader)->BaseOfCode);
}

__inline
ULONG  *
OHImageBase (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->ImageBase) :
                 (ULONG *)&(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->ImageBase);
}

__inline
ULONG  *
OHSectionAlignment (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->SectionAlignment) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->SectionAlignment);
}

__inline
ULONG  *
OHFileAlignment (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->FileAlignment) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->FileAlignment);
}

__inline
USHORT *
OHMajorOperatingSystemVersion (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->MajorOperatingSystemVersion) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->MajorOperatingSystemVersion);
}

__inline
USHORT *
OHMinorOperatingSystemVersion (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->MinorOperatingSystemVersion) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->MinorOperatingSystemVersion);
}

__inline
USHORT *
OHMajorImageVersion (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->MajorImageVersion) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->MajorImageVersion);
}

__inline
USHORT *
OHMinorImageVersion (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->MinorImageVersion) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->MinorImageVersion);
}

__inline
USHORT *
OHMajorSubsystemVersion (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->MajorSubsystemVersion) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->MajorSubsystemVersion);
}

__inline
USHORT *
OHMinorSubsystemVersion (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->MinorSubsystemVersion) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->MinorSubsystemVersion);
}

__inline
ULONG  *
OHWin32VersionValue (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->Win32VersionValue) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->Win32VersionValue);
}

__inline
ULONG  *
OHSizeOfImage (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->SizeOfImage) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->SizeOfImage);
}

__inline
ULONG  *
OHSizeOfHeaders (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->SizeOfHeaders) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->SizeOfHeaders);
}

__inline
ULONG  *
OHCheckSum (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->CheckSum) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->CheckSum);
}

__inline
USHORT *
OHSubsystem (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->Subsystem) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->Subsystem);
}

__inline
USHORT *
OHDllCharacteristics (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->DllCharacteristics) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->DllCharacteristics);
}

__inline
ULONG  *
OHSizeOfStackReserve (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->SizeOfStackReserve) :
                 (ULONG *)&(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->SizeOfStackReserve);
}

__inline
ULONG  *
OHSizeOfStackCommit (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->SizeOfStackCommit) :
                 (ULONG *)&(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->SizeOfStackCommit);
}

__inline
ULONG  *
OHSizeOfHeapReserve (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->SizeOfHeapReserve) :
                 (ULONG *)&(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->SizeOfHeapReserve);
}

__inline
ULONG  *
OHSizeOfHeapCommit (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->SizeOfHeapCommit) :
                 (ULONG *)&(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->SizeOfHeapCommit);
}

__inline
ULONG  *
OHLoaderFlags (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->LoaderFlags) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->LoaderFlags);
}

__inline
ULONG  *
OHNumberOfRvaAndSizes (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->NumberOfRvaAndSizes) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->NumberOfRvaAndSizes);
}

__inline
IMAGE_DATA_DIRECTORY *
OHDataDirectory (PVOID OptHeader)
{
    return ((PIMAGE_OPTIONAL_HEADER)OptHeader)->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ?
                 &(((PIMAGE_OPTIONAL_HEADER32) OptHeader)->DataDirectory[0]) :
                 &(((PIMAGE_OPTIONAL_HEADER64) OptHeader)->DataDirectory[0]);
}

PVOID
MapItRO(
      HANDLE FileHandle
      );

HANDLE
IMAGEAPI
fnFindDebugInfoFileEx(
    IN  LPSTR FileName,
    IN  LPSTR SymbolPath,
    OUT LPSTR DebugFilePath,
    IN  PFIND_DEBUG_FILE_CALLBACK Callback,
    IN  PVOID CallerData,
    IN  DWORD flag
    );

BOOL
GetSymbolFileFromServer(
    IN  LPCSTR ServerInfo, 
    IN  LPCSTR FileName, 
    IN  DWORD  ts,
    IN  DWORD  sig,
    IN  DWORD  age,
    OUT LPSTR FilePath
    );

void
CloseSymbolServer(
    VOID
    );

#define fdifRECURSIVE   0x1

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\map.c ===
/*++

Copyright (c) 1994-96  Microsoft Corporation

Module Name:

    map.c

Abstract:
    Implementation for the MapAndLoad API

Author:

Revision History:

--*/

#include <private.h>


BOOL
MapAndLoad(
    LPSTR ImageName,
    LPSTR DllPath,
    PLOADED_IMAGE LoadedImage,
    BOOL DotDll,
    BOOL ReadOnly
    )
{
    HANDLE hFile;
    HANDLE hMappedFile;
    CHAR SearchBuffer[MAX_PATH];
    DWORD dw;
    LPSTR FilePart;
    LPSTR OpenName;

    // open and map the file.
    // then fill in the loaded image descriptor

    LoadedImage->hFile = INVALID_HANDLE_VALUE;

    OpenName = ImageName;
    dw = 0;
retry:
    hFile = CreateFile(
                OpenName,
                ReadOnly ? GENERIC_READ : GENERIC_READ | GENERIC_WRITE,
                OSVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT ? (FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE) : (FILE_SHARE_READ | FILE_SHARE_WRITE),
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );


    if ( hFile == INVALID_HANDLE_VALUE ) {
        if ( !dw ) {
            //
            // open failed try to find the file on the search path
            //

            dw =   SearchPath(
                    DllPath,
                    ImageName,
                    DotDll ? ".dll" : ".exe",
                    MAX_PATH,
                    SearchBuffer,
                    &FilePart
                    );
            if ( dw && dw < MAX_PATH ) {
                OpenName = SearchBuffer;
                goto retry;
            }
        }
        return FALSE;
    }

    if (MapIt(hFile, LoadedImage, ReadOnly) == FALSE) {
        CloseHandle(hFile);
        return FALSE;
    } else {
        LoadedImage->ModuleName = (LPSTR) MemAlloc( strlen(OpenName)+16 );
        strcpy( LoadedImage->ModuleName, OpenName );

        // If readonly, no need to keep the file open..

        if (ReadOnly) {
            CloseHandle(hFile);
        }

        return TRUE;
    }
}


BOOL
MapIt(
    HANDLE hFile,
    PLOADED_IMAGE LoadedImage,
    BOOL   ReadOnly
    )
{
    HANDLE hMappedFile;

    hMappedFile = CreateFileMapping(
                    hFile,
                    NULL,
                    ReadOnly ? PAGE_READONLY : PAGE_READWRITE,
                    0,
                    0,
                    NULL
                    );
    if ( !hMappedFile ) {
        return FALSE;
    }

    LoadedImage->MappedAddress = (PUCHAR) MapViewOfFile(
                                    hMappedFile,
                                    ReadOnly ? FILE_MAP_READ : FILE_MAP_WRITE,
                                    0,
                                    0,
                                    0
                                    );

    CloseHandle(hMappedFile);

    LoadedImage->SizeOfImage = GetFileSize(hFile, NULL);

    if (!LoadedImage->MappedAddress ||
        !CalculateImagePtrs(LoadedImage)) {
        return(FALSE);
    }

    if (ReadOnly) {
        LoadedImage->hFile = INVALID_HANDLE_VALUE;
    } else {
        LoadedImage->hFile = hFile;
    }

    return(TRUE);
}


BOOL
CalculateImagePtrs(
    PLOADED_IMAGE LoadedImage
    )
{
    PIMAGE_DOS_HEADER DosHeader;
    PIMAGE_NT_HEADERS NtHeaders;
    PIMAGE_FILE_HEADER FileHeader;
    BOOL fRC;

    // Everything is mapped. Now check the image and find nt image headers

    fRC = TRUE;  // Assume the best

    __try {
        DosHeader = (PIMAGE_DOS_HEADER)LoadedImage->MappedAddress;

        if ((DosHeader->e_magic != IMAGE_DOS_SIGNATURE) &&
            (DosHeader->e_magic != IMAGE_NT_SIGNATURE)) {
            fRC = FALSE;
            goto tryout;
        }

        if (DosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
            if (DosHeader->e_lfanew == 0) {
                LoadedImage->fDOSImage = TRUE;
                fRC = FALSE;
                goto tryout;
            }
            LoadedImage->FileHeader = (PVOID)((ULONG_PTR)DosHeader + DosHeader->e_lfanew);

            if (
                // If IMAGE_NT_HEADERS would extend past the end of file...
                (PBYTE)LoadedImage->FileHeader + sizeof(IMAGE_NT_HEADERS) >
                    (PBYTE)LoadedImage->MappedAddress + LoadedImage->SizeOfImage ||

                 // ..or if it would begin in, or before the IMAGE_DOS_HEADER...
                     (PBYTE)LoadedImage->FileHeader <
                      (PBYTE)LoadedImage->MappedAddress + sizeof(IMAGE_DOS_HEADER)  )
            {
                // ...then e_lfanew is not as expected.
                // (Several Win95 files are in this category.)
                fRC = FALSE;
                goto tryout;
            }
        } else {

            // No DOS header indicates an image built w/o a dos stub

            LoadedImage->FileHeader = (PVOID)((ULONG_PTR)DosHeader);
        }

        NtHeaders = LoadedImage->FileHeader;

        if ( NtHeaders->Signature != IMAGE_NT_SIGNATURE ) {
            if ( (USHORT)NtHeaders->Signature == (USHORT)IMAGE_OS2_SIGNATURE ||
                 (USHORT)NtHeaders->Signature == (USHORT)IMAGE_OS2_SIGNATURE_LE
               ) {
                LoadedImage->fDOSImage = TRUE;
            }

            fRC = FALSE;
            goto tryout;
        } else {
            LoadedImage->fDOSImage = FALSE;
        }

        FileHeader = &NtHeaders->FileHeader;

        // No optional header indicates an object...

        if ( FileHeader->SizeOfOptionalHeader == 0 ) {
            fRC = FALSE;
            goto tryout;
        }

        if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            // 32-bit image.  Do some tests.
            if (((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.ImageBase >= 0x80000000) {
                LoadedImage->fSystemImage = TRUE;
            } else {
                LoadedImage->fSystemImage = FALSE;
            }

            if (((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.MajorLinkerVersion < 3 &&
                ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.MinorLinkerVersion < 5)
            {
                fRC = FALSE;
                goto tryout;
            }

        } else {
            LoadedImage->fSystemImage = FALSE;
        }

        LoadedImage->Sections = IMAGE_FIRST_SECTION(NtHeaders);

        InitializeListHead( &LoadedImage->Links );
        LoadedImage->Characteristics = FileHeader->Characteristics;
        LoadedImage->NumberOfSections = FileHeader->NumberOfSections;
        LoadedImage->LastRvaSection = LoadedImage->Sections;

tryout:
        if (fRC == FALSE) {
            UnmapViewOfFile(LoadedImage->MappedAddress);
        }

    } __except ( EXCEPTION_EXECUTE_HANDLER ) {
        fRC = FALSE;
    }

    return fRC;
}

BOOL
UnMapAndLoad(
    PLOADED_IMAGE pLi
    )
{
    UnMapIt(pLi);

    if (pLi->hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(pLi->hFile);
    }

    return TRUE;
}

BOOL
GrowMap (
    PLOADED_IMAGE   pLi,
    LONG            lSizeOfDelta
    )
{
    if (pLi->hFile == INVALID_HANDLE_VALUE) {
        // Can't grow read/only files.
        return FALSE;
    } else {
        HANDLE hMappedFile;
        FlushViewOfFile(pLi->MappedAddress, pLi->SizeOfImage);
        UnmapViewOfFile(pLi->MappedAddress);

        pLi->SizeOfImage += lSizeOfDelta;

        SetFilePointer(pLi->hFile, pLi->SizeOfImage, NULL, FILE_BEGIN);
        SetEndOfFile(pLi->hFile);

        hMappedFile = CreateFileMapping(
                        pLi->hFile,
                        NULL,
                        PAGE_READWRITE,
                        0,
                        pLi->SizeOfImage,
                        NULL
                        );
        if ( !hMappedFile ) {
            return FALSE;
        }

        pLi->MappedAddress = (PUCHAR) MapViewOfFile(
                                        hMappedFile,
                                        FILE_MAP_WRITE,
                                        0,
                                        0,
                                        0
                                        );

        CloseHandle(hMappedFile);

        if (!pLi->MappedAddress) {
            return(FALSE);
        }

        // Win95 doesn't zero fill when it extends.  Do it here.
        if (lSizeOfDelta > 0) {
            memset(pLi->MappedAddress + pLi->SizeOfImage - lSizeOfDelta, 0, lSizeOfDelta);
        }

        // Recalc the LoadedImage struct (remapping may have changed the map address)
        if (!CalculateImagePtrs(pLi)) {
            return(FALSE);
        }

        return TRUE;
    }
}


VOID
UnMapIt(
    PLOADED_IMAGE pLi
    )
{
    DWORD HeaderSum, CheckSum;
    BOOL bl;
    DWORD dw;
    PIMAGE_NT_HEADERS NtHeaders;

    // Test for read-only
    if (pLi->hFile == INVALID_HANDLE_VALUE) {
        UnmapViewOfFile(pLi->MappedAddress);
    } else {
        CheckSumMappedFile( pLi->MappedAddress,
                            pLi->SizeOfImage,
                            &HeaderSum,
                            &CheckSum
                          );

        NtHeaders = pLi->FileHeader;

        if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.CheckSum = CheckSum;
        } else {
            if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
                ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.CheckSum = CheckSum;
            }
        }

        FlushViewOfFile(pLi->MappedAddress, pLi->SizeOfImage);
        UnmapViewOfFile(pLi->MappedAddress);

        if (pLi->SizeOfImage != GetFileSize(pLi->hFile, NULL)) {
            dw = SetFilePointer(pLi->hFile, pLi->SizeOfImage, NULL, FILE_BEGIN);
            dw = GetLastError();
            bl = SetEndOfFile(pLi->hFile);
            dw = GetLastError();
        }
    }
}


BOOL
GetImageConfigInformation(
    PLOADED_IMAGE LoadedImage,
    PIMAGE_LOAD_CONFIG_DIRECTORY ImageConfigInformation
    )
{
    PIMAGE_LOAD_CONFIG_DIRECTORY ImageConfigData;
    ULONG i;

    ImageConfigData = (PIMAGE_LOAD_CONFIG_DIRECTORY) ImageDirectoryEntryToData( LoadedImage->MappedAddress,
                                                 FALSE,
                                                 IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG,
                                                 &i
                                               );
    if (ImageConfigData != NULL && i == sizeof( *ImageConfigData )) {
        memcpy( ImageConfigInformation, ImageConfigData, sizeof( *ImageConfigData ) );
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
SetImageConfigInformation(
    PLOADED_IMAGE LoadedImage,
    PIMAGE_LOAD_CONFIG_DIRECTORY ImageConfigInformation
    )
{
    PIMAGE_LOAD_CONFIG_DIRECTORY ImageConfigData;
    ULONG i;
    ULONG DirectoryAddress;
    PIMAGE_NT_HEADERS NtHeaders;
    PIMAGE_DATA_DIRECTORY pLoadCfgDataDir;

    if (LoadedImage->hFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    ImageConfigData = (PIMAGE_LOAD_CONFIG_DIRECTORY) ImageDirectoryEntryToData( LoadedImage->MappedAddress,
                                                 FALSE,
                                                 IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG,
                                                 &i
                                               );
    if (ImageConfigData != NULL && i == sizeof( *ImageConfigData )) {
        memcpy( ImageConfigData, ImageConfigInformation, sizeof( *ImageConfigData ) );
        return TRUE;
    }

    DirectoryAddress = GetImageUnusedHeaderBytes( LoadedImage, &i );
    if (i < sizeof(*ImageConfigData)) {
        return FALSE;
    }

    NtHeaders = LoadedImage->FileHeader;

    if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
        pLoadCfgDataDir = &((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG];
    } else {
        pLoadCfgDataDir = &((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG];
    }
    pLoadCfgDataDir->VirtualAddress = DirectoryAddress;
    pLoadCfgDataDir->Size = sizeof(*ImageConfigData);
    ImageConfigData = (PIMAGE_LOAD_CONFIG_DIRECTORY) ((PCHAR)LoadedImage->MappedAddress + DirectoryAddress);
    memcpy( ImageConfigData, ImageConfigInformation, sizeof( *ImageConfigData ) );
    return TRUE;
}


BOOLEAN ImageLoadInit;
LIST_ENTRY ImageLoadList;

PLOADED_IMAGE
ImageLoad(
    LPSTR DllName,
    LPSTR DllPath
    )
{
    PLIST_ENTRY Head,Next;
    PLOADED_IMAGE LoadedImage;
    CHAR Drive[_MAX_DRIVE];
    CHAR Dir[_MAX_DIR];
    CHAR Filename[_MAX_FNAME];
    CHAR Ext[_MAX_EXT];
    CHAR LoadedModuleName[_MAX_PATH];
    BOOL fFileNameOnly;

    if (!ImageLoadInit) {
        InitializeListHead( &ImageLoadList );
        ImageLoadInit = TRUE;
    }

    Head = &ImageLoadList;
    Next = Head->Flink;

    _splitpath(DllName, Drive, Dir, Filename, Ext);
    if (!strlen(Drive) && !strlen(Dir)) {
        // The user only specified a filename (no drive/path).
        fFileNameOnly = TRUE;
    } else {
        fFileNameOnly = FALSE;
    }

    while (Next != Head) {
        LoadedImage = CONTAINING_RECORD( Next, LOADED_IMAGE, Links );
        if (fFileNameOnly) {
            _splitpath(LoadedImage->ModuleName, NULL, NULL, Filename, Ext);
            strcpy(LoadedModuleName, Filename);
            strcat(LoadedModuleName, Ext);
        } else {
            strcpy(LoadedModuleName, LoadedImage->ModuleName);
        }

        if (!_stricmp( DllName, LoadedModuleName )) {
            return LoadedImage;
        }

        Next = Next->Flink;
    }

    LoadedImage = (PLOADED_IMAGE) MemAlloc( sizeof( *LoadedImage ) + strlen( DllName ) + 1 );
    if (LoadedImage != NULL) {
        LoadedImage->ModuleName = (LPSTR)(LoadedImage + 1);
        strcpy( LoadedImage->ModuleName, DllName );
        if (MapAndLoad( DllName, DllPath, LoadedImage, TRUE, TRUE )) {
            InsertTailList( &ImageLoadList, &LoadedImage->Links );
            return LoadedImage;
        }

        MemFree( LoadedImage );
        LoadedImage = NULL;
    }

    return LoadedImage;
}

BOOL
ImageUnload(
    PLOADED_IMAGE LoadedImage
    )
{
    if (!IsListEmpty( &LoadedImage->Links )) {
        RemoveEntryList( &LoadedImage->Links );
    }

    UnMapAndLoad( LoadedImage );
    MemFree( LoadedImage );

    return TRUE;
}

BOOL
UnloadAllImages()
{
    PLIST_ENTRY Head,Next;
    PLOADED_IMAGE LoadedImage;

    if (!ImageLoadInit) {
        return(TRUE);
    }

    Head = &ImageLoadList;
    Next = Head->Flink;

    while (Next != Head) {
        LoadedImage = CONTAINING_RECORD( Next, LOADED_IMAGE, Links );
        Next = Next->Flink;
        ImageUnload(LoadedImage);
    }

    ImageLoadInit = FALSE;
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\mapdebug.c ===
#include <private.h>
#include <symbols.h>

#ifdef MAP_DEBUG_TEST
#undef MemAlloc
#undef MemFree

PVOID
MemAlloc(ULONG_PTR AllocSize)
{
    return LocalAlloc(LPTR, AllocSize);
}

VOID
MemFree(PVOID MemPtr)
{
    LocalFree(MemPtr);
}

#endif

// these are used only by ...
//  GetSymbolFileFromServer()
//  CloseSymbolServer()

HINSTANCE              ghSrv = 0;
CHAR                   gszSrvName[_MAX_PATH * 2];
LPSTR                  gszSrvParams = NULL; 
PSYMBOLSERVERPROC      gfnSymbolServer = NULL;
PSYMBOLSERVERCLOSEPROC gfnSymbolServerClose = NULL;

BOOL
ProcessImageDebugInfo(
    PIMGHLP_DEBUG_DATA pIDD
    );


BOOL
IsImageMachineType64(
    DWORD MachineType
    )
{
   switch(MachineType) {
   case IMAGE_FILE_MACHINE_AXP64:
   case IMAGE_FILE_MACHINE_IA64:
       return TRUE;
   default:
       return FALSE;
   }
} 

ULONG
ReadImageData(
    IN  HANDLE  hprocess,
    IN  ULONG64 ul,
    IN  ULONG64 addr,
    OUT LPVOID  buffer,
    IN  ULONG   size
    )
{
    ULONG bytesread;

    if (hprocess) {

        ULONG64 base = ul;

        BOOL rc;

        rc = ReadInProcMemory(hprocess, 
                              base + addr, 
                              buffer, 
                              size, 
                              &bytesread);
        
        if (!rc || (bytesread < (ULONG)size)) 
            return 0;
    
    } else {

        PCHAR p = (PCHAR)ul + addr;

        memcpy(buffer, p, size);
    } 

    return size;
}

PVOID
MapItRO(
      HANDLE FileHandle
      )
{
    PVOID MappedBase = NULL;

    if (FileHandle) {

        HANDLE MappingHandle = CreateFileMapping( FileHandle, NULL, PAGE_READONLY, 0, 0, NULL );
        if (MappingHandle) {
            MappedBase = MapViewOfFile( MappingHandle, FILE_MAP_READ, 0, 0, 0 );
            CloseHandle(MappingHandle);
        }
    }

    return MappedBase;
}


void
CloseSymbolServer(
    VOID
    )
{
    if (!ghSrv) 
        return;

    if (gfnSymbolServerClose)
        gfnSymbolServerClose();

    FreeLibrary(ghSrv);

    ghSrv = 0;
    *gszSrvName = 0;
    gszSrvParams = NULL;
    gfnSymbolServer = NULL;
    gfnSymbolServerClose = NULL;
}


BOOL
GetSymbolFileFromServer(
    IN  LPCSTR ServerInfo, 
    IN  LPCSTR FileName, 
    IN  DWORD  num1,
    IN  DWORD  num2,
    IN  DWORD  num3,
    OUT LPSTR FilePath
    )
{
    BOOL rc;
    CHAR *params;
    
    // initialize server, if needed

    if (!ghSrv) {
        ghSrv = INVALID_HANDLE_VALUE;
        strcpy(gszSrvName, &ServerInfo[7]);
        if (!*gszSrvName) 
            return FALSE;
        // BUGBUG: gszSrvParams is no longer needed because it is 
        // now implemented in the local variable, 'params'
        // Still, we need to zero out this location to get gszSrvName.
        gszSrvParams = strchr(gszSrvName, '*');
        if (!gszSrvParams ) 
            return FALSE;
        *gszSrvParams++ = '\0';
        ghSrv = LoadLibrary(gszSrvName);
        if (ghSrv) {
            gfnSymbolServer = (PSYMBOLSERVERPROC)GetProcAddress(ghSrv, "SymbolServer");
            if (!gfnSymbolServer) {
                FreeLibrary(ghSrv);
                ghSrv = INVALID_HANDLE_VALUE;
            }
            gfnSymbolServerClose = (PSYMBOLSERVERCLOSEPROC)GetProcAddress(ghSrv, "SymbolServerClose");
        } else {
            ghSrv = INVALID_HANDLE_VALUE;
        }
    }

    // bail, if we have no valid server

    if (ghSrv == INVALID_HANDLE_VALUE) {
        DPRINTF(NULL, "SymSrv load failure: %s\n", gszSrvName);
        return FALSE;
    }

    params = strchr(ServerInfo, '*');
    if (!params)
        return FALSE;
    params = strchr(params+1, '*');
    if (!params)
        return FALSE;
    rc = gfnSymbolServer(params+1, FileName, num1, num2, num3, FilePath);

    if (!*FilePath) {
        DPRINTF(NULL, 
                "SymSrv: %s not in %s, (0x%x 0x%x 0x%x)\n",
                FileName,
                params,
                num1,
                num2,
                num3);
    }

    return rc;
}


__inline
EC
SetPDBError(
    EC ccode,
    EC ncode
    )
{
    if (ncode == EC_OK)
        return ncode;

    if (ccode != EC_NOT_FOUND)
        return ccode;

    return ncode;
}

PDB *
LocatePdb(
    char *szPDB,
    ULONG PdbAge,
    ULONG PdbSignature,
    char *SymbolPath,
    char *szImageExt,
    BOOL  fImagePathPassed
    )
{
    PDB  *pdb = NULL;
    EC    ec;
    char  szError[cbErrMax] = "";
    char  szPDBSansPath[_MAX_FNAME];
    char  szPDBExt[_MAX_EXT];
    char  szPDBLocal[_MAX_PATH];
    char  szDbgPath[PDB_MAX_PATH];
    char *SemiColon;
    DWORD pass;
    EC    ecode = EC_NOT_FOUND;
    BOOL  symsrv = TRUE;
    char  szPDBName[_MAX_PATH];

    // SymbolPath is a semicolon delimited path (reference path first)

    strcpy (szPDBLocal, szPDB);
    _splitpath(szPDBLocal, NULL, NULL, szPDBSansPath, szPDBExt);

    do {
        SemiColon = strchr(SymbolPath, ';');

        if (SemiColon) {
            *SemiColon = '\0';
        }
 
        if (fImagePathPassed) {
            pass = 2;
            fImagePathPassed = 0;;
        } else {
            pass = 0;
        }
 
        if (SymbolPath) {
do_again:
            if (!_strnicmp(SymbolPath, "SYMSRV*", 7)) {
                
                *szPDBLocal = 0;
                sprintf(szPDBName, "%s%s", szPDBSansPath, ".pdb");
                if (symsrv) {
                    GetSymbolFileFromServer(SymbolPath, 
                                            szPDBName, 
                                            PdbSignature,
                                            PdbAge,
                                            0,
                                            szPDBLocal);
                    symsrv = FALSE;
                }
            
            } else {
            
                strcpy(szPDBLocal, SymbolPath);
                EnsureTrailingBackslash(szPDBLocal);
                
                // search order is ...
                //
                //   %dir%\symbols\%ext%\%file%
                //   %dir%\%ext%\%file%
                //   %dir%\%file%
                
                switch (pass)
                {
                case 0:
                    strcat(szPDBLocal, "symbols");
                    EnsureTrailingBackslash(szPDBLocal);
                    // pass through
                case 1:
                    strcat(szPDBLocal, szImageExt);
                    // pass through
                default:
                    EnsureTrailingBackslash(szPDBLocal);
                    break;
                }
    
                strcat(szPDBLocal, szPDBSansPath);
                strcat(szPDBLocal, szPDBExt);
            }

            if (*szPDBLocal) {

                DPRINTF(NULL, "LocatePDB-> Looking for %s... ", szPDBLocal);
                PDBOpenValidate(szPDBLocal, NULL, "r", PdbSignature, PdbAge, &ec, szError, &pdb);
                ecode = SetPDBError(ecode, ec);
                if (pdb) {
                    assert(ec == EC_OK);
                    break;
                } else {
                    if (ec == EC_INVALID_SIG || ec == EC_INVALID_AGE) {
                        EPRINTF(NULL, "unmatched pdb ");
                        if (PdbSignature == 0 && PdbAge == 0) {
                            if (PDBOpen(szError, "r", 0, &ec, szError, &pdb)) {
                                break;
                            }
                        }
                        EPRINTF(NULL, "\n");
                    } else if (ec == EC_NOT_FOUND) {
                        EPRINTF(NULL, "file not found\n");
                    } else {
                        EPRINTF(NULL, "pdb error 0x%x\n", ec);
                    }
                    
                    if (pass < 2) {
                        pass++;
                        goto do_again;
                    }
                }
            }
        }

        if (SemiColon) {
            *SemiColon = ';';
             SemiColon++;
             symsrv = TRUE;
        }

        SymbolPath = SemiColon;
    } while (SemiColon);

    if (!pdb) {
        strcpy(szPDBLocal, szPDB);
        DPRINTF(NULL, "LocatePDB-> Looking for %s... ", szPDBLocal);
        PDBOpenValidate(szPDBLocal, NULL, "r", PdbSignature, PdbAge, &ec, szError, &pdb);
        if (!pdb) {
            if (ec == EC_INVALID_SIG || ec == EC_INVALID_AGE) {
                EPRINTF(NULL, "unmatched pdb ");
                if (PdbSignature == 0 && PdbAge == 0) {
                    PDBOpen(szError, "r", 0, &ec, szError, &pdb);                    
                }
                if (!pdb)
                    EPRINTF(NULL, "\n");
            } else if (ec == EC_NOT_FOUND) {
                EPRINTF(NULL, "file not found\n");
            } else {
                EPRINTF(NULL, "pdb error 0x%x\n", ec);
            }
        }                                                                     
    }

    if (pdb) {
        EPRINTF(NULL, "OK\n");
        // Store the name of the PDB we actually opened for later reference.
        strcpy(szPDB, szPDBLocal);
        SetLastError(NO_ERROR);
    }


    return pdb;
}


BOOL
ProcessOldStyleCodeView(
    PIMGHLP_DEBUG_DATA pIDD
    )
{
    OMFSignature    *omfSig;
    OMFDirHeader    *omfDirHdr;
    OMFDirEntry     *omfDirEntry;
    OMFSegMap       *omfSegMap;
    OMFSegMapDesc   *omfSegMapDesc;
    DWORD            i, j, k, SectionSize;
    DWORD            SectionStart;
    PIMAGE_SECTION_HEADER   Section;

    if (pIDD->cOmapFrom) {
        // If there's omap, we need to generate the original section map

        omfSig = (OMFSignature *)pIDD->pMappedCv;
        omfDirHdr = (OMFDirHeader*) ((PCHAR)pIDD->pMappedCv + (DWORD)omfSig->filepos);
        omfDirEntry = (OMFDirEntry*) ((PCHAR)omfDirHdr + sizeof(OMFDirHeader));

        for (i=0; i<omfDirHdr->cDir; i++,omfDirEntry++) {
            if (omfDirEntry->SubSection == sstSegMap) {

                omfSegMap = (OMFSegMap*) ((PCHAR)pIDD->pMappedCv + omfDirEntry->lfo);

                omfSegMapDesc = (OMFSegMapDesc*)&omfSegMap->rgDesc[0];

                SectionStart = *(DWORD *)pIDD->pOmapFrom;

                Section = (PIMAGE_SECTION_HEADER) MemAlloc(omfSegMap->cSeg * sizeof(IMAGE_SECTION_HEADER));

                if (Section) {
                    for (j=0, k=0; j < omfSegMap->cSeg; j++) {
                        if (omfSegMapDesc[j].frame) {
                            // The linker sets the frame field to the actual section header number.  Zero is
                            // used to track absolute symbols that don't exist in a real sections.

                            Section[k].Misc.VirtualSize =
                                SectionSize = omfSegMapDesc[j].cbSeg;
                            Section[k].VirtualAddress =
                                SectionStart =
                                    SectionStart + ((SectionSize + (pIDD->ImageAlign-1)) & ~(pIDD->ImageAlign-1));
                            k++;
                        }
                    }

                    pIDD->pOriginalSections = Section;
                    pIDD->cOriginalSections = k;
                }
            }
        }
    }

    return TRUE;
}

BOOL
ProcessPdbDebugInfo(
    PIMGHLP_DEBUG_DATA pIDD
    )
{
    PDB    *pPdb;
    Dbg    *pDbg;
    DBI    *pDbi;
    GSI    *pGsi;
    int     DebugCount;
    void   *DebugData;
    PCHAR   szLocalSymbolPath = NULL;
    DWORD   cpathlen = 0;
    CHAR    szExt[_MAX_EXT] = {0};
    BOOL    fImagePathPassed = FALSE;

    if (pIDD->SymbolPath) 
        cpathlen = strlen(pIDD->SymbolPath);
    szLocalSymbolPath = MemAlloc(cpathlen + strlen(pIDD->PdbReferencePath) + 2);
    if (!szLocalSymbolPath) {
        return FALSE;
    }

    strcpy(szLocalSymbolPath, pIDD->PdbReferencePath);
    if (*szLocalSymbolPath) {            
        if (pIDD->SymbolPath)                             
            strcat(szLocalSymbolPath, ";");
        fImagePathPassed = TRUE;
    }
    if (pIDD->SymbolPath)                           
        strcat(szLocalSymbolPath, pIDD->SymbolPath);
    
    if (*pIDD->ImageFilePath) {
        _splitpath(pIDD->ImageFilePath, NULL, NULL, NULL, szExt);
    } else if (*pIDD->ImageName) {
        _splitpath(pIDD->ImageName, NULL, NULL, NULL, szExt);
    }

    // if we have no valid filename, then this must be an executable

    if (!*szExt)
        strcpy(szExt, ".exe");
        
    // go ahead and get it
    
    pPdb = LocatePdb(pIDD->PdbFileName, pIDD->PdbAge, pIDD->PdbSignature, szLocalSymbolPath, &szExt[1], fImagePathPassed);
    MemFree(szLocalSymbolPath);
    if (!pPdb) {
        return FALSE;
    }

    if (!PDBOpenDBI( pPdb, "r", "", &pDbi )) {
        PDBClose( pPdb );
        return FALSE;
    }

    if (!DBIOpenPublics( pDbi, &pGsi)) {
        DBIClose( pDbi );
        PDBClose( pPdb );
        return FALSE;
    }

    // Read in the omap.

    if (DBIOpenDbg(pDbi, dbgtypeOmapFromSrc, &pDbg)) {
        DebugCount = DbgQuerySize(pDbg);
        if (DebugCount) {
            DebugData = MemAlloc( DebugCount * sizeof(OMAP) );

            if (DbgQueryNext((Dbg *) pDbg, DebugCount, DebugData)) {
                pIDD->cOmapFrom = DebugCount;
                pIDD->pOmapFrom = DebugData;
            }
        }
        DbgClose(pDbg);
    }

    if (DBIOpenDbg(pDbi, dbgtypeOmapToSrc, &pDbg)) {
        DebugCount = DbgQuerySize(pDbg);
        if (DebugCount) {
            DebugData = MemAlloc( DebugCount * sizeof(OMAP) );

            if (DbgQueryNext((Dbg *) pDbg, DebugCount, DebugData)) {
                pIDD->cOmapTo = DebugCount;
                pIDD->pOmapTo = DebugData;
            }
        }

        DbgClose(pDbg);
    }

    // Read in the fpo (if it exists)

    if (DBIOpenDbg(pDbi, dbgtypeFPO, &pDbg)) {
        DebugCount = DbgQuerySize(pDbg);
        if (DebugCount) {
            DebugData = MemAlloc( DebugCount * sizeof(FPO_DATA) );

            if (DbgQueryNext((Dbg *) pDbg, DebugCount, DebugData)) {
                pIDD->cFpo = DebugCount;
                pIDD->pFpo = DebugData;
            }
        }
        DbgClose(pDbg);
    }

    // Read in the Pdata - BUGBUG: Using largest size for now
#if 0
    if (DBIOpenDbg(pDbi, dbgtypeException, &pDbg)) {
        DebugCount = DbgQuerySize(pDbg);
        if (DebugCount) {
            DebugData = MemAlloc( DebugCount * sizeof(IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY) );

            if (DbgQueryNext((Dbg *) pDbg, DebugCount, DebugData)) {
                pIDD->NumberOfPdataFunctionEntries = DebugCount;
                pIDD->pImageFunction = DebugData;
            }
        }
        DbgClose(pDbg);
    }
#endif

    if (!pIDD->pCurrentSections) {
        if (DBIOpenDbg(pDbi, dbgtypeSectionHdr, &pDbg)) {
            DebugCount = DbgQuerySize(pDbg);
            if (DebugCount) {
                DebugData = MemAlloc( DebugCount * sizeof(IMAGE_SECTION_HEADER) );
    
                if (DbgQueryNext((Dbg *) pDbg, DebugCount, DebugData)) {
                    pIDD->cCurrentSections = DebugCount;
                    pIDD->pCurrentSections = DebugData;
                }
            }
            DbgClose(pDbg);
        }
    }

    if (pIDD->cOmapFrom) {
        // If the image has omap, we need the original section headers.
        OMFSegMap *  omfSegMap = NULL;

        // Create the sec map from the CV symbolic.

        if (DBIQuerySecMap(pDbi, NULL, &DebugCount) &&
            (omfSegMap = (OMFSegMap *) MemAlloc (DebugCount)) &&
            DBIQuerySecMap(pDbi, (char *)omfSegMap, &DebugCount))
        {
            OMFSegMapDesc          *omfSegMapDesc = (OMFSegMapDesc*)&omfSegMap->rgDesc[0];
            DWORD                   j = 0, k=0, SectionSize = 0;
            DWORD                   SectionStart = *(DWORD *)pIDD->pOmapFrom;
            PIMAGE_SECTION_HEADER   Section = (PIMAGE_SECTION_HEADER) MemAlloc(omfSegMap->cSeg * sizeof(IMAGE_SECTION_HEADER));

            for (j=0; j < omfSegMap->cSeg; j++) {
                if (omfSegMapDesc[j].frame) {
                    // The linker sets the frame field to the actual section header number.  Zero is
                    // used to track absolute symbols that don't exist in a real sections.

                    Section[k].VirtualAddress =
                        SectionStart =
                            SectionStart + ((SectionSize + (pIDD->ImageAlign-1)) & ~(pIDD->ImageAlign-1));
                    Section[k].Misc.VirtualSize =
                        SectionSize = omfSegMapDesc[j].cbSeg;
                    k++;
                }
            }

            pIDD->pOriginalSections = Section;
            pIDD->cOriginalSections = k;

            MemFree(omfSegMap);
        }
    }

    pIDD->pPdb = pPdb;
    pIDD->pDbi = pDbi;
    pIDD->pGsi = pGsi;
    return TRUE;
}

__inline
DWORD
IsDataInSection (PIMAGE_SECTION_HEADER Section,
                 PIMAGE_DATA_DIRECTORY Data
                 )
{
    DWORD RealDataOffset;
    if ((Data->VirtualAddress >= Section->VirtualAddress) &&
        ((Data->VirtualAddress + Data->Size) <= (Section->VirtualAddress + Section->SizeOfRawData))) {
        RealDataOffset = (DWORD)(Data->VirtualAddress -
                                 Section->VirtualAddress +
                                 Section->PointerToRawData);
    } else {
        RealDataOffset = 0;
    }
    return RealDataOffset;
}

__inline
DWORD
SectionContains (
    HANDLE hp,
    PIMAGE_SECTION_HEADER pSH,
    PIMAGE_DATA_DIRECTORY ddir
    )
{
    DWORD rva = 0;

    if (!ddir->VirtualAddress)
        return 0;

    if (ddir->VirtualAddress >= pSH->VirtualAddress) {
        if ((ddir->VirtualAddress + ddir->Size) <= (pSH->VirtualAddress + pSH->SizeOfRawData)) {
            rva = ddir->VirtualAddress;
            if (!hp) 
                rva = rva - pSH->VirtualAddress + pSH->PointerToRawData;
        }
    }

    return rva;
}

typedef struct NB10I                   // NB10 debug info
{
    DWORD   nb10;                      // NB10
    DWORD   off;                       // offset, always 0
    DWORD   sig;
    DWORD   age;
} NB10I;

void
RetrievePdbInfo(
    PIMGHLP_DEBUG_DATA pIDD,
    CHAR const *szReference
    )
{
    NB10I *pNb10 = (NB10I *)pIDD->pMappedCv;
    CHAR szRefDrive[_MAX_DRIVE];
    CHAR szRefPath[_MAX_DIR];

    if (pIDD->PdbSignature) {
        return;
    }

    if (pNb10->nb10 != '01BN') {
        return;
    }

    pIDD->PdbAge = pNb10->age;
    pIDD->PdbSignature = pNb10->sig;
    strcpy(pIDD->PdbFileName, (PCHAR)pNb10 + sizeof(NB10I));
    _splitpath(szReference, szRefDrive, szRefPath, NULL, NULL);
    _makepath(pIDD->PdbReferencePath, szRefDrive, szRefPath, NULL, NULL);
    if (strlen(szRefPath) > 1) {
        // Chop off trailing backslash.
        pIDD->PdbReferencePath[strlen(pIDD->PdbReferencePath)-1] = '\0';
    } else {
        // No path.  Put on at least a dot "."
        strcpy(pIDD->PdbReferencePath, ".");
    }
    return;
}

BOOL
FakePdbName(
    PIMGHLP_DEBUG_DATA pIDD
    )
{
    CHAR szName[_MAX_FNAME];
    
    if (pIDD->PdbSignature) {
        return FALSE;
    }

    if (!pIDD->ImageName)
        return FALSE;

    _splitpath(pIDD->ImageName, NULL, NULL, szName, NULL);
    if (!*szName)
        return FALSE;

    strcpy(pIDD->PdbFileName, szName);
    strcat(pIDD->PdbFileName, ".pdb");

    return TRUE;
}

BOOL
FindDebugInfoFileExCallback(
    HANDLE FileHandle,
    PSTR FileName,
    PVOID CallerData
    )
{
    PIMGHLP_DEBUG_DATA pIDD;
    PIMAGE_SEPARATE_DEBUG_HEADER DbgHeader;
    PVOID FileMap;
    BOOL  rc;

    rc = TRUE;

    if (!CallerData)
        return TRUE;

    pIDD = (PIMGHLP_DEBUG_DATA)CallerData;

    FileMap = MapItRO(FileHandle);

    if (!FileMap) {
        return FALSE;
    }

    DbgHeader = (PIMAGE_SEPARATE_DEBUG_HEADER)FileMap;

    // Only support .dbg files for X86 and Alpha (32 bit).

    if ((DbgHeader->Signature != IMAGE_SEPARATE_DEBUG_SIGNATURE) ||
        ((DbgHeader->Machine != IMAGE_FILE_MACHINE_I386) &&
         (DbgHeader->Machine != IMAGE_FILE_MACHINE_ALPHA)))
    {
        rc = FALSE;
        goto cleanup;
    }

    // ignore checksums, they are bogus
    rc = (pIDD->TimeDateStamp == DbgHeader->TimeDateStamp) ? TRUE : FALSE;

cleanup:
    if (FileMap)
        UnmapViewOfFile(FileMap);

    return rc;
}

BOOL
ProcessDebugInfo(
    PIMGHLP_DEBUG_DATA pIDD,
    DWORD datasrc
    )
{
    BOOL                         status;
    ULONG                        cb;
    IMAGE_DOS_HEADER             dh;
    IMAGE_NT_HEADERS32           nh32;
    IMAGE_NT_HEADERS64           nh64;
    PIMAGE_ROM_OPTIONAL_HEADER   rom;
    IMAGE_SEPARATE_DEBUG_HEADER  sdh;
    PIMAGE_FILE_HEADER           fh;
    PIMAGE_DEBUG_MISC            md;
    ULONG                        ddva;
    ULONG                        shva;
    ULONG                        nSections;
    PIMAGE_SECTION_HEADER        psh;
    IMAGE_DEBUG_DIRECTORY        dd;
    PIMAGE_DATA_DIRECTORY        datadir;
    PCHAR                        pCV;
    ULONG                        i;
    int                          nDebugDirs = 0;
    HANDLE                       hp;
    ULONG64                      base;

    DWORD                        rva;
    PCHAR                        filepath;
    IMAGE_EXPORT_DIRECTORY       expdir;
    DWORD                        fsize;
    BOOL                         rc;
    USHORT                       filetype;

    // setup pointers for grabing data

    switch (datasrc) {
    case dsInProc:
        hp = pIDD->hProcess;
        base = pIDD->InProcImageBase;
        fsize = 0;
        filepath = pIDD->ImageFilePath;
        break;
    case dsImage:
        hp = NULL;
        // BUGBUG: localize this!
        pIDD->ImageMap = MapItRO(pIDD->ImageFileHandle);
        base = (ULONG64)pIDD->ImageMap;
        fsize = GetFileSize(pIDD->ImageFileHandle, NULL);
        filepath = pIDD->ImageFilePath;
        break;
    case dsDbg:
        hp = NULL;
        // BUGBUG: localize this!
        pIDD->DbgFileMap = MapItRO(pIDD->DbgFileHandle);
        base = (ULONG64)pIDD->DbgFileMap;
        fsize = GetFileSize(pIDD->DbgFileHandle, NULL);
        filepath = pIDD->DbgFilePath;
        break;
    default:
        return FALSE;
    }

    // some initialization
    pIDD->fNeedImage = FALSE;
    rc = FALSE;

    __try {

        // test the file type
    
        status = ReadImageData(hp, base, 0, &filetype, sizeof(filetype));
        if (!status)
            return FALSE;
        if (filetype == IMAGE_DOS_SIGNATURE)
            goto image;
        if (filetype == IMAGE_SEPARATE_DEBUG_SIGNATURE)
            goto dbg;
        return FALSE;
        
dbg:
    
        // grab the dbg header
    
        status = ReadImageData(hp, base, 0, &sdh, sizeof(sdh));
        if (!status)
            return FALSE;
        
        // Only support .dbg files for X86 and Alpha (32 bit).
    
        if ((sdh.Machine != IMAGE_FILE_MACHINE_I386) 
            && (sdh.Machine != IMAGE_FILE_MACHINE_ALPHA))
        {
            UnmapViewOfFile(pIDD->DbgFileMap);
            pIDD->DbgFileMap = 0;
            return FALSE;
        }
    
        pIDD->ImageAlign = sdh.SectionAlignment;
        pIDD->CheckSum = sdh.CheckSum;
        pIDD->Machine = sdh.Machine;
        pIDD->TimeDateStamp = sdh.TimeDateStamp;
        pIDD->Characteristics = sdh.Characteristics;
        if (!pIDD->ImageBaseFromImage) {
            pIDD->ImageBaseFromImage = sdh.ImageBase;
        }
    
        if (!pIDD->SizeOfImage) {
            pIDD->SizeOfImage = sdh.SizeOfImage;
        }
    
        nSections = sdh.NumberOfSections;
        psh = (PIMAGE_SECTION_HEADER) MemAlloc(nSections * sizeof(IMAGE_SECTION_HEADER));
        status = ReadImageData(hp, 
                               base, 
                               sizeof(IMAGE_SEPARATE_DEBUG_HEADER), 
                               psh, 
                               nSections * sizeof(IMAGE_SECTION_HEADER));
        if (!status) 
            goto debugdirs;
        
        pIDD->pCurrentSections  = (PCHAR)psh;
        pIDD->cCurrentSections  = nSections;
//        pIDD->ExportedNamesSize = sdh.ExportedNamesSize;
        
        if (sdh.DebugDirectorySize) {
            nDebugDirs = (int)(sdh.DebugDirectorySize / sizeof(IMAGE_DEBUG_DIRECTORY));
            ddva = sizeof(IMAGE_SEPARATE_DEBUG_HEADER) 
                   + (sdh.NumberOfSections * sizeof(IMAGE_SECTION_HEADER)) 
                   + sdh.ExportedNamesSize;
        }
    
        goto debugdirs;
    
image:
    
        // grab the dos header
    
        status = ReadImageData(hp, base, 0, &dh, sizeof(dh));
        if (!status)
            return FALSE;
    
        // grab the pe header
    
        status = ReadImageData(hp, base, dh.e_lfanew, &nh32, sizeof(nh32));
        if (!status)
            return FALSE;
    
        // read header info
    
        if (nh32.Signature != IMAGE_NT_SIGNATURE) {
            
            // if header is not NT sig, this is a ROM image
    
            rom = (PIMAGE_ROM_OPTIONAL_HEADER)&nh32.OptionalHeader;
            if (rom->Magic == IMAGE_ROM_OPTIONAL_HDR_MAGIC) {
                fh = &nh32.FileHeader;
                pIDD->fROM = TRUE;
                pIDD->iohMagic = rom->Magic;
    
                pIDD->ImageBaseFromImage = rom->BaseOfCode;
                pIDD->SizeOfImage = rom->SizeOfCode;
                pIDD->CheckSum = 0;
            } else {
                return FALSE;
            }
        
        } else {
    
            // otherwise, get info from appropriate header type for 32 or 64 bit
    
            if (IsImageMachineType64(nh32.FileHeader.Machine)) {
    
                // Reread the header as a 64bit header.
                status = ReadImageData(hp, base, dh.e_lfanew, &nh64, sizeof(nh64));
                if (!status)
                    return FALSE;
    
                fh = &nh64.FileHeader;
                datadir = nh64.OptionalHeader.DataDirectory;
                shva = dh.e_lfanew + sizeof(nh64);
                pIDD->iohMagic = nh64.OptionalHeader.Magic;
                pIDD->fPE64 = TRUE;       // seems to be unused
    
                // BUGBUG: get rid of this mapping!
                if (datasrc == dsImage) {
                    pIDD->ImageBaseFromImage = nh64.OptionalHeader.ImageBase;
                    pIDD->ImageAlign = nh64.OptionalHeader.SectionAlignment;
                    pIDD->CheckSum = nh64.OptionalHeader.CheckSum;
                }
                pIDD->SizeOfImage = nh64.OptionalHeader.SizeOfImage;
            }   
            else {
                fh = &nh32.FileHeader;
                datadir = nh32.OptionalHeader.DataDirectory;
                shva = dh.e_lfanew + sizeof(nh32);
                pIDD->iohMagic = nh32.OptionalHeader.Magic;
                
                // BUGBUG: get rid of this mapping!
                if (datasrc == dsImage) {
                    pIDD->ImageBaseFromImage = nh32.OptionalHeader.ImageBase;
                    pIDD->ImageAlign = nh32.OptionalHeader.SectionAlignment;
                    pIDD->CheckSum = nh32.OptionalHeader.CheckSum;
                }
                pIDD->SizeOfImage = nh32.OptionalHeader.SizeOfImage;
            }
        }
    
        // read the section headers
    
        nSections = fh->NumberOfSections;
        psh = (PIMAGE_SECTION_HEADER) MemAlloc(nSections * sizeof(IMAGE_SECTION_HEADER));
        status = ReadImageData(hp, base, shva, psh, nSections * sizeof(IMAGE_SECTION_HEADER));
        if (!status) 
            goto debugdirs;
        
        // store off info to return struct
    
        pIDD->pCurrentSections = (PCHAR)psh;
        pIDD->cCurrentSections = nSections;
        pIDD->Machine = fh->Machine;
        pIDD->TimeDateStamp = fh->TimeDateStamp;
        pIDD->Characteristics = fh->Characteristics;
    
        if (pIDD->fROM)
            goto debugdirs;
    
        // get information from the sections
        
        for (i = 0; i < nSections; i++, psh++) {
            DWORD offset;
    
            if (offset = SectionContains(hp, psh, &datadir[IMAGE_DIRECTORY_ENTRY_EXPORT]))
            {
                status = ReadImageData(hp, base, offset, &expdir, sizeof(expdir));
                memcpy(&pIDD->expdir, &expdir, sizeof(expdir));
                pIDD->pMappedExportDirectory = (PCHAR)&pIDD->expdir;
//              pIDD->ExportedNamesSize = psh->SizeOfRawData;
                pIDD->dsExports = datasrc;
            }
            
            if (offset = SectionContains(hp, psh, &datadir[IMAGE_DIRECTORY_ENTRY_DEBUG]))
            {
                ddva = offset;
                nDebugDirs = datadir[IMAGE_DIRECTORY_ENTRY_DEBUG].Size / sizeof(IMAGE_DEBUG_DIRECTORY);
            }
        }
    
debugdirs:
        
        rc = TRUE;

        // copy the virtual addr of the debug directories over for MapDebugInformation

        if (datasrc == dsImage) {
            pIDD->ddva = ddva;
            pIDD->cdd  = nDebugDirs;
        }
    
        // read the debug directories

        while (nDebugDirs) {
            
            status = ReadImageData(hp, base, (ULONG_PTR)ddva, &dd, sizeof(dd));
            if (!status) 
                break;
            if (!dd.SizeOfData) 
                goto nextdebugdir;
    
            // these debug directories are processed both in-proc and from file
    
            switch (dd.Type) 
            {
            case IMAGE_DEBUG_TYPE_CODEVIEW:
                // get info on pdb file
                if (hp && dd.AddressOfRawData) {
                    // in-proc image               
                    if (!(pCV = MemAlloc(dd.SizeOfData)))
                        break;
                    status = ReadImageData(hp, base, dd.AddressOfRawData, pCV, dd.SizeOfData);
                    if (!status) {
                        MemFree(pCV);
                        break;
                    }
                } else {
                    // file-base image
                    if (dd.PointerToRawData >= fsize) 
                        break;
                    pCV = (PCHAR)base + dd.PointerToRawData;
                    pIDD->fCvMapped = TRUE;
                }
                pIDD->pMappedCv = (PCHAR)pCV;
                pIDD->cMappedCv = dd.SizeOfData;
                pIDD->dsCV = datasrc;
                RetrievePdbInfo(pIDD, filepath);
                break;
            
            case IMAGE_DEBUG_TYPE_MISC:
                // on stripped files, find the dbg file
                // on dbg file, find the original file name
                if (dd.PointerToRawData < fsize) {
                    md = (PIMAGE_DEBUG_MISC)((PCHAR)base + dd.PointerToRawData);
                    if (md->DataType != IMAGE_DEBUG_MISC_EXENAME) 
                        break;
                    if (datasrc == dsDbg) {
                        if (!*pIDD->OriginalImageFileName)
                            strncpy(pIDD->OriginalImageFileName, md->Data, sizeof(pIDD->OriginalImageFileName));
                        break;
                    }
                    if (fh->Characteristics & IMAGE_FILE_DEBUG_STRIPPED) {
                        strncpy(pIDD->OriginalDbgFileName, md->Data, sizeof(pIDD->OriginalDbgFileName));
                    } else {
                        strncpy(pIDD->OriginalImageFileName, md->Data, sizeof(pIDD->OriginalImageFileName));
                    }
                }
                break;
            
            case IMAGE_DEBUG_TYPE_COFF:
                if (dd.PointerToRawData < fsize) {
//                  pIDD->fNeedImage = TRUE;
                    pIDD->pMappedCoff = (PCHAR)base + dd.PointerToRawData;
                    pIDD->cMappedCoff = dd.SizeOfData;
                    pIDD->fCoffMapped = TRUE;
                    pIDD->dsCoff = datasrc;
                } else {
                    pIDD->fNeedImage = TRUE;
                }
                break;
#ifdef INPROC_SUPPORT
            case IMAGE_DEBUG_TYPE_FPO:
                if (dd.PointerToRawData < fsize) {
                    pIDD->pFpo = (PCHAR)base + dd.PointerToRawData;
                    pIDD->cFpo = dd.SizeOfData / SIZEOF_RFPO_DATA;
                    pIDD->fFpoMapped = TRUE;
                    pIDD->dsFPO = datasrc;
                } else {
                    DPRINTF(NULL, "found fpo in-process\n");
                }
                break;
            case IMAGE_DEBUG_TYPE_OMAP_TO_SRC:
                if (dd.PointerToRawData < fsize) {
                    pIDD->pOmapTo = (PCHAR)base + dd.PointerToRawData;
                    pIDD->cOmapTo = dd.SizeOfData / sizeof(OMAP);
                    pIDD->fOmapToMapped = TRUE;
                    pIDD->dsOmapTo = datasrc;
                } else {
                    DPRINTF(NULL, "found found omap-to in-process\n");
                }
                break;

            case IMAGE_DEBUG_TYPE_OMAP_FROM_SRC:
                if (dd.PointerToRawData < fsize) {
                    pIDD->pOmapFrom = (PCHAR)base + dd.PointerToRawData;
                    pIDD->cOmapFrom = dd.SizeOfData / sizeof(OMAP);
                    pIDD->fOmapFromMapped = TRUE;
                    pIDD->dsOmapFrom = datasrc;
                } else {
                    DPRINTF(NULL, "found omap-from in-process\n");
                }
                break;
#endif
            }
    
            // these debug directories are only processed for disk-based images
    
            if (dd.PointerToRawData < fsize) {
    
                switch (dd.Type) 
                {
                case IMAGE_DEBUG_TYPE_FPO:
                    pIDD->pFpo = (PCHAR)base + dd.PointerToRawData;
                    pIDD->cFpo = dd.SizeOfData / SIZEOF_RFPO_DATA;
                    pIDD->fFpoMapped = TRUE;
                    pIDD->dsFPO = datasrc;
                    break;
    
                case IMAGE_DEBUG_TYPE_OMAP_TO_SRC:
                    pIDD->pOmapTo = (PCHAR)base + dd.PointerToRawData;
                    pIDD->cOmapTo = dd.SizeOfData / sizeof(OMAP);
                    pIDD->fOmapToMapped = TRUE;
                    pIDD->dsOmapTo = datasrc;
                    break;
    
                case IMAGE_DEBUG_TYPE_OMAP_FROM_SRC:
                    pIDD->pOmapFrom = (PCHAR)base + dd.PointerToRawData;
                    pIDD->cOmapFrom = dd.SizeOfData / sizeof(OMAP);
                    pIDD->fOmapFromMapped = TRUE;
                    pIDD->dsOmapFrom = datasrc;
                    break;

                case IMAGE_DEBUG_TYPE_EXCEPTION:
                    pIDD->dsExceptions = datasrc;
                    break;
                }
            }
    
nextdebugdir:

            ddva += sizeof(IMAGE_DEBUG_DIRECTORY);
            nDebugDirs--;
        }
    
    } __except (EXCEPTION_EXECUTE_HANDLER) {

          // We might have gotten enough information
          // to be okay.  So don't indicate error.
    }

    return rc;
}


__inline
BOOL
ProcessImageDebugInfo(
    PIMGHLP_DEBUG_DATA pIDD
    )
{
    return ProcessDebugInfo(pIDD, dsImage);
}


__inline
BOOL
ProcessInProcDebugInfo(
    PIMGHLP_DEBUG_DATA pIDD
    )
{
    return ProcessDebugInfo(pIDD, dsInProc);
}


__inline
BOOL
ProcessDbgDebugInfo(
    PIMGHLP_DEBUG_DATA pIDD
    )
{
    return ProcessDebugInfo(pIDD, dsDbg);
}


BOOL
FigureOutImageName(
    PIMGHLP_DEBUG_DATA pIDD
    )
/*
    We got here because we didn't get the image name passed in from the original call
    to ImgHlpFindDebugInfo AND we were unable to find the MISC data with the name
    Have to figure it out.

    A couple of options here.  First, if the DLL bit is set, try looking for Export
    table.  If found, IMAGE_EXPORT_DIRECTORY->Name is a rva pointer to the dll name.
    If it's not found, see if there's a OriginalDbgFileName.
      If so see if the format is <ext>\<filename>.dbg.
        If there's more than one backslash or no backslash, punt and label it with a .dll
        extension.
        Otherwise a splitpath will do the trick.
    If there's no DbgFilePath, see if there's a PDB name.  The same rules apply there as
    for .dbg files.  Worst case, you s/b able to get the base name and just stick on a
    If this all fails, label it as mod<base address>.
    If the DLL bit is not set, assume an exe and tag it with that extension.  The base name
    can be retrieved from DbgFilePath, PdbFilePath, or use just APP.
*/
{
    // Quick hack to get Dr. Watson going.

    CHAR szName[_MAX_FNAME];
    CHAR szExt[_MAX_FNAME];

    if (pIDD->OriginalDbgFileName[0]) {
        _splitpath(pIDD->OriginalDbgFileName, NULL, NULL, szName, NULL);
        strcpy(pIDD->OriginalImageFileName, szName);
        strcat(pIDD->OriginalImageFileName, pIDD->Characteristics & IMAGE_FILE_DLL ? ".dll" : ".exe");
    } else if (pIDD->ImageName) {
        _splitpath(pIDD->ImageName, NULL, NULL, szName, szExt);
        strcpy(pIDD->OriginalImageFileName, szName);
        if (*szExt) {
            strcat(pIDD->OriginalImageFileName, szExt);
        }
    } else if (pIDD->PdbFileName[0]) {
        _splitpath(pIDD->PdbFileName, NULL, NULL, szName, NULL);
        strcpy(pIDD->OriginalImageFileName, szName);
        strcat(pIDD->OriginalImageFileName, pIDD->Characteristics & IMAGE_FILE_DLL ? ".dll" : ".exe");
    } else {
        sprintf(pIDD->OriginalImageFileName, "MOD%p", pIDD->InProcImageBase);
    }


    return TRUE;
}


BOOL
FindExecutableImageExCallback(
    HANDLE FileHandle,
    PSTR FileName,
    PVOID CallerData
    )
{
    PIMGHLP_DEBUG_DATA pIDD;
    PIMAGE_FILE_HEADER FileHeader = NULL;
    PVOID ImageMap = NULL;
    BOOL rc;

    if (!CallerData)
        return TRUE;
    
    pIDD = (PIMGHLP_DEBUG_DATA)CallerData;
    if (!pIDD->TimeDateStamp)
        return TRUE;

    // Crack the image and let's see what we're working with
    ImageMap = MapItRO(FileHandle);

    // Check the first word.  We're either looking at a normal PE32/PE64 image, or it's
    // a ROM image (no DOS stub) or it's a random file.
    switch (*(PUSHORT)ImageMap) {
        case IMAGE_FILE_MACHINE_I386:
            // Must be an X86 ROM image (ie: ntldr)
            FileHeader = &((PIMAGE_ROM_HEADERS)ImageMap)->FileHeader;

            // Make sure
            if (!(FileHeader->SizeOfOptionalHeader == sizeof(IMAGE_OPTIONAL_HEADER32) &&
                pIDD->iohMagic == IMAGE_NT_OPTIONAL_HDR32_MAGIC))
            {
                FileHeader = NULL;
            }
            break;

        case IMAGE_FILE_MACHINE_ALPHA:
        case IMAGE_FILE_MACHINE_IA64:
            // Should be an Alpha/IA64 ROM image (ie: osloader.exe)
            FileHeader = &((PIMAGE_ROM_HEADERS)ImageMap)->FileHeader;

            // Make sure
            if (!(FileHeader->SizeOfOptionalHeader == sizeof(IMAGE_ROM_OPTIONAL_HEADER) &&
                 pIDD->iohMagic == IMAGE_ROM_OPTIONAL_HDR_MAGIC))
            {
                FileHeader = NULL;
            } 
            break;

        case IMAGE_DOS_SIGNATURE:
            {
                PIMAGE_NT_HEADERS NtHeaders = ImageNtHeader(ImageMap);
                if (NtHeaders) {
                    FileHeader = &NtHeaders->FileHeader;
                }
            }
            break;

        default:
            break;
    }

    // default return is a match

    rc = TRUE;

    // compare timestamps

    if (FileHeader && FileHeader->TimeDateStamp != pIDD->TimeDateStamp)
        rc = FALSE;

    // cleanup

    if (ImageMap)
        UnmapViewOfFile(ImageMap);

    return rc;
}


PIMGHLP_DEBUG_DATA
ImgHlpFindDebugInfo(
    HANDLE  hProcess,
    HANDLE  FileHandle,
    LPSTR   FileName,
    LPSTR   SymbolPath,
    ULONG64 ImageBase,
    ULONG   dwFlags
    )
/*
   Given:
     ImageFileHandle - Map the thing.  The only time FileHandle s/b non-null
                       is if we're given an image handle.  If this is not
                       true, ignore the handle.
    !ImageFileHandle - Use the filename and search for first the image name,
                       then the .dbg file, and finally a .pdb file.

    dwFlags:           NO_PE64_IMAGES - Return failure if only image is PE64.
                                        Used to implement MapDebugInformation()

*/
{
    PIMGHLP_DEBUG_DATA pIDD;

    // No File handle and   no file name.  Bail

    if (!FileHandle && (!FileName || !*FileName)) {
        return NULL;
    }

    SetLastError(NO_ERROR);

    pIDD = MemAlloc(sizeof(IMGHLP_DEBUG_DATA));
    if (!pIDD) {
        SetLastError(ERROR_OUTOFMEMORY);
        return NULL;
    }
    ZeroMemory(pIDD, sizeof(IMGHLP_DEBUG_DATA));

    __try {

        // store off parameters

        pIDD->InProcImageBase = ImageBase;
        pIDD->hProcess = hProcess;

        if (FileName)
            lstrcpy(pIDD->ImageName, FileName);

        if (SymbolPath) {
            pIDD->SymbolPath = MemAlloc(strlen(SymbolPath) + 1);
            if (pIDD->SymbolPath) {
                strcpy(pIDD->SymbolPath, SymbolPath);
            }
        }
        
        // if we have a base pointer into process memory.  See what we can get here.
        if (pIDD->InProcImageBase) {
            pIDD->fInProcHeader = ProcessInProcDebugInfo(pIDD);
        } 
        
        // find disk-based image

        if (FileHandle) {
            // if passed a handle, save it
            if (!DuplicateHandle(
                                 GetCurrentProcess(),
                                 FileHandle,
                                 GetCurrentProcess(),
                                 &pIDD->ImageFileHandle,
                                 GENERIC_READ,
                                 FALSE,
                                 DUPLICATE_SAME_ACCESS
                                ))
            {
                return NULL;
            }
            if (FileName) {
                strcpy(pIDD->ImageFilePath, FileName);
            }

        } else if (FileName && *FileName && !pIDD->fInProcHeader)
        {
            // otherwise use the file name to open the disk image 
            // only if we didn't have access to in-proc headers
            pIDD->ImageFileHandle = FindExecutableImageEx(FileName, 
                                                          SymbolPath, 
                                                          pIDD->ImageFilePath, 
                                                          FindExecutableImageExCallback, 
                                                          pIDD);
        }

        // if we have a file handle.  See what we can get here.
        if (pIDD->ImageFileHandle) { 
            if (!pIDD->DbgFileHandle && !*pIDD->PdbFileName) {
                ProcessImageDebugInfo(pIDD);
            }
        }

        // search for pdb, if indicated or if we have found no image info, so far
        if (!pIDD->Characteristics || (pIDD->Characteristics & IMAGE_FILE_DEBUG_STRIPPED)) {
            pIDD->DbgFileHandle = fnFindDebugInfoFileEx(
                                        (*pIDD->OriginalDbgFileName) ? pIDD->OriginalDbgFileName : pIDD->ImageName,
                                        pIDD->SymbolPath,
                                        pIDD->DbgFilePath,
                                        FindDebugInfoFileExCallback,
                                        pIDD,
                                        fdifRECURSIVE
                                        );
        }

        // if we have a .dbg file.  See what we can get from it.
        if (pIDD->DbgFileHandle) {
            ProcessDbgDebugInfo(pIDD);
        }

        // check one more time to see if information we have aquired
        // indicates we need the image.
        if (FileName && *FileName && pIDD->fNeedImage) {
            pIDD->ImageFileHandle = FindExecutableImageEx(FileName, 
                                                          SymbolPath, 
                                                          pIDD->ImageFilePath, 
                                                          FindExecutableImageExCallback, 
                                                          pIDD);
            if (pIDD->ImageFileHandle) { 
                    ProcessImageDebugInfo(pIDD);
            }
        }

        // if there's a pdb.  Pull what we can from there.
        if (*pIDD->PdbFileName) {
            ProcessPdbDebugInfo(pIDD);
        
        // otherwise, if old codeview, pull from there
        } else if (pIDD->pMappedCv) {
            ProcessOldStyleCodeView(pIDD);
        
        // otherwise if we couldn't read from the image info, look for PDB anyway
        } else if (!pIDD->ImageFileHandle && !pIDD->DbgFileHandle) {
            if (FakePdbName(pIDD)) {
                ProcessPdbDebugInfo(pIDD);
            }
        } 

        if (!pIDD->OriginalImageFileName[0]) {
            FigureOutImageName(pIDD);
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        if (pIDD) {
            ImgHlpReleaseDebugInfo(pIDD, IMGHLP_FREE_ALL);
            pIDD = NULL;
        }
    }

    return pIDD;
}


void
ImgHlpReleaseDebugInfo(
    PIMGHLP_DEBUG_DATA pIDD,
    DWORD              dwFlags
    )
{
    if (!pIDD)
        return;

    if (pIDD->ImageMap) {
        UnmapViewOfFile(pIDD->ImageMap);
    }

    if (pIDD->ImageFileHandle) {
        CloseHandle(pIDD->ImageFileHandle);
    }

    if (pIDD->DbgFileMap) {
        UnmapViewOfFile(pIDD->DbgFileMap);
    }

    if (pIDD->DbgFileHandle) {
        CloseHandle(pIDD->DbgFileHandle);
    }

    if ((dwFlags & IMGHLP_FREE_FPO) &&
        pIDD->pFpo &&
        !pIDD->fFpoMapped
       )
    {
        MemFree(pIDD->pFpo);
    }

    if ((dwFlags & IMGHLP_FREE_PDATA) &&
        pIDD->pImageFunction &&
        !pIDD->fImageFunctionMapped
       )
    {
        MemFree(pIDD->pImageFunction);
    }

    if ((dwFlags & IMGHLP_FREE_PDATA) &&
        pIDD->pMappedCoff &&
        !pIDD->fCoffMapped
       )
    {
        MemFree(pIDD->pMappedCoff);
    }

    if ((dwFlags & IMGHLP_FREE_PDATA) &&
        pIDD->pMappedCv &&
        !pIDD->fCvMapped
       )
    {
        MemFree(pIDD->pMappedCv);
    }

    if ((dwFlags & IMGHLP_FREE_OMAPT) &&
        pIDD->pOmapTo &&
        !pIDD->fOmapToMapped
       )
    {
        MemFree(pIDD->pOmapTo);
    }

    if ((dwFlags & IMGHLP_FREE_OMAPF) &&
        pIDD->pOmapFrom &&
        !pIDD->fOmapFromMapped
       )
    {
        MemFree(pIDD->pOmapFrom);
    }

    if ((dwFlags & IMGHLP_FREE_OSECT) &&
        pIDD->pOriginalSections
       )
    {
        MemFree(pIDD->pOriginalSections);
    }

    if ((dwFlags & IMGHLP_FREE_CSECT) &&
        pIDD->pCurrentSections &&
        !pIDD->fCurrentSectionsMapped
       )
    {
        MemFree(pIDD->pCurrentSections);
    }

    if (dwFlags & IMGHLP_FREE_PDB) {
        if (pIDD->pGsi) {
            GSIClose(pIDD->pGsi);
        }
        if (pIDD->pDbi) {
            DBIClose(pIDD->pDbi);
        }
        if (pIDD->pPdb) {
            PDBClose(pIDD->pPdb);
        }
    }

    if (pIDD->SymbolPath) {
        MemFree(pIDD->SymbolPath);
    }

    MemFree(pIDD);

    return;
}



#ifdef MAP_DEBUG_TEST

void
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    CHAR szSymPath[4096];
    PIMGHLP_DEBUG_DATA pDebugInfo;

    strcpy(szSymPath, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test1");
    pDebugInfo = ImgHlpFindDebugInfo(NULL, NULL, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test1\\ntoskrnl.exe", szSymPath, 0x1000000, 0);
    ImgHlpReleaseDebugInfo(pDebugInfo, IMGHLP_FREE_ALL);

    strcpy(szSymPath, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test2");
    pDebugInfo = ImgHlpFindDebugInfo(NULL, NULL, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test2\\ntoskrnl.exe", szSymPath, 0x1000000, 0);
    ImgHlpReleaseDebugInfo(pDebugInfo, IMGHLP_FREE_ALL);

    strcpy(szSymPath, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test3");
    pDebugInfo = ImgHlpFindDebugInfo(NULL, NULL, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test3\\ntoskrnl.exe", szSymPath, 0x1000000, 0);
    ImgHlpReleaseDebugInfo(pDebugInfo, IMGHLP_FREE_ALL);

    strcpy(szSymPath, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test4");
    pDebugInfo = ImgHlpFindDebugInfo(NULL, NULL, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test4\\ntoskrnl.exe", szSymPath, 0x1000000, 0);
    ImgHlpReleaseDebugInfo(pDebugInfo, IMGHLP_FREE_ALL);

    strcpy(szSymPath, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test5");
    pDebugInfo = ImgHlpFindDebugInfo(NULL, NULL, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test5\\ntdll.dll", szSymPath, 0x1000000, 0);
    ImgHlpReleaseDebugInfo(pDebugInfo, IMGHLP_FREE_ALL);

    strcpy(szSymPath, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test6");
    pDebugInfo = ImgHlpFindDebugInfo(NULL, NULL, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test6\\ntdll.dll", szSymPath, 0x1000000, 0);
    ImgHlpReleaseDebugInfo(pDebugInfo, IMGHLP_FREE_ALL);

    strcpy(szSymPath, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test7");
    pDebugInfo = ImgHlpFindDebugInfo(NULL, NULL, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test7\\osloader.exe", szSymPath, 0x1000000, 0);
    ImgHlpReleaseDebugInfo(pDebugInfo, IMGHLP_FREE_ALL);

    strcpy(szSymPath, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test8");
    pDebugInfo = ImgHlpFindDebugInfo(NULL, NULL, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test8\\osloader.exe", szSymPath, 0x1000000, 0);
    ImgHlpReleaseDebugInfo(pDebugInfo, IMGHLP_FREE_ALL);

    strcpy(szSymPath, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test9");
    pDebugInfo = ImgHlpFindDebugInfo(NULL, NULL, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test9\\msvcrt.dll", szSymPath, 0x1000000, 0);
    ImgHlpReleaseDebugInfo(pDebugInfo, IMGHLP_FREE_ALL);

    strcpy(szSymPath, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test10");
    pDebugInfo = ImgHlpFindDebugInfo(NULL, NULL, "h:\\nt\\private\\sdktools\\imagehlp\\test\\test10\\msvcrt.dll", szSymPath, 0x1000000, 0);
    ImgHlpReleaseDebugInfo(pDebugInfo, IMGHLP_FREE_ALL);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\rebase.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    rebase.c

Abstract:

    Source file for the REBASE utility that takes a group of image files and
    rebases them so they are packed as closely together in the virtual address
    space as possible.

Author:

    Mark Lucovsky (markl) 30-Apr-1993

Revision History:

--*/

#include <private.h>

#define ROUNDUP(x, y) ((x + (y-1)) & ~(y-1))

VOID
RemoveRelocations(
    PCHAR ImageName
    );


#define REBASE_ERR 99
#define REBASE_OK  0
ULONG ReturnCode = REBASE_OK;

#define ROUND_UP( Size, Amount ) (((ULONG)(Size) + ((Amount) - 1)) & ~((Amount) - 1))

BOOL fVerbose;
BOOL fQuiet;
BOOL fGoingDown;
BOOL fSumOnly;
BOOL fRebaseSysfileOk;
BOOL fShowAllBases;
BOOL fCoffBaseIncExt;
FILE *CoffBaseDotTxt;
FILE *BaseAddrFile;
FILE *RebaseLog;
BOOL fSplitSymbols;
ULONG SplitFlags;
BOOL fRemovePrivteSym;
BOOL fRemoveRelocs;
BOOL fUpdateSymbolsOnly;

LPSTR BaseAddrFileName;

BOOL
ProcessGroupList(
    LPSTR ImagesRoot,
    LPSTR GroupListFName,
    BOOL  fReBase,
    BOOL  fOverlay
    );

BOOL
FindInIgnoreList(
    LPSTR chName
    );

ULONG64
FindInBaseAddrFile(
    LPSTR Name,
    PULONG pulSize
    );

VOID
ReBaseFile(
    LPSTR pstrName,
    BOOL  fReBase
    );

VOID
ParseSwitch(
    CHAR chSwitch,
    int *pArgc,
    char **pArgv[]
    );


VOID
ShowUsage(
    VOID
    );

typedef struct _GROUPNODE {
    struct _GROUPNODE *pgnNext;
    PCHAR chName;
} GROUPNODE, *PGROUPNODE;

PGROUPNODE pgnIgnoreListHdr, pgnIgnoreListEnd;

typedef BOOL (__stdcall *REBASEIMAGE64) (
    IN     PSTR CurrentImageName,
    IN     PSTR SymbolPath,
    IN     BOOL  fReBase,          // TRUE if actually rebasing, false if only summing
    IN     BOOL  fRebaseSysfileOk, // TRUE is system images s/b rebased
    IN     BOOL  fGoingDown,       // TRUE if the image s/b rebased below the given base
    IN     ULONG CheckImageSize,   // Max size allowed  (0 if don't care)
    OUT    ULONG *OldImageSize,    // Returned from the header
    OUT    ULONG64 *OldImageBase,  // Returned from the header
    OUT    ULONG *NewImageSize,    // Image size rounded to next separation boundary
    IN OUT ULONG64 *NewImageBase,  // (in) Desired new address.
                                   // (out) Next address (actual if going down)
    IN     ULONG TimeStamp         // new timestamp for image, if non-zero
    );

REBASEIMAGE64 pReBaseImage64;

UCHAR ImagesRoot[ MAX_PATH+1 ];
PCHAR SymbolPath;
UCHAR DebugFilePath[ MAX_PATH+1 ];

ULONG64 OriginalImageBase;
ULONG OriginalImageSize;
ULONG64 NewImageBase;
ULONG NewImageSize;

ULONG64 InitialBase = 0;
ULONG64 MinBase = (~((ULONG64)0));
ULONG64 TotalSize;


int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    char chChar, *pchChar;
    envp;
    _tzset();

    pgnIgnoreListHdr = (PGROUPNODE) malloc( sizeof ( GROUPNODE ) );
    pgnIgnoreListHdr->chName = NULL;
    pgnIgnoreListHdr->pgnNext = NULL;
    pgnIgnoreListEnd = pgnIgnoreListHdr;

    pReBaseImage64 = (REBASEIMAGE64) GetProcAddress(GetModuleHandle("imagehlp.dll"), "ReBaseImage64");
    if (!pReBaseImage64) {
        puts("REBASE: Warning\n"
             "REBASE: Warning - unable to correctly rebase 64-bit images - update your imagehlp.dll\n"
             "REBASE: Warning");
        pReBaseImage64 = (REBASEIMAGE64) GetProcAddress(GetModuleHandle("imagehlp.dll"), "ReBaseImage");
    }

    fVerbose = FALSE;
    fQuiet = FALSE;
    fGoingDown = FALSE;
    fSumOnly = FALSE;
    fRebaseSysfileOk = FALSE;
    fShowAllBases = FALSE;

    ImagesRoot[ 0 ] = '\0';

    if (argc <= 1) {
        ShowUsage();
        }

    while (--argc) {
        pchChar = *++argv;
        if (*pchChar == '/' || *pchChar == '-') {
            while (chChar = *++pchChar) {
                ParseSwitch( chChar, &argc, &argv );
                }
            }
        else {
            if ( !FindInIgnoreList( pchChar ) ) {
                ReBaseFile( pchChar, TRUE );
                }
            }
        }

    if ( !fQuiet ) {

        if ( BaseAddrFile ) {
            InitialBase = MinBase;
        }

        if ( fGoingDown ) {
            TotalSize = InitialBase - NewImageBase;
        }
        else {
            TotalSize = NewImageBase - InitialBase;
        }

        fprintf( stdout, "\n" );
        fprintf( stdout, "REBASE: Total Size of mapping 0x%016I64x\n", TotalSize );
        fprintf( stdout, "REBASE: Range 0x%016I64x -0x%016I64x\n",
                 min(NewImageBase, InitialBase), max(NewImageBase, InitialBase));

        if (RebaseLog) {
            fprintf( RebaseLog, "\nTotal Size of mapping 0x%016I64x\n", TotalSize );
            fprintf( RebaseLog, "Range 0x%016I64x -0x%016I64x\n\n",
                     min(NewImageBase, InitialBase), max(NewImageBase, InitialBase));
        }
    }

    if (RebaseLog) {
        fclose(RebaseLog);
        }

    if (BaseAddrFile){
        fclose(BaseAddrFile);
        }

    if (CoffBaseDotTxt){
        fclose(CoffBaseDotTxt);
        }

    return ReturnCode;
}


VOID
ShowUsage(
    VOID
    )
{
    fputs( "usage: REBASE [switches]\n"
           "              [-R image-root [-G filename] [-O filename] [-N filename]]\n"
           "              image-names... \n"
           "\n"
           "              One of -b and -i switches are mandatory.\n"
           "\n"
           "              [-a] Used with -x.  extract All debug info into .dbg file\n"
           "              [-b InitialBase] specify initial base address\n"
           "              [-c coffbase_filename] generate coffbase.txt\n"
           "                  -C includes filename extensions, -c does not\n"
           "              [-d] top down rebase\n"
           "              [-f] Strip relocs after rebasing the image\n"
           "              [-i coffbase_filename] get base addresses from coffbase_filename\n"
           "              [-l logFilePath] write image bases to log file.\n"
           "              [-p] Used with -x.  Remove private debug info when extracting\n"
           "              [-q] minimal output\n"
           "              [-s] just sum image range\n"
           "              [-u symbol_dir] Update debug info in .DBG along this path\n"
           "              [-v] verbose output\n"
           "              [-x symbol_dir] extract debug info into separate .DBG file first\n"
           "              [-z] allow system file rebasing\n"
           "              [-?] display this message\n"
           "\n"
           "              [-R image_root] set image root for use by -G, -O, -N\n"
           "              [-G filename] group images together in address space\n"
           "              [-O filename] overlay images in address space\n"
           "              [-N filename] leave images at their origional address\n"
           "                  -G, -O, -N, may occur multiple times.  File \"filename\"\n"
           "                  contains a list of files (relative to \"image-root\")\n" ,
           stderr );

    exit( REBASE_ERR );
}


VOID
ParseSwitch(
    CHAR chSwitch,
    int *pArgc,
    char **pArgv[]
    )
{

    switch (toupper( chSwitch )) {

        case '?':
            ShowUsage();
            break;

        case 'A':
            SplitFlags |= SPLITSYM_EXTRACT_ALL;
            break;

        case 'B':
            if (!--(*pArgc)) {
                ShowUsage();
                }
            (*pArgv)++;
            sscanf(**pArgv, "%I64x", &InitialBase);
            NewImageBase = InitialBase;
            break;

        case 'C':
            if (!--(*pArgc)) {
                ShowUsage();
                }
            (*pArgv)++;
            fCoffBaseIncExt = (chSwitch == 'C');
            CoffBaseDotTxt = fopen( *(*pArgv), "at" );
            if ( !CoffBaseDotTxt ) {
                fprintf( stderr, "REBASE: fopen %s failed %d\n", *(*pArgv), errno );
                ExitProcess( REBASE_ERR );
                }
            break;

        case 'D':
            fGoingDown = TRUE;
            break;

        case 'F':
            fRemoveRelocs = TRUE;
            break;

        case 'G':
        case 'O':
        case 'N':
            if (!--(*pArgc)) {
                ShowUsage();
                }
            (*pArgv)++;
            if (!ImagesRoot[0]) {
                fprintf( stderr, "REBASE: -R must preceed -%c\n", chSwitch );
                exit( REBASE_ERR );
                }
            ProcessGroupList( (PCHAR) ImagesRoot,
                              *(*pArgv),
                              toupper(chSwitch) != 'N',
                              toupper(chSwitch) == 'O');
            break;

        case 'I':
            if (!--(*pArgc)) {
                ShowUsage();
                }
            (*pArgv)++;
            BaseAddrFileName = *(*pArgv);
            BaseAddrFile = fopen( *(*pArgv), "rt" );
            if ( !BaseAddrFile ) {
                fprintf( stderr, "REBASE: fopen %s failed %d\n", *(*pArgv), errno );
                ExitProcess( REBASE_ERR );
                }
            break;

        case 'L':
            if (!--(*pArgc)) {
                ShowUsage();
                }
            (*pArgv)++;
            RebaseLog = fopen( *(*pArgv), "at" );
            if ( !RebaseLog ) {
                fprintf( stderr, "REBASE: fopen %s failed %d\n", *(*pArgv), errno );
                ExitProcess( REBASE_ERR );
                }
            break;

        case 'P':
            SplitFlags |= SPLITSYM_REMOVE_PRIVATE;
            break;

        case 'Q':
            fQuiet = TRUE;
            break;

        case 'R':
            if (!--(*pArgc)) {
                ShowUsage();
                }
            (*pArgv)++;
            strcpy( (PCHAR) ImagesRoot, *(*pArgv) );
            break;

        case 'S':
            fprintf(stdout,"\n");
            fSumOnly = TRUE;
            break;

        case 'U':
            if (!--(*pArgc)) {
                ShowUsage();
                }
            (*pArgv)++;
            fUpdateSymbolsOnly = TRUE;
            SymbolPath = **pArgv;
            break;

        case 'V':
            fVerbose = TRUE;
            break;

        case 'X':
            if (!--(*pArgc)) {
                ShowUsage();
                }
            (*pArgv)++;
            SymbolPath = **pArgv;
            fSplitSymbols = TRUE;
            break;

        case 'Z':
            fRebaseSysfileOk = TRUE;
            break;

        default:
            fprintf( stderr, "REBASE: Invalid switch - /%c\n", chSwitch );
            ShowUsage();
            break;

        }
}


BOOL
ProcessGroupList(
    LPSTR ImagesRoot,
    LPSTR GroupListFName,
    BOOL  fReBase,
    BOOL  fOverlay
    )
{

    PGROUPNODE pgn;
    FILE *GroupList;

    CHAR  chName[MAX_PATH+1];
    int   ateof;
    ULONG64 SavedImageBase;
    ULONG MaxImageSize=0;

    DWORD dw;
    CHAR  Buffer[ MAX_PATH+1 ];
    LPSTR FilePart;


    if (RebaseLog) {
        fprintf( RebaseLog, "*** %s\n", GroupListFName );
    }

    GroupList = fopen( GroupListFName, "rt" );
    if ( !GroupList ) {
        fprintf( stderr, "REBASE: fopen %s failed %d\n", GroupListFName, errno );
        ExitProcess( REBASE_ERR );
    }

    ateof = fscanf( GroupList, "%s", chName );

    SavedImageBase = NewImageBase;

    while ( ateof && ateof != EOF ) {

        dw = SearchPath( ImagesRoot, chName, NULL, sizeof(Buffer), Buffer, &FilePart );
        if ( dw == 0 || dw > sizeof( Buffer ) ) {
            if (!fQuiet) {
                fprintf( stderr, "REBASE: Could Not Find %s\\%s\n", ImagesRoot, chName );
            }
        }
        else {

            _strlwr( Buffer );  // Lowercase for consistency when displayed.

            pgn = (PGROUPNODE) malloc( sizeof( GROUPNODE ) );
            pgn->chName = _strdup( Buffer );
            if ( NULL == pgn->chName ) {
                fprintf( stderr, "REBASE: *** strdup failed (%s).\n", Buffer );
                ExitProcess( REBASE_ERR );
            }
            pgn->pgnNext = NULL;
            pgnIgnoreListEnd->pgnNext = pgn;
            pgnIgnoreListEnd = pgn;

            ReBaseFile( Buffer, fReBase );

            if ( fOverlay ) {
                if ( MaxImageSize < NewImageSize ) {
                    MaxImageSize = NewImageSize;
                }
                NewImageBase = SavedImageBase;
            }
        }

        ateof = fscanf( GroupList, "%s", chName );
    }

    fclose( GroupList );

    if ( fOverlay ) {
        if ( fGoingDown ) {
            NewImageBase -= ROUND_UP( MaxImageSize, IMAGE_SEPARATION );
        }
        else {
            NewImageBase += ROUND_UP( MaxImageSize, IMAGE_SEPARATION );
        }
    }

    if (RebaseLog) {
        fprintf( RebaseLog, "\n" );
    }

    return TRUE;
}


BOOL
FindInIgnoreList(
    LPSTR chName
    )
{
    PGROUPNODE pgn;

    DWORD dw;
    CHAR  Buffer[ MAX_PATH+1 ];
    LPSTR FilePart;


    dw = GetFullPathName( chName, sizeof(Buffer), Buffer, &FilePart );
    if ( dw == 0 || dw > sizeof( Buffer ) ) {
        fprintf( stderr, "REBASE: *** GetFullPathName failed (%s).\n", chName );
        ExitProcess( REBASE_ERR );
        }

    for (pgn = pgnIgnoreListHdr->pgnNext;
         pgn != NULL;
         pgn = pgn->pgnNext) {

        if (!_stricmp( Buffer, pgn->chName ) ) {
            return TRUE;
            }

        }

    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
/*
******************************************************************************
On a Hydra System, we don't want imaghlp.dll to load user32.dll since it
prevents CSRSS from exiting when running a under a debugger.
The following function has been copied from user32.dll so that we don't
link to user32.dll.
******************************************************************************
*/
////////////////////////////////////////////////////////////////////////////

LPSTR CharPrev(
    LPCSTR lpStart,
    LPCSTR lpCurrentChar)
{
    if (lpCurrentChar > lpStart) {
        LPCSTR lpChar;
        BOOL bDBC = FALSE;

        for (lpChar = --lpCurrentChar - 1 ; lpChar >= lpStart ; lpChar--) {
            if (!IsDBCSLeadByte(*lpChar))
                break;
            bDBC = !bDBC;
        }

        if (bDBC)
            lpCurrentChar--;
    }
    return (LPSTR)lpCurrentChar;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


VOID
ReBaseFile(
    LPSTR CurrentImageName,
    BOOL fReBase
    )
{
    DWORD dw;
    CHAR  Buffer[ MAX_PATH+1 ];
    CHAR  Buffer2[ MAX_PATH+1 ];
    LPSTR FilePart;
    LPSTR LocalSymbolPath;
    ULONG ThisImageExpectedSize = 0;
    ULONG64 ThisImageRequestedBase = NewImageBase;
    ULONG TimeStamp;

    if ( !InitialBase && !BaseAddrFile ) {
        fprintf( stderr, "REBASE: -b switch must specify a non-zero base  --or--\n" );
        fprintf( stderr, "        -i must specify a filename\n" );
        exit( REBASE_ERR );
        }

    if ( BaseAddrFile && ( InitialBase || fGoingDown || CoffBaseDotTxt ) ) {
        fprintf( stderr, "REBASE: -i is incompatible with -b, -d, and -c\n" );
        exit( REBASE_ERR );
    }

    dw = GetFullPathName( CurrentImageName, sizeof(Buffer), Buffer, &FilePart );
    if ( dw == 0 || dw > sizeof(Buffer) ) {
        FilePart = CurrentImageName;
    }
    _strlwr( FilePart );  // Lowercase for consistency when displayed.

    if ( BaseAddrFile && !(NewImageBase = ThisImageRequestedBase = FindInBaseAddrFile( FilePart, &ThisImageExpectedSize )) ) {
        fprintf( stdout, "REBASE: %-16s Not listed in %s\n", FilePart, BaseAddrFileName );
    }

    if (fSplitSymbols && !fSumOnly ) {

        if ( SplitSymbols( CurrentImageName, SymbolPath, (PCHAR) DebugFilePath, SplitFlags ) ) {
            if ( fVerbose ) {
                fprintf( stdout, "REBASE: %16s symbols split into %s\n", FilePart, DebugFilePath );
            }
        }
        else if (GetLastError() != ERROR_ALREADY_ASSIGNED && GetLastError() != ERROR_BAD_EXE_FORMAT) {
            fprintf( stdout, "REBASE: %-16s - unable to split symbols (%u)\n", FilePart, GetLastError() );
        }
    }

    if (fUpdateSymbolsOnly) {
        // On update, the symbol path is a semi-colon delimited path.  Find the one we want and
        // then fix the path for RebaseImage.
        HANDLE hDebugFile;
        CHAR Drive[_MAX_DRIVE];
        CHAR Dir[_MAX_DIR];
        PCHAR s;
        hDebugFile = FindDebugInfoFile(CurrentImageName, SymbolPath, DebugFilePath);
        if ( hDebugFile ) {
            CloseHandle(hDebugFile);
            _splitpath(DebugFilePath, Drive, Dir, NULL, NULL);
            _makepath(Buffer2, Drive, Dir, NULL, NULL);
            s = Buffer2 + strlen(Buffer2);
            s = CharPrev(Buffer2, s);
            if (*s == '\\') {
                *s = '\0';
            }
            LocalSymbolPath = Buffer2;
        } else {
            LocalSymbolPath = NULL;
        }
    } else {
        LocalSymbolPath = SymbolPath;
    }

    NewImageSize = (ULONG) -1;  // Hack so we can tell when system images are skipped.

    time( (time_t *) &TimeStamp );

    if (!(*pReBaseImage64)( CurrentImageName,
                      (PCHAR) LocalSymbolPath,
                      fReBase && !fSumOnly,
                      fRebaseSysfileOk,
                      fGoingDown,
                      ThisImageExpectedSize,
                      &OriginalImageSize,
                      &OriginalImageBase,
                      &NewImageSize,
                      &ThisImageRequestedBase,
                      TimeStamp ) ) {

        if (ThisImageRequestedBase == 0) {
            fprintf(stderr,
                    "REBASE: %-16s ***Grew too large (Size=0x%x; ExpectedSize=0x%x)\n",
                    FilePart,
                    OriginalImageSize,
                    ThisImageExpectedSize);
        } else {
            if (GetLastError() == ERROR_BAD_EXE_FORMAT) {
                if (fVerbose) {
                    fprintf( stderr,
                            "REBASE: %-16s DOS or OS/2 image ignored\n",
                            FilePart );
                }
            } else
            if (GetLastError() == ERROR_INVALID_ADDRESS) {
                fprintf( stderr,
                        "REBASE: %-16s Rebase failed.  Relocations are missing or new address is invalid\n",
                        FilePart );
                if (RebaseLog) {
                    fprintf( RebaseLog,
                             "%16s based at 0x%016I64x (size 0x%08x)  Unable to rebase. (missing relocations or new address is invalid)\n",
                             FilePart,
                             OriginalImageBase,
                             OriginalImageSize);
                }
            } else {
                fprintf( stderr,
                        "REBASE: *** RelocateImage failed (%s).  Image may be corrupted\n",
                        FilePart );
            }
        }

        ReturnCode = REBASE_ERR;
        return;

    } else {
        if (GetLastError() == ERROR_INVALID_DATA) {
            fprintf(stderr, "REBASE: Warning: DBG checksum did not match image.\n");
        }
    }

    // Keep track of the lowest base address.

    if (MinBase > NewImageBase) {
        MinBase = NewImageBase;
    }

    if ( fSumOnly || !fReBase ) {
        if (!fQuiet) {
            fprintf( stdout,
                     "REBASE: %16s mapped at %016I64x (size 0x%08x)\n",
                     FilePart,
                     OriginalImageBase,
                     OriginalImageSize);
        }
    } else {
        if (RebaseLog) {
            fprintf( RebaseLog,
                     "%16s rebased to 0x%016I64x (size 0x%08x)\n",
                     FilePart,
                     fGoingDown ? ThisImageRequestedBase : NewImageBase,
                     NewImageSize);
        }

        if ((NewImageSize != (ULONG64) -1) &&
            (OriginalImageBase != (fGoingDown ? ThisImageRequestedBase : NewImageBase)) &&
            ( fVerbose || fQuiet )
           ) {
            if ( fVerbose ) {
                fprintf( stdout,
                         "REBASE: %16s initial base at 0x%016I64x (size 0x%08x)\n",
                         FilePart,
                         OriginalImageBase,
                         OriginalImageSize);
            }

            fprintf( stdout,
                     "REBASE: %16s rebased to 0x%016I64x (size 0x%08x)\n",
                     FilePart,
                     fGoingDown ? ThisImageRequestedBase : NewImageBase,
                     NewImageSize);

            if ( fVerbose && (fSplitSymbols || fUpdateSymbolsOnly) && DebugFilePath[0]) {
                char szExt[_MAX_EXT];
                _splitpath(DebugFilePath, NULL, NULL, NULL, szExt);
                if (_stricmp(szExt, ".pdb")) {
                    fprintf( stdout, "REBASE: %16s updated image base in %s\n", FilePart, DebugFilePath );
                }
            }
        }

        if (fRemoveRelocs) {
            RemoveRelocations(CurrentImageName);
        }
    }

    if ( CoffBaseDotTxt ) {
        if ( !fCoffBaseIncExt ) {
            char *n;
            if ( n  = strrchr(FilePart,'.') ) {
                *n = '\0';
            }
        }

        fprintf( CoffBaseDotTxt,
                 "%-16s 0x%016I64x 0x%08x\n",
                 FilePart,
                 fSumOnly ? OriginalImageBase : (fGoingDown ? ThisImageRequestedBase : NewImageBase),
                 NewImageSize);
    }

    NewImageBase = ThisImageRequestedBase;   // Set up the next one...
}

ULONG64
FindInBaseAddrFile(
    LPSTR Name,
    PULONG pulSize
    )
{

    struct {
        CHAR  Name[MAX_PATH+1];
        ULONG64 Base;
        ULONG Size;
    } BAFileEntry;

    CHAR NameNoExt[MAX_PATH+1];
//    PCHAR pchExt;
    int ateof;


    strcpy(NameNoExt,Name);
//    if (pchExt = strrchr(NameNoExt,'.')) {
//        *pchExt = '\0';
//        }

    fseek(BaseAddrFile, 0, SEEK_SET);

    ateof = fscanf(BaseAddrFile,"%s %I64x %x",BAFileEntry.Name,&BAFileEntry.Base,&BAFileEntry.Size);
    while ( ateof && ateof != EOF ) {
        if ( !_stricmp(NameNoExt,BAFileEntry.Name) ) {
            *pulSize = BAFileEntry.Size;
            return BAFileEntry.Base;
            }
        ateof = fscanf(BaseAddrFile,"%s %I64x %x",BAFileEntry.Name,&BAFileEntry.Base,&BAFileEntry.Size);
        }

    *pulSize = 0;
    return 0;
}

VOID
RemoveRelocations(
    PCHAR ImageName
    )
{
    // UnSafe...

    LOADED_IMAGE li;
    IMAGE_SECTION_HEADER RelocSectionHdr, *Section, *pRelocSecHdr;
    PIMAGE_DEBUG_DIRECTORY DebugDirectory;
    ULONG DebugDirectorySize, i, RelocSecNum;
    PIMAGE_OPTIONAL_HEADER32 OptionalHeader32 = NULL;
    PIMAGE_OPTIONAL_HEADER64 OptionalHeader64 = NULL;
    PIMAGE_FILE_HEADER FileHeader;

    if (!MapAndLoad(ImageName, NULL, &li, FALSE, FALSE)) {
        return;
    }

    FileHeader = &li.FileHeader->FileHeader;

    OptionalHeadersFromNtHeaders((PIMAGE_NT_HEADERS32)li.FileHeader, &OptionalHeader32, &OptionalHeader64);

    // See if the image has already been stripped or there are no relocs.

    if ((FileHeader->Characteristics & IMAGE_FILE_RELOCS_STRIPPED) ||
        (!OPTIONALHEADER(DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size))) {
        UnMapAndLoad(&li);
        return;
    }

    for (Section = li.Sections, i = 0; i < li.NumberOfSections; Section++, i++) {
        if (Section->PointerToRawData != 0) {
            if (!_stricmp( (char *) Section->Name, ".reloc" )) {
                RelocSectionHdr = *Section;
                pRelocSecHdr = Section;
                RelocSecNum = i + 1;
            }
        }
    }

    RelocSectionHdr.Misc.VirtualSize = ROUNDUP(RelocSectionHdr.Misc.VirtualSize, OPTIONALHEADER(SectionAlignment));
    RelocSectionHdr.SizeOfRawData = ROUNDUP(RelocSectionHdr.SizeOfRawData, OPTIONALHEADER(FileAlignment));

    if (RelocSecNum != li.NumberOfSections) {
        // Move everything else up and fixup old addresses.
        for (i = RelocSecNum - 1, Section = pRelocSecHdr;i < li.NumberOfSections - 1; Section++, i++) {
            *Section = *(Section + 1);
            Section->VirtualAddress -= RelocSectionHdr.Misc.VirtualSize;
            Section->PointerToRawData -= RelocSectionHdr.SizeOfRawData;
        }
    }

    // Zero out the last one.

    RtlZeroMemory(Section, sizeof(IMAGE_SECTION_HEADER));

    // Reduce the section count.

    FileHeader->NumberOfSections--;

    // Set the strip bit in the header

    FileHeader->Characteristics |= IMAGE_FILE_RELOCS_STRIPPED;

    // If there's a pointer to the coff symbol table, move it back.

    if (FileHeader->PointerToSymbolTable) {
        FileHeader->PointerToSymbolTable -= RelocSectionHdr.SizeOfRawData;
    }

    // Clear out the base reloc entry in the data dir.

    OPTIONALHEADER_LV(DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size) = 0;
    OPTIONALHEADER_LV(DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress) = 0;

    // Reduce the Init Data size.

    OPTIONALHEADER_LV(SizeOfInitializedData) -= RelocSectionHdr.Misc.VirtualSize;

    // Reduce the image size.

    OPTIONALHEADER_LV(SizeOfImage) -=
        ((RelocSectionHdr.SizeOfRawData +
          (OPTIONALHEADER(SectionAlignment) - 1)
         ) & ~(OPTIONALHEADER(SectionAlignment) - 1));

    // Move the debug info up (if there is any).

    DebugDirectory = (PIMAGE_DEBUG_DIRECTORY)
                            ImageDirectoryEntryToData( li.MappedAddress,
                                                      FALSE,
                                                      IMAGE_DIRECTORY_ENTRY_DEBUG,
                                                      &DebugDirectorySize
                                                    );
    if (DebugDirectoryIsUseful(DebugDirectory, DebugDirectorySize)) {
        for (i = 0; i < (DebugDirectorySize / sizeof(IMAGE_DEBUG_DIRECTORY)); i++) {
            RtlMoveMemory(li.MappedAddress + DebugDirectory->PointerToRawData - RelocSectionHdr.SizeOfRawData,
                            li.MappedAddress + DebugDirectory->PointerToRawData,
                            DebugDirectory->SizeOfData);

            DebugDirectory->PointerToRawData -= RelocSectionHdr.SizeOfRawData;

            if (DebugDirectory->AddressOfRawData) {
                DebugDirectory->AddressOfRawData -= RelocSectionHdr.Misc.VirtualSize;
            }

            DebugDirectory++;
        }
    }

    // Truncate the image size

    li.SizeOfImage -= RelocSectionHdr.SizeOfRawData;

    // And we're done.

    UnMapAndLoad(&li);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\sources.inc ===
MAJORCOMP=sdktools
MINORCOMP=imagehlp

TARGETPATH=obj
TARGETPATHLIB=$(BASEDIR)\public\sdk\lib
TARGETTYPE=DYNLINK
#DLLENTRY=ImageHlpDllEntry
DLLENTRY=_DllMainCRTStartup
DLLDEF=$(O)\imagehlp.def

INCLUDES=..; \
         $(BASEDIR)\private\sdktools\vctools\pdb6\langapi\include; \

USE_MSVCRT=1
NO_NTDLL=1

TARGETLIBS=\
    $(LIBRARY_PATH)\kernel32.lib \
    ..\*\msdbi60L.lib

MSC_WARNING_LEVEL=/W3 /WX

C_DEFINES=$(C_DEFINES) -DCC_CVTYPE32 -D_VC_VER_INC -DIMAGEHLPSRC

UMTYPE=console
SUBSYSTEM_VERSION=4.00
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\smashlck.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    smashlck.c

Abstract:

    This function smashes lock prefixes replacing them with NOPs

Author:

    Mark Lucovsky (markl) 30-Apr-1993

Revision History:

--*/

#include <private.h>


BOOL fVerbose;
BOOL fUpdate;
BOOL fUsage;

UCHAR LockPrefixOpcode = 0xf0;
UCHAR NoOpOpcode = 0x90;

LPSTR CurrentImageName;
PIMAGE_OPTIONAL_HEADER32 OptionalHeader32;
PIMAGE_OPTIONAL_HEADER64 OptionalHeader64;
PIMAGE_FILE_HEADER FileHeader;
LOADED_IMAGE CurrentImage;
CHAR DebugFilePath[_MAX_PATH];
LPSTR SymbolPath;

PVOID
ImageVaToLoadVa(
    PVOID ImageVa,
    PLOADED_IMAGE Image
    )
{
    PIMAGE_SECTION_HEADER Section;
    ULONG i, Rva;
    PVOID Va;
    PIMAGE_OPTIONAL_HEADER32 OptionalHeader32 = NULL;
    PIMAGE_OPTIONAL_HEADER64 OptionalHeader64 = NULL;
    PIMAGE_FILE_HEADER FileHeader;

    FileHeader = &((PIMAGE_NT_HEADERS32)Image->FileHeader)->FileHeader;

    OptionalHeadersFromNtHeaders((PIMAGE_NT_HEADERS32)Image->FileHeader,
                                 &OptionalHeader32,
                                 &OptionalHeader64);

    Rva = (ULONG)((ULONG_PTR)((PUCHAR)ImageVa - (PUCHAR)OPTIONALHEADER(ImageBase)));
    Va = NULL;
    Section = Image->LastRvaSection;
    if ( Rva >= Section->VirtualAddress &&
         Rva < (Section->VirtualAddress + Section->SizeOfRawData) ) {
        Va = (PVOID)(Rva - Section->VirtualAddress + Section->PointerToRawData + Image->MappedAddress);
    } else {
        for(Section = Image->Sections,i=0; i<Image->NumberOfSections; i++,Section++) {
            if ( Rva >= Section->VirtualAddress &&
                 Rva < (Section->VirtualAddress + Section->SizeOfRawData) ) {
                Va = (PVOID)(Rva - Section->VirtualAddress + Section->PointerToRawData + Image->MappedAddress);
                Image->LastRvaSection = Section;
                break;
            }
        }
    }
    if ( !Va ) {
        fprintf(stderr,"SMASHLOCK: ImageVaToLoadVa %p in image %p failed\n",ImageVa,Image);
    }
    return Va;
}

int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    DWORD dw;
    LPSTR FilePart;
    CHAR Buffer[MAX_PATH];
    PIMAGE_LOAD_CONFIG_DIRECTORY ConfigInfo;
    ULONG whocares;
    char c, *p;
    BOOLEAN LocksSmashed;
    ULONG CheckSum;
    ULONG HeaderSum;
    ULONG OldChecksum;
    int   retval = 0;

    fUsage = FALSE;
    fVerbose = FALSE;
    fUpdate = FALSE;

    _tzset();

    if (argc <= 1) {
        goto showUsage;
    }

    while (--argc) {
        p = *++argv;
        if (*p == '/' || *p == '-') {
            while (c = *++p)
            switch (toupper( c )) {
                case '?':
                    fUsage = TRUE;
                    break;

                case 'V':
                    fVerbose = TRUE;
                    break;

                case 'U':
                    fUpdate = TRUE;
                    break;

                case 'S':
                    argc--, argv++;
                    SymbolPath = *argv;
                    break;

                default:
                    fprintf( stderr, "SMASHLOCK: Invalid switch - /%c\n", c );
                    fUsage = TRUE;
                    break;
            }

            if ( fUsage ) {
showUsage:
                fputs("usage: SMASHLOCK [switches] image-names... \n"
                      "              [-?] display this message\n"
                      "              [-u] update image\n"
                      "              [-v] verbose output\n"
                      "              [-s] path to symbol files\n", stderr );
                exit(1);
            }
        } else {
            LocksSmashed = FALSE;

            CurrentImageName = p;
            dw = GetFullPathName(CurrentImageName,sizeof(Buffer),Buffer,&FilePart);
            if ( dw == 0 || dw > sizeof(Buffer) ) {
                FilePart = CurrentImageName;
            }

            //
            // Map and load the current image
            //

            if ( MapAndLoad(CurrentImageName, NULL, &CurrentImage, FALSE, !fUpdate )) {

                FileHeader = &((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader)->FileHeader;

                OptionalHeadersFromNtHeaders((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader,
                                             &OptionalHeader32,
                                             &OptionalHeader64);
                //
                // make sure the image has correct configuration information,
                // and that the LockPrefixTable is set up properly
                //

                ConfigInfo = (PIMAGE_LOAD_CONFIG_DIRECTORY)ImageDirectoryEntryToData(
                                                                CurrentImage.MappedAddress,
                                                                FALSE,
                                                                IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG,
                                                                &whocares
                                                                );
                if ( ConfigInfo && ConfigInfo->LockPrefixTable ) {

                    //
                    // Walk through the lock prefix table
                    //

                    PUCHAR *LockPrefixs;
                    PUCHAR LockPrefix;

                    LockPrefixs =  (PUCHAR *)ImageVaToLoadVa((PVOID)ConfigInfo->LockPrefixTable,&CurrentImage);

                    while(LockPrefixs && *LockPrefixs) {
                        LockPrefix = (PUCHAR) ImageVaToLoadVa(*LockPrefixs,&CurrentImage);
                        if ( LockPrefix && *LockPrefix == LockPrefixOpcode ) {
                            if (fVerbose) {
                                printf("LockPrefix Found at 0x%p = %x\n",*LockPrefixs,*LockPrefix);
                            }
                            if (fUpdate) {
                                LocksSmashed = TRUE;
                                *LockPrefix = NoOpOpcode;
                            }
                        }
                        LockPrefixs++;
                    }
                }

                if ( fUpdate && LocksSmashed ) {

                    //
                    // recompute the checksum.
                    //

                    OldChecksum = OPTIONALHEADER(CheckSum);
                    if ( CurrentImage.hFile != INVALID_HANDLE_VALUE ) {

                        OPTIONALHEADER_ASSIGN(CheckSum, 0);

                        CheckSumMappedFile(
                                    (PVOID)CurrentImage.MappedAddress,
                                    GetFileSize(CurrentImage.hFile, NULL),
                                    &HeaderSum,
                                    &CheckSum
                                    );

                        OPTIONALHEADER_ASSIGN(CheckSum, CheckSum);
                    }

                    FlushViewOfFile(CurrentImage.MappedAddress,0);
                    TouchFileTimes(CurrentImage.hFile,NULL);

                    // And update the .dbg file (if requested)
                    if (SymbolPath &&
                        FileHeader->Characteristics & IMAGE_FILE_DEBUG_STRIPPED) {
                        if ( UpdateDebugInfoFileEx( CurrentImageName,
                                                    SymbolPath,
                                                    DebugFilePath,
                                                    (PIMAGE_NT_HEADERS32) CurrentImage.FileHeader,
                                                    OldChecksum) ) {
                            if (GetLastError() == ERROR_INVALID_DATA) {
                                printf( "Warning: Old checksum did not match for %s\n", DebugFilePath);
                                }
                            printf("Updated symbols for %s\n", DebugFilePath);
                        } else {
                            printf("Unable to update symbols: %s\n", DebugFilePath);
                            retval=1;
                        }
                    }
                }

                UnmapViewOfFile(CurrentImage.MappedAddress);
                if ( CurrentImage.hFile != INVALID_HANDLE_VALUE ) {
                    CloseHandle(CurrentImage.hFile);
                }
                ZeroMemory(&CurrentImage,sizeof(CurrentImage));
            } else {
                if (!CurrentImage.fSystemImage && !CurrentImage.fDOSImage) {
                    fprintf(stderr,"SMASHLOCK: failure mapping and loading %s\n",CurrentImageName);
                    retval=1;
                }
            }
        }
    }

    return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\rebasei.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    rebase.c

Abstract:

    Source file for the REBASE utility that takes a group of image files and
    rebases them so they are packed as closely together in the virtual address
    space as possible.

Author:

    Mark Lucovsky (markl) 30-Apr-1993

Revision History:

--*/

#include <private.h>

//
// byte swapping macros (LE/BE) used for IA64 relocations
// source != destination
//

#define SWAP_SHORT(_dst,_src)                                                  \
   ((((unsigned char *)_dst)[1] = ((unsigned char *)_src)[0]),                 \
    (((unsigned char *)_dst)[0] = ((unsigned char *)_src)[1]))

#define SWAP_INT(_dst,_src)                                                    \
   ((((unsigned char *)_dst)[3] = ((unsigned char *)_src)[0]),                 \
    (((unsigned char *)_dst)[2] = ((unsigned char *)_src)[1]),                 \
    (((unsigned char *)_dst)[1] = ((unsigned char *)_src)[2]),                 \
    (((unsigned char *)_dst)[0] = ((unsigned char *)_src)[3]))

#define SWAP_LONG_LONG(_dst,_src)                                              \
   ((((unsigned char *)_dst)[7] = ((unsigned char *)_src)[0]),                 \
    (((unsigned char *)_dst)[6] = ((unsigned char *)_src)[1]),                 \
    (((unsigned char *)_dst)[5] = ((unsigned char *)_src)[2]),                 \
    (((unsigned char *)_dst)[4] = ((unsigned char *)_src)[3]),                 \
    (((unsigned char *)_dst)[3] = ((unsigned char *)_src)[4]),                 \
    (((unsigned char *)_dst)[2] = ((unsigned char *)_src)[5]),                 \
    (((unsigned char *)_dst)[1] = ((unsigned char *)_src)[6]),                 \
    (((unsigned char *)_dst)[0] = ((unsigned char *)_src)[7]))


#define REBASE_ERR 99
#define REBASE_OK  0

static
PVOID
RvaToVa(
    ULONG Rva,
    PLOADED_IMAGE Image
    );

typedef
PIMAGE_BASE_RELOCATION
(WINAPI *LPRELOCATE_ROUTINE)(
    IN ULONG_PTR VA,
    IN ULONG SizeOfBlock,
    IN PUSHORT NextOffset,
    IN LONG_PTR Diff
    );

typedef
PIMAGE_BASE_RELOCATION
(WINAPI *LPRELOCATE_ROUTINE64)(
    IN ULONG_PTR VA,
    IN ULONG SizeOfBlock,
    IN PUSHORT NextOffset,
    IN LONGLONG Diff
    );


static LPRELOCATE_ROUTINE RelocRoutineNative;
static LPRELOCATE_ROUTINE64 RelocRoutine64;

PIMAGE_BASE_RELOCATION
xxLdrProcessRelocationBlock64(
    IN ULONG_PTR VA,
    IN ULONG SizeOfBlock,
    IN PUSHORT NextOffset,
    IN LONGLONG Diff
    );



#define x256MEG (256*(1024*1024))

#define x256MEGSHIFT 28

#define ROUND_UP( Size, Amount ) (((ULONG)(Size) + ((Amount) - 1)) & ~((Amount) - 1))

VOID
AdjImageBaseSize(
    PULONG  pImageBase,
    PULONG  ImageSize,
    BOOL    fGoingDown
    );


BOOL
RelocateImage(
    PLOADED_IMAGE LoadedImage,
    ULONG64 NewBase,
    ULONG64 *Diff,
    ULONG tstamp
    );

BOOL
ReBaseImage(
    IN     LPSTR CurrentImageName,
    IN     LPSTR SymbolPath,        // Symbol path (if
    IN     BOOL  fReBase,           // TRUE if actually rebasing, false if only summing
    IN     BOOL  fRebaseSysfileOk,  // TRUE is system images s/b rebased
    IN     BOOL  fGoingDown,        // TRUE if the image s/b rebased below the given base
    IN     ULONG CheckImageSize,    // Max size allowed  (0 if don't care)
    OUT    ULONG *OldImageSize,     // Returned from the header
    OUT    ULONG_PTR *OldImageBase, // Returned from the header
    OUT    ULONG *NewImageSize,     // Image size rounded to next separation boundary
    IN OUT ULONG_PTR *NewImageBase, // (in) Desired new address.
                                    // (out) Next new address (above/below this one)
    IN     ULONG tstamp             // new timestamp for image
    )
{
    ULONG64 xOldImageBase = *OldImageBase;
    ULONG64 xNewImageBase = *NewImageBase;
    BOOL rc;

    rc = ReBaseImage64(
        CurrentImageName,
        SymbolPath,
        fReBase,
        fRebaseSysfileOk,
        fGoingDown,
        CheckImageSize,
        OldImageSize,
        &xOldImageBase,
        NewImageSize,
        &xNewImageBase,
        tstamp);

    *OldImageBase = (ULONG_PTR)xOldImageBase;
    *NewImageBase = (ULONG_PTR)xNewImageBase;
    return rc;
}

BOOL
ReBaseImage64(
    IN     LPSTR CurrentImageName,
    IN     LPSTR SymbolPath,       // Symbol path (if
    IN     BOOL  fReBase,          // TRUE if actually rebasing, false if only summing
    IN     BOOL  fRebaseSysfileOk, // TRUE is system images s/b rebased
    IN     BOOL  fGoingDown,       // TRUE if the image s/b rebased below the given base
    IN     ULONG CheckImageSize,   // Max size allowed  (0 if don't care)
    OUT    ULONG *OldImageSize,    // Returned from the header
    OUT    ULONG64 *OldImageBase,  // Returned from the header
    OUT    ULONG *NewImageSize,    // Image size rounded to next separation boundary
    IN OUT ULONG64 *NewImageBase,  // (in) Desired new address.
                                   // (out) Next new address (above/below this one)
    IN     ULONG tstamp            // new timestamp for image
    )
{
    BOOL  fSymbolsAlreadySplit = FALSE;
    CHAR  DebugFileName[ MAX_PATH+1 ];
    CHAR  DebugFilePath[ MAX_PATH+1 ];
    ULONG CurrentImageSize;
    ULONG64 DesiredImageBase;
    ULONG OldChecksum;
    ULONG64 Diff = 0;
    ULONG UpdateSymbolsError = 0;
    LOADED_IMAGE CurrentImage;

    BOOL rc = TRUE;

    if (fReBase && (*NewImageBase & 0x0000FFFF) != 0) {
        rc = FALSE;
        UpdateSymbolsError = ERROR_INVALID_ADDRESS;
        goto Exit;
    }

    // Map and load the current image

    if ( MapAndLoad( CurrentImageName, NULL, &CurrentImage, FALSE, fReBase ? FALSE : TRUE ) ) {
        PVOID pCertificates;
        DWORD dwCertificateSize;
        pCertificates = ImageDirectoryEntryToData(
                                                  CurrentImage.MappedAddress,
                                                  FALSE,
                                                  IMAGE_DIRECTORY_ENTRY_SECURITY,
                                                  &dwCertificateSize
                                                  );

        if (pCertificates || dwCertificateSize) {
            UpdateSymbolsError = ERROR_BAD_EXE_FORMAT;
            rc = FALSE;
            goto CleanupAndExit;
        }

        if (!(!fRebaseSysfileOk && CurrentImage.fSystemImage)) {
            fSymbolsAlreadySplit = CurrentImage.Characteristics & IMAGE_FILE_DEBUG_STRIPPED ? TRUE : FALSE;
            if ( fSymbolsAlreadySplit ) {

                // Find DebugFileName for later use.

                PIMAGE_DEBUG_DIRECTORY DebugDirectories;
                ULONG DebugDirectoriesSize;
                PIMAGE_DEBUG_MISC MiscDebug;

                strcpy( DebugFileName, CurrentImageName );

                DebugDirectories = (PIMAGE_DEBUG_DIRECTORY)ImageDirectoryEntryToData(
                                                        CurrentImage.MappedAddress,
                                                        FALSE,
                                                        IMAGE_DIRECTORY_ENTRY_DEBUG,
                                                        &DebugDirectoriesSize
                                                        );
                if (DebugDirectoryIsUseful(DebugDirectories, DebugDirectoriesSize)) {
                    while (DebugDirectoriesSize != 0) {
                        if (DebugDirectories->Type == IMAGE_DEBUG_TYPE_MISC) {
                            MiscDebug = (PIMAGE_DEBUG_MISC)
                                ((PCHAR)CurrentImage.MappedAddress +
                                 DebugDirectories->PointerToRawData
                                );
                            strcpy( DebugFileName, (PCHAR) MiscDebug->Data );
                            break;
                        }
                        else {
                            DebugDirectories += 1;
                            DebugDirectoriesSize -= sizeof( *DebugDirectories );
                        }
                    }
                }
            }

            if (CurrentImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
                CurrentImageSize = ((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader)->OptionalHeader.SizeOfImage;
                *OldImageBase = ((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader)->OptionalHeader.ImageBase;
            } else {
                CurrentImageSize = ((PIMAGE_NT_HEADERS64)CurrentImage.FileHeader)->OptionalHeader.SizeOfImage;
                *OldImageBase = ((PIMAGE_NT_HEADERS64)CurrentImage.FileHeader)->OptionalHeader.ImageBase;
            }

            // Save the current settings for the caller.

            *OldImageSize = CurrentImageSize;
            *NewImageSize = ROUND_UP( CurrentImageSize, IMAGE_SEPARATION );

            if (CheckImageSize) {
                // The user asked for a max size test.

                if ( *NewImageSize > ROUND_UP(CheckImageSize, IMAGE_SEPARATION) ) {
                    *NewImageBase = 0;
                    rc = FALSE;
                    goto CleanupAndExit;
                }
            }

            DesiredImageBase = *NewImageBase;

            // So long as we're not basing to zero or rebasing to the same address,
            // go for it.

            if (fReBase) {
                BOOL fAdjust;
                if ((CurrentImage.FileHeader->FileHeader.Machine != IMAGE_FILE_MACHINE_I386) &&
                    (CurrentImage.FileHeader->FileHeader.Machine != IMAGE_FILE_MACHINE_ALPHA) &&
                    (CurrentImage.FileHeader->FileHeader.Machine != IMAGE_FILE_MACHINE_ALPHA64) &&
                    (CurrentImage.FileHeader->FileHeader.Machine != IMAGE_FILE_MACHINE_IA64))
                {
                    fAdjust = TRUE;
                } else {
                    fAdjust = FALSE;
                }

                if (fGoingDown) {
                    DesiredImageBase -= *NewImageSize;
                    if (fAdjust) {
                        AdjImageBaseSize( (PULONG)&DesiredImageBase, &CurrentImageSize, fGoingDown );
                    }
                }

                if ((DesiredImageBase) &&
                    (DesiredImageBase != *OldImageBase)
                   ) {

                    if (CurrentImage.FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
                        OldChecksum = ((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader)->OptionalHeader.CheckSum;
                    } else {
                        OldChecksum = ((PIMAGE_NT_HEADERS64)CurrentImage.FileHeader)->OptionalHeader.CheckSum;
                    }
                    if ( !RelocateImage( &CurrentImage, DesiredImageBase, &Diff, tstamp ) ) {
                        UpdateSymbolsError = GetLastError();
                        rc = FALSE;
                        goto CleanupAndExit;
                    }

                    if ( fSymbolsAlreadySplit && Diff ) {
                        if ( UpdateDebugInfoFileEx(CurrentImageName,
                                                   SymbolPath,
                                                   DebugFilePath,
                                                   (PIMAGE_NT_HEADERS32)(CurrentImage.FileHeader),
                                                   OldChecksum )) {
                            UpdateSymbolsError = GetLastError();
                        } else {
                            UpdateSymbolsError = 0;
                        }
                    }
                } else {
                    //
                    // Should this be -1??  shouldn't it be 0 instead? - kentf
                    //
                    Diff = (ULONG) -1;
                }

                if (!fGoingDown && Diff) {
                    DesiredImageBase += *NewImageSize;
                    if (fAdjust) {
                        AdjImageBaseSize( (PULONG)&DesiredImageBase, &CurrentImageSize, fGoingDown );
                    }
                }

            }
        }

        if (fReBase) {
            if (Diff) {
                *NewImageBase = DesiredImageBase;
            } else {
                UpdateSymbolsError = ERROR_INVALID_ADDRESS;
                rc = FALSE;
                goto CleanupAndExit;
            }
        }
    } else {
        if (CurrentImage.fDOSImage == TRUE) {
            UpdateSymbolsError = ERROR_BAD_EXE_FORMAT;
        } else {
            UpdateSymbolsError = GetLastError();
        }
        rc = FALSE;
        goto Exit;
    }

CleanupAndExit:
    UnmapViewOfFile( CurrentImage.MappedAddress );
    if ( CurrentImage.hFile != INVALID_HANDLE_VALUE ) {
        CloseHandle( CurrentImage.hFile );
    }
    ZeroMemory( &CurrentImage, sizeof( CurrentImage ) );

Exit:

    SetLastError(UpdateSymbolsError);

    return(TRUE);
}


VOID
AdjImageBaseSize (
    PULONG pulImageBase,
    PULONG pulImageSize,
    BOOL   fGoingDown
    )
{

    DWORD Meg1, Meg2, Delta;

    //
    // ImageBase is the base for the current image. Make sure that
    // the image does not span a 256Mb boundry. This is due to an r4000
    // chip bug that has problems computing the correct address for absolute
    // jumps that occur in the last few instructions of a 256mb region
    //

    Meg1 = *pulImageBase >> x256MEGSHIFT;
    Meg2 = ( *pulImageBase + ROUND_UP( *pulImageSize, IMAGE_SEPARATION ) ) >> x256MEGSHIFT;

    if ( Meg1 != Meg2 ) {

        //
        // If we are going down, then subtract the overlap from ThisBase
        //

        if ( fGoingDown ) {

            Delta = ( *pulImageBase + ROUND_UP( *pulImageSize, IMAGE_SEPARATION ) ) -
                    ( Meg2 << x256MEGSHIFT );
            Delta += IMAGE_SEPARATION;
            *pulImageBase = *pulImageBase - Delta;
            *pulImageSize += Delta;
            }
        else {
            Delta = ( Meg2 << x256MEGSHIFT ) - *pulImageBase;
            *pulImageBase += Delta;
            *pulImageSize += Delta;
            }
        }
}

BOOL
RelocateImage(
    PLOADED_IMAGE LoadedImage,
    ULONG64 NewBase,
    ULONG64 *Diff,
    ULONG tstamp
    )
{
    ULONG TotalCountBytes;
    ULONG_PTR VA;
    ULONG64 OldBase;
    ULONG SizeOfBlock;
    PUSHORT NextOffset;
    PIMAGE_NT_HEADERS NtHeaders;
    PIMAGE_BASE_RELOCATION NextBlock;
    ULONG CheckSum;
    ULONG HeaderSum;
    PIMAGE_FILE_HEADER FileHeader;

    static BOOL  fInit = FALSE;

    if (!fInit) {

        RelocRoutineNative = (LPRELOCATE_ROUTINE)GetProcAddress(GetModuleHandle("ntdll"), "LdrProcessRelocationBlock");

#ifdef _WIN64
        RelocRoutine64 = RelocRoutineNative;
#else
        RelocRoutine64 = xxLdrProcessRelocationBlock64;
#endif
    }

    NtHeaders = LoadedImage->FileHeader;
    FileHeader = &NtHeaders->FileHeader;
    if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
        OldBase = ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.ImageBase;
    } else {
        OldBase = ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.ImageBase;
    }

    //
    // Locate the relocation section.
    //

    NextBlock = (PIMAGE_BASE_RELOCATION)ImageDirectoryEntryToData(
                                            LoadedImage->MappedAddress,
                                            FALSE,
                                            IMAGE_DIRECTORY_ENTRY_BASERELOC,
                                            &TotalCountBytes
                                            );

    if (!NextBlock || !TotalCountBytes) {

        //
        // The image does not contain a relocation table, and therefore
        // cannot be relocated.
        //

        return TRUE;
    }

    *Diff = NewBase - OldBase;

    //
    // If the image has a relocation table, then apply the specified fixup
    // information to the image.
    //

    while (TotalCountBytes) {
        SizeOfBlock = NextBlock->SizeOfBlock;
        TotalCountBytes -= SizeOfBlock;
        SizeOfBlock -= sizeof(IMAGE_BASE_RELOCATION);
        SizeOfBlock /= sizeof(USHORT);
        NextOffset = (PUSHORT)(NextBlock + 1);

        //
        // Compute the address and value for the fixup.
        //

        if ( SizeOfBlock ) {
            VA = (ULONG_PTR)RvaToVa(NextBlock->VirtualAddress,LoadedImage);
            if ( !VA ) {
                NtHeaders->Signature = (ULONG)-1;
                return FALSE;
                }

            if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
                if ( !(NextBlock = (RelocRoutine64)(VA,SizeOfBlock,NextOffset,*Diff)) ) {
                    NtHeaders->Signature = (ULONG)-1;
                    return FALSE;
                }
            } else {
                if ( !(NextBlock = (RelocRoutineNative)(VA,SizeOfBlock,NextOffset,(LONG_PTR)*Diff)) ) {
                    NtHeaders->Signature = (ULONG)-1;
                    return FALSE;
                    }
                }
            }
        else {
            NextBlock++;
            }
        }

    if (tstamp) {
        FileHeader->TimeDateStamp = tstamp;
    } else {
        FileHeader->TimeDateStamp++;
    }

    if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
        ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.ImageBase = (ULONG)NewBase;
        if ( LoadedImage->hFile != INVALID_HANDLE_VALUE ) {

            ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.CheckSum = 0;

            CheckSumMappedFile(
                        (PVOID)LoadedImage->MappedAddress,
                        GetFileSize(LoadedImage->hFile, NULL),
                        &HeaderSum,
                        &CheckSum
                        );
            ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.CheckSum = CheckSum;
        }
    } else {
        ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.ImageBase = NewBase;
        if ( LoadedImage->hFile != INVALID_HANDLE_VALUE ) {
            ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.CheckSum = 0;

            CheckSumMappedFile(
                        (PVOID)LoadedImage->MappedAddress,
                        GetFileSize(LoadedImage->hFile, NULL),
                        &HeaderSum,
                        &CheckSum
                        );

            ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.CheckSum = CheckSum;
        }
    }

    FlushViewOfFile(LoadedImage->MappedAddress,0);
    TouchFileTimes(LoadedImage->hFile,NULL);
    return TRUE;
}


PVOID
RvaToVa(
    ULONG Rva,
    PLOADED_IMAGE Image
    )
{

    PIMAGE_SECTION_HEADER Section;
    ULONG i;
    PVOID Va;

    Va = NULL;
    Section = Image->LastRvaSection;
    if (Rva == 0) {
        // a NULL Rva will be sent if there are relocs before the first page
        //  (ie: we're relocating a system image)

        Va = Image->MappedAddress;

    } else {
        if ( Rva >= Section->VirtualAddress &&
             Rva < (Section->VirtualAddress + Section->SizeOfRawData) ) {
            Va = (PVOID)(Rva - Section->VirtualAddress + Section->PointerToRawData + Image->MappedAddress);
        } else {
            for(Section = Image->Sections,i=0; i<Image->NumberOfSections; i++,Section++) {
                if ( Rva >= Section->VirtualAddress &&
                     Rva < (Section->VirtualAddress + Section->SizeOfRawData) ) {
                    Va = (PVOID)(Rva - Section->VirtualAddress + Section->PointerToRawData + Image->MappedAddress);
                    Image->LastRvaSection = Section;
                    break;
                }
            }
        }
    }

    return Va;
}

PIMAGE_BASE_RELOCATION
xxLdrProcessRelocationBlock64(
    IN ULONG_PTR VA,
    IN ULONG SizeOfBlock,
    IN PUSHORT NextOffset,
    IN LONGLONG Diff
    )
{
    PUCHAR FixupVA;
    USHORT Offset;
    LONG Temp;
    ULONG Temp32;
    ULONGLONG Value64;
    LONGLONG Temp64;

    while (SizeOfBlock--) {

       Offset = *NextOffset & (USHORT)0xfff;
       FixupVA = (PUCHAR)(VA + Offset);

       //
       // Apply the fixups.
       //

       switch ((*NextOffset) >> 12) {

            case IMAGE_REL_BASED_HIGHLOW :
                //
                // HighLow - (32-bits) relocate the high and low half
                //      of an address.
                //
                *(LONG UNALIGNED *)FixupVA += (ULONG) Diff;
                break;

            case IMAGE_REL_BASED_HIGH :
                //
                // High - (16-bits) relocate the high half of an address.
                //
                Temp = *(PUSHORT)FixupVA << 16;
                Temp += (ULONG) Diff;
                *(PUSHORT)FixupVA = (USHORT)(Temp >> 16);
                break;

            case IMAGE_REL_BASED_HIGHADJ :
                //
                // Adjust high - (16-bits) relocate the high half of an
                //      address and adjust for sign extension of low half.
                //

                Temp = *(PUSHORT)FixupVA << 16;
                ++NextOffset;
                --SizeOfBlock;
                Temp += (LONG)(*(PSHORT)NextOffset);
                Temp += (ULONG) Diff;
                Temp += 0x8000;
                *(PUSHORT)FixupVA = (USHORT)(Temp >> 16);
                break;

            case IMAGE_REL_BASED_LOW :
                //
                // Low - (16-bit) relocate the low half of an address.
                //
                Temp = *(PSHORT)FixupVA;
                Temp += (ULONG) Diff;
                *(PUSHORT)FixupVA = (USHORT)Temp;
                break;

#if 0
            case IMAGE_REL_BASED_IA64_IMM64:

                //
                // Align it to bundle address before fixing up the
                // 64-bit immediate value of the movl instruction.
                //

                FixupVA = (PUCHAR)((ULONG_PTR)FixupVA & ~(15));
                Value64 = (ULONGLONG)0;

                //
                // Extract the lower 32 bits of IMM64 from bundle
                //


                EXT_IMM64(Value64,
                        (PULONG)FixupVA + EMARCH_ENC_I17_IMM7B_INST_WORD_X,
                        EMARCH_ENC_I17_IMM7B_SIZE_X,
                        EMARCH_ENC_I17_IMM7B_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM7B_VAL_POS_X);
                EXT_IMM64(Value64,
                        (PULONG)FixupVA + EMARCH_ENC_I17_IMM9D_INST_WORD_X,
                        EMARCH_ENC_I17_IMM9D_SIZE_X,
                        EMARCH_ENC_I17_IMM9D_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM9D_VAL_POS_X);
                EXT_IMM64(Value64,
                        (PULONG)FixupVA + EMARCH_ENC_I17_IMM5C_INST_WORD_X,
                        EMARCH_ENC_I17_IMM5C_SIZE_X,
                        EMARCH_ENC_I17_IMM5C_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM5C_VAL_POS_X);
                EXT_IMM64(Value64,
                        (PULONG)FixupVA + EMARCH_ENC_I17_IC_INST_WORD_X,
                        EMARCH_ENC_I17_IC_SIZE_X,
                        EMARCH_ENC_I17_IC_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IC_VAL_POS_X);
                EXT_IMM64(Value64,
                        (PULONG)FixupVA + EMARCH_ENC_I17_IMM41a_INST_WORD_X,
                        EMARCH_ENC_I17_IMM41a_SIZE_X,
                        EMARCH_ENC_I17_IMM41a_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM41a_VAL_POS_X);

                //
                // Update 64-bit address
                //

                Value64+=Diff;
                Value64 = (__int64)(__int32)PtrToLong((PULONG)Value64);

                //
                // Insert IMM64 into bundle
                //

                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IMM7B_INST_WORD_X),
                        EMARCH_ENC_I17_IMM7B_SIZE_X,
                        EMARCH_ENC_I17_IMM7B_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM7B_VAL_POS_X);
                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IMM9D_INST_WORD_X),
                        EMARCH_ENC_I17_IMM9D_SIZE_X,
                        EMARCH_ENC_I17_IMM9D_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM9D_VAL_POS_X);
                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IMM5C_INST_WORD_X),
                        EMARCH_ENC_I17_IMM5C_SIZE_X,
                        EMARCH_ENC_I17_IMM5C_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM5C_VAL_POS_X);
                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IC_INST_WORD_X),
                        EMARCH_ENC_I17_IC_SIZE_X,
                        EMARCH_ENC_I17_IC_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IC_VAL_POS_X);
                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IMM41a_INST_WORD_X),
                        EMARCH_ENC_I17_IMM41a_SIZE_X,
                        EMARCH_ENC_I17_IMM41a_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM41a_VAL_POS_X);
                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IMM41b_INST_WORD_X),
                        EMARCH_ENC_I17_IMM41b_SIZE_X,
                        EMARCH_ENC_I17_IMM41b_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM41b_VAL_POS_X);
                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IMM41c_INST_WORD_X),
                        EMARCH_ENC_I17_IMM41c_SIZE_X,
                        EMARCH_ENC_I17_IMM41c_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM41c_VAL_POS_X);
                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_SIGN_INST_WORD_X),
                        EMARCH_ENC_I17_SIGN_SIZE_X,
                        EMARCH_ENC_I17_SIGN_INST_WORD_POS_X,
                        EMARCH_ENC_I17_SIGN_VAL_POS_X);
                break;

            case IMAGE_REL_BASED_DIR64:

                *(ULONGLONG UNALIGNED *)FixupVA += Diff;

                break;

            case IMAGE_REL_BASED_MIPS_JMPADDR :
                //
                // JumpAddress - (32-bits) relocate a MIPS jump address.
                //
                Temp = (*(PULONG)FixupVA & 0x3ffffff) << 2;
                Temp += (ULONG) Diff;
                *(PULONG)FixupVA = (*(PULONG)FixupVA & ~0x3ffffff) |
                                                ((Temp >> 2) & 0x3ffffff);

                break;

#endif // 0
            case IMAGE_REL_BASED_ABSOLUTE :
                //
                // Absolute - no fixup required.
                //
                break;

            case IMAGE_REL_BASED_SECTION :
                //
                // Section Relative reloc.  Ignore for now.
                //
                break;

            case IMAGE_REL_BASED_REL32 :
                //
                // Relative intrasection. Ignore for now.
                //
                break;

           case IMAGE_REL_BASED_HIGH3ADJ :
               //
               // Similar to HIGHADJ except this is the third word.
               //  Adjust low half of high dword of an address and adjust for
               //   sign extension of the low dword.
               //

               Temp64 = *(PUSHORT)FixupVA << 16;
               ++NextOffset;
               --SizeOfBlock;
               Temp64 += (LONG)((SHORT)NextOffset[1]);
               Temp64 <<= 16;
               Temp64 += (LONG)((USHORT)NextOffset[0]);
               Temp64 += Diff;
               Temp64 += 0x8000;
               Temp64 >>=16;
               Temp64 += 0x8000;
               *(PUSHORT)FixupVA = (USHORT)(Temp64 >> 16);
               ++NextOffset;
               --SizeOfBlock;
               break;

            default :
                //
                // Illegal - illegal relocation type.
                //

                return (PIMAGE_BASE_RELOCATION)NULL;
       }
       ++NextOffset;
    }
    return (PIMAGE_BASE_RELOCATION)NextOffset;
}



// Dummy stub so the rebase.exe that shipped with VC5/VC6 will load.
VOID
RemoveRelocations(
    PCHAR ImageName
    )
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\splitsym.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    splitsym.c

Abstract:

    This is the main source file for the SPLITSYM utility program.  This
    program can be used to split the debugging information contained in
    an executable image file into a separate .DBG file and strip it from
    the image file.  Allow stripped image files to be distributed which
    significantly reduces disk space requirements, but allows full
    debugging by accesing the associated .DBG files over the network
    when needed.

Author:

    Steve Wood (stevewo) 03-May-1993

Revision History:

--*/

#include <private.h>


BOOL fVerbose;
BOOL fRecurse;
ULONG SplitFlags = 0;

UCHAR RecurseDirectory[ MAX_PATH ];

UCHAR CurrentImageName[ MAX_PATH ];

UCHAR SymbolPath[ MAX_PATH ];

UCHAR DbgFileName[ MAX_PATH ];

VOID
SplitSymbolsInTree(
    LPSTR RootPath
    );

void
Usage( void )
{
    fputs ( "usage: SPLITSYM [-?] [-v] [-p] [-a] [-s symbol directory] [-r directory] image-names...\n"
            "              [-?] display this message\n"
            "              [-v] verbose output\n"
            "              [-p] remove private debug info when creating .dbg file\n"
            "              [-a] extract all debug info into .dbg file\n"
            "              [-r directory] - recursively process all image files.\n"
            "              [-s symbol directory] - where to put .DBG files.\n"
            "                                      Default is same place as image file.\n",
            stderr );
    exit( 1 );
}

int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    char c, *s;
    LPSTR FilePart;

    if (argc <= 1) {
        Usage();
        }

    SymbolPath[ 0 ] = '\0';
    while (--argc) {
        s = *++argv;
        if (*s == '/' || *s == '-') {
            while (c = *++s)
                switch (toupper( c )) {
                case '?':
                    Usage();
                    break;

                case 'V':
                    fVerbose = TRUE;
                    break;

                case 'R':
                    if (--argc) {
                        fRecurse = TRUE;
                        strcpy( (PCHAR) RecurseDirectory, *++argv );
                        }
                    else {
                        fprintf( stderr, "SPLITSYM: Argument to /%c switch missing\n", c );
                        Usage();
                        }
                    break;

                case 'S':
                    if (--argc) {
                        strcpy( (PCHAR) SymbolPath, *++argv );
                        }
                    else {
                        fprintf( stderr, "SPLITSYM: Argument to /%c switch missing\n", c );
                        Usage();
                        }
                    break;

                case 'P':
                    SplitFlags |= SPLITSYM_REMOVE_PRIVATE;
                    break;

                case 'A':
                    SplitFlags |= SPLITSYM_EXTRACT_ALL;
                    break;

                default:
                    fprintf( stderr, "SPLITSYM: Invalid switch - /%c\n", c );
                    Usage();
                    break;
                }
            }
        else {
            if (fRecurse) {
                fprintf( stderr, "SPLITSYM: May not specify specific file names with /R switch.\n" );
                Usage();
                }
            else
            if (!GetFullPathNameA( s, sizeof( CurrentImageName ), (PCHAR) CurrentImageName, &FilePart )) {
                fprintf( stderr, "SPLITSYM: invalid file name - %s (%u)\n", s, GetLastError() );
                }
            else {
                if (SplitSymbols( (PCHAR) CurrentImageName, (PCHAR) SymbolPath, (PCHAR) DbgFileName, SplitFlags )) {
                    if (fVerbose) {
                        fprintf( stdout,
                                 "SPLITSYM: %16s symbols split into %s\n",
                                 FilePart,
                                 DbgFileName
                               );
                        }
                    }
                else
                if (GetLastError() != ERROR_BAD_EXE_FORMAT &&
                    GetLastError() != ERROR_ALREADY_ASSIGNED
                   ) {
                    fprintf( stderr, "SPLITSYM: Unable to split symbols from '%s' into '%s' (%u)\n",
                             CurrentImageName,
                             DbgFileName,
                             GetLastError()
                           );
                    }
                }
            }
        }

    if (fRecurse) {
        SplitSymbolsInTree( (PCHAR) RecurseDirectory );
        }

    exit( 0 );
    return 0;
}


#define MAX_DEPTH 32

VOID
SplitSymbolsInTree(
    LPSTR RootPath
    )
{
    LPSTR FilePart;
    PUCHAR Prefix = (PUCHAR) "";
    CHAR PathBuffer[ MAX_PATH ];
    ULONG Depth;
    PCHAR PathTail[ MAX_DEPTH ];
    PCHAR FindHandle[ MAX_DEPTH ];
    LPWIN32_FIND_DATA FindFileData;
    UCHAR FindFileBuffer[ MAX_PATH + sizeof( WIN32_FIND_DATA ) ];

    strcpy( PathBuffer, RootPath );
    FindFileData = (LPWIN32_FIND_DATA)FindFileBuffer;
    Depth = 0;
    while (TRUE) {
startDirectorySearch:
        PathTail[ Depth ] = strchr( PathBuffer, '\0' );
        if (PathTail[ Depth ] > PathBuffer && PathTail[ Depth ][ -1 ] != '\\') {
            *(PathTail[ Depth ])++ = '\\';
            }

        strcpy( PathTail[ Depth ], "*.*" );
        FindHandle[ Depth ] = (PCHAR) FindFirstFile( PathBuffer, FindFileData );
        if (FindHandle[ Depth ] != INVALID_HANDLE_VALUE) {
            do {
                if (FindFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                    if (strcmp( FindFileData->cFileName, "." ) &&
                        strcmp( FindFileData->cFileName, ".." ) &&
                        Depth < MAX_DEPTH
                       ) {
                        sprintf( PathTail[ Depth ], "%s\\", FindFileData->cFileName );
                        Depth++;
                        goto startDirectorySearch;
                        }
                    }
                else
                if (!(FindFileData->dwFileAttributes & FILE_ATTRIBUTE_READONLY)) {
                    strcpy( PathTail[ Depth ], FindFileData->cFileName );
                    if (!GetFullPathNameA( PathBuffer, sizeof( CurrentImageName ), (PCHAR) CurrentImageName, &FilePart )) {
                        fprintf( stderr, "SPLITSYM: invalid file name - %s (%u)\n", PathBuffer, GetLastError() );
                        }
                    else {
                        if (SplitSymbols( (PCHAR) CurrentImageName, (PCHAR) SymbolPath, (PCHAR) DbgFileName, SplitFlags )) {
                            if (fVerbose) {
                                fprintf( stdout,
                                         "SPLITSYM: %16s symbols split into %s\n",
                                         FilePart,
                                         DbgFileName
                                       );
                                }
                            }
                        else
                        if (GetLastError() != ERROR_BAD_EXE_FORMAT ) {
                            fprintf( stderr, "SPLITSYM: Unable to split symbols from '%s' into '%s' (%u)\n",
                                     CurrentImageName,
                                     DbgFileName,
                                     GetLastError()
                                   );
                            }
                        }
                    }

restartDirectorySearch:
                ;
                }
            while (FindNextFile( FindHandle[ Depth ], FindFileData ));
            FindClose( FindHandle[ Depth ] );

            if (Depth == 0) {
                break;
                }

            Depth--;
            goto restartDirectorySearch;
            }
        }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\splitsymi.c ===
#include <private.h>

#define CLEAN_PD(addr) ((addr) & ~0x3)
#define CLEAN_PD64(addr) ((addr) & ~0x3UI64)


typedef struct NB10I                   // NB10 debug info
{
    DWORD   nb10;                      // NB10
    DWORD   off;                       // offset, always 0
    DWORD   sig;
    DWORD   age;
} NB10I;

BOOL
IMAGEAPI
SplitSymbols(
    LPSTR ImageName,
    LPSTR SymbolsPath,
    LPSTR SymbolFilePath,
    ULONG Flags
    )
{
#ifdef _WIN64
    return TRUE;
#else
    // UnSafe...

    HANDLE FileHandle, SymbolFileHandle;
    HANDLE hMappedFile;
    LPVOID ImageBase;
    PIMAGE_NT_HEADERS32 NtHeaders;
    LPSTR ImageFileName;
    DWORD SizeOfSymbols;
    ULONG_PTR ImageNameOffset;
    ULONG_PTR DebugSectionStart;
    PIMAGE_SECTION_HEADER DebugSection = NULL;
    DWORD SectionNumber, BytesWritten, NewFileSize, HeaderSum, CheckSum;
    PIMAGE_DEBUG_DIRECTORY DebugDirectory, DebugDirectories, DbgDebugDirectories = NULL;
    IMAGE_DEBUG_DIRECTORY MiscDebugDirectory = {0};
    IMAGE_DEBUG_DIRECTORY FpoDebugDirectory = {0};
    IMAGE_DEBUG_DIRECTORY FunctionTableDir;
    PIMAGE_DEBUG_DIRECTORY pFpoDebugDirectory = NULL;
    DWORD DebugDirectorySize, DbgFileHeaderSize, NumberOfDebugDirectories;
    IMAGE_SEPARATE_DEBUG_HEADER DbgFileHeader;
    PIMAGE_EXPORT_DIRECTORY ExportDirectory;
    DWORD  ExportedNamesSize;
    LPDWORD pp;
    LPSTR ExportedNames = NULL, Src, Dst;
    DWORD i, j, RvaOffset, ExportDirectorySize;
    PFPO_DATA FpoTable = NULL;
    DWORD FpoTableSize;
    PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY RuntimeFunctionTable, pSrc;
    DWORD RuntimeFunctionTableSize;
    PIMAGE_FUNCTION_ENTRY FunctionTable = NULL, pDst;
    DWORD FunctionTableSize;
    ULONG NumberOfFunctionTableEntries, DbgOffset;
    DWORD SavedErrorCode;
    BOOL InsertExtensionSubDir;
    LPSTR ImageFilePathToSaveInImage;
    BOOL MiscInRdata = FALSE;
    BOOL DiscardFPO = Flags & SPLITSYM_EXTRACT_ALL;
    BOOL MiscDebugFound, OtherDebugFound, PdbDebugFound;
    BOOL fNewCvData = FALSE;
    PCHAR  NewDebugData = NULL;
    CHAR AltPdbPath[_MAX_PATH];
    PIMAGE_FILE_HEADER FileHeader;
    PIMAGE_OPTIONAL_HEADER32 OptionalHeader;
    PIMAGE_SECTION_HEADER Sections;
    NB10I *pNB10Info;

    if (Flags & SPLITSYM_SYMBOLPATH_IS_SRC) {
        strncpy(AltPdbPath, SymbolFilePath, sizeof(AltPdbPath));
    }

    ImageFileName = ImageName + strlen( ImageName );
    while (ImageFileName > ImageName) {
        if (*ImageFileName == '\\' ||
            *ImageFileName == '/' ||
            *ImageFileName == ':' )
        {
            ImageFileName = CharNext(ImageFileName);
            break;
        } else {
            ImageFileName = CharPrev(ImageName, ImageFileName);
        }
    }

    if (SymbolsPath == NULL ||
        SymbolsPath[ 0 ] == '\0' ||
        SymbolsPath[ 0 ] == '.' )
    {
        strncpy( SymbolFilePath, ImageName, (int)(ImageFileName - ImageName) );
        SymbolFilePath[ ImageFileName - ImageName ] = '\0';
        InsertExtensionSubDir = FALSE;
    } else {
        strcpy( SymbolFilePath, SymbolsPath );
        InsertExtensionSubDir = TRUE;
    }

    Dst = SymbolFilePath + strlen( SymbolFilePath );
    if (Dst > SymbolFilePath &&
        *CharPrev(SymbolFilePath, Dst) != '\\' &&
        *CharPrev(SymbolFilePath, Dst) != '/'  &&
        *CharPrev(SymbolFilePath, Dst) != ':')
    {
        *Dst++ = '\\';
    }
    ImageFilePathToSaveInImage = Dst;
    Src = strrchr( ImageFileName, '.' );
    if (Src != NULL && InsertExtensionSubDir) {
        while (*Dst = *++Src) {
            Dst += 1;
        }
        *Dst++ = '\\';
    }

    strcpy( Dst, ImageFileName );
    Dst = strrchr( Dst, '.' );
    if (Dst == NULL) {
        Dst = SymbolFilePath + strlen( SymbolFilePath );
    }
    strcpy( Dst, ".dbg" );

    // Now, open and map the input file.

    FileHandle = CreateFile( ImageName,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             0,
                             NULL
                           );


    if (FileHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    hMappedFile = CreateFileMapping( FileHandle,
                                     NULL,
                                     PAGE_READWRITE,
                                     0,
                                     0,
                                     NULL
                                   );
    if (!hMappedFile) {
        CloseHandle( FileHandle );
        return FALSE;
    }

    ImageBase = MapViewOfFile( hMappedFile,
                               FILE_MAP_WRITE,
                               0,
                               0,
                               0
                             );
    CloseHandle( hMappedFile );
    if (!ImageBase) {
        CloseHandle( FileHandle );
        return FALSE;
    }

    //
    // Everything is mapped. Now check the image and find nt image headers
    //

    NtHeaders = ImageNtHeader( ImageBase );
    if (NtHeaders == NULL) {
        FileHeader = (PIMAGE_FILE_HEADER)ImageBase;
        OptionalHeader = ((PIMAGE_OPTIONAL_HEADER32)((ULONG_PTR)FileHeader+IMAGE_SIZEOF_FILE_HEADER));
        // One last check
        if (OptionalHeader->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
            goto HeaderOk;
HeaderBad:
        UnmapViewOfFile( ImageBase );
        CloseHandle( FileHandle );
        SetLastError( ERROR_BAD_EXE_FORMAT );
        return FALSE;
    } else {
        FileHeader = &NtHeaders->FileHeader;
        OptionalHeader = &NtHeaders->OptionalHeader;
        if (OptionalHeader->Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC)
            goto HeaderBad;
    }

HeaderOk:

    if ((OptionalHeader->MajorLinkerVersion < 3) &&
        (OptionalHeader->MinorLinkerVersion < 5) )
    {
        UnmapViewOfFile( ImageBase );
        CloseHandle( FileHandle );
        SetLastError( ERROR_BAD_EXE_FORMAT );
        return FALSE;
    }

    {
        DWORD dwCertificateSize;
        PVOID pCertificates;
        pCertificates = ImageDirectoryEntryToData(ImageBase, FALSE, IMAGE_DIRECTORY_ENTRY_SECURITY, &dwCertificateSize);
        if (pCertificates || dwCertificateSize) {
            // This image has been signed.  Can't strip the symbols w/o invalidating the certificate.
            UnmapViewOfFile( ImageBase );
            CloseHandle( FileHandle );
            SetLastError( ERROR_BAD_EXE_FORMAT );
            return FALSE;
        }
    }

    if (FileHeader->Characteristics & IMAGE_FILE_DEBUG_STRIPPED)
    {
        // The symbols have already been stripped.  No need to continue.
        UnmapViewOfFile( ImageBase );
        CloseHandle( FileHandle );
        SetLastError( ERROR_ALREADY_ASSIGNED );
        return FALSE;
    }

    DebugDirectories = (PIMAGE_DEBUG_DIRECTORY) ImageDirectoryEntryToData( ImageBase,
                                                  FALSE,
                                                  IMAGE_DIRECTORY_ENTRY_DEBUG,
                                                  &DebugDirectorySize
                                                );
    if (!DebugDirectoryIsUseful(DebugDirectories, DebugDirectorySize)) {
        UnmapViewOfFile( ImageBase );
        CloseHandle( FileHandle );
        SetLastError( ERROR_BAD_EXE_FORMAT );
        return FALSE;
    }

    NumberOfDebugDirectories = DebugDirectorySize / sizeof( IMAGE_DEBUG_DIRECTORY );

    // See if there's a MISC debug dir and if not, there s/b ONLY a CV data or it's an error.

    MiscDebugFound = FALSE;
    OtherDebugFound = FALSE;
    for (i=0,DebugDirectory=DebugDirectories; i<NumberOfDebugDirectories; i++,DebugDirectory++) {
        switch (DebugDirectory->Type) {
            case IMAGE_DEBUG_TYPE_MISC:
                MiscDebugFound = TRUE;
                break;

            case IMAGE_DEBUG_TYPE_CODEVIEW:
                pNB10Info = (NB10I *) (DebugDirectory->PointerToRawData + (PCHAR)ImageBase);
                if (pNB10Info->nb10 == '01BN') {
                    PdbDebugFound = TRUE;
                }
                break;

            default:
                OtherDebugFound = TRUE;
                break;
        }
    }

    if (OtherDebugFound && !MiscDebugFound) {
        UnmapViewOfFile( ImageBase );
        CloseHandle( FileHandle );
        SetLastError( ERROR_BAD_EXE_FORMAT );
        return FALSE;
    }

    if (PdbDebugFound && !OtherDebugFound && (OptionalHeader->MajorLinkerVersion >= 6)) {
        // This is a VC6 generated image.  Don't create a .dbg file.
        MiscDebugFound = FALSE;
    }

    // Make sure we can open the .dbg file before we continue...
    if (!MakeSureDirectoryPathExists( SymbolFilePath )) {
        return FALSE;
    }

    if (MiscDebugFound) {
        // Try to open the symbol file
        SymbolFileHandle = CreateFile( SymbolFilePath,
                                       GENERIC_WRITE,
                                       0,
                                       NULL,
                                       CREATE_ALWAYS,
                                       0,
                                       NULL
                                     );
        if (SymbolFileHandle == INVALID_HANDLE_VALUE) {
            goto nosyms;
        }
    }

    // The entire file is mapped so we don't have to care if the rva's
    // are correct.  It is interesting to note if there's a debug section
    // we need to whack before terminating, though.

    {
        if (NtHeaders) {
            Sections = IMAGE_FIRST_SECTION( NtHeaders );
        } else {
            Sections = (PIMAGE_SECTION_HEADER)
                        ((ULONG_PTR)ImageBase +
                          ((PIMAGE_FILE_HEADER)ImageBase)->SizeOfOptionalHeader +
                          IMAGE_SIZEOF_FILE_HEADER );
        }

        for (SectionNumber = 0;
             SectionNumber < FileHeader->NumberOfSections;
             SectionNumber++ ) {

            if (Sections[ SectionNumber ].PointerToRawData != 0 &&
                !_stricmp( (char *) Sections[ SectionNumber ].Name, ".debug" )) {
                DebugSection = &Sections[ SectionNumber ];
            }
        }
    }

    FpoTable           = NULL;
    ExportedNames      = NULL;
    DebugSectionStart  = 0xffffffff;

    //
    // Find the size of the debug section.
    //

    SizeOfSymbols = 0;

    for (i=0,DebugDirectory=DebugDirectories; i<NumberOfDebugDirectories; i++,DebugDirectory++) {

        switch (DebugDirectory->Type) {
            case IMAGE_DEBUG_TYPE_MISC :

                // Save it away.
                MiscDebugDirectory = *DebugDirectory;

                // check to see if the misc debug data is in some other section.

                // If Address Of Raw Data is cleared, it must be in .debug (there's no such thing as not-mapped rdata)
                // If it's set and there's no debug section, it must be somewhere else.
                // If it's set and there's a debug section, check the range.

                if ((DebugDirectory->AddressOfRawData != 0) &&
                    ((DebugSection == NULL) ||
                     (((DebugDirectory->PointerToRawData < DebugSection->PointerToRawData) ||
                       (DebugDirectory->PointerToRawData >= DebugSection->PointerToRawData + DebugSection->SizeOfRawData)
                      )
                     )
                    )
                   )
                {
                    MiscInRdata = TRUE;
                } else {
                    if (DebugDirectory->PointerToRawData < DebugSectionStart) {
                        DebugSectionStart = DebugDirectory->PointerToRawData;
                    }
                }

                break;

            case IMAGE_DEBUG_TYPE_FPO:
                if (DebugDirectory->PointerToRawData < DebugSectionStart) {
                    DebugSectionStart = DebugDirectory->PointerToRawData;
                }

                // Save it away.

                FpoDebugDirectory = *DebugDirectory;
                pFpoDebugDirectory = DebugDirectory;
                break;

            case IMAGE_DEBUG_TYPE_CODEVIEW:
                {
                    ULONG   NewDebugSize;

                    if (DebugDirectory->PointerToRawData < DebugSectionStart) {
                        DebugSectionStart = DebugDirectory->PointerToRawData;
                    }

                    // If private's are removed, do so to the static CV data and save the new size...
                    pNB10Info = (NB10I *) (DebugDirectory->PointerToRawData + (PCHAR)ImageBase);
                    if (pNB10Info->nb10 == '01BN') {
                        // Got a PDB.  The name immediately follows the signature.

                        CHAR PdbName[_MAX_PATH];
                        CHAR NewPdbName[_MAX_PATH];
                        CHAR Drive[_MAX_DRIVE];
                        CHAR Dir[_MAX_DIR];
                        CHAR Filename[_MAX_FNAME];
                        CHAR FileExt[_MAX_EXT];
                        BOOL rc;

                        memset(PdbName, 0, sizeof(PdbName));
                        memcpy(PdbName, ((PCHAR)pNB10Info) + sizeof(NB10I), DebugDirectory->SizeOfData - sizeof(NB10I));

                        _splitpath(PdbName, NULL, NULL, Filename, FileExt);
                        _splitpath(SymbolFilePath, Drive, Dir, NULL, NULL);
                        _makepath(NewPdbName, Drive, Dir, Filename, FileExt);
                        rc = CopyPdb(PdbName, NewPdbName, Flags & SPLITSYM_REMOVE_PRIVATE);

                        if (!rc) {
                            if (Flags & SPLITSYM_SYMBOLPATH_IS_SRC) {
                                // Try the AltPdbPath.
                                strcpy(PdbName, AltPdbPath);
                                strcat(PdbName, Filename);
                                strcat(PdbName, FileExt);
                                rc = CopyPdb(PdbName, NewPdbName, Flags & SPLITSYM_REMOVE_PRIVATE);
                            }

                            if ( !rc) {
                                // It's possible the name in the pdb isn't in the same location as it was when built.  See if we can
                                //  find it in the same dir as the image...
                                _splitpath(ImageName, Drive, Dir, NULL, NULL);
                                _makepath(PdbName, Drive, Dir, Filename, FileExt);

                                rc = CopyPdb(PdbName, NewPdbName, Flags & SPLITSYM_REMOVE_PRIVATE);
                            }
                        }

                        if (rc) {
                            SetFileAttributes(NewPdbName, FILE_ATTRIBUTE_NORMAL);

                            // Change the data so only the pdb name is in the .dbg file (no path).

                            if (MiscDebugFound) {
                                NewDebugSize = sizeof(NB10I) + strlen(Filename) + strlen(FileExt) + 1;

                                NewDebugData = (PCHAR) MemAlloc( NewDebugSize );
                                *(NB10I *)NewDebugData = *pNB10Info;
                                strcpy(NewDebugData + sizeof(NB10I), Filename);
                                strcat(NewDebugData + sizeof(NB10I), FileExt);

                                DebugDirectory->PointerToRawData = (ULONG) (NewDebugData - (PCHAR)ImageBase);
                                DebugDirectory->SizeOfData = NewDebugSize;
                            } else {
                                strcpy(((PCHAR)pNB10Info) + sizeof(NB10I), Filename);
                                strcat(((PCHAR)pNB10Info) + sizeof(NB10I), FileExt);
                            }
                        } else {
                            // Unable to copy the pdb.  Forget we knew about it.
                            DebugDirectory->PointerToRawData = 0;
                            DebugDirectory->SizeOfData = 0;
                        }
                    } else {
                        if (Flags & SPLITSYM_REMOVE_PRIVATE) {
                            if (RemovePrivateCvSymbolicEx(DebugDirectory->PointerToRawData + (PCHAR)ImageBase,
                                                    DebugDirectory->SizeOfData,
                                                    &NewDebugData,
                                                    &NewDebugSize)) {
                                if (DebugDirectory->PointerToRawData != (ULONG) (NewDebugData - (PCHAR)ImageBase))
                                {
                                    DebugDirectory->PointerToRawData = (ULONG) (NewDebugData - (PCHAR)ImageBase);
                                    DebugDirectory->SizeOfData = NewDebugSize;
                                } else {
                                    NewDebugData = NULL;
                                }
                            }
                        }
                    }
                }

                break;

            case IMAGE_DEBUG_TYPE_OMAP_TO_SRC:
            case IMAGE_DEBUG_TYPE_OMAP_FROM_SRC:
                if (DebugDirectory->PointerToRawData < DebugSectionStart) {
                    DebugSectionStart = DebugDirectory->PointerToRawData;
                }

                // W/o the OMAP, FPO is useless.
                DiscardFPO = TRUE;
                break;

            case IMAGE_DEBUG_TYPE_FIXUP:
                if (DebugDirectory->PointerToRawData < DebugSectionStart) {
                    DebugSectionStart = DebugDirectory->PointerToRawData;
                }

                // If all PRIVATE debug is removed, don't send FIXUP along.
                if (Flags & SPLITSYM_REMOVE_PRIVATE) {
                    DebugDirectory->SizeOfData = 0;
                }
                break;

            default:
                if (DebugDirectory->SizeOfData &&
                   (DebugDirectory->PointerToRawData < DebugSectionStart))
                {
                    DebugSectionStart = DebugDirectory->PointerToRawData;
                }

                // Nothing else to special case...
                break;
        }

        SizeOfSymbols += (DebugDirectory->SizeOfData + 3) & ~3; // Minimally align it all.
    }

    if (!MiscDebugFound) {
        NewFileSize = GetFileSize(FileHandle, NULL);

        CheckSumMappedFile( ImageBase,
                            NewFileSize,
                            &HeaderSum,
                            &CheckSum
                          );
        OptionalHeader->CheckSum = CheckSum;

        goto nomisc;
    }

    if (DiscardFPO) {
        pFpoDebugDirectory = NULL;
    }

    if (pFpoDebugDirectory) {
        // If FPO stays here, make a copy so we don't need to worry about stomping on it.

        FpoTableSize = pFpoDebugDirectory->SizeOfData;
        FpoTable = (PFPO_DATA) MemAlloc( FpoTableSize );
        if ( FpoTable == NULL ) {
            goto nosyms;
        }

        RtlMoveMemory( FpoTable,
                       (PCHAR) ImageBase + pFpoDebugDirectory->PointerToRawData,
                       FpoTableSize );
    }

    ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)
        ImageDirectoryEntryToData( ImageBase,
                                   FALSE,
                                   IMAGE_DIRECTORY_ENTRY_EXPORT,
                                   &ExportDirectorySize
                                 );
    if (ExportDirectory) {
        //
        // This particular piece of magic gets us the RVA of the
        // EXPORT section.  Dont ask.
        //

        RvaOffset = (ULONG_PTR)
            ImageDirectoryEntryToData( ImageBase,
                                       TRUE,
                                       IMAGE_DIRECTORY_ENTRY_EXPORT,
                                       &ExportDirectorySize
                                     ) - (ULONG_PTR)ImageBase;

        pp = (LPDWORD)((ULONG_PTR)ExportDirectory +
                      (ULONG_PTR)ExportDirectory->AddressOfNames - RvaOffset
                     );

        ExportedNamesSize = 1;
        for (i=0; i<ExportDirectory->NumberOfNames; i++) {
            Src = (LPSTR)((ULONG_PTR)ExportDirectory + *pp++ - RvaOffset);
            ExportedNamesSize += strlen( Src ) + 1;
        }
        ExportedNamesSize = (ExportedNamesSize + 16) & ~15;

        Dst = (LPSTR) MemAlloc( ExportedNamesSize );
        if (Dst != NULL) {
            ExportedNames = Dst;
            pp = (LPDWORD)((ULONG_PTR)ExportDirectory +
                          (ULONG_PTR)ExportDirectory->AddressOfNames - RvaOffset
                         );
            for (i=0; i<ExportDirectory->NumberOfNames; i++) {
                Src = (LPSTR)((ULONG_PTR)ExportDirectory + *pp++ - RvaOffset);
                while (*Dst++ = *Src++) {
                    ;
                }
            }
        }
    } else {
        ExportedNamesSize = 0;
    }

    RuntimeFunctionTable = (PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY)
        ImageDirectoryEntryToData( ImageBase,
                                   FALSE,
                                   IMAGE_DIRECTORY_ENTRY_EXCEPTION,
                                   &RuntimeFunctionTableSize
                                 );
    if (RuntimeFunctionTable == NULL) {
        RuntimeFunctionTableSize = 0;
        FunctionTableSize = 0;
        FunctionTable = NULL;
        }
    else {
        NumberOfFunctionTableEntries = RuntimeFunctionTableSize / sizeof( IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY );
        FunctionTableSize = NumberOfFunctionTableEntries * sizeof( IMAGE_FUNCTION_ENTRY );
        FunctionTable = (PIMAGE_FUNCTION_ENTRY) MemAlloc( FunctionTableSize );
        if (FunctionTable == NULL) {
            goto nosyms;
            }

        pSrc = RuntimeFunctionTable;
        pDst = FunctionTable;
        for (i=0; i<NumberOfFunctionTableEntries; i++) {
            //
            // Make .pdata entries in .DBG file relative.
            //
            pDst->StartingAddress = CLEAN_PD(pSrc->BeginAddress) - OptionalHeader->ImageBase;
            pDst->EndingAddress = CLEAN_PD(pSrc->EndAddress) - OptionalHeader->ImageBase;
            pDst->EndOfPrologue = CLEAN_PD(pSrc->PrologEndAddress) - OptionalHeader->ImageBase;
            pSrc += 1;
            pDst += 1;
            }
        }

    DbgFileHeaderSize = sizeof( DbgFileHeader ) +
                        ((FileHeader->NumberOfSections - (DebugSection ? 1 : 0)) *
                         sizeof( IMAGE_SECTION_HEADER )) +
                        ExportedNamesSize +
                        FunctionTableSize +
                        DebugDirectorySize;

    if (FunctionTable != NULL) {
        DbgFileHeaderSize += sizeof( IMAGE_DEBUG_DIRECTORY );
        memset( &FunctionTableDir, 0, sizeof( IMAGE_DEBUG_DIRECTORY ) );
        FunctionTableDir.Type = IMAGE_DEBUG_TYPE_EXCEPTION;
        FunctionTableDir.SizeOfData = FunctionTableSize;
        FunctionTableDir.PointerToRawData = DbgFileHeaderSize - FunctionTableSize;
    }

    DbgFileHeaderSize = ((DbgFileHeaderSize + 15) & ~15);

    BytesWritten = 0;

    if (SetFilePointer( SymbolFileHandle,
                        DbgFileHeaderSize,
                        NULL,
                        FILE_BEGIN
                      ) == DbgFileHeaderSize ) {

        for (i=0, DebugDirectory=DebugDirectories;
             i < NumberOfDebugDirectories;
             i++, DebugDirectory++) {

            DWORD WriteCount;

            if (DebugDirectory->SizeOfData) {
                WriteFile( SymbolFileHandle,
                           (PCHAR) ImageBase + DebugDirectory->PointerToRawData,
                           (DebugDirectory->SizeOfData +3) & ~3,
                           &WriteCount,
                           NULL );

                BytesWritten += WriteCount;
            }
        }
    }

    if (BytesWritten == SizeOfSymbols) {
        FileHeader->PointerToSymbolTable = 0;
        FileHeader->NumberOfSymbols = 0;
        FileHeader->Characteristics |= IMAGE_FILE_DEBUG_STRIPPED;

        if (DebugSection != NULL) {
            OptionalHeader->SizeOfImage = DebugSection->VirtualAddress;
            OptionalHeader->SizeOfInitializedData -= DebugSection->SizeOfRawData;
            FileHeader->NumberOfSections--;
            // NULL out that section
            memset(DebugSection, 0, IMAGE_SIZEOF_SECTION_HEADER);
        }

        NewFileSize = DebugSectionStart;  // Start with no symbolic

        //
        // Now that the data has moved to the .dbg file, rebuild the original
        // with MISC debug first and FPO second.
        //

        if (MiscDebugDirectory.SizeOfData) {
            if (MiscInRdata) {
                // Just store the new name in the existing misc field...

                ImageNameOffset = (ULONG_PTR) ((PCHAR)ImageBase +
                                  MiscDebugDirectory.PointerToRawData +
                                  FIELD_OFFSET( IMAGE_DEBUG_MISC, Data ));

                RtlCopyMemory( (LPVOID) ImageNameOffset,
                               ImageFilePathToSaveInImage,
                               strlen(ImageFilePathToSaveInImage) + 1 );
            } else {
                if (DebugSectionStart != MiscDebugDirectory.PointerToRawData) {
                    RtlMoveMemory((PCHAR) ImageBase + DebugSectionStart,
                                  (PCHAR) ImageBase + MiscDebugDirectory.PointerToRawData,
                                  MiscDebugDirectory.SizeOfData);
                }

                ImageNameOffset = (ULONG_PTR) ((PCHAR)ImageBase + DebugSectionStart +
                                  FIELD_OFFSET( IMAGE_DEBUG_MISC, Data ));

                RtlCopyMemory( (LPVOID)ImageNameOffset,
                               ImageFilePathToSaveInImage,
                               strlen(ImageFilePathToSaveInImage) + 1 );

                NewFileSize += MiscDebugDirectory.SizeOfData;
                NewFileSize = (NewFileSize + 3) & ~3;
            }
        }

        if (FpoTable) {
            RtlCopyMemory( (PCHAR) ImageBase + NewFileSize,
                           FpoTable,
                           FpoTableSize );

            NewFileSize += FpoTableSize;
            NewFileSize = (NewFileSize + 3) & ~3;
        }

        // Make a copy of the Debug directory that we can write into the .dbg file

        DbgDebugDirectories = (PIMAGE_DEBUG_DIRECTORY) MemAlloc( NumberOfDebugDirectories * sizeof(IMAGE_DEBUG_DIRECTORY) );

        RtlMoveMemory(DbgDebugDirectories,
                        DebugDirectories,
                        sizeof(IMAGE_DEBUG_DIRECTORY) * NumberOfDebugDirectories);


        // Then write the MISC and (perhaps) FPO data to the image.

        FpoDebugDirectory.PointerToRawData = DebugSectionStart;
        DebugDirectorySize = 0;

        if (MiscDebugDirectory.SizeOfData != 0) {
            if (!MiscInRdata) {
                MiscDebugDirectory.PointerToRawData = DebugSectionStart;
                FpoDebugDirectory.PointerToRawData += MiscDebugDirectory.SizeOfData;
                MiscDebugDirectory.AddressOfRawData = 0;
            }

            DebugDirectories[0] = MiscDebugDirectory;
            DebugDirectorySize  += sizeof(IMAGE_DEBUG_DIRECTORY);
        }

        if (pFpoDebugDirectory) {
            FpoDebugDirectory.AddressOfRawData = 0;
            DebugDirectories[1] = FpoDebugDirectory;
            DebugDirectorySize += sizeof(IMAGE_DEBUG_DIRECTORY);
        }

        OptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size = DebugDirectorySize;

        DbgOffset = DbgFileHeaderSize;

        for (i = 0, j=0, DebugDirectory=DbgDebugDirectories;
             i < NumberOfDebugDirectories; i++) {

            if (DebugDirectory[i].SizeOfData) {
                DebugDirectory[j] = DebugDirectory[i];

                DebugDirectory[j].AddressOfRawData = 0;
                DebugDirectory[j].PointerToRawData = DbgOffset;

                DbgOffset += (DebugDirectory[j].SizeOfData + 3 )& ~3;
                j++;
            }
        }

        if (FunctionTable) {
            FunctionTableDir.PointerToRawData -= sizeof(IMAGE_DEBUG_DIRECTORY) * (NumberOfDebugDirectories - j);
        }
        NumberOfDebugDirectories = j;

        CheckSumMappedFile( ImageBase,
                            NewFileSize,
                            &HeaderSum,
                            &CheckSum
                          );
        OptionalHeader->CheckSum = CheckSum;

        DbgFileHeader.Signature = IMAGE_SEPARATE_DEBUG_SIGNATURE;
        DbgFileHeader.Flags = 0;
        DbgFileHeader.Machine = FileHeader->Machine;
        DbgFileHeader.Characteristics = FileHeader->Characteristics;
        DbgFileHeader.TimeDateStamp = FileHeader->TimeDateStamp;
        DbgFileHeader.CheckSum = CheckSum;
        DbgFileHeader.ImageBase = OptionalHeader->ImageBase;
        DbgFileHeader.SizeOfImage = OptionalHeader->SizeOfImage;
        DbgFileHeader.ExportedNamesSize = ExportedNamesSize;
        DbgFileHeader.DebugDirectorySize = NumberOfDebugDirectories * sizeof(IMAGE_DEBUG_DIRECTORY);
        if (FunctionTable) {
            DbgFileHeader.DebugDirectorySize += sizeof (IMAGE_DEBUG_DIRECTORY);
        }
        DbgFileHeader.NumberOfSections = FileHeader->NumberOfSections;
        memset( DbgFileHeader.Reserved, 0, sizeof( DbgFileHeader.Reserved ) );
        DbgFileHeader.SectionAlignment = OptionalHeader->SectionAlignment;

        SetFilePointer( SymbolFileHandle, 0, NULL, FILE_BEGIN );
        WriteFile( SymbolFileHandle,
                   &DbgFileHeader,
                   sizeof( DbgFileHeader ),
                   &BytesWritten,
                   NULL
                 );
        if (NtHeaders) {
            Sections = IMAGE_FIRST_SECTION( NtHeaders );
        } else {
            Sections = (PIMAGE_SECTION_HEADER)
                        ((ULONG_PTR)ImageBase +
                          ((PIMAGE_FILE_HEADER)ImageBase)->SizeOfOptionalHeader +
                          IMAGE_SIZEOF_FILE_HEADER );
        }
        WriteFile( SymbolFileHandle,
                   (PVOID)Sections,
                   sizeof( IMAGE_SECTION_HEADER ) * FileHeader->NumberOfSections,
                   &BytesWritten,
                   NULL
                 );

        if (ExportedNamesSize) {
            WriteFile( SymbolFileHandle,
                       ExportedNames,
                       ExportedNamesSize,
                       &BytesWritten,
                       NULL
                     );
        }

        WriteFile( SymbolFileHandle,
                   DbgDebugDirectories,
                   sizeof (IMAGE_DEBUG_DIRECTORY) * NumberOfDebugDirectories,
                   &BytesWritten,
                   NULL );


        if (FunctionTable) {
            WriteFile( SymbolFileHandle,
                       &FunctionTableDir,
                       sizeof (IMAGE_DEBUG_DIRECTORY),
                       &BytesWritten,
                       NULL );

            WriteFile( SymbolFileHandle,
                       FunctionTable,
                       FunctionTableSize,
                       &BytesWritten,
                       NULL
                     );
        }

        SetFilePointer( SymbolFileHandle, 0, NULL, FILE_END );
        CloseHandle( SymbolFileHandle );

nomisc:

        FlushViewOfFile( ImageBase, NewFileSize );
        UnmapViewOfFile( ImageBase );

        SetFilePointer( FileHandle, NewFileSize, NULL, FILE_BEGIN );
        SetEndOfFile( FileHandle );

        TouchFileTimes( FileHandle, NULL );
        CloseHandle( FileHandle );

        if (ExportedNames) {
            MemFree( ExportedNames );
        }

        if (FpoTable) {
            MemFree( FpoTable );
        }

        if (FunctionTable) {
            MemFree( FunctionTable );
        }

        if (NewDebugData) {
            MemFree(NewDebugData);
        }

        if (DbgDebugDirectories) {
            MemFree(DbgDebugDirectories);
        }

        return TRUE;

    } else {
        CloseHandle( SymbolFileHandle );
        DeleteFile( SymbolFilePath );
    }

nosyms:
    SavedErrorCode = GetLastError();
    if (ExportedNames != NULL) {
        MemFree( ExportedNames );
    }

    if (FpoTable != NULL) {
        MemFree( FpoTable );
    }

    if (FunctionTable != NULL) {
        MemFree( FunctionTable );
    }

    UnmapViewOfFile( ImageBase );
    CloseHandle( FileHandle );
    SetLastError( SavedErrorCode );
    return FALSE;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\symbols.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    symbols.c

Abstract:

    This function implements a generic simple symbol handler.

Author:

    Wesley Witt (wesw) 1-Sep-1994

Environment:

    User Mode

--*/

#include "private.h"
#include "symbols.h"


BOOL
IMAGEAPI
SympGetSymNextPrev(
    IN     HANDLE              hProcess,
    IN OUT PIMAGEHLP_SYMBOL64  Symbol,
    IN     int                 Direction
    );

//
// globals
//
LIST_ENTRY      ProcessList;
BOOL            SymInitialized;
DWORD           SymOptions = SYMOPT_UNDNAME;

BOOL
IMAGEAPI
SymInitialize(
    IN HANDLE   hProcess,
    IN LPSTR    UserSearchPath,
    IN BOOL     InvadeProcess
    )

/*++

Routine Description:

    This function initializes the symbol handler for
    a process.  The process is identified by the
    process handle passed into this function.

Arguments:

    hProcess        - Process handle.  If InvadeProcess is FALSE
                      then this can be any unique value that identifies
                      the process to the symbol handler.

    UserSearchPath  - Pointer to a string of paths separated by semicolons.
                      These paths are used to search for symbol files.
                      The value NULL is acceptable.

    InvadeProcess   - If this is set to TRUE then the process identified
                      by the process handle is "invaded" and it's loaded
                      module list is enumerated.  Each module is added
                      to the symbol handler and symbols are attempted
                      to be loaded.

Return Value:

    TRUE            - The symbol handler was successfully initialized.

    FALSE           - The initialization failed.  Call GetLastError to
                      discover the cause of the failure.

--*/

{
    PPROCESS_ENTRY  ProcessEntry;

    __try {

        if (!SymInitialized) {
            SymInitialized = TRUE;
            InitializeListHead( &ProcessList );
        }

        if (FindProcessEntry( hProcess )) {
            SetLastError( ERROR_INVALID_HANDLE );
            return TRUE;
        }

        ProcessEntry = (PPROCESS_ENTRY) MemAlloc( sizeof(PROCESS_ENTRY) );
        if (!ProcessEntry) {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return FALSE;
        }
        ZeroMemory( ProcessEntry, sizeof(PROCESS_ENTRY) );

        ProcessEntry->hProcess = hProcess;
        ProcessEntry->pid = (int) GetPID(hProcess);
        InitializeListHead( &ProcessEntry->ModuleList );
        InsertTailList( &ProcessList, &ProcessEntry->ListEntry );

        if (!SymSetSearchPath( hProcess, UserSearchPath )) {
            //
            // last error code was set by SymSetSearchPath, so just return
            //
            SymCleanup( hProcess );
            return FALSE;
        }

        if (InvadeProcess) {
            DWORD DosError = GetProcessModules(hProcess, InternalGetModule, NULL);
            if (DosError) {
                SymCleanup( hProcess );
                SetLastError( DosError );
                return FALSE;
            }
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return TRUE;
}


BOOL
IMAGEAPI
SymCleanup(
    HANDLE hProcess
    )

/*++

Routine Description:

    This function cleans up the symbol handler's data structures
    for a previously initialized process.

Arguments:

    hProcess        - Process handle.

Return Value:

    TRUE            - The symbol handler was successfully cleaned up.

    FALSE           - The cleanup failed.  Call GetLastError to
                      discover the cause of the failure.

--*/

{
    PPROCESS_ENTRY      ProcessEntry;
    PLIST_ENTRY         Next;
    PMODULE_ENTRY       ModuleEntry;


    __try {

        ProcessEntry = FindProcessEntry( hProcess );
        if (!ProcessEntry) {
            SetLastError( ERROR_INVALID_HANDLE );
            return FALSE;
        }

        Next = ProcessEntry->ModuleList.Flink;
        if (Next) {
            while (Next != &ProcessEntry->ModuleList) {
                ModuleEntry = CONTAINING_RECORD( Next, MODULE_ENTRY, ListEntry );
                Next = ModuleEntry->ListEntry.Flink;
                FreeModuleEntry( ModuleEntry );
            }
        }

        CloseSymbolServer();

        if (ProcessEntry->SymbolSearchPath) {
            MemFree( ProcessEntry->SymbolSearchPath );
        }

        RemoveEntryList( &ProcessEntry->ListEntry );
        MemFree( ProcessEntry );

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return TRUE;
}


DWORD
IMAGEAPI
SymSetOptions(
    DWORD   UserOptions
    )

/*++

Routine Description:

    This function changes the symbol handler's option mask.

Arguments:

    UserOptions     - The new options mask.

Return Value:

    The new mask is returned.

--*/

{
    SymOptions = UserOptions;
    return SymOptions;
}


DWORD
IMAGEAPI
SymGetOptions(
    VOID
    )

/*++

Routine Description:

    This function queries the symbol handler's option mask.

Arguments:

    None.

Return Value:

    The current options mask is returned.

--*/

{
    return SymOptions;
}


BOOL
SympEnumerateModules(
    IN HANDLE   hProcess,
    IN PROC     EnumModulesCallback,
    IN PVOID    UserContext,
    IN BOOL     Use64
    )

/*++

Routine Description:

    This is the worker function for the 32 and 64 bit versions.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    EnumModulesCallback - Callback pointer that is called once for each
                          module that is enumerated.  If the enum callback
                          returns FALSE then the enumeration is terminated.

    UserContext         - This data is simply passed on to the callback function
                          and is completly user defined.

    Use64               - Supplies flag which determines whether to use the 32 bit
                          or 64 bit callback prototype.

Return Value:

    TRUE                - The modules were successfully enumerated.

    FALSE               - The enumeration failed.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    PPROCESS_ENTRY  ProcessEntry;
    PMODULE_ENTRY   ModuleEntry;
    PLIST_ENTRY     Next;


    __try {

        ProcessEntry = FindProcessEntry( hProcess );
        if (!ProcessEntry) {
            SetLastError( ERROR_INVALID_HANDLE );
            return FALSE;
        }

        Next = ProcessEntry->ModuleList.Flink;
        if (Next) {
            while (Next != &ProcessEntry->ModuleList) {
                ModuleEntry = CONTAINING_RECORD( Next, MODULE_ENTRY, ListEntry );
                Next = ModuleEntry->ListEntry.Flink;
                if (Use64) {
                    if ( !(*(PSYM_ENUMMODULES_CALLBACK64)EnumModulesCallback) (
                            ModuleEntry->ModuleName,
                            ModuleEntry->BaseOfDll,
                            UserContext
                            )) {
                        break;
                    }
                } else {
                    if ( !(*(PSYM_ENUMMODULES_CALLBACK)EnumModulesCallback) (
                            ModuleEntry->ModuleName,
                            (DWORD)ModuleEntry->BaseOfDll,
                            UserContext
                            )) {
                        break;
                    }
                }
            }
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return TRUE;
}

BOOL
IMAGEAPI
SymEnumerateModules(
    IN HANDLE                      hProcess,
    IN PSYM_ENUMMODULES_CALLBACK EnumModulesCallback,
    IN PVOID                       UserContext
    )

/*++

Routine Description:

    This function enumerates all of the modules that are currently
    loaded into the symbol handler.  This is the 32 bit wrapper.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    EnumModulesCallback - Callback pointer that is called once for each
                          module that is enumerated.  If the enum callback
                          returns FALSE then the enumeration is terminated.

    UserContext         - This data is simply passed on to the callback function
                          and is completly user defined.

Return Value:

    TRUE                - The modules were successfully enumerated.

    FALSE               - The enumeration failed.  Call GetLastError to
                          discover the cause of the failure.

--*/
{
    return SympEnumerateModules(hProcess, (PROC)EnumModulesCallback, UserContext, FALSE);
}


BOOL
IMAGEAPI
SymEnumerateModules64(
    IN HANDLE   hProcess,
    IN PSYM_ENUMMODULES_CALLBACK64 EnumModulesCallback,
    IN PVOID    UserContext
    )

/*++

Routine Description:

    This function enumerates all of the modules that are currently
    loaded into the symbol handler.  This is the 64 bit wrapper.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    EnumModulesCallback - Callback pointer that is called once for each
                          module that is enumerated.  If the enum callback
                          returns FALSE then the enumeration is terminated.

    UserContext         - This data is simply passed on to the callback function
                          and is completly user defined.

Return Value:

    TRUE                - The modules were successfully enumerated.

    FALSE               - The enumeration failed.  Call GetLastError to
                          discover the cause of the failure.

--*/
{
    return SympEnumerateModules(hProcess, (PROC)EnumModulesCallback, UserContext, TRUE);
}

int __cdecl
CompareAddrs (const void *addr1, const void *addr2) {
    LONGLONG Diff = *(DWORD64 *)addr1 - *(DWORD64 *)addr2;

    if (Diff < 0) {
        return -1;
    } else if (Diff > 0) {
        return 1;
    } else {
        return 0;
    }
}

BOOL
SympEnumerateSymbols(
    IN HANDLE  hProcess,
    IN ULONG64 BaseOfDll,
    IN PROC    EnumSymbolsCallback,
    IN PVOID   UserContext,
    IN BOOL    Use64,
    IN BOOL    CallBackUsesUnicode
    )

/*++

Routine Description:

    This function enumerates all of the symbols contained the module
    specified by the BaseOfDll argument.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize

    BaseOfDll           - Base address of the DLL that symbols are to be
                          enumerated for

    EnumSymbolsCallback - User specified callback routine for enumeration
                          notification

    UserContext         - Pass thru variable, this is simply passed thru to the
                          callback function

    Use64               - Supplies flag which determines whether to use the 32 bit
                          or 64 bit callback prototype.

Return Value:

    TRUE                - The symbols were successfully enumerated.

    FALSE               - The enumeration failed.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    PPROCESS_ENTRY      ProcessEntry;
    PLIST_ENTRY         Next;
    PMODULE_ENTRY       ModuleEntry;
    DWORD               i;
    PSYMBOL_ENTRY       sym;
    LPSTR               szSymName;

    __try {

        ProcessEntry = FindProcessEntry( hProcess );
        if (!ProcessEntry) {
            SetLastError( ERROR_INVALID_HANDLE );
            return FALSE;
        }

        Next = ProcessEntry->ModuleList.Flink;
        if (Next) {
            while (Next != &ProcessEntry->ModuleList) {
                ModuleEntry = CONTAINING_RECORD( Next, MODULE_ENTRY, ListEntry );
                Next = ModuleEntry->ListEntry.Flink;
                if (ModuleEntry->BaseOfDll == BaseOfDll) {
                    if (ModuleEntry->Flags & MIF_DEFERRED_LOAD) {
                        if ((ModuleEntry->Flags & MIF_NO_SYMBOLS) ||
                                !CompleteDeferredSymbolLoad( hProcess, ModuleEntry )) {
                            continue;
                        }
                    }

                    if (ModuleEntry->SymType == SymPdb) {

                        // In order to set the size field in the callback, we need to read
                        // all the addresses, sort the array, then calculate the size based
                        // on the delta between each.

                        DATASYM32 *dataSym = NULL;
                        DWORD64    *pPdbAddrs;
                        DWORD       cPdbAddrs = 4096;   // Arbitrary - initial 32k allocation for addr array
                        DWORD       SymCount = 0;
                        DWORD64     addr;
                        DWORD       size;
                        DWORD       Bias;
                        LPSTR       SymbolName;
                        UCHAR       SymbolLen;
                        unsigned short k;

                        pPdbAddrs = MemAlloc(cPdbAddrs * sizeof(addr));
                        if (!pPdbAddrs)
                            return FALSE;

                        // Init the addr array with an end ptr
                        *pPdbAddrs = ModuleEntry->DllSize + ModuleEntry->BaseOfDll;
                        SymCount = 1;

                        for (;;) {

                            dataSym = (DATASYM32 *) GSINextSym( ModuleEntry->gsi, (PUCHAR)dataSym );

                            if (dataSym == NULL)
                                break;          // Hit the terminator

                            k = DataSymSeg(dataSym) - 1;

                            if (k < ModuleEntry->OriginalNumSections) {
                                SymbolName = DataSymNameStart(dataSym);

                                if (*(ULONG UNALIGNED *)SymbolName == 0x435f3f3f) /* starts with ??_C */
                                    continue;           // ignore strings

                                addr = ModuleEntry->BaseOfDll + DataSymOffset(dataSym);
                                addr += ModuleEntry->OriginalSectionHdrs[k].VirtualAddress;

                                addr = ConvertOmapFromSrc( ModuleEntry, addr, &Bias );

                                if (addr != 0)
                                    addr += Bias;

                                *(pPdbAddrs+SymCount) = addr;

                                SymCount++;

                                if (SymCount >= cPdbAddrs) {
                                    PVOID pTmp = MemReAlloc(pPdbAddrs, (cPdbAddrs + 1024) * sizeof(addr));
                                    if (!pTmp)
                                        return FALSE;
                                    pPdbAddrs = pTmp;
                                    cPdbAddrs += 1024;
                                }
                            }
                        }

                        // Sort the addr array
                        qsort(pPdbAddrs, SymCount, sizeof(addr), CompareAddrs);

                        // Now go through again, this time sending it off

                        dataSym = NULL;

                        for (;;) {
                            unsigned short k;

                            dataSym = (DATASYM32 *) GSINextSym( ModuleEntry->gsi, (PUCHAR)dataSym );

                            if (dataSym == NULL)
                                break;

                            k = DataSymSeg(dataSym) - 1;

                            if (k < ModuleEntry->OriginalNumSections) {
                                SymbolName = DataSymNameStart(dataSym);

                                if (*(ULONG UNALIGNED *)SymbolName == 0x435f3f3f) /* starts with ??_C */
                                    continue;           // ignore strings

                                SymbolLen  = DataSymNameLength(dataSym);
                                if (SymOptions & SYMOPT_UNDNAME) {
                                    SymUnDNameInternal( ModuleEntry->TmpSym.Name, TMP_SYM_LEN-sizeof(ModuleEntry->TmpSym), SymbolName, SymbolLen);
                                } else {
                                    ModuleEntry->TmpSym.Name[0] = 0;
                                    strncat( ModuleEntry->TmpSym.Name, SymbolName, __min(SymbolLen, TMP_SYM_LEN-sizeof(ModuleEntry->TmpSym)) );
                                }

                                addr = ModuleEntry->BaseOfDll + DataSymOffset(dataSym);
                                addr += ModuleEntry->OriginalSectionHdrs[k].VirtualAddress;
                                addr = ConvertOmapFromSrc( ModuleEntry, addr, &Bias );

                                if (addr != 0)
                                    addr += Bias;

                                {
                                    // Find the addr in the array
                                    DWORD High;
                                    DWORD Low;
                                    DWORD Middle;
                                    LONG Result;

                                    Low = 0;
                                    High = SymCount - 1;
                                    while (High >= Low) {
                                        Middle = (Low + High) >> 1;
                                        Result = CompareAddrs(&addr, &pPdbAddrs[Middle]);

                                        if (Result < 0)
                                            High = Middle - 1;
                                        else if (Result > 0)
                                            Low = Middle + 1;
                                        else
                                            break;
                                    }

                                    if (High < Low)
                                        size = 0;
                                    else
                                        size = (DWORD)(pPdbAddrs[Middle+1] - pPdbAddrs[Middle]);
                                }

                                if (Use64) {
                                    if ( !(*(PSYM_ENUMSYMBOLS_CALLBACK64)EnumSymbolsCallback) (
                                                ModuleEntry->TmpSym.Name,
                                                addr,
                                                size,
                                                UserContext )) {
                                        break;
                                    }
                                } else {
                                    if (CallBackUsesUnicode) {
                                        PWSTR pszTmp = AnsiToUnicode(ModuleEntry->TmpSym.Name);
                                        if ( !(*(PSYM_ENUMSYMBOLS_CALLBACKW)EnumSymbolsCallback) (
                                                    pszTmp,
                                                    (DWORD)addr,
                                                    size,
                                                    UserContext )) {
                                            free(pszTmp);
                                            break;
                                        }
                                        free(pszTmp);
                                    } else {
                                        if ( !(*(PSYM_ENUMSYMBOLS_CALLBACK)EnumSymbolsCallback) (
                                                    ModuleEntry->TmpSym.Name,
                                                    (DWORD)addr,
                                                    size,
                                                    UserContext )) {
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        MemFree(pPdbAddrs);
                        return TRUE;
                    }

                    for (i = 0; i < ModuleEntry->numsyms; i++) {
                        sym = &ModuleEntry->symbolTable[i];
                        ModuleEntry->TmpSym.Name[0] = 0;
                        strncat( ModuleEntry->TmpSym.Name, sym->Name, TMP_SYM_LEN );
                        if (Use64) {
                            if ( !(*(PSYM_ENUMSYMBOLS_CALLBACK64)EnumSymbolsCallback) (
                                        ModuleEntry->TmpSym.Name,
                                        sym->Address,
                                        sym->Size,
                                        UserContext )) {
                                break;
                            }
                        } else {
                            if (CallBackUsesUnicode) {
                                PWSTR pszTmp = AnsiToUnicode(ModuleEntry->TmpSym.Name);
                                if ( !(*(PSYM_ENUMSYMBOLS_CALLBACKW)EnumSymbolsCallback) (
                                            pszTmp,
                                            (DWORD)sym->Address,
                                            sym->Size,
                                            UserContext )) {
                                    free(pszTmp);
                                    break;
                                }
                                free(pszTmp);
                            } else {
                                if ( !(*(PSYM_ENUMSYMBOLS_CALLBACK)EnumSymbolsCallback) (
                                            ModuleEntry->TmpSym.Name,
                                            (DWORD)sym->Address,
                                            sym->Size,
                                            UserContext )) {
                                    break;
                                }
                            }
                        }
                    }
                    break;
                }
            }
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return TRUE;
}

BOOL
IMAGEAPI
SymEnumerateSymbols(
    IN HANDLE                       hProcess,
    IN ULONG                        BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACK    EnumSymbolsCallback,
    IN PVOID                        UserContext
    )

/*++

Routine Description:

    This function enumerates all of the symbols contained the module
    specified by the BaseOfDll argument.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize

    BaseOfDll           - Base address of the DLL that symbols are to be
                          enumerated for

    EnumSymbolsCallback - User specified callback routine for enumeration
                          notification

    UserContext         - Pass thru variable, this is simply passed thru to the
                          callback function

Return Value:

    TRUE                - The symbols were successfully enumerated.

    FALSE               - The enumeration failed.  Call GetLastError to
                          discover the cause of the failure.

--*/
{
    return SympEnumerateSymbols(hProcess, BaseOfDll, (PROC)EnumSymbolsCallback, UserContext, FALSE, FALSE);
}

BOOL
IMAGEAPI
SymEnumerateSymbolsW(
    IN HANDLE                       hProcess,
    IN ULONG                        BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACKW   EnumSymbolsCallback,
    IN PVOID                        UserContext
    )
{
    return SympEnumerateSymbols(hProcess, BaseOfDll, (PROC)EnumSymbolsCallback, UserContext, FALSE, TRUE);
}

BOOL
IMAGEAPI
SymEnumerateSymbols64(
    IN HANDLE                       hProcess,
    IN ULONG64                      BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACK64  EnumSymbolsCallback,
    IN PVOID                        UserContext
    )
{
    return SympEnumerateSymbols(hProcess, BaseOfDll, (PROC)EnumSymbolsCallback, UserContext, TRUE, FALSE);
}

BOOL
IMAGEAPI
SymEnumerateSymbolsW64(
    IN HANDLE                       hProcess,
    IN ULONG64                      BaseOfDll,
    IN PSYM_ENUMSYMBOLS_CALLBACK64W EnumSymbolsCallback,
    IN PVOID                        UserContext
    )
{
    return SympEnumerateSymbols(hProcess, BaseOfDll, (PROC)EnumSymbolsCallback, UserContext, TRUE, TRUE);
}

BOOL
SympGetSymFromAddr(
    IN  HANDLE              hProcess,
    IN  DWORD64             Address,
    OUT PDWORD64            Displacement,
    OUT PSYMBOL_ENTRY       SymRet
    )

/*++

Routine Description:

    This function finds an entry in the symbol table based on an address.
    This is the common worker function for the 32 and 64 bit API.


Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    Address             - Address of the desired symbol.


    Displacement        - This value is set to the offset from the beginning
                          of the symbol.

    sym                 - Returns the found symbol

Return Value:

    TRUE - The symbol was located.

    FALSE - The symbol was not found.  Call GetLastError to
              discover the cause of the failure.

--*/

{
    PPROCESS_ENTRY      ProcessEntry;
    PMODULE_ENTRY       mi;
    PSYMBOL_ENTRY       psym;

    __try {

        ProcessEntry = FindProcessEntry( hProcess );
        if (!ProcessEntry) {
            SetLastError( ERROR_INVALID_HANDLE );
            return FALSE;
        }

        mi = GetModuleForPC( ProcessEntry, Address, FALSE );
        if (mi == NULL) {
            SetLastError( ERROR_MOD_NOT_FOUND );
            return FALSE;
        }

        if (!ENSURE_SYMBOLS(hProcess, mi)) {
            SetLastError( ERROR_MOD_NOT_FOUND );
            return FALSE;
        }
        
        psym = GetSymFromAddr( Address, Displacement, mi );
        if (psym) {
            *SymRet = *psym;
        } else {
            SetLastError( ERROR_INVALID_ADDRESS );
            return FALSE;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return TRUE;
}

BOOL
IMAGEAPI
SymGetSymFromAddr64(
    IN  HANDLE              hProcess,
    IN  DWORD64             Address,
    OUT PDWORD64            Displacement,
    OUT PIMAGEHLP_SYMBOL64  Symbol
    )

/*++

Routine Description:

    This function finds an entry in the symbol table based on an address.


Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    Address             - Address of the desired symbol.


    Displacement        - This value is set to the offset from the beginning
                          of the symbol.

    Symbol              - Returns the found symbol

Return Value:

    TRUE - The symbol was located.

    FALSE - The symbol was not found.  Call GetLastError to
              discover the cause of the failure.

--*/
{
    SYMBOL_ENTRY sym;

    if (SympGetSymFromAddr(hProcess, Address, Displacement, &sym)) {
        symcpy64(Symbol, &sym);
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
IMAGEAPI
SymGetSymFromAddr(
    IN  HANDLE              hProcess,
    IN  DWORD               Address,
    OUT PDWORD              Displacement,
    OUT PIMAGEHLP_SYMBOL    Symbol
    )

/*++

Routine Description:

    This function finds an entry in the symbol table based on an address.


Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    Address             - Address of the desired symbol.


    Displacement        - This value is set to the offset from the beginning
                          of the symbol.

    Symbol              - Returns the found symbol

Return Value:

    TRUE - The symbol was located.

    FALSE - The symbol was not found.  Call GetLastError to
              discover the cause of the failure.

--*/
{
    SYMBOL_ENTRY sym;
    DWORD64 qDisplacement;

    if (SympGetSymFromAddr(hProcess, Address, &qDisplacement, &sym)) {
        symcpy32(Symbol, &sym);
        if (Displacement) {
            *Displacement = (DWORD)qDisplacement;
        }
        return TRUE;
    } else {
        return FALSE;
    }
}


BOOL
SympGetSymFromName(
    IN  HANDLE          hProcess,
    IN  LPSTR           Name,
    OUT PSYMBOL_ENTRY   SymRet
    )

/*++

Routine Description:

    This function finds an entry in the symbol table based on a name.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    SymName             - A string containing the symbol name.

    sym                 - Returns the located symbol

Return Value:

    TRUE - The symbol was located.

    FALSE - The symbol was not found.  Call GetLastError to
              discover the cause of the failure.

--*/

{
    LPSTR               p;
    PPROCESS_ENTRY      ProcessEntry;
    PMODULE_ENTRY       mi = NULL;
    PLIST_ENTRY         Next;
    PSYMBOL_ENTRY       psym;


    __try {

        ProcessEntry = FindProcessEntry( hProcess );
        if (!ProcessEntry) {
            SetLastError( ERROR_INVALID_HANDLE );
            return FALSE;
        }

        p = strchr( Name, '!' );
        if (p > Name) {

            LPSTR ModName = MemAlloc(p - Name + 1);
            memcpy(ModName, Name, (int)(p - Name));
            ModName[p-Name] = 0;

            //
            // the caller wants to look in a specific module
            //

            mi = FindModule(hProcess, ProcessEntry, ModName, TRUE);

            MemFree(ModName);

            if (mi != NULL) {
                psym = FindSymbolByName( ProcessEntry, mi, p+1 );
                if (psym) {
                    *SymRet = *psym;
                    return TRUE;
                }
            }

            SetLastError( ERROR_MOD_NOT_FOUND );
            return FALSE;
        }

        Next = ProcessEntry->ModuleList.Flink;
        if (!Next) {
            SetLastError( ERROR_MOD_NOT_FOUND );
            return FALSE;
        }

        while (Next != &ProcessEntry->ModuleList) {

            mi = CONTAINING_RECORD( Next, MODULE_ENTRY, ListEntry );
            Next = mi->ListEntry.Flink;

            if (!ENSURE_SYMBOLS(hProcess, mi)) {
                continue;
            }

            psym = FindSymbolByName( ProcessEntry, mi, Name );
            if (psym) {
                *SymRet = *psym;
                return TRUE;
            }
        }

        SetLastError( ERROR_MOD_NOT_FOUND );
        return FALSE;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    SetLastError( ERROR_INVALID_FUNCTION );
    return FALSE;
}

BOOL
IMAGEAPI
SymGetSymFromName64(
    IN  HANDLE              hProcess,
    IN  LPSTR               Name,
    OUT PIMAGEHLP_SYMBOL64  Symbol
    )

/*++

Routine Description:

    This function finds an entry in the symbol table based on a name.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    SymName             - A string containing the symbol name.

    Symbol              - Returns found symbol

Return Value:

    TRUE - The symbol was located.

    FALSE - The symbol was not found.  Call GetLastError to
              discover the cause of the failure.

--*/
{
    SYMBOL_ENTRY sym;

    if (SympGetSymFromName(hProcess, Name, &sym)) {
        symcpy64(Symbol, &sym);
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
IMAGEAPI
SymGetSymFromName(
    IN  HANDLE              hProcess,
    IN  LPSTR               Name,
    OUT PIMAGEHLP_SYMBOL  Symbol
    )

/*++

Routine Description:

    This function finds an entry in the symbol table based on a name.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    SymName             - A string containing the symbol name.

    Symbol              - Returns found symbol

Return Value:

    TRUE - The symbol was located.

    FALSE - The symbol was not found.  Call GetLastError to
              discover the cause of the failure.

--*/
{
    SYMBOL_ENTRY sym;

    if (SympGetSymFromName(hProcess, Name, &sym)) {
        symcpy32(Symbol, &sym);
        return TRUE;
    } else {
        return FALSE;
    }
}


BOOL
IMAGEAPI
SymGetSymNext(
    IN     HANDLE              hProcess,
    IN OUT PIMAGEHLP_SYMBOL  Symbol32
    )

/*++

Routine Description:

    This function finds the next symbol in the symbol table that falls
    sequentially after the symbol passed in.


Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    Symbol              - Starting symbol.

Return Value:

    Non NULL pointer    - The symbol was located.

    NULL pointer        - The symbol was not found.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    PIMAGEHLP_SYMBOL64 Symbol64;
    BOOL r;

    Symbol64 = MemAlloc(sizeof(IMAGEHLP_SYMBOL64) + Symbol32->MaxNameLength);

    if (Symbol64) {
        SympConvertSymbol32To64(Symbol32, Symbol64);
        if (SympGetSymNextPrev(hProcess, Symbol64, 1)) {
            SympConvertSymbol64To32(Symbol64, Symbol32);
            r = TRUE;
        }

        MemFree(Symbol64);
    }
    return r;
}


BOOL
IMAGEAPI
SymGetSymNext64(
    IN     HANDLE              hProcess,
    IN OUT PIMAGEHLP_SYMBOL64  Symbol
    )

/*++

Routine Description:

    This function finds the next symbol in the symbol table that falls
    sequentially after the symbol passed in.


Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    Symbol              - Starting symbol.

Return Value:

    Non NULL pointer    - The symbol was located.

    NULL pointer        - The symbol was not found.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    return SympGetSymNextPrev(hProcess, Symbol, 1);
}

BOOL
IMAGEAPI
SymGetSymPrev(
    IN     HANDLE              hProcess,
    IN OUT PIMAGEHLP_SYMBOL  Symbol32
    )

/*++

Routine Description:

    This function finds the next symbol in the symbol table that falls
    sequentially after the symbol passed in.


Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    Symbol              - Starting symbol.

Return Value:

    Non NULL pointer    - The symbol was located.

    NULL pointer        - The symbol was not found.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    PIMAGEHLP_SYMBOL64 Symbol64;
    BOOL r = FALSE;

    Symbol64 = MemAlloc(sizeof(IMAGEHLP_SYMBOL64) + Symbol32->MaxNameLength);

    if (Symbol64) {
        SympConvertSymbol32To64(Symbol32, Symbol64);
        if (SympGetSymNextPrev(hProcess, Symbol64, -1)) {
            SympConvertSymbol64To32(Symbol64, Symbol32);
            r = TRUE;
        }
        MemFree(Symbol64);
    }
    return r;
}

BOOL
IMAGEAPI
SymGetSymPrev64(
    IN     HANDLE              hProcess,
    IN OUT PIMAGEHLP_SYMBOL64  Symbol
    )

/*++

Routine Description:

    This function finds the next symbol in the symbol table that falls
    sequentially after the symbol passed in.


Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    Symbol              - Starting symbol.

Return Value:

    Non NULL pointer    - The symbol was located.

    NULL pointer        - The symbol was not found.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    return SympGetSymNextPrev(hProcess, Symbol, -1);
}

BOOL
SympGetSymNextPrev(
    IN     HANDLE               hProcess,
    IN OUT PIMAGEHLP_SYMBOL64   Symbol,
    IN     int                  Direction
    )

/*++

Routine Description:

    Common code for SymGetSymNext and SymGetSymPrev.


Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    Symbol              - Starting symbol.

    Dir                 - Supplies direction to search

Return Value:

    Non NULL pointer    - The symbol was located.

    NULL pointer        - The symbol was not found.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    PPROCESS_ENTRY      ProcessEntry;
    PMODULE_ENTRY       mi;
    ULONG64             Displacement;
    PSYMBOL_ENTRY       sym;

    __try {

        ProcessEntry = FindProcessEntry( hProcess );
        if (!ProcessEntry) {
            SetLastError( ERROR_INVALID_HANDLE );
            return FALSE;
        }

        mi = GetModuleForPC( ProcessEntry, Symbol->Address, FALSE );
        if (mi == NULL) {
            SetLastError( ERROR_MOD_NOT_FOUND );
            return FALSE;
        }

        if (!ENSURE_SYMBOLS(hProcess, mi)) {
            SetLastError( ERROR_MOD_NOT_FOUND );
            return FALSE;
        }

        sym = GetSymFromAddr( Symbol->Address, &Displacement, mi );
        if (!sym) {
            SetLastError( ERROR_INVALID_ADDRESS );
            return FALSE;
        }

        if (mi->SymType == SymPdb && Direction < 0) {

            sym = GetSymFromAddr( sym->Address, &Displacement, mi );
            if (sym) {
                symcpy64( Symbol, sym );
            } else {
                SetLastError( ERROR_INVALID_ADDRESS );
                return FALSE;
            }

        } else if (mi->SymType == SymPdb) {

            DATASYM32 *nextSym;
            DATASYM32 *bestSym;
            DWORD64 bestAddr;
            PIMAGE_SECTION_HEADER sh;
            DWORD64 addr;
            ULONG k;
            LPSTR SymbolName;
            UCHAR SymbolLen;
            DWORD Bias;

            nextSym = (DATASYM32*)GSINextSym( mi->gsi, NULL );
            bestSym = NULL;
            bestAddr = (DWORD64)-1;

            while( nextSym ) {
                addr = 0;
                k = DataSymSeg(nextSym);

                if ((k <= mi->OriginalNumSections)) {
                    addr = mi->OriginalSectionHdrs[k-1].VirtualAddress + DataSymOffset(nextSym) + mi->BaseOfDll;

                    if ((addr > sym->Address) && (addr < bestAddr)) {

                        SymbolName = DataSymNameStart(nextSym);
                        // ignore strings
                        if (*(ULONG UNALIGNED *)SymbolName != 0x435f3f3f) { /* starts with ??_C */
                            bestAddr = addr;
                            bestSym = nextSym;
                        }
                    }
                }
                nextSym = (DATASYM32*)GSINextSym( mi->gsi, (PUCHAR)nextSym );
            }

            if (!bestSym) {
                SetLastError( ERROR_INVALID_ADDRESS );
                return FALSE;
            }

            SymbolName = DataSymNameStart(bestSym);
            SymbolLen  = DataSymNameLength(bestSym);

            sym = &mi->TmpSym;

            if (SymOptions & SYMOPT_UNDNAME) {
                SymUnDNameInternal( sym->Name, TMP_SYM_LEN-sizeof(*sym), SymbolName, SymbolLen);
            } else {
                // use strncat to always get a \0 at the end
                sym->Name[0] = 0;
                strncat( sym->Name, SymbolName, TMP_SYM_LEN-sizeof(*sym) );
            }
            sym->NameLength = strlen(sym->Name);

            addr = ConvertOmapFromSrc( mi, bestAddr, &Bias );

            if (addr != 0) {
                bestAddr = addr + Bias;
            }

            sym->Size = 0;
            sym->Flags = 0;
            sym->Address = bestAddr;

            symcpy64( Symbol, sym );

        } else {

            if (Direction > 0 && sym+1 >= mi->symbolTable+mi->numsyms) {
                SetLastError( ERROR_INVALID_ADDRESS );
                return FALSE;
            } else if (Direction < 0 && sym-1 < mi->symbolTable) {
                SetLastError( ERROR_INVALID_ADDRESS );
                return FALSE;
            }

            symcpy64( Symbol, sym + Direction);
        }


        return TRUE;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return FALSE;
}

BOOL
IMAGEAPI
SymGetLineFromAddr64(
    IN  HANDLE                  hProcess,
    IN  DWORD64                 dwAddr,
    OUT PDWORD                  pdwDisplacement,
    OUT PIMAGEHLP_LINE64        Line
    )

/*++

Routine Description:

    This function finds a source file and line number entry for the
    line closest to the given address.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    dwAddr              - Supplies an address for which a line is to be
                          located.

    pdwDisplacement     - Returns the offset between the given address
                          and the first instruction of the line.

    Line                - Returns the line and file information.

Return Value:

    TRUE                - A line was located.

    FALSE               - The line was not found.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    PPROCESS_ENTRY      ProcessEntry;
    PMODULE_ENTRY       mi;

    __try {
        if (Line->SizeOfStruct != sizeof(IMAGEHLP_LINE64)) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        ProcessEntry = FindProcessEntry( hProcess );
        if (!ProcessEntry) {
            SetLastError( ERROR_INVALID_HANDLE );
            return FALSE;
        }

        mi = GetModuleForPC( ProcessEntry, dwAddr, FALSE );
        if (mi == NULL) {
            SetLastError( ERROR_MOD_NOT_FOUND );
            return FALSE;
        }

        if (!ENSURE_SYMBOLS(hProcess, mi)) {
            SetLastError( ERROR_MOD_NOT_FOUND );
            return FALSE;
        }

        if (!GetLineFromAddr(mi, dwAddr, pdwDisplacement, Line)) {
            SetLastError( ERROR_INVALID_ADDRESS );
            return FALSE;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return TRUE;
}

BOOL
IMAGEAPI
SymGetLineFromAddr(
    IN  HANDLE                  hProcess,
    IN  DWORD                   dwAddr,
    OUT PDWORD                  pdwDisplacement,
    OUT PIMAGEHLP_LINE        Line32
    )
{
    IMAGEHLP_LINE64 Line64;
    Line64.SizeOfStruct = sizeof(Line64);
    if (SymGetLineFromAddr64(hProcess, dwAddr, pdwDisplacement, &Line64)) {
        SympConvertLine64To32(&Line64, Line32);
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
IMAGEAPI
SymGetLineFromName64(
    IN     HANDLE               hProcess,
    IN     LPSTR                ModuleName,
    IN     LPSTR                FileName,
    IN     DWORD                dwLineNumber,
       OUT PLONG                plDisplacement,
    IN OUT PIMAGEHLP_LINE64     Line
    )

/*++

Routine Description:

    This function finds an entry in the source file and line-number
    information based on a particular filename and line number.

    A module name can be given if the search is to be restricted to
    a specific module.

    The filename can be omitted if a pure line number search is desired,
    in which case Line must be a previously filled out line number
    struct.  The module and file that Line->Address lies in is used
    to look up the new line number.  This cannot be used when a module
    name is given.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    ModuleName          - Module name or NULL.

    FileName            - File name or NULL.

    dwLineNumber        - Line number of interest.

    plDisplacement      - Difference between requested line number and
                          returned line number.

    Line                - Line information input and return.

Return Value:

    TRUE                - A line was located.

    FALSE               - A line was not found.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    PPROCESS_ENTRY      ProcessEntry;
    PMODULE_ENTRY       mi = NULL;
    PLIST_ENTRY         Next;

    __try {
        if (Line->SizeOfStruct != sizeof(IMAGEHLP_LINE64)) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        ProcessEntry = FindProcessEntry( hProcess );
        if (!ProcessEntry) {
            SetLastError( ERROR_INVALID_HANDLE );
            return FALSE;
        }

        if (ModuleName != NULL) {

            //
            // The caller wants to look in a specific module.
            // A filename must be given in this case because it doesn't
            // make sense to do an address-driven search when a module
            // is explicitly specified since the address also specifies
            // a module.
            //

            if (FileName == NULL) {
                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }

            mi = FindModule(hProcess, ProcessEntry, ModuleName, TRUE);
            if (mi != NULL &&
                FindLineByName( mi, FileName, dwLineNumber, plDisplacement, Line )) {
                return TRUE;
            }

            SetLastError( ERROR_MOD_NOT_FOUND );
            return FALSE;
        }

        if (FileName == NULL) {
            // Only a line number has been given, implying that
            // it's a line in the same file as the given line is currently in.

            mi = GetModuleForPC( ProcessEntry, Line->Address, FALSE );
            if (mi == NULL) {
                SetLastError( ERROR_MOD_NOT_FOUND );
                return FALSE;
            }

            if (!ENSURE_SYMBOLS(hProcess, mi)) {
                SetLastError( ERROR_MOD_NOT_FOUND );
                return FALSE;
            }

            if (FindLineByName( mi, FileName, dwLineNumber,
                                plDisplacement, Line )) {
                return TRUE;
            }

            SetLastError( ERROR_MOD_NOT_FOUND );
            return FALSE;
        }

        Next = ProcessEntry->ModuleList.Flink;
        if (!Next) {
            SetLastError( ERROR_MOD_NOT_FOUND );
            return FALSE;
        }

        while (Next != &ProcessEntry->ModuleList) {

            mi = CONTAINING_RECORD( Next, MODULE_ENTRY, ListEntry );
            Next = mi->ListEntry.Flink;

            if (!ENSURE_SYMBOLS(hProcess, mi)) {
                continue;
            }

            if (FindLineByName( mi, FileName, dwLineNumber,
                                plDisplacement, Line )) {
                return TRUE;
            }
        }

        SetLastError( ERROR_MOD_NOT_FOUND );
        return FALSE;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    SetLastError( ERROR_INVALID_FUNCTION );
    return FALSE;
}

BOOL
IMAGEAPI
SymGetLineFromName(
    IN     HANDLE               hProcess,
    IN     LPSTR                ModuleName,
    IN     LPSTR                FileName,
    IN     DWORD                dwLineNumber,
       OUT PLONG                plDisplacement,
    IN OUT PIMAGEHLP_LINE     Line32
    )
{
    IMAGEHLP_LINE64 Line64;
    Line64.SizeOfStruct = sizeof(Line64);
    SympConvertLine32To64(Line32, &Line64);
    if (SymGetLineFromName64(hProcess,
                             ModuleName,
                             FileName,
                             dwLineNumber,
                             plDisplacement,
                             &Line64)) {
        return SympConvertLine64To32(&Line64, Line32);
    } else {
        return FALSE;
    }
}


BOOL
IMAGEAPI
SymGetLineNext64(
    IN     HANDLE               hProcess,
    IN OUT PIMAGEHLP_LINE64     Line
    )

/*++

Routine Description:

    This function returns line address information for the line immediately
    following the line given.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    Line                - Supplies line number information for the line
                          prior to the one being located.

Return Value:

    TRUE                - A line was located.  The Key, LineNumber and Address
                          of Line are updated.

    FALSE               - No such line exists.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    PPROCESS_ENTRY      ProcessEntry;
    PMODULE_ENTRY       mi;
    PSOURCE_LINE        SrcLine;
    PSOURCE_ENTRY       Src;

    __try {
        if (Line->SizeOfStruct != sizeof(IMAGEHLP_LINE64)) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        ProcessEntry = FindProcessEntry( hProcess );
        if (!ProcessEntry) {
            SetLastError( ERROR_INVALID_HANDLE );
            return FALSE;
        }

        // Use existing information to look up module and then
        // locate the file information.  The key could be extended
        // to make this unnecessary but it's done as a validation step
        // more than as a way to save a DWORD.

        SrcLine = (PSOURCE_LINE)Line->Key;

        mi = GetModuleForPC( ProcessEntry, SrcLine->Addr, FALSE );
        if (mi == NULL) {
            SetLastError( ERROR_MOD_NOT_FOUND );
            return FALSE;
        }

        for (Src = mi->SourceFiles; Src != NULL; Src = Src->Next) {
            if (SrcLine >= Src->LineInfo &&
                SrcLine < Src->LineInfo+Src->Lines) {
                break;
            }
        }

        if (Src == NULL) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        if (SrcLine == Src->LineInfo+Src->Lines-1) {
            SetLastError(ERROR_NO_MORE_ITEMS);
            return FALSE;
        }

        SrcLine++;
        Line->Key = SrcLine;
        Line->LineNumber = SrcLine->Line;
        Line->Address = SrcLine->Addr;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return TRUE;
}

BOOL
IMAGEAPI
SymGetLineNext(
    IN     HANDLE               hProcess,
    IN OUT PIMAGEHLP_LINE     Line32
    )
{
    IMAGEHLP_LINE64 Line64;
    Line64.SizeOfStruct = sizeof(Line64);
    SympConvertLine32To64(Line32, &Line64);
    if (SymGetLineNext64(hProcess, &Line64)) {
        return SympConvertLine64To32(&Line64, Line32);
    } else {
        return FALSE;
    }
}


BOOL
IMAGEAPI
SymGetLinePrev64(
    IN     HANDLE               hProcess,
    IN OUT PIMAGEHLP_LINE64     Line
    )

/*++

Routine Description:

    This function returns line address information for the line immediately
    before the line given.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    Line                - Supplies line number information for the line
                          after the one being located.

Return Value:

    TRUE                - A line was located.  The Key, LineNumber and Address
                          of Line are updated.

    FALSE               - No such line exists.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    PPROCESS_ENTRY      ProcessEntry;
    PMODULE_ENTRY       mi;
    PSOURCE_LINE        SrcLine;
    PSOURCE_ENTRY       Src;

    __try {
        if (Line->SizeOfStruct != sizeof(IMAGEHLP_LINE64)) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        ProcessEntry = FindProcessEntry( hProcess );
        if (!ProcessEntry) {
            SetLastError( ERROR_INVALID_HANDLE );
            return FALSE;
        }

        // Use existing information to look up module and then
        // locate the file information.  The key could be extended
        // to make this unnecessary but it's done as a validation step
        // more than as a way to save a DWORD.

        SrcLine = (PSOURCE_LINE)Line->Key;

        mi = GetModuleForPC( ProcessEntry, SrcLine->Addr, FALSE );
        if (mi == NULL) {
            SetLastError( ERROR_MOD_NOT_FOUND );
            return FALSE;
        }

        for (Src = mi->SourceFiles; Src != NULL; Src = Src->Next) {
            if (SrcLine >= Src->LineInfo &&
                SrcLine < Src->LineInfo+Src->Lines) {
                break;
            }
        }

        if (Src == NULL) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        if (SrcLine == Src->LineInfo) {
            SetLastError(ERROR_NO_MORE_ITEMS);
            return FALSE;
        }

        SrcLine--;
        Line->Key = SrcLine;
        Line->LineNumber = SrcLine->Line;
        Line->Address = SrcLine->Addr;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return TRUE;
}

BOOL
IMAGEAPI
SymGetLinePrev(
    IN     HANDLE               hProcess,
    IN OUT PIMAGEHLP_LINE     Line32
    )
{
    IMAGEHLP_LINE64 Line64;
    Line64.SizeOfStruct = sizeof(Line64);
    SympConvertLine32To64(Line32, &Line64);
    if (SymGetLinePrev64(hProcess, &Line64)) {
        return SympConvertLine64To32(&Line64, Line32);
    } else {
        return FALSE;
    }
}


BOOL
IMAGEAPI
SymMatchFileName(
    IN  LPSTR  FileName,
    IN  LPSTR  Match,
    OUT LPSTR *FileNameStop,
    OUT LPSTR *MatchStop
    )

/*++

Routine Description:

    This function attempts to match a string against a filename and path.
    The match string is allowed to be a suffix of the complete filename,
    so this function is useful for matching a plain filename against
    a fully qualified filename.

    Matching begins from the end of both strings and proceeds backwards.
    Matching is case-insensitive and equates \ with /.

Arguments:

    FileName            - Filename to match against.

    Match               - String to match against filename.

    FileNameStop        - Returns pointer into FileName where matching stopped.
                          May be one before FileName for full matches.
                          May be NULL.

    MatchStop           - Returns pointer info Match where matching stopped.
                          May be one before Match for full matches.
                          May be NULL.        

Return Value:

    TRUE                - Match is a matching suffix of FileName.

    FALSE               - Mismatch.

--*/

{
    LPSTR pF, pM;

    pF = FileName+strlen(FileName)-1;
    pM = Match+strlen(Match)-1;

    while (pF >= FileName && pM >= Match) {
        int chF, chM;

        chF = tolower(*pF);
        chF = chF == '\\' ? '/' : chF;
        chM = tolower(*pM);
        chM = chM == '\\' ? '/' : chM;

        if (chF != chM) {
            break;
        }

        pF--;
        pM--;
    }

    if (FileNameStop != NULL) {
        *FileNameStop = pF;
    }
    if (MatchStop != NULL) {
        *MatchStop = pM;
    }

    return pM < Match;
}


BOOL
IMAGEAPI
SymRegisterFunctionEntryCallback(
    IN HANDLE                     hProcess,
    IN PSYMBOL_FUNCENTRY_CALLBACK CallbackFunction,
    IN PVOID                      UserContext
    )
/*++

Routine Description:

    Set the address of a callback routine to access extended function
    table entries directly. This function is useful when debugging
    Alpha processes where RUNTIME_FUNCTION_ENTRYs are available from
    sources other than in the image. Two existing examples are:
    
    1) Access to dynamic function tables for run-time code
    2) Access to function tables for ROM images
    
Arguments:

    hProcess    - Process handle, must have been previously registered
                  with SymInitialize.
                          
                                
    DirectFunctionTableRoutine - Address of direct function table callback routine.
                  On alpha this routine must return a pointer to the
                  RUNTIME_FUNCTION_ENTRY containing the specified address.
                  If no such entry is available, it must return NULL.
    
Return Value:

    TRUE        - The callback was successfully registered

    FALSE       - The initialization failed. Most likely failure is that
                  the hProcess parameter is invalid. Call GetLastError()
                  for specific error codes.
--*/
{
    PPROCESS_ENTRY  ProcessEntry = NULL;

    __try {

        if (!CallbackFunction) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        ProcessEntry = FindProcessEntry( hProcess );
        if (!ProcessEntry) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        ProcessEntry->pFunctionEntryCallback32 = CallbackFunction;
        ProcessEntry->pFunctionEntryCallback64 = NULL;
        ProcessEntry->FunctionEntryUserContext = (ULONG64)UserContext;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }
    return TRUE;
}


BOOL
IMAGEAPI
SymRegisterFunctionEntryCallback64(
    IN HANDLE                       hProcess,
    IN PSYMBOL_FUNCENTRY_CALLBACK64 CallbackFunction,
    IN ULONG64                      UserContext
    )
/*++

Routine Description:

    See SymRegisterFunctionEntryCallback64
--*/    
{
    PPROCESS_ENTRY  ProcessEntry = NULL;

    __try {

        if (!CallbackFunction) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        ProcessEntry = FindProcessEntry( hProcess );
        if (!ProcessEntry) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        ProcessEntry->pFunctionEntryCallback32 = NULL;
        ProcessEntry->pFunctionEntryCallback64 = CallbackFunction;
        ProcessEntry->FunctionEntryUserContext = (ULONG64)UserContext;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }
    return TRUE;
}

LPVOID
IMAGEAPI
SymFunctionTableAccess(
    HANDLE  hProcess,
    DWORD   AddrBase
    )
{
    return SymFunctionTableAccess64(hProcess, AddrBase);
}

LPVOID
IMAGEAPI
SymFunctionTableAccess64(
    HANDLE  hProcess,
    DWORD64 AddrBase
    )

/*++

Routine Description:

    This function finds a function table entry or FPO record for an address.

Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    AddrBase            - Supplies an address for which a function table entry
                          or FPO entry is to be located.

Return Value:

    Non NULL pointer    - The symbol was located.

    NULL pointer        - The symbol was not found.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    PPROCESS_ENTRY  ProcessEntry;
    PMODULE_ENTRY   mi;
    PVOID           rtf;

    __try {

        ProcessEntry = FindProcessEntry( hProcess );
        if (!ProcessEntry) {
            SetLastError( ERROR_INVALID_HANDLE );
            return NULL;
        }

        mi = GetModuleForPC( ProcessEntry, AddrBase, FALSE );
        if (mi == NULL) {
            SetLastError( ERROR_MOD_NOT_FOUND );
            return NULL;
        }

        if (!ENSURE_SYMBOLS(hProcess, mi)) {
            SetLastError( ERROR_MOD_NOT_FOUND );
            return NULL;
        }

        switch (mi->MachineType) {
            default:
                rtf = NULL;
                break;

            case IMAGE_FILE_MACHINE_I386:
                if (!mi->pFpoData) {
                    rtf = NULL;
                } else {
                    DWORD Bias;
                    AddrBase = ConvertOmapToSrc( mi, AddrBase, &Bias, TRUE );
                    if (AddrBase == 0) {
                        rtf = NULL;
                    } else {
                        AddrBase += Bias;
                        rtf = SwSearchFpoData( (ULONG)(AddrBase - mi->BaseOfDll), mi->pFpoData, mi->dwEntries );
                    }
                }
                break;

            case IMAGE_FILE_MACHINE_ALPHA:             // Alpha_AXP
                rtf = LookupFunctionEntryAxp32( mi,
                                                (DWORD)AddrBase
                                                );
                break;

            case IMAGE_FILE_MACHINE_IA64:              // Intel 64
                rtf = LookupFunctionEntryIA64( mi,
                                               (ULONG)(AddrBase - mi->BaseOfDll)
                                               );
                break;

            case IMAGE_FILE_MACHINE_AXP64:             // AXP64

                rtf = LookupFunctionEntryAxp64( mi,
                                                AddrBase
                                                );
                break;
        }

        if (!rtf) {
            SetLastError( ERROR_INVALID_ADDRESS );
            return NULL;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return NULL;

    }

    return rtf;
}


BOOL
IMAGEAPI
SymGetModuleInfo64(
    IN  HANDLE              hProcess,
    IN  DWORD64             dwAddr,
    OUT PIMAGEHLP_MODULE64  ModuleInfo
    )
{
    PPROCESS_ENTRY          ProcessEntry;
    PMODULE_ENTRY           mi;
    DWORD                   SizeOfStruct;

    __try {

        ProcessEntry = FindProcessEntry( hProcess );
        if (!ProcessEntry) {
            SetLastError( ERROR_INVALID_HANDLE );
            return FALSE;
        }

        mi = GetModuleForPC( ProcessEntry, dwAddr, FALSE );
        if (mi == NULL) {
            SetLastError( ERROR_MOD_NOT_FOUND );
            return FALSE;
        }

        SizeOfStruct = ModuleInfo->SizeOfStruct;
        if (SizeOfStruct > sizeof(IMAGEHLP_MODULE64)) {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }
        ZeroMemory( ModuleInfo, SizeOfStruct);
        ModuleInfo->SizeOfStruct = SizeOfStruct;

        ModuleInfo->BaseOfImage = mi->BaseOfDll;
        ModuleInfo->ImageSize = mi->DllSize;
        ModuleInfo->NumSyms = mi->numsyms;
        ModuleInfo->CheckSum = mi->CheckSum;
        ModuleInfo->TimeDateStamp = mi->TimeDateStamp;
        ModuleInfo->SymType = mi->SymType;
        strcpy( ModuleInfo->ModuleName, mi->ModuleName );
        if (mi->ImageName) {
            strcpy( ModuleInfo->ImageName, mi->ImageName );
        }
        if (mi->LoadedImageName) {
            strcpy( ModuleInfo->LoadedImageName, mi->LoadedImageName );
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return TRUE;
}



/*++

Routine Description:

    This routine is used to get type information from a type index or a type-name
    in the module. 
    
   TypeIn      -  Specifies the type of the input
   
   DataIn      -  Pointer to Input data         
   
   TypeOut     -  Specifies type of output data and what kind of processing to 
                  be done.
   
   SizeOut     -  Size of the buffer allocated to the DataOut pointer
   
   DataOut     -  Value/Record to be returned is copied here.
   
++*/

BOOL
IMAGEAPI
SymGetModuleInfoEx64(
    IN  HANDLE          hProcess,
    IN  DWORD64         Address,
    IN  IMAGEHLP_TYPES  TypeIn,
    IN  PBYTE           DataIn,
    IN  IMAGEHLP_TYPES  TypeOut,
    IN  OUT PULONG      SizeOut,
    IN  OUT PBYTE       DataOut
    ){
    PPROCESS_ENTRY      ProcessEntry;
    PLIST_ENTRY         Next;
    PMODULE_ENTRY       ModuleEntry;
    PIMGHLP_DEBUG_DATA  pIDD;
    PMODULE_TYPE_INFO   pModTypes;
    BOOL res=0;

    __try {

       if (!SizeOut || !DataOut || !DataIn) {
          return FALSE;
       }

       ProcessEntry = FindProcessEntry( hProcess );
       if (!ProcessEntry) {
          SetLastError( ERROR_INVALID_HANDLE );
          return FALSE;
       }

       Next = ProcessEntry->ModuleList.Flink;
       if (Next) {
          while (Next != &ProcessEntry->ModuleList) {
             ModuleEntry = CONTAINING_RECORD( Next, MODULE_ENTRY, ListEntry );
             Next = ModuleEntry->ListEntry.Flink;
             if (ModuleEntry->BaseOfDll == Address) {
                break;
             }
          }
       }

       if (!ModuleEntry) {
          return FALSE;
       }

       switch (TypeOut) {
       case IMAGEHLP_TYPEID_MODULE_TYPE_INFO: {
          PBYTE buffer; 
          PDWORD plen;
          CV_typ_t typIndex;

          if (TypeIn == IMAGEHLP_TYPEID_INDEX) {
             typIndex = *((PULONG) DataIn);
          } else {
             break;
          }

          if (ModuleEntry->ptpi) {
             if (*SizeOut) {
                plen = SizeOut; 
                buffer = DataOut;
                return(TypesQueryCVRecordForTi(ModuleEntry->ptpi, typIndex, 
                                               buffer, plen));
             }
          }
          return FALSE;
       } 

       case IMAGEHLP_TYPEID_INDEX: {      
          LPSTR name;
          CV_typ_t *typIndex;

          if (TypeIn == IMAGEHLP_TYPEID_NAME) {
             name = ((LPSTR) DataIn);
          } else {
             break;
          }
          if (*SizeOut >= 4) {
             if (ModuleEntry->ptpi) {
                if (TypesQueryTiForUDT((TPI *) ModuleEntry->ptpi, name, FALSE, (CV_typ_t *) DataOut)) {
                   return TRUE;
                }
             }
             // Try to get something from globals
             return GetPdbTypeInfo((DBI *) ModuleEntry->dbi, 
                                   (GSI *) ModuleEntry->globals, 
                                   name, 
                                   FALSE, 
                                   TypeOut,
                                   DataOut);

          }
          break;
       }

       case IMAGEHLP_TYPEID_TYPE_ENUM_INFO : {
          LPSTR  nameIn=NULL;
          CHAR name[MAX_SYM_NAME + 1];
          ULONG len, res;
          BOOL partial=FALSE;
          CV_typ_t *typeIndex;
          GSI *Globals;

          switch (TypeIn) {
          case IMAGEHLP_TYPEID_IMAGEHLP_SYMBOL64: {
             PIMAGEHLP_SYMBOL64 pTypeName = (PIMAGEHLP_SYMBOL64) DataIn;
             if (pTypeName->SizeOfStruct == sizeof(IMAGEHLP_SYMBOL64)) {
                nameIn = &pTypeName->Name[0];
             }
             break;
          }
          case IMAGEHLP_TYPEID_IMAGEHLP_SYMBOL: {
             PIMAGEHLP_SYMBOL pTypeName = (PIMAGEHLP_SYMBOL) DataIn;
             if (pTypeName->SizeOfStruct == sizeof(IMAGEHLP_SYMBOL)) {
                nameIn = &pTypeName->Name[0];
             }
             break;
          }

          case IMAGEHLP_TYPEID_NAME: {
             nameIn = (LPSTR) DataIn;
             break;
          }
          default:
             break;
          }

          if (!nameIn) {
             break;
          }

          ZeroMemory(name, sizeof(name)); len = strlen (nameIn);
          strncpy(name, nameIn, ( len > MAX_SYM_NAME ? MAX_SYM_NAME : len));

          return GetPdbTypeInfo((DBI *) ModuleEntry->dbi, 
                                (GSI *) ModuleEntry->globals, 
                                name, 
                                TRUE, 
                                TypeOut,
                                DataOut);
       }

       default:
          break;
       } /* switch */

    } __except (EXCEPTION_EXECUTE_HANDLER) {

         ImagepSetLastErrorFromStatus( GetExceptionCode() );
         return FALSE;

    }

    return FALSE;
}


BOOL
IMAGEAPI
SymGetModuleInfoEx(
    IN  HANDLE          hProcess,
    IN  DWORD           Address,
    IN  IMAGEHLP_TYPES  TypeIn,
    IN  PBYTE           DataIn,
    IN  IMAGEHLP_TYPES  TypeOut,
    IN  OUT PULONG      SizeOut,
    IN  OUT PBYTE       DataOut
    ) {
   return SymGetModuleInfoEx64(hProcess, Address, TypeIn, DataIn, TypeOut, SizeOut, DataOut);
}

BOOL
IMAGEAPI
SymGetModuleInfoW(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr,
    OUT PIMAGEHLP_MODULEW   W_ModuleInfo
    )
{
    IMAGEHLP_MODULE A_ModuleInfo;

    if (W_ModuleInfo->SizeOfStruct != sizeof(IMAGEHLP_MODULEW)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    ZeroMemory(W_ModuleInfo, sizeof(IMAGEHLP_MODULEW));
    W_ModuleInfo->SizeOfStruct = sizeof(IMAGEHLP_MODULEW);
    
    if (!SympConvertUnicodeModule32ToAnsiModule32(
        W_ModuleInfo, &A_ModuleInfo)) 
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!SymGetModuleInfo(hProcess, dwAddr, &A_ModuleInfo)) {
        return FALSE;
    }

    if (!SympConvertAnsiModule32ToUnicodeModule32(
        &A_ModuleInfo, W_ModuleInfo)) {

        return FALSE;
    }
    return TRUE;
}

BOOL
IMAGEAPI
SymGetModuleInfoW64(
    IN  HANDLE              hProcess,
    IN  DWORD64             dwAddr,
    OUT PIMAGEHLP_MODULEW64 W_ModuleInfo
    )
{

    IMAGEHLP_MODULE64 A_ModuleInfo;

    if (!SympConvertUnicodeModule64ToAnsiModule64(
        W_ModuleInfo, &A_ModuleInfo)) {

        return FALSE;
    }

    if (!SymGetModuleInfo64(hProcess, dwAddr, &A_ModuleInfo)) {
        return FALSE;
    }

    if (!SympConvertAnsiModule64ToUnicodeModule64(
        &A_ModuleInfo, W_ModuleInfo)) {

        return FALSE;
    }
    return TRUE;
}

BOOL
IMAGEAPI
SymGetModuleInfo(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr,
    OUT PIMAGEHLP_MODULE   ModuleInfo
    )
{
    PPROCESS_ENTRY          ProcessEntry;
    PMODULE_ENTRY           mi;
    DWORD                   SizeOfStruct;

    __try {

        ProcessEntry = FindProcessEntry( hProcess );
        if (!ProcessEntry) {
            SetLastError( ERROR_INVALID_HANDLE );
            return FALSE;
        }

        mi = GetModuleForPC( ProcessEntry,
            dwAddr == (DWORD)-1 ? (DWORD64)-1 : dwAddr, FALSE );
        if (mi == NULL) {
            SetLastError( ERROR_MOD_NOT_FOUND );
            return FALSE;
        }

        SizeOfStruct = ModuleInfo->SizeOfStruct;
        if (SizeOfStruct > sizeof(IMAGEHLP_MODULE)) {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }
        ZeroMemory( ModuleInfo, SizeOfStruct);
        ModuleInfo->SizeOfStruct = SizeOfStruct;

        ModuleInfo->BaseOfImage = (DWORD)mi->BaseOfDll;
        ModuleInfo->ImageSize = mi->DllSize;
        ModuleInfo->NumSyms = mi->numsyms;
        ModuleInfo->CheckSum = mi->CheckSum;
        ModuleInfo->TimeDateStamp = mi->TimeDateStamp;
        ModuleInfo->SymType = mi->SymType;
        strcpy( ModuleInfo->ModuleName, mi->ModuleName );
        if (mi->ImageName) {
            strcpy( ModuleInfo->ImageName, mi->ImageName );
        }
        if (mi->LoadedImageName) {
            strcpy( ModuleInfo->LoadedImageName, mi->LoadedImageName );
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return TRUE;
}

DWORD64
IMAGEAPI
SymGetModuleBase64(
    IN  HANDLE  hProcess,
    IN  DWORD64 dwAddr
    )
{
    PPROCESS_ENTRY          ProcessEntry;
    PMODULE_ENTRY           mi;


    __try {

        ProcessEntry = FindProcessEntry( hProcess );
        if (!ProcessEntry) {
            return 0;
        }

        mi = GetModuleForPC( ProcessEntry, dwAddr, FALSE );
        if (mi == NULL) {
            return 0;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return mi->BaseOfDll;
}

DWORD
IMAGEAPI
SymGetModuleBase(
    IN  HANDLE hProcess,
    IN  DWORD  dwAddr
    )
{
    return (ULONG)SymGetModuleBase64(hProcess, dwAddr);
}

BOOL
IMAGEAPI
SymUnloadModule64(
    IN  HANDLE      hProcess,
    IN  DWORD64     BaseOfDll
    )

/*++

Routine Description:

    Remove the symbols for an image from a process' symbol table.

Arguments:

    hProcess - Supplies the token which refers to the process

    BaseOfDll - Supplies the offset to the image as supplies by the
        LOAD_DLL_DEBUG_EVENT and UNLOAD_DLL_DEBUG_EVENT.

Return Value:

    Returns TRUE if the module's symbols were successfully unloaded.
    Returns FALSE if the symbol handler does not recognize hProcess or
    no image was loaded at the given offset.

--*/

{
    PPROCESS_ENTRY  ProcessEntry;
    PLIST_ENTRY     Next;
    PMODULE_ENTRY   ModuleEntry;


    __try {

        ProcessEntry = FindProcessEntry( hProcess );
        if (!ProcessEntry) {
            return FALSE;
        }

        Next = ProcessEntry->ModuleList.Flink;
        if (Next) {
            while (Next != &ProcessEntry->ModuleList) {
                ModuleEntry = CONTAINING_RECORD( Next, MODULE_ENTRY, ListEntry );
                if (ModuleEntry->BaseOfDll == BaseOfDll) {
                    RemoveEntryList(Next);
                    FreeModuleEntry(ModuleEntry);
                    return TRUE;
                }
                Next = ModuleEntry->ListEntry.Flink;
            }
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return FALSE;
}

BOOL
IMAGEAPI
SymUnloadModule(
    IN  HANDLE      hProcess,
    IN  DWORD       BaseOfDll
    )
{
    return SymUnloadModule64(hProcess, BaseOfDll);
}

DWORD64
IMAGEAPI
SymLoadModule64(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD64         BaseOfDll,
    IN  DWORD           DllSize
    )

/*++

Routine Description:

    Loads the symbols for an image for use by the other Sym functions.

Arguments:

    hProcess - Supplies unique process identifier.

    hFile -

    ImageName - Supplies the name of the image file.

    ModuleName - ???? Supplies the module name that will be returned by
            enumeration functions ????

    BaseOfDll - Supplies loaded base address of image.

    DllSize


Return Value:


--*/

{
    __try {

        return InternalLoadModule( hProcess, ImageName, ModuleName, BaseOfDll, DllSize, hFile );

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return 0;

    }
}

DWORD
IMAGEAPI
SymLoadModule(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD           BaseOfDll,
    IN  DWORD           DllSize
    )
{
    return (DWORD)SymLoadModule64( hProcess, hFile, ImageName, ModuleName, BaseOfDll, DllSize );
}

BOOL
IMAGEAPI
SymUnDName(
    IN  PIMAGEHLP_SYMBOL  sym,
    OUT LPSTR               UnDecName,
    OUT DWORD               UnDecNameLength
    )
{
    __try {

        if (SymUnDNameInternal( UnDecName, UnDecNameLength-1, sym->Name, strlen(sym->Name) )) {
            return TRUE;
        } else {
            return FALSE;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }
}

BOOL
IMAGEAPI
SymUnDName64(
    IN  PIMAGEHLP_SYMBOL64  sym,
    OUT LPSTR               UnDecName,
    OUT DWORD               UnDecNameLength
    )
{
    __try {

        if (SymUnDNameInternal( UnDecName, UnDecNameLength-1, sym->Name, strlen(sym->Name) )) {
            return TRUE;
        } else {
            return FALSE;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }
}


BOOL
IMAGEAPI
SymGetSearchPath(
    IN  HANDLE          hProcess,
    OUT LPSTR           SearchPath,
    IN  DWORD           SearchPathLength
    )

/*++

Routine Description:

    This function looks up the symbol search path associated with a process.

Arguments:

    hProcess - Supplies the token associated with a process.

Return Value:

    A pointer to the search path.  Returns NULL if the process is not
    know to the symbol handler.

--*/

{
    PPROCESS_ENTRY ProcessEntry;


    __try {

        ProcessEntry = FindProcessEntry( hProcess );

        if (!ProcessEntry) {
            return FALSE;
        }

        SearchPath[0] = 0;
        strncat( SearchPath, ProcessEntry->SymbolSearchPath, SearchPathLength );

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return TRUE;
}

BOOL
IMAGEAPI
SymSetSearchPath(
    HANDLE      hProcess,
    LPSTR       UserSearchPath
    )

/*++

Routine Description:

    This functions sets the searh path to be used by the symbol loader
    for the given process.  If UserSearchPath is not supplied, a default
    path will be used.

Arguments:

    hProcess - Supplies the process token associated with a symbol table.

    UserSearchPath - Supplies the new search path to associate with the
        process. If this argument is NULL, the following path is generated:

        .;%_NT_SYMBOL_PATH%;%_NT_ALTERNATE_SYMBOL_PATH%;%WINDIR%

        It is ok if any or all of the environment variables is missing.

Return Value:

    A pointer to the new search path.  The user should not modify this string.
    Returns NULL if the process is not known to the symbol handler.

--*/

{
    PPROCESS_ENTRY  ProcessEntry;
    LPSTR           p;
    DWORD           cbSymPath;
    DWORD           cb;
    char            ExpandedSearchPath[MAX_PATH];

    __try {

        ProcessEntry = FindProcessEntry( hProcess );
        if (!ProcessEntry) {
            return FALSE;
        }

        if (ProcessEntry->SymbolSearchPath) {
            MemFree(ProcessEntry->SymbolSearchPath);
        }

        if (UserSearchPath) {
            cbSymPath = ExpandEnvironmentStrings(UserSearchPath, 
                                     ExpandedSearchPath, 
                                     sizeof(ExpandedSearchPath) / sizeof(ExpandedSearchPath[0]));
            if (cbSymPath < sizeof(ExpandedSearchPath)/sizeof(ExpandedSearchPath[0])) {
            ProcessEntry->SymbolSearchPath = StringDup(ExpandedSearchPath);
            } else {
                ProcessEntry->SymbolSearchPath = (LPSTR)MemAlloc( cbSymPath );
                ExpandEnvironmentStrings(UserSearchPath, 
                                         ProcessEntry->SymbolSearchPath,
                                         cbSymPath );
            }
        } else {

            //
            // ".;%_NT_SYMBOL_PATH%;%_NT_ALTERNATE_SYMBOL_PATH%;%WINDIR%"
            //

            cbSymPath = 2;     // ".;"

            //
            // GetEnvironmentVariable returns the size of the string
            // INCLUDING the '\0' in this case.
            //
            cbSymPath += GetEnvironmentVariable( SYMBOL_PATH, NULL, 0 );
            cbSymPath += GetEnvironmentVariable( ALTERNATE_SYMBOL_PATH, NULL, 0 );
            cbSymPath += GetEnvironmentVariable( WINDIR, NULL, 0 );


            p = ProcessEntry->SymbolSearchPath = (LPSTR) MemAlloc( cbSymPath );
            if (!p) {
                return FALSE;
            }

            *p++ = '.';
            --cbSymPath;

            cb = GetEnvironmentVariable(SYMBOL_PATH, p+1, cbSymPath);
            if (cb) {
                *p = ';';
                p += cb+1;
                cbSymPath -= cb+1;
            }

            cb = GetEnvironmentVariable(ALTERNATE_SYMBOL_PATH, p+1, cbSymPath);
            if (cb) {
                *p = ';';
                p += cb+1;
                cbSymPath -= cb+1;
            }

            cb = GetEnvironmentVariable(WINDIR, p+1, cbSymPath);
            if (cb) {
                *p = ';';
                p += cb+1;
            }

            *p = 0;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return TRUE;
}


BOOL
IMAGEAPI
EnumerateLoadedModules(
    IN HANDLE                           hProcess,
    IN PENUMLOADED_MODULES_CALLBACK     EnumLoadedModulesCallback,
    IN PVOID                            UserContext
    )
{
    LOADED_MODULE lm;
    DWORD status = NO_ERROR;

    __try {

        lm.EnumLoadedModulesCallback32 = EnumLoadedModulesCallback;
        lm.EnumLoadedModulesCallback64 = NULL;
        lm.Context = UserContext;

        status = GetProcessModules( hProcess, (PINTERNAL_GET_MODULE)LoadedModuleEnumerator, (PVOID)&lm );

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return (status == NO_ERROR);
}


BOOL
IMAGEAPI
EnumerateLoadedModules64(
    IN HANDLE                           hProcess,
    IN PENUMLOADED_MODULES_CALLBACK64   EnumLoadedModulesCallback,
    IN PVOID                            UserContext
    )
{
    LOADED_MODULE lm;
    DWORD status = NO_ERROR;

    __try {

        lm.EnumLoadedModulesCallback64 = EnumLoadedModulesCallback;
        lm.EnumLoadedModulesCallback32 = NULL;
        lm.Context = UserContext;

        status = GetProcessModules( hProcess, LoadedModuleEnumerator, (PVOID)&lm );

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return (status == NO_ERROR);
}

BOOL
IMAGEAPI
SymRegisterCallback(
    IN HANDLE                        hProcess,
    IN PSYMBOL_REGISTERED_CALLBACK   CallbackFunction,
    IN PVOID                         UserContext
    )
{
    PPROCESS_ENTRY  ProcessEntry = NULL;

    __try {

        if (!CallbackFunction) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        ProcessEntry = FindProcessEntry( hProcess );
        if (!ProcessEntry) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        ProcessEntry->pCallbackFunction32 = CallbackFunction;
        ProcessEntry->pCallbackFunction64 = NULL;
        ProcessEntry->CallbackUserContext = (ULONG64)UserContext;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return TRUE;
}


BOOL
IMAGEAPI
SymRegisterCallback64(
    IN HANDLE                        hProcess,
    IN PSYMBOL_REGISTERED_CALLBACK64 CallbackFunction,
    IN ULONG64                       UserContext
    )
{
    PPROCESS_ENTRY  ProcessEntry = NULL;

    __try {

        if (!CallbackFunction) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        ProcessEntry = FindProcessEntry( hProcess );
        if (!ProcessEntry) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        ProcessEntry->pCallbackFunction32 = NULL;
        ProcessEntry->pCallbackFunction64 = CallbackFunction;
        ProcessEntry->CallbackUserContext = UserContext;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return TRUE;
}

BOOL
SympConvertAnsiModule32ToUnicodeModule32(
    PIMAGEHLP_MODULE  A_Module32,
    PIMAGEHLP_MODULEW W_Module32
    )
{
    // BUGBUG - kcarlos - Better sizeof validation

    ZeroMemory(W_Module32, sizeof(*W_Module32));
    W_Module32->SizeOfStruct = sizeof(*W_Module32);

    W_Module32->BaseOfImage = A_Module32->BaseOfImage;
    W_Module32->ImageSize = A_Module32->ImageSize;
    W_Module32->TimeDateStamp = A_Module32->TimeDateStamp;
    W_Module32->CheckSum = A_Module32->CheckSum;
    W_Module32->NumSyms = A_Module32->NumSyms;
    W_Module32->SymType = A_Module32->SymType;

    if (!CopyAnsiToUnicode(W_Module32->ModuleName, A_Module32->ModuleName,
        sizeof(A_Module32->ModuleName) / sizeof(A_Module32->ModuleName[0])) ) {

        return FALSE;
    }

    if (!CopyAnsiToUnicode(W_Module32->ImageName, A_Module32->ImageName,
        sizeof(A_Module32->ImageName) / sizeof(A_Module32->ImageName[0])) ) {

        return FALSE;
    }

    if (!CopyAnsiToUnicode(W_Module32->LoadedImageName, A_Module32->LoadedImageName,
        sizeof(A_Module32->LoadedImageName) / sizeof(A_Module32->LoadedImageName[0])) ) {

        return FALSE;
    }

    return TRUE;
}

BOOL
SympConvertUnicodeModule32ToAnsiModule32(
    PIMAGEHLP_MODULEW W_Module32,
    PIMAGEHLP_MODULE  A_Module32
    )
{
    ZeroMemory(A_Module32, sizeof(*A_Module32));
    A_Module32->SizeOfStruct = sizeof(*A_Module32);

    A_Module32->BaseOfImage = W_Module32->BaseOfImage;
    A_Module32->ImageSize = W_Module32->ImageSize;
    A_Module32->TimeDateStamp = W_Module32->TimeDateStamp;
    A_Module32->CheckSum = W_Module32->CheckSum;
    A_Module32->NumSyms = W_Module32->NumSyms;
    A_Module32->SymType = W_Module32->SymType;

    if (!CopyUnicodeToAnsi(A_Module32->ModuleName, W_Module32->ModuleName,
        sizeof(W_Module32->ModuleName) / sizeof(W_Module32->ModuleName[0])) ) {

        return FALSE;
    }

    if (!CopyUnicodeToAnsi(A_Module32->ImageName, W_Module32->ImageName,
        sizeof(W_Module32->ImageName) / sizeof(W_Module32->ImageName[0])) ) {

        return FALSE;
    }

    if (!CopyUnicodeToAnsi(A_Module32->LoadedImageName, W_Module32->LoadedImageName,
        sizeof(W_Module32->LoadedImageName) / sizeof(W_Module32->LoadedImageName[0])) ) {

        return FALSE;
    }

    return TRUE;
}


BOOL
SympConvertAnsiModule64ToUnicodeModule64(
    PIMAGEHLP_MODULE64  A_Module64,
    PIMAGEHLP_MODULEW64 W_Module64
    )
{
    // BUGBUG - kcarlos - Better sizeof validation

    ZeroMemory(W_Module64, sizeof(*W_Module64));
    W_Module64->SizeOfStruct = sizeof(*W_Module64);

    W_Module64->BaseOfImage = A_Module64->BaseOfImage;
    W_Module64->ImageSize = A_Module64->ImageSize;
    W_Module64->TimeDateStamp = A_Module64->TimeDateStamp;
    W_Module64->CheckSum = A_Module64->CheckSum;
    W_Module64->NumSyms = A_Module64->NumSyms;
    W_Module64->SymType = A_Module64->SymType;

    if (!CopyAnsiToUnicode(W_Module64->ModuleName, A_Module64->ModuleName,
        sizeof(A_Module64->ModuleName) / sizeof(A_Module64->ModuleName[0])) ) {

        return FALSE;
    }

    if (!CopyAnsiToUnicode(W_Module64->ImageName, A_Module64->ImageName,
        sizeof(A_Module64->ImageName) / sizeof(A_Module64->ImageName[0])) ) {

        return FALSE;
    }

    if (!CopyAnsiToUnicode(W_Module64->LoadedImageName, A_Module64->LoadedImageName,
        sizeof(A_Module64->LoadedImageName) / sizeof(A_Module64->LoadedImageName[0])) ) {

        return FALSE;
    }

    return TRUE;
}

BOOL
SympConvertUnicodeModule64ToAnsiModule64(
    PIMAGEHLP_MODULEW64 W_Module64,
    PIMAGEHLP_MODULE64  A_Module64
    )
{
    ZeroMemory(A_Module64, sizeof(*A_Module64));
    A_Module64->SizeOfStruct = sizeof(*A_Module64);

    A_Module64->BaseOfImage = W_Module64->BaseOfImage;
    A_Module64->ImageSize = W_Module64->ImageSize;
    A_Module64->TimeDateStamp = W_Module64->TimeDateStamp;
    A_Module64->CheckSum = W_Module64->CheckSum;
    A_Module64->NumSyms = W_Module64->NumSyms;
    A_Module64->SymType = W_Module64->SymType;

    if (!CopyUnicodeToAnsi(A_Module64->ModuleName, W_Module64->ModuleName,
        sizeof(W_Module64->ModuleName) / sizeof(W_Module64->ModuleName[0])) ) {

        return FALSE;
    }

    if (!CopyUnicodeToAnsi(A_Module64->ImageName, W_Module64->ImageName,
        sizeof(W_Module64->ImageName) / sizeof(W_Module64->ImageName[0])) ) {

        return FALSE;
    }

    if (!CopyUnicodeToAnsi(A_Module64->LoadedImageName, W_Module64->LoadedImageName,
        sizeof(W_Module64->LoadedImageName) / sizeof(W_Module64->LoadedImageName[0])) ) {

        return FALSE;
    }

    return TRUE;
}

/*++

Routine Description:

    This routine looks up a global variable and returns the index for its type.
    
   TypeIn      -  Specifies the type of the input
   
   DataIn      -  Pointer to Input data         
   
   TypeOut     -  Specifies type of output data and what kind of processing to 
                  be done.
   
   SizeOut     -  Size of the buffer allocated to the DataOut pointer
   
   DataOut     -  Value/Record to be returned is copied here.
   
++*/

BOOL 
IMAGEAPI
SymGetSymbolInfo64(
    IN  HANDLE          hProcess,
    IN  DWORD64         Address,
    IN  IMAGEHLP_TYPES  TypeIn,
    IN  PBYTE           DataIn,
    IN  IMAGEHLP_TYPES  TypeOut,
    IN  OUT PULONG      SizeOut,
    IN  OUT PBYTE       DataOut
    ){   
    PMODULE_ENTRY me, ModuleEntry;
    PPROCESS_ENTRY ProcessEntry;
    PLIST_ENTRY Next;
    BOOL partial=TRUE;

    __try {
       if (!SizeOut || !DataOut || !DataIn) {
          return FALSE;
       }

       ProcessEntry = FindProcessEntry( hProcess );
       if (!ProcessEntry) {
          SetLastError(ERROR_INVALID_HANDLE);
          return FALSE;
       }

       me = NULL;
       Next = ProcessEntry->ModuleList.Flink;
       if (Next) {
          while (Next != &ProcessEntry->ModuleList) {
             ModuleEntry = CONTAINING_RECORD( Next, MODULE_ENTRY, ListEntry );
             Next = ModuleEntry->ListEntry.Flink;
             if (ModuleEntry->BaseOfDll == Address) {
                me = ModuleEntry;
             }
          }
       }

       if (!me) {
          return FALSE;
       }
       ModuleEntry = me;

       if ((TypeOut == IMAGEHLP_TYPEID_INDEX) ||
           (TypeOut == IMAGEHLP_TYPEID_TYPE_ENUM_INFO)) {
          LPSTR  nameIn=NULL;
          CHAR name[MAX_SYM_NAME + 1];
          ULONG len;
          CV_typ_t *typeIndex;

          switch (TypeIn) {
          case IMAGEHLP_TYPEID_IMAGEHLP_SYMBOL64: {
             PIMAGEHLP_SYMBOL64 pTypeName = (PIMAGEHLP_SYMBOL64) DataIn;
             if (pTypeName->SizeOfStruct == sizeof(IMAGEHLP_SYMBOL64)) {
                nameIn = &pTypeName->Name[0];
             }
             break;
          }
          case IMAGEHLP_TYPEID_IMAGEHLP_SYMBOL: {
             PIMAGEHLP_SYMBOL pTypeName = (PIMAGEHLP_SYMBOL) DataIn;
             if (pTypeName->SizeOfStruct == sizeof(IMAGEHLP_SYMBOL)) {
                nameIn = &pTypeName->Name[0];
             }
             break;
          }
          case IMAGEHLP_TYPEID_NAME: {
             nameIn = (LPSTR) DataIn;
             break;
          }
          default:
             break;
          }

          if (!nameIn) {
             return FALSE;
          }

          ZeroMemory(name, sizeof(name)); len = strlen (nameIn);
          strncpy(name, nameIn, ( len > MAX_SYM_NAME ? MAX_SYM_NAME : len));

          return GetPdbTypeInfo((DBI *) ModuleEntry->dbi, 
                                (GSI *) ModuleEntry->gsi, 
                                name, 
                                TypeOut == IMAGEHLP_TYPEID_TYPE_ENUM_INFO,
                                TypeOut, 
                                DataOut);
       }
       return FALSE;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
         ImagepSetLastErrorFromStatus( GetExceptionCode() );
         return FALSE;
    }
    return FALSE;
}

BOOL 
IMAGEAPI
SymGetSymbolInfo(
    IN  HANDLE          hProcess,
    IN  DWORD           Address,
    IN  IMAGEHLP_TYPES  TypeIn,
    IN  PBYTE           DataIn,
    IN  IMAGEHLP_TYPES  TypeOut,
    IN  OUT PULONG      SizeOut,
    IN  OUT PBYTE       DataOut
    ) {
   return SymGetSymbolInfo64(hProcess, Address, TypeIn, DataIn, TypeOut, SizeOut, DataOut);
}


//#ifdef _WIN64
#if 0
BOOL  __cdecl  PDBOpenTpi(PDB* ppdb, const char* szMode,  TPI** pptpi) {return FALSE;}
BOOL  __cdecl  PDBCopyTo(PDB* ppdb, const char* szTargetPdb, DWORD dwCopyFilter, DWORD dwReserved){return FALSE;}
BOOL  __cdecl  PDBClose(PDB* ppdb) {return FALSE;}
BOOL  __cdecl  ModQueryImod(Mod* pmod,  USHORT* pimod) {return FALSE;}
BOOL  __cdecl  ModQueryLines(Mod* pmod, BYTE* pbLines, long* pcb) {return FALSE;}
BOOL  __cdecl  DBIQueryModFromAddr(DBI* pdbi, USHORT isect, long off,  Mod** ppmod,  USHORT* pisect,  long* poff,  long* pcb){return FALSE;}
BOOL  __cdecl  ModClose(Mod* pmod){return FALSE;}
BOOL  __cdecl  DBIQueryNextMod(DBI* pdbi, Mod* pmod, Mod** ppmodNext) {return FALSE;}
BYTE* __cdecl  GSINextSym (GSI* pgsi, BYTE* pbSym) {return NULL;}
BOOL  __cdecl  PDBOpen(char* szPDB,char* szMode,SIG sigInitial,EC* pec,char szError[cbErrMax],PDB** pppdb) {return FALSE;}
BOOL  __cdecl  TypesClose(TPI* ptpi){return FALSE;}
BOOL  __cdecl  GSIClose(GSI* pgsi){return FALSE;}
BOOL  __cdecl  DBIClose(DBI* pdbi){return FALSE;}
BYTE* __cdecl  GSINearestSym (GSI* pgsi, USHORT isect, long off, long* pdisp){return NULL;}
BOOL  __cdecl  PDBOpenValidate(char* szPDB,char* szPath,char* szMode,SIG sig,AGE age,EC* pec,char szError[cbErrMax],PDB** pppdb){return FALSE;}
BOOL  __cdecl  PDBOpenDBI(PDB* ppdb, const char* szMode, const char* szTarget,  DBI** ppdbi){return FALSE;}
BOOL  __cdecl  DBIOpenPublics(DBI* pdbi,  GSI **ppgsi){return FALSE;}
BOOL  __cdecl  DBIQuerySecMap(DBI* pdbi,  BYTE* pb, long* pcb){return FALSE;}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\stripcv.cxx ===
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <imagehlp.h>
#include <cvinfo.h>
#include <private.h>

extern "C"
BOOL
IMAGEAPI
CopyPdb(
    CHAR const * szSrcPdb,
    CHAR const * szDestPdb,
    BOOL StripPrivate
    );

BOOL
StripCv(
    PSZ szImage
    );

void __cdecl main(int argc, char *argv[]);
void Usage(void);

void
Usage (void)
{
    puts("USAGE: StripCV <imagename>\n"
         "\tRemove non-public CV info from an image.\n");
}

void __cdecl
main(
    int argc,
    char *argv[])
{
    int i;

    if (argc < 2) {
        Usage();
        exit(1);
    }

    for (i = 1; i < argc; i++) {
        StripCv(argv[i]);
    }
}

BOOL
StripCv(
    PSZ szImage
    )
{
    PCHAR               CvDebugData;
    unsigned int        i, NumberOfDebugDirectories;
    ULONG               DebugDirectorySize, NewCvSize = 0, CvDebugSize;
    PCHAR               NewCvData;
    HANDLE              FileHandle, hMappedFile;
    PVOID               DebugDirectories, ImageBase;
    PIMAGE_NT_HEADERS   NtHeaders;
    PIMAGE_DEBUG_DIRECTORY DebugDirectory;
    BOOL                fRemoveCV = FALSE;
    BOOL                fDbgFile = FALSE;
    ULONG              *pDebugSize, FileSize;
    BOOL                RC = TRUE;

    FileHandle = CreateFile(
                     szImage,
                     GENERIC_READ | GENERIC_WRITE,
                     FILE_SHARE_READ,
                     NULL,
                     OPEN_EXISTING,
                     0,
                     NULL );

    if (FileHandle == INVALID_HANDLE_VALUE) {
        printf("Error: Unable to open %s - rc: %d\n", szImage, GetLastError());
        RC = FALSE;
        goto cleanup1;
    }

    FileSize = GetFileSize(FileHandle, NULL);

    hMappedFile = CreateFileMapping( FileHandle, NULL, PAGE_READWRITE, 0, 0, NULL );
    if (!hMappedFile) {
        printf("Error: Unable to create read/write map on %s - rc: %d\n", szImage, GetLastError());
        RC = FALSE;
        goto cleanup2;
    }

    ImageBase = MapViewOfFile( hMappedFile, FILE_MAP_WRITE, 0, 0, 0 );
    if (!ImageBase) {
        printf("Error: Unable to Map view of file %s - rc: %d\n", szImage, GetLastError());
        RC = FALSE;
        goto cleanup3;
    }

    if (*(USHORT *)ImageBase == IMAGE_SEPARATE_DEBUG_SIGNATURE) {

        fDbgFile = TRUE;

        PIMAGE_SEPARATE_DEBUG_HEADER DbgFile = (PIMAGE_SEPARATE_DEBUG_HEADER) ImageBase;

        DebugDirectories = (PIMAGE_DEBUG_DIRECTORY)((PUCHAR)ImageBase +
                                    sizeof(IMAGE_SEPARATE_DEBUG_HEADER) +
                                    (DbgFile->NumberOfSections * sizeof(IMAGE_SECTION_HEADER)) +
                                    DbgFile->ExportedNamesSize );
        pDebugSize = &(DbgFile->DebugDirectorySize);

        DebugDirectorySize = DbgFile->DebugDirectorySize;

    } else {

        NtHeaders = ImageNtHeader( ImageBase );
        if (NtHeaders == NULL) {
            printf("Error: %s is not an NT image\n", szImage);
            RC = FALSE;
            goto cleanup4;
        }

        DebugDirectories =
            ImageDirectoryEntryToData(
                ImageBase,
                FALSE,
                IMAGE_DIRECTORY_ENTRY_DEBUG,
                &DebugDirectorySize );
        pDebugSize = &(NtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size);
    }

    if (DebugDirectories == NULL || DebugDirectorySize == 0)
    {
        printf("Warning: No debug info found on %s\n", szImage);
        RC = FALSE;
        goto cleanup4;
    }

    DebugDirectory = (PIMAGE_DEBUG_DIRECTORY) DebugDirectories;

    NumberOfDebugDirectories = DebugDirectorySize / sizeof( IMAGE_DEBUG_DIRECTORY );

    CvDebugData = NULL;

    for (i=0; i < NumberOfDebugDirectories; i++) {
        if (DebugDirectory->Type == IMAGE_DEBUG_TYPE_CODEVIEW) {
            CvDebugData = (PCHAR)ImageBase + DebugDirectory->PointerToRawData;
            CvDebugSize = DebugDirectory->SizeOfData;
            break;
        }

        // Zero out the Fixup data

        if (DebugDirectory->Type == IMAGE_DEBUG_TYPE_FIXUP) {
            printf("Info: Removing Fixup data from %s\n", szImage);
            RtlZeroMemory(((PUCHAR)ImageBase + DebugDirectory->PointerToRawData),
                          DebugDirectory->SizeOfData);
            DebugDirectory = DebugDirectory+1;
            *pDebugSize -= sizeof(IMAGE_DEBUG_DIRECTORY);
        } else {
            DebugDirectory++;
        }
    }

    if (CvDebugData == NULL) {
        printf("Info: No CV Debug found on %s\n", szImage);
        RC = FALSE;
        goto cleanup5;
    }

    if (RemovePrivateCvSymbolicEx(CvDebugData, CvDebugSize, &NewCvData, &NewCvSize)) {
        // No CV debug in new size.  Let's check for PDB's.  If so, copy the pdb to
        // <filename>pub

        typedef struct NB10I {                 // NB10 debug info
            DWORD   nb10;                      // NB10
            DWORD   off;                       // offset, always 0
            DWORD   sig;
            DWORD   age;
        } NB10I;

        NB10I *NB10Data = (NB10I *)CvDebugData;
        PCHAR  szPrivatePdb;
        CHAR  szPublicPdb[_MAX_PATH];

        if (NB10Data->nb10 == '01BN') {
            // It has a NB10 signature.  Get the name.
            szPrivatePdb = CvDebugData + sizeof(NB10I);
            strcpy(szPublicPdb, szPrivatePdb);
            strcat(szPublicPdb, "pub");
            CopyPdb(szPrivatePdb, szPublicPdb, TRUE);
        } else {
            printf("Info: CV types info stripped from %s\n", szImage);
        }
    }

    RtlCopyMemory(CvDebugData, NewCvData, NewCvSize);

    DebugDirectory = (PIMAGE_DEBUG_DIRECTORY) DebugDirectories;

    for (i=0; i < NumberOfDebugDirectories; i++) {
        if (DebugDirectory->Type == IMAGE_DEBUG_TYPE_CODEVIEW) {
            if (i+1 == NumberOfDebugDirectories) {
                // This is the simple case.  cv is the last entry.  Simply truncate the image.
                FileSize += NewCvSize - DebugDirectory->SizeOfData;
            }
            DebugDirectory->SizeOfData = NewCvSize;
            break;
        }

        DebugDirectory++;
    }

cleanup5:

    // All done.

    if (!fDbgFile) {
        PIMAGE_NT_HEADERS pHdr = NULL;
        DWORD SumHeader;
        DWORD SumTotal;

        pHdr = CheckSumMappedFile(ImageBase, FileSize, &SumHeader, &SumTotal);
        if (pHdr != NULL) {
            pHdr->OptionalHeader.CheckSum = SumTotal;
        }
    }

    FlushViewOfFile(ImageBase, NULL);
cleanup4:
    UnmapViewOfFile(ImageBase);
cleanup3:
    CloseHandle(hMappedFile);
cleanup2:
    SetFilePointer(FileHandle, FileSize, NULL, FILE_BEGIN);
    SetEndOfFile(FileHandle);
    CloseHandle(FileHandle);
cleanup1:
    return(RC);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\symutil.h ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <tchar.h>


#define MAX_SYM_ERR         500

#define IGNORE_IF_SPLIT     130
#define ERROR_IF_SPLIT      131
#define ERROR_IF_NOT_SPLIT  132

typedef struct _EXCLUDE_LIST {
    LPTSTR *szExcList;      // Pointers to the file names
    DWORD dNumFiles;
} EXCLUDE_LIST, *PEXCLUDE_LIST;

PEXCLUDE_LIST
GetExcludeList(
    LPTSTR szFileName
);

BOOL
InExcludeList(
    LPTSTR szFileName,
    PEXCLUDE_LIST pExcludeList
);

BOOL
CheckSymbols (
    LPTSTR ErrMsg,
    LPTSTR szSearchpath,
    LPTSTR szFileName,
    FILE   *hSymCDLog,
    ULONG SymchkFlag,
    BOOL Verbose
);

// Stuff for logging the errors

#define NO_DEBUG_DIRECTORIES                10
#define NO_DEBUG_DIRECTORIES_IN_DBG_HEADER  11
#define NO_MISC_ENTRY                       12
#define NO_FILE_IN_MISC                     13
#define NO_CODE_VIEW                        15
#define CREATE_FILE_FAILED                  16
#define CREATE_FILE_MAPPING_FAILED          17
#define MAPVIEWOFFILE_FAILED                18
#define GET_FILE_INFO_FAILED                19
#define HEADER_NOT_ON_LONG_BOUNDARY         20
#define IMAGE_BIGGER_THAN_FILE              21
#define NO_DOS_HEADER                       22
#define NOT_NT_IMAGE                        23
#define IMAGE_PASSED                        24
#define RESOURCE_ONLY_DLL                   25
#define FILE_NOT_FOUND                      26
#define EXTRA_RAW_DATA_IN_6                 27
#define INVALID_POINTERTORAWDATA_NON_ZERO   28
#define INVALID_ADDRESSOFRAWDATA_ZERO_DEBUG 29
#define INVALID_POINTERTORAWDATA_ZERO_DEBUG 30
#define PRIVATE_INFO_NOT_REMOVED            31
#define PDB_MAY_BE_CORRUPT                  32
#define SIGNED_AND_NON_SPLIT                33

#define MAX_PDB_ERR                         200

typedef struct _SymErr {
    BOOL   Verbose;
    UINT   ErrNo;                         // Error message number
    UINT   ErrNo2;                        // Additional error number
    TCHAR  szFileName[_MAX_FNAME];        // Image file
    TCHAR  szSymbolFileName[_MAX_FNAME];  // Full path and name of DBG file
    TCHAR  szSymbolSearchPath[_MAX_PATH]; // ; delimited symbol search path
    BOOL   SymbolFileFound;               // Was a DBG file found
    BOOL   SizeOfImageMatch;              // Does size of image match between
                                          //   image and the DBG?
    BOOL   CheckSumsMatch;                // Do Checksums match between the
                                          //   image and the DBG
    BOOL   TimeDateStampsMatch;           // Do TimeDateStampsMatch between
                                          //   the image and the DBG
    BOOL   PdbFileFound;                  // Pdb with correct name was located
    BOOL   PdbValid;                      // Pdb opens and validates
    TCHAR  szPdbErr[MAX_PDB_ERR];         // Pdb error message
    TCHAR  szPdbFileName[_MAX_FNAME];     // Full path and name of Pdb file
} SYM_ERR, *PSYM_ERR;

BOOL
LogError(
    LPTSTR ErrMsg,
    PSYM_ERR pSymErr,
    UINT ErrNo
);


BOOL
LogDbgError(
    LPTSTR ErrMsg,
    PSYM_ERR pSymErr
);

BOOL
LogPdbError(
    LPTSTR ErrMsg,
    PSYM_ERR pSymErr
);

int __cdecl
SymComp2(
      const void *e1,
      const void *e2
);

typedef struct _LIST_ELEM {
    CHAR FName[_MAX_PATH];
    CHAR Path[_MAX_PATH];
} LIST_ELEM, *P_LIST_ELEM;

typedef struct _LIST {
    LIST_ELEM *List;      // Pointers to the file names
    DWORD dNumFiles;
} LIST, *P_LIST;

P_LIST
GetList(
    LPTSTR szFileName
);

BOOL
InList(
    LPTSTR szFileName,
    P_LIST pExcludeList
);

// Global variables

extern BOOL CheckPrivate;
extern PEXCLUDE_LIST pErrorFilterList;
extern P_LIST pCDIncludeList;
extern BOOL DbgOnly;
extern BOOL Recurse;
extern BOOL CheckCodeView;
extern BOOL LogCheckSumErrors;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\typesrv.c ===
/*******************************************************************
*
*    Copyright (c) 1999  Microsoft Corporation
*
*    DESCRIPTION:
*       Use PDB information to get type info and decode a symbol address
*
*    AUTHOR: Kshitiz K. Sharma
*
*    DATE:4/19/1999
*
*******************************************************************/


#define PDB_LIBRARY
#include <cvinfo.h>
#include <pdb.h>
#include <private.h>
#include <winnt.h>
#include <windef.h>
#include "symbols.h"

#define MAX_NAME                         2000

/*
 *Function Name: GetSymbolType
 *
 *Description: Returns PDB type index / enumerates the symbol.
 *
 *Returns: BOOL
 *
 */
BOOL
GetSymbolType(
   IN GSI* pgsi,
   IN OUT TCHAR *symName,
   IN BOOL PrefixMatch,
   OUT TI *ptypeIndex,
   OUT PTYPE_ENUM_INFO pEnumInfo
   )
{
   BYTE Sym[512], prevSym[512], *symReturned, sInfo[sizeof(IMAGEHLP_SYMBOL) + MAX_NAME];
   BOOL found=FALSE, hashedStart=TRUE, foundOnce=FALSE;
   WORD i, length, symIndex;
   PDWORD typeIndex;
   DWORD indx=0;
   TCHAR name[MAX_NAME];
   PIMAGEHLP_SYMBOL symInfo;

   symReturned = NULL;
   symInfo = (PIMAGEHLP_SYMBOL) &(sInfo[0]);
   symInfo->SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
   symInfo->MaxNameLength = MAX_NAME;

   if (pgsi!=NULL) {
      // Try exact match using hash first, if failed it will try best match
      symReturned = GSIHashSym(pgsi, symName, NULL);
      if ((symReturned==NULL) || pEnumInfo) { // Enumerate all
         hashedStart = FALSE;
         symReturned = GSINextSym(pgsi, NULL);
      }
   }

   while ((symReturned!=NULL) && (!found || pEnumInfo)) {
      typeIndex = NULL;
      ZeroMemory(name, MAX_NAME);
      symIndex = *((PWORD) (symReturned+=2));
      symReturned+=2;
      switch (symIndex) {
      case S_COMPILE : // 0x0001   Compile flags symbol
      case S_REGISTER_16t : { // 0x0002   Register variable
         break;
      }
      case S_CONSTANT_16t : { // 0x0003   constant symbol
         DWORD len=4, val;

         // GetNumericValue(symReturned+4, &val, &len);
         val = *((PDWORD )(symReturned +4));
         typeIndex = (PDWORD) symReturned;
         strncpy(name, symReturned+5+len, (UCHAR) symReturned[4+len]);
         break;
      }
      case S_UDT_16t : { // 0x0004   User defined type
         typeIndex = ((PDWORD) (symReturned+2));
         strncpy(name, symReturned + 7, (UCHAR) symReturned[6]);
         break;
      }
      case S_SSEARCH : // 0x0005   Start Search
      case S_END : // 0x0006   Block, procedure, "with" or thunk end
      case S_SKIP : // 0x0007   Reserve symbol space in $$Symbols table
      case S_CVRESERVE : // 0x0008   Reserved symbol for CV internal use
      case S_OBJNAME : // 0x0009   path to object file name
      case S_ENDARG : // 0x000a   end of argument/return list
      case S_COBOLUDT_16t : // 0x000b   special UDT for cobol that does not symbol pack
      case S_MANYREG_16t : // 0x000c   multiple register variable
      case S_RETURN : // 0x000d   return description symbol
      case S_ENTRYTHIS : // 0x000e   description of this pointer on entry
      case S_BPREL16 : // 0x0100   BP-relative
      case S_LDATA16 : // 0x0101   Module-local symbol
      case S_GDATA16 : // 0x0102   Global data symbol
      case S_PUB16 : // 0x0103   a public symbol
      case S_LPROC16 : // 0x0104   Local procedure start
      case S_GPROC16 : // 0x0105   Global procedure start
      case S_THUNK16 : // 0x0106   Thunk Start
      case S_BLOCK16 : // 0x0107   block start
      case S_WITH16 : // 0x0108   with start
      case S_LABEL16 : // 0x0109   code label
      case S_CEXMODEL16 : // 0x010a   change execution model
      case S_VFTABLE16 : // 0x010b   address of virtual function table
      case S_REGREL16 : // 0x010c   register relative address
      case S_BPREL32_16t : { // 0x0200   BP-relative
         break;
      }
      case S_LDATA32_16t :// 0x0201   Module-local symbol
      case S_GDATA32_16t :// 0x0202   Global data symbol
      case S_PUB32_16t : { // 0x0203   a public symbol (CV internal reserved)
         DATASYM32_16t *pData;

         pData = (DATASYM32_16t *) (symReturned -4);
         indx = pData->typind; typeIndex = &indx;
         strncpy(name, &pData->name[1], (UCHAR) pData->name[0]);
         break;
      }
      case S_LPROC32_16t : // 0x0204   Local procedure start
      case S_GPROC32_16t : { // 0x0205   Global procedure start
         typeIndex = ((PDWORD) symReturned) + 6;
         strncpy(name, symReturned + 36, (UCHAR) symReturned[35]);
         break;
      }
      case S_THUNK32 : // 0x0206   Thunk Start
      case S_BLOCK32 : // 0x0207   block start
      case S_WITH32 : // 0x0208   with start
      case S_LABEL32 : // 0x0209   code label
      case S_CEXMODEL32 : // 0x020a   change execution model
      case S_VFTABLE32_16t : // 0x020b   address of virtual function table
      case S_REGREL32_16t : // 0x020c   register relative address
      case S_LTHREAD32_16t : // 0x020d   local thread storage
      case S_GTHREAD32_16t : // 0x020e   global thread storage
      case S_SLINK32 : // 0x020f   static link for MIPS EH implementation
      case S_LPROCMIPS_16t : // 0x0300   Local procedure start
      case S_GPROCMIPS_16t : { // 0x0301   Global procedure start
         break;
      }

      case S_PROCREF : { // 0x0400   Reference to a procedure
         // typeIndex = ((PDWORD) symReturned) + 3;
         // strncpy(name, symReturned + 13, (char) *(symReturned+12));
         break;
      }
      case S_DATAREF : // 0x0401   Reference to data
      case S_ALIGN : // 0x0402   Used for page alignment of symbols
      case S_LPROCREF : // 0x0403   Local Reference to a procedure

         // sym records with 32-bit types embedded instead of 16-bit
         // all have  0x1000 bit set for easy identification
         // only do the 32-bit target versions since we don't really
         // care about 16-bit ones anymore.
      case S_TI16_MAX : // 0x1000,
      case S_REGISTER : { // 0x1001   Register variable
         break;
      }

      case S_CONSTANT : { // 0x1002   constant symbol
         DWORD len=4, val;

         // GetNumericValue(symReturned+4, &val, &len);
         val = *((PDWORD )(symReturned +4));
         typeIndex = (PDWORD) symReturned;
         strncpy(name, symReturned+5+len, (UCHAR) symReturned[4+len]);
         break;
      }
      case S_UDT : { // 0x1003   User defined type
         typeIndex = (PDWORD) symReturned;
         strncpy(name, symReturned+5, (UCHAR) symReturned[4]);
         break;
      }

      case S_COBOLUDT : // 0x1004   special UDT for cobol that does not symbol pack
      case S_MANYREG : // 0x1005   multiple register variable
      case S_BPREL32 : { // 0x1006   BP-relative
         break;
      }

      case S_LDATA32 : // 0x1007   Module-local symbol
      case S_GDATA32 : // 0x1008   Global data symbol
      case S_PUB32 : { // 0x1009   a public symbol (CV internal reserved)
         typeIndex = (PDWORD) symReturned;
         strncpy(name, symReturned+11, (UCHAR) symReturned[10]);

         break;
      }
      case S_LPROC32 :  // 0x100a   Local procedure start
      case S_GPROC32 : { // 0x100b   Global procedure start
         typeIndex = (PDWORD) (symReturned+24);
         strncpy(name, symReturned+32, (UCHAR) symReturned[31]);
         break;
      }

      case S_VFTABLE32 : // 0x100c   address of virtual function table
      case S_REGREL32 : // 0x100d   register relative address
      case S_LTHREAD32 : // 0x100e   local thread storage
      case S_GTHREAD32 : // 0x100f   global thread storage
      case S_LPROCMIPS : // 0x1010   Local procedure start
      case S_GPROCMIPS : // 0x1011   Global procedure start
      case S_FRAMEPROC : // 0x1012   extra frame and proc information
      case S_COMPILE2 : // 0x1013   extended compile flags and info
      case S_MANYREG2 : // 0x1014   multiple register variable
      case S_LPROCIA64 : // 0x1015   Local procedure start (IA64)
      case S_GPROCIA64 : // 0x1016   Global procedure start (IA64)
      case S_RECTYPE_MAX :
      default:
         break;

      } /* switch */

      if (*((ULONG *) &name[0]) != 0x435f3f3f) {   // Not intrested in names like "??_C"*
         if (symName[0] != '_') {
            // We can undecorate name and check if it matches
            TCHAR tmpName[MAX_NAME];

            strcpy(tmpName, name);
            SymUnDNameInternal( name, strlen(name), tmpName, MAX_NAME);
         }

         if (hashedStart || !PrefixMatch) {
            found = !(strcmp(name, symName));
         } else {
            found = !(strncmp(name, symName, strlen(symName)));
         }
         if (found) {
            foundOnce = TRUE;
            if (typeIndex && ptypeIndex) {
               *ptypeIndex = *typeIndex;
            }
            if (pEnumInfo) { // Do a callback
               if (! (*((PSYMBOL_TYPE_NAME_CALLBACK) pEnumInfo->CallbackRoutine)) (
                        &name[0],
                        (typeIndex != NULL) ? *typeIndex : 0,
                        pEnumInfo->CallerData))
                  return TRUE;
            }
            if (!PrefixMatch) {
               return TRUE;
            }
         }

      }

      symReturned = GSINextSym(pgsi, symReturned-4);

      if (hashedStart && (symReturned==NULL)) {
         // Did not fint exact match  - try incomplete match
         hashedStart = FALSE;
         symReturned = GSINextSym(pgsi, NULL);
      }

   } /* while */
   return(foundOnce);
} /* End function GetSymbolType */

/*
  Function Name: GetPdbTypeInfo
 
  Parameters:
             pgsi, pDbi - Pointer to Global and Debug symbol Info
             symName - name of symbol,
             PrefixMatch - if given should matched exact or not,
             ReturnType - Describes if symbols should be enumerated
 
  Description: Gets the type index of given symbol and enumerates all matching
 * symbols depending on ReturnType
 
  Returns: TRUE on success
 
 */
BOOL
GetPdbTypeInfo(
   DBI *pDbi,
   GSI *pGsi,
   LPSTR symName,
   BOOL PrefixMatch,
   IMAGEHLP_TYPES ReturnType,
   PBYTE pRetVal
   )
{
   TPI *typeInfo=NULL;
   GSI *Publics, *Globals;
   DBI *pDBI;
   BOOL openedDBI=FALSE, openedGSI=FALSE, openedPGSI=FALSE;
   CV_typ_t typ, *typeIndex;
   PTYPE_ENUM_INFO pEnumInfo;

   Publics = pGsi; Globals=NULL; pDBI=NULL;
   if ((pDbi == NULL) || (pGsi == NULL) || (pRetVal == NULL)) {
      return FALSE;
   }

   if (ReturnType == IMAGEHLP_TYPEID_INDEX) {
      typeIndex = (CV_typ_t *) pRetVal;
      pEnumInfo = NULL;
   } else if (ReturnType == IMAGEHLP_TYPEID_TYPE_ENUM_INFO) {
      typeIndex = &typ;
      pEnumInfo = (PTYPE_ENUM_INFO) pRetVal;
   } else {
      return FALSE;
   }

   return (GetSymbolType(pGsi, symName, PrefixMatch, typeIndex, pEnumInfo)) ;

} /* End function GetPdbTypeInfo */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\symbols.h ===
//
// defines for symbol file searching
//
#define SYMBOL_PATH             "_NT_SYMBOL_PATH"
#define ALTERNATE_SYMBOL_PATH   "_NT_ALT_SYMBOL_PATH"
#define WINDIR                  "windir"
#define HASH_MODULO             253
#define OMAP_SYM_EXTRA          1024
#define CPP_EXTRA               2
#define OMAP_SYM_STRINGS        (OMAP_SYM_EXTRA * 256)
#define TMP_SYM_LEN             4096
#define MAX_SYM_NAME            2000
//
// structures
//
typedef struct _LOADED_MODULE {
    PENUMLOADED_MODULES_CALLBACK      EnumLoadedModulesCallback32;
    PENUMLOADED_MODULES_CALLBACK64      EnumLoadedModulesCallback64;
    PVOID                               Context;
} LOADED_MODULE, *PLOADED_MODULE;

typedef struct _PROCESS_ENTRY {
    LIST_ENTRY                      ListEntry;
    LIST_ENTRY                      ModuleList;
    ULONG                           Count;
    HANDLE                          hProcess;
    DWORD                           pid;
    LPSTR                           SymbolSearchPath;
    PSYMBOL_REGISTERED_CALLBACK     pCallbackFunction32;
    PSYMBOL_REGISTERED_CALLBACK64   pCallbackFunction64;
    ULONG64                         CallbackUserContext;
    PSYMBOL_FUNCENTRY_CALLBACK      pFunctionEntryCallback32;
    PSYMBOL_FUNCENTRY_CALLBACK64    pFunctionEntryCallback64;
    ULONG64                         FunctionEntryUserContext;
} PROCESS_ENTRY, *PPROCESS_ENTRY;

typedef struct _OMAP {
    ULONG  rva;
    ULONG  rvaTo;
} OMAP, *POMAP;

typedef struct _OMAPLIST {
   struct _OMAPLIST *next;
   OMAP             omap;
   ULONG            cb;
} OMAPLIST, *POMAPLIST;

#define SYMF_DUPLICATE    0x80000000
#define SYMF_OMAP_GENERATED   0x00000001
#define SYMF_OMAP_MODIFIED    0x00000002

typedef struct _SYMBOL_ENTRY {
    struct _SYMBOL_ENTRY        *Next;
    DWORD                       Size;
    DWORD                       Flags;
    DWORD64                     Address;
    LPSTR                       Name;
    ULONG                       NameLength;
} SYMBOL_ENTRY, *PSYMBOL_ENTRY;

typedef struct _SECTION_START {
    ULONG64                     Offset;
    DWORD                       Size;
    DWORD                       Flags;
} SECTION_START, *PSECTION_START;

//
// source file and line number information
//
typedef struct _SOURCE_LINE {
    DWORD64             Addr;
    DWORD               Line;
} SOURCE_LINE, *PSOURCE_LINE;

typedef struct _SOURCE_ENTRY {
    struct _SOURCE_ENTRY       *Next;
    DWORD64                     MinAddr;
    DWORD64                     MaxAddr;
    LPSTR                       File;
    DWORD                       Lines;
    PSOURCE_LINE                LineInfo;
    PVOID                       PdbModule;
} SOURCE_ENTRY, *PSOURCE_ENTRY;

//
// module flags
//
#define MIF_DEFERRED_LOAD   0x00000001
#define MIF_NO_SYMBOLS      0x00000002
#define MIF_ROM_IMAGE       0x00000004

typedef struct _MODULE_ENTRY {
    LIST_ENTRY                      ListEntry;
    ULONG64                         BaseOfDll;
    ULONG                           DllSize;
    ULONG                           TimeDateStamp;
    ULONG                           CheckSum;
    USHORT                          MachineType;
    CHAR                            ModuleName[32];
    CHAR                            AliasName[32];
    PSTR                            ImageName;
    PSTR                            LoadedImageName;
    PSYMBOL_ENTRY                   symbolTable;
    LPSTR                           SymStrings;
    PSYMBOL_ENTRY                   NameHashTable[HASH_MODULO];
    ULONG                           numsyms;
    ULONG                           MaxSyms;
    ULONG                           StringSize;
    SYM_TYPE                        SymType;
    PVOID                           pdb;
    PVOID                           dbi;
    PVOID                           gsi;
    PVOID                           globals;
    PVOID                           ptpi;
    PIMAGE_SECTION_HEADER           SectionHdrs;
    ULONG                           NumSections;
    PFPO_DATA                       pFpoData;       // pointer to fpo data (x86)
    PVOID                           pExceptionData; // pointer to pdata (risc)
    ULONG                           dwEntries;      // # of fpo or pdata recs
    POMAP                           pOmapFrom;      // pointer to omap data
    ULONG                           cOmapFrom;      // count of omap entries
    POMAP                           pOmapTo;        // pointer to omap data
    ULONG                           cOmapTo;        // count of omap entries
    SYMBOL_ENTRY                    TmpSym;         // used only for pdb symbols
    ULONG                           Flags;
    HANDLE                          hFile;
    PIMAGE_SECTION_HEADER           OriginalSectionHdrs;
    ULONG                           OriginalNumSections;
    PSOURCE_ENTRY                   SourceFiles;
    
    HANDLE                          hProcess;
    ULONG64                         InProcImageBase;
    BOOL                            fInProcHeader;
    DWORD                           dsExceptions;
} MODULE_ENTRY, *PMODULE_ENTRY;

typedef struct _PDB_INFO {
    CHAR    Signature[4];   // "NBxx"
    ULONG   Offset;         // always zero
    ULONG   sig;
    ULONG   age;
    CHAR    PdbName[_MAX_PATH];
} PDB_INFO, *PPDB_INFO;

#define n_name          N.ShortName
#define n_zeroes        N.Name.Short
#define n_nptr          N.LongName[1]
#define n_offset        N.Name.Long

// Forces symbols to be present for the given module, if possible.
// Returns BOOL.
#define ENSURE_SYMBOLS(hProcess, mi) \
    (((mi)->Flags & MIF_DEFERRED_LOAD) && !((mi)->Flags & MIF_NO_SYMBOLS) ? \
     CompleteDeferredSymbolLoad(hProcess, mi) : \
     TRUE)


//
// global externs
//
extern LIST_ENTRY      ProcessList;
extern BOOL            SymInitialized;
extern DWORD           SymOptions;


//
// internal prototypes
//
DWORD_PTR
GetPID(
    HANDLE hProcess
    );

DWORD
GetProcessModules(
    HANDLE                  hProcess,
    PINTERNAL_GET_MODULE    InternalGetModule,
    PVOID                   Context
    );

BOOL
InternalGetModule(
    HANDLE  hProcess,
    LPSTR   ModuleName,
    DWORD64 ImageBase,
    DWORD   ImageSize,
    PVOID   Context
    );

VOID
FreeModuleEntry(
    PMODULE_ENTRY ModuleEntry
    );

PPROCESS_ENTRY
FindProcessEntry(
    HANDLE  hProcess
    );

PPROCESS_ENTRY
FindFirstProcessEntry(
    );

VOID
GetSymName(
    PIMAGE_SYMBOL Symbol,
    PUCHAR        StringTable,
    LPSTR         s,
    DWORD         size
    );

BOOL
ProcessOmapSymbol(
    PMODULE_ENTRY   mi,
    PSYMBOL_ENTRY   sym
    );

DWORD64
ConvertOmapFromSrc(
    PMODULE_ENTRY  mi,
    DWORD64        addr,
    LPDWORD        bias
    );

DWORD64
ConvertOmapToSrc(
    PMODULE_ENTRY  mi,
    DWORD64        addr,
    LPDWORD        bias,
    BOOL           fBackup
    );

POMAP
GetOmapFromSrcEntry(
    PMODULE_ENTRY  mi,
    DWORD64        addr
    );

VOID
ProcessOmapForModule(
    PMODULE_ENTRY      mi,
    PIMGHLP_DEBUG_DATA pIDD
    );

BOOL
LoadCoffSymbols(
    HANDLE             hProcess,
    PMODULE_ENTRY      mi,
    PIMGHLP_DEBUG_DATA pIDD
    );

BOOL
LoadCodeViewSymbols(
    HANDLE             hProcess,
    PMODULE_ENTRY      mi,
    PIMGHLP_DEBUG_DATA pIDD
    );

ULONG
LoadExportSymbols(
    PMODULE_ENTRY      mi,
    PIMGHLP_DEBUG_DATA pIDD
    );

PMODULE_ENTRY
GetModuleForPC(
    PPROCESS_ENTRY  ProcessEntry,
    DWORD64         dwPcAddr,
    BOOL            ExactMatch
    );

PSYMBOL_ENTRY
GetSymFromAddr(
    DWORD64         dwAddr,
    PDWORD64        pqwDisplacement,
    PMODULE_ENTRY   mi
    );

LPSTR
StringDup(
    LPSTR str
    );

DWORD64
InternalLoadModule(
    IN  HANDLE          hProcess,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD64         BaseOfDll,
    IN  DWORD           SizeOfDll,
    IN  HANDLE          hFile
    );

DWORD
ComputeHash(
    LPSTR   lpname,
    ULONG   cb
    );

PSYMBOL_ENTRY
FindSymbolByName(
    PPROCESS_ENTRY  ProcessEntry,
    PMODULE_ENTRY   mi,
    LPSTR           SymName
    );

PFPO_DATA
SwSearchFpoData(
    DWORD     key,
    PFPO_DATA base,
    DWORD     num
    );

PIMAGE_FUNCTION_ENTRY
LookupFunctionEntryAxp32 (
    PMODULE_ENTRY mi,
    DWORD         ControlPc
    );

PIMAGE_FUNCTION_ENTRY64
LookupFunctionEntryAxp64 (
    PMODULE_ENTRY mi,
    DWORD64       ControlPc
    );

PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY
GetAlphaFunctionEntryFromDebugInfo (
    PPROCESS_ENTRY  ProcessEntry,
    DWORD64         ControlPc
    );

PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY
LookupFunctionEntryIA64 (
    PMODULE_ENTRY mi,
    DWORD         ControlPc
    );

BOOL
LoadedModuleEnumerator(
    HANDLE         hProcess,
    LPSTR          ModuleName,
    DWORD64        ImageBase,
    DWORD          ImageSize,
    PLOADED_MODULE lm
    );

BOOL
CompleteDeferredSymbolLoad(
    IN  HANDLE          hProcess,
    IN  PMODULE_ENTRY   mi
    );

LPSTR
symfmt(
    LPSTR DstName,
    LPSTR SrcName,
    ULONG Length
    );

PIMAGEHLP_SYMBOL
symcpy32(
    PIMAGEHLP_SYMBOL  External,
    PSYMBOL_ENTRY       Internal
    );

PIMAGEHLP_SYMBOL64
symcpy64(
    PIMAGEHLP_SYMBOL64  External,
    PSYMBOL_ENTRY       Internal
    );

BOOL
SympConvertSymbol32To64(
    PIMAGEHLP_SYMBOL Symbol32,
    PIMAGEHLP_SYMBOL64 Symbol64
    );

BOOL
SympConvertSymbol64To32(
    PIMAGEHLP_SYMBOL64 Symbol64,
    PIMAGEHLP_SYMBOL Symbol32
    );

BOOL
SympConvertLine32To64(
    PIMAGEHLP_LINE Line32,
    PIMAGEHLP_LINE64 Line64
    );

BOOL
SympConvertLine64To32(
    PIMAGEHLP_LINE64 Line64,
    PIMAGEHLP_LINE Line32
    );

BOOL
SympConvertAnsiModule32ToUnicodeModule32(
    PIMAGEHLP_MODULE  A_Symbol32,
    PIMAGEHLP_MODULEW W_Symbol32
    );

BOOL
SympConvertUnicodeModule32ToAnsiModule32(
    PIMAGEHLP_MODULEW W_Symbol32,
    PIMAGEHLP_MODULE  A_Symbol32
    );

BOOL
SympConvertAnsiModule64ToUnicodeModule64(
    PIMAGEHLP_MODULE64  A_Symbol64,
    PIMAGEHLP_MODULEW64 W_Symbol64
    );

BOOL
SympConvertUnicodeModule64ToAnsiModule64(
    PIMAGEHLP_MODULEW64 W_Symbol64,
    PIMAGEHLP_MODULE64  A_Symbol64
    );

PMODULE_ENTRY
FindModule(
    HANDLE hModule,
    PPROCESS_ENTRY ProcessEntry,
    LPSTR ModuleName,
    BOOL LoadSymbols
    );

LPSTR
SymUnDNameInternal(
    LPSTR UnDecName,
    DWORD UnDecNameLength,
    LPSTR DecName,
    DWORD MaxDecNameLength
    );

BOOL
GetLineFromAddr(
    PMODULE_ENTRY mi,
    DWORD64 Addr,
    PDWORD Displacement,
    PIMAGEHLP_LINE64 Line
    );

BOOL
FindLineByName(
    PMODULE_ENTRY mi,
    LPSTR FileName,
    DWORD LineNumber,
    PLONG Displacement,
    PIMAGEHLP_LINE64 Line
    );

BOOL
AddLinesForCoff(
    PMODULE_ENTRY mi,
    PIMAGE_SYMBOL allSymbols,
    DWORD numberOfSymbols,
    PIMAGE_LINENUMBER LineNumbers
    );

BOOL
AddLinesForOmfSourceModule(
    PMODULE_ENTRY mi,
    BYTE *Base,
    OMFSourceModule *OmfSrcMod,
    PVOID PdbModule
    );

DWORD
ReadInProcMemory(
    HANDLE    hProcess,
    DWORD64   addr,
    PVOID     buf,
    DWORD     bytes,
    DWORD    *bytesread
    );

BOOL
GetPData(
    HANDLE        hp,
    PMODULE_ENTRY mi
    );

VOID
SympSendDebugString(
    PPROCESS_ENTRY ProcessEntry,
    LPSTR          String
    );

int
WINAPIV
SympDprintf(
    PPROCESS_ENTRY ProcessEntry,
    LPSTR          Format,
    ...
    );

int
WINAPIV
SympEprintf(
    PPROCESS_ENTRY ProcessEntry,
    LPSTR Format,
    ...
    );

BOOL 
GetPdbTypeInfo(
   DBI *pDbi, 
   GSI *pGsi, 
   LPSTR symName, 
   BOOL PrefixMatch,
   IMAGEHLP_TYPES ReturnType,
   PBYTE pRetVal
   );

#define DPRINTF ((SymOptions & SYMOPT_DEBUG) == SYMOPT_DEBUG)&&SympDprintf
#define EPRINTF ((SymOptions & SYMOPT_DEBUG) == SYMOPT_DEBUG)&&SympEprintf
#define CPRINTF SympDprintf
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\undecsym.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    undecsym.cxx

Abstract:

    This is the engine for the C++ name undecorator.


    Syntax for Decorated Names


    cv-decorated-name ::=
            '?' '@' <decorated-name>

    decorated-name ::=
            '?' <symbol-name> [ <scope> ] '@' <type-encoding>


    symbol-name ::=
            <zname>
            <operator-name>


    zname ::=
            <letter> [ { <letter> | <number> } ] '@'
            <zname-replicator>

    letter ::=
            { 'A'..'Z' | 'a'..'z' | '_' | '$' }

    number ::=
            { '0'..'9' }

    zname-replicator ::=
            '0'..'9'                   Corresponding to the first through
                                       tenth 'zname' to have appeared

    The 'zname-replicator' is a compression facility for decorated names.
    Anywhere a 'zname' is expected, a single digit replicator may be used.
    The digits are '0' through '9' and correspond to the first through tenth unique
    'zname's which occur in the decorated name prior to the use of the replicator.

    operator-name ::=
            '?' <operator-code>


    scope ::=
            <zname> [ <scope> ]
            '?' <decorated-name> [ < scope > ]
            '?' <lexical-frame> [ <scope> ]
            '?' '$' <template-name> [ <scope> ]

    The 'scope' is ordered sequentially as a function of lexical scope, with successive enclosing
    scopes appearing to the right of the enclosed scopes.  Thus, the innermost scope is always placed
    first, followed by each successive enclosing scope.

    operator-code ::=
            '0'                Constructor
            '1'                Destructor
            '2'                'new'
            '3'                'delete'
            '4'                '='   Assignment
            '5'                '>>'  Right shift
            '6'                '<<'  Left shift
            '7'                '!'   Boolean NOT
            '8'                '=='  Equality
            '9'                '!='  Inequality
            'A'                '[]'  Indexing
            'B'                User Defined Conversion
            'C'                '->'  Member selection indirect
            'D'                '*'   Dereference or multiply
            'E'                '++'  Pre/Post-increment
            'F'                '--'  Pre/Post-decrement
            'G'                '-'   Two's complement negate, or subtract
            'H'                '+'   Unary plus, or add
            'I'                '&'   Address of, or bitwise AND
            'J'                '->*' Pointer to member selection
            'K'                '/'   Divide
            'L'                '%'   Modulo
            'M'                '<'   Less than
            'N'                '<='  Less than or equal to
            'O'                '>'   Greater than
            'P'                '>='  Greater than or equal to
            'Q'                ','   Sequence
            'R'                '()'  Function call
            'S'                '~'   Bitwise NOT
            'T'                '^'   Bitwise XOR
            'U'                '|'   Bitwise OR
            'V'                '&&'  Boolean AND
            'W'                '||'  Boolean OR
            'X'                '*='  Multiply and assign
            'Y'                '+='  Add and assign
            'Z'                '-='  Subtract and assign
            '_0'               '/='  Divide and assign
            '_1'               '%='  Modulo and assign
            '_2'               '>>=' Right shift and assign
            '_3'               '<<=' Left shift and assign
            '_4'               '&='  Bitwise AND and assign
            '_5'               '|='  Bitwise OR and assign
            '_6'               '^='  Bitwise XOR and assign
            '_7'               VTable
            '_8'               VBase
            '_9'               VCall Thunk
            '_A'               Metaclass
            '_B'               Guard variable for local statics
            '_C'               Ultimate Constructor for Vbases
            '_D'               Ultimate Destructor for Vbases
            '_E'               Vector Deleting Destructor
            '_F'               Default Constructor Closure
            '_G'               Scalar Deleting Destructor
            '_H'               Vector Constructor Iterator
            '_I'               Vector Destructor Iterator
            '_J'               Vector Allocating Constructor


    type-encoding ::=

    Member Functions

            'A'  <member-function-type>                 private near
            'B'  <member-function-type>                 private far
            'C'  <static-member-function-type>          private near
            'D'  <static-member-function-type>          private far
            'G'  <adjustor-thunk-type>                  private near
            'H'  <adjustor-thunk-type>                  private far
            'I'  <member-function-type>                 protected near
            'J'  <member-function-type>                 protected far
            'K'  <static-member-function-type>          protected near
            'L'  <static-member-function-type>          protected far
            'O'  <adjustor-thunk-type>                  protected near
            'P'  <adjustor-thunk-type>                  protected far
            'Q'  <member-function-type>                 public near
            'R'  <member-function-type>                 public far
            'S'  <static-member-function-type>          public near
            'T'  <static-member-function-type>          public far
            'W'  <adjustor-thunk-type>                  public near
            'X'  <adjustor-thunk-type>                  public far
            '$0' <virtual-adjustor-thunk-type>          private near
            '$1' <virtual-adjustor-thunk-type>          private far
            '$2' <virtual-adjustor-thunk-type>          protected near
            '$3' <virtual-adjustor-thunk-type>          protected far
            '$4' <virtual-adjustor-thunk-type>          public near
            '$5' <virtual-adjustor-thunk-type>          public far

    Virtual Member Functions

            'E'  <member-function-type>                 private near
            'F'  <member-function-type>                 private far
            'M'  <member-function-type>                 protected near
            'N'  <member-function-type>                 protected far
            'U'  <member-function-type>                 public near
            'V'  <member-function-type>                 public far

    Non-Member Functions

            'Y'  <external-function-type>               near
            'Z'  <external-function-type>               far
            '$A' <local-static-data-destructor-type>
            '$B' <vcall-thunk-type>

    Non-Functions

            '0'  <static-member-data-type>              private
            '1'  <static-member-data-type>              protected
            '2'  <static-member-data-type>              public
            '3'  <external-data-type>
            '4'  <local-static-data-type>
            '5'  <local-static-data-guard-type>
            '6'  <vtable-type>
            '7'  <vbase-type>
            '8'  <metaclass-type>


    Based variants of the above

    Member Functions

            '_A' <based-member-function-type>            private near
            '_B' <based-member-function-type>            private far
            '_C' <based-static-member-function-type>     private near
            '_D' <based-static-member-function-type>     private far
            '_G' <based-adjustor-thunk-type>             private near
            '_H' <based-adjustor-thunk-type>             private far
            '_I' <based-member-function-type>            protected near
            '_J' <based-member-function-type>            protected far
            '_K' <based-static-member-function-type>     protected near
            '_L' <based-static-member-function-type>     protected far
            '_O' <based-adjustor-thunk-type>             protected near
            '_P' <based-adjustor-thunk-type>             protected far
            '_Q' <based-member-function-type>            public near
            '_R' <based-member-function-type>            public far
            '_S' <based-static-member-function-type>     public near
            '_T' <based-static-member-function-type>     public far
            '_W' <based-adjustor-thunk-type>             public near
            '_X' <based-adjustor-thunk-type>             public far
            '_$0' <based-virtual-adjustor-thunk-type>    private near
            '_$1' <based-virtual-adjustor-thunk-type>    private far
            '_$2' <based-virtual-adjustor-thunk-type>    protected near
            '_$3' <based-virtual-adjustor-thunk-type>    protected far
            '_$4' <based-virtual-adjustor-thunk-type>    public near
            '_$5' <based-virtual-adjustor-thunk-type>    public far

    Virtual Member Functions

            '_E' <based-member-function-type>           private near
            '_F' <based-member-function-type>           private far
            '_M' <based-member-function-type>           protected near
            '_N' <based-member-function-type>           protected far
            '_U' <based-member-function-type>           public near
            '_V' <based-member-function-type>           public far

    Non-Member Functions

            '_Y'  <based-external-function-type>        near
            '_Z'  <based-external-function-type>        far
            '_$B' <based-vcall-thunk-type>


    external-function-type ::=
            <function-type>

    based-external-function-type ::=
            <based-type><external-function-type>

    external-data-type ::=
            <data-type><storage-convention>

    member-function-type ::=
            <this-type><static-member-function-type>

    based-member-function-type ::=
            <based-type><member-function-type>

    static-member-function-type ::=
            <function-type>

    based-static-member-function-type ::=
            <based-type><static-member-function-type>

    static-member-data-type ::=
            <external-data-type>

    local-static-data-type ::=
            <lexical-frame><external-data-type>

    local-static-data-guard-type ::=
            <guard-number>

    local-static-data-destructor-type ::=
            <calling-convention><local-static-data-type>

    vtable-type ::=
            <storage-convention> [ <vpath-name> ] '@'

    vbase-type ::=
            <storage-convention> [ <vpath-name> ] '@'

    metaclass-type ::=
            <storage-convention>

    adjustor-thunk-type ::=
            <displacement><member-function-type>

    based-adjustor-thunk-type ::=
            <based-type><adjustor-thunk-type>

    virtual-adjustor-thunk-type ::=
            <displacement><adjustor-thunk-type>

    based-virtual-adjustor-thunk-type ::=
            <based-type><virtual-adjustor-thunk-type>

    vcall-thunk-type ::=
            <call-index><vcall-model-type>

    based-vcall-thunk-type ::=
            <based-type><vcall-thunk-type>


    function-type ::=
            <calling-convention><return-type><argument-types>
                                                            <throw-types>


    segment-name ::=
            <zname>

    ecsu-name ::=
            <zname> [ <scope> ] '@'
            '?' <template-name> [ <scope> ] '@'


    return-type ::=
            '@'                        No type, for Ctor's and Dtor's
            <data-type>

    data-type ::=
            <primary-data-type>
            'X'                        'void'
            '?' <ecsu-data-indirect-type><ecsu-data-type>


    storage-convention ::=
            <data-indirect-type>

    this-type ::=
            <data-indirect-type>


    lexical-frame ::=
            <dimension>

    displacement ::=
            <dimension>

    call-index ::=
            <dimension>

    guard-number ::=
            <dimension>


    vcall-model-type ::=
            'A'                        near this, near call,  near vfptr
            'B'                        near this,  far call,  near vfptr
            'C'                         far this, near call,  near vfptr
            'D'                         far this,  far call,  near vfptr
            'E'                        near this, near call,   far vfptr
            'F'                        near this,  far call,   far vfptr
            'G'                         far this, near call,   far vfptr
            'H'                         far this,  far call,   far vfptr
            'I' <based-type>           near this, near call, based vfptr
            'JK' <based-type>          near this,  far call, based vfptr
            'KJ' <based-type>           far this, near call, based vfptr
            'L' <based-type>            far this,  far call, based vfptr


    throw-types ::=
            <argument-types>


    template-name ::=
            <zname><argument-list>

    calling-convention ::=
            'A'                        cdecl
            'B'                        cdecl saveregs
            'C'                        pascal/fortran/oldcall
            'D'                        pascal/fortran/oldcall saveregs
            'E'                        syscall
            'F'                        syscall saveregs
            'G'                        stdcall
            'H'                        stdcall saveregs
            'I'                        fastcall
            'J'                        fastcall saveregs
            'K'                        interrupt


    argument-types ::=
            'Z'                        (...)
            'X'                        (void)
            <argument-list> 'Z'        (arglist,...)
            <argument-list> '@'        (arglist)

    argument-list ::=
            <argument-replicator> [ <argument-list> ]
            <primary-data-type> [ <argument-list> ]

    argument-replicator ::=
            '0'..'9'           Corresponding to the first through tenth
                               argument of more than one character type
                               encoding.

    The 'argument-replicator' like the 'zname-replicator' is used to improve the compression of
    information present in decorated names.  In this case however, the 'replicator' allows a single
    digit to be used where an argument type is expected, and to refer to the first through tenth unique
    'argument-type' seen prior to this one.  This replicator refers to ANY argument type seen before,
    even if it was introduced in the recursively generated name for an argument which itself was a
    pointer or reference to a function.  An 'argument-replicator' is used only when the argument encoding
    exceeds one character, otherwise it would represent no actual compression.

    primary-data-type ::=
            'A' <reference-type>       Reference to
            'B' <reference-type>       Volatile reference to
            <basic-data-type>                  Other types


    reference-type ::=
            <data-indirect-type><reference-data-type>
            <function-indirect-type><function-type>


    pointer-type ::=
            <data-indirect-type><pointer-data-type>
            <function-indirect-type><function-type>


    vpath-name ::=
            <scope> '@' [ <vpath-name> ]


    ecsu-data-indirect-type ::=
            'A'                                near
            'B'                                near const
            'C'                                near volatile
            'D'                                near const volatile
            'E'                                far
            'F'                                far const
            'G'                                far volatile
            'H'                                far const volatile
            'I'                                huge
            'J'                                huge const
            'K'                                huge volatile
            'L'                                huge const volatile
            'M' <based-type>                   based
            'N' <based-type>                   based const
            'O' <based-type>                   based volatile
            'P' <based-type>                   based const volatile

    data-indirect-type ::=
            <ecsu-data-indirect-type>
            'Q' <scope> '@'            member near
            'R' <scope> '@'            member near const
            'S' <scope> '@'            member near volatile
            'T' <scope> '@'            member near const volatile
            'U' <scope> '@'            member far
            'V' <scope> '@'            member far const
            'W' <scope> '@'            member far volatile
            'X' <scope> '@'            member far const volatile
            'Y' <scope> '@'            member huge
            'Z' <scope> '@'            member huge const
            '0' <scope> '@'            member huge volatile
            '1' <scope> '@'            member huge const volatile
            '2' <scope> '@' <based-type>       member based
            '3' <scope> '@' <based-type>       member based const
            '4' <scope> '@' <based-type>       member based volatile
            '5' <scope> '@' <based-type>       member based const volatile


    function-indirect-type ::=
            '6'                                                        near
            '7'                                                        far
            '8'  <scope> '@' <this-type>                               member near
            '9'  <scope> '@' <this-type>                               member far
            '_A' <based-type>                                          based near
            '_B' <based-type>                                          based far
            '_C' <scope> '@' <this-type><based-type>                   based member
                                                                       near
            '_D' <scope> '@' <this-type><based-type>                   based member
                                                                       far


    based-type ::=
            '0'                        based on void
            '1'                        based on self
            '2'                        based on near pointer
            '3'                        based on far pointer
            '4'                        based on huge pointer
            '5' <based-type>           based on based pointer (reserved)
            '6'                        based on segment variable
            '7' <segment-name>         based on named segment
            '8'                        based on segment address of var
            '9'                        reserved


    basic-data-type ::=
            'C'                        signed char
            'D'                        char
            'E'                        unsigned char
            'F'                        (signed) short
            'G'                        unsigned short
            'H'                        (signed) int
            'I'                        unsigned int
            'J'                        (signed) long
            'K'                        unsigned long
            'L'                        __segment
            'M'                        float
            'N'                        double
            'O'                        long double
            'P' <pointer-type>         pointer to
            'Q' <pointer-type>         const pointer to
            'R' <pointer-type>         volatile pointer to
            'S' <pointer-type>         const volatile pointer to
            <ecsu-data-type>
            '_A'                       (signed) __int64
            '_B'                       unsigned __int64


    ecsu-data-type ::=
            'T' <ecsu-name>    union
            'U' <ecsu-name>    struct
            'V' <ecsu-name>    class
            'W' <enum-name>    enum


    pointer-data-type ::=
            'X'                        void
            <reference-data-type>

    reference-data-type ::=
            'Y' <array-type>           array of
            <basic-data-type>


    enum-name ::=
            <enum-type><ecsu-name>

    enum-type ::=
            '0'                        signed char enum
            '1'                        unsigned char enum
            '2'                        signed short enum
            '3'                        unsigned short enum
            '4'                        signed int enum
            '5'                        unsigned int enum
            '6'                        signed long enum
            '7'                        unsigned long enum


    array-type ::=
            <number-of-dimensions> { <dimension> } <basic-data-type>

    number-of-dimensions ::=
            <dimension>

    dimension ::=
            '0'..'9'                   Corresponding to 1 to 10 dimensions
            <adjusted-hex-digit> [ { <adjusted-hex-digit> } ] '@'

    adjusted-hex-digit ::=
            'A'..'P'                   Corresponding to values 0x0 to 0xF


Author:

    Wesley Witt (wesw) 09-June-1993   ( this code came from languages, i just ported it )

Revision History:

--*/

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

extern "C" {
#define _IMAGEHLP_SOURCE_
#include <imagehlp.h>
#include "private.h"
LONGLONG UndecTime;
}

HMODULE hMsvcrt;
PUNDNAME pfUnDname;
BOOL fLoadMsvcrtDLL;

void * __cdecl AllocIt(unsigned int cb)
{
    return (MemAlloc(cb));
}

void __cdecl FreeIt(void * p)
{
    MemFree(p);
}

DWORD
IMAGEAPI
WINAPI
UnDecorateSymbolName(
    LPCSTR name,
    LPSTR outputString,
    DWORD maxStringLength,
    DWORD flags
    )
{
    DWORD rc;

    //
    // can't undecorate into a zero length buffer
    //
    if (maxStringLength < 2) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    if (!fLoadMsvcrtDLL) {
        // The first time we run, see if we can find the system undname.  Use
        // GetModuleHandle to avoid any additionally overhead.

        hMsvcrt = GetModuleHandle("msvcrt.dll");

        if (hMsvcrt) {
            pfUnDname = (PUNDNAME) GetProcAddress(hMsvcrt, "__unDName");
        }
        fLoadMsvcrtDLL = TRUE;
    }

    rc = 0;     // Assume failure

    __try {
        if (pfUnDname) {
            if (flags & UNDNAME_NO_ARGUMENTS) {
                flags |= UNDNAME_NAME_ONLY;
                flags &= ~UNDNAME_NO_ARGUMENTS;
            }

            if (flags & UNDNAME_NO_SPECIAL_SYMS) {
                flags &= ~UNDNAME_NO_SPECIAL_SYMS;
            }
            if (pfUnDname(outputString, name, maxStringLength-1, AllocIt, FreeIt, (USHORT)flags)) {
                rc = strlen(outputString);
            }
        } else {
            rc = strlen(strncpy(outputString, "Unable to load msvcrt!__unDName", maxStringLength));
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) { }

    if (!rc) {
        SetLastError(ERROR_INVALID_PARAMETER);
    }
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\symutil.c ===
#include <assert.h>
#include "symutil.h"
#define PDB_LIBRARY
#include "pdb.h"
#include "dbghelp.h"
#include "cvinfo.h"
#include "cvexefmt.h"
#include "exe_vxd.h"
#include "share.h"
#include "winbase.h"


// Stuff for Checking symbols


#define DBGSYM 2
#define PDBSYM 3

BOOL CheckPrivate=FALSE;
BOOL CheckCodeView=TRUE;
PEXCLUDE_LIST pErrorFilterList=NULL;
P_LIST pCDIncludeList=NULL;
BOOL DbgOnly = FALSE;
BOOL Recurse = FALSE;
BOOL LogCheckSumErrors = FALSE;

// Typedefs

typedef struct _NB10I {
    DWORD   dwSig;    // NB10
    DWORD   dwOffset; // offset, always 0
    SIG     sig;
    AGE     age;
    char    szPDB[_MAX_PATH];
}NB10I, *PNB10I;

typedef struct _FILE_INFO {
    DWORD       TimeDateStamp;
    DWORD       SizeOfImage;
    DWORD       CheckSum;
    TCHAR       szName[MAX_PATH];
} FILE_INFO, *PFILE_INFO;


PIMAGE_DOS_HEADER
MapFileHeader (
              LPTSTR szFileName,
              PHANDLE phFile,
              PSYM_ERR pSymErr
              );

PIMAGE_NT_HEADERS
GetNtHeader (
            PIMAGE_DOS_HEADER pDosHeader,
            HANDLE hDosFile,
            LPTSTR szFileName,
            PSYM_ERR pSymErr
            );

BOOL
ResourceOnlyDll(
               PVOID pImageBase,
               BOOLEAN bMappedAsImage
               );

PIMAGE_SEPARATE_DEBUG_HEADER
MapDbgHeader (
             LPTSTR szFileName,
             PHANDLE phFile,
             PSYM_ERR pSymErr
             );

BOOL
UnmapFile(
         LPCVOID phFileMap,
         HANDLE hFile
         );

PIMAGE_DEBUG_DIRECTORY
GetDebugDirectoryInExe(
                      PIMAGE_DOS_HEADER pDosHeader,
                      ULONG *NumberOfDebugDirectories
                      );

PIMAGE_DEBUG_DIRECTORY
GetDebugDirectoryInDbg(
                      PIMAGE_SEPARATE_DEBUG_HEADER pDbgHeader,
                      ULONG *NumberOfDebugDirectories
                      );

PIMAGE_SEPARATE_DEBUG_HEADER
MapMatchingDbgFile(
                  LPTSTR szSearchPath,
                  PFILE_INFO pFileInfo,
                  LPTSTR szFoundPath
                  );

BOOL
VerifyCV(
        LPTSTR szFileName,
        PCHAR pImageBase,
        PIMAGE_DEBUG_DIRECTORY pDbgDir,
        LPTSTR szExtPath,
        LPTSTR szSearchPath,
        PSYM_ERR pSymErr
        );

LPSTR
GetMiscFile(
           PCHAR pImageBase,
           PIMAGE_DEBUG_DIRECTORY pDbgDir
           );

LPTSTR
SearchForSymbolFile (
                    LPTSTR szSearchPath,
                    LPTSTR szSymName,
                    LPTSTR szPathExt,
                    PSYM_ERR pSymErr,
                    DWORD SymType,
                    PVOID  pelem1
                    );

USHORT
__cdecl
CompDbg(
       PVOID pelem1,
       LPTSTR szSymName,
       PSYM_ERR pSymErr
       );

USHORT
__cdecl
CompPdb(
       PVOID pelem1,
       LPTSTR szSymName,
       PSYM_ERR pSymErr
       );

BOOL
AddToSymbolsCDLog(
                 FILE *hSymCDLog,
                 PSYM_ERR pSymErr,
                 LPTSTR szSymbolPath,
                 LPTSTR szFileExt
                 );

BOOL PDBPrivateStripped(
                       PDB *ppdb,
                       DBI *pdbi
                       );

int __cdecl
SymComp(
       const void *e1,
       const void *e2
       );

PEXCLUDE_LIST
GetExcludeList(
              LPTSTR szFileName
              )

{
    PEXCLUDE_LIST pExcList;

    FILE  *fFile;
    TCHAR szCurFile[_MAX_FNAME+1], *c;
    TCHAR fname[_MAX_FNAME+1], ext[_MAX_EXT+1];
    DWORD i;
    LPTSTR szEndName;


    pExcList = (PEXCLUDE_LIST)malloc(sizeof(EXCLUDE_LIST));

    pExcList->dNumFiles = 0;
    if (  (fFile = _tfopen(szFileName,_T("r") )) == NULL ) {
        // printf( "Cannot open the exclude file %s\n",szFileName );
        return FALSE;
    }

    while ( _fgetts(szCurFile,_MAX_FNAME,fFile) ) {
        if ( szCurFile[0] == ';' ) continue;
        (pExcList->dNumFiles)++;
    }

    // Go back to the beginning of the file
    fseek(fFile,0,0);
    pExcList->szExcList = (LPTSTR*)malloc( sizeof(LPTSTR) *
                                           (pExcList->dNumFiles));
    if (pExcList->szExcList == NULL) return FALSE;

    i = 0;
    while ( i < pExcList->dNumFiles ) {
        memset(szCurFile,'\0',sizeof(TCHAR) * (_MAX_FNAME+1) );
        _fgetts(szCurFile,_MAX_FNAME,fFile);

        // Replace the \n with \0
        c = NULL;
        c  = _tcschr(szCurFile, '\n');
        if ( c != NULL) *c='\0';

        if ( szCurFile[0] == ';' ) continue;

        if ( _tcslen(szCurFile) > _MAX_FNAME ) {
            printf("File %s has a string that is too large\n",szFileName);
            return(NULL);
        }

        // Allow for spaces and a ; after the file name
        // Move the '\0' back until it has erased the ';' and any
        // tabs and spaces that might come before it

        szEndName = _tcschr(szCurFile, ';');
        if (szEndName != NULL ) {
            while ( *szEndName == ';' || *szEndName == ' '
                    || *szEndName == '\t' ) {
                *szEndName = '\0';
                if ( szEndName > szCurFile ) szEndName--;
            }
        }

        pExcList->szExcList[i]=(LPTSTR)
                               malloc( sizeof(TCHAR) * (_tcslen(szCurFile)+1) );

        if (pExcList->szExcList[i] == NULL ) {
            printf("Malloc failed for %s\n",szCurFile);
        }

        _tsplitpath(szCurFile,NULL,NULL,fname,ext);

        _tcscpy(pExcList->szExcList[i],fname);
        _tcscat(pExcList->szExcList[i],ext);

        i++;
    }

    fclose(fFile);


    // Sort the List
    qsort( (void*)pExcList->szExcList, (size_t)pExcList->dNumFiles,
           (size_t)sizeof(LPTSTR), SymComp );


    return (pExcList);

}

BOOL
InExcludeList(
             LPTSTR szFileName,
             PEXCLUDE_LIST pExcludeList
             )

{
    DWORD i;
    int High;
    int Low;
    int Middle;
    int Result;

    // Lookup the name using a binary search
    if ( pExcludeList == NULL ) return FALSE;
    if ( pExcludeList->dNumFiles == 0 ) return FALSE;

    Low = 0;
    High = pExcludeList->dNumFiles - 1;
    while ( High >= Low ) {

        Middle = (Low + High) >> 1;
        Result = _tcsicmp( szFileName, pExcludeList->szExcList[Middle] );

        if ( Result < 0 ) {
            High = Middle - 1;

        } else if ( Result > 0 ) {
            Low = Middle + 1;

        } else {
            break;
        }
    }

    if ( High < Low ) return FALSE;

    return TRUE;
}


BOOL
InList(
      LPTSTR szFileName,
      P_LIST pExcludeList
      )

{
    DWORD i;
    int High;
    int Low;
    int Middle;
    int Result;

    // Lookup the name using a binary search
    if ( pExcludeList == NULL ) return FALSE;
    if ( pExcludeList->dNumFiles == 0 ) return FALSE;

    Low = 0;
    High = pExcludeList->dNumFiles - 1;
    while ( High >= Low ) {

        Middle = (Low + High) >> 1;
        Result = _tcsicmp( szFileName, pExcludeList->List[Middle].Path );

        if ( Result < 0 ) {
            High = Middle - 1;

        } else if ( Result > 0 ) {
            Low = Middle + 1;

        } else {
            break;
        }
    }

    if ( High < Low ) return FALSE;

    return TRUE;
}


int __cdecl
SymComp(
       const void *e1,
       const void *e2
       )
{
    LPTSTR* p1;
    LPTSTR* p2;

    p1 = (LPTSTR*)e1;
    p2 = (LPTSTR*)e2;

    return ( _tcsicmp(*p1,*p2) );
}


BOOL
CheckSymbols (
             LPTSTR ErrMsg,
             LPTSTR szSearchPath,
             LPTSTR szFileName,
             FILE   *hSymCDLog,
             ULONG SymchkFlag,
             BOOL Verbose
             )
/*++

Routine Description:

    This function accepts a file name and a symbol search path
    (delimited by ;) and determines if its symbols match.

Arguments:
    szSearchPath    Search path delimited by ;

    szFileName      Full path and name of the file to verify symbols for

    szCopyDest      If this is not a NULL value, then generate actually copy the
                    symbols to this destination

    SymchkFlag      Specifies action to take according to whether symbols are
                    split or not split.

                    Possible values:
                        ERROR_IF_SPLIT      Print an error if the image is split already
                        ERROR_IF_NOT_SPLIT  Error if image is not split
                        IGNORE_IF_SPLIT     Don't check symbols for split images

    Verbose         If true, print an output line for every file
                    If false, print output only for files that fail

Return Value:
    TRUE    if symbols are correct, or symbol checking was ignored
    FALSE   if symbols are not correct

--*/

{

    PIMAGE_NT_HEADERS pNtHeader = NULL;
    PIMAGE_DOS_HEADER pDosHeader = NULL;
    PIMAGE_SEPARATE_DEBUG_HEADER pDbgHeader= NULL;

    PIMAGE_DEBUG_DIRECTORY DebugDirectory;
    PIMAGE_DEBUG_DIRECTORY pDbgDir=NULL;
    PIMAGE_DEBUG_MISC pDebugMisc;

    PTCHAR pImageBase;

    ULONG NumberOfDebugDirectories;
    FILE_INFO FileInfo;
    LPTSTR szDbgFileName;
    LPSTR szMiscFileName;
    UINT i;
    PNB10I pDebugCV;


    TCHAR path_buffer[_MAX_PATH];
    TCHAR drive[_MAX_DRIVE];
    TCHAR dir[_MAX_DIR];
    TCHAR fname[_MAX_FNAME];
    TCHAR ext[_MAX_EXT];

    HANDLE DbgFile = 0;
    HANDLE DosFile = 0;

    BOOL SymbolsOK = TRUE;
    BOOL CVFound = FALSE;
    BOOL MiscFound = FALSE;
    BOOL RawDataFound = FALSE;

    SYM_ERR SymErr;

    // Get the file name and the extension
    _tsplitpath( szFileName,drive,dir,fname,ext);


    // Initialize SymErr
    memset( &SymErr,0,sizeof(SYM_ERR) );
    SymErr.Verbose = Verbose;
    _tcscpy( SymErr.szFileName, szFileName );
    _tcscpy( SymErr.szSymbolSearchPath, szSearchPath );
    _tcscpy( SymErr.szSymbolFileName, _T("") );
    _tcscpy( SymErr.szPdbErr, _T("") );
    _tcscpy( SymErr.szPdbFileName, _T("") );

    pDosHeader = MapFileHeader( szFileName, &DosFile, &SymErr );
    if ( SymErr.ErrNo > 0 ) {
        LogError( ErrMsg, &SymErr, 0);
        return TRUE;
    }

    pNtHeader = GetNtHeader( pDosHeader, DosFile, szFileName, &SymErr );
    if ( SymErr.ErrNo > 0 ) {
        LogError( ErrMsg, &SymErr,0 );
        return TRUE;
    }

    __try {
        // Resource Dll's shouldn't have symbols
        if ( ResourceOnlyDll((PVOID)pDosHeader, FALSE) ) {
            LogError( ErrMsg, &SymErr,RESOURCE_ONLY_DLL);
            SymbolsOK = TRUE;
            __leave;
        }

        // Get info out of file header for comparison later
        if (pNtHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
            FileInfo.CheckSum = ((PIMAGE_NT_HEADERS32)pNtHeader)->OptionalHeader.CheckSum;
            FileInfo.SizeOfImage = ((PIMAGE_NT_HEADERS32)pNtHeader)->OptionalHeader.SizeOfImage;
        } else {
            if (pNtHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
                FileInfo.CheckSum = ((PIMAGE_NT_HEADERS64)pNtHeader)->OptionalHeader.CheckSum;
                FileInfo.SizeOfImage = ((PIMAGE_NT_HEADERS64)pNtHeader)->OptionalHeader.SizeOfImage;
            } else {
                FileInfo.CheckSum = -1;
            }
        }
        FileInfo.TimeDateStamp = pNtHeader->FileHeader.TimeDateStamp;
        _tcscpy(FileInfo.szName,szFileName);


        // Locate the Debug Directory in this file
        DebugDirectory = NULL;
        DebugDirectory = GetDebugDirectoryInExe(
                                               pDosHeader,
                                               &NumberOfDebugDirectories
                                               );
        if (!DebugDirectory) {
            LogError( ErrMsg, &SymErr,NO_DEBUG_DIRECTORIES);
            SymbolsOK = FALSE;
            __leave;
        }
        pImageBase = (PCHAR) pDosHeader;

        // Do some checks on the Debug Directories
        /* Commenting this out for a few year because none of the debuggers
           really care about this stuff.  Also, BBT had a bug and didn't write
           the size of the debug directory correctly, so INVALID_POINTERTORAWDATA_
           ZERO_DEBUG was showing up as an error for some MFC files.  BryanT wanted
           me to comment this out.

            for ( i=0; i<NumberOfDebugDirectories; i++ ) {
                pDbgDir = DebugDirectory + i;

                if ( pDbgDir->SizeOfData != 0 ) {

                    if ( pDbgDir->PointerToRawData == 0 ) {
                        LogError( ErrMsg, &SymErr, INVALID_POINTERTORAWDATA_NON_ZERO );
                        return(FALSE);
                    }

                } else {

                    if ( pDbgDir->AddressOfRawData != 0 ) {
                        LogError( ErrMsg, &SymErr, INVALID_ADDRESSOFRAWDATA_ZERO_DEBUG );
                        return(FALSE);
                    }

                    if ( pDbgDir->PointerToRawData != 0 ) {
                        LogError( ErrMsg, &SymErr, INVALID_POINTERTORAWDATA_ZERO_DEBUG );
                        return(FALSE);
                    }
                }
            }
        */

        // Debug Information is stripped, we need the misc directory to find
        // out the DBG file name
        if ( (pNtHeader->FileHeader.Characteristics & IMAGE_FILE_DEBUG_STRIPPED) ) {
            if (SymchkFlag == ERROR_IF_SPLIT) {
                // Image is split, log error and continue;
                LogError( ErrMsg, &SymErr,ERROR_IF_SPLIT);
                SymbolsOK = FALSE;
                __leave;
            } else if (SymchkFlag == IGNORE_IF_SPLIT ) {
                // Image is split, don't check the symbols
                LogError( ErrMsg, &SymErr,IGNORE_IF_SPLIT);
                SymbolsOK = TRUE;
                __leave;
            }

            // Get the MISC entry
            i=0;
            while ( (i<NumberOfDebugDirectories) &&
                    ((DebugDirectory+i)->Type != IMAGE_DEBUG_TYPE_MISC) ) i++;

            if (i >= NumberOfDebugDirectories) {
                LogError( ErrMsg, &SymErr,NO_MISC_ENTRY);
                SymbolsOK = FALSE;
                __leave;
            }

            szMiscFileName = NULL;
            szMiscFileName = GetMiscFile(pImageBase,DebugDirectory + i);
            if (!szMiscFileName) {
                LogError( ErrMsg, &SymErr,NO_FILE_IN_MISC);
                SymbolsOK = FALSE;
                __leave;
            }

            // Debug info is stripped.
            // First, locate the correct DBG file
            szDbgFileName = NULL;
            szDbgFileName = SearchForSymbolFile (
                                                szSearchPath,
                                                szMiscFileName,
                                                ext+1, // Extension of the image
                                                &SymErr,
                                                DBGSYM,
                                                (PVOID)&FileInfo );

            if (!szDbgFileName) {
                LogDbgError(ErrMsg, &SymErr);
                SymbolsOK = FALSE;
                __leave;
            } else if ( hSymCDLog != NULL) {
                AddToSymbolsCDLog( hSymCDLog, &SymErr, SymErr.szSymbolFileName, ext+1);
            }

            // International builds need to call symchk and only grab the DBG and
            // write it to the symbols CD log.
            if (DbgOnly) {
                SymbolsOK = TRUE;
                __leave;
            }

            pDbgHeader = NULL;
            pDbgHeader = MapDbgHeader(szDbgFileName,&DbgFile, &SymErr);
            if (!pDbgHeader) {
                SymbolsOK = FALSE;
                // 0 means info is inside of SymErr
                LogError(ErrMsg, &SymErr,0);
                __leave;
            }

            DebugDirectory = NULL;
            DebugDirectory = GetDebugDirectoryInDbg(
                                                   pDbgHeader,
                                                   &NumberOfDebugDirectories
                                                   );
            if (!DebugDirectory) {
                LogError( ErrMsg, &SymErr,NO_DEBUG_DIRECTORIES_IN_DBG_HEADER);
                SymbolsOK = FALSE;
                __leave;
            }
            pImageBase = (PCHAR)pDbgHeader;
        }

        // Image is not split
        else {

            // VC 6 compiler always produces non-split images.
            // Check the debug directories to determine if this is a VC 6 image.

            RawDataFound = FALSE;
            CVFound = FALSE;
            MiscFound = FALSE;
            for ( i=0; i< NumberOfDebugDirectories; i++ ) {
                pDbgDir = DebugDirectory + i;
                switch (pDbgDir->Type) {
                    case IMAGE_DEBUG_TYPE_MISC:
                        MiscFound = TRUE;
                        break;

                    case IMAGE_DEBUG_TYPE_CODEVIEW:
                        CVFound = TRUE;
                        break;

                    default:
                        // Nothing except the CV entry should point to raw data
                        if ( pDbgDir->SizeOfData != 0 ) {
                            RawDataFound = TRUE;
                        }
                        break;
                }
            }

            if ( !MiscFound && CVFound ) {

                // This is using the 6.0 linker.  It does not
                // need to be split into iamge + dbg, so don't
                // give an error for it, unless there is another
                // debug directory with a non-null pointer to raw data.

                if ( RawDataFound ) {
                    LogError( ErrMsg, &SymErr, EXTRA_RAW_DATA_IN_6);
                    return ( FALSE);
                } else {
                    // Continue - image should not be split
                }
            } else {
                DWORD CertificateSize;
                PVOID pCertificates = ImageDirectoryEntryToData(
                                                     (PVOID)pDosHeader,
                                                     FALSE,
                                                     IMAGE_DIRECTORY_ENTRY_SECURITY,
                                                     &CertificateSize
                                                     );
                if ( pCertificates ) {
                    // Image is signed and non-split
                    // It should be split before it is signed
                    LogError( ErrMsg, &SymErr, SIGNED_AND_NON_SPLIT);
                    SymbolsOK = FALSE;
                    __leave;
                } else if (SymchkFlag == ERROR_IF_NOT_SPLIT) {
                    // Image isn't split, log error and continue;
                    LogError( ErrMsg, &SymErr,ERROR_IF_NOT_SPLIT);
                    SymbolsOK = FALSE;
                    __leave;
                }
            }

            // File with the DBG info is the original image file name
            // This line may not be necessary.
            _tcscpy( SymErr.szSymbolFileName, szFileName );
        }

        CVFound = FALSE;
        // Process the Debug Directories
        for ( i=0; i<NumberOfDebugDirectories; i++) {
            pDbgDir = DebugDirectory + i;
            switch (pDbgDir->Type) {

                // Don't need to process entry since directory table has
                // already been located.
                case IMAGE_DEBUG_TYPE_MISC:  break;

                case IMAGE_DEBUG_TYPE_CODEVIEW:
                    CVFound = TRUE;
                    if ( !VerifyCV(
                                  szFileName,
                                  pImageBase,
                                  pDbgDir,
                                  ext+1,
                                  szSearchPath,
                                  &SymErr
                                  )
                       ) {
                        LogPdbError(ErrMsg, &SymErr);
                        SymbolsOK = FALSE;
                    } else if (hSymCDLog != NULL && _tcscmp(SymErr.szPdbFileName, "") ) {
                        // Copy SymErr.szPdbFileName to Symbol Dest\ext
                        AddToSymbolsCDLog( hSymCDLog, &SymErr, SymErr.szPdbFileName, ext+1 );
                    }
                    break;
                default:    break;
            }
        }
        if (!CVFound && CheckCodeView ) {
            SymErr.ErrNo = NO_CODE_VIEW;
            LogPdbError(ErrMsg, &SymErr);
            SymbolsOK=FALSE;
        }
    } __finally {
        UnmapFile((LPCVOID)pDbgHeader,DbgFile);
        UnmapFile((LPCVOID)pDosHeader,DosFile);
    }

    if (SymbolsOK) {
        LogError( ErrMsg, &SymErr, IMAGE_PASSED );
    }

    return SymbolsOK;
}


PIMAGE_DOS_HEADER
MapFileHeader (
              LPTSTR szFileName,
              PHANDLE phFile,
              PSYM_ERR pSymErr
              )

{

    /*
        Creates a file mapping and returns Handle for the DOS_HEADER
        If the file does not have a DOS_HEADER, then it returns NULL.


    */
    HANDLE hFileMap;
    PIMAGE_DOS_HEADER pDosHeader;
    DWORD  dFileType;

    // phFile map needs to be returned, so it can be closed later
    (*phFile) = CreateFile( (LPCTSTR) szFileName,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                          );

    if (*phFile == INVALID_HANDLE_VALUE) {
        pSymErr->ErrNo  = CREATE_FILE_FAILED;
        pSymErr->ErrNo2 = GetLastError();
        _tcscpy( pSymErr->szFileName, szFileName);
        return(NULL);
    }

    hFileMap = CreateFileMapping( *phFile,
                                  NULL,
                                  PAGE_READONLY,
                                  0,
                                  0,
                                  NULL
                                );

    if ( hFileMap == INVALID_HANDLE_VALUE) {
        pSymErr->ErrNo = CREATE_FILE_MAPPING_FAILED;
        pSymErr->ErrNo2 = GetLastError();
        _tcscpy( pSymErr->szFileName, szFileName);
        CloseHandle(*phFile);
        return(NULL);
    }

    pDosHeader = (PIMAGE_DOS_HEADER) MapViewOfFile( hFileMap,
                                                    FILE_MAP_READ,
                                                    0,  // high
                                                    0,  // low
                                                    0   // whole file
                                                  );

    CloseHandle(hFileMap);

    if ( !pDosHeader ) {
        pSymErr->ErrNo = MAPVIEWOFFILE_FAILED;
        pSymErr->ErrNo2 = GetLastError();
        _tcscpy( pSymErr->szFileName, szFileName);
        UnmapFile((LPCVOID)pDosHeader, *phFile);
        return(NULL);
    }

    //
    // Check to determine if this is an NT image (PE format)

    if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
        pSymErr->ErrNo = NO_DOS_HEADER;
        UnmapFile((LPCVOID)pDosHeader,*phFile);
        return(NULL);
    }

    return (pDosHeader);
}


PIMAGE_NT_HEADERS
GetNtHeader ( PIMAGE_DOS_HEADER pDosHeader,
              HANDLE hDosFile,
              LPTSTR szFileName,
              PSYM_ERR pSymErr
            )
{

    /*
        Returns the pointer the address of the NT Header.  If there isn't
        an NT header, it returns NULL
    */
    PIMAGE_NT_HEADERS pNtHeader;
    LPBY_HANDLE_FILE_INFORMATION lpFileInfo;


    lpFileInfo = (LPBY_HANDLE_FILE_INFORMATION) malloc
                 (sizeof(BY_HANDLE_FILE_INFORMATION) );
    if (!GetFileInformationByHandle( hDosFile, lpFileInfo)) {
        pSymErr->ErrNo = GET_FILE_INFO_FAILED;
        pSymErr->ErrNo2 = GetLastError();
        free(lpFileInfo);
        return(NULL);
    }

    if ( ((ULONG)(pDosHeader->e_lfanew) & 3) != 0) {

        //
        // The image header is not aligned on a long boundary.
        // Report this as an invalid protect mode image.
        //

        pSymErr->ErrNo = HEADER_NOT_ON_LONG_BOUNDARY;
        free(lpFileInfo);
        return (NULL);
    }


    if ((ULONG)(pDosHeader->e_lfanew) > lpFileInfo->nFileSizeLow) {
        pSymErr->ErrNo = IMAGE_BIGGER_THAN_FILE;
        free(lpFileInfo);
        return (NULL);
    }


    pNtHeader = (PIMAGE_NT_HEADERS)((PCHAR)pDosHeader +
                                    (ULONG)pDosHeader->e_lfanew);

    if (pNtHeader->Signature != IMAGE_NT_SIGNATURE) {
        free(lpFileInfo);
        pSymErr->ErrNo = NOT_NT_IMAGE;
        return(NULL);
    }

    free(lpFileInfo);
    return (pNtHeader);
}


PIMAGE_SEPARATE_DEBUG_HEADER
MapDbgHeader (
             LPTSTR szFileName,
             PHANDLE phFile,
             PSYM_ERR pSymErr
             )
{
    HANDLE hFileMap;
    PIMAGE_SEPARATE_DEBUG_HEADER pDbgHeader;
    DWORD  dFileType;

    (*phFile) = CreateFile( (LPCTSTR) szFileName,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                          );

    if (*phFile == INVALID_HANDLE_VALUE) {
        pSymErr->ErrNo  = CREATE_FILE_FAILED;
        pSymErr->ErrNo2 = GetLastError();
        _tcscpy( pSymErr->szFileName, szFileName);
        CloseHandle(*phFile);
        return(NULL);
    }

    hFileMap = CreateFileMapping( *phFile,
                                  NULL,
                                  PAGE_READONLY,
                                  0,
                                  0,
                                  NULL
                                );

    if ( hFileMap == INVALID_HANDLE_VALUE) {
        pSymErr->ErrNo = CREATE_FILE_MAPPING_FAILED;
        pSymErr->ErrNo2 = GetLastError();
        _tcscpy( pSymErr->szFileName, szFileName);
        CloseHandle(*phFile);
        CloseHandle(hFileMap);
        return(NULL);
    }


    pDbgHeader = (PIMAGE_SEPARATE_DEBUG_HEADER) MapViewOfFile( hFileMap,
                                                               FILE_MAP_READ,
                                                               0,  // high
                                                               0,  // low
                                                               0   // whole file
                                                             );
    CloseHandle(hFileMap);

    if ( !pDbgHeader ) {
        pSymErr->ErrNo = MAPVIEWOFFILE_FAILED;
        pSymErr->ErrNo2 = GetLastError();
        _tcscpy( pSymErr->szFileName, szFileName);
        UnmapFile((LPCVOID)pDbgHeader, *phFile);
        return(NULL);
    }

    return (pDbgHeader);
}

BOOL
UnmapFile( LPCVOID phFileMap, HANDLE hFile )
{
    if ((PHANDLE)phFileMap != NULL) {
        UnmapViewOfFile( phFileMap );
    }
    if (hFile) {
        CloseHandle(hFile);
    }
    return TRUE;
}


PIMAGE_DEBUG_DIRECTORY
GetDebugDirectoryInExe(
                      PIMAGE_DOS_HEADER pDosHeader,
                      ULONG *NumberOfDebugDirectories
                      )
{

    /* Exe is already mapped and a pointer to the base is
       passed in. Find a pointer to the Debug Directories
    */
    ULONG size;

    PIMAGE_DEBUG_DIRECTORY pDebugDirectory = NULL;
    ULONG DebugDirectorySize;
    PIMAGE_SECTION_HEADER pSectionHeader;

    size = sizeof(IMAGE_DEBUG_DIRECTORY);

    pDebugDirectory = (PIMAGE_DEBUG_DIRECTORY)
                      ImageDirectoryEntryToDataEx (
                                                  (PVOID)pDosHeader,
                                                  FALSE,
                                                  IMAGE_DIRECTORY_ENTRY_DEBUG,
                                                  &DebugDirectorySize,
                                                  &pSectionHeader );

    if (pDebugDirectory) {
        (*NumberOfDebugDirectories) =
        DebugDirectorySize / sizeof(IMAGE_DEBUG_DIRECTORY);
        return (pDebugDirectory);
    } else return(NULL);
}

PIMAGE_DEBUG_DIRECTORY
GetDebugDirectoryInDbg(
                      PIMAGE_SEPARATE_DEBUG_HEADER pDbgHeader,
                      ULONG *NumberOfDebugDirectories
                      )
/*  Dbg is already mapped and a pointer to the base is
    passed in.  Returns a pointer to the Debug directories
*/
{
    PIMAGE_DEBUG_DIRECTORY pDebugDirectory = NULL;

    pDebugDirectory = (PIMAGE_DEBUG_DIRECTORY) ((PCHAR)pDbgHeader +
                                                sizeof(IMAGE_SEPARATE_DEBUG_HEADER) +
                                                pDbgHeader->NumberOfSections * sizeof(IMAGE_SECTION_HEADER) +
                                                pDbgHeader->ExportedNamesSize);

    if (!pDebugDirectory) {
        return(NULL);
    }

    (*NumberOfDebugDirectories) =   pDbgHeader->DebugDirectorySize /
                                    sizeof(IMAGE_DEBUG_DIRECTORY);
    return (pDebugDirectory);

}


BOOL
VerifyCV(
        LPTSTR szFileName,
        PCHAR pImageBase,
        PIMAGE_DEBUG_DIRECTORY pDbgDir,
        LPTSTR szExtPath,
        LPTSTR szSearchPath,
        PSYM_ERR pSymErr
        )

{
    PNB10I pDebugCV;
    LPTSTR szPdbFileName;

    TCHAR szFName[_MAX_FNAME];
    TCHAR szExt[_MAX_EXT];

    pDebugCV = (PNB10I) (pImageBase +
                         pDbgDir->PointerToRawData );

    // Initialize pSymErr
    pSymErr->PdbFileFound = FALSE;
    pSymErr->PdbValid = FALSE;
    _tcscpy(pSymErr->szPdbErr,_T("") );
    _tcscpy(pSymErr->szPdbFileName,_T("") );

    if ( pDebugCV->dwSig == '05BN') {
        // CVpack failed
        // Symbols are not OK
        _tcscpy(pSymErr->szPdbErr,_T("Codeview type is NB05") );
        return (FALSE);

    }
    if ( (pDebugCV->dwSig == '90BN') ||
         ( pDebugCV->dwSig == '11BN') ) {
        // For NB09 and NB11, the codeview info is in the image file
        // Thus, no need to locate symbols.  They are probably OK.
        return(TRUE);
    } else if ( pDebugCV->dwSig == '01BN') {
        // Symbols are type NB10
        // Locate the PDB information

        szPdbFileName = NULL;

        szPdbFileName = SearchForSymbolFile (
                                            szSearchPath,
                                            pDebugCV->szPDB, // File Name
                                            szExtPath,
                                            pSymErr,
                                            PDBSYM,
                                            (PVOID)pDebugCV
                                            );
        if (szPdbFileName) {
            // SearchForSymbolFile already gave pSymErr->szPdbFilename its value
            return TRUE;
        } else {
            _tsplitpath(pDebugCV->szPDB,NULL,NULL,szFName,szExt);
            _tcscpy(pSymErr->szPdbFileName,szFName);
            _tcscat(pSymErr->szPdbFileName,szExt);
            return FALSE;
        }
    } else {
        _tcscpy(pSymErr->szPdbErr,
                _T("Codeview info is not NB09, NB10, or NB11\n") );
        return(FALSE);
    }
}


LPSTR
GetMiscFile(
           PCHAR pImageBase,
           PIMAGE_DEBUG_DIRECTORY pDbgDir
           )

{
    PIMAGE_DEBUG_MISC pDebugMisc;
    LPSTR szData;

    // Nothing to verify, but here is how to get to the DBG entry
    // Get the debug directory

    pDebugMisc = (PIMAGE_DEBUG_MISC)(pImageBase +
                                     pDbgDir->PointerToRawData );
    szData = (LPSTR) &pDebugMisc->Data[0];
    return(szData);
}


LPTSTR SearchForSymbolFile ( LPTSTR     szSearchPath, // ; separated search path
                             LPTSTR     szSymName,    // Symbol File to search for
                             LPTSTR     szPathExt,    // Extension directory
                             PSYM_ERR   pSymErr,
                             DWORD      dSymType,
                             PVOID      pelem1
                           )

{
    /*++

    Routine Description:
       For each symbol path in szSearchPath, this function looks in the path
       and in the path concatenated with the szPathExt subdirectory.

    Arguments:
        szSearchPath    ; separated symbol path

        szSymName       Symbol file to search for

        szPathExt       Extension for the image that the symbol file matches

        pSymErr         Error structure

        dSymType        Type of symbol.  Possible values: DBGSYM, PDBSYM

        pelem1          Pointer to structure needed for comparing the symbols


    Return Value:
        If the symbol file is found and verifies, it returns the full path and
        name of the symbol file.  Otherwise, it returns NULL.

    --*/

    TCHAR szTmpSearchPath[_MAX_PATH];
    TCHAR szExtPath[_MAX_PATH];
    TCHAR szFName[_MAX_FNAME];
    TCHAR szExt[_MAX_EXT];

    LPTSTR szResultFileName;
    LPTSTR szResult;
    LPTSTR seps = _T(";");
    LPTSTR szCurPath;
    DWORD  FoundLength;
    DWORD  CurLen, ExtLen;
    DWORD  dwResultLength;

    dwResultLength = _MAX_PATH;
    szResult = (LPTSTR)malloc( _MAX_PATH * sizeof(TCHAR) );

    // Make a copy of szSearchPath because tcstok alters it
    _tcscpy(szTmpSearchPath,(LPCTSTR)szSearchPath);

    // Strip FileName from its path
    _tsplitpath(szSymName, NULL, NULL, szFName, szExt);

    // Try each search path
    szCurPath = _tcstok(szTmpSearchPath,seps);

    while ( szCurPath != NULL ) {

        FoundLength = SearchPath( szCurPath,
                                  szFName,
                                  szExt,
                                  dwResultLength,
                                  szResult,
                                  &szResultFileName
                                );
        if (FoundLength > 0 && FoundLength < dwResultLength) {

            switch ( dSymType ) {
                case DBGSYM:
                    // Status info, a match was found
                    pSymErr->SymbolFileFound = TRUE;
                    _tcscpy(pSymErr->szSymbolFileName, szResult);

                    // Validate the DBG file
                    if ( CompDbg(pelem1, szResult, pSymErr) ) {
                        return (szResult);
                    }
                    break;

                case PDBSYM:
                    // Status info, a match was found
                    pSymErr->PdbFileFound = TRUE;
                    _tcscpy(pSymErr->szPdbFileName, szResult);

                    // Validate the PDB file
                    if ( CompPdb(pelem1, szResult, pSymErr) ) {
                        return (szResult);
                    }
                    break;

                default: break;
            }
        }

        // Now try the path with szPathExt at the end of it
        // Don't try it if current path already has the extension
        // at the end of it
        CurLen = _tcslen(szCurPath);
        ExtLen = _tcslen(szPathExt);

        if ( _tcscmp ( (szCurPath + CurLen - ExtLen), szPathExt ) ) {

            _tcscpy(szExtPath, szCurPath);
            _tcscat(szExtPath, _T("\\") );
            _tcscat(szExtPath, szPathExt);

            FoundLength = SearchPath( szExtPath,
                                      szFName,
                                      szExt,
                                      dwResultLength,
                                      szResult,
                                      &szResultFileName
                                    );
            if (FoundLength > 0 && FoundLength < dwResultLength) {
                switch ( dSymType ) {
                    case DBGSYM:
                        // Status info, a match was found
                        pSymErr->SymbolFileFound = TRUE;
                        _tcscpy(pSymErr->szSymbolFileName, szResult);

                        // Validate the DBG file
                        if ( CompDbg(pelem1, szResult, pSymErr) ) {
                            return (szResult);
                        }
                        break;
                    case PDBSYM:
                        // Status info, a match was found
                        pSymErr->PdbFileFound = TRUE;
                        _tcscpy(pSymErr->szPdbFileName, szResult);

                        // Validate the PDB file
                        if ( CompPdb(pelem1, szResult, pSymErr) ) {
                            return (szResult);
                        }
                        break;
                    default: break;
                }
            }
        }
        szCurPath = _tcstok(NULL,seps);
    }

    // Symbol wasn't found.  Put name of file into SymErr for error message
    switch ( dSymType ) {
        case DBGSYM:
            _tcscpy(pSymErr->szSymbolFileName,szFName);
            _tcscat(pSymErr->szSymbolFileName,szExt);
            break;
        case PDBSYM:
            _tcscpy(pSymErr->szPdbFileName, szFName);
            _tcscat(pSymErr->szPdbFileName, szExt);
            break;
        default: break;
    }

    free(szResult);
    return NULL;
}


USHORT
__cdecl
CompDbg(
       PVOID pelem1,
       LPTSTR szSymName,
       PSYM_ERR pSymErr
       )

/*++

    Routine Description:
        Validates the DBG against the original image

    Return Value:
        TRUE -  DBG matches
        FALSE - DBG doesn't match timedatestamp and checksum


--*/
{

    PFILE_INFO pFileInfo;
    PIMAGE_SEPARATE_DEBUG_HEADER pDbgHeader;
    HANDLE hFile;

    pFileInfo = (PFILE_INFO)(pelem1);
    pDbgHeader = MapDbgHeader ( szSymName, &hFile, pSymErr );

    if (pDbgHeader == NULL) {
        printf("ERROR: CompDbg(), %s was not opened successfully\n",szSymName);
        UnmapFile((LPCVOID)pDbgHeader, hFile);
        return FALSE;
    }
    if (pDbgHeader->Signature != IMAGE_SEPARATE_DEBUG_SIGNATURE) {
        printf("ERROR: CompDbg(), %s doesn't have Debug signature in header\n");
        UnmapFile((LPCVOID)pDbgHeader, hFile);
        return FALSE;
    }

    // Record specifics of whether timedatestamp and checksum matched
    if ( pDbgHeader->SizeOfImage == pFileInfo->SizeOfImage ) {
        pSymErr->SizeOfImageMatch = TRUE;
    } else pSymErr->SizeOfImageMatch = FALSE;

    if ( pDbgHeader->TimeDateStamp == pFileInfo->TimeDateStamp ) {
        pSymErr->TimeDateStampsMatch = TRUE;
    } else pSymErr->TimeDateStampsMatch = FALSE;

    if ( pDbgHeader->CheckSum == pFileInfo->CheckSum ) {
        pSymErr->CheckSumsMatch = TRUE;
    } else pSymErr->CheckSumsMatch = FALSE;

    // Just check the timedatestamp for determining if the DBG matches
    // VC and KD don't pay attention to the checksum anymore.
    if ( pSymErr->TimeDateStampsMatch  &&
         pSymErr->SizeOfImageMatch &&
         ( !LogCheckSumErrors || pSymErr->CheckSumsMatch ) ) {
        UnmapFile((LPCVOID)pDbgHeader, hFile);
        return TRUE;
    } else {
        UnmapFile((LPCVOID)pDbgHeader, hFile);
        return FALSE;
    }
}

USHORT
__cdecl
CompPdb(
       PVOID pelem1,
       LPTSTR szSymName,
       PSYM_ERR pSymErr
       )

/*++

    Routine Description:
        Validates the PDB

    Return Value:
        TRUE    PDB validates
        FALSE   PDB doesn't validate
--*/

{

    PNB10I pPdbInfo;
    PNB10I pCurPdb;

    BOOL valid;
    PDB *pdb;
    EC ec;
    char szError[cbErrMax] = _T("");
    SIG sig;
    AGE age;

    DBI *pdbi;

    pdb=NULL;

    pPdbInfo = (PNB10I)(pelem1);

    valid = PDBOpenValidate(szSymName,
                            NULL,
                            _T("r"),
                            pPdbInfo->sig,
                            pPdbInfo->age,
                            &ec,
                            szError,
                            &pdb
                           );

    /*
      valid = PDBOpen( pPdbInfo->szPDB,
                       _T("r"),
                       pPdbInfo->sig,
                       &ec,
                       szError,
                       &pdb
                       );
    */

    if ( !valid ) {
        pSymErr->PdbValid = FALSE;
        return FALSE;
    } else pSymErr->PdbValid = TRUE;

    //  sig = PDBQuerySignature(pdb);
    //  age = PDBQueryAge(pdb);


    if (!CheckPrivate) {
        PDBClose(pdb);
        return (USHORT)pSymErr->PdbValid;
    }

    // Verify that private information is stripped
    // Verify that line information is removed

    if ( !PDBOpenDBI(pdb, pdbRead, NULL, &pdbi) ) {
        // OpenDBI failed
        pSymErr->ErrNo = PDB_MAY_BE_CORRUPT;
        return FALSE;
    }

    if ( !PDBPrivateStripped(pdb, pdbi) ) {
        //Error - Source line info is not stripped
        pSymErr->PdbValid = FALSE;
        pSymErr->ErrNo = PRIVATE_INFO_NOT_REMOVED;
    }

    PDBClose(pdb);
    return (USHORT)pSymErr->PdbValid;


}


BOOL
ResourceOnlyDll(
               PVOID pImageBase,
               BOOLEAN bMappedAsImage
               )

/*++

Routine Description:

    Returns true if the image is a resource only dll.

--*/

{

    PVOID pExports, pImports, pResources;
    DWORD dwExportSize, dwImportSize, dwResourceSize;
    BOOL fResourceOnlyDll;

    pExports = ImageDirectoryEntryToData(pImageBase,
                                         bMappedAsImage,
                                         IMAGE_DIRECTORY_ENTRY_EXPORT,
                                         &dwExportSize);

    pImports = ImageDirectoryEntryToData(pImageBase,
                                         bMappedAsImage,
                                         IMAGE_DIRECTORY_ENTRY_IMPORT,
                                         &dwImportSize);

    pResources = ImageDirectoryEntryToData(pImageBase,
                                           bMappedAsImage,
                                           IMAGE_DIRECTORY_ENTRY_RESOURCE,
                                           &dwResourceSize);

    if (pResources && dwResourceSize &&
        !pImports && !dwImportSize &&
        !pExports && !dwExportSize) {
        return (TRUE);
    } else {
        return (FALSE);
    }
}


BOOL
LogError(
        LPTSTR ErrMsg,
        PSYM_ERR pSymErr,
        UINT ErrNo )
{

    TCHAR szFName[_MAX_FNAME];
    TCHAR szExt[_MAX_EXT];
    TCHAR szCurName[_MAX_FNAME];


    if (pSymErr->ErrNo != 0) ErrNo = pSymErr->ErrNo;

    // Get the file name without any path info:
    if (Recurse) {
        _tcscpy(szCurName, pSymErr->szFileName);
    } else {
        _tsplitpath(pSymErr->szFileName,NULL,NULL,szFName,szExt);
        _tcscpy(szCurName,szFName);
        _tcscat(szCurName,szExt);
    }

    _tcscpy(ErrMsg,_T(""));

    // See if this is a file that we aren't supposed to report errors
    // for.  If it is, just return without writing an error.

    if ( pErrorFilterList != NULL ) {
        if ( InExcludeList( szCurName, pErrorFilterList ) ) {
            return(TRUE);
        }
    }

    switch (ErrNo) {
        case NO_DEBUG_DIRECTORIES:
            _stprintf(ErrMsg, "%-20s FAILED  - Built with no debugging information\n",
                      szCurName);
            return(TRUE);

        case NO_DEBUG_DIRECTORIES_IN_DBG_HEADER:
            _stprintf(ErrMsg, "%-20s FAILED  - Header for %s has no debugging information\n",
                      szCurName);
            return(TRUE);

        case NO_MISC_ENTRY:
            _stprintf(ErrMsg, "%-20s FAILED  - No MISC entry in debug directories\n",
                      szCurName);
            return(TRUE);

        case NO_FILE_IN_MISC:
            _stprintf(ErrMsg, "%-20s FAILED  - MISC entry contains no .dbg file information\n",
                      szCurName);
            return(TRUE);

        case ERROR_IF_SPLIT:
            _stprintf(ErrMsg, "%-20s FAILED  - Debug information is stripped from image\n",
                      szCurName);
            return(TRUE);

        case ERROR_IF_NOT_SPLIT:
            _stprintf(ErrMsg, "%-20s FAILED  - Image still contains data that should be in a .DBG file\n",
                      szCurName);
            return(TRUE);

        case EXTRA_RAW_DATA_IN_6:
            _stprintf(ErrMsg, "%-20s FAILED  - No misc entry, but debug directories point to non-Codeview data\n",
                      szCurName );
            return (TRUE);

        case IGNORE_IF_SPLIT:
            if ( pSymErr->Verbose) {
                _stprintf(ErrMsg, "%-20s IGNORED - Image is already split\n",szCurName);
            }
            return(TRUE);


        case NO_CODE_VIEW:
            _stprintf(ErrMsg, "%-20s FAILED  - %s does not have a pointer to CodeView information\n",
                      szCurName, pSymErr->szSymbolFileName);
            return(TRUE);

        case FILE_NOT_FOUND:
            _stprintf(ErrMsg, "%-20s FAILED  - File does not exist\n",szCurName);
            return(TRUE);

        case CREATE_FILE_FAILED :
            if ( pSymErr->Verbose) {
                _stprintf(ErrMsg, "%-20s IGNORED - Image is not a valid NT image.\n", szCurName);
            }
            return(TRUE);

        case CREATE_FILE_MAPPING_FAILED :
            if ( pSymErr->Verbose) {
                _stprintf(ErrMsg, "%-20s IGNORED - Image is not a valid NT image.\n", szCurName);
            }
            return(TRUE);

        case MAPVIEWOFFILE_FAILED :
            if ( pSymErr->Verbose) {
                _stprintf(ErrMsg, "%-20s IGNORED - Image is not a valid NT image.\n", szCurName);
            }
            return(TRUE);

        case GET_FILE_INFO_FAILED :
            if ( pSymErr->Verbose) {
                _stprintf(ErrMsg, "%-20s IGNORED - Image is not a valid NT image.\n", szCurName);
            }
            return(TRUE);

        case HEADER_NOT_ON_LONG_BOUNDARY:
            // Not an NT image - ignore the error
            if (pSymErr->Verbose) {
                _stprintf(ErrMsg, "%-20s IGNORED - This is either corrupt or a DOS image\n", szCurName);
            }
            return(TRUE);

        case IMAGE_BIGGER_THAN_FILE:
            if (pSymErr->Verbose) {
                _stprintf(ErrMsg, "%-20s IGNORED - This is either corrupt or a DOS image\n", szCurName);
            }
            return(TRUE);

        case INVALID_ADDRESSOFRAWDATA_ZERO_DEBUG:
            _stprintf(ErrMsg, "%-20s FAILED  - Invalid AddressOfRawData for zero sized debug info\n",
                      szCurName);
            return(TRUE);

        case INVALID_POINTERTORAWDATA_NON_ZERO:
            _stprintf(ErrMsg, "%-20s FAILED  - Invalid PointerToRawData for non-zero sized debug info\n",
                      szCurName);
            return(TRUE);

        case INVALID_POINTERTORAWDATA_ZERO_DEBUG:
            _stprintf(ErrMsg, "%-20s FAILED  - Invalid PointerToRawData for zero sized debug info\n",
                      szCurName);
            return(TRUE);

        case NO_DOS_HEADER:
            if ( pSymErr->Verbose) {
                _stprintf(ErrMsg, "%-20s IGNORED - Image does not have a DOS header\n",
                          szCurName);
            }
            return(TRUE);

        case NOT_NT_IMAGE:
            if ( pSymErr->Verbose) {
                _stprintf(ErrMsg, "%-20s IGNORED - Image does not have an NT header\n",
                          szCurName);
            }
            return(TRUE);
        case IMAGE_PASSED :
            if ( pSymErr->Verbose) {
                _stprintf(ErrMsg, "%-20s PASSED \n",szCurName);
            }
            return(TRUE);

        case RESOURCE_ONLY_DLL:
            if ( pSymErr->Verbose) {
                _stprintf(ErrMsg, "%-20s IGNORED - Resource only DLL\n",szCurName);
            }
            return(TRUE);

        case SIGNED_AND_NON_SPLIT:
            _stprintf(ErrMsg, "%-20s FAILED  - It is signed and debug info can't be stripped without invalidating the signature\n",
                      szCurName);
            return(TRUE);

        default:
            return(TRUE);
    }
    return (FALSE);
}


BOOL
LogDbgError(
           LPTSTR ErrMsg,
           PSYM_ERR pSymErr
           )

{

    TCHAR szFName[_MAX_FNAME];
    TCHAR szExt[_MAX_EXT];
    TCHAR szCurName[_MAX_FNAME];
    TCHAR szSymName[_MAX_FNAME];

    // Get the file name without any path info:
    if (Recurse) {
        _tcscpy(szCurName, pSymErr->szFileName);
    } else {
        _tsplitpath(pSymErr->szFileName,NULL,NULL,szFName,szExt);
        _tcscpy(szCurName,szFName);
        _tcscat(szCurName,szExt);
    }

    _tcscpy(ErrMsg,_T("") );

    // See if this is a file that we aren't supposed to report errors
    // for.  If it is, just return without writing an error.

    if ( pErrorFilterList != NULL ) {
        if ( InExcludeList( szCurName, pErrorFilterList ) ) {
            return(TRUE);
        }
    }

    // Get the file name without any path info:
    _tsplitpath(pSymErr->szSymbolFileName,NULL,NULL,szFName,szExt);
    _tcscpy(szSymName,szFName);
    _tcscat(szSymName,szExt);


    if ( !pSymErr->SymbolFileFound ) {
        _stprintf(ErrMsg, "%-20s FAILED  - Image is split correctly, but %s is missing\n",
                  szCurName, szSymName);
        return(TRUE);
    }

    if ( LogCheckSumErrors && !pSymErr->CheckSumsMatch) {
        _stprintf(ErrMsg, "%-20s FAILED  - Checksum doesn't match with %s\n",
                  szCurName, szSymName);
        return(TRUE);
    }

    if ( !pSymErr->SizeOfImageMatch) {
        _stprintf(ErrMsg, "%-20s FAILED  - Size of image doesn't match with %s\n",
                  szCurName, szSymName);
        return(TRUE);
    }

    if ( !pSymErr->TimeDateStampsMatch) {
        _stprintf(ErrMsg, "%-20s FAILED  - Timedate stamp doesn't match with %s\n",
                  szCurName, szSymName);
        return(TRUE);
    }

    return(TRUE);
}


BOOL
LogPdbError(
           LPTSTR ErrMsg,
           PSYM_ERR pSymErr
           )

{

    TCHAR szFName[_MAX_FNAME];
    TCHAR szExt[_MAX_EXT];
    TCHAR szCurName[_MAX_FNAME];
    TCHAR szSymName[_MAX_FNAME];
    TCHAR szPdbName[_MAX_FNAME];

    // Get the file name without any path info:
    if (Recurse) {
        _tcscpy(szCurName, pSymErr->szFileName);
    } else {
        _tsplitpath(pSymErr->szFileName,NULL,NULL,szFName,szExt);
        _tcscpy(szCurName,szFName);
        _tcscat(szCurName,szExt);
    }

    _tcscpy(ErrMsg,_T("") );

    // See if this is a file that we aren't supposed to report errors
    // for.  If it is, just return without writing an error.

    if ( pErrorFilterList != NULL ) {
        if ( InExcludeList( szCurName, pErrorFilterList ) ) {
            return(TRUE);
        }
    }

    // Get the file name without any path info:
    _tsplitpath(pSymErr->szSymbolFileName,NULL,NULL,szFName,szExt);
    _tcscpy(szSymName,szFName);
    _tcscat(szSymName,szExt);


    // Get the file name without any path info:
    _tsplitpath(pSymErr->szPdbFileName,NULL,NULL,szFName,szExt);
    _tcscpy(szPdbName,szFName);
    _tcscat(szPdbName,szExt);

    if (pSymErr->ErrNo == NO_CODE_VIEW) {
        _stprintf(ErrMsg, "%-20s FAILED  - %s does not point to CodeView information\n",
                  szCurName, szSymName);
        return(TRUE);
    }
    if (pSymErr->ErrNo == PRIVATE_INFO_NOT_REMOVED) {
        _stprintf(ErrMsg, "%-20s FAILED  - %s contains private information\n",
                  szCurName, szPdbName);
        return(TRUE);
    }

    if (pSymErr->ErrNo == PDB_MAY_BE_CORRUPT) {
        _stprintf(ErrMsg, "%-20s FAILED  - %s may be corrupt\n",
                  szCurName, szPdbName);
        return(TRUE);
    }

    if ( _tcscmp(pSymErr->szPdbErr,_T("") ) ) {
        _stprintf(ErrMsg, "%-20s FAILED  - %s\n",szCurName, pSymErr->szPdbErr );
        return(TRUE);
    }

    if ( pSymErr->SymbolFileFound  && !pSymErr->PdbFileFound ) {
        _stprintf(ErrMsg, "%-20s FAILED  - %s is correct, but %s is missing\n",
                  szCurName, szSymName, szPdbName);
        return(TRUE);
    }

    if ( !pSymErr->PdbFileFound ) {
        _stprintf(ErrMsg, "%-20s FAILED  - %s is missing \n",szCurName,szPdbName );
        return(TRUE);
    }

    // There was a DBG file, but PDB file didn't validate

    if ( pSymErr->SymbolFileFound && !pSymErr->PdbValid ) {
        _stprintf(ErrMsg, "%-20s FAILED  - %s and %s signatures do not match\n",
                  szCurName, szSymName, szPdbName);
        return(TRUE);
    }

    // There isn't supposed to be a DBG file.  PDB doesn't validate against
    // image.

    if ( !pSymErr->PdbValid ) {
        _stprintf(ErrMsg, "%-20s FAILED  - signature does not match %s\n",
                  szCurName, szPdbName );
        return(TRUE);
    }
    return(FALSE);
}


BOOL AddToSymbolsCDLog(
                      FILE *hSymCDLog,
                      PSYM_ERR pSymErr,
                      LPTSTR szSymbolPath,
                      LPTSTR szFileExt
                      )

/*
   szSymbolPath is the full path and name to the symbol file
   szFileExt is the extension of the image without the '.' at
   the front
*/

{

    LPTSTR szSrc;
    LPTSTR szDest;
    LPTSTR szTmp;

    TCHAR szFName[_MAX_FNAME+1];
    TCHAR szExt[_MAX_EXT+1];
    TCHAR szCurName[_MAX_FNAME + _MAX_EXT + 1];
    TCHAR szDestDir[_MAX_PATH];
    TCHAR szSymName[_MAX_FNAME + 1];
    TCHAR szSymExt[_MAX_EXT + 1];

    // If there is a list of the files that belong on the
    // CD, then only write this file to the log for the
    // symbol CD if the file is in the list
    //
    // Originally, this was used for the international
    // incremental builds.
    //
    if ( pCDIncludeList != NULL ) {
        if ( !InList( szSymbolPath, pCDIncludeList ) ) {
            return (TRUE);
        }
    }

    // Get the file name without any path info:
    _tsplitpath(pSymErr->szFileName,NULL,NULL,szFName,szExt);
    _tcscpy(szCurName,szFName);


    // Put the path below "binaries" as the source
    szSrc = _tcsstr(szSymbolPath, _T("symbols\\") );

    if (szSrc == NULL) {
        printf("%s: Cannot find \"symbols\\\" in the symbol file's path\n",
               szCurName);
        exit(1);
    }
    if ( _tcscmp( szSrc, _T("symbols\\") )  == 0 ) {
        printf("Symbol file name cannot end with \"symbols\\\"\n");
        exit(1);
    }

    // Move the Destination up to the directory after symbols.  If this is
    // the retail directory, don't include retail in the path.
    szDest = szSrc + _tcslen(_T("symbols\\"));

    if ( _tcsncmp( szDest, _T("retail\\"), _tcslen(_T("retail\\")) ) == 0 ) {
        szDest = szDest + _tcslen(_T("retail\\"));
    }

    _tsplitpath(szDest,NULL,szDestDir,NULL,NULL);

    // Remove the '\' from the end of the string;
    szTmp = szDestDir + _tcslen(szDestDir) - 1;
    while ( _tcscmp( szTmp, _T("\\")) == 0 ) {
        _tcscpy( szTmp, _T("") );
        szTmp--;
    }

    // get the symbol file name
    _tsplitpath(szSymbolPath,NULL,NULL,szSymName,szSymExt);


    fprintf(hSymCDLog, "%s%s,%s%s,%s,%s\n", szFName,szExt,
            szSymName,szSymExt,szSrc,szDestDir);

    return (TRUE);
}



P_LIST
GetList(
       LPTSTR szFileName
       )

{

    /* GetList gets the list and keeps the original file name which could
     * have included the path to the file
     * Note, it can be merged with GetExcludeList.  I first created it for
     * use in creating the symbols CD, and didn't want to risk entering a
     * bug into symchk
     */

    P_LIST pList;

    FILE  *fFile;
    TCHAR szCurFile[_MAX_FNAME+1], *c;
    TCHAR fname[_MAX_FNAME+1], ext[_MAX_EXT+1];
    DWORD i;
    LPTSTR szEndName;


    pList = (P_LIST)malloc(sizeof(LIST));

    pList->dNumFiles = 0;
    if (  (fFile = _tfopen(szFileName,_T("r") )) == NULL ) {
        // printf( "Cannot open the exclude file %s\n",szFileName );
        return FALSE;
    }

    while ( _fgetts(szCurFile,_MAX_FNAME,fFile) ) {
        if ( szCurFile[0] == ';' ) continue;
        (pList->dNumFiles)++;
    }

    // Go back to the beginning of the file
    fseek(fFile,0,0);
    pList->List = (LIST_ELEM*)malloc( sizeof(LIST_ELEM) *
                                      (pList->dNumFiles));
    if (pList->List == NULL) return FALSE;

    i = 0;
    while ( i < pList->dNumFiles ) {
        memset(szCurFile,'\0',sizeof(TCHAR) * (_MAX_FNAME+1) );
        _fgetts(szCurFile,_MAX_FNAME,fFile);

        // Replace the \n with \0
        c = NULL;
        c  = _tcschr(szCurFile, '\n');
        if ( c != NULL) *c='\0';

        if ( szCurFile[0] == ';' ) continue;

        if ( _tcslen(szCurFile) > _MAX_FNAME ) {
            printf("File %s has a string that is too large\n",szFileName);
            return(NULL);
        }

        // Allow for spaces and a ; after the file name
        // Move the '\0' back until it has erased the ';' and any
        // tabs and spaces that might come before it
        szEndName = _tcschr(szCurFile, ';');
        if (szEndName != NULL ) {
            while ( *szEndName == ';' || *szEndName == ' '
                    || *szEndName == '\t' ) {
                *szEndName = '\0';
                if ( szEndName > szCurFile ) szEndName--;
            }
        }

        _tcscpy(pList->List[i].Path,szCurFile);

        _tsplitpath(szCurFile,NULL,NULL,fname,ext);

        _tcscpy(pList->List[i].FName,fname);
        _tcscat(pList->List[i].FName,ext);

        i++;
    }

    fclose(fFile);


    // Sort the List
    qsort( (void*)pList->List, (size_t)pList->dNumFiles,
           (size_t)sizeof(LIST_ELEM), SymComp2 );


    return (pList);

}

int __cdecl
SymComp2(
        const void *e1,
        const void *e2
        )
{
    LPTSTR p1,n1;
    LPTSTR p2,n2;
    int rc;

    p1 = ((LIST_ELEM*)e1)->FName;
    p2 = ((LIST_ELEM*)e2)->FName;

    n1 = ((LIST_ELEM*)e1)->Path;
    n2 = ((LIST_ELEM*)e2)->Path;

    rc = _tcsicmp(p1,p2);
    if (rc == 0) return ( _tcsicmp(n1,n2) );
    else return (rc);
}



BOOL PDBPrivateStripped(
                       PDB *ppdb,
                       DBI *pdbi
                       )
{
    // Return values:
    // FALSE - Private Information has NOT been stripped
    // TRUE - Private Information has been stripped

    Mod *pmod;
    long cb;

    unsigned itsm;
    TPI *ptpi;
    TI  tiMin;
    TI  tiMac;

    pmod = NULL;
    while (DBIQueryNextMod(pdbi, pmod, &pmod) && pmod) {

        // Check that Source line info is removed
        ModQueryLines(pmod, NULL, &cb);

        if (cb != 0) {
            return FALSE;
        }

        // Check that local symbols are removed
        ModQuerySymbols(pmod, NULL, &cb);

        if (cb != 0) {
            return FALSE;
        }

    }

    // Check that types are removed
    for ( itsm = 0; itsm < 256; itsm++) {
        ptpi = 0;
        if (DBIQueryTypeServer(pdbi, (ITSM) itsm, &ptpi)) {
            continue;
        }
        if (!ptpi) {

            PDBOpenTpi(ppdb, pdbRead, &ptpi);
            tiMin = TypesQueryTiMinEx(ptpi);
            tiMac = TypesQueryTiMacEx(ptpi);
            if (tiMin < tiMac) {
                return FALSE;
            }
        }
    }
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\sympriv.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    symbolsp.c

Abstract:

    This function implements a generic simple symbol handler.

Author:

    Wesley Witt (wesw) 1-Sep-1994

Environment:

    User Mode

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntldr.h>
#include "private.h"
#include "symbols.h"
#include "tlhelp32.h"

typedef BOOL   (WINAPI *PMODULE32)(HANDLE, LPMODULEENTRY32);
typedef HANDLE (WINAPI *PCREATE32SNAPSHOT)(DWORD, DWORD);

typedef ULONG (NTAPI *PRTLQUERYPROCESSDEBUGINFORMATION)(HANDLE,ULONG,PRTL_DEBUG_INFORMATION);
typedef PRTL_DEBUG_INFORMATION (NTAPI *PRTLCREATEQUERYDEBUGBUFFER)(ULONG,BOOLEAN);
typedef NTSTATUS (NTAPI *PRTLDESTROYQUERYDEBUGBUFFER)(PRTL_DEBUG_INFORMATION);
typedef NTSTATUS (NTAPI *PNTQUERYSYSTEMINFORMATION)(SYSTEM_INFORMATION_CLASS,PVOID,ULONG,PULONG);
typedef ULONG (NTAPI *PRTLNTSTATUSTODOSERROR)(NTSTATUS);
//typedef NTSTATUS (NTAPI *PNTQUERYINFORMATIONPROCESS)(UINT_PTR,PROCESSINFOCLASS,UINT_PTR,ULONG,UINT_PTR);
typedef NTSTATUS (NTAPI *PNTQUERYINFORMATIONPROCESS)(HANDLE,PROCESSINFOCLASS,PVOID,ULONG,PULONG);

DWORD_PTR Win95GetProcessModules(HANDLE, PINTERNAL_GET_MODULE ,PVOID);
DWORD_PTR NTGetProcessModules(HANDLE, PINTERNAL_GET_MODULE ,PVOID);
DWORD64 miGetModuleBase(HANDLE hProcess, DWORD64 Address);

DWORD_PTR
NTGetPID(
    HANDLE hProcess
    )
{
    HMODULE hModule;
    PNTQUERYINFORMATIONPROCESS NtQueryInformationProcess;
    PROCESS_BASIC_INFORMATION pi;
    NTSTATUS status;

    hModule = GetModuleHandle( "ntdll.dll" );
    if (!hModule) {
        return ERROR_MOD_NOT_FOUND;
    }

    NtQueryInformationProcess = (PNTQUERYINFORMATIONPROCESS)GetProcAddress(
        hModule,
        "NtQueryInformationProcess"
        );

    if (!NtQueryInformationProcess) {
        return ERROR_INVALID_FUNCTION;
    }


    status = NtQueryInformationProcess(hProcess,
                                       ProcessBasicInformation,
                                       &pi,
                                       sizeof(pi),
                                       NULL);

    if (!NT_SUCCESS(status))
        return 0;

    return pi.UniqueProcessId;
}


//
// the block bounded by the #ifdef _X86_ statement
// contains the code for getting the PID from an
// HPROCESS when running under Win9X
//

#ifdef _X86_

#define HANDLE_INVALID  	       ((HANDLE)0xFFFFFFFF)
#define HANDLE_CURRENT_PROCESS	 ((HANDLE)0x7FFFFFFF)
#define HANDLE_CURRENT_THREAD    ((HANDLE)0xFFFFFFFE)
#define MAX_HANDLE_VALUE         ((HANDLE)0x00FFFFFF) 


// Thread Information Block.

typedef struct _TIB {

    DWORD     unknown[12];
    DWORD_PTR ppdb;

} TIB, *PTIB;

// Task Data Block

typedef struct _TDB {

    DWORD unknown[2];
    TIB		tib;
    
} TDB, *PTDB;

typedef struct _OBJ {

    BYTE    typObj;             // object type 
    BYTE    objFlags;           // object flags
    WORD    cntUses;            // count of this objects usage

} OBJ, *POBJ;
  
typedef struct _HTE {

    DWORD   flFlags;
    POBJ    pobj;
    
} HTE, *PHTE;

typedef struct _HTB {

    DWORD   chteMax;
    HTE     rghte[1];
    
} HTB, *PHTB;

typedef struct _W9XPDB {

    DWORD  unknown[17];
    PHTB   phtbHandles;

} W9XPDB, *PW9XPDB;

#pragma warning(disable:4035)

_inline struct _TIB * GetCurrentTib(void) { _asm mov eax, fs:[0x18] }

// stuff needed to convert local handle

#define IHTETOHANDLESHIFT  2
#define GLOBALHANDLEMASK  (0x453a4d3cLU)

#define IHTEFROMHANDLE(hnd) ((hnd) == HANDLE_INVALID ? (DWORD)(hnd) : (((DWORD)(hnd)) >> IHTETOHANDLESHIFT))

#define IHTEISGLOBAL(ihte) \
        (((ihte) >> (32 - 8 - IHTETOHANDLESHIFT)) == (((DWORD)GLOBALHANDLEMASK) >> 24))

#define IS_WIN32_PREDEFINED_HANDLE(hnd) \
        ((hnd == HANDLE_CURRENT_PROCESS)||(hnd == HANDLE_CURRENT_THREAD)||(hnd == HANDLE_INVALID))

DWORD
GetWin9xObsfucator(
  VOID
  )
/*++

Routine Description:

  GetWin9xObsfucator()


Arguments:

  none


Return Value:

  Obsfucator key used by Windows9x to hide Process and Thread Id's


Notes:

  The code has only been tested on Windows98SE and Millennium.
  

--*/
{
    DWORD ppdb       = 0;      // W9XPDB = Process Data Block
    DWORD processId  = (DWORD) GetCurrentProcessId();
  
    // get PDB pointer
  
    ppdb = GetCurrentTib()->ppdb;
    
    return ppdb ^ processId;
}


DWORD_PTR
GetPtrFromHandle(
  IN HANDLE Handle
  )
/*++

Routine Description:

  GetPtrFromHandle()


Arguments:

  Handle - handle from Process handle table


Return Value:

  Real Pointer to object


Notes:

  The code has only been tested on Windows98SE and Millennium.
  

--*/
{
    DWORD_PTR ptr  = 0;
    DWORD     ihte = 0;
    PW9XPDB   ppdb = 0;
  
    ppdb = (PW9XPDB) GetCurrentTib()->ppdb;
  
    // check for pre-defined handle values.
  
    if (Handle == HANDLE_CURRENT_PROCESS) {
        ptr = (DWORD_PTR) ppdb;
    } else if (Handle == HANDLE_CURRENT_THREAD) {
        ptr = (DWORD_PTR) CONTAINING_RECORD(GetCurrentTib(), TDB, tib);
    } else if (Handle == HANDLE_INVALID) {
        ptr = 0;
    } else {
        // not a special handle, we can perform our magic.
    
        ihte = IHTEFROMHANDLE(Handle);

        // if we have a global handle, it is only meaningful in the context
        // of the kernel process's handle table...we don't currently deal with
        // this type of handle
    
        if (!(IHTEISGLOBAL(ihte))) {
            ptr = (DWORD_PTR) ppdb->phtbHandles->rghte[ihte].pobj;
        }
    }

    return ptr;
}


DWORD_PTR
Win9xGetPID(
  IN HANDLE hProcess
  )
/*++

Routine Description:

  Win9xGetPid()


Arguments:

  hProcess - Process handle


Return Value:

  Process Id


Notes:

  The code has only been tested on Windows98SE and Millennium.
  

--*/
{
    static DWORD dwObsfucator = 0;

    // check to see that we have a predefined handle or an index into
    // our local handle table.

    if (IS_WIN32_PREDEFINED_HANDLE(hProcess) || (hProcess < MAX_HANDLE_VALUE)) {
        if (!dwObsfucator) {
            dwObsfucator = GetWin9xObsfucator();
            assert(dwObsfucator != 0);
        }
        return dwObsfucator ^ GetPtrFromHandle(hProcess);  
    }

    // don't know what we have here

    return 0;
}

#endif // _X86_


DWORD_PTR
GetPID(
    HANDLE hProcess
    )
{
    OSVERSIONINFO VerInfo;

    if (hProcess == GetCurrentProcess())
        return GetCurrentProcessId();

    VerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&VerInfo);
    if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        return NTGetPID(hProcess);
    } else {
#ifdef _X86_
        return Win9xGetPID(hProcess);
#else
        return 0;
#endif
    }
}


DWORD
GetProcessModules(
    HANDLE                  hProcess,
    PINTERNAL_GET_MODULE    InternalGetModule,
    PVOID                   Context
    )
{
#ifdef _X86_
    OSVERSIONINFO VerInfo;

    VerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&VerInfo);
    if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        return NTGetProcessModules(hProcess, InternalGetModule, Context);
    } else {
        return Win95GetProcessModules(hProcess, InternalGetModule, Context);
    }
}


DWORD
Win95GetProcessModules(
    HANDLE                  hProcess,
    PINTERNAL_GET_MODULE    InternalGetModule,
    PVOID                   Context
    )
{
    MODULEENTRY32 ModuleEntry;
    PMODULE32     pModule32Next, pModule32First;
    PCREATE32SNAPSHOT pCreateToolhelp32Snapshot;
    HANDLE hSnapshot;
    HMODULE hToolHelp;
    DWORD pid;

    // get the PID:
    // this hack supports old bug workaround, in which callers were passing
    // a pid, because an hprocess didn't work on W9X.

    pid = GetPID(hProcess);
    if (!pid)
        pid = (DWORD)hProcess;

    // get the module list from toolhelp apis

    hToolHelp = GetModuleHandle("kernel32.dll");
    if (!hToolHelp)
        return ERROR_MOD_NOT_FOUND;

    pModule32Next = (PMODULE32)GetProcAddress(hToolHelp, "Module32Next");
    pModule32First = (PMODULE32)GetProcAddress(hToolHelp, "Module32First");
    pCreateToolhelp32Snapshot = (PCREATE32SNAPSHOT)GetProcAddress(hToolHelp, "CreateToolhelp32Snapshot");
    if (!pModule32Next || !pModule32First || !pCreateToolhelp32Snapshot)
        return ERROR_MOD_NOT_FOUND;

    hSnapshot = pCreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pid); 
    if (hSnapshot == (HANDLE)-1) {
        return ERROR_MOD_NOT_FOUND;
    }

    ModuleEntry.dwSize = sizeof(MODULEENTRY32);

    if (pModule32First(hSnapshot, &ModuleEntry)) {
        do
        {
            if (!InternalGetModule(
                    hProcess,
                    ModuleEntry.szModule,
                    (DWORD) ModuleEntry.modBaseAddr,
                    ModuleEntry.modBaseSize,
                    Context))
            {
                break;
            }

        } while ( pModule32Next(hSnapshot, &ModuleEntry) );
    }

    CloseHandle(hSnapshot);

    return(ERROR_SUCCESS);
}


DWORD
NTGetProcessModules(
    HANDLE                  hProcess,
    PINTERNAL_GET_MODULE    InternalGetModule,
    PVOID                   Context
    )
{

#endif      // _X86_

    PRTLQUERYPROCESSDEBUGINFORMATION    RtlQueryProcessDebugInformation;
    PRTLCREATEQUERYDEBUGBUFFER          RtlCreateQueryDebugBuffer;
    PRTLDESTROYQUERYDEBUGBUFFER         RtlDestroyQueryDebugBuffer;
    HMODULE                             hModule;
    NTSTATUS                            Status;
    PRTL_DEBUG_INFORMATION              Buffer;
    ULONG                               i;
    DWORD_PTR                           ProcessId;

    hModule = GetModuleHandle( "ntdll.dll" );
    if (!hModule) {
        return ERROR_MOD_NOT_FOUND;
    }

    RtlQueryProcessDebugInformation = (PRTLQUERYPROCESSDEBUGINFORMATION)GetProcAddress(
        hModule,
        "RtlQueryProcessDebugInformation"
        );

    if (!RtlQueryProcessDebugInformation) {
        return ERROR_INVALID_FUNCTION;
    }

    RtlCreateQueryDebugBuffer = (PRTLCREATEQUERYDEBUGBUFFER)GetProcAddress(
        hModule,
        "RtlCreateQueryDebugBuffer"
        );

    if (!RtlCreateQueryDebugBuffer) {
        return ERROR_INVALID_FUNCTION;
    }

    RtlDestroyQueryDebugBuffer = (PRTLDESTROYQUERYDEBUGBUFFER)GetProcAddress(
        hModule,
        "RtlDestroyQueryDebugBuffer"
        );

    if (!RtlDestroyQueryDebugBuffer) {
        return ERROR_INVALID_FUNCTION;
    }

    Buffer = RtlCreateQueryDebugBuffer( 0, FALSE );
    if (!Buffer) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ProcessId = GetPID(hProcess);

    // for backwards compatibility with an old bug
    if (!ProcessId)
        ProcessId = (DWORD_PTR)hProcess;

    Status = RtlQueryProcessDebugInformation(
        (HANDLE)ProcessId,
        RTL_QUERY_PROCESS_MODULES,
        Buffer
        );

    if (Status != STATUS_SUCCESS) {
        RtlDestroyQueryDebugBuffer( Buffer );
        return(ImagepSetLastErrorFromStatus(Status));
    }

    for (i=0; i<Buffer->Modules->NumberOfModules; i++) {
        PRTL_PROCESS_MODULE_INFORMATION Module = &Buffer->Modules->Modules[i];
        if (!InternalGetModule(
                hProcess,
                (LPSTR) &Module->FullPathName[Module->OffsetToFileName],
                (DWORD64)Module->ImageBase,
                (DWORD)Module->ImageSize,
                Context
                ))
        {
            break;
        }
    }

    RtlDestroyQueryDebugBuffer( Buffer );
    return ERROR_SUCCESS;
}


VOID
FreeModuleEntry(
    PMODULE_ENTRY ModuleEntry
    )
{
    if (ModuleEntry->symbolTable) {
        MemFree( ModuleEntry->symbolTable  );
    }
    if (ModuleEntry->SymType == SymPdb) {
        TPI *tpi;
        if ( ModuleEntry->ptpi ) {
            TypesClose(ModuleEntry->ptpi);
        } else if (PDBOpenTpi(ModuleEntry->pdb, pdbRead, &tpi)){
            TypesClose(tpi);
        }
        GSIClose( ModuleEntry->globals );
        GSIClose( ModuleEntry->gsi );
        DBIClose( ModuleEntry->dbi );
        PDBClose( ModuleEntry->pdb );
    }
    if (ModuleEntry->SectionHdrs) {
        MemFree( ModuleEntry->SectionHdrs );
    }
    if (ModuleEntry->OriginalSectionHdrs) {
        MemFree( ModuleEntry->OriginalSectionHdrs );
    }
    if (ModuleEntry->pFpoData) {
        VirtualFree( ModuleEntry->pFpoData, 0, MEM_RELEASE );
    }
    if (ModuleEntry->pExceptionData) {
        VirtualFree( ModuleEntry->pExceptionData, 0, MEM_RELEASE );
    }
    if (ModuleEntry->TmpSym.Name) {
        MemFree( ModuleEntry->TmpSym.Name );
    }
    if (ModuleEntry->ImageName) {
        MemFree( ModuleEntry->ImageName );
    }
    if (ModuleEntry->LoadedImageName) {
        MemFree( ModuleEntry->LoadedImageName );
    }
    if (ModuleEntry->pOmapTo) {
        MemFree( ModuleEntry->pOmapTo );
    }
    if (ModuleEntry->pOmapFrom) {
        MemFree( ModuleEntry->pOmapFrom );
    }
    if (ModuleEntry->SourceFiles) {
        PSOURCE_ENTRY Src, SrcNext;

        for (Src = ModuleEntry->SourceFiles; Src != NULL; Src = SrcNext) {
            SrcNext = Src->Next;
            MemFree(Src);
        }
    }
    MemFree( ModuleEntry );
}




BOOL __inline
MatchSymbolName(
    PSYMBOL_ENTRY       sym,
    LPSTR               SymName
    )
{
    if (SymOptions & SYMOPT_CASE_INSENSITIVE) {
        if (_stricmp( sym->Name, SymName ) == 0) {
            return TRUE;
        }
    } else {
        if (strcmp( sym->Name, SymName ) == 0) {
            return TRUE;
        }
    }

    return FALSE;
}


PSYMBOL_ENTRY
HandleDuplicateSymbols(
    PPROCESS_ENTRY  ProcessEntry,
    PMODULE_ENTRY   mi,
    PSYMBOL_ENTRY   sym
    )
{
    DWORD                       i;
    DWORD                       Dups;
    DWORD                       NameSize;
    PIMAGEHLP_SYMBOL64          Syms64 = NULL;
    PIMAGEHLP_SYMBOL          Syms32 = NULL;
    PIMAGEHLP_DUPLICATE_SYMBOL64 DupSym64 = NULL;
    PIMAGEHLP_DUPLICATE_SYMBOL DupSym32 = NULL;
    PULONG                      SymSave;


    if (!ProcessEntry->pCallbackFunction32 && !ProcessEntry->pCallbackFunction64) {
        return sym;
    }

    if (!(sym->Flags & SYMF_DUPLICATE)) {
        return sym;
    }

    Dups = 0;
    NameSize = 0;
    for (i = 0; i < mi->numsyms; i++) {
        if ((mi->symbolTable[i].NameLength == sym->NameLength) &&
            (strcmp( mi->symbolTable[i].Name, sym->Name ) == 0)) {
                Dups += 1;
                NameSize += (mi->symbolTable[i].NameLength + 1);
        }
    }

    if (ProcessEntry->pCallbackFunction32) {
        DupSym32 = (PIMAGEHLP_DUPLICATE_SYMBOL) MemAlloc( sizeof(IMAGEHLP_DUPLICATE_SYMBOL) );
        if (!DupSym32) {
            return sym;
        }

        Syms32 = (PIMAGEHLP_SYMBOL) MemAlloc( (sizeof(IMAGEHLP_SYMBOL) * Dups) + NameSize );
        if (!Syms32) {
            MemFree( DupSym32 );
            return sym;
        }

        SymSave = (PULONG) MemAlloc( sizeof(ULONG) * Dups );
        if (!SymSave) {
            MemFree( Syms32 );
            MemFree( DupSym32 );
            return sym;
        }

        DupSym32->SizeOfStruct    = sizeof(IMAGEHLP_DUPLICATE_SYMBOL);
        DupSym32->NumberOfDups    = Dups;
        DupSym32->Symbol          = Syms32;
        DupSym32->SelectedSymbol  = (ULONG) -1;

        Dups = 0;
        for (i = 0; i < mi->numsyms; i++) {
            if ((mi->symbolTable[i].NameLength == sym->NameLength) &&
                (strcmp( mi->symbolTable[i].Name, sym->Name ) == 0)) {
                    symcpy32( Syms32, &mi->symbolTable[i] );
                    Syms32 += (sizeof(IMAGEHLP_SYMBOL) + mi->symbolTable[i].NameLength + 1);
                    SymSave[Dups] = i;
                    Dups += 1;
            }
        }

    } else {
        DupSym64 = (PIMAGEHLP_DUPLICATE_SYMBOL64) MemAlloc( sizeof(IMAGEHLP_DUPLICATE_SYMBOL64) );
        if (!DupSym64) {
            return sym;
        }

        Syms64 = (PIMAGEHLP_SYMBOL64) MemAlloc( (sizeof(IMAGEHLP_SYMBOL64) * Dups) + NameSize );
        if (!Syms64) {
            MemFree( DupSym64 );
            return sym;
        }

        SymSave = (PULONG) MemAlloc( sizeof(ULONG) * Dups );
        if (!SymSave) {
            MemFree( Syms64 );
            MemFree( DupSym64 );
            return sym;
        }

        DupSym64->SizeOfStruct    = sizeof(IMAGEHLP_DUPLICATE_SYMBOL64);
        DupSym64->NumberOfDups    = Dups;
        DupSym64->Symbol          = Syms64;
        DupSym64->SelectedSymbol  = (ULONG) -1;

        Dups = 0;
        for (i = 0; i < mi->numsyms; i++) {
            if ((mi->symbolTable[i].NameLength == sym->NameLength) &&
                (strcmp( mi->symbolTable[i].Name, sym->Name ) == 0)) {
                    symcpy64( Syms64, &mi->symbolTable[i] );
                    Syms64 += (sizeof(IMAGEHLP_SYMBOL64) + mi->symbolTable[i].NameLength + 1);
                    SymSave[Dups] = i;
                    Dups += 1;
            }
        }

    }

    sym = NULL;

    __try {

        if (ProcessEntry->pCallbackFunction32) {
            ProcessEntry->pCallbackFunction32(
                ProcessEntry->hProcess,
                CBA_DUPLICATE_SYMBOL,
                (PVOID) DupSym32,
                (PVOID) ProcessEntry->CallbackUserContext
                );

            if (DupSym32->SelectedSymbol != (ULONG) -1) {
                if (DupSym32->SelectedSymbol < DupSym32->NumberOfDups) {
                    sym = &mi->symbolTable[SymSave[DupSym32->SelectedSymbol]];
                }
            }
        } else {
            ProcessEntry->pCallbackFunction64(
                ProcessEntry->hProcess,
                CBA_DUPLICATE_SYMBOL,
                (ULONG64) &DupSym64,
                ProcessEntry->CallbackUserContext
                );

            if (DupSym64->SelectedSymbol != (ULONG) -1) {
                if (DupSym64->SelectedSymbol < DupSym64->NumberOfDups) {
                    sym = &mi->symbolTable[SymSave[DupSym64->SelectedSymbol]];
                }
            }
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        ;
    }

    if (DupSym32) {
        MemFree( DupSym32 );
    }
    if (DupSym64) {
        MemFree( DupSym64 );
    }
    if (Syms32) {
        MemFree( Syms32 );
    }
    if (Syms64) {
        MemFree( Syms64 );
    }
    MemFree( SymSave );

    return sym;
}


PSYMBOL_ENTRY
FindSymbolByName(
    PPROCESS_ENTRY  ProcessEntry,
    PMODULE_ENTRY   mi,
    LPSTR           SymName
    )
{
    DWORD               Hash;
    PSYMBOL_ENTRY       sym;
    DWORD               i;
    LPSTR               name;
    LPSTR               p;
    int                 rslt;

    if (mi->SymType == SymPdb) {
        DATASYM32 *dataSym = (DATASYM32*)GSINextSym( mi->gsi, NULL );
        PIMAGE_SECTION_HEADER sh;
        DWORD64 addr;
        ULONG k;
        LPSTR PdbSymbolName;
        UCHAR PdbSymbolLen;
        while( dataSym ) {
            PdbSymbolName = DataSymNameStart(dataSym);
            PdbSymbolLen  = DataSymNameLength(dataSym);
            addr = 0;
            k = DataSymSeg(dataSym);

            if ((k <= mi->OriginalNumSections)) {
                addr = mi->OriginalSectionHdrs[k-1].VirtualAddress + DataSymOffset(dataSym) + mi->BaseOfDll;

                if (SymOptions & SYMOPT_UNDNAME) {
                    SymUnDNameInternal( mi->TmpSym.Name, TMP_SYM_LEN-sizeof(mi->TmpSym), PdbSymbolName, PdbSymbolLen );
                } else {
                    mi->TmpSym.Name[0] = 0;
                    strncat( mi->TmpSym.Name, PdbSymbolName, __min(PdbSymbolLen, TMP_SYM_LEN-sizeof(mi->TmpSym)) );
                }
                if (SymOptions & SYMOPT_CASE_INSENSITIVE) {
                    rslt = _stricmp( mi->TmpSym.Name, SymName );
                } else {
                    rslt = strcmp( mi->TmpSym.Name, SymName );
                }
                if (rslt == 0) {
                    DWORD Bias;

                    addr = ConvertOmapFromSrc( mi, addr, &Bias );

                    if (addr != 0) {
                        addr += Bias;
                    }

                    mi->TmpSym.Size = 0;
                    mi->TmpSym.Flags = 0;
                    mi->TmpSym.Address = addr;
                    mi->TmpSym.NameLength = 0;

                    return &mi->TmpSym;
                }
            }
            dataSym = (DATASYM32*)GSINextSym( mi->gsi, (PUCHAR)dataSym );
        }
        return NULL;
    }

    Hash = ComputeHash( SymName, strlen(SymName) );
    sym = mi->NameHashTable[Hash];

    if (sym) {
        //
        // there are collision(s) so lets walk the
        // collision list and match the names
        //
        while( sym ) {
            if (MatchSymbolName( sym, SymName )) {
                sym = HandleDuplicateSymbols( ProcessEntry, mi, sym );
                return sym;
            }
            sym = sym->Next;
        }
    }

    //
    // the symbol did not hash to anything valid
    // this is possible if the caller passed an undecorated name
    // now we must look linearly thru the list
    //
    for (i=0; i<mi->numsyms; i++) {
        sym = &mi->symbolTable[i];
        if (MatchSymbolName( sym, SymName )) {
            sym = HandleDuplicateSymbols( ProcessEntry, mi, sym );
            return sym;
        }
    }

    return NULL;
}


IMGHLP_RVA_FUNCTION_DATA *
SearchRvaFunctionTable(
    IMGHLP_RVA_FUNCTION_DATA *FunctionTable,
    LONG High,
    LONG Low,
    DWORD dwPC
    )
{
    LONG    Middle;
    IMGHLP_RVA_FUNCTION_DATA *FunctionEntry;

    // Perform binary search on the function table for a function table
    // entry that subsumes the specified PC.

    while (High >= Low) {

        // Compute next probe index and test entry. If the specified PC
        // is greater than of equal to the beginning address and less
        // than the ending address of the function table entry, then
        // return the address of the function table entry. Otherwise,
        // continue the search.

        Middle = (Low + High) >> 1;
        FunctionEntry = &FunctionTable[Middle];
        if (dwPC < FunctionEntry->rvaBeginAddress) {
            High = Middle - 1;

        } else if (dwPC >= FunctionEntry->rvaEndAddress) {
            Low = Middle + 1;

        } else {
            return FunctionEntry;
        }
    }
    return NULL;
}

PIMAGE_FUNCTION_ENTRY
LookupFunctionEntryAxp32 (
    PMODULE_ENTRY mi,
    DWORD         ControlPc
    )
{
    IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY *FunctionEntry;
    static IMAGE_FUNCTION_ENTRY ife;

    // Don't specify the function table access callback or it will cause recursion. 

    FunctionEntry = LookupFunctionEntry(mi->hProcess, ControlPc, ReadInProcMemory, miGetModuleBase, NULL, FALSE );
    
    if (!FunctionEntry)
        return NULL;

    ife.StartingAddress = (ULONG)FunctionEntry->BeginAddress;
    ife.EndingAddress   = (ULONG)FunctionEntry->EndAddress;
    ife.EndOfPrologue   = (ULONG)FunctionEntry->PrologEndAddress;

    return &ife;
} // LookupFunctionEntryAxp32()


PIMAGE_FUNCTION_ENTRY64
LookupFunctionEntryAxp64 (
    PMODULE_ENTRY mi,
    DWORD64       ControlPc
    )
{
    IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY *FunctionEntry;
    static IMAGE_FUNCTION_ENTRY64 ife64;

    // Don't specify the function table access callback or it will cause recursion. 

    FunctionEntry = LookupFunctionEntry(mi->hProcess, ControlPc, ReadInProcMemory, miGetModuleBase, NULL, TRUE );
    
    if (!FunctionEntry == 0)
        return NULL;

    ife64.StartingAddress = FunctionEntry->BeginAddress;
    ife64.EndingAddress   = FunctionEntry->EndAddress;
    ife64.EndOfPrologue   = FunctionEntry->PrologEndAddress;

    return &ife64;

} // LookupFunctionEntryAxp64()

PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY
GetAlphaFunctionEntryFromDebugInfo (
    PPROCESS_ENTRY  ProcessEntry,
    DWORD64         ControlPc
    )
{
    PMODULE_ENTRY mi;
    IMGHLP_RVA_FUNCTION_DATA   *FunctionTable;
    IMGHLP_RVA_FUNCTION_DATA   *FunctionEntry;
    static IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY rfe64;

    mi = GetModuleForPC( ProcessEntry, ControlPc, FALSE );
    if (mi == NULL) {
        return NULL;
    }

    if (!GetPData(ProcessEntry->hProcess, mi))
        return NULL;

    FunctionTable = (IMGHLP_RVA_FUNCTION_DATA *)mi->pExceptionData;
    FunctionEntry = SearchRvaFunctionTable(FunctionTable, mi->dwEntries - 1, 0, (ULONG)(ControlPc - mi->BaseOfDll));
    
    if (!FunctionEntry) {
        return NULL;
    }
    
    rfe64.BeginAddress      = mi->BaseOfDll + FunctionEntry->rvaBeginAddress;
    rfe64.EndAddress        = mi->BaseOfDll + FunctionEntry->rvaEndAddress;
    rfe64.ExceptionHandler  = 0;
    rfe64.HandlerData       = 0;
    rfe64.PrologEndAddress  = mi->BaseOfDll + FunctionEntry->rvaPrologEndAddress;

    return &rfe64;
}

PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY
LookupFunctionEntryIA64 (
    PMODULE_ENTRY mi,
    DWORD         ControlPc
    )
{
    IMGHLP_RVA_FUNCTION_DATA   *FunctionTable;
    IMGHLP_RVA_FUNCTION_DATA   *FunctionEntry;
    static IMAGE_IA64_RUNTIME_FUNCTION_ENTRY irfe;

// TF-FIXFIX
if (!GetPData(NULL, mi))
   return NULL;

    FunctionTable = (IMGHLP_RVA_FUNCTION_DATA *)mi->pExceptionData;
    FunctionEntry = SearchRvaFunctionTable(FunctionTable, mi->dwEntries - 1, 0, ControlPc);

    if (!FunctionEntry) {
        return NULL;
    }

    irfe.BeginAddress      = FunctionEntry->rvaBeginAddress;
    irfe.EndAddress        = FunctionEntry->rvaEndAddress;
    irfe.UnwindInfoAddress = FunctionEntry->rvaPrologEndAddress;

    return &irfe;

} // LookupFunctionEntryIA64()

PFPO_DATA
SwSearchFpoData(
    DWORD     key,
    PFPO_DATA base,
    DWORD     num
    )
{
    PFPO_DATA  lo = base;
    PFPO_DATA  hi = base + (num - 1);
    PFPO_DATA  mid;
    DWORD      half;

    while (lo <= hi) {
        if (half = num / 2) {
            mid = lo + ((num & 1) ? half : (half - 1));
            if ((key >= mid->ulOffStart)&&(key < (mid->ulOffStart+mid->cbProcSize))) {
                return mid;
            }
            if (key < mid->ulOffStart) {
                hi = mid - 1;
                num = (num & 1) ? half : half-1;
            } else {
                lo = mid + 1;
                num = half;
            }
        } else
        if (num) {
            if ((key >= lo->ulOffStart)&&(key < (lo->ulOffStart+lo->cbProcSize))) {
                return lo;
            } else {
                break;
            }
        } else {
            break;
        }
    }
    return(NULL);
}

BOOL
DoSymbolCallback (
    PPROCESS_ENTRY                  ProcessEntry,
    ULONG                           CallbackType,
    IN  PMODULE_ENTRY               mi,
    PIMAGEHLP_DEFERRED_SYMBOL_LOAD64 idsl64,
    LPSTR                           FileName
    )
{
    BOOL Status;
    IMAGEHLP_DEFERRED_SYMBOL_LOAD idsl32;

    Status = FALSE;
    if (ProcessEntry->pCallbackFunction32) {
        idsl32.SizeOfStruct  = sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOAD);
        idsl32.BaseOfImage   = (ULONG)mi->BaseOfDll;
        idsl32.CheckSum      = mi->CheckSum;
        idsl32.TimeDateStamp = mi->TimeDateStamp;
        idsl32.Reparse       = FALSE;
        idsl32.FileName[0] = 0;
        if (FileName) {
            strncat( idsl32.FileName, FileName, MAX_PATH );
        }

        __try {

            Status = ProcessEntry->pCallbackFunction32(
                        ProcessEntry->hProcess,
                        CallbackType,
                        (PVOID)&idsl32,
                        (PVOID)ProcessEntry->CallbackUserContext
                        );
            idsl64->SizeOfStruct = sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOAD64);
            idsl64->BaseOfImage = idsl32.BaseOfImage;
            idsl64->CheckSum = idsl32.CheckSum;
            idsl64->TimeDateStamp = idsl32.TimeDateStamp;
            idsl64->Reparse = idsl32.Reparse;
            if (idsl32.FileName) {
                strncpy( idsl64->FileName, idsl32.FileName, MAX_PATH );
            }

        } __except (EXCEPTION_EXECUTE_HANDLER) {
        }
    } else
    if (ProcessEntry->pCallbackFunction64) {
        idsl64->SizeOfStruct  = sizeof(IMAGEHLP_DEFERRED_SYMBOL_LOAD64);
        idsl64->BaseOfImage   = mi->BaseOfDll;
        idsl64->CheckSum      = mi->CheckSum;
        idsl64->TimeDateStamp = mi->TimeDateStamp;
        idsl64->Reparse       = FALSE;
        idsl64->FileName[0] = 0;
        if (FileName) {
            strncat( idsl64->FileName, FileName, MAX_PATH );
        }

        __try {

            Status = ProcessEntry->pCallbackFunction64(
                        ProcessEntry->hProcess,
                        CallbackType,
                        (ULONG64)(ULONG_PTR)idsl64,
                        ProcessEntry->CallbackUserContext
                        );

        } __except (EXCEPTION_EXECUTE_HANDLER) {
        }
    }

    return Status;
}

VOID
SympSendDebugString(
    PPROCESS_ENTRY ProcessEntry,
    LPSTR          String
    )
{
    DWORD Status;
    __try {
        if (!ProcessEntry) 
            ProcessEntry = FindFirstProcessEntry();
        if (!ProcessEntry)
            return;
        
        if (ProcessEntry->pCallbackFunction32) {
            Status = ProcessEntry->pCallbackFunction32(
                        ProcessEntry->hProcess,
                        CBA_DEBUG_INFO,
                        (PVOID)String,
                        (PVOID)ProcessEntry->CallbackUserContext
                        );
        } else
        if (ProcessEntry->pCallbackFunction64) {
            Status = ProcessEntry->pCallbackFunction64(
                        ProcessEntry->hProcess,
                        CBA_DEBUG_INFO,
                        (ULONG64)String,
                        ProcessEntry->CallbackUserContext
                        );

        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
    }
}

int
WINAPIV
SympDprintf(
    PPROCESS_ENTRY ProcessEntry,
    LPSTR Format,
    ...
    )
{
    static char buf[1000] = "DBGHELP: ";
    va_list args;

    va_start(args, Format);
    _vsnprintf(buf+9, sizeof(buf)-9, Format, args);
    va_end(args);
    SympSendDebugString(ProcessEntry, buf);
    return 1;
}

int
WINAPIV
SympEprintf(
    PPROCESS_ENTRY ProcessEntry,
    LPSTR Format,
    ...
    )
{
    static char buf[1000] = "";
    va_list args;

    va_start(args, Format);
    _vsnprintf(buf, sizeof(buf), Format, args);
    va_end(args);
    SympSendDebugString(ProcessEntry, buf);
    return 1;
}


BOOL
CompleteDeferredSymbolLoad(
    IN  HANDLE          hProcess,
    IN  PMODULE_ENTRY   mi
    )
{
    IMAGEHLP_DEFERRED_SYMBOL_LOAD64 idsl;
    PPROCESS_ENTRY              ProcessEntry;
    ULONG                       i;
    PIMGHLP_DEBUG_DATA          pIDD;
    ULONG                       bias;
    PIMAGE_SYMBOL               lpSymbolEntry;
    PUCHAR                      lpStringTable;
    PUCHAR                      p;
    BOOL                        SymbolsLoaded = FALSE;
    PUCHAR                      CallbackFileName, ImageName;
    ULONG                       Size;

    ProcessEntry = FindProcessEntry( hProcess );
    if (!ProcessEntry) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    CallbackFileName   = mi->LoadedImageName ? mi->LoadedImageName :
                                mi->ImageName ? mi->ImageName : mi->ModuleName;

    DoSymbolCallback(
        ProcessEntry,
        CBA_DEFERRED_SYMBOL_LOAD_START,
        mi,
        &idsl,
        CallbackFileName
        );

    ImageName = mi->ImageName;
    for (; ;) {
        pIDD = ImgHlpFindDebugInfo(
            hProcess,
            mi->hFile,
            ImageName,
            ProcessEntry->SymbolSearchPath,
            mi->BaseOfDll,
            0
            );

        if (pIDD) {
            break;
        }

        DPRINTF(ProcessEntry, "ImgHlpFindDebugInfo(%p, %s, %s, %I64x, 0) failed\n",
            mi->hFile,
            ImageName,
            ProcessEntry->SymbolSearchPath,
            mi->BaseOfDll
            );

        if (!DoSymbolCallback(
                 ProcessEntry,
                 CBA_DEFERRED_SYMBOL_LOAD_FAILURE,
                 mi,
                 &idsl,
                 CallbackFileName
                 ) || !idsl.Reparse) {
            mi->SymType = SymNone;
            mi->Flags |= MIF_NO_SYMBOLS;
            return FALSE;
        }

        ImageName = idsl.FileName;
        CallbackFileName = idsl.FileName;
    }

    // The following code ONLY works if the dll wasn't rebased
    // during install.  Is it really useful?

    if (!mi->BaseOfDll) {
        //
        // This case occurs when modules are loaded multiple times by
        // name with no explicit base address.
        //
        if (GetModuleForPC( ProcessEntry, pIDD->ImageBaseFromImage, TRUE )) {
            if (pIDD->ImageBaseFromImage) {
                DPRINTF(ProcessEntry, "GetModuleForPC(%p, %I64x, TRUE) failed\n",
                    ProcessEntry,
                    pIDD->ImageBaseFromImage,
                    TRUE
                    );
            } else {
                DPRINTF(ProcessEntry, "No base address for %s:  Please specify\n", ImageName);
            }
            return FALSE;
        }
        mi->BaseOfDll    = pIDD->ImageBaseFromImage;
    }

    if (!mi->DllSize) {
        mi->DllSize      = pIDD->SizeOfImage;
    }

    mi->hProcess         = pIDD->hProcess;
    mi->InProcImageBase  = pIDD->InProcImageBase;

    mi->CheckSum         = pIDD->CheckSum;
    mi->TimeDateStamp    = pIDD->TimeDateStamp;
    mi->MachineType      = pIDD->Machine;
    if (pIDD->DbgFileMap) {
        mi->LoadedImageName = StringDup(pIDD->DbgFilePath);
    } else if (*pIDD->ImageFilePath) {
        mi->LoadedImageName = StringDup(pIDD->ImageFilePath);
    } else if (pIDD->pPdb) {
        mi->LoadedImageName = StringDup(pIDD->PdbFileName);
    } else {
        mi->LoadedImageName = StringDup("");
    }

    if (pIDD->fROM) {
        mi->Flags |= MIF_ROM_IMAGE;
    }

    if (!mi->ImageName) {
        mi->ImageName = StringDup(pIDD->OriginalImageFileName);
        _splitpath( mi->ImageName, NULL, NULL, mi->ModuleName, NULL );
        mi->AliasName[0] = 0;
    }

    mi->dsExceptions = pIDD->dsExceptions;

    if (pIDD->cFpo) {
        //
        // use virtualalloc() because the rtf search function
        // return a pointer into this memory.  we want to make
        // all of this memory read only so that callers cannot
        // stomp on imagehlp's data
        //
        mi->pFpoData = VirtualAlloc(
            NULL,
            sizeof(FPO_DATA) * pIDD->cFpo,
            MEM_COMMIT,
            PAGE_READWRITE
            );
        if (mi->pFpoData) {
            mi->dwEntries = pIDD->cFpo;
            CopyMemory(
                mi->pFpoData,
                pIDD->pFpo,
                sizeof(FPO_DATA) * mi->dwEntries
                );
            VirtualProtect(
                mi->pFpoData,
                sizeof(FPO_DATA) * mi->dwEntries,
                PAGE_READONLY,
                &i
                );
        }
    }

    mi->NumSections = pIDD->cCurrentSections;
    if (pIDD->fCurrentSectionsMapped) {
        mi->SectionHdrs = (PIMAGE_SECTION_HEADER) MemAlloc(
            sizeof(IMAGE_SECTION_HEADER) * mi->NumSections
            );
        if (mi->SectionHdrs) {
            CopyMemory(
                mi->SectionHdrs,
                pIDD->pCurrentSections,
                sizeof(IMAGE_SECTION_HEADER) * mi->NumSections
                );
        }
    } else {
        mi->SectionHdrs = pIDD->pCurrentSections;
    }

    if (pIDD->pOriginalSections) {
        mi->OriginalNumSections = pIDD->cOriginalSections;
        mi->OriginalSectionHdrs = pIDD->pOriginalSections;
    } else {
        mi->OriginalNumSections = mi->NumSections;
        mi->OriginalSectionHdrs = (PIMAGE_SECTION_HEADER) MemAlloc(
            sizeof(IMAGE_SECTION_HEADER) * mi->NumSections
            );
        if (mi->OriginalSectionHdrs) {
            CopyMemory(
                mi->OriginalSectionHdrs,
                pIDD->pCurrentSections,
                sizeof(IMAGE_SECTION_HEADER) * mi->NumSections
                );
        }
    }

    mi->TmpSym.Name = (LPSTR) MemAlloc( TMP_SYM_LEN );

    if (pIDD->pPdb) {
        mi->pdb = pIDD->pPdb;
        mi->dbi = pIDD->pDbi;
        mi->gsi = pIDD->pGsi;
        PDBOpenTpi(pIDD->pPdb, pdbRead, (TPI **) &mi->ptpi);
        if (mi->dbi) 
           DBIOpenGlobals((DBI *) mi->dbi, (GSI **) &mi->globals);
        else
           mi->globals = NULL;
        mi->SymType = SymPdb;
        SymbolsLoaded = TRUE;
    } else {
        if (pIDD->pMappedCv) {
            SymbolsLoaded = LoadCodeViewSymbols(
                hProcess,
                mi,
                pIDD
                );
            DPRINTF(ProcessEntry, "codeview symbols %sloaded\n", SymbolsLoaded?"":"not ");
        }
        if (!SymbolsLoaded && pIDD->pMappedCoff) {
            SymbolsLoaded = LoadCoffSymbols(hProcess, mi, pIDD);
            DPRINTF(ProcessEntry, "coff symbols %sloaded\n", SymbolsLoaded?"":"not ");
        }

        if (!SymbolsLoaded && pIDD->pMappedExportDirectory) {
            SymbolsLoaded = LoadExportSymbols( mi, pIDD );
            DPRINTF(ProcessEntry, "export symbols %sloaded\n", SymbolsLoaded?"":"not ");
        }

        if (!SymbolsLoaded) {
            mi->SymType = SymNone;
            DPRINTF(ProcessEntry, "no symbols loaded\n");
        }
    }

    ProcessOmapForModule( mi, pIDD );

    ImgHlpReleaseDebugInfo( pIDD, IMGHLP_FREE_FPO | IMGHLP_FREE_SYMPATH );
    mi->Flags &= ~MIF_DEFERRED_LOAD;

    DoSymbolCallback(
        ProcessEntry,
        CBA_DEFERRED_SYMBOL_LOAD_COMPLETE,
        mi,
        &idsl,
        CallbackFileName
        );

    return TRUE;
}


DWORD64
InternalLoadModule(
    IN  HANDLE          hProcess,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD64         BaseOfDll,
    IN  DWORD           DllSize,
    IN  HANDLE          hFile
    )
{
    IMAGEHLP_DEFERRED_SYMBOL_LOAD64 idsl;
    PPROCESS_ENTRY              ProcessEntry;
    PMODULE_ENTRY               mi;
    LPSTR                       p;

    ProcessEntry = FindProcessEntry( hProcess );
    if (!ProcessEntry) {
        return 0;
    }

    if (BaseOfDll) {
        mi = GetModuleForPC( ProcessEntry, BaseOfDll, TRUE );
    } else {
        mi = NULL;
    }

    if (mi) {
        //
        // in this case the symbols are already loaded
        // so the caller really wants the deferred
        // symbols to be loaded
        //
        if ( (mi->Flags & MIF_DEFERRED_LOAD) &&
                CompleteDeferredSymbolLoad( hProcess, mi )) {

            return mi->BaseOfDll;
        } else {
            return 0;
        }
    }

    //
    // look to see if there is an overlapping module entry
    //
    if (BaseOfDll) {
        do {
            mi = GetModuleForPC( ProcessEntry, BaseOfDll, FALSE );
            if (mi) {
                RemoveEntryList( &mi->ListEntry );

                DoSymbolCallback(
                    ProcessEntry,
                    CBA_SYMBOLS_UNLOADED,
                    mi,
                    &idsl,
                    mi->LoadedImageName ? mi->LoadedImageName : mi->ImageName ? mi->ImageName : mi->ModuleName
                    );

                FreeModuleEntry( mi );
            }
        } while( mi );
    }

    mi = (PMODULE_ENTRY) MemAlloc( sizeof(MODULE_ENTRY) );
    if (!mi) {
        return 0;
    }
    ZeroMemory( mi, sizeof(MODULE_ENTRY) );

    mi->BaseOfDll = BaseOfDll;
    mi->DllSize = DllSize;
    mi->hFile = hFile;
    if (ImageName) {
        mi->ImageName = StringDup(ImageName);
        _splitpath( ImageName, NULL, NULL, mi->ModuleName, NULL );
        if (ModuleName && _stricmp( ModuleName, mi->ModuleName ) != 0) {
            strcpy( mi->AliasName, ModuleName );
        } else {
            mi->AliasName[0] = 0;
        }
    } else {

        if (ModuleName) {
            strcpy( mi->AliasName, ModuleName );
        }

    }

    if ((SymOptions & SYMOPT_DEFERRED_LOADS) && BaseOfDll) {
        mi->Flags |= MIF_DEFERRED_LOAD;
        mi->SymType = SymDeferred;
    } else if (!CompleteDeferredSymbolLoad( hProcess, mi )) {
        FreeModuleEntry( mi );
        return 0;
    }

    ProcessEntry->Count += 1;

    InsertTailList( &ProcessEntry->ModuleList, &mi->ListEntry);

    return mi->BaseOfDll;
}

PPROCESS_ENTRY
FindProcessEntry(
    HANDLE  hProcess
    )
{
    PLIST_ENTRY                 Next;
    PPROCESS_ENTRY              ProcessEntry;

    Next = ProcessList.Flink;
    if (!Next) {
        return NULL;
    }

    while ((PVOID)Next != (PVOID)&ProcessList) {
        ProcessEntry = CONTAINING_RECORD( Next, PROCESS_ENTRY, ListEntry );
        Next = ProcessEntry->ListEntry.Flink;
        if (ProcessEntry->hProcess == hProcess) {
            return ProcessEntry;
        }
    }

    return NULL;
}

PPROCESS_ENTRY
FindFirstProcessEntry(
    )
{
    return CONTAINING_RECORD(ProcessList.Flink, PROCESS_ENTRY, ListEntry);
}


PMODULE_ENTRY
FindModule(
    HANDLE hProcess,
    PPROCESS_ENTRY ProcessEntry,
    LPSTR ModuleName,
    BOOL LoadSymbols
    )
{
    PLIST_ENTRY Next;
    PMODULE_ENTRY mi;

    Next = ProcessEntry->ModuleList.Flink;
    if (Next) {
        while ((PVOID)Next != (PVOID)&ProcessEntry->ModuleList) {
            mi = CONTAINING_RECORD( Next, MODULE_ENTRY, ListEntry );
            Next = mi->ListEntry.Flink;

            if ((_stricmp( mi->ModuleName, ModuleName ) == 0) ||
                (mi->AliasName[0] &&
                 _stricmp( mi->AliasName, ModuleName ) == 0))
            {
                if (LoadSymbols && !ENSURE_SYMBOLS(hProcess, mi)) {
                    return NULL;
                }

                return mi;
            }
        }
    }

    return NULL;
}


#ifdef FORLATER
        
BOOL
GetSizeofPDBSym(
    
    PMODULE_ENTRY   mi
        
    IN     HANDLE               hProcess,
    IN OUT PIMAGEHLP_SYMBOL64   Symbol,
    IN     int                  Direction
    )

/*++

Routine Description:

    Common code for SymGetSymNext and SymGetSymPrev.


Arguments:

    hProcess            - Process handle, must have been previously registered
                          with SymInitialize.

    Symbol              - Starting symbol.

    Dir                 - Supplies direction to search

Return Value:

    Non NULL pointer    - The symbol was located.

    NULL pointer        - The symbol was not found.  Call GetLastError to
                          discover the cause of the failure.

--*/

{
    PPROCESS_ENTRY      ProcessEntry;
    PMODULE_ENTRY       mi;
    ULONG64             Displacement;
    PSYMBOL_ENTRY       sym;

    DATASYM32 *nextSym;
    DATASYM32 *bestSym;
    DWORD64 bestAddr;
    PIMAGE_SECTION_HEADER sh;
    DWORD64 addr;
    ULONG k;
    LPSTR SymbolName;
    UCHAR SymbolLen;
    DWORD Bias;


    __try {

        nextSym = (DATASYM32*)GSINextSym( mi->gsi, NULL );
        bestSym = NULL;
        bestAddr = 0xffffffff;

        while( nextSym ) {
            addr = 0;
            k = DataSymSeg(nextSym);

            if ((k <= mi->OriginalNumSections)) {
                addr = mi->OriginalSectionHdrs[k-1].VirtualAddress + DataSymOffset(nextSym) + mi->BaseOfDll;

                if ((addr > sym->Address) && (addr < bestAddr)) {

                    SymbolName = DataSymNameStart(nextSym);
                    // ignore strings
                    if (*(ULONG *)SymbolName != 0x435f3f3f) { /* starts with ??_C */
                        bestAddr = addr;
                        bestSym = nextSym;
                    }
                }
            }
            nextSym = (DATASYM32*)GSINextSym( mi->gsi, (PUCHAR)nextSym );
        }

        if (!bestSym) {
            SetLastError( ERROR_INVALID_ADDRESS );
            return FALSE;
        }

        SymbolName = DataSymNameStart(bestSym);
        SymbolLen  = DataSymNameLength(bestSym);

        sym = &mi->TmpSym;

        if (SymOptions & SYMOPT_UNDNAME) {
            SymUnDNameInternal( sym->Name, TMP_SYM_LEN-sizeof(*sym), SymbolName, SymbolLen);
        } else {
            // use strncat to always get a \0 at the end
            sym->Name[0] = 0;
            strncat( sym->Name, SymbolName, TMP_SYM_LEN-sizeof(*sym) );
        }
        sym->NameLength = strlen(sym->Name);

        addr = ConvertOmapFromSrc( mi, bestAddr, &Bias );

        if (addr != 0) {
            bestAddr = addr + Bias;
        }

        sym->Size = 0;
        sym->Flags = 0;
        sym->Address = bestAddr;

        symcpy64( Symbol, sym );

        return TRUE;
    
    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return FALSE;

    }

    return FALSE;
}



#endif FORLATER


PSYMBOL_ENTRY
GetSymFromAddr(
    DWORD64         dwAddr,
    PDWORD64        pqwDisplacement,
    PMODULE_ENTRY   mi
    )
{
    PSYMBOL_ENTRY           sym;
    DWORD                   i;
    LONG                    High;
    LONG                    Low;
    LONG                    Middle;
    DWORD                   Displacement32;

    if (mi == NULL) {
        return NULL;
    }

    if (mi->SymType == SymPdb) {
        DWORD       Bias;
        DWORD64     SectionBase;
        DATASYM32  *dataSym;
        DATASYM32  *nextSym;
        DWORD64     srcBlkAddr;
        DWORD64     srcIPAddr;
        DWORD64     symAddr;
        DWORD64     nextAddr;
        LONG        size;           // presume no symbol can be larger than this
        BOOL        omap = FALSE;

        srcBlkAddr = ConvertOmapToSrc( mi,
                                   dwAddr,
                                   &Bias,
                                   (SymOptions & SYMOPT_OMAP_FIND_NEAREST) != 0
                                   );

        if (srcBlkAddr == 0) {
            //
            // No equivalent address
            //
            return NULL;
        }

        //
        // We have successfully converted
        //
        srcIPAddr = srcBlkAddr + Bias;

        if (srcIPAddr != dwAddr) {
            omap = TRUE;
        }

        //
        // locate the section that the address resides in
        //

        {
            PIMAGE_SECTION_HEADER   sh;

            for (i=0, sh=mi->OriginalSectionHdrs; i < mi->OriginalNumSections; i++, sh++) {
                if (srcIPAddr >= (mi->BaseOfDll + sh->VirtualAddress) &&
                    srcIPAddr <  (mi->BaseOfDll + sh->VirtualAddress + sh->Misc.VirtualSize))
                {
                    SectionBase = sh->VirtualAddress;
                    //
                    // found the section
                    //
                    break;
                }
            }
        }

        if (i == mi->OriginalNumSections) {
            return NULL;
        }

        dataSym = (DATASYM32*)GSINearestSym(
            mi->gsi,
            (USHORT)(i+1),
            (ULONG)(srcIPAddr - mi->BaseOfDll - SectionBase),
            &Displacement32
            );

        if (pqwDisplacement) {
            *pqwDisplacement = Displacement32;
        }

        if (dataSym == NULL) {
            return NULL;
        }

        // start to build symbol: address

        mi->TmpSym.Flags = 0;
        mi->TmpSym.Address  = srcIPAddr - Displacement32;

        // setup the name

        if (SymOptions & SYMOPT_UNDNAME) {
            SymUnDNameInternal( mi->TmpSym.Name, TMP_SYM_LEN,
                    DataSymNameStart(dataSym), DataSymNameLength(dataSym));
        } else {
            mi->TmpSym.NameLength = DataSymNameLength(dataSym);
            memcpy( mi->TmpSym.Name, DataSymNameStart(dataSym), mi->TmpSym.NameLength );
            mi->TmpSym.Name[mi->TmpSym.NameLength] = 0;
        }

        // get the address

        i = DataSymSeg(dataSym) - 1;
        symAddr = mi->OriginalSectionHdrs[i].VirtualAddress + mi->BaseOfDll + DataSymOffset(dataSym);

#  if 0 //BUGBUG - develop a system for representing relocated symbols
        // if the block is relocated, change symbol name

        if (omap) {
    
            if (symAddr < srcBlkAddr) {
                char sz[10];
                sprintf(sz, "_%d", Bias);
                strcat(mi->TmpSym.Name, sz);
                mi->TmpSym.NameLength = strlen(mi->TmpSym.Name);
            } 
        }
#endif

        // calculate size of symbol

        mi->TmpSym.Size = 0;

        // done

        return &mi->TmpSym;
    }

    //
    // do a binary search to locate the symbol
    //
    Low = 0;
    High = mi->numsyms - 1;

    while (High >= Low) {
        Middle = (Low + High) >> 1;
        sym = &mi->symbolTable[Middle];
        if (dwAddr < sym->Address) {

            High = Middle - 1;

        } else if (dwAddr >= sym->Address + sym->Size) {

            Low = Middle + 1;

        } else {

            if (pqwDisplacement) {
                *pqwDisplacement = dwAddr - sym->Address;
            }
            return sym;

        }
    }

    return NULL;
}


PMODULE_ENTRY
GetModuleForPC(
    PPROCESS_ENTRY  ProcessEntry,
    DWORD64         dwPcAddr,
    BOOL            ExactMatch
    )
{
    static PLIST_ENTRY          Next = NULL;
    PMODULE_ENTRY               ModuleEntry;


    if (dwPcAddr == (DWORD64)-1) {
        if ((PVOID)Next == (PVOID)&ProcessEntry->ModuleList) {
            // Reset to NULL so the list can be re-walked
            Next = NULL;
            return NULL;
        }
        ModuleEntry = CONTAINING_RECORD( Next, MODULE_ENTRY, ListEntry );
        Next = ModuleEntry->ListEntry.Flink;
        return ModuleEntry;
    }

    Next = ProcessEntry->ModuleList.Flink;
    if (!Next) {
        return NULL;
    }

    while ((PVOID)Next != (PVOID)&ProcessEntry->ModuleList) {
        ModuleEntry = CONTAINING_RECORD( Next, MODULE_ENTRY, ListEntry );
        Next = ModuleEntry->ListEntry.Flink;
        if (dwPcAddr == 0) {
            return ModuleEntry;
        }
        if (ExactMatch) {
            if (dwPcAddr == ModuleEntry->BaseOfDll) {
               return ModuleEntry;
            }
        } else
        if ((dwPcAddr == ModuleEntry->BaseOfDll && ModuleEntry->DllSize == 0) ||
            ((dwPcAddr >= ModuleEntry->BaseOfDll) &&
                (dwPcAddr  < ModuleEntry->BaseOfDll + ModuleEntry->DllSize))) {
               return ModuleEntry;
        }
    }

    return NULL;
}

PSYMBOL_ENTRY
GetSymFromAddrAllContexts(
    DWORD64         dwAddr,
    PDWORD64        pqwDisplacement,
    PPROCESS_ENTRY  ProcessEntry
    )
{
    PMODULE_ENTRY mi = GetModuleForPC( ProcessEntry, dwAddr, FALSE );
    if (mi == NULL) {
        return NULL;
    }
    return GetSymFromAddr( dwAddr, pqwDisplacement, mi );
}

DWORD
ComputeHash(
    LPSTR   lpbName,
    ULONG   cb
    )
{
    ULONG UNALIGNED *   lpulName;
    ULONG               ulEnd = 0;
    int                 cul;
    int                 iul;
    ULONG               ulSum = 0;

    while (cb & 3) {
        ulEnd |= (lpbName[cb - 1] & 0xdf);
        ulEnd <<= 8;
        cb -= 1;
    }

    cul = cb / 4;
    lpulName = (ULONG UNALIGNED *) lpbName;
    for (iul =0; iul < cul; iul++) {
        ulSum ^= (lpulName[iul] & 0xdfdfdfdf);
        ulSum = _lrotl( ulSum, 4);
    }
    ulSum ^= ulEnd;
    return ulSum % HASH_MODULO;
}

PSYMBOL_ENTRY
AllocSym(
    PMODULE_ENTRY   mi,
    DWORD64         addr,
    LPSTR           name
    )
{
    PSYMBOL_ENTRY       sym;
    ULONG               Length;


    if (mi->numsyms == mi->MaxSyms) {
        return NULL;
    }

    if (!mi->StringSize) {
        return NULL;
    }

    Length = strlen(name);

    if ((Length + 1) > mi->StringSize) {
        return NULL;
    }

    sym = &mi->symbolTable[mi->numsyms];

    mi->numsyms += 1;
    sym->Name = mi->SymStrings;
    mi->SymStrings += (Length + 2);
    mi->StringSize -= (Length + 2);

    strcpy( sym->Name, name );
    sym->Address = addr;
    sym->Size = 0;
    sym->Flags = 0;
    sym->Next = NULL;
    sym->NameLength = Length;

    return sym;
}

int __cdecl
SymbolTableAddressCompare(
    const void *e1,
    const void *e2
    )
{
    PSYMBOL_ENTRY    sym1 = (PSYMBOL_ENTRY) e1;
    PSYMBOL_ENTRY    sym2 = (PSYMBOL_ENTRY) e2;
    LONG64 diff;

    if ( sym1 && sym2 ) {
        diff = (sym1->Address - sym2->Address);
        return (diff < 0) ? -1 : (diff == 0) ? 0 : 1;
    } else {
        return 1;
    }
}

int __cdecl
SymbolTableNameCompare(
    const void *e1,
    const void *e2
    )
{
    PSYMBOL_ENTRY    sym1 = (PSYMBOL_ENTRY) e1;
    PSYMBOL_ENTRY    sym2 = (PSYMBOL_ENTRY) e2;

    return strcmp( sym1->Name, sym2->Name );
}

VOID
CompleteSymbolTable(
    PMODULE_ENTRY   mi
    )
{
    PSYMBOL_ENTRY       sym;
    PSYMBOL_ENTRY       symH;
    ULONG               Hash;
    ULONG               i;
    ULONG               dups;
    ULONG               seq;


    //
    // sort the symbols by name
    //
    qsort(
        mi->symbolTable,
        mi->numsyms,
        sizeof(SYMBOL_ENTRY),
        SymbolTableNameCompare
        );

    //
    // mark duplicate names
    //
    seq = 0;
    for (i=0; i<mi->numsyms; i++) {
        dups = 0;
        while ((mi->symbolTable[i+dups].NameLength == mi->symbolTable[i+dups+1].NameLength) &&
               (strcmp( mi->symbolTable[i+dups].Name, mi->symbolTable[i+dups+1].Name ) == 0)) {
                   mi->symbolTable[i+dups].Flags |= SYMF_DUPLICATE;
                   mi->symbolTable[i+dups+1].Flags |= SYMF_DUPLICATE;
                   dups += 1;
        }
        i += dups;
    }

    //
    // sort the symbols by address
    //
    qsort(
        mi->symbolTable,
        mi->numsyms,
        sizeof(SYMBOL_ENTRY),
        SymbolTableAddressCompare
        );

    //
    // calculate the size of each symbol
    //
    for (i=0; i<mi->numsyms; i++) {
        mi->symbolTable[i].Next = NULL;
        if (i+1 < mi->numsyms) {
            mi->symbolTable[i].Size = (ULONG)(mi->symbolTable[i+1].Address - mi->symbolTable[i].Address);
        }
    }

    //
    // compute the hash for each symbol
    //
    ZeroMemory( mi->NameHashTable, sizeof(mi->NameHashTable) );
    for (i=0; i<mi->numsyms; i++) {
        sym = &mi->symbolTable[i];

        Hash = ComputeHash( sym->Name, sym->NameLength );

        if (mi->NameHashTable[Hash]) {

            //
            // we have a collision
            //
            symH = mi->NameHashTable[Hash];
            while( symH->Next ) {
                symH = symH->Next;
            }
            symH->Next = sym;

        } else {

            mi->NameHashTable[Hash] = sym;

        }
    }
}

BOOL
CreateSymbolTable(
    PMODULE_ENTRY   mi,
    DWORD           SymbolCount,
    SYM_TYPE        SymType,
    DWORD           NameSize
    )
{
    //
    // allocate the symbol table
    //
    NameSize += OMAP_SYM_STRINGS;
    mi->symbolTable = (PSYMBOL_ENTRY) MemAlloc(
        (sizeof(SYMBOL_ENTRY) * (SymbolCount + OMAP_SYM_EXTRA)) + NameSize + (SymbolCount * CPP_EXTRA)
        );
    if (!mi->symbolTable) {
        return FALSE;
    }

    //
    // initialize the relevant fields
    //
    mi->numsyms    = 0;
    mi->MaxSyms    = SymbolCount + OMAP_SYM_EXTRA;
    mi->SymType    = SymType;
    mi->StringSize = NameSize + (SymbolCount * CPP_EXTRA);
    mi->SymStrings = (LPSTR)(mi->symbolTable + SymbolCount + OMAP_SYM_EXTRA);

    return TRUE;
}

PIMAGE_SECTION_HEADER 
FindSection(
    PIMAGE_SECTION_HEADER   sh,
    ULONG                   NumSections,
    ULONG                   Address
    )
{
    ULONG i;
    for (i=0; i<NumSections; i++) {
        if (Address >= sh[i].VirtualAddress &&
            Address <  (sh[i].VirtualAddress + sh[i].Misc.VirtualSize)) {
                    return &sh[i];
        }
    }
    return NULL;
}

PVOID 
GetSectionPhysical(
    HANDLE             hp,
    ULONG64            base,
    PIMGHLP_DEBUG_DATA pIDD,
    ULONG              Address
    )
{
    PIMAGE_SECTION_HEADER   sh;

    sh = FindSection( pIDD->pCurrentSections, pIDD->cCurrentSections, Address );
    if (!sh) {
        return 0;
    }

    return (PCHAR)pIDD->ImageMap + sh->PointerToRawData + (Address - sh->VirtualAddress);
}

BOOL
ReadSectionInfo(
    HANDLE             hp,
    ULONG64            base,
    PIMGHLP_DEBUG_DATA pIDD,
    ULONG              address,
    PVOID              buf,
    DWORD              size
    )
{
    PIMAGE_SECTION_HEADER   sh;
    DWORD_PTR status = TRUE;

    sh = FindSection( pIDD->pCurrentSections, pIDD->cCurrentSections, address );
    if (!sh) 
        return FALSE;

    if (!hp) {
        status = (DWORD_PTR)memcpy((PCHAR)buf, 
                               (PCHAR)base + sh->PointerToRawData + (address - sh->VirtualAddress), 
                               size);
    } else {
        status = ReadImageData(hp, base, address, buf, size);
    }
    if (!status)
        return FALSE;

    return TRUE;
}


ULONG
LoadExportSymbols(
    PMODULE_ENTRY      mi,
    PIMGHLP_DEBUG_DATA pIDD
    )
{
    PULONG                  names;
    PULONG                  addrs;
    PUSHORT                 ordinals;
    PUSHORT                 ordidx;
    ULONG                   cnt;
    ULONG                   idx;
    PIMAGE_EXPORT_DIRECTORY expdir;
    ULONG                   i;
    PSYMBOL_ENTRY           sym;
    ULONG                   NameSize;
    HANDLE                  hp;
    ULONG64                 base;
    CHAR                    name[2048];
    BOOL                    rc;

    // setup pointers for grabing data

    switch (pIDD->dsExports) {
    case dsInProc:
        hp = pIDD->hProcess;
        base = pIDD->InProcImageBase;
        break;
    case dsImage:
        hp = NULL;
        // BUGBUG: localize this!
        if (!pIDD->ImageMap)
            pIDD->ImageMap = MapItRO(pIDD->ImageFileHandle);
        base = (ULONG64)pIDD->ImageMap;
        break;
    default:
        return 0;
    }

    expdir = &pIDD->expdir;

    names = (PULONG) MemAlloc( expdir->NumberOfNames * sizeof(ULONG) );
    addrs = (PULONG) MemAlloc( expdir->NumberOfFunctions * sizeof(ULONG) );
    ordinals = (PUSHORT) MemAlloc( expdir->NumberOfNames * sizeof(USHORT) );
    ordidx = (PUSHORT) MemAlloc( expdir->NumberOfFunctions * sizeof(USHORT) );
    
    if (!names || !addrs || !ordinals || !ordidx)
        goto cleanup;

    rc = ReadSectionInfo(hp,
                         base,
                         pIDD,
                         expdir->AddressOfNames,
                         (PCHAR)names,
                         expdir->NumberOfNames * sizeof(ULONG));
    if (!rc)
        goto cleanup;
                              
    rc = ReadSectionInfo(hp,
                        base,
                        pIDD,
                        expdir->AddressOfFunctions,
                        (PCHAR)addrs,
                        expdir->NumberOfFunctions * sizeof(ULONG));
    if (!rc)
        goto cleanup;
                    
    rc = ReadSectionInfo(hp,
                         base,
                         pIDD,
                         expdir->AddressOfNameOrdinals,
                         (PCHAR)ordinals,
                         expdir->NumberOfNames * sizeof(USHORT));
    if (!rc)
        goto cleanup;
    
    cnt = 0;
    NameSize = 0;

    //
    // count the symbols
    //

    for (i=0; i<expdir->NumberOfNames; i++) {
        *name = 0;
        ReadSectionInfo(hp,
                        base,
                        pIDD,
                        names[i],
                        name,
                        sizeof(name));
        if (!*name) {
            continue;
        }
        if (SymOptions & SYMOPT_UNDNAME) {
            SymUnDNameInternal( mi->TmpSym.Name, TMP_SYM_LEN, name, strlen(name) );
            NameSize += strlen(mi->TmpSym.Name);
            cnt += 1;
        } else {
            NameSize += (strlen(name) + 2);
            cnt += 1;
        }
    }

    for (i=0,idx=expdir->NumberOfNames; i<expdir->NumberOfFunctions; i++) {
        if (!ordidx[i]) {
            NameSize += 16;
            cnt += 1;
        }
    }

    //
    // allocate the symbol table
    //
    if (!CreateSymbolTable( mi, cnt, SymExport, NameSize )) {
        cnt = 0;
        goto cleanup;
    }

    //
    // allocate the symbols
    //

    cnt = 0;

    for (i=0; i<expdir->NumberOfNames; i++) {
        idx = ordinals[i];
        ordidx[idx] = TRUE;
        *name = 0;
        ReadSectionInfo(hp,
                        base,
                        pIDD,
                        names[i],
                        name,
                        sizeof(name));
        if (!*name) {
            continue;
        }
        if (SymOptions & SYMOPT_UNDNAME) {
            SymUnDNameInternal( mi->TmpSym.Name, TMP_SYM_LEN, (LPSTR)name, strlen(name) );
            sym = AllocSym( mi, addrs[idx] + mi->BaseOfDll, mi->TmpSym.Name);
        } else {
            sym = AllocSym( mi, addrs[idx] + mi->BaseOfDll, name);
        }
        if (sym) {
            cnt += 1;
        }
    }

    for (i=0,idx=expdir->NumberOfNames; i<expdir->NumberOfFunctions; i++) {
        if (!ordidx[i]) {
            CHAR NameBuf[sizeof("Ordinal99999") + 1];       // Ordinals are only 64k max.
            strcpy( NameBuf, "Ordinal" );
            _itoa( i+expdir->Base, &NameBuf[7], 10 );
            sym = AllocSym( mi, addrs[i] + mi->BaseOfDll, NameBuf);
            if (sym) {
                cnt += 1;
            }
            idx += 1;
        }
    }

    CompleteSymbolTable( mi );

cleanup:
    if (names)    MemFree(names);
    if (addrs)    MemFree(addrs);
    if (ordinals) MemFree(ordinals);
    if (ordidx)   MemFree( ordidx );

    return cnt;
}


BOOL
LoadCoffSymbols(
    HANDLE             hProcess,
    PMODULE_ENTRY      mi,
    PIMGHLP_DEBUG_DATA pIDD
    )
{
    PIMAGE_COFF_SYMBOLS_HEADER pCoffHeader = (PIMAGE_COFF_SYMBOLS_HEADER)(pIDD->pMappedCoff);
    PUCHAR              stringTable;
    PIMAGE_SYMBOL       allSymbols;
    DWORD               numberOfSymbols;
    PIMAGE_LINENUMBER   LineNumbers;
    PIMAGE_SYMBOL       NextSymbol;
    PIMAGE_SYMBOL       Symbol;
    PSYMBOL_ENTRY       sym;
    CHAR                szSymName[256];
    DWORD               i;
    DWORD64             addr;
    DWORD               CoffSymbols = 0;
    DWORD               NameSize = 0;
    DWORD64             Bias;

    allSymbols = (PIMAGE_SYMBOL)((PCHAR)pCoffHeader +
                 pCoffHeader->LvaToFirstSymbol);

    stringTable = (PUCHAR)pCoffHeader +
                  pCoffHeader->LvaToFirstSymbol +
                  (pCoffHeader->NumberOfSymbols * IMAGE_SIZEOF_SYMBOL);

    numberOfSymbols = pCoffHeader->NumberOfSymbols;
    LineNumbers = (PIMAGE_LINENUMBER)(PCHAR)pCoffHeader +
                        pCoffHeader->LvaToFirstLinenumber;

    //
    // count the number of actual symbols
    //
    NextSymbol = allSymbols;
    for (i= 0; i < numberOfSymbols; i++) {
        Symbol = NextSymbol++;
        if (Symbol->StorageClass == IMAGE_SYM_CLASS_EXTERNAL &&
            Symbol->SectionNumber > 0) {
            GetSymName( Symbol, stringTable, szSymName, sizeof(szSymName) );
            if (szSymName[0] == '?' && szSymName[1] == '?' &&
                szSymName[2] == '_' && szSymName[3] == 'C'    ) {
                //
                // ignore strings
                //
            } else if (SymOptions & SYMOPT_UNDNAME) {
                SymUnDNameInternal( mi->TmpSym.Name, TMP_SYM_LEN, szSymName,
                                    strlen(szSymName) );
                NameSize += strlen(mi->TmpSym.Name);
                CoffSymbols += 1;
            } else {
                CoffSymbols += 1;
                NameSize += (strlen(szSymName) + 1);
            }
        }

        NextSymbol += Symbol->NumberOfAuxSymbols;
        i += Symbol->NumberOfAuxSymbols;
    }

    //
    // allocate the symbol table
    //
    if (!CreateSymbolTable( mi, CoffSymbols, SymCoff, NameSize )) {
        return FALSE;
    }

    //
    // populate the symbol table
    //

    if (mi->Flags & MIF_ROM_IMAGE) {
        Bias = mi->BaseOfDll & 0xffffffff00000000;
    } else {
        Bias = mi->BaseOfDll;
    }

    NextSymbol = allSymbols;
    for (i= 0; i < numberOfSymbols; i++) {
        Symbol = NextSymbol++;
        if (Symbol->StorageClass == IMAGE_SYM_CLASS_EXTERNAL &&
            Symbol->SectionNumber > 0) {
            GetSymName( Symbol, stringTable, szSymName, sizeof(szSymName) );
            addr = Symbol->Value + Bias;
            if (szSymName[0] == '?' && szSymName[1] == '?' &&
                szSymName[2] == '_' && szSymName[3] == 'C'    ) {
                //
                // ignore strings
                //
            } else if (SymOptions & SYMOPT_UNDNAME) {
                SymUnDNameInternal( mi->TmpSym.Name, TMP_SYM_LEN, szSymName,
                                    strlen(szSymName) );
                AllocSym( mi, addr, mi->TmpSym.Name);
            } else {
                AllocSym( mi, addr, szSymName );
            }
        }

        NextSymbol += Symbol->NumberOfAuxSymbols;
        i += Symbol->NumberOfAuxSymbols;
    }

    CompleteSymbolTable( mi );

    if (SymOptions & SYMOPT_LOAD_LINES) {
        AddLinesForCoff(mi, allSymbols, numberOfSymbols, LineNumbers);
    }

    return TRUE;
}

BOOL
LoadCodeViewSymbols(
    HANDLE             hProcess,
    PMODULE_ENTRY      mi,
    PIMGHLP_DEBUG_DATA pIDD
    )
{
    DWORD                   i, j;
    PPROCESS_ENTRY          ProcessEntry;
    OMFSignature           *omfSig;
    OMFDirHeader           *omfDirHdr;
    OMFDirEntry            *omfDirEntry;
    OMFSymHash             *omfSymHash;
    DATASYM32              *dataSym;
    DWORD64                 addr;
    DWORD                   CvSymbols;
    DWORD                   NameSize;

    ProcessEntry = FindProcessEntry( hProcess );
    if (!ProcessEntry) {
        return FALSE;
    }

    DPRINTF(ProcessEntry, "LoadCodeViewSymbols:\n"
            " hProcess   %p\n"
            " mi         %p\n"
            " pCvData    %p\n"
            " dwSize     %x\n",
            hProcess,
            mi,
            pIDD->pMappedCv,
            pIDD->cMappedCv
            );

    omfSig = (OMFSignature*) pIDD->pMappedCv;
    if ((*(DWORD *)(omfSig->Signature) != '80BN') &&
        (*(DWORD *)(omfSig->Signature) != '90BN') &&
        (*(DWORD *)(omfSig->Signature) != '11BN')) {
        DPRINTF(ProcessEntry, "unrecognized OMF sig: %x\n",
                *(DWORD *)(omfSig->Signature));
        return FALSE;
    }

    //
    // count the number of actual symbols
    //
    omfDirHdr = (OMFDirHeader*) ((ULONG_PTR)omfSig + (DWORD)omfSig->filepos);
    omfDirEntry = (OMFDirEntry*) ((ULONG_PTR)omfDirHdr + sizeof(OMFDirHeader));

    NameSize = 0;
    CvSymbols = 0;

    for (i=0; i<omfDirHdr->cDir; i++,omfDirEntry++) {
        LPSTR SymbolName;
        UCHAR SymbolLen;
        if (omfDirEntry->SubSection == sstGlobalPub) {
            omfSymHash = (OMFSymHash*) ((ULONG_PTR)omfSig + omfDirEntry->lfo);
            dataSym = (DATASYM32*) ((ULONG_PTR)omfSig + omfDirEntry->lfo + sizeof(OMFSymHash));
            for (j=sizeof(OMFSymHash); j<=omfSymHash->cbSymbol; ) {
                addr = 0;
                if (DataSymSeg(dataSym) && (DataSymSeg(dataSym) <= mi->OriginalNumSections))
                {
                    addr = mi->OriginalSectionHdrs[DataSymSeg(dataSym)-1].VirtualAddress + DataSymOffset(dataSym) + mi->BaseOfDll;
                    SymbolName = DataSymNameStart(dataSym);
                    SymbolLen = DataSymNameLength(dataSym);
                    if (SymbolName[0] == '?' &&
                        SymbolName[1] == '?' &&
                        SymbolName[2] == '_' &&
                        SymbolName[3] == 'C' )
                    {
                        //
                        // ignore strings
                        //
                    } else if (SymOptions & SYMOPT_UNDNAME) {
                        SymUnDNameInternal( mi->TmpSym.Name, TMP_SYM_LEN, SymbolName, SymbolLen );
                        NameSize += strlen(mi->TmpSym.Name);
                        CvSymbols += 1;
                    } else {
                        CvSymbols += 1;
                        NameSize += SymbolLen + 1;
                    }
                }
                j += dataSym->reclen + 2;
                dataSym = (DATASYM32*) ((ULONG_PTR)dataSym + dataSym->reclen + 2);
            }
            break;
        }
    }

    //
    // allocate the symbol table
    //
    if (!CreateSymbolTable( mi, CvSymbols, SymCv, NameSize )) {
        DPRINTF(ProcessEntry, "CreateSymbolTable failed\n");
        return FALSE;
    }

    //
    // populate the symbol table
    //
    omfDirHdr = (OMFDirHeader*) ((ULONG_PTR)omfSig + (DWORD)omfSig->filepos);
    omfDirEntry = (OMFDirEntry*) ((ULONG_PTR)omfDirHdr + sizeof(OMFDirHeader));
    for (i=0; i<omfDirHdr->cDir; i++,omfDirEntry++) {
        LPSTR SymbolName;
        if (omfDirEntry->SubSection == sstGlobalPub) {
            omfSymHash = (OMFSymHash*) ((ULONG_PTR)omfSig + omfDirEntry->lfo);
            dataSym = (DATASYM32*) ((ULONG_PTR)omfSig + omfDirEntry->lfo + sizeof(OMFSymHash));
            for (j=sizeof(OMFSymHash); j<=omfSymHash->cbSymbol; ) {
                addr = 0;
                if (DataSymSeg(dataSym) && (DataSymSeg(dataSym) <= mi->OriginalNumSections))
                {
                    addr = mi->OriginalSectionHdrs[DataSymSeg(dataSym)-1].VirtualAddress + DataSymOffset(dataSym) + mi->BaseOfDll;
                    SymbolName = DataSymNameStart(dataSym);
                    if (SymbolName[0] == '?' &&
                        SymbolName[1] == '?' &&
                        SymbolName[2] == '_' &&
                        SymbolName[3] == 'C' )
                    {
                        //
                        // ignore strings
                        //
                    } else if (SymOptions & SYMOPT_UNDNAME) {
                        SymUnDNameInternal( mi->TmpSym.Name, TMP_SYM_LEN, SymbolName, DataSymNameLength(dataSym) );

                        AllocSym( mi, addr, (LPSTR) mi->TmpSym.Name);
                    } else {
                        mi->TmpSym.NameLength = DataSymNameLength(dataSym);
                        memcpy( mi->TmpSym.Name, SymbolName, mi->TmpSym.NameLength );
                        mi->TmpSym.Name[mi->TmpSym.NameLength] = 0;
                        AllocSym( mi, addr, mi->TmpSym.Name);
                    }
                }
                j += dataSym->reclen + 2;
                dataSym = (DATASYM32*) ((ULONG_PTR)dataSym + dataSym->reclen + 2);
            }
            break;
        }
        else if (omfDirEntry->SubSection == sstSrcModule &&
                 (SymOptions & SYMOPT_LOAD_LINES)) {
            AddLinesForOmfSourceModule(mi, (PCHAR)(pIDD->pMappedCv)+omfDirEntry->lfo,
                                       (OMFSourceModule *)
                                       ((PCHAR)(pIDD->pMappedCv)+omfDirEntry->lfo),
                                       NULL);
        }
    }

    CompleteSymbolTable( mi );

    return TRUE;
}

VOID
GetSymName(
    PIMAGE_SYMBOL Symbol,
    PUCHAR        StringTable,
    LPSTR         s,
    DWORD         size
    )
{
    DWORD i;

    if (Symbol->n_zeroes) {
        for (i=0; i<8; i++) {
            if ((Symbol->n_name[i]>0x1f) && (Symbol->n_name[i]<0x7f)) {
                *s++ = Symbol->n_name[i];
            }
        }
        *s = 0;
    }
    else {
        strncpy( s, (char *) &StringTable[Symbol->n_offset], size );
    }
}


VOID
ProcessOmapForModule(
    PMODULE_ENTRY      mi,
    PIMGHLP_DEBUG_DATA pIDD
    )
{
    PSYMBOL_ENTRY       sym;
    PSYMBOL_ENTRY       symN;
    DWORD               i;

    if (pIDD->pOmapTo) {
        if (pIDD->fOmapToMapped) {
            mi->pOmapTo = MemAlloc(pIDD->cOmapTo * sizeof(OMAP));
            if (mi->pOmapTo) {
                CopyMemory(
                    mi->pOmapTo,
                    pIDD->pOmapTo,
                    pIDD->cOmapTo * sizeof(OMAP)
                    );
            }
        } else {
            mi->pOmapTo = pIDD->pOmapTo;
        }
        mi->cOmapTo = pIDD->cOmapTo;
    }

    if (pIDD->pOmapFrom) {
        if (pIDD->fOmapFromMapped) {
            mi->pOmapFrom = MemAlloc(pIDD->cOmapFrom * sizeof(OMAP));
            if (mi->pOmapFrom) {
                CopyMemory(
                    mi->pOmapFrom,
                    pIDD->pOmapFrom,
                    pIDD->cOmapFrom * sizeof(OMAP)
                    );
            }
        } else {
            mi->pOmapFrom = pIDD->pOmapFrom;
        }

        mi->cOmapFrom = pIDD->cOmapFrom;
    }

    if (!mi->pOmapFrom ||
        !mi->symbolTable ||
        ((mi->SymType != SymCoff) && (mi->SymType != SymCv))
       )
    {
        return;
    }

    for (i=0; i<mi->numsyms; i++) {
        ProcessOmapSymbol( mi, &mi->symbolTable[i] );
    }

    CompleteSymbolTable( mi );
}


BOOL
ProcessOmapSymbol(
    PMODULE_ENTRY       mi,
    PSYMBOL_ENTRY       sym
    )
{
    DWORD           bias;
    DWORD64         OptimizedSymAddr;
    DWORD           rvaSym;
    POMAPLIST       pomaplistHead;
    DWORD64         SymbolValue;
    DWORD64         OrgSymAddr;
    POMAPLIST       pomaplistNew;
    POMAPLIST       pomaplistPrev;
    POMAPLIST       pomaplistCur;
    POMAPLIST       pomaplistNext;
    DWORD           rva;
    DWORD           rvaTo;
    DWORD           cb;
    DWORD           end;
    DWORD           rvaToNext;
    LPSTR           NewSymName;
    CHAR            Suffix[32];
    DWORD64         addrNew;
    POMAP           pomap;
    PSYMBOL_ENTRY   symOmap;

    if ((sym->Flags & SYMF_OMAP_GENERATED) || (sym->Flags & SYMF_OMAP_MODIFIED)) {
        return FALSE;
    }

    OrgSymAddr = SymbolValue = sym->Address;

    OptimizedSymAddr = ConvertOmapFromSrc( mi, SymbolValue, &bias );

    if (OptimizedSymAddr == 0) {
        //
        // No equivalent address
        //
        sym->Address = 0;
        return FALSE;

    }

    //
    // We have successfully converted
    //
    sym->Address = OptimizedSymAddr + bias;

    rvaSym = (ULONG)(SymbolValue - mi->BaseOfDll);
    SymbolValue = sym->Address;

    pomap = GetOmapFromSrcEntry( mi, OrgSymAddr );
    if (!pomap) {
        goto exit;
    }

    pomaplistHead = NULL;

    //
    // Look for all OMAP entries belonging to SymbolEntry
    //

    end = (ULONG)(OrgSymAddr - mi->BaseOfDll + sym->Size);

    while (pomap && (pomap->rva < end)) {

        if (pomap->rvaTo == 0) {
            pomap++;
            continue;
        }

        //
        // Allocate and initialize a new entry
        //
        pomaplistNew = (POMAPLIST) MemAlloc( sizeof(OMAPLIST) );
        if (!pomaplistNew) {
            return FALSE;
        }

        pomaplistNew->omap = *pomap;
        pomaplistNew->cb = pomap[1].rva - pomap->rva;

        pomaplistPrev = NULL;
        pomaplistCur = pomaplistHead;

        while (pomaplistCur != NULL) {
            if (pomap->rvaTo < pomaplistCur->omap.rvaTo) {
                //
                // Insert between Prev and Cur
                //
                break;
            }
            pomaplistPrev = pomaplistCur;
            pomaplistCur = pomaplistCur->next;
        }

        if (pomaplistPrev == NULL) {
            //
            // Insert in head position
            //
            pomaplistHead = pomaplistNew;
        } else {
            pomaplistPrev->next = pomaplistNew;
        }

        pomaplistNew->next = pomaplistCur;

        pomap++;
    }

    if (pomaplistHead == NULL) {
        goto exit;
    }

    pomaplistCur = pomaplistHead;
    pomaplistNext = pomaplistHead->next;

    //
    // we do have a list
    //
    while (pomaplistNext != NULL) {
        rva = pomaplistCur->omap.rva;
        rvaTo  = pomaplistCur->omap.rvaTo;
        cb = pomaplistCur->cb;
        rvaToNext = pomaplistNext->omap.rvaTo;

        if (rvaToNext == sym->Address - mi->BaseOfDll) {
            //
            // Already inserted above
            //
        } else if (rvaToNext < (rvaTo + cb + 8)) {
            //
            // Adjacent to previous range
            //
        } else {
            addrNew = mi->BaseOfDll + rvaToNext;
            Suffix[0] = '_';
            _ltoa( pomaplistNext->omap.rva - rvaSym, &Suffix[1], 10 );
            memcpy( mi->TmpSym.Name, sym->Name, sym->NameLength );
            strncpy( &mi->TmpSym.Name[sym->NameLength], Suffix, strlen(Suffix) + 1 );
            symOmap = AllocSym( mi, addrNew, mi->TmpSym.Name);
            if (symOmap) {
                symOmap->Flags |= SYMF_OMAP_GENERATED;
            }
        }

        MemFree(pomaplistCur);

        pomaplistCur = pomaplistNext;
        pomaplistNext = pomaplistNext->next;
    }

    MemFree(pomaplistCur);

exit:
    if (sym->Address != OrgSymAddr) {
        sym->Flags |= SYMF_OMAP_MODIFIED;
    }

    return TRUE;
}


DWORD64
ConvertOmapFromSrc(
    PMODULE_ENTRY  mi,
    DWORD64        addr,
    LPDWORD        bias
    )
{
    DWORD   rva;
    DWORD   comap;
    POMAP   pomapLow;
    POMAP   pomapHigh;
    DWORD   comapHalf;
    POMAP   pomapMid;


    *bias = 0;

    if (!mi->pOmapFrom) {
        return addr;
    }

    rva = (DWORD)(addr - mi->BaseOfDll);

    comap = mi->cOmapFrom;
    pomapLow = mi->pOmapFrom;
    pomapHigh = pomapLow + comap;

    while (pomapLow < pomapHigh) {

        comapHalf = comap / 2;

        pomapMid = pomapLow + ((comap & 1) ? comapHalf : (comapHalf - 1));

        if (rva == pomapMid->rva) {
            if (pomapMid->rvaTo) {
                return mi->BaseOfDll + pomapMid->rvaTo;
            } else {
                return(0);      // No need adding the base.  This address was discarded...
            }
        }

        if (rva < pomapMid->rva) {
            pomapHigh = pomapMid;
            comap = (comap & 1) ? comapHalf : (comapHalf - 1);
        } else {
            pomapLow = pomapMid + 1;
            comap = comapHalf;
        }
    }

    //
    // If no exact match, pomapLow points to the next higher address
    //
    if (pomapLow == mi->pOmapFrom) {
        //
        // This address was not found
        //
        return 0;
    }

    if (pomapLow[-1].rvaTo == 0) {
        //
        // This address is in a discarded block
        //
        return 0;
    }

    //
    // Return the closest address plus the bias
    //
    *bias = rva - pomapLow[-1].rva;

    return mi->BaseOfDll + pomapLow[-1].rvaTo;
}


DWORD64
ConvertOmapToSrc(
    PMODULE_ENTRY  mi,
    DWORD64        addr,
    LPDWORD        bias,
    BOOL           fBackup
    )
{
    DWORD   rva;
    DWORD   comap;
    POMAP   pomapLow;
    POMAP   pomapHigh;
    DWORD   comapHalf;
    POMAP   pomapMid;

    *bias = 0;

    if (!mi->pOmapTo) {
        return addr;
    }

    rva = (DWORD)(addr - mi->BaseOfDll);

    comap = mi->cOmapTo;
    pomapLow = mi->pOmapTo;
    pomapHigh = pomapLow + comap;

    while (pomapLow < pomapHigh) {

        comapHalf = comap / 2;

        pomapMid = pomapLow + ((comap & 1) ? comapHalf : (comapHalf - 1));

        if (rva == pomapMid->rva) {
            if (pomapMid->rvaTo == 0) {
                //
                // We may be at the start of an inserted branch instruction
                //

                if (fBackup) {
                    //
                    // Return information about the next lower address
                    //

                    rva--;
                    pomapLow = pomapMid;
                    break;
                }

                return 0;
            }

            return mi->BaseOfDll + pomapMid->rvaTo;
        }

        if (rva < pomapMid->rva) {
            pomapHigh = pomapMid;
            comap = (comap & 1) ? comapHalf : (comapHalf - 1);
        } else {
            pomapLow = pomapMid + 1;
            comap = comapHalf;
        }
    }

    //
    // If no exact match, pomapLow points to the next higher address
    //
    
    if (pomapLow == mi->pOmapTo) {
        //
        // This address was not found
        //
        return 0;
    }

    // find the previous valid item in the omap

    do {
        pomapLow--;
        if (pomapLow->rvaTo)
            break;
    } while (pomapLow > mi->pOmapTo);

    // should never occur

    assert(pomapLow->rvaTo);
    if (pomapLow->rvaTo == 0) {
        return 0;   
    }

    //
    // Return the new address plus the bias
    //
    *bias = rva - pomapLow->rva;

    return mi->BaseOfDll + pomapLow->rvaTo;
}

POMAP
GetOmapFromSrcEntry(
    PMODULE_ENTRY  mi,
    DWORD64        addr
    )
{
    DWORD   rva;
    DWORD   comap;
    POMAP   pomapLow;
    POMAP   pomapHigh;
    DWORD   comapHalf;
    POMAP   pomapMid;


    if (mi->pOmapFrom == NULL) {
        return NULL;
    }

    rva = (DWORD)(addr - mi->BaseOfDll);

    comap = mi->cOmapFrom;
    pomapLow = mi->pOmapFrom;
    pomapHigh = pomapLow + comap;

    while (pomapLow < pomapHigh) {

        comapHalf = comap / 2;

        pomapMid = pomapLow + ((comap & 1) ? comapHalf : (comapHalf - 1));

        if (rva == pomapMid->rva) {
            return pomapMid;
        }

        if (rva < pomapMid->rva) {
            pomapHigh = pomapMid;
            comap = (comap & 1) ? comapHalf : (comapHalf - 1);
        } else {
            pomapLow = pomapMid + 1;
            comap = comapHalf;
        }
    }

    return NULL;
}

LPSTR
StringDup(
    LPSTR str
    )
{
    LPSTR ds = (LPSTR) MemAlloc( strlen(str) + 1 );
    if (ds) {
        strcpy( ds, str );
    }
    return ds;
}


BOOL
InternalGetModule(
    HANDLE  hProcess,
    LPSTR   ModuleName,
    DWORD64 ImageBase,
    DWORD   ImageSize,
    PVOID   Context
    )
{
    InternalLoadModule(
            hProcess,
            ModuleName,
            NULL,
            ImageBase,
            ImageSize,
            NULL
            );

    return TRUE;
}


BOOL
LoadedModuleEnumerator(
    HANDLE         hProcess,
    LPSTR          ModuleName,
    DWORD64        ImageBase,
    DWORD          ImageSize,
    PLOADED_MODULE lm
    )
{
    if (lm->EnumLoadedModulesCallback64) {
        return lm->EnumLoadedModulesCallback64( ModuleName, ImageBase, ImageSize, lm->Context );
    } else {
        return lm->EnumLoadedModulesCallback32( ModuleName, (DWORD)ImageBase, ImageSize, lm->Context );
    }
}


LPSTR
SymUnDNameInternal(
    LPSTR UnDecName,
    DWORD UnDecNameLength,
    LPSTR DecName,
    DWORD DecNameLength
    )
{
    LPSTR p;
    ULONG Suffix;
    ULONG i;
    LPSTR TmpDecName;


    UnDecName[0] = 0;

    if ((DecName[0] == '?') || (DecName[0] == '.' && DecName[1] == '.' && DecName[2] == '?')) {

        __try {

            if (DecName[0] == '.' && DecName[1] == '.') {
                Suffix = 2;
                UnDecName[0] = '.';
                UnDecName[1] = '.';
            } else {
                Suffix = 0;
            }

            TmpDecName = MemAlloc( 4096 );
            if (!TmpDecName) {
                strncat( UnDecName, DecName, min(DecNameLength,UnDecNameLength) );
                return UnDecName;
            }
            TmpDecName[0] = 0;
            strncat( TmpDecName, DecName+Suffix, DecNameLength );

            if(UnDecorateSymbolName( TmpDecName,
                                     UnDecName+Suffix,
                                     UnDecNameLength-Suffix,
                                     UNDNAME_NAME_ONLY ) == 0 ) {
                strncat( UnDecName, DecName, min(DecNameLength,UnDecNameLength) );
            }

            MemFree( TmpDecName );

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            strncat( UnDecName, DecName, min(DecNameLength,UnDecNameLength) );

        }

        if (SymOptions & SYMOPT_NO_CPP) {
            while (p = strstr( UnDecName, "::" )) {
                p[0] = '_';
                p[1] = '_';
            }
        }

    } else {

        __try {

            if (DecName[0] == '_' || DecName[0] == '@') {
                DecName += 1;
                DecNameLength -= 1;
            }
            p = 0;
            for (i = 0; i < DecNameLength; i++) {
                if (DecName [i] == '@') {
                    p = &DecName [i];
                    break;
                }
            }
            if (p) {
                i = (int)(p - DecName);
            } else {
                i = min(DecNameLength,UnDecNameLength);
            }
            strncat( UnDecName, DecName, i );

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            strncat( UnDecName, DecName, min(DecNameLength,UnDecNameLength) );

        }

    }

    return UnDecName;
}



PIMAGEHLP_SYMBOL
symcpy32(
    PIMAGEHLP_SYMBOL  External,
    PSYMBOL_ENTRY       Internal
    )
{
    External->Address      = (ULONG)Internal->Address;
    External->Size         = Internal->Size;
    External->Flags        = Internal->Flags;

    External->Name[0] = 0;
    strncat( External->Name, Internal->Name, External->MaxNameLength );

    return External;
}

PIMAGEHLP_SYMBOL64
symcpy64(
    PIMAGEHLP_SYMBOL64  External,
    PSYMBOL_ENTRY       Internal
    )
{
    External->Address      = Internal->Address;
    External->Size         = Internal->Size;
    External->Flags        = Internal->Flags;

    External->Name[0] = 0;
    strncat( External->Name, Internal->Name, External->MaxNameLength );

    return External;
}

BOOL
SympConvertSymbol64To32(
    PIMAGEHLP_SYMBOL64 Symbol64,
    PIMAGEHLP_SYMBOL Symbol32
    )
{
    Symbol32->Address = (DWORD)Symbol64->Address;
    Symbol32->Size = Symbol64->Size;
    Symbol32->Flags = Symbol64->Flags;
    Symbol32->MaxNameLength = Symbol64->MaxNameLength;
    Symbol32->Name[0] = 0;
    strncat( Symbol32->Name, Symbol64->Name, Symbol32->MaxNameLength );

    return (Symbol64->Address >> 32) == 0;
}

BOOL
SympConvertSymbol32To64(
    PIMAGEHLP_SYMBOL Symbol32,
    PIMAGEHLP_SYMBOL64 Symbol64
    )
{
    Symbol64->Address = Symbol32->Address;
    Symbol64->Size = Symbol32->Size;
    Symbol64->Flags = Symbol32->Flags;
    Symbol64->MaxNameLength = Symbol32->MaxNameLength;
    Symbol64->Name[0] = 0;
    strncat( Symbol64->Name, Symbol32->Name, Symbol64->MaxNameLength );

    return TRUE;
}

BOOL
SympConvertLine64To32(
    PIMAGEHLP_LINE64 Line64,
    PIMAGEHLP_LINE Line32
    )
{
    Line32->Key = Line64->Key;
    Line32->LineNumber = Line64->LineNumber;
    Line32->FileName = Line64->FileName;
    Line32->Address = (DWORD)Line64->Address;

    return (Line64->Address >> 32) == 0;
}

BOOL
SympConvertLine32To64(
    PIMAGEHLP_LINE Line32,
    PIMAGEHLP_LINE64 Line64
    )
{
    Line64->Key = Line32->Key;
    Line64->LineNumber = Line32->LineNumber;
    Line64->FileName = Line32->FileName;
    Line64->Address = Line32->Address;

    return TRUE;
}

DWORD
ReadInProcMemory(
    HANDLE    hProcess,
    DWORD64   addr,
    PVOID     buf,
    DWORD     bytes,
    DWORD    *bytesread
    )
{
    DWORD                    rc;
    PPROCESS_ENTRY           pe;
    IMAGEHLP_CBA_READ_MEMORY rm;

    rm.addr      = addr;
    rm.buf       = buf;
    rm.bytes     = bytes;
    rm.bytesread = bytesread;

    rc = FALSE;
    
    __try {
        pe = FindProcessEntry(hProcess);
        if (!pe) {
            SetLastError( ERROR_INVALID_HANDLE );
            return FALSE;
        }

        if (pe->pCallbackFunction32) {
            rc = pe->pCallbackFunction32(pe->hProcess,
                                         CBA_READ_MEMORY,
                                         (PVOID)&rm,
                                         (PVOID)pe->CallbackUserContext);
        
        } else if (pe->pCallbackFunction64) {
            rc = pe->pCallbackFunction64(pe->hProcess,
                                         CBA_READ_MEMORY,
                                         (ULONG64)&rm,
                                         pe->CallbackUserContext);
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        rc = FALSE;
    }

    return (rc != FALSE);
}

__inline
BOOL
miReadInProcMemory(
    PMODULE_ENTRY mi,
    ULONG_PTR     addr,
    PVOID         buf,
    DWORD         bytes,
    DWORD        *bytesread
    )
{
    return ReadInProcMemory(mi->hProcess, /*(DWORD64)(PCHAR)*/mi->InProcImageBase + addr, buf, bytes, bytesread);
}

DWORD64
miGetModuleBase(
    HANDLE  hProcess,
    DWORD64 Address
    )
{
    IMAGEHLP_MODULE64 ModuleInfo = {0};
    ModuleInfo.SizeOfStruct = sizeof(ModuleInfo);

    if (SymGetModuleInfo64(hProcess, Address, &ModuleInfo)) {
        return ModuleInfo.BaseOfImage;
    } else {
        return 0;
    }
}

BOOL
GetPData(
    HANDLE        hp,
    PMODULE_ENTRY mi
    )
{
    BOOL status;
    ULONG cb;
    PCHAR pc;
    BOOL  fROM = FALSE;
    IMAGE_DOS_HEADER DosHeader;
    IMAGE_NT_HEADERS ImageNtHeaders;
    PIMAGE_FILE_HEADER ImageFileHdr;
    PIMAGE_OPTIONAL_HEADER ImageOptionalHdr;
    PIMAGE_OPTIONAL_HEADER32 OptionalHeader32 = NULL;
    PIMAGE_OPTIONAL_HEADER64 OptionalHeader64 = NULL;
    ULONG feCount = 0;
    ULONG i;

    HANDLE fh = 0;
    PCHAR  base = NULL;
    USHORT                       filetype;
    PIMAGE_SEPARATE_DEBUG_HEADER  sdh;
    PIMAGE_DOS_HEADER dh;
    PIMAGE_NT_HEADERS inth;
    PIMAGE_OPTIONAL_HEADER32 ioh32;
    PIMAGE_OPTIONAL_HEADER64 ioh64;
    ULONG cdd;
    PCHAR p;
    PIMAGE_DEBUG_DIRECTORY dd;
    ULONG cexp = 0;
    ULONG tsize;
    ULONG csize;

    // IA64 is not ready to roll with on-demand pdata.
    // Call the original code.

    if (mi->MachineType == IMAGE_FILE_MACHINE_IA64)
        goto ia64;

    // if the pdata is already loaded, return

    if (mi->pExceptionData) 
        return TRUE;

    if (!ENSURE_SYMBOLS(hp, mi)) 
        return FALSE;

    if (!mi->dsExceptions)
        return FALSE;

    // open the file and get the file typ

    fh = CreateFile(mi->LoadedImageName,
                    GENERIC_READ,
                    OSVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT ? (FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE) : (FILE_SHARE_READ | FILE_SHARE_WRITE),
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );

    if (fh == INVALID_HANDLE_VALUE) 
        return FALSE;

    base = MapItRO(fh);
    if (!base)
        goto cleanup;
    p = base;

    filetype = *(USHORT *)p;
    if (filetype == IMAGE_DOS_SIGNATURE)
        goto image;
    if (filetype == IMAGE_SEPARATE_DEBUG_SIGNATURE)
        goto dbg;
    goto cleanup;

image:

    // process disk-based image

    dh = (PIMAGE_DOS_HEADER)p;
    p  += dh->e_lfanew;
    inth = (PIMAGE_NT_HEADERS)p;

    if (inth->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
        ioh32 = (PIMAGE_OPTIONAL_HEADER32)&inth->OptionalHeader;
        p = base + ioh32->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress;
        csize = ioh32->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].Size;
    } 
    else if (inth->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
        ioh64 = (PIMAGE_OPTIONAL_HEADER64)&inth->OptionalHeader;
        p = base + ioh64->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress;
        csize = ioh64->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].Size;
    }
    
    if (!csize)
        goto cleanup;

    switch (mi->MachineType) 
    {
    case IMAGE_FILE_MACHINE_ALPHA:
        cexp = csize / sizeof(IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY);
        break;
    case IMAGE_FILE_MACHINE_ALPHA64:
        cexp = csize / sizeof(IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY);
        break;
    case IMAGE_FILE_MACHINE_IA64:
        cexp = csize / sizeof(IMAGE_IA64_RUNTIME_FUNCTION_ENTRY);
        break;
    default:
        goto cleanup;
    }
    
    goto table;

dbg:

    // process dbg file

    sdh = (PIMAGE_SEPARATE_DEBUG_HEADER)p;
    cdd = sdh->DebugDirectorySize / sizeof(IMAGE_DEBUG_DIRECTORY);
    p +=  sizeof(IMAGE_SEPARATE_DEBUG_HEADER) +
          (sdh->NumberOfSections * sizeof(IMAGE_SECTION_HEADER)) +
          sdh->ExportedNamesSize;
    dd = (PIMAGE_DEBUG_DIRECTORY)p;

    for (i = 0; i < cdd; i++, dd++) {
        if (dd->Type == IMAGE_DEBUG_TYPE_EXCEPTION) {
            p = base + dd->PointerToRawData;
            cexp = dd->SizeOfData / sizeof(IMAGE_FUNCTION_ENTRY);
            break;
        }
    }
    
table:
    
    // parse the pdata into a table

    if (!cexp) 
        goto cleanup;

    tsize = cexp * sizeof(IMGHLP_RVA_FUNCTION_DATA);

    mi->pExceptionData = VirtualAlloc( NULL, tsize, MEM_COMMIT, PAGE_READWRITE );

    if (mi->pExceptionData) {
        IMGHLP_RVA_FUNCTION_DATA *pIRFD = mi->pExceptionData;
        switch (mi->MachineType) {

        case IMAGE_FILE_MACHINE_ALPHA:
            if (filetype == IMAGE_SEPARATE_DEBUG_SIGNATURE) {
                // easy case.  The addresses are already in rva format.
                PIMAGE_FUNCTION_ENTRY pFE = (PIMAGE_FUNCTION_ENTRY)p;
                for (i = 0; i < cexp; i++) {
                    pIRFD[i].rvaBeginAddress     = pFE[i].StartingAddress;
                    pIRFD[i].rvaEndAddress       = pFE[i].EndingAddress;
                    pIRFD[i].rvaPrologEndAddress = pFE[i].EndOfPrologue;
                    pIRFD[i].rvaExceptionHandler = 0;
                    pIRFD[i].rvaHandlerData      = 0;
                }
            } else {
                PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY pRFE = (PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY)p;
                for (i = 0; i < cexp; i++) {
                    pIRFD[i].rvaBeginAddress     = pRFE[i].BeginAddress - (ULONG)mi->BaseOfDll;
                    pIRFD[i].rvaEndAddress       = pRFE[i].EndAddress - (ULONG)mi->BaseOfDll;
                    pIRFD[i].rvaPrologEndAddress = pRFE[i].PrologEndAddress - (ULONG)mi->BaseOfDll;
                    pIRFD[i].rvaExceptionHandler = pRFE[i].ExceptionHandler - (ULONG)mi->BaseOfDll;
                    pIRFD[i].rvaHandlerData      = pRFE[i].HandlerData - (ULONG)mi->BaseOfDll;
                }
            }
            break;

        case IMAGE_FILE_MACHINE_ALPHA64:
            {
                PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY pRFE = (PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY)p;
                for (i = 0; i < cexp; i++) {
                    pIRFD[i].rvaBeginAddress     = (DWORD)(pRFE[i].BeginAddress - mi->BaseOfDll);
                    pIRFD[i].rvaEndAddress       = (DWORD)(pRFE[i].EndAddress - mi->BaseOfDll);
                    pIRFD[i].rvaPrologEndAddress = (DWORD)(pRFE[i].PrologEndAddress - mi->BaseOfDll);
                    pIRFD[i].rvaExceptionHandler = (DWORD)(pRFE[i].ExceptionHandler - mi->BaseOfDll);
                    pIRFD[i].rvaHandlerData      = (DWORD)(pRFE[i].HandlerData - mi->BaseOfDll);
                }
            }
            break;

        case IMAGE_FILE_MACHINE_IA64:
            {
                PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY pRFE = (PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY)p; // mi->pImageFunction
                for (i = 0; i < cexp; i++) {
                    pIRFD[i].rvaBeginAddress     = pRFE[i].BeginAddress;
                    pIRFD[i].rvaEndAddress       = pRFE[i].EndAddress;
                    pIRFD[i].rvaPrologEndAddress = pRFE[i].UnwindInfoAddress;
                    pIRFD[i].rvaExceptionHandler = 0;
                    pIRFD[i].rvaHandlerData      = 0;
                }
            }
            break;

        default:
            break;
        }
        
        VirtualProtect( mi->pExceptionData, tsize, PAGE_READONLY, &i );

        mi->dwEntries     = cexp;
    }
                                   
cleanup:
    
    if (base)
        UnmapViewOfFile(base);

    if (fh)
        CloseHandle(fh);

    return (cexp) ? TRUE : FALSE;




// The is the original GetPData, preserved for IA64 support which still relies 
// on this working by calling from in-proc memory.

ia64:
    
// if the pdata is already loaded, return

    if (mi->pExceptionData) 
        return TRUE;

    // get in-process header pointers

    status = miReadInProcMemory(mi, 0, &DosHeader, sizeof(DosHeader), &cb);
    if (!status || cb != sizeof(DosHeader) || DosHeader.e_magic != IMAGE_DOS_SIGNATURE) 
        return FALSE;

    status = miReadInProcMemory(mi, DosHeader.e_lfanew, &ImageNtHeaders, sizeof(ImageNtHeaders), &cb);
    if (!status || cb != sizeof(ImageNtHeaders))
        return FALSE;

    ImageFileHdr = &ImageNtHeaders.FileHeader;
    if (ImageNtHeaders.OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
        OptionalHeader32 = (PIMAGE_OPTIONAL_HEADER32)&ImageNtHeaders.OptionalHeader;
        OptionalHeader64 = NULL; 
    } else
    if (ImageNtHeaders.OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
        OptionalHeader64 = (PIMAGE_OPTIONAL_HEADER64)&ImageNtHeaders.OptionalHeader;
        OptionalHeader32 = NULL;
    }
    
    // this doesn't work with ROM images

    if (ImageFileHdr->SizeOfOptionalHeader == sizeof(IMAGE_ROM_OPTIONAL_HEADER)) 
        return FALSE;

    // copy pdata from in-process memory

    if (pc = MemAlloc(OPTIONALHEADER(DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].Size))) {
        status = miReadInProcMemory(mi, 
                                    OPTIONALHEADER(DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress),
                                    pc, 
                                    OPTIONALHEADER(DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].Size),
                                    &cb);

        if (status && cb == OPTIONALHEADER(DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].Size)) {
            switch (ImageFileHdr->Machine) {
                case IMAGE_FILE_MACHINE_ALPHA:
                    feCount = OPTIONALHEADER(DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].Size) /
                              sizeof(IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY);
                    break;

                case IMAGE_FILE_MACHINE_ALPHA64:
                    feCount = OPTIONALHEADER(DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].Size) /
                              sizeof(IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY);
                    break;

                case IMAGE_FILE_MACHINE_IA64:
                    feCount = OPTIONALHEADER(DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].Size) /
                              sizeof(IMAGE_IA64_RUNTIME_FUNCTION_ENTRY);
                    break;
            }
        } 
    }

    // parse the pdata into a table

    if (feCount) {

        ULONG TableSize = feCount * sizeof(IMGHLP_RVA_FUNCTION_DATA);

        mi->pExceptionData = VirtualAlloc( NULL, TableSize, MEM_COMMIT, PAGE_READWRITE );

        if (mi->pExceptionData) {
            IMGHLP_RVA_FUNCTION_DATA *pIRFD = mi->pExceptionData;

            switch (mi->MachineType) {
                case IMAGE_FILE_MACHINE_ALPHA:
                    {
                        PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY pRFE = (PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY)pc; // mi->pImageFunction
                        DWORD ImageBase = (DWORD)mi->InProcImageBase;
                        for (i = 0; i < feCount; i++) {
                            pIRFD[i].rvaBeginAddress     = pRFE[i].BeginAddress - ImageBase;
                            pIRFD[i].rvaEndAddress       = pRFE[i].EndAddress - ImageBase;
                            pIRFD[i].rvaPrologEndAddress = pRFE[i].PrologEndAddress - ImageBase;
                            pIRFD[i].rvaExceptionHandler = pRFE[i].ExceptionHandler - ImageBase;
                            pIRFD[i].rvaHandlerData      = pRFE[i].HandlerData - ImageBase;
                        }
                    }
                    break;

                case IMAGE_FILE_MACHINE_ALPHA64:
                    {
                        PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY pRFE = (PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY)pc; // mi->pImageFunction
                        DWORD ImageBase = (DWORD)mi->InProcImageBase;
                        for (i = 0; i < feCount; i++) {
                            pIRFD[i].rvaBeginAddress     = (DWORD)(pRFE[i].BeginAddress - ImageBase);
                            pIRFD[i].rvaEndAddress       = (DWORD)(pRFE[i].EndAddress - ImageBase);
                            pIRFD[i].rvaPrologEndAddress = (DWORD)(pRFE[i].PrologEndAddress - ImageBase);
                            pIRFD[i].rvaExceptionHandler = (DWORD)(pRFE[i].ExceptionHandler - ImageBase);
                            pIRFD[i].rvaHandlerData      = (DWORD)(pRFE[i].HandlerData - ImageBase);
                        }
                    }
                    break;

                case IMAGE_FILE_MACHINE_IA64:
                    {
                        PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY pRFE = (PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY)pc; // mi->pImageFunction
                        for (i = 0; i < feCount; i++) {
                            pIRFD[i].rvaBeginAddress     = pRFE[i].BeginAddress;
                            pIRFD[i].rvaEndAddress       = pRFE[i].EndAddress;
                            pIRFD[i].rvaPrologEndAddress = pRFE[i].UnwindInfoAddress;
                            pIRFD[i].rvaExceptionHandler = 0;
                            pIRFD[i].rvaHandlerData      = 0;
                        }
                    }
                    break;
                default:
                    break;
           }
            
            VirtualProtect( mi->pExceptionData, TableSize, PAGE_READONLY, &i );

            mi->dwEntries     = feCount;
        }
    }
                                   
    // clean up

    if (pc)
        MemFree(pc);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\undname.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    undname.c

Abstract:

    This is the main source file for the UNDNAME utility program.
    This is a simple command line utility for undecorating C++ symbol
    names.

Author:

    Weslwy Witt (wesw) 09-June-1993

Revision History:

--*/

#include <private.h>
#include <ntverp.h>
#include <common.ver>


void
Usage( void )
{
    fprintf( stderr,
             "usage: UNDNAME [-f] decorated-names...\n"
             "       -f Undecorate fully.  Default is to only undecorate the class::member\n");
    exit( 1 );
}

int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    char UnDecoratedName[4000];
    DWORD Flags;

    fputs(VER_PRODUCTNAME_STR "\nUNDNAME Version " VER_PRODUCTVERSION_STR, stderr );
    fputs(VER_LEGALCOPYRIGHT_STR "\n\n", stderr);

    if (argc <= 1) {
        Usage();
    }

    if ((argv[1][0] == '-') && (argv[1][1] == 'f')) {
        Flags = UNDNAME_COMPLETE;
        argc--;
        argv++;
    } else {
        Flags = UNDNAME_NAME_ONLY;
    }

    if (argc <= 1) {
        Usage();
    }

    while (--argc) {
        UnDecorateSymbolName( *++argv, UnDecoratedName, sizeof(UnDecoratedName), Flags );
        printf( ">> %s == %s\n", *argv, UnDecoratedName );
    }

    exit( 0 );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\verfix.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    verfix.c

Abstract:

    This module fixes updates the major and minor subsystem version
    numbers in an executable and recomputes the checksum.

Author:

    Robert Reichel (robertre) 2-May-1993

Revision History:

--*/

#include <private.h>


#define NEW_MAJOR_VERSION  3
#define NEW_MINOR_VERSION  10

void Usage()
{
    fputs(  "usage: VERFIX [-?] [-v] [-q] image-names...\n"
            "              [-?] display this message\n"
            "              [-n #.#] Subsystem Major.Minor versions (default to 3.10)\n"
            "              [-q] quiet on failure\n"
            "              [-v] verbose output\n",
          stderr);
    exit( 1 );
}

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    HANDLE FileHandle;
    HANDLE MappingHandle;
    PIMAGE_NT_HEADERS NtHeaders;
    PVOID BaseAddress;
    ULONG CheckSum;
    ULONG FileLength;
    ULONG HeaderSum;
    ULONG OldCheckSum;
    USHORT MajorSubsystemVersion;
    USHORT MinorSubsystemVersion;
    ULONG NewMajorSubsystemVersion = NEW_MAJOR_VERSION;
    ULONG NewMinorSubsystemVersion = NEW_MINOR_VERSION;
    LPSTR ImageName;
    BOOLEAN fVerbose = FALSE;
    BOOLEAN fQuiet = FALSE;
    LPSTR s;
    UCHAR c;

    if (argc <= 1) {
        Usage();
        }

    --argc;
    while (argc) {
        s = *++argv;
        if ( *s == '-' ) {
            while (c=*++s) {
                switch (c) {
                    case 'q':
                    case 'Q':
                        fQuiet = TRUE;
                        break;

                    case 'v':
                    case 'V':
                        fVerbose=TRUE;
                        break;

                    case 'n':
                    case 'N':
                        s = *++argv;
                        --argc;
                        sscanf(s, "%d.%d", &NewMajorSubsystemVersion, &NewMinorSubsystemVersion);
                        goto NextArgument;
                        break;

                    case 'h':
                    case 'H':
                    case '?':
                        Usage();

                    default:
                        fprintf( stderr, "VERFIX: illegal option /%c\n", c );
                        Usage();
                    }
                }
        } else {
            ImageName = s;
            FileHandle = CreateFile( ImageName,
                                     GENERIC_READ | GENERIC_WRITE,
                                     FILE_SHARE_READ,
                                     NULL,
                                     OPEN_EXISTING,
                                     0,
                                     NULL
                                   );
            if (FileHandle == INVALID_HANDLE_VALUE) {
                if (!fQuiet) {
                    fprintf( stderr, "VERFIX: Unable to open %s (%u) - skipping\n", ImageName, GetLastError() );
                    goto NextArgument;
                }
            }

            MappingHandle = CreateFileMapping( FileHandle,
                                           NULL,
                                           PAGE_READWRITE,
                                           0,
                                           0,
                                           NULL
                                         );
            if (MappingHandle == NULL) {
                CloseHandle( FileHandle );
                if (!fQuiet) {
                    fprintf( stderr, "VERFIX: Unable to create mapping object for file %s (%u) - skipping\n", ImageName, GetLastError() );
                }
            } else {
                BaseAddress = MapViewOfFile( MappingHandle,
                                             FILE_MAP_READ | FILE_MAP_WRITE,
                                             0,
                                             0,
                                             0
                                           );
                CloseHandle( MappingHandle );
                if (BaseAddress == NULL) {
                    CloseHandle( FileHandle );
                    if (!fQuiet ) {
                        fprintf( stderr, "VERFIX: Unable to map view of file %s (%u) - skipping\n", ImageName, GetLastError() );
                    }
                } else {
                    //
                    // Get the length of the file in bytes and compute the checksum.
                    //

                    FileLength = GetFileSize( FileHandle, NULL );

                    //
                    // Obtain a pointer to the header information.
                    //

                    NtHeaders = ImageNtHeader( BaseAddress );
                    if (NtHeaders == NULL) {
                        CloseHandle( FileHandle );
                        UnmapViewOfFile( BaseAddress );
                        if (!fQuiet) {
                            fprintf( stderr, "VERFIX: %s is not a valid image file - skipping\n", ImageName, GetLastError() );
                        }
                    } else {
                        //
                        // Write the information to the file.  Update the
                        // SubsystemVersion major and minor codes.
                        //

                        MajorSubsystemVersion = NtHeaders->OptionalHeader.MajorSubsystemVersion;
                        MinorSubsystemVersion = NtHeaders->OptionalHeader.MinorSubsystemVersion;
                        OldCheckSum = NtHeaders->OptionalHeader.CheckSum;

                        NtHeaders->OptionalHeader.MajorSubsystemVersion = (USHORT)NewMajorSubsystemVersion;
                        NtHeaders->OptionalHeader.MinorSubsystemVersion = (USHORT)NewMinorSubsystemVersion;

                        //
                        // Recompute and reset the checksum of the modified file.
                        //

                        (VOID) CheckSumMappedFile( BaseAddress,
                                                   FileLength,
                                                   &HeaderSum,
                                                   &CheckSum
                                                 );

                        NtHeaders->OptionalHeader.CheckSum = CheckSum;

                        if (fVerbose) {
                            printf( "%s - Old version: %u.%u  Old Checksum: %x",
                                    ImageName, MajorSubsystemVersion, MinorSubsystemVersion, OldCheckSum
                                  );

                            printf( "  New version: %u.%u  New Checksum: %x\n",
                                    NtHeaders->OptionalHeader.MajorSubsystemVersion,
                                    NtHeaders->OptionalHeader.MinorSubsystemVersion,
                                    NtHeaders->OptionalHeader.CheckSum
                                  );
                        }

                        if (!FlushViewOfFile( BaseAddress, FileLength )) {
                            if (!fQuiet) {
                                fprintf( stderr,
                                         "VERFIX: Flush of %s failed (%u)\n",
                                         ImageName,
                                         GetLastError()
                                       );
                            }
                        }

                        UnmapViewOfFile( BaseAddress );
                        if (!TouchFileTimes( FileHandle, NULL )) {
                            if (!fQuiet) {
                                fprintf( stderr, "VERFIX: Unable to touch file %s (%u)\n", ImageName, GetLastError() );
                            }
                        }

                        CloseHandle( FileHandle );
                    }
                }
            }
        }
NextArgument:
        --argc;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\vwndia64.c ===
/**
***  Copyright  (C) 1996-1999 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
****************************************************************************
***
*** WARNING: ntos\rtl\ia64\vunwind.c and sdktools\imagehlp\vwndia64.c are
***          identical. For sake of maintenance and for debug purposes, 
**           please keep them as this. Thank you.
***
****************************************************************************
**/

#define _CROSS_PLATFORM_
#define _IA64REG_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "private.h"
#include "ia64inst.h"
#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"
#include <stdlib.h>

#ifdef _IMAGEHLP_SOURCE_

#define NOT_IMAGEHLP(E)
#define FUNCTION_ENTRY_IS_IMAGE_STYLE
#define RtlVirtualUnwind VirtualUnwindIa64
#define VUW_DEBUG_PRINT OutputDebugString

#else  // !_IMAGEHLP_SOURCE_

#define NOT_IMAGEHLP(E) E
#define VUW_DEBUG_PRINT DbgPrint

#endif // !_IMAGEHLP_SOURCE_

#ifdef MASK
#undef MASK
#endif // MASK
#define MASK(bp,value)  (value << bp)

//
// ABI values
//

#define SVR4_ABI      0
#define HPUX_ABI      1
#define NT_ABI        2


#ifdef KERNEL_DEBUGGER
#define FUNCTION_ENTRY_IS_IMAGE_STYLE
#define RtlVirtualUnwind VirtualUnwind
#endif

#define STATE_RECORD_STACK_SIZE 32

#define SPILLSIZE_OF_FLOAT128_IN_DWORDS   4
#define SPILLSIZE_OF_ULONGLONG_IN_DWORDS  2

#define REGISTER_SIZE                sizeof(ULONGLONG)
#define STATIC_REGISTER_SET_SIZE     32
#define SLOTS_PER_BUNDLE             3

#define R1_MASK              0xC0
#define R1_PREFIX            0x0
#define R1_REGION_TYPE_MASK  0x20
#define R1_LENGTH_MASK       0x1F

#define R2_MASK              0xE0
#define R2_PREFIX            0x40

#define R3_MASK              0xE0
#define R3_PREFIX            0x60
#define R3_REGION_TYPE_MASK  0x3

#define P1_MASK              0xE0
#define P1_PREFIX            0x80
#define P2_MASK              0xF0
#define P2_PREFIX            0xA0
#define P3_MASK              0xF8
#define P3_PREFIX            0xB0
#define P4_MASK              0xFF
#define P4_PREFIX            0xB8
#define P5_MASK              0xFF
#define P5_PREFIX            0xB9
#define P6_MASK              0xE0
#define P6_PREFIX            0xC0
#define P7_MASK              0xF0
#define P7_PREFIX            0xE0
#define P8_MASK              0xFF
#define P8_PREFIX            0xF0
#define P9_MASK              0xFF
#define P9_PREFIX            0xF1
#define P10_MASK             0xFF
#define P10_PREFIX           0xFF

#define B1_MASK              0xC0
#define B1_PREFIX            0x80
#define B1_TYPE_MASK         0x20
#define B1_LABEL_MASK        0x1F
#define B2_MASK              0xE0
#define B2_PREFIX            0xC0
#define B2_ECOUNT_MASK       0x1F
#define B3_MASK              0xF0
#define B3_PREFIX            0xE0
#define B4_MASK              0xF0
#define B4_PREFIX            0xF0
#define B4_TYPE_MASK         0x08

//
// P3 descriptor type
//

#define PSP_GR               0
#define RP_GR                1
#define PFS_GR               2
#define PREDS_GR             3
#define UNAT_GR              4
#define LC_GR                5
#define RP_BR                6
#define RNAT_GR              7
#define BSP_GR               8
#define BSPSTORE_GR          9
#define FPSR_GR              10
#define PRIUNAT_GR           11

//
// P7 descriptor type
//

#define MEM_STACK_F          0
#define MEM_STACK_V          1
#define SPILL_BASE           2
#define PSP_SPREL            3
#define RP_WHEN              4
#define RP_PSPREL            5
#define PFS_WHEN             6
#define PFS_PSPREL           7
#define PREDS_WHEN           8
#define PREDS_PSPREL         9
#define LC_WHEN              10
#define LC_PSPREL            11
#define UNAT_WHEN            12
#define UNAT_PSPREL          13
#define FPSR_WHEN            14
#define FPSR_PSPREL          15

//
// P8 descriptor type
//

#define PSP_PSPREL           0
#define RP_SPREL             1
#define PFS_SPREL            2
#define PREDS_SPREL          3
#define LC_SPREL             4
#define UNAT_SPREL           5
#define FPSR_SPREL           6
#define BSP_WHEN             7
#define BSP_PSPREL           8
#define BSP_SPREL            9
#define BSPSTORE_WHEN        10
#define BSPSTORE_PSPREL      11
#define BSPSTORE_SPREL       12
#define RNAT_WHEN            13
#define RNAT_PSPREL          14
#define RNAT_SPREL           15
#define PRIUNAT_WHEN         16
#define PRIUNAT_PSPREL       17
#define PRIUNAT_SPREL        18


#define STACK_POINTER_GR     12

#define FIRST_PRESERVED_GR                4
#define LAST_PRESERVED_GR                 7
#define NUMBER_OF_PRESERVED_GR            4

#define FIRST_LOW_PRESERVED_FR            2
#define LAST_LOW_PRESERVED_FR             5
#define NUMBER_OF_LOW_PRESERVED_FR        4

#define FIRST_HIGH_PRESERVED_FR           16
#define LAST_HIGH_PRESERVED_FR            31
#define NUMBER_OF_HIGH_PRESERVED_FR       16
#define NUMBER_OF_PRESERVED_FR            NUMBER_OF_LOW_PRESERVED_FR+NUMBER_OF_HIGH_PRESERVED_FR

#define FIRST_PRESERVED_BR                1
#define LAST_PRESERVED_BR                 5
#define NUMBER_OF_PRESERVED_BR            5

#define NUMBER_OF_PRESERVED_MISC          7

#define NUMBER_OF_PRESERVED_REGISTERS     12


#define REG_MISC_BASE        0
#define REG_PREDS            REG_MISC_BASE+0
#define REG_SP               REG_MISC_BASE+1
#define REG_PFS              REG_MISC_BASE+2
#define REG_RP               REG_MISC_BASE+3
#define REG_UNAT             REG_MISC_BASE+4
#define REG_LC               REG_MISC_BASE+5
#define REG_NATS             REG_MISC_BASE+6

#define REG_BR_BASE          REG_MISC_BASE+NUMBER_OF_PRESERVED_MISC

#define REG_FPSR             0xff // REG_MISC_BASE+7
#define REG_BSP              0xff // REG_MISC_BASE+8
#define REG_BSPSTORE         0xff // REG_MISC_BASE+9
#define REG_RNAT             0xff // REG_MISC_BASE+10

//
// Where is a preserved register saved?
//
//     1. stack general register
//     2. memory stack (pspoff)
//     3. memory stack (spoff)
//     4. branch register
//

#define GENERAL_REG          0
#define PSP_RELATIVE         1
#define SP_RELATIVE          2
#define BRANCH_REG           3


#define ADD_STATE_RECORD(States, RegionLength, DescBeginIndex)       \
    States.Top++;                                                    \
    States.Top->IsTarget = FALSE;                                    \
    States.Top->MiscMask = 0;                                        \
    States.Top->FrMask = 0;                                          \
    States.Top->GrMask = 0;                                          \
    States.Top->Label = (LABEL)0;                                    \
    States.Top->Ecount = 0;                                          \
    States.Top->RegionLen = RegionLength;                            \
    States.Top->RegionBegin = UnwindContext.SlotCount;               \
    States.Top->SpWhen = 0;                                          \
    States.Top->SpAdjustment = 0;                                    \
    States.Top->SpillBase = (States.Top-1)->SpillPtr;                \
    States.Top->SpillPtr = (States.Top-1)->SpillPtr;                 \
    States.Top->Previous = States.Current;                           \
    States.Top->DescBegin = DescBeginIndex;                          \
    States.Current = States.Top


#define VALID_LABEL_BIT_POSITION    15

#define LABEL_REGION(Region, Label)                                    \
    Region->Label = Label;                                             \
    Region->MiscMask |= (1 << VALID_LABEL_BIT_POSITION)

#define IS_REGION_LABELED(Region)  \
    (Region->MiscMask & (1 << VALID_LABEL_BIT_POSITION))

#define CHECK_LABEL(State, Label) \
    ( (IS_REGION_LABELED(State)) && (Label == State->Label) )


#define EXTRACT_NAT_FROM_UNAT(NatBit)  \
    NatBit = (UCHAR)((IntNats >> (((ULONG_PTR)Source & 0x1F8) >> 3)) & 0x1);


#if DBG
int UnwindDebugLevel = 0;
# ifdef _IMAGEHLP_SOURCE_
#  define UW_DEBUG(x) if (UnwindDebugLevel) dbPrint##x
# else
#  define UW_DEBUG(x) if (UnwindDebugLevel) DbgPrint##x
# endif
#else
# define UW_DEBUG(x)
#endif // DBG



typedef struct _REGISTER_RECORD {
    ULONG Where : 2;                  // 2-bit field
    ULONG SaveOffset : 30;            // 30 bits for offset, big enough?
    ULONG When;                       // slot offset relative to region
} REGISTER_RECORD, *PREGISTER_RECORD;

typedef ULONG LABEL;

typedef struct _STATE_RECORD {
    struct _STATE_RECORD *Previous;   // pointer to outer nested prologue
    BOOLEAN IsTarget;       // TRUE if the control pc is in this prologue
    UCHAR GrMask;           // Mask that specifies which GRs to be restored
    USHORT MiscMask;        // Mask that specifies which BRs and misc. registers
                            // are to be restored.
                            // N.B. MSBit indicates Label is valid or not.
    ULONG FrMask;           // Mask that specifies which FRs to be restored
    ULONG SpAdjustment;     // size of stack frame allocated in the prologue
    ULONG SpWhen;           // slot offset relative to region
    ULONG SpillPtr;         // current spill location
    ULONG SpillBase;        // spill base of the region
    ULONG RegionBegin;      // first slot of region relative to function entry
    ULONG RegionLen;        // number of slots in the region
    LABEL Label;            // label that identifies a post-prologue state
    ULONG Ecount;           // number of prologue regions to pop
    ULONG DescBegin;        // first prologue descriptor for the region
    ULONG DescEnd;          // last prologue descriptor for the region
} STATE_RECORD, *PSTATE_RECORD;

typedef struct _UNWIND_CONTEXT {
    REGISTER_RECORD MiscRegs[NUMBER_OF_PRESERVED_REGISTERS];
    REGISTER_RECORD Float[NUMBER_OF_PRESERVED_FR];
    REGISTER_RECORD Integer[NUMBER_OF_PRESERVED_GR];
    BOOLEAN ActiveRegionFound;
    USHORT Version;
    PUCHAR Descriptors;               // beginning of descriptor data
    ULONG Size;                       // total size of all descriptors
    ULONG DescCount;                  // number of descriptor bytes processed
    ULONG TargetSlot;
    ULONG SlotCount;
} UNWIND_CONTEXT, *PUNWIND_CONTEXT;

typedef struct _STATE_RECORD_STACK {
    ULONG Size;
    PSTATE_RECORD Current;
    PSTATE_RECORD Top;
    PSTATE_RECORD Base;
} STATE_RECORD_STACK, *PSTATE_RECORD_STACK;

#define OFFSET(type, field) ((ULONG_PTR)(&((type *)0)->field))

static USHORT MiscContextOffset[NUMBER_OF_PRESERVED_REGISTERS] = {
    OFFSET(IA64_CONTEXT, Preds),
    OFFSET(IA64_CONTEXT, IntSp),
    OFFSET(IA64_CONTEXT, RsPFS),
    OFFSET(IA64_CONTEXT, BrRp),
    OFFSET(IA64_CONTEXT, ApUNAT),
    OFFSET(IA64_CONTEXT, ApLC),
    0,
    OFFSET(IA64_CONTEXT, BrS0),
    OFFSET(IA64_CONTEXT, BrS1),
    OFFSET(IA64_CONTEXT, BrS2),
    OFFSET(IA64_CONTEXT, BrS3),
    OFFSET(IA64_CONTEXT, BrS4)
};

static USHORT MiscContextPointersOffset[NUMBER_OF_PRESERVED_REGISTERS] = {
    OFFSET(IA64_KNONVOLATILE_CONTEXT_POINTERS, Preds),
    OFFSET(IA64_KNONVOLATILE_CONTEXT_POINTERS, IntSp),
    OFFSET(IA64_KNONVOLATILE_CONTEXT_POINTERS, RsPFS),
    OFFSET(IA64_KNONVOLATILE_CONTEXT_POINTERS, BrRp),
    OFFSET(IA64_KNONVOLATILE_CONTEXT_POINTERS, ApUNAT),
    OFFSET(IA64_KNONVOLATILE_CONTEXT_POINTERS, ApLC),
    0,
    OFFSET(IA64_KNONVOLATILE_CONTEXT_POINTERS, BrS0),
    OFFSET(IA64_KNONVOLATILE_CONTEXT_POINTERS, BrS1),
    OFFSET(IA64_KNONVOLATILE_CONTEXT_POINTERS, BrS2),
    OFFSET(IA64_KNONVOLATILE_CONTEXT_POINTERS, BrS3),
    OFFSET(IA64_KNONVOLATILE_CONTEXT_POINTERS, BrS4)
};

static UCHAR P3RecordTypeToRegisterIndex[] =
    {REG_SP, REG_RP, REG_PFS, REG_PREDS, REG_UNAT, REG_LC, REG_RP};

static UCHAR P7RecordTypeToRegisterIndex[] =
    {0, REG_SP, 0, REG_SP, REG_RP, REG_RP, REG_PFS, REG_PFS, REG_PREDS,
     REG_PREDS, REG_LC, REG_LC, REG_UNAT, REG_UNAT, REG_FPSR, REG_FPSR};

static UCHAR P8RecordTypeToRegisterIndex[] =
    {REG_SP, REG_RP, REG_PFS, REG_PREDS, REG_LC, REG_UNAT, REG_FPSR,
     REG_BSP, REG_BSP, REG_BSP, REG_BSPSTORE, REG_BSPSTORE, REG_BSPSTORE,
     REG_RNAT, REG_RNAT, REG_RNAT, REG_NATS, REG_NATS, REG_NATS};

UCHAR
NewParsePrologueRegionPhase0 (
    IN PUNWIND_CONTEXT UwContext,
    IN PSTATE_RECORD StateRecord,
    IN OUT PUCHAR AbiImmContext
    );

VOID
NewParsePrologueRegionPhase1 (
    IN PUNWIND_CONTEXT UwContext,
    IN PSTATE_RECORD StateRecord
    );


VOID
SrInitialize (
    IN PSTATE_RECORD_STACK StateTable,
    IN PSTATE_RECORD StateRecord,
    IN ULONG Size
    )
{
    StateTable->Size = Size;
    StateTable->Base = StateRecord;
    StateTable->Top = StateRecord;
    StateTable->Current = StateRecord;
    RtlZeroMemory(StateTable->Top, sizeof(STATE_RECORD));
}


ULONG
ReadLEB128 (
    IN PUCHAR Descriptors,
    IN OUT PULONG CurrentDescIndex
    )
{
    PUCHAR Buffer;
    ULONG Value;
    ULONG ShiftCount = 7;
    ULONG Count;

    Buffer = Descriptors + *CurrentDescIndex;
    Count = 1;

    Value = Buffer[0] & 0x7F;
    if (Buffer[0] & 0x80) {
        while (TRUE) {
            Value += ((Buffer[Count] & 0x7F) << ShiftCount);
            if (Buffer[Count++] & 0x80) {
                ShiftCount += 7;
            } else {
                break;
            }
        }
    }

    *CurrentDescIndex += Count;

    return Value;
}


ULONGLONG
RestorePreservedRegisterFromGR (
    IN PIA64_CONTEXT Context,
    IN SHORT BsFrameSize,
    IN SHORT RNatSaveIndex,
    IN SHORT GrNumber,
#ifdef _IMAGEHLP_SOURCE_
    IN HANDLE hProcess,
    IN PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
    OUT BOOL *Succeed,
#else
    OUT ULONG64 *SourceAddress,
#endif // _IMAGEHLP_SOURCE_
    OUT PUCHAR Nat OPTIONAL
    )
{
    ULONGLONG Result;
    SHORT Offset;
    SHORT Temp;
#ifdef _IMAGEHLP_SOURCE_
    ULONG Size;
#endif // _IMAGEHLP_SOURCE_

#ifdef _IMAGEHLP_SOURCE_
    *Succeed = FALSE;
#endif // _IMAGEHLP_SOURCE_

    if (GrNumber >= STATIC_REGISTER_SET_SIZE) {

        Offset = GrNumber - STATIC_REGISTER_SET_SIZE;
        if ( Offset < BsFrameSize ) {

            Temp = Offset + RNatSaveIndex - IA64_NAT_BITS_PER_RNAT_REG;
            while (Temp >= 0) {
                Offset++;
                Temp -= IA64_NAT_BITS_PER_RNAT_REG;
            }
            Offset = Offset * sizeof(ULONGLONG);

#ifdef _IMAGEHLP_SOURCE_
            *Succeed = ReadMemory(hProcess, Context->RsBSP + Offset,
                                  &Result, sizeof(ULONGLONG), &Size);
#else
            *SourceAddress = (ULONG64)(Context->RsBSP + Offset);
            Result = *(PULONGLONG)(Context->RsBSP + Offset);
#endif // _IMAGEHLP_SOURCE_

        } else {

            UW_DEBUG(("ERROR: Invalid GR!\n"));
        }

    } else {

        if (GrNumber == 0 || GrNumber == 12) {

            //
            // Invalid GR number -> Invalid Unwind Descriptor
            //

            UW_DEBUG(("ERROR: Invalid GR!\n"));

        } else {

            UW_DEBUG(("WARNING: Target register is not a stacked GR!\n"));
            Offset = GrNumber - 1;
            NOT_IMAGEHLP(*SourceAddress = (ULONG64)(&Context->IntGp + Offset));
            Result = *(&Context->IntGp + Offset);

#ifdef _IMAGEHLP_SOURCE_
            *Succeed = TRUE;
#endif // _IMAGEHLP_SOURCE_

        }
    }

    if (ARGUMENT_PRESENT(Nat)) {

        //
        // TBD: Pick up the corresponding Nat bit
        //

        *Nat = (UCHAR) 0;

    }

    return (Result);
}


UCHAR
ParseBodyRegionDescriptors (
    IN PUNWIND_CONTEXT UnwindContext,
    IN PSTATE_RECORD_STACK StateTable,
    IN ULONG RegionLen
    )
{
    LABEL Label;
    UCHAR FirstByte;
    BOOLEAN EcountDefined;
    BOOLEAN CopyLabel;
    ULONG Ecount;
    ULONG SlotOffset;
    PSTATE_RECORD StateTablePtr;
    PUCHAR Descriptors;

    CopyLabel = EcountDefined = FALSE;
    Descriptors = UnwindContext->Descriptors;

    while (UnwindContext->DescCount < UnwindContext->Size) {

        FirstByte = Descriptors[UnwindContext->DescCount++];

        if ( (FirstByte & B1_MASK) == B1_PREFIX ) {

            Label = (LABEL)(FirstByte & B1_LABEL_MASK);
            if (FirstByte & B1_TYPE_MASK) {

                //
                // copy the entry state
                //

                CopyLabel = TRUE;

            } else {

                //
                // label the entry state
                //

                LABEL_REGION(StateTable->Top, Label);
            }

            UW_DEBUG(("Body region desc B1: copy=%d, label_num=%d\n",
                     FirstByte & B1_TYPE_MASK ? TRUE : FALSE, Label));

        } else if ( (FirstByte & B2_MASK) == B2_PREFIX ) {

            Ecount = FirstByte & B2_ECOUNT_MASK;
            SlotOffset = ReadLEB128(Descriptors, &UnwindContext->DescCount);
            EcountDefined = TRUE;

            UW_DEBUG(("Epilog desc B2: ecount=%d, LEB128(slot)=%d\n",
                      Ecount, SlotOffset));

        } else if ( (FirstByte & B3_MASK) == B3_PREFIX ) {

            SlotOffset = ReadLEB128(Descriptors, &UnwindContext->DescCount);
            Ecount = ReadLEB128(Descriptors, &UnwindContext->DescCount);
            EcountDefined = TRUE;

            UW_DEBUG(("Epilog desc B3: ecount=%d, LEB128 val=%d\n",
                      Ecount, SlotOffset));

        } else if ( (FirstByte & B4_MASK) == B4_PREFIX ) {

            Label = ReadLEB128(Descriptors, &UnwindContext->DescCount);

            if (FirstByte & B4_TYPE_MASK) {

                //
                // copy the entry state
                //

                CopyLabel = TRUE;

            } else {

                //
                // label the current top of stack
                //

                LABEL_REGION(StateTable->Top, Label);
            }

            UW_DEBUG(("Body region desc B4: copy=%d, label_num=%d\n",
                     FirstByte & B4_TYPE_MASK, Label));

        } else {

            //
            // Encounter another region header record
            //

            break;
        }
    }

    if (CopyLabel) {
        StateTablePtr = StateTable->Top;
        while (TRUE) {
            if (CHECK_LABEL(StateTablePtr, Label)) {
                StateTable->Current = StateTablePtr;
                break;
            } else if ((StateTablePtr == StateTable->Base)) {
                UW_DEBUG(("Undefined Label %d\n", Label));
                break;
            }
            StateTablePtr--;
        }
    }

    if (EcountDefined) {

        Ecount++;    // Ecount specifies additional level of prologue
                     // regions to undo (i.e. a value of 0 implies 1
                     // prologue region)

        if (UnwindContext->ActiveRegionFound == FALSE) {
            while (Ecount-- > 0) {
                if (StateTable->Current->Previous) {
                    StateTable->Current = StateTable->Current->Previous;
                }

#if DBG
                else {
                    UW_DEBUG(("WARNING: Ecount is greater than the # of active prologues!\n"));
                }
#endif // DBG

            }
        } else {

            //
            // control PC is in this body/epilog region
            //

            if ((UnwindContext->SlotCount + RegionLen - SlotOffset)
                    <= UnwindContext->TargetSlot)
            {
                PSTATE_RECORD SrPointer;

                StateTable->Current->Ecount = Ecount;
                SrPointer = StateTable->Current;
                while (Ecount > 0) {

                    if (SrPointer->Previous) {
                        SrPointer->Ecount = Ecount;
                        SrPointer->SpWhen = 0;
                        SrPointer->SpAdjustment = 0;
                        SrPointer = SrPointer->Previous;
                    }

#if DBG
                    else {
                        UW_DEBUG(("WARNING: Ecount is greater than the # of active prologues!\n"));
                    }
#endif // DBG
                    Ecount--;

                }
            }
        }
    }

    return FirstByte;
}


ULONGLONG
ProcessInterruptRegion (
#ifdef _IMAGEHLP_SOURCE_
    IN HANDLE hProcess,
    IN PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory,
#else
    IN PIA64_KNONVOLATILE_CONTEXT_POINTERS ContextPointers,
#endif _IMAGEHLP_SOURCE_
    IN PUNWIND_CONTEXT UnwindContext,
    IN PIA64_CONTEXT Context,
    IN SHORT BsFrameSize,
    IN SHORT RNatSaveIndex,
    IN UCHAR AbiImmContext
    )
{
    //
    // no prologue descriptor in interrupt region.
    //

    PIA64_CONTEXT PrevContext;
    ULONGLONG NextPc;
    ULONG Index;
    SHORT TempFrameSize;
    BOOLEAN Success;
#ifdef _IMAGEHLP_SOURCE_
    ULONG Size;
#else
    PVOID *Source;
    PVOID Address;
#endif _IMAGEHLP_SOURCE_


    if (AbiImmContext != IA64_CONTEXT_FRAME) {

        PIA64_KTRAP_FRAME TrapFrame;
        PIA64_KEXCEPTION_FRAME ExFrame;
#ifdef _IMAGEHLP_SOURCE_
        IA64_KTRAP_FRAME TF;
        IA64_KEXCEPTION_FRAME ExF;
#endif // _IMAGEHLP_SOURCE_

        TrapFrame = (PIA64_KTRAP_FRAME) Context->IntSp;
#ifdef _IMAGEHLP_SOURCE_
        if (!ReadMemory(hProcess, Context->IntSp, &TF, sizeof(IA64_KTRAP_FRAME), &Size))
        {
            return 0;
        }
        TrapFrame = &TF;
#endif // _IMAGEHLP_SOURCE_

        Context->ApDCR = TrapFrame->ApDCR;
        Context->ApUNAT = TrapFrame->ApUNAT;
        Context->StFPSR = TrapFrame->StFPSR;
        Context->Preds = TrapFrame->Preds;
        Context->IntSp = TrapFrame->IntSp;
        Context->StIPSR = TrapFrame->StIPSR;
        Context->StIFS = TrapFrame->StIFS;
        Context->BrRp = TrapFrame->BrRp;
        Context->RsPFS = TrapFrame->RsPFS;

#ifndef _IMAGEHLP_SOURCE_
        if (ARGUMENT_PRESENT(ContextPointers)) {
            ContextPointers->ApUNAT = &TrapFrame->ApUNAT;
            ContextPointers->IntSp = &TrapFrame->IntSp;
            ContextPointers->BrRp = &TrapFrame->BrRp;
            ContextPointers->RsPFS = &TrapFrame->RsPFS;
            ContextPointers->Preds = &TrapFrame->Preds;
        }
#endif // _IMAGEHLP_SOURCE_

        switch (AbiImmContext) {

        case IA64_SYSCALL_FRAME:

            //
            // System Call Handler Frame
            //

            BsFrameSize = (SHORT)(TrapFrame->StIFS >> IA64_PFS_SIZE_SHIFT);
            BsFrameSize &= IA64_PFS_SIZE_MASK;
            break;

        case IA64_INTERRUPT_FRAME:
        case IA64_EXCEPTION_FRAME:

            //
            // External Interrupt Frame / Exception Frame
            //

            BsFrameSize = (SHORT)TrapFrame->StIFS & IA64_PFS_SIZE_MASK;
            break;

        default:

            break;
        }

        RNatSaveIndex = (SHORT)(TrapFrame->RsBSP >> 3) & IA64_NAT_BITS_PER_RNAT_REG;
        TempFrameSize = BsFrameSize - RNatSaveIndex;
        while (TempFrameSize > 0) {
            BsFrameSize++;
            TempFrameSize -= IA64_NAT_BITS_PER_RNAT_REG;
        }

        Context->RsBSP = TrapFrame->RsBSP - BsFrameSize * sizeof(ULONGLONG);
        Context->RsBSPSTORE = Context->RsBSP;
        Context->RsRNAT = TrapFrame->RsRNAT;

        NextPc = Ia64InsertIPSlotNumber(TrapFrame->StIIP,
                     ((TrapFrame->StIPSR >> PSR_RI) & 0x3));

        return (NextPc);
    }

    //
    // Kernel-to-User thunk, context of the previous frame can be
    // found on the user stack (i.e. context's address = sp+SCRATCH_AREA)
    //

    PrevContext = (PIA64_CONTEXT)(Context->IntSp + IA64_STACK_SCRATCH_AREA);
#ifdef _IMAGEHLP_SOURCE_
    if (!ReadMemory(hProcess, (DWORD64)PrevContext, Context, sizeof(IA64_CONTEXT), &Size))
    {
        return 0;
    }
    NextPc = Ia64InsertIPSlotNumber(Context->StIIP,
                                       ((Context->StIPSR >> PSR_RI) & 0x3));
#else

    RtlCopyMemory(&Context->BrRp, &PrevContext->BrRp,
                  (NUMBER_OF_PRESERVED_BR+1) * sizeof(ULONGLONG));
    RtlCopyMemory(&Context->FltS0, &PrevContext->FltS0,
                  NUMBER_OF_LOW_PRESERVED_FR * sizeof(FLOAT128));
    RtlCopyMemory(&Context->FltS4, &PrevContext->FltS4,
                  NUMBER_OF_HIGH_PRESERVED_FR * sizeof(FLOAT128));
    RtlCopyMemory(&Context->IntS0, &PrevContext->IntS0,
                  NUMBER_OF_PRESERVED_GR * sizeof(ULONGLONG));

    Context->IntSp = PrevContext->IntSp;
    Context->IntNats = PrevContext->IntNats;
    Context->ApUNAT = PrevContext->ApUNAT;
    Context->ApLC = PrevContext->ApLC;
    Context->ApEC = PrevContext->ApEC;
    Context->Preds = PrevContext->Preds;
    Context->RsPFS = PrevContext->RsPFS;
    Context->RsBSP = PrevContext->RsBSP;
    Context->RsBSPSTORE = PrevContext->RsBSPSTORE;
    Context->RsRSC = PrevContext->RsRSC;
    Context->RsRNAT = PrevContext->RsRNAT;
    Context->StIFS = PrevContext->StIFS;
    Context->StIPSR = PrevContext->StIPSR;
    NextPc = Ia64InsertIPSlotNumber(PrevContext->StIIP,
                 ((PrevContext->StIPSR >> PSR_RI) & 0x3));

#endif // _IMAGEHLP_SOURCE_

    return(NextPc);
}


ULONGLONG
RtlVirtualUnwind (
#ifdef _IMAGEHLP_SOURCE_
    HANDLE hProcess,
    ULONGLONG ImageBase,
    ULONGLONG ControlPc,
    PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY FunctionEntry,
    PIA64_CONTEXT ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory
#define ContextPointers ((PIA64_KNONVOLATILE_CONTEXT_POINTERS)0)
#else
    IN ULONGLONG ImageBase,
    IN ULONGLONG ControlPc,
    IN PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY FunctionEntry,
    IN OUT PIA64_CONTEXT ContextRecord,
    OUT PBOOLEAN InFunction,
    OUT PFRAME_POINTERS EstablisherFrame,
    IN OUT PIA64_KNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL
#endif
    )

/*++

Routine Description:

    This function virtually unwinds the specfified function by executing its
    prologue code backwards.

    If the function is a leaf function, then the address where control left
    the previous frame is obtained from the context record. If the function
    is a nested function, but not an exception or interrupt frame, then the
    prologue code is executed backwards and the address where control left
    the previous frame is obtained from the updated context record.

    Otherwise, an exception or interrupt entry to the system is being unwound
    and an especially coded prologue restores the return address twice. Once
    from the fault instruction address and once from the saved return address
    register. The first restore is returned as the function value and the
    second restore is placed in the updated context record.

    If a context pointers record is specified, then the address where each
    nonvolatile registers is restored from is recorded in the appropriate
    element of the context pointers record.

Arguments:

    ImageBase - Supplies the base address of the module to which the
        function belongs.

    ControlPc - Supplies the address where control left the specified
        function.

    FunctionEntry - Supplies the address of the function table entry for the
        specified function.

    ContextRecord - Supplies the address of a context record.

    InFunction - Supplies a pointer to a variable that receives whether the
        control PC is within the current function.

    EstablisherFrame - Supplies a pointer to a variable that receives the
        the establisher frame pointer value.

    ContextPointers - Supplies an optional pointer to a context pointers
        record.

Return Value:

    The address where control left the previous frame is returned as the
    function value.

--*/

{
#ifdef _IMAGEHLP_SOURCE_
    BOOL Succeed;
#endif // _IMAGEHLP_SOURCE_
    PUCHAR Descriptors = NULL;
    UCHAR AbiImmContext = 0xFF;
    ULONG Mask;
    ULONGLONG NextPc;
    ULONG RegionLen;
    UCHAR FirstByte;
    UCHAR Nat;
    SHORT BsFrameSize;                  // in 8-byte units
    SHORT LocalFrameSize;                  // in 8-byte units
    SHORT TempFrameSize;                // in 8-byte units
    SHORT RNatSaveIndex;
    ULONG i;
    PULONG Buffer;
    BOOLEAN IsPrologueRegion;
    BOOLEAN PspRestored;
    ULONGLONG PreviousIntSp;
    PVOID Destination;
    ULONG64 Source;
    ULONG64 *CtxPtr;
    ULONG64 *NatCtxPtr;
    ULONG64 IntNatsSource;
    ULONG64 IntNats;
    ULONG Size;
    ULONGLONG OldTopRnat;
    ULONGLONG NewTopRnat;
    IA64_UNWIND_INFO UnwindInfo;
    ULONG64 UnwindInfoPtr;
    UNWIND_CONTEXT UnwindContext;
    PSTATE_RECORD SrPointer;
    STATE_RECORD_STACK StateTable;
    STATE_RECORD StateRecords[STATE_RECORD_STACK_SIZE];


    BsFrameSize = (SHORT)ContextRecord->StIFS & IA64_PFS_SIZE_MASK;
    RNatSaveIndex = (SHORT)(ContextRecord->RsBSP >> 3) & IA64_NAT_BITS_PER_RNAT_REG;
    TempFrameSize = RNatSaveIndex + BsFrameSize - IA64_NAT_BITS_PER_RNAT_REG;
    while (TempFrameSize >= 0) {
        BsFrameSize++;
        TempFrameSize -= IA64_NAT_BITS_PER_RNAT_REG;
    }

    UnwindInfoPtr = ImageBase + FunctionEntry->UnwindInfoAddress;
#ifdef _IMAGEHLP_SOURCE_
    if (!ReadMemory( hProcess, (ULONG64)UnwindInfoPtr,
                     &UnwindInfo, sizeof(IA64_UNWIND_INFO), &Size))
    {
        return 0;
    }

    UnwindContext.Version = UnwindInfo.Version;
    Size = UnwindInfo.DataLength * sizeof(ULONGLONG);
    if (Size) {
        Descriptors = (PUCHAR) MemAlloc (Size);
        if (!ReadMemory(hProcess,(ULONG64)(UnwindInfoPtr+sizeof(IA64_UNWIND_INFO)), Descriptors, Size, &Size)) {
            return 0;
        }
    }
#else
    UnwindContext.Version = ((PIA64_UNWIND_INFO)UnwindInfoPtr)->Version;
    Size = ((PIA64_UNWIND_INFO)UnwindInfoPtr)->DataLength * sizeof(ULONGLONG);
    Descriptors = (PUCHAR)UnwindInfoPtr + sizeof(IA64_UNWIND_INFO);
#endif // _IMAGEHLP_SOURCE_

    UnwindContext.Size = Size;
    UnwindContext.ActiveRegionFound = FALSE;
    UnwindContext.DescCount = 0;
    UnwindContext.SlotCount = 0;
    UnwindContext.TargetSlot = (ULONG)(((ControlPc - FunctionEntry->BeginAddress - ImageBase) >> 4) * SLOTS_PER_BUNDLE + ((ControlPc >> 2) & 0x3));
    UnwindContext.Descriptors = Descriptors;

    SrInitialize(&StateTable, StateRecords, STATE_RECORD_STACK_SIZE);

    if (Size) {
        FirstByte = Descriptors[UnwindContext.DescCount++];
    }


    while ( (UnwindContext.DescCount < UnwindContext.Size) &&
            (!UnwindContext.ActiveRegionFound) )
    {

        //
        // Assume a prologue region but not an interrupt region.
        //

        IsPrologueRegion = TRUE;

        //
        // Based on the type of region header, dispatch
        // to the corresponding routine that processes
        // the succeeding descriptors until the next
        // region header record.
        //

        if ((FirstByte & R1_MASK) == R1_PREFIX) {

            //
            // region header record in short format
            //

            RegionLen = FirstByte & R1_LENGTH_MASK;

            if (FirstByte & R1_REGION_TYPE_MASK) {
                IsPrologueRegion = FALSE;
            } else {
                ADD_STATE_RECORD(StateTable, RegionLen, UnwindContext.DescCount);
            }

            UW_DEBUG(("Region R1 format: body=%x, length=%d\n",
                     IsPrologueRegion ? 0 : 1, RegionLen));

        } else if ((FirstByte & R2_MASK) == R2_PREFIX) {

            //
            // general prologue region header
            // N.B. Skip the 2nd byte of the header and proceed to read
            //      the region length; the header descriptors will be
            //      processed again in phase 1.
            //

            ULONG R2DescIndex;

            R2DescIndex = UnwindContext.DescCount - 1;
            UnwindContext.DescCount++;
            RegionLen = ReadLEB128(Descriptors, &UnwindContext.DescCount);
            ADD_STATE_RECORD(StateTable, RegionLen, R2DescIndex);
            UW_DEBUG(("Region R2: body=0, length=%d\n", RegionLen));

        } else if ((FirstByte & R3_MASK) == R3_PREFIX) {

            //
            // region header record in long format
            //

            RegionLen = ReadLEB128(Descriptors, &UnwindContext.DescCount);

            switch (FirstByte & R3_REGION_TYPE_MASK) {

            case 0:      // prologue region header

                ADD_STATE_RECORD(StateTable, RegionLen, UnwindContext.DescCount);
                break;

            case 1:      // body region header

                IsPrologueRegion = FALSE;
                break;

            }

            UW_DEBUG(("Region R3: body=%x, length=%d\n",
                      IsPrologueRegion ? 0 : 1, RegionLen));

        } else {

            //
            // Not a region header record -> Invalid unwind descriptor.
            //

            UW_DEBUG(("Invalid unwind descriptor!\n"));

        }

        if (UnwindContext.TargetSlot < (UnwindContext.SlotCount + RegionLen)) {
            UnwindContext.ActiveRegionFound = TRUE;
            StateTable.Current->IsTarget = IsPrologueRegion;
        }

        if (IsPrologueRegion) {
            FirstByte = NewParsePrologueRegionPhase0(&UnwindContext,
                                                     StateTable.Current,
                                                     &AbiImmContext);
        } else {
            FirstByte = ParseBodyRegionDescriptors(&UnwindContext,
                                                   &StateTable,
                                                   RegionLen);
        }

        UnwindContext.SlotCount += RegionLen;
    }

    //
    // Restore the value of psp and save the current NatCr.
    // N.B. If the value is restored from stack/bstore, turn off the
    //      corresponding sp bit in the saved mask associated with the
    //      prologue region in which psp is saved.
    //

    if (ARGUMENT_PRESENT(ContextPointers)) {
        IntNatsSource = (ULONG64)ContextPointers->ApUNAT;
    } 
    IntNats = ContextRecord->ApUNAT;
    PreviousIntSp = ContextRecord->IntSp;
    PspRestored = FALSE;

    SrPointer = StateTable.Current;
    while (SrPointer != StateTable.Base) {
        NewParsePrologueRegionPhase1(&UnwindContext, SrPointer);

        if (SrPointer->MiscMask & (1 << REG_SP)) {
            if (UnwindContext.MiscRegs[REG_SP].Where == GENERAL_REG) {
                PreviousIntSp = RestorePreservedRegisterFromGR (
                                    ContextRecord,
                                    BsFrameSize,
                                    RNatSaveIndex,
                                    (SHORT)UnwindContext.MiscRegs[REG_SP].SaveOffset,
#ifdef _IMAGEHLP_SOURCE_
                                    hProcess,
                                    ReadMemory,
                                    &Succeed,
#else
                                    &Source,
#endif // _IMAGEHLP_SOURCE_
                                    &Nat
                                    );
#ifdef _IMAGEHLP_SOURCE_
                if (!Succeed) {
                    return 0;
                }
#endif // _IMAGEHLP_SOURCE_

            } else {

                Source = ContextRecord->IntSp + UnwindContext.MiscRegs[REG_SP].SaveOffset*4;
#ifdef _IMAGEHLP_SOURCE_
                if (!ReadMemory(hProcess, (ULONG64)(Source), &PreviousIntSp, sizeof(ULONGLONG), &Size)) {
                    return 0;
                }
#else
                PreviousIntSp = *(PULONGLONG)Source;
#endif // _IMAGEHLP_SOURCE_
                EXTRACT_NAT_FROM_UNAT(Nat);

            }
            ContextRecord->IntNats &= ~(0x1 << STACK_POINTER_GR);
            ContextRecord->IntNats |= (Nat << STACK_POINTER_GR);
            SrPointer->MiscMask &= ~(1 << REG_SP);
            if (ARGUMENT_PRESENT(ContextPointers)) {
                CtxPtr = (ULONG64 *)((ULONG_PTR)ContextPointers +
                                   MiscContextPointersOffset[REG_SP]);
                *CtxPtr = Source;
            }
            PspRestored = TRUE;
        }
        if (PspRestored == FALSE) {
            PreviousIntSp += SrPointer->SpAdjustment * 4;
        }
        SrPointer = SrPointer->Previous;
    }

    if (AbiImmContext != 0xFF) {

        ContextRecord->IntSp = PreviousIntSp;  // trap/context frame address
        NextPc = ProcessInterruptRegion(
#ifdef _IMAGEHLP_SOURCE_
                     hProcess,
                     ReadMemory,
#else
                     ContextPointers,
#endif _IMAGEHLP_SOURCE_
                     &UnwindContext,
                     ContextRecord,
                     BsFrameSize,
                     RNatSaveIndex,
                     AbiImmContext);

        goto FastExit;
    }

    //
    // Restore the contents of any preserved registers saved in this frame.
    //

    SrPointer = StateTable.Current;
    while (SrPointer != StateTable.Base) {

        Mask = SrPointer->MiscMask;
        UW_DEBUG(("MiscMask = 0x%x\n", Mask));

        for (i = 0; i < NUMBER_OF_PRESERVED_REGISTERS; i++) {
            Destination = (PVOID)((ULONG_PTR)ContextRecord + MiscContextOffset[i]);
            if (Mask & 0x1) {

                if (ARGUMENT_PRESENT(ContextPointers)) {
                    CtxPtr = (ULONG64 *)((ULONG_PTR)ContextPointers +
                                       MiscContextPointersOffset[i]);
                    Source = *CtxPtr;
                }

                if (UnwindContext.MiscRegs[i].Where == GENERAL_REG) {

                    *(PULONGLONG)Destination =
                        RestorePreservedRegisterFromGR (
                            ContextRecord,
                            BsFrameSize,
                            RNatSaveIndex,
                            (SHORT)UnwindContext.MiscRegs[i].SaveOffset,
#ifdef _IMAGEHLP_SOURCE_
                            hProcess,
                            ReadMemory,
                            &Succeed,
#else
                            &Source,
#endif // _IMAGEHLP_SOURCE_
                            NULL
                            );
#ifdef _IMAGEHLP_SOURCE_
                    if (!Succeed) {
                        return 0;
                    }
#endif // _IMAGEHLP_SOURCE_

                } else if (UnwindContext.MiscRegs[i].Where == BRANCH_REG) {

                    //
                    // restore return pointer from branch register
                    //

                    USHORT Offset;

                    Offset = (USHORT)UnwindContext.MiscRegs[i].SaveOffset-FIRST_PRESERVED_BR;
                    Source = (ULONG64)(&ContextRecord->BrS0 + Offset);
#ifdef _IMAGEHLP_SOURCE_
                    if (!ReadMemory(hProcess, (ULONG64)(Source), Destination, sizeof(ULONGLONG), &Size)) {
                        return 0;
                    }
#else
                    *(PULONGLONG)Destination = *(PULONGLONG)(Source);
#endif // _IMAGEHLP_SOURCE_

                } else if (UnwindContext.MiscRegs[i].Where == PSP_RELATIVE) {

                    if ((SrPointer->Ecount == 0) || (UnwindContext.MiscRegs[i].SaveOffset <= (IA64_STACK_SCRATCH_AREA/sizeof(ULONG)))) {
                        Source = PreviousIntSp + IA64_STACK_SCRATCH_AREA
                                     - UnwindContext.MiscRegs[i].SaveOffset*4;

                        if (i == REG_NATS) {
                            Destination = (PVOID)&IntNats;
                            IntNatsSource = Source;
                        }

#ifdef _IMAGEHLP_SOURCE_
                        if (!ReadMemory(hProcess, (ULONG64)(Source), Destination, sizeof(ULONGLONG), &Size)) {
                            return 0;
                        }
#else
                        *(PULONGLONG)Destination = *(PULONGLONG)(Source);
#endif // _IMAGEHLP_SOURCE_
                    }

                } else if (UnwindContext.MiscRegs[i].Where == SP_RELATIVE) {

                    //
                    // Make the necessary adjustment depending on whether
                    // the preserved register is saved before or after the
                    // stack pointer has been adjusted in this prologue.
                    //

                    if (UnwindContext.MiscRegs[i].When >= SrPointer->SpWhen)
                        Source = ContextRecord->IntSp
                                     + UnwindContext.MiscRegs[i].SaveOffset*4;
                    else
                        Source = ContextRecord->IntSp+SrPointer->SpAdjustment*4
                                     + UnwindContext.MiscRegs[i].SaveOffset*4;

                        if (i == REG_NATS) {
                            Destination = (PVOID)&IntNats;
                            IntNatsSource = Source;
                        }

#ifdef _IMAGEHLP_SOURCE_
                    if (!ReadMemory(hProcess, (ULONG64)(Source), Destination, sizeof(ULONGLONG), &Size)) {
                        return 0;
                    }
#else
                    *(PULONGLONG)Destination = *(PULONGLONG)(Source);
#endif // _IMAGEHLP_SOURCE_
                }

                if (ARGUMENT_PRESENT(ContextPointers) && (i != REG_NATS)) {
                    *CtxPtr = Source;
                }

            } else if (Mask == 0) {

                //
                // No more registers to restore
                //

                break;
            }

            Mask = Mask >> 1;
        }

        //
        // Restore preserved FRs (f2 - f5, f16 - f31)
        //

        Mask = SrPointer->FrMask;
        Destination = (PVOID)&ContextRecord->FltS0;
        CtxPtr = (ULONG64 *)&ContextPointers->FltS0;

        UW_DEBUG(("FrMask = 0x%x\n", Mask));
        for (i = 0; i < NUMBER_OF_PRESERVED_FR; i++) {
            if (Mask & 0x1) {

                if ((SrPointer->Ecount == 0) || (UnwindContext.Float[i].SaveOffset <= (IA64_STACK_SCRATCH_AREA/sizeof(ULONG)))) {
                    Source = PreviousIntSp + IA64_STACK_SCRATCH_AREA
                                 - UnwindContext.Float[i].SaveOffset*4;
#ifdef _IMAGEHLP_SOURCE_
                    if (!ReadMemory(hProcess, (ULONG64)(Source), Destination, sizeof(FLOAT128), &Size)) {
                        return 0;
                    }
#else
                    *(FLOAT128 *)Destination = *(FLOAT128 *)Source;
#endif // _IMAGEHLP_SOURCE_

                    if (ARGUMENT_PRESENT(ContextPointers)) {
                        *CtxPtr = Source;
                    }
                }

            } else if (Mask == 0) {
                break;
            }

            Mask = Mask >> 1;

            if (i == (NUMBER_OF_LOW_PRESERVED_FR - 1)) {
                Destination = (PVOID)&ContextRecord->FltS4;
                CtxPtr = (ULONG64 *)(&ContextPointers->FltS4);
            } else {
                Destination = (PVOID)((FLOAT128 *)Destination+1);
                CtxPtr++;
            }
        }

        //
        // Restore preserved GRs (r4 - r7)
        //

        Mask = SrPointer->GrMask;
        Destination = (PVOID)&ContextRecord->IntS0;
        CtxPtr = (ULONG64 *)&ContextPointers->IntS0;
        NatCtxPtr = (ULONG64 *)&ContextPointers->IntS0Nat;

        UW_DEBUG(("GrMask = 0x%x\n", Mask));
        for (i = 0; i < NUMBER_OF_PRESERVED_GR; i++)
        {
            if (Mask & 0x1) {

                if ((SrPointer->Ecount == 0) || (UnwindContext.Integer[i].SaveOffset <= (IA64_STACK_SCRATCH_AREA/sizeof(ULONG)))) {
                    Source = PreviousIntSp + IA64_STACK_SCRATCH_AREA
                                 - UnwindContext.Integer[i].SaveOffset*4;

#ifdef _IMAGEHLP_SOURCE_
                    if (!ReadMemory(hProcess, (ULONG64)(Source), Destination, sizeof(ULONGLONG), &Size)) {
                        return 0;
                    }
#else
                    *(PULONGLONG)Destination = *(PULONGLONG)Source;
#endif // _IMAGEHLP_SOURCE_
                    EXTRACT_NAT_FROM_UNAT(Nat);
                    Nat = (UCHAR)((IntNats >> (((ULONG_PTR)Source & 0x1F8) >> 3)) & 0x1);
                    ContextRecord->IntNats &= ~(0x1 << (i+FIRST_PRESERVED_GR));
                    ContextRecord->IntNats |= (Nat << (i+FIRST_PRESERVED_GR));

#ifndef _IMAGEHLP_SOURCE_
                    if (ARGUMENT_PRESENT(ContextPointers)) {
                        *CtxPtr = Source;
                        *NatCtxPtr = IntNatsSource;
                    }
#endif
                }

            } else if (Mask == 0) {
                break;
            }

            Mask = Mask >> 1;
            Destination = (PVOID)((PULONGLONG)Destination+1);
            CtxPtr++;
            NatCtxPtr++;
        }

        ContextRecord->IntSp += SrPointer->SpAdjustment * 4;
        SrPointer = SrPointer->Previous;
    }

    ContextRecord->IntSp = PreviousIntSp;

    //
    // Restore the value of the epilogue count from the PFS
    //

    ContextRecord->ApEC = (ContextRecord->RsPFS >> IA64_PFS_EC_SHIFT) &
                               ~(((ULONGLONG)1 << IA64_PFS_EC_SIZE) - 1);
    if (ARGUMENT_PRESENT(ContextPointers)) {
        ContextPointers->ApEC = ContextPointers->RsPFS;
    }


FastExit:

    NOT_IMAGEHLP(*InFunction = TRUE);
    NOT_IMAGEHLP(EstablisherFrame->MemoryStackFp = ContextRecord->IntSp);
    NOT_IMAGEHLP(EstablisherFrame->BackingStoreFp = ContextRecord->RsBSP);

#ifdef _IMAGEHLP_SOURCE_
    if (Descriptors)
        MemFree(Descriptors);
#endif // _IMAGEHLP_SOURCE_

    if (AbiImmContext == 0xFF) {

#ifdef _IMAGEHLP_SOURCE_
        NextPc = ContextRecord->BrRp;
#else
        NextPc = Ia64InsertIPSlotNumber((ContextRecord->BrRp-16), 2);
#endif // _IMAGEHLP_SOURCE_

        //
        // determine the local frame size of previous frame and compute
        // the new bsp.
        //

        OldTopRnat = (ContextRecord->RsBSP+(BsFrameSize-1)*8) | IA64_RNAT_ALIGNMENT;

        ContextRecord->StIFS = MASK(IA64_IFS_V, (ULONGLONG)1) | ContextRecord->RsPFS;
        BsFrameSize = (SHORT)ContextRecord->StIFS & IA64_PFS_SIZE_MASK;
        LocalFrameSize = (SHORT)(ContextRecord->StIFS >> IA64_PFS_SIZE_SHIFT) & IA64_PFS_SIZE_MASK;
        TempFrameSize = LocalFrameSize - RNatSaveIndex;
        while (TempFrameSize > 0) {
            LocalFrameSize++;
            BsFrameSize++;
            TempFrameSize -= IA64_NAT_BITS_PER_RNAT_REG;
        }
        ContextRecord->RsBSP -= LocalFrameSize * 8;
        ContextRecord->RsBSPSTORE = ContextRecord->RsBSP;

        //
        // determine if the RNAT field needs to be updated.
        //

        NewTopRnat = (ContextRecord->RsBSP+(BsFrameSize-1)*8) | IA64_RNAT_ALIGNMENT;

        if (NewTopRnat < OldTopRnat) {

#ifdef _IMAGEHLP_SOURCE_
            Destination = &ContextRecord->RsRNAT;
            Source = NewTopRnat;
            if (!ReadMemory(hProcess, (ULONG64)Source, Destination, 8, &Size)) {
                return 0;
            }
#else
            ContextRecord->RsRNAT = *(PULONGLONG)(NewTopRnat);
#endif // _IMAGEHLP_SOURCE_

        }
    }

#ifdef _IMAGEHLP_SOURCE_
    UW_DEBUG(("NextPc = 0x%lx, PSP = 0x%lx, BSP = 0x%lx\n",
               (ULONGLONG)NextPc,
               (ULONGLONG)ContextRecord->IntSp,
               (ULONGLONG)ContextRecord->RsBSP));
#else
    UW_DEBUG(("NextPc = 0x%lx, PSP = 0x%lx, BSP = 0x%lx\n",
               (ULONGLONG)NextPc,
               EstablisherFrame->MemoryStackFp,
               EstablisherFrame->BackingStoreFp));
#endif // _IMAGEHLP_SOURCE_
    return (NextPc);
}


UCHAR
NewParsePrologueRegionPhase0 (
    IN PUNWIND_CONTEXT UwContext,
    IN PSTATE_RECORD State,
    IN OUT PUCHAR AbiImmContext
    )
{
    PUCHAR Desc = UwContext->Descriptors;
    ULONG Offset;
    ULONG FrameSize;
    ULONG Index;
    UCHAR RecType;
    UCHAR FirstByte;
    UCHAR SecondByte;
    ULONG GrSave;
    ULONG TempMask;
    ULONG i;

    while (UwContext->DescCount < UwContext->Size) {

        FirstByte = Desc[UwContext->DescCount++];

        if ( (FirstByte & P1_MASK) == P1_PREFIX) {

            continue;

        } else if ( (FirstByte & P2_MASK) == P2_PREFIX ) {

            UwContext->DescCount++;

        } else if ( (FirstByte & P3_MASK) == P3_PREFIX ) {

            UwContext->DescCount++;

        } else if ( (FirstByte & P4_MASK) == P4_PREFIX ) {

            UwContext->DescCount += ((State->RegionLen+3) >> 2);

        } else if ( (FirstByte & P5_MASK) == P5_PREFIX ) {

            UwContext->DescCount += 3;

        } else if ( (FirstByte & P6_MASK) == P6_PREFIX ) {

            continue;

        } else if ( (FirstByte & P7_MASK) == P7_PREFIX ) {

            RecType = FirstByte & ~P7_MASK;

            switch (RecType) {

            case MEM_STACK_F:

                Offset = ReadLEB128(Desc, &UwContext->DescCount);
                FrameSize = ReadLEB128(Desc, &UwContext->DescCount);

                if (UwContext->TargetSlot > (UwContext->SlotCount+Offset))
                {
                    State->SpAdjustment += FrameSize*4;
                    State->SpWhen = Offset;
                }
                break;

            case SPILL_BASE:

                State->SpillBase = ReadLEB128(Desc, &UwContext->DescCount);
                State->SpillPtr = State->SpillBase;
                break;

            case MEM_STACK_V:
            case RP_WHEN:
            case PFS_WHEN:
            case PREDS_WHEN:
            case LC_WHEN:
            case UNAT_WHEN:
            case FPSR_WHEN:

                Offset = ReadLEB128(Desc, &UwContext->DescCount);
                if ((State->IsTarget) &&
                    (UwContext->TargetSlot > (UwContext->SlotCount+Offset)))
                {
                    Index = P7RecordTypeToRegisterIndex[RecType];
                    if (!(State->MiscMask & (1 << Index))) {
                        State->MiscMask |= MASK(Index,1);
                        UwContext->MiscRegs[Index].When = Offset;
                    } else {
                        UW_DEBUG(("Duplicate descriptors,"));
                        UW_DEBUG(("unwinder may produce incorrect result!\n"));
                    }
                }
                UW_DEBUG(("Prolog P7: type=%d slot= %d\n", RecType, Offset));
                break;

            case PSP_SPREL:
            case RP_PSPREL:
            case PFS_PSPREL:
            case PREDS_PSPREL:
            case LC_PSPREL:
            case UNAT_PSPREL:
            case FPSR_PSPREL:

                Offset = ReadLEB128(Desc, &UwContext->DescCount);
                break;

            default:

                UW_DEBUG(("Invalid record type for descriptor P7!\n"));

            }

        } else if ( (FirstByte & P8_MASK) == P8_PREFIX ) {

            RecType = Desc[UwContext->DescCount++];

            switch (RecType) {

            case PSP_PSPREL:
            case RP_SPREL:
            case PFS_SPREL:
            case PREDS_SPREL:
            case LC_SPREL:
            case UNAT_SPREL:
            case FPSR_SPREL:
            case BSP_PSPREL:
            case BSP_SPREL:
            case BSPSTORE_PSPREL:
            case BSPSTORE_SPREL:
            case RNAT_PSPREL:
            case RNAT_SPREL:
            case PRIUNAT_PSPREL:
            case PRIUNAT_SPREL:

                Offset = ReadLEB128(Desc, &UwContext->DescCount);
                UW_DEBUG(("Prolog P8: type=%d slot= %d\n", RecType, Offset));
                break;

            case BSP_WHEN:
            case BSPSTORE_WHEN:
            case RNAT_WHEN:
            case PRIUNAT_WHEN:

                Offset = ReadLEB128(Desc, &UwContext->DescCount);
                if ((State->IsTarget) &&
                    (UwContext->TargetSlot > (UwContext->SlotCount+Offset)))
                {
                    Index = P7RecordTypeToRegisterIndex[RecType];
                    if (!(State->MiscMask & (1 << Index))) {
                        State->MiscMask |= MASK(Index,1);
                        UwContext->MiscRegs[Index].When = Offset;
                    } else {
                        UW_DEBUG(("Duplicate descriptors,"));
                        UW_DEBUG(("unwinder may produce incorrect result!\n"));
                    }
                }
                UW_DEBUG(("Prolog P8: type=%d slot= %d\n", RecType, Offset));
                break;

            default:

                UW_DEBUG(("Invalid record type for descriptor P8!\n"));

            }

        } else if ( (FirstByte & P9_MASK) == P9_PREFIX ) {

            UwContext->DescCount += 2;
            VUW_DEBUG_PRINT("Format P9 not supported yet!\n");

        } else if ( (FirstByte & P10_MASK) == P10_PREFIX ) {

            UCHAR Abi = Desc[UwContext->DescCount++];
            UCHAR Context = Desc[UwContext->DescCount++];

            *AbiImmContext = Context;

            if (Abi != NT_ABI) {
                VUW_DEBUG_PRINT("Unknown ABI unwind descriptor\n");
            }

        } else {

            //
            // Encounter another region header record
            //

            break;
        }
    }

    State->DescEnd = UwContext->DescCount - 2;

    return FirstByte;
}

VOID
NewParsePrologueRegionPhase1 (
    IN PUNWIND_CONTEXT UwContext,
    IN PSTATE_RECORD State
    )
{
    ULONG FrameSize;
    ULONG Offset;
    ULONG GrSave;
    ULONG BrBase;
    ULONG Index;
    ULONG Count;
    UCHAR RecType;
    UCHAR FirstByte, SecondByte;   // 1st & 2nd bytes of a region header record
    ULONG DescIndex;
    ULONG ImaskBegin;
    UCHAR NextBr, NextGr, NextFr;
    USHORT MiscMask;
    ULONG TempMask;
    ULONG FrMask = 0;
    UCHAR BrMask = 0;
    UCHAR GrMask = 0;
    PUCHAR Desc = UwContext->Descriptors;
    BOOLEAN SpillMaskOmitted = TRUE;

    DescIndex = State->DescBegin;

    FirstByte = Desc[DescIndex];

    if ((FirstByte & R2_MASK) == R2_PREFIX) {

        //
        // general prologue region header; need to process it first
        //

        ULONG GrSave, Count;
        UCHAR MiscMask;
        UCHAR SecondByte;
        USHORT i;

        DescIndex++;
        SecondByte = Desc[DescIndex++];
        MiscMask = ((FirstByte & 0x7) << 1) | ((SecondByte & 0x80) >> 7);
        GrSave = SecondByte & 0x7F;
        ReadLEB128(Desc, &DescIndex);    // advance the descriptor index

        if (GrSave < STATIC_REGISTER_SET_SIZE) {
            UW_DEBUG(("Invalid unwind descriptor!\n"));
        }

        UW_DEBUG(("Region R2: rmask=%x,grsave=%d,length=%d\n",
                  MiscMask, GrSave, State->RegionLen));

        Count = 0;
        for (Index = REG_PREDS; Index <= REG_RP; Index++) {
            if (MiscMask & 0x1) {
                if (!(State->IsTarget) ||
                    (State->MiscMask & MASK(Index,1)))
                {
                    UwContext->MiscRegs[Index].Where = GENERAL_REG;
                    UwContext->MiscRegs[Index].SaveOffset = GrSave+Count;
                    UwContext->MiscRegs[Index].When = 0;
                    State->MiscMask |= MASK(Index,1);
                }
                Count++;
            }
            MiscMask = MiscMask >> 1;
        }
    }

    while (DescIndex <= State->DescEnd) {

        FirstByte = Desc[DescIndex++];

        if ( (FirstByte & P1_MASK) == P1_PREFIX) {

            BrMask = FirstByte & ~P1_MASK;
            State->MiscMask |= (BrMask << REG_BR_BASE);

            UW_DEBUG(("Prolog P1: brmask=%x\n", BrMask));

            for (Count = REG_BR_BASE;
                 Count < REG_BR_BASE+NUMBER_OF_PRESERVED_BR;
                 Count++)
            {
                if (BrMask & 0x1) {
                    UwContext->MiscRegs[Count].Where = PSP_RELATIVE;
                    UwContext->MiscRegs[Count].When = State->RegionLen;
                }
                BrMask = BrMask >> 1;
            }

        } else if ( (FirstByte & P2_MASK) == P2_PREFIX ) {

            SecondByte = Desc[DescIndex++];
            GrSave = SecondByte & 0x7F;
            BrMask = ((FirstByte & ~P2_MASK) << 1) | ((SecondByte & 0x80) >> 7);
            UW_DEBUG(("Prolog P2: brmask=%x reg base=%d\n", BrMask, GrSave));

            State->MiscMask |= (BrMask << REG_BR_BASE);

            for (Count = REG_BR_BASE;
                 Count < REG_BR_BASE+NUMBER_OF_PRESERVED_BR;
                 Count++)
            {
                if (BrMask & 0x1) {
                    UwContext->MiscRegs[Count].Where = GENERAL_REG;
                    UwContext->MiscRegs[Count].SaveOffset = GrSave++;
                }
                BrMask = BrMask >> 1;
            }

        } else if ( (FirstByte & P3_MASK) == P3_PREFIX ) {

            SecondByte = Desc[DescIndex++];
            RecType = ((SecondByte & 0x80) >> 7) | ((FirstByte & 0x7) << 1);
            Index = P3RecordTypeToRegisterIndex[RecType];

            if (!(State->IsTarget) ||
                (State->MiscMask & MASK(Index,1)))
            {
                if (RecType == RP_BR) {
                    UwContext->MiscRegs[Index].Where = BRANCH_REG;
                } else {
                    UwContext->MiscRegs[Index].Where = GENERAL_REG;
                }
                UwContext->MiscRegs[Index].SaveOffset = SecondByte & 0x7F;
                UwContext->MiscRegs[Index].When = 0;
                State->MiscMask |= MASK(Index,1);

                UW_DEBUG(("Prolog P3: type=%d reg=%d\n",
                          RecType, UwContext->MiscRegs[Index].SaveOffset));
            }

        } else if ( (FirstByte & P4_MASK) == P4_PREFIX ) {

            SpillMaskOmitted = FALSE;
            ImaskBegin = DescIndex;
            DescIndex += ((State->RegionLen+3) >> 2);

        } else if ( (FirstByte & P5_MASK) == P5_PREFIX ) {

            GrMask = (Desc[DescIndex] & 0xF0) >> 4;
            FrMask = ((ULONG)(Desc[DescIndex] & 0xF) << 16) |
                         ((ULONG)Desc[DescIndex+1] << 8) |
                         ((ULONG)Desc[DescIndex+2]);

            DescIndex += 3;    // increment the descriptor index

            State->GrMask |= GrMask;
            State->FrMask |= FrMask;

            UW_DEBUG(("Prolog P5: grmask = %x, frmask = %x\n",
                      State->GrMask, State->FrMask));

        } else if ( (FirstByte & P6_MASK) == P6_PREFIX ) {

            if (FirstByte & 0x10) {

                GrMask = FirstByte & 0xF;
                State->GrMask |= GrMask;

            } else {

                FrMask = FirstByte & 0xF;
                State->FrMask |= FrMask;

            }

            UW_DEBUG(("Prolog P6: is_gr = %d, mask = %x\n",
                      (FirstByte & 0x10) ? 1 : 0,
                      (FirstByte & 0x10) ? State->GrMask : State->FrMask));

        } else if ( (FirstByte & P7_MASK) == P7_PREFIX ) {

            RecType = FirstByte & ~P7_MASK;

            switch (RecType) {

            case PSP_SPREL:

                //
                // sp-relative location
                //

                Index = P7RecordTypeToRegisterIndex[RecType];
                Offset = ReadLEB128(Desc, &DescIndex);
                if (!(State->IsTarget) || (State->MiscMask & MASK(Index,1)))
                {
                    UwContext->MiscRegs[Index].Where = SP_RELATIVE;
                    UwContext->MiscRegs[Index].SaveOffset = Offset;
                    if (!(State->MiscMask & MASK(Index,1))) {
                        UwContext->MiscRegs[Index].When = State->RegionLen;
                        State->MiscMask |= MASK(Index,1);
                    }
                }
                UW_DEBUG(("Prolog P7: type=%d spoff = %d\n", RecType, Offset));
                break;


            case RP_PSPREL:
            case PFS_PSPREL:
            case PREDS_PSPREL:
            case LC_PSPREL:
            case UNAT_PSPREL:
            case FPSR_PSPREL:

                //
                // psp-relative location
                //

                Index = P7RecordTypeToRegisterIndex[RecType];
                Offset = ReadLEB128(Desc, &DescIndex);
                if (!(State->IsTarget) || (State->MiscMask & MASK(Index,1)))
                {
                    UwContext->MiscRegs[Index].Where = PSP_RELATIVE;
                    UwContext->MiscRegs[Index].SaveOffset = Offset;
                    UwContext->MiscRegs[Index].When = 0;
                    State->MiscMask |= MASK(Index,1);
                }
                UW_DEBUG(("Prolog P7: type=%d pspoff= %d\n", RecType, Offset));
                break;

            case MEM_STACK_V:
            case RP_WHEN:
            case PFS_WHEN:
            case PREDS_WHEN:
            case LC_WHEN:
            case UNAT_WHEN:
            case FPSR_WHEN:

                //
                // Nevermind processing these descriptors because they
                // have been taken care of in phase 0
                //

                Offset = ReadLEB128(Desc, &DescIndex);
                break;

            case MEM_STACK_F:

                Offset = ReadLEB128(Desc, &DescIndex);
                FrameSize = ReadLEB128(Desc, &DescIndex);

                UW_DEBUG(("Prolog P7: type=%d Slot=%d FrameSize=%d\n",
                          RecType, Offset, FrameSize));
                break;

            case SPILL_BASE:

                State->SpillBase = ReadLEB128(Desc, &DescIndex);
                State->SpillPtr = State->SpillBase;
                UW_DEBUG(("Prolog P7: type=%d, spillbase=%d\n",
                          RecType, State->SpillBase));
                break;

            default:

                UW_DEBUG(("invalid unwind descriptors\n"));

            }

        } else if ( (FirstByte & P8_MASK) == P8_PREFIX ) {

            RecType = Desc[DescIndex++];

            switch (RecType) {

            case PSP_PSPREL:
                 VUW_DEBUG_PRINT("Unsupported Unwind Descriptor!\n");
                 break;

            case RP_SPREL:
            case PFS_SPREL:
            case PREDS_SPREL:
            case LC_SPREL:
            case UNAT_SPREL:
            case FPSR_SPREL:
            case BSP_SPREL:
            case BSPSTORE_SPREL:
            case RNAT_SPREL:
            case PRIUNAT_SPREL:

                //
                // sp-relative location
                //

                Index = P8RecordTypeToRegisterIndex[RecType];
                Offset = ReadLEB128(Desc, &DescIndex);
                if (!(State->IsTarget) || (State->MiscMask & MASK(Index,1)))
                {
                    UwContext->MiscRegs[Index].Where = SP_RELATIVE;
                    UwContext->MiscRegs[Index].SaveOffset = Offset;
                    if (!(State->MiscMask & MASK(Index,1))) {
                        UwContext->MiscRegs[Index].When=State->RegionLen;
                        State->MiscMask |= MASK(Index,1);
                    }
                }
                UW_DEBUG(("Prolog P8: type=%d spoff= %d\n", RecType, Offset));
                break;

            case BSP_PSPREL:
            case BSPSTORE_PSPREL:
            case RNAT_PSPREL:
            case PRIUNAT_PSPREL:

                //
                // psp-relative location
                //

                Index = P8RecordTypeToRegisterIndex[RecType];
                Offset = ReadLEB128(Desc, &DescIndex);
                if (!(State->IsTarget) || (State->MiscMask & MASK(Index,1)))
                {
                    UwContext->MiscRegs[Index].Where = PSP_RELATIVE;
                    UwContext->MiscRegs[Index].SaveOffset = Offset;
                    UwContext->MiscRegs[Index].When = 0;
                    State->MiscMask |= MASK(Index,1);
                }
                UW_DEBUG(("Prolog P8: type=%d pspoff= %d\n", RecType, Offset));
                break;

            case BSP_WHEN:
            case BSPSTORE_WHEN:
            case RNAT_WHEN:
            case PRIUNAT_WHEN:

                //
                // Nevermind processing these descriptors because they
                // have been taken care of in phase 0
                //

                Offset = ReadLEB128(Desc, &DescIndex);
                break;

            default:

                UW_DEBUG(("Invalid record type for descriptor P8!\n"));

            }

        } else if ( (FirstByte & P9_MASK) == P9_PREFIX ) {

            DescIndex += 2;
            VUW_DEBUG_PRINT("Format P9 not supported yet!\n");

        } else if ( (FirstByte & P10_MASK) == P10_PREFIX ) {

            UCHAR Abi = Desc[DescIndex++];
            UCHAR Context = Desc[DescIndex++];

        } else {

            UW_DEBUG(("Invalid descriptor!\n"));

        }
    }

    GrMask = State->GrMask;
    FrMask = State->FrMask;
    BrMask = State->MiscMask >> REG_BR_BASE;

    if (!(GrMask | FrMask | BrMask)) {

        return;

    } else if (SpillMaskOmitted && !(State->IsTarget)) {

        //
        // When spillmask is omitted, floating point registers, general
        // registers, and then branch regisers are spilled in order.
        // They are not modified in the prologue region; therefore, there
        // is no need to restore their contents when the control ip is
        // in this prologue region.
        //

        // 1. floating point registers

        State->SpillPtr &= ~(SPILLSIZE_OF_FLOAT128_IN_DWORDS - 1);
        NextFr = NUMBER_OF_PRESERVED_FR - 1;
        while (FrMask & 0xFFFFF) {
            if (FrMask & 0x80000) {
                State->SpillPtr += SPILLSIZE_OF_FLOAT128_IN_DWORDS;
                UwContext->Float[NextFr].SaveOffset = State->SpillPtr;
            }
            FrMask = FrMask << 1;
            NextFr--;
        }

        // 2. branch registers

        NextBr = REG_BR_BASE + NUMBER_OF_PRESERVED_BR - 1;
        while (BrMask & 0x1F) {
            if (BrMask & 0x10) {
                if (UwContext->MiscRegs[Index].Where == PSP_RELATIVE) {
                    State->SpillPtr += SPILLSIZE_OF_ULONGLONG_IN_DWORDS;
                    UwContext->MiscRegs[NextBr].SaveOffset = State->SpillPtr;
                }
            }
            BrMask = BrMask << 1;
            NextBr--;
        }

        // 3. general registers

        NextGr = NUMBER_OF_PRESERVED_GR - 1;
        while (GrMask & 0xF) {
            if (GrMask & 0x8) {
                State->SpillPtr += SPILLSIZE_OF_ULONGLONG_IN_DWORDS;
                UwContext->Integer[NextGr].SaveOffset = State->SpillPtr;
            }
            GrMask = GrMask << 1;
            NextGr--;
        }

    } else if (SpillMaskOmitted && State->IsTarget) {

        State->GrMask = 0;
        State->FrMask = 0;
        State->MiscMask &= MASK(REG_BR_BASE, 1) - 1;

    } else if (SpillMaskOmitted == FALSE) {

        ULONG Length;

        if (State->IsTarget) {

            //
            // control ip is in the prologue region; clear the masks
            // and then process the imask to determine which preserved
            // Gr/Fr/Br have been saved and set the corresponding bits.
            //

            State->GrMask = 0;
            State->FrMask = 0;
            State->MiscMask &= MASK(REG_BR_BASE, 1) - 1;
            Length = UwContext->TargetSlot - State->RegionBegin;
        } else {
            Length = State->RegionLen;
        }

        NextGr = NUMBER_OF_PRESERVED_GR - 1;
        NextBr = NUMBER_OF_PRESERVED_BR - 1;
        NextFr = NUMBER_OF_PRESERVED_FR - 1;
        for (Count = 0; Count < Length; Count++) {

            if ((Count % 4) == 0) {
                FirstByte = Desc[ImaskBegin++];
            } else {
                FirstByte = FirstByte << 2;
            }

            switch (FirstByte & 0xC0) {

            case 0x40:                  // 0x01 - save next fr

                while ( !(FrMask & 0x80000) && (NextFr > 0) ) {
                    NextFr--;
                    FrMask = FrMask << 1;
                }

                UW_DEBUG(("spilled register FS%lx\n", (ULONG)NextFr));

                State->FrMask |= MASK(NextFr,1);
                UwContext->Float[NextFr].When = Count;
                State->SpillPtr += SPILLSIZE_OF_ULONGLONG_IN_DWORDS;
                State->SpillPtr &= ~(SPILLSIZE_OF_FLOAT128_IN_DWORDS - 1);
                State->SpillPtr += SPILLSIZE_OF_FLOAT128_IN_DWORDS;
                UwContext->Float[NextFr].SaveOffset = State->SpillPtr;

                NextFr--;
                FrMask = FrMask << 1;
                break;

            case 0x80:                  // 0x10 - save next gr

                while ( !(GrMask & 0x8) && (NextGr > 0) ) {
                    NextGr--;
                    GrMask = GrMask << 1;
                }

                UW_DEBUG(("spilled register S%lx\n", (ULONG)NextGr));

                State->GrMask |= MASK(NextGr,1);
                UwContext->Integer[NextGr].When = Count;
                State->SpillPtr += SPILLSIZE_OF_ULONGLONG_IN_DWORDS;
                UwContext->Integer[NextGr].SaveOffset = State->SpillPtr;

                NextGr--;
                GrMask = GrMask << 1;
                break;

            case 0xC0:                  // 0x11 - save next br

                while ( !(BrMask & 0x10) && (NextBr > 0) ) {
                    NextBr--;
                    BrMask = BrMask << 1;
                }

                UW_DEBUG(("spilled register BS%lx\n", (ULONG)NextBr));

                Index = REG_BR_BASE + NextBr;
                State->MiscMask |= MASK(Index,1);
                UwContext->MiscRegs[Index].When = Count;
                if (UwContext->MiscRegs[Index].Where == PSP_RELATIVE) {
                    State->SpillPtr += SPILLSIZE_OF_ULONGLONG_IN_DWORDS;
                    UwContext->MiscRegs[Index].SaveOffset = State->SpillPtr;
                }

                NextBr--;
                BrMask = BrMask << 1;
                break;

            default:                    // 0x00 - save no register
                break;

            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\upddbg.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    upddbg.c

Abstract:

    This tool updates debug files to match corresponding binary checksum,
    base address and timestamp

Author:

    Matthew Hoehnen (matthoe) 08-Jun-1995

Revision History:

--*/
#define _IMAGEHLP_SOURCE_
#include <private.h>

BOOL                            fUpdate;
LPSTR                           CurrentImageName;
LOADED_IMAGE                    CurrentImage;
CHAR                            DebugFilePath[_MAX_PATH];
CHAR                            SymbolPathBuffer[MAX_PATH*10];
LPSTR                           SymbolPath;
DWORD                           dw;
LPSTR                           FilePart;
CHAR                            Buffer[MAX_PATH];
PIMAGE_LOAD_CONFIG_DIRECTORY    ConfigInfo;
CHAR                            c;
LPSTR                           p;
BOOL                            DbgHeaderModified;
ULONG                           CheckSum;
HANDLE                          hDbgFile;
ULONG                           cb;
IMAGE_SEPARATE_DEBUG_HEADER     DbgHeader;


VOID
DisplayUsage(
    VOID
    )
{
    fputs("usage: UPDDBG [switches] image-names... \n"
          "              [-?] display this message\n"
          "              [-u] update image\n"
          "              [-s] path to symbol files\n", stderr
          );
}



int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    if (argc <= 1) {
        DisplayUsage();
        return 1;
    }

    _tzset();

    while (--argc) {
        p = *++argv;
        if (*p == '/' || *p == '-') {
            while (c = *++p)
            switch (tolower( c )) {
                case '?':
                    DisplayUsage();
                    return 0;

                case 'u':
                    fUpdate = TRUE;
                    break;

                case 's':
                    argc--, argv++;
                    SymbolPath = *argv;
                    break;

                default:
                    fprintf( stderr, "UPDDBG: Invalid switch - /%c\n", c );
                    DisplayUsage();
                    return 1;
            }
        }
    }

    if (!SymbolPath) {
        if (GetEnvironmentVariable( "_nt_symbol_path", SymbolPathBuffer, sizeof(SymbolPathBuffer)-1 )) {
            SymbolPath = SymbolPathBuffer;
        }
    }

    if (!SymbolPath) {
        fprintf( stderr, "UPDDBG: uknown symbol file path\n" );
        return 1;
    }

    CurrentImageName = p;

    //
    // Map and load the current image
    //

    if (!MapAndLoad( CurrentImageName, NULL, &CurrentImage, FALSE, TRUE )) {
        fprintf( stderr, "UPDDBG: failure mapping and loading %s\n", CurrentImageName );
        return 1;
    }

    CurrentImageName = CurrentImage.ModuleName;

    FlushViewOfFile( CurrentImage.MappedAddress, 0 );

    if (!fUpdate) {
        hDbgFile = FindDebugInfoFile( CurrentImageName, SymbolPath, DebugFilePath );
        if (hDbgFile == INVALID_HANDLE_VALUE || hDbgFile == NULL) {
            fprintf( stderr, "UPDDBG: could not locate DBG file %s\n", CurrentImageName );
            return 1;
        }

        if (!ReadFile( hDbgFile, &DbgHeader, sizeof(IMAGE_SEPARATE_DEBUG_HEADER), &cb, NULL )) {
            fprintf( stderr, "UPDDBG: could not read DBG file %s\n", CurrentImageName );
            return 1;
        }

        printf( "*\n" );
        if (((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader)->OptionalHeader.CheckSum != DbgHeader.CheckSum) {
            printf( "*************************************\n" );
            printf( "* WARNING: checksums do not match   *\n" );
            printf( "*************************************\n" );
            printf( "*\n" );
        }

        _strlwr( CurrentImageName );
        _strlwr( DebugFilePath );

        printf( "Image    0x%08x %s\n", ((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader)->OptionalHeader.CheckSum, CurrentImageName );
        printf( "DBG File 0x%08x %s\n", DbgHeader.CheckSum, DebugFilePath );

        return 0;
    }

    if (!((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader)->FileHeader.Characteristics & IMAGE_FILE_DEBUG_STRIPPED) {
        fprintf( stderr, "UPDDBG: symbols have not been split %s\n", CurrentImageName );
        return 1;
    }

    if ( UpdateDebugInfoFileEx( CurrentImageName,
                                SymbolPath,
                                DebugFilePath,
                                (PIMAGE_NT_HEADERS32)(CurrentImage.FileHeader),
                                ((PIMAGE_NT_HEADERS32)CurrentImage.FileHeader)->OptionalHeader.CheckSum
                                ) ) {
        if (GetLastError() == ERROR_INVALID_DATA) {
            printf( "UPDDBG: Warning - Old checksum did not match for %s\n", DebugFilePath );
        }
        printf( "Updated symbols for %s\n", DebugFilePath );
    } else {
        printf( "Unable to update symbols: %s\n", DebugFilePath );
    }

    return 0;
}

#define _BUILDING_UPDDBG_
#include "upddbgi.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\upddbgi.c ===
#include <private.h>

// Random debug info modification functions for imagehlp


BOOL
IMAGEAPI
UpdateDebugInfoFile(
    LPSTR ImageFileName,
    LPSTR SymbolPath,
    LPSTR DebugFilePath,
    PIMAGE_NT_HEADERS32 NtHeaders
    )
{
    return UpdateDebugInfoFileEx(
                ImageFileName,
                SymbolPath,
                DebugFilePath,
                NtHeaders,
                NtHeaders->OptionalHeader.CheckSum);
}

BOOL
IMAGEAPI
UpdateDebugInfoFileEx(
    LPSTR ImageFileName,
    LPSTR SymbolPath,
    LPSTR DebugFilePath,
    PIMAGE_NT_HEADERS32 NtHeaders,
    DWORD OldCheckSum
    )
{
    // UnSafe...

    HANDLE hDebugFile, hMappedFile;
    PVOID MappedAddress;
    PIMAGE_SEPARATE_DEBUG_HEADER DbgFileHeader;
    DWORD dwError = ERROR_SUCCESS;

#ifdef _BUILDING_UPDDBG_
    OSVERSIONINFO OSVerInfo;
    OSVerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&OSVerInfo);
#endif

    hDebugFile = FindDebugInfoFile(
                    ImageFileName,
                    SymbolPath,
                    DebugFilePath
                    );
    if ( hDebugFile == NULL ) {
        return FALSE;
    }
    CloseHandle(hDebugFile);

    hDebugFile = CreateFile( DebugFilePath,
                             GENERIC_READ | GENERIC_WRITE,
                             OSVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT ? (FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE) : (FILE_SHARE_READ | FILE_SHARE_WRITE),
                             NULL,
                             OPEN_EXISTING,
                             0,
                             NULL
                           );
    if ( hDebugFile == INVALID_HANDLE_VALUE ) {
        return FALSE;
    }

    hMappedFile = CreateFileMapping(
                    hDebugFile,
                    NULL,
                    PAGE_READWRITE,
                    0,
                    0,
                    NULL
                    );
    if ( !hMappedFile ) {
        CloseHandle(hDebugFile);
        return FALSE;
    }

    MappedAddress = MapViewOfFile(hMappedFile,
                        FILE_MAP_WRITE,
                        0,
                        0,
                        0
                        );
    CloseHandle(hMappedFile);
    if ( !MappedAddress ) {
        CloseHandle(hDebugFile);
        return FALSE;
    }

    DbgFileHeader = (PIMAGE_SEPARATE_DEBUG_HEADER)MappedAddress;
    if (DbgFileHeader->ImageBase != NtHeaders->OptionalHeader.ImageBase ||
        DbgFileHeader->CheckSum != NtHeaders->OptionalHeader.CheckSum   ||
        DbgFileHeader->SizeOfImage != NtHeaders->OptionalHeader.SizeOfImage
       ) {
        DbgFileHeader->ImageBase = NtHeaders->OptionalHeader.ImageBase;
        if (OldCheckSum != DbgFileHeader->CheckSum) {
            DbgFileHeader->Flags |= IMAGE_SEPARATE_DEBUG_MISMATCH;
            dwError = ERROR_INVALID_DATA;
        }
        DbgFileHeader->CheckSum = NtHeaders->OptionalHeader.CheckSum;
        DbgFileHeader->TimeDateStamp = NtHeaders->FileHeader.TimeDateStamp;
        DbgFileHeader->SizeOfImage = NtHeaders->OptionalHeader.SizeOfImage;
        FlushViewOfFile(MappedAddress,0);
        UnmapViewOfFile(MappedAddress);
        TouchFileTimes(hDebugFile,NULL);
        CloseHandle(hDebugFile);
        SetLastError(dwError);
        return TRUE;
    } else {
        FlushViewOfFile(MappedAddress,0);
        UnmapViewOfFile(MappedAddress);
        CloseHandle(hDebugFile);
        return FALSE;
    }
}
#ifndef _BUILDING_UPDDBG_

BOOL
IMAGEAPI
RemovePrivateCvSymbolic(
    PCHAR   DebugData,
    PCHAR * NewDebugData,
    ULONG * NewDebugSize
    )
{
    BOOL rc;
    rc = RemovePrivateCvSymbolicEx(DebugData, 0, NewDebugData, NewDebugSize);
    if (rc && (*NewDebugSize == 0) && (*NewDebugData == DebugData)) {
        *NewDebugData = NULL;
    }
    return(rc);
}

BOOL
IMAGEAPI
RemovePrivateCvSymbolicEx(
    PCHAR   DebugData,
    ULONG   DebugSize,
    PCHAR * NewDebugData,
    ULONG * NewDebugSize
    )
{
    OMFSignature       *CvDebugData, *NewStartCvSig, *NewEndCvSig;
    OMFDirEntry        *CvDebugDirEntry;
    OMFDirHeader       *CvDebugDirHead;
    unsigned int        i, j;
    PCHAR               NewCvData;
    ULONG               NewCvSize = 0, NewCvOffset;
    BOOL                RC = FALSE;

    __try {
        CvDebugDirHead  = NULL;
        CvDebugDirEntry = NULL;
        CvDebugData = (OMFSignature *)DebugData;

        if ((((*(PULONG)(CvDebugData->Signature)) == '90BN') ||
             ((*(PULONG)(CvDebugData->Signature)) == '80BN') ||
             ((*(PULONG)(CvDebugData->Signature)) == '11BN'))  &&
            ((CvDebugDirHead = (OMFDirHeader *)((PUCHAR) CvDebugData + CvDebugData->filepos)) != NULL) &&
            ((CvDebugDirEntry = (OMFDirEntry *)((PUCHAR) CvDebugDirHead + CvDebugDirHead->cbDirHeader)) != NULL)) {

            // Walk the directory.  Keep what we want, zero out the rest.

            for (i=0, j=0; i < CvDebugDirHead->cDir; i++) {
                switch (CvDebugDirEntry[i].SubSection) {
                    case sstSegMap:
                    case sstSegName:
                    case sstOffsetMap16:
                    case sstOffsetMap32:
                    case sstModule:
                    case SSTMODULE:
                    case SSTPUBLIC:
                    case sstPublic:
                    case sstPublicSym:
                    case sstGlobalPub:
                        CvDebugDirEntry[j] = CvDebugDirEntry[i];
                        NewCvSize += CvDebugDirEntry[j].cb;
                        NewCvSize = (NewCvSize + 3) & ~3;
                        if (i != j++) {
                            // Clear the old entry.
                            RtlZeroMemory(&CvDebugDirEntry[i], CvDebugDirHead->cbDirEntry);
                        }
                        break;

                    default:
                        RC = TRUE;
                        RtlZeroMemory(CvDebugDirEntry[i].lfo + (PUCHAR) CvDebugData, CvDebugDirEntry[i].cb);
                        RtlZeroMemory(&CvDebugDirEntry[i], CvDebugDirHead->cbDirEntry);
                        break;
                }
            }

            // Now, allocate the new cv data.

            CvDebugDirHead->cDir = j;

            NewCvSize += (j * CvDebugDirHead->cbDirEntry) + // The directory itself
                            CvDebugDirHead->cbDirHeader +   // The directory header
                            (sizeof(OMFSignature) * 2);     // The signature/offset pairs at each end.

            NewCvData = (PCHAR) MemAlloc( NewCvSize );

            // And move the stuff we kept into the new section.

            NewCvOffset = sizeof(OMFSignature);

            RtlCopyMemory(NewCvData + NewCvOffset, CvDebugDirHead, CvDebugDirHead->cbDirHeader);

            CvDebugDirHead = (OMFDirHeader *) (NewCvData + NewCvOffset);

            NewCvOffset += CvDebugDirHead->cbDirHeader;

            RtlCopyMemory(NewCvData + NewCvOffset,
                        CvDebugDirEntry,
                        CvDebugDirHead->cDir * CvDebugDirHead->cbDirEntry);

            CvDebugDirEntry = (OMFDirEntry *)(NewCvData + NewCvOffset);

            NewCvOffset += (CvDebugDirHead->cbDirEntry * CvDebugDirHead->cDir);

            for (i=0; i < CvDebugDirHead->cDir; i++) {
                RtlCopyMemory(NewCvData + NewCvOffset,
                            CvDebugDirEntry[i].lfo + (PCHAR) CvDebugData,
                            CvDebugDirEntry[i].cb);
                CvDebugDirEntry[i].lfo = NewCvOffset;
                NewCvOffset += (CvDebugDirEntry[i].cb + 3) & ~3;
            }


            // Re-do the start/end signatures

            NewStartCvSig = (OMFSignature *) NewCvData;
            NewEndCvSig   = (OMFSignature *) ((PCHAR)NewCvData + NewCvOffset);
            *(PULONG)(NewStartCvSig->Signature) = *(PULONG)(CvDebugData->Signature);
            NewStartCvSig->filepos = (int)((PCHAR)CvDebugDirHead - (PCHAR)NewStartCvSig);
            *(PULONG)(NewEndCvSig->Signature) = *(PULONG)(CvDebugData->Signature);
            NewCvOffset += sizeof(OMFSignature);
            NewEndCvSig->filepos = (LONG)NewCvOffset;

            // Set the return values appropriately

            *NewDebugData = NewCvData;
            *NewDebugSize = NewCvSize;

        } else {
            if (*(PULONG)(CvDebugData->Signature) == '01BN') {
                *NewDebugData = DebugData;
                *NewDebugSize = DebugSize;
                RC = TRUE;
            } else {
                // Not NB10, NB09 or NB08.  Forget we ever heard of it.
                *NewDebugData = DebugData;
                *NewDebugSize = 0;
                RC = TRUE;
            }
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        RC = FALSE;
    }

    return(RC);
}

#include <copypdb.c>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\walkalp.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    walkalpha.c

Abstract:

    This file implements the ALPHA stack walking api.

Author:

    Wesley Witt (wesw) 1-Oct-1993

Environment:

    User Mode

--*/

#define _IMAGEHLP_SOURCE_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "private.h"
#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"
#include "symbols.h"
#include "alphaops.h"
#include <stdlib.h>
#include <stddef.h>

#ifdef __cplusplus
extern "C"
#endif

BOOL
WalkAlphaInit(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PALPHA_NT5_CONTEXT                Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  GetFunctionEntry,
    BOOL                              Use64
    );

BOOL
WalkAlphaNext(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PALPHA_NT5_CONTEXT                Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  GetFunctionEntry,
    BOOL                              Use64
    );

BOOL
WalkAlphaGetStackFrame(
    HANDLE                            hProcess,
    PULONG64                          ReturnAddress,
    PULONG64                          FramePointer,
    PALPHA_NT5_CONTEXT                Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  GetFunctionEntry,
    PKDHELP64                         KdHelp,
    BOOL                              Use64
    );

PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY
LookupDirectFunctionEntry (
    HANDLE                            hProcess,
    ULONG64                           ControlPc,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  GetFunctionEntry,
    BOOL                              Use64
    );

PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY
LookupStaticFunctionEntry(
    HANDLE                            hProcess,
    ULONG64                           ControlPc,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  GetFunctionEntry,
    BOOL                              Use64,
    PBOOLEAN                          InImage
    );

VOID
GetUnwindFunctionEntry(
    HANDLE                                hProcess,
    ULONG64                               ControlPc,
    PREAD_PROCESS_MEMORY_ROUTINE64        ReadMemory,
    PGET_MODULE_BASE_ROUTINE64            GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64      GetFunctionEntry,
    BOOL                                  Use64,
    PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY FunctionEntry,
    PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY UnwindFunctionEntry,
    PULONG                                StackAdjust,
    PULONG64                              FixedReturn
    );

PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY
FetchFunctionEntry (
    HANDLE                            hProcess,
    ULONG64                           Address,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    BOOL                              Use64
    );

PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY
PromoteFunctionEntry (
    PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY Address
    );

ULONG64
FunctionTableBase(
    HANDLE                            hProcess,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    BOOL                              Use64,
    ULONG64                           Base,
    PULONG                            Size
    );

#if DBG
void
ShowRuntimeFunction(
    PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY FunctionEntry,
    PSTR Label
    );

#define MAXENTRYTYPE 2
char *EntryTypeName[] = {
    "ALPHA_RF_NOT_CONTIGUOUS", // 0
    "ALPHA_RF_ALT_ENT_PROLOG", // 1
    "ALPHA_RF_NULL_CONTEXT",   // 2
    "***INVALID***"
};

BOOLEAN DebugFunctionEntries = 0;
#endif

#define ZERO 0x0                /* integer register 0 */
#define SP 0x1d                 /* integer register 29 */
#define RA 0x1f                 /* integer register 31 */
#define SAVED_FLOATING_MASK 0xfff00000 /* saved floating registers */
#define SAVED_INTEGER_MASK 0xf3ffff02 /* saved integer registers */
#define IS_FLOATING_SAVED(Register) ((SAVED_FLOATING_MASK >> Register) & 1L)
#define IS_INTEGER_SAVED(Register) ((SAVED_INTEGER_MASK >> Register) & 1L)
#define CALLBACK_STACK(f)  (f->KdHelp.ThCallbackStack)
#define CALLBACK_NEXT(f)   (f->KdHelp.NextCallback)
#define CALLBACK_FUNC(f)   (f->KdHelp.KiCallUserMode)
#define CALLBACK_THREAD(f) (f->KdHelp.Thread)
#define CALLBACK_FP(f)     (f->KdHelp.FramePointer)
#define CALLBACK_DISPATCHER(f) (f->KdHelp.KeUserCallbackDispatcher)
#define SYSTEM_RANGE_START(f) (f->KdHelp.SystemRangeStart)

// The function entry algorithms use the address of the function entry. This structure keeps
// both the function entry's address in the target process and its contents.

typedef struct {
    IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY  Value;        // copy of function entry
    ULONG64 Address;                                    // address of this function entry in target process
    HANDLE  Process;                                    // process id from which this function entry came
#if DBG
    PCHAR   Description;                                // description of address
#endif
} LOCAL_FUNCTION_ENTRY, *PLOCAL_FUNCTION_ENTRY;

// This array caches a small number of function entries to speed up the function entry binary search
#define LFE_MAX 60                                      // total number of cached function entries
#define LFE_NEW 40                                      // once the cache is full new entries will
                                                        // will be read into the part of the table
                                                        // beyond this index.
LOCAL_FUNCTION_ENTRY LocalFunctionEntry[LFE_MAX];
ULONG LocalFunctionEntryCount = 0;
ULONG LocalFunctionEntryNext  = 0;

// These two entries save the most recent primary and secondary function entry. This is a big performance
// improvement because the function entries used to get the return address and params from one call to
// WalkAlp are used to get the return PC in the next call (each WalkAlp() call does two virtual unwinds).

LOCAL_FUNCTION_ENTRY LastPrimaryFunctionEntry;          // Primary function entry from last call to walkalp
LOCAL_FUNCTION_ENTRY LastSecondaryFunctionEntry;        // Secondary function entry from last call to walkalp
LOCAL_FUNCTION_ENTRY LastDynamicFunctionEntry;          // Dynamic function entry from last registered FunctionEntryCallback
LOCAL_FUNCTION_ENTRY LastUserFunctionEntry;             // Function entry from last stack walk FunctionEntryCallback

// Macro to retrieve address of a fetched function entry.
// Dependent on RUNTIME_FUNCTION being the first member of LOCAL_FUNCTION_ENTRY.

#define FUNCTION_ENTRY_ADDRESS(pfe) ((pfe) != NULL? ((LOCAL_FUNCTION_ENTRY *)pfe)->Address : 0)
#define FUNCTION_ENTRY_DESCRIPTION(pfe) ((pfe) != NULL? ((LOCAL_FUNCTION_ENTRY *)pfe)->Description: "" )

#define IS_HANDLER_DEFINED(FunctionEntry) \
    (RF_EXCEPTION_HANDLER(FunctionEntry) != 0)

// These modifications of the RF_ macros are required because of the need for an explicit ULONG64 result

#define FIXED_RETURN(RF) (((ULONG64)(RF)->ExceptionHandler) & (~3))
#define ALT_PROLOG(RF)   (((ULONG64)(RF)->ExceptionHandler) & (~3))

BOOL
WalkAlpha(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PALPHA_NT5_CONTEXT                Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  GetFunctionEntry,
    BOOL                              Use64
    )
{
    BOOL rval;

    if (StackFrame->Virtual) {

        rval = WalkAlphaNext( hProcess,
                              StackFrame,
                              Context,
                              ReadMemory,
                              GetModuleBase,
                              GetFunctionEntry,
                              Use64
                            );

    } else {

        rval = WalkAlphaInit( hProcess,
                              StackFrame,
                              Context,
                              ReadMemory,
                              GetModuleBase,
                              GetFunctionEntry,
                              Use64
                            );

    }

    return rval;
}


ULONG64
VirtualUnwind (
    HANDLE                                  hProcess,
    ULONG64                                 ControlPc,
    PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY   FunctionEntry,
    ULONG                                   StackAdjust,
    ULONG64                                 FixedReturn,
    PALPHA_NT5_CONTEXT                      Context,
    PREAD_PROCESS_MEMORY_ROUTINE64          ReadMemory
//    PKNONVOLATILE_CONTEXT_POINTERS          ContextPointers OPTIONAL
    )

/*++

Routine Description:

    This function virtually unwinds the specified function by executing its
    prologue code backwards. Given the current context and the instructions
    that preserve registers in the prologue, it is possible to recreate the
    nonvolatile context at the point the function was called.

    If the function is a leaf function, then the address where control left
    the previous frame is obtained from the context record. If the function
    is a nested function, but not an exception or interrupt frame, then the
    prologue code is executed backwards and the address where control left
    the previous frame is obtained from the updated context record.

    Otherwise, an exception or interrupt entry to the system is being unwound
    and a specially coded prologue restores the return address twice. Once
    from the fault instruction address and once from the saved return address
    register. The first restore is returned as the function value and the
    second restore is placed in the updated context record.

    During the unwind, the virtual and real frame pointers for the function
    are calculated and returned in the given frame pointers structure.

    If a context pointers record is specified, then the address where each
    register is restored from is recorded in the appropriate element of the
    context pointers record.

Arguments:

    ControlPc - Supplies the address where control left the specified
        function.

    FunctionEntry - Supplies the address of the function table entry for the
        specified function.

    ContextRecord - Supplies the address of a context record.

    ContextPointers - Supplies an optional pointer to a context pointers
        record.

Return Value:

    The address where control left the previous frame is returned as the
    function value.

Implementation Notes:

    N.B. "where control left" is not the "return address" of the call in the
    previous frame. For normal frames, NextPc points to the last instruction
    that completed in the previous frame (the JSR/BSR). The difference between
    NextPc and NextPc + 4 (return address) is important for correct behavior
    in boundary cases of exception addresses and scope tables.

    For exception and interrupt frames, NextPc is obtained from the trap frame
    contination address (Fir). For faults and synchronous traps, NextPc is both
    the last instruction to execute in the previous frame and the next
    instruction to execute if the function were to return. For asynchronous
    traps, NextPc is the continuation address. It is the responsibility of the
    compiler to insert TRAPB instructions to insure asynchronous traps do not
    occur outside the scope from the instruction(s) that caused them.

    N.B. in this and other files where RtlVirtualUnwind is used, the variable
    named NextPc is perhaps more accurately, LastPc - the last PC value in
    the previous frame, or CallPc - the address of the call instruction, or
    ControlPc - the address where control left the previous frame. Instead
    think of NextPc as the next PC to use in another call to virtual unwind.

    The Alpha version of virtual unwind is similar in design, but slightly
    more complex than the Mips version. This is because Alpha compilers
    are given more flexibility to optimize generated code and instruction
    sequences, including within procedure prologues. And also because of
    compiler design issues, the function must manage both virtual and real
    frame pointers.

Version Information:  This version was taken from exdspatch.c@v37 (Feb 1993)

--*/

{
    ALPHA_INSTRUCTION FollowingInstruction;
    ALPHA_INSTRUCTION Instruction;
    ULONGLONG         Address;
    ULONG             DecrementOffset;
    ULONG             DecrementRegister;
    PULONGLONG        FloatingRegister;
    ULONG             FrameSize;
    ULONG             Function;
    PULONGLONG        IntegerRegister;
    ULONG             Literal8;
    ULONGLONG         NextPc;
    LONG              Offset16;
    ULONG             Opcode;
    ULONG             Ra;
    ULONG             Rb;
    ULONG             Rc;
    BOOLEAN           RestoredRa;
    BOOLEAN           RestoredSp;
    DWORD             cb;
    PVOID             Prolog;


    //
    // perf hack: fill cache with prolog
    // skip it if this is a secondary function entry
    //

    if (FunctionEntry &&
        (ALPHA_RF_PROLOG_END_ADDRESS(FunctionEntry) > ALPHA_RF_BEGIN_ADDRESS(FunctionEntry)) &&
        (ALPHA_RF_PROLOG_END_ADDRESS(FunctionEntry) < ALPHA_RF_END_ADDRESS(FunctionEntry)) ) {

        cb = (ULONG)(ALPHA_RF_PROLOG_END_ADDRESS(FunctionEntry) - ALPHA_RF_BEGIN_ADDRESS(FunctionEntry));

        //
        // If the function is a leaf it doesn't have a prolog, skip this
        // optimization.
        //

        if (cb != 0) {
            Prolog = (PVOID) MemAlloc( cb );
            if (!ReadMemory( hProcess,
                             ALPHA_RF_BEGIN_ADDRESS(FunctionEntry),
                             Prolog,
                             cb,
                             &cb )) {
                return 0;
            }
            MemFree(Prolog);
        }
    }

    //
    // Set the base address of the integer and floating register arrays within
    // the context record. Each set of 32 registers is known to be contiguous.
    //

    // assuming that quad values are together in context.

    IntegerRegister      = &Context->IntV0;
    FloatingRegister     = &Context->FltF0;

    //
    // Handle the epilogue case where the next instruction is a return.
    //
    // Exception handlers cannot be called if the ControlPc is within the
    // epilogue because exception handlers expect to operate with a current
    // stack frame. The value of SP is not current within the epilogue.
    //

    if (!ReadMemory(hProcess, ControlPc, &Instruction.Long, 4, &cb))  {
        return(0);
    }

    if (IS_RETURN_0001_INSTRUCTION(Instruction.Long)) {
        Rb = Instruction.Jump.Rb;
        NextPc = IntegerRegister[Rb] - 4;

        //
        // The instruction at the point where control left the specified
        // function is a return, so any saved registers have already been
        // restored, and the stack pointer has already been adjusted. The
        // stack does not need to be unwound in this case and the saved
        // return address register is returned as the function value.
        //
        // In fact, reverse execution of the prologue is not possible in
        // this case: the stack pointer has already been incremented and
        // so, for this frame, neither a valid stack pointer nor frame
        // pointer exists from which to begin reverse execution of the
        // prologue. In addition, the integrity of any data on the stack
        // below the stack pointer is never guaranteed (due to interrupts
        // and exceptions).
        //
        // The epilogue instruction sequence is:
        //
        // ==>  ret   zero, (Ra), 1     // return
        // or
        //
        //      mov   ra, Rx            // save return address
        //      ...
        // ==>  ret   zero, (Rx), 1     // return
        //

        return NextPc;
    }

    //
    // Handle the epilogue case where the next two instructions are a stack
    // frame deallocation and a return.
    //

    if (!ReadMemory(hProcess,(ControlPc+4),&FollowingInstruction.Long,4,&cb)) {
        return 0;
    }

    if (IS_RETURN_0001_INSTRUCTION(FollowingInstruction.Long)) {
        Rb = FollowingInstruction.Jump.Rb;
        NextPc = IntegerRegister[Rb] - 4;

        //
        // The second instruction following the point where control
        // left the specified function is a return. If the instruction
        // before the return is a stack increment instruction, then all
        // saved registers have already been restored except for SP.
        // The value of the stack pointer register cannot be recovered
        // through reverse execution of the prologue because in order
        // to begin reverse execution either the stack pointer or the
        // frame pointer (if any) must still be valid.
        //
        // Instead, the effect that the stack increment instruction
        // would have had on the context is manually applied to the
        // current context. This is forward execution of the epilogue
        // rather than reverse execution of the prologue.
        //
        // In an epilogue, as in a prologue, the stack pointer is always
        // adjusted with a single instruction: either an immediate-value
        // (lda) or a register-value (addq) add instruction.
        //

        Function = Instruction.OpReg.Function;
        Offset16 = Instruction.Memory.MemDisp;
        Opcode = Instruction.OpReg.Opcode;
        Ra = Instruction.OpReg.Ra;
        Rb = Instruction.OpReg.Rb;
        Rc = Instruction.OpReg.Rc;

        if ((Opcode == LDA_OP) && (Ra == SP_REG)) {

            //
            // Load Address instruction.
            //
            // Since the destination (Ra) register is SP, an immediate-
            // value stack deallocation operation is being performed. The
            // displacement value should be added to SP. The displacement
            // value is assumed to be positive. The amount of stack
            // deallocation possible using this instruction ranges from
            // 16 to 32752 (32768 - 16) bytes. The base register (Rb) is
            // usually SP, but may be another register.
            //
            // The epilogue instruction sequence is:
            //
            // ==>  lda   sp, +N(sp)        // deallocate stack frame
            //      ret   zero, (ra)        // return
            // or
            //
            // ==>  lda   sp, +N(Rx)        // restore SP and deallocate frame
            //      ret   zero, (ra)        // return
            //

            Context->IntSp = Offset16 + IntegerRegister[Rb];
            return NextPc;

        } else if ((Opcode == ARITH_OP) && (Function == ADDQ_FUNC) &&
                   (Rc == SP_REG) &&
                   (Instruction.OpReg.RbvType == RBV_REGISTER_FORMAT)) {

            //
            // Add Quadword instruction.
            //
            // Since both source operands are registers, and the
            // destination register is SP, a register-value stack
            // deallocation is being performed. The value of the two
            // source registers should be added and this is the new
            // value of SP. One of the source registers is usually SP,
            // but may be another register.
            //
            // The epilogue instruction sequence is:
            //
            //      ldiq  Rx, N             // set [large] frame size
            //      ...
            // ==>  addq  sp, Rx, sp        // deallocate stack frame
            //      ret   zero, (ra)        // return
            // or
            //
            // ==>  addq  Rx, Ry, sp        // restore SP and deallocate frame
            //      ret   zero, (ra)        // return
            //

            Context->IntSp = IntegerRegister[Ra] + IntegerRegister[Rb];
            return NextPc;
        }
    }

    //
    // By default set the frame pointers to the current value of SP.
    //
    // When a procedure is called, the value of SP before the stack
    // allocation instruction is the virtual frame pointer. When reverse
    // executing instructions in the prologue, the value of SP before the
    // stack allocation instruction is encountered is the real frame
    // pointer. This is the current value of SP unless the procedure uses
    // a frame pointer (e.g., FP_REG).
    //

    //
    // If the address where control left the specified function is beyond
    // the end of the prologue, then the control PC is considered to be
    // within the function and the control address is set to the end of
    // the prologue. Otherwise, the control PC is not considered to be
    // within the function (i.e., the prologue).
    //
    // N.B. PrologEndAddress is equal to BeginAddress for a leaf function.
    //
    // The low-order two bits of PrologEndAddress are reserved for the IEEE
    // exception mode and so must be masked out.
    //

    if ((ControlPc < ALPHA_RF_BEGIN_ADDRESS(FunctionEntry)) ||
        (ControlPc >= ALPHA_RF_PROLOG_END_ADDRESS(FunctionEntry))) {
        ControlPc = ALPHA_RF_PROLOG_END_ADDRESS(FunctionEntry);
    }

    //
    // Scan backward through the prologue to reload callee saved registers
    // that were stored or copied and to increment the stack pointer if it
    // was decremented.
    //

    DecrementRegister = ZERO_REG;
    NextPc = Context->IntRa - 4;
    RestoredRa = FALSE;
    RestoredSp = FALSE;
    while (ControlPc > ALPHA_RF_BEGIN_ADDRESS(FunctionEntry)) {

        //
        // Get instruction value, decode fields, case on opcode value, and
        // reverse register store and stack decrement operations.
        // N.B. The location of Opcode, Ra, Rb, and Rc is the same across
        // all opcode formats. The same is not true for Function.
        //

        ControlPc -= 4;
        if (!ReadMemory(hProcess, ControlPc, &Instruction.Long, 4, &cb)) {
             return 0;
        }
        Function = Instruction.OpReg.Function;
        Literal8 = Instruction.OpLit.Literal;
        Offset16 = Instruction.Memory.MemDisp;
        Opcode = Instruction.OpReg.Opcode;
        Ra = Instruction.OpReg.Ra;
        Rb = Instruction.OpReg.Rb;
        Rc = Instruction.OpReg.Rc;

        //
        // Compare against each instruction type that will affect the context
        // and that is allowed in a prologue. Any other instructions found
        // in the prologue will be ignored since they are assumed to have no
        // effect on the context.
        //

        switch (Opcode) {

        case STQ_OP :

            //
            // Store Quad instruction.
            //
            // If the base register is SP, then reload the source register
            // value from the value stored on the stack.
            //
            // The prologue instruction sequence is:
            //
            // ==>  stq   Rx, N(sp)         // save integer register Rx
            //

            if ((Rb == SP_REG) && (Ra != ZERO_REG)) {

                //
                // Reload the register by retrieving the value previously
                // stored on the stack.
                //

                Address = (Offset16 + Context->IntSp);
                if (!ReadMemory(hProcess, Address, &IntegerRegister[Ra], 8L, &cb)) {
                    return 0;
                }

                //
                // If the destination register is RA and this is the first
                // time that RA is being restored, then set the address of
                // where control left the previous frame. Otherwise, if this
                // is the second time RA is being restored, then the first
                // one was an interrupt or exception address and the return
                // PC should not have been biased by 4.
                //

                if (Ra == RA_REG) {
                    if (RestoredRa == FALSE) {
                        NextPc = Context->IntRa - 4;
                        RestoredRa = TRUE;

                    } else {
                        NextPc += 4;
                    }

                //
                // Otherwise, if the destination register is SP and this is
                // the first time that SP is being restored, then set the
                // establisher frame pointers.
                //

                } else if ((Ra == SP_REG) && (RestoredSp == FALSE)) {
                    RestoredSp = TRUE;
                }

                //
                // If a context pointer record is specified, then record
                // the address where the destination register contents
                // are stored.
                //

                //if (ContextPointers != (PKNONVOLATILE_CONTEXT_POINTERS) NULL) {
                //    ContextPointers->IntegerContext[Ra] = (PULONGLONG)Address;
                //}
            }
            break;

        case LDAH_OP :
            Offset16 <<= 16;

        case LDA_OP :

            //
            // Load Address High, Load Address instruction.
            //
            // There are several cases where the lda and/or ldah instructions
            // are used: one to decrement the stack pointer directly, and the
            // others to load immediate values into another register and that
            // register is then used to decrement the stack pointer.
            //
            // In the examples below, as a single instructions or as a pair,
            // a lda may be substituted for a ldah and visa-versa.
            //

            if (Ra == SP_REG) {
                if (Rb == SP_REG) {

                    //
                    // If both the destination (Ra) and base (Rb) registers
                    // are SP, then a standard stack allocation was performed
                    // and the negated displacement value is the stack frame
                    // size. The amount of stack allocation possible using
                    // the lda instruction ranges from 16 to 32768 bytes and
                    // the amount of stack allocation possible using the ldah
                    // instruction ranges from 65536 to 2GB in multiples of
                    // 65536 bytes. It is rare for the ldah instruction to be
                    // used in this manner.
                    //
                    // The prologue instruction sequence is:
                    //
                    // ==>  lda   sp, -N(sp)    // allocate stack frame
                    //

                    FrameSize = -Offset16;
                    goto StackAllocation;

                } else {

                    //
                    // The destination register is SP and the base register
                    // is not SP, so this instruction must be the second
                    // half of an instruction pair to allocate a large size
                    // (>32768 bytes) stack frame. Save the displacement value
                    // as the partial decrement value and postpone adjusting
                    // the value of SP until the first instruction of the pair
                    // is encountered.
                    //
                    // The prologue instruction sequence is:
                    //
                    //      ldah  Rx, -N(sp)    // prepare new SP (upper)
                    // ==>  lda   sp, sN(Rx)    // allocate stack frame
                    //

                    DecrementRegister = Rb;
                    DecrementOffset = Offset16;
                }

            } else if (Ra == DecrementRegister) {
                if (Rb == DecrementRegister) {

                    //
                    // Both the destination and base registers are the
                    // decrement register, so this instruction exists as the
                    // second half of a two instruction pair to load a
                    // 31-bit immediate value into the decrement register.
                    // Save the displacement value as the partial decrement
                    // value.
                    //
                    // The prologue instruction sequence is:
                    //
                    //      ldah  Rx, +N(zero)      // set frame size (upper)
                    // ==>  lda   Rx, sN(Rx)        // set frame size (+lower)
                    //      ...
                    //      subq  sp, Rx, sp        // allocate stack frame
                    //

                    DecrementOffset += Offset16;

                } else if (Rb == ZERO_REG) {

                    //
                    // The destination register is the decrement register and
                    // the base register is zero, so this instruction exists
                    // to load an immediate value into the decrement register.
                    // The stack frame size is the new displacement value added
                    // to the previous displacement value, if any.
                    //
                    // The prologue instruction sequence is:
                    //
                    // ==>  lda   Rx, +N(zero)      // set frame size
                    //      ...
                    //      subq  sp, Rx, sp        // allocate stack frame
                    // or
                    //
                    // ==>  ldah  Rx, +N(zero)      // set frame size (upper)
                    //      lda   Rx, sN(Rx)        // set frame size (+lower)
                    //      ...
                    //      subq  sp, Rx, sp        // allocate stack frame
                    //

                    FrameSize = (Offset16 + DecrementOffset);
                    goto StackAllocation;

                } else if (Rb == SP_REG) {

                    //
                    // The destination (Ra) register is SP and the base (Rb)
                    // register is the decrement register, so a two
                    // instruction, large size (>32768 bytes) stack frame
                    // allocation was performed. Add the new displacement
                    // value to the previous displacement value. The negated
                    // displacement value is the stack frame size.
                    //
                    // The prologue instruction sequence is:
                    //
                    // ==>  ldah  Rx, -N(sp)    // prepare new SP (upper)
                    //      lda   sp, sN(Rx)    // allocate stack frame
                    //

                    FrameSize = -(Offset16 + (LONG)DecrementOffset);
                    goto StackAllocation;
                }
            }
            break;

        case ARITH_OP :

            if ((Function == ADDQ_FUNC) &&
                (Instruction.OpReg.RbvType != RBV_REGISTER_FORMAT)) {

                //
                // Add Quadword (immediate) instruction.
                //
                // If the first source register is zero, and the second
                // operand is a literal, and the destination register is
                // the decrement register, then the instruction exists
                // to load an unsigned immediate value less than 256 into
                // the decrement register. The immediate value is the stack
                // frame size.
                //
                // The prologue instruction sequence is:
                //
                // ==>  addq  zero, N, Rx       // set frame size
                //      ...
                //      subq  sp, Rx, sp        // allocate stack frame
                //

                if ((Ra == ZERO_REG) && (Rc == DecrementRegister)) {
                    FrameSize = Literal8;
                    goto StackAllocation;
                }

            } else if ((Function == SUBQ_FUNC) &&
                       (Instruction.OpReg.RbvType == RBV_REGISTER_FORMAT)) {

                //
                // Subtract Quadword (register) instruction.
                //
                // If both source operands are registers and the first
                // source (minuend) register and the destination
                // (difference) register are both SP, then a register value
                // stack allocation was performed and the second source
                // (subtrahend) register value will be added to SP when its
                // value is known. Until that time save the register number of
                // this decrement register.
                //
                // The prologue instruction sequence is:
                //
                //      ldiq  Rx, N             // set frame size
                //      ...
                // ==>  subq  sp, Rx, sp        // allocate stack frame
                //

                if ((Ra == SP_REG) && (Rc == SP_REG)) {
                    DecrementRegister = Rb;
                    DecrementOffset = 0;
                }
            }
            break;

        case BIT_OP :

            //
            // If the second operand is a register the bit set instruction
            // may be a register move instruction, otherwise if the second
            // operand is a literal, the bit set instruction may be a load
            // immediate value instruction.
            //

            if ((Function == BIS_FUNC) && (Rc != ZERO_REG)) {
                if (Instruction.OpReg.RbvType == RBV_REGISTER_FORMAT) {

                    //
                    // Bit Set (register move) instruction.
                    //
                    // If both source registers are the same register, or
                    // one of the source registers is zero, then this is a
                    // register move operation. Restore the value of the
                    // source register by copying the current destination
                    // register value back to the source register.
                    //
                    // The prologue instruction sequence is:
                    //
                    // ==>  bis   Rx, Rx, Ry        // copy register Rx
                    // or
                    //
                    // ==>  bis   Rx, zero, Ry      // copy register Rx
                    // or
                    //
                    // ==>  bis   zero, Rx, Ry      // copy register Rx
                    //

                    if (Ra == ZERO_REG) {

                        //
                        // Map the third case above to the first case.
                        //

                        Ra = Rb;

                    } else if (Rb == ZERO_REG) {

                        //
                        // Map the second case above to the first case.
                        //

                        Rb = Ra;
                    }

                    if ((Ra == Rb) && (Ra != ZERO_REG)) {
                        IntegerRegister[Ra] = IntegerRegister[Rc];


                        //
                        // If the destination register is RA and this is the
                        // first time that RA is being restored, then set the
                        // address of where control left the previous frame.
                        // Otherwise, if this is the second time RA is being
                        // restored, then the first one was an interrupt or
                        // exception address and the return PC should not
                        // have been biased by 4.
                        //

                        if (Ra == RA_REG) {
                            if (RestoredRa == FALSE) {
                                NextPc = Context->IntRa - 4;
                                RestoredRa = TRUE;

                            } else {
                                NextPc += 4;
                            }
                        }

                        //
                        // If the source register is SP and this is the first
                        // time SP is set, then this is a frame pointer set
                        // instruction. Reset the frame pointers to this new
                        // value of SP.
                        //

                        if ((Ra == SP_REG) && (RestoredSp == FALSE)) {
                            RestoredSp = TRUE;
                        }
                    }

                } else {

                    //
                    // Bit Set (load immediate) instruction.
                    //
                    // If the first source register is zero, and the second
                    // operand is a literal, and the destination register is
                    // the decrement register, then this instruction exists
                    // to load an unsigned immediate value less than 256 into
                    // the decrement register. The decrement register value is
                    // the stack frame size.
                    //
                    // The prologue instruction sequence is:
                    //
                    // ==>  bis   zero, N, Rx       // set frame size
                    //      ...
                    //      subq  sp, Rx, sp        // allocate stack frame
                    //

                    if ((Ra == ZERO_REG) && (Rc == DecrementRegister)) {
                        FrameSize = Literal8;
StackAllocation:
                        //
                        // Add the frame size to SP to reverse the stack frame
                        // allocation, leave the real frame pointer as is, set
                        // the virtual frame pointer with the updated SP value,
                        // and clear the decrement register.
                        //

                        Context->IntSp += FrameSize;
                        DecrementRegister = ZERO_REG;
                    }
                }
            }
            break;

        case STT_OP :

            //
            // Store T-Floating (quadword integer) instruction.
            //
            // If the base register is SP, then reload the source register
            // value from the value stored on the stack.
            //
            // The prologue instruction sequence is:
            //
            // ==>  stt   Fx, N(sp)         // save floating register Fx
            //

            if ((Rb == SP_REG) && (Ra != FZERO_REG)) {

                //
                // Reload the register by retrieving the value previously
                // stored on the stack.
                //

                Address = (Offset16 + Context->IntSp);
                if (!ReadMemory(hProcess, Address, &FloatingRegister[Ra], 8L, &cb)) {
                    return 0;
                }

                //
                // If a context pointer record is specified, then record
                // the address where the destination register contents are
                // stored.
                //

                //if (ContextPointers != (PKNONVOLATILE_CONTEXT_POINTERS) NULL) {
                //    ContextPointers->FloatingContext[Ra] = (PULONGLONG)Address;
                //}
            }
            break;


        case STS_OP :

            //
            // Store T-Floating (dword integer) instruction.
            //
            // If the base register is SP, then reload the source register
            // value from the value stored on the stack.
            //
            // The prologue instruction sequence is:
            //
            // ==>  stt   Fx, N(sp)         // save floating register Fx
            //

            if ((Rb == SP_REG) && (Ra != FZERO_REG)) {

                //
                // Reload the register by retrieving the value previously
                // stored on the stack.
                //

                float f;

                Address = (Offset16 + Context->IntSp);
                if (!ReadMemory(hProcess, Address, &f, sizeof(float), &cb)) {
                    return 0;
                }

                //
                // value was stored as a float.  Do a conversion to a
                // double, since registers are Always read as doubles
                //
                FloatingRegister[Ra] = (ULONGLONG)(double)f;

                //
                // If a context pointer record is specified, then record
                // the address where the destination register contents are
                // stored.
                //

                //if (ContextPointers != (PKNONVOLATILE_CONTEXT_POINTERS) NULL) {
                //    ContextPointers->FloatingContext[Ra] = (PULONGLONG)Address;
                //}
            }
            break;

        case FPOP_OP :

            //
            // N.B. The floating operate function field is not the same as
            // the integer operate nor the jump function fields.
            //

            if (Instruction.FpOp.Function == CPYS_FUNC) {

                //
                // Copy Sign (floating-point move) instruction.
                //
                // If both source registers are the same register, then this is
                // a floating-point register move operation. Restore the value
                // of the source register by copying the current destination
                // register value to the source register.
                //
                // The prologue instruction sequence is:
                //
                // ==>  cpys  Fx, Fx, Fy        // copy floating register Fx
                //

                if ((Ra == Rb) && (Ra != FZERO_REG)) {
                    FloatingRegister[Ra] = FloatingRegister[Rc];
                }
            }

        default :
            break;
        }
    }

    if (StackAdjust) {
        // Check for exlicit stack adjust amount

        Context->IntSp += StackAdjust;
    }

    if (FixedReturn != 0) {
        NextPc = FixedReturn;
    }

    return NextPc;
}

void
ConvertAlphaRf32To64(
    PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY rf32,
    PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY rf64
    )
{
    rf64->BeginAddress     = (ULONG64)(LONG64)(LONG)rf32->BeginAddress;
    rf64->EndAddress       = (ULONG64)(LONG64)(LONG)rf32->EndAddress;
    rf64->ExceptionHandler = (ULONG64)(LONG64)(LONG)rf32->ExceptionHandler;
    rf64->HandlerData      = (ULONG64)(LONG64)(LONG)rf32->HandlerData;
    rf64->PrologEndAddress = (ULONG64)(LONG64)(LONG)rf32->PrologEndAddress;
}

BOOL
WalkAlphaGetStackFrame(
    HANDLE                            hProcess,
    PULONG64                          ReturnAddress,
    PULONG64                          FramePointer,
    PALPHA_NT5_CONTEXT                Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  GetFunctionEntry,
    PKDHELP64                         KdHelp,
    BOOL                              Use64
    )
{
    PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY rf64;
    LOCAL_FUNCTION_ENTRY             UnwindFunctionEntry;
    ULONG64                          NextPc = Context->IntRa;
    BOOL                             rval = TRUE;
    ULONG                            cb;
    ULONG                            StackAdjust;
    ULONG64                          FixedReturn;


    if (*ReturnAddress == 0) {
        return FALSE;
    }

    __try {
        rf64 = LookupFunctionEntry( hProcess, *ReturnAddress, ReadMemory, GetModuleBase, GetFunctionEntry, Use64 );

        if (rf64) {

            // Construct a function entry suitable for unwinding from ControlPc

            UnwindFunctionEntry.Address = 0;
            UnwindFunctionEntry.Process = 0;

            GetUnwindFunctionEntry( hProcess, *ReturnAddress, ReadMemory, GetModuleBase, GetFunctionEntry, Use64, rf64,
                                    &UnwindFunctionEntry.Value, &StackAdjust, &FixedReturn );
#if DBG
            UnwindFunctionEntry.Description = "from UnwindFunctionEntry";
            ShowRuntimeFunction(&UnwindFunctionEntry.Value, "VirtualUnwind: unwind function entry");
            if (DebugFunctionEntries) {
                dbPrint("    FixedReturn      = %16.8I64x\n", FixedReturn );
                dbPrint("    StackAdjust      = %16x\n", StackAdjust );
            }
#endif

            NextPc = VirtualUnwind( hProcess, *ReturnAddress, &UnwindFunctionEntry.Value, StackAdjust, FixedReturn, Context, ReadMemory);
#if DBG
            if (DebugFunctionEntries) {
                dbPrint("NextPc = %.8I64x\n", NextPc );
            }
#endif
            if (!NextPc) {
                rval = FALSE;
            }

            //
            // The Ra value coming out of mainCRTStartup is set by some RTL
            // routines to be "1"; return out of mainCRTStartup is actually
            // done through Jump/Unwind, so this serves to cause an error if
            // someone actually does a return.  That's why we check here for
            // NextPc == 1 - this happens when in the frame for CRTStartup.
            //
            // We test for (0-4) and (1-4) because on ALPHA, the value returned by
            // VirtualUnwind is the value to be passed to the next call to
            // VirtualUnwind, which is NOT the same as the Ra - it's sometimes
            // decremented by four - this gives the faulting instruction -
            // in particular, we want the fault instruction so we can get the
            // correct scope in the case of an exception.
            //
            if ((NextPc == 1) || (NextPc == 4) || (NextPc == (0-4)) || (NextPc == (1-4)) ) {
                NextPc = 0;
            }
            if ( !NextPc || (NextPc == *ReturnAddress && *FramePointer == Context->IntSp) ) {
                rval = FALSE;
            }

            *ReturnAddress = NextPc;
            *FramePointer  = Context->IntSp;

        } else {

            if ( (NextPc == *ReturnAddress && *FramePointer == Context->IntSp) ||
                 (NextPc == 1) || (NextPc == 0) || (NextPc == (-4)) ) {
                rval = FALSE;
            }

            *ReturnAddress = Context->IntRa;
            *FramePointer  = Context->IntSp;

        }

    } __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                    EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        rval = FALSE;
    }

    return rval;
}


BOOL
WalkAlphaInit(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PALPHA_NT5_CONTEXT                Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  GetFunctionEntry,
    BOOL                              Use64
    )
{
    ALPHA_NT5_CONTEXT  ContextSave;
    ULONG64            PcOffset;
    ULONG64            FrameOffset;
    DWORD              cb;
    ALPHA_KEXCEPTION_FRAME   ExceptionFrame;
    PALPHA_KEXCEPTION_FRAME  pef = &ExceptionFrame;
    DWORD              Result;

    if (StackFrame->AddrFrame.Offset) {
        if (ReadMemory( hProcess,
                        StackFrame->AddrFrame.Offset,
                        &ExceptionFrame,
                        sizeof(ALPHA_KEXCEPTION_FRAME),
                        &cb )) {
            //
            // successfully read an exception frame from the stack
            //
            Context->IntSp  = StackFrame->AddrFrame.Offset;
            Context->Fir    = pef->SwapReturn;
            Context->IntRa  = pef->SwapReturn;
            Context->IntS0  = pef->IntS0;
            Context->IntS1  = pef->IntS1;
            Context->IntS2  = pef->IntS2;
            Context->IntS3  = pef->IntS3;
            Context->IntS4  = pef->IntS4;
            Context->IntS5  = pef->IntS5;
            Context->Psr    = pef->Psr;
        } else {
            return FALSE;
        }
    }

    ZeroMemory( StackFrame, FIELD_OFFSET( STACKFRAME64, KdHelp.ThCallbackBStore) );

    StackFrame->Virtual = TRUE;

    StackFrame->AddrPC.Offset       = Context->Fir;
    StackFrame->AddrPC.Mode         = AddrModeFlat;

    StackFrame->AddrFrame.Offset    = Context->IntSp;
    StackFrame->AddrFrame.Mode      = AddrModeFlat;

    ContextSave = *Context;
    PcOffset    = StackFrame->AddrPC.Offset;
    FrameOffset = StackFrame->AddrFrame.Offset;

    if (!WalkAlphaGetStackFrame( hProcess,
                        &PcOffset,
                        &FrameOffset,
                        &ContextSave,
                        ReadMemory,
                        GetModuleBase,
                        GetFunctionEntry,
                        &StackFrame->KdHelp,
                        Use64) ) {

        StackFrame->AddrReturn.Offset = Context->IntRa;

    } else {

        StackFrame->AddrReturn.Offset = PcOffset;
    }

    StackFrame->AddrReturn.Mode     = AddrModeFlat;

    //
    // get the arguments to the function
    //
    StackFrame->Params[0] = Context->IntA0;
    StackFrame->Params[1] = Context->IntA1;
    StackFrame->Params[2] = Context->IntA2;
    StackFrame->Params[3] = Context->IntA3;

    return TRUE;
}


BOOL
WalkAlphaNext(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PALPHA_NT5_CONTEXT                Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  GetFunctionEntry,
    BOOL                              Use64
    )
{
    DWORD              cb;
    ALPHA_NT5_CONTEXT  ContextSave;
    BOOL               rval = TRUE;
    ULONG64            Address;
    PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY  rf64;
    ULONG64            SystemRangeStart;
    DWORD              dw;
    ULONG64            qw;


    if (!WalkAlphaGetStackFrame( hProcess,
                        &StackFrame->AddrPC.Offset,
                        &StackFrame->AddrFrame.Offset,
                        Context,
                        ReadMemory,
                        GetModuleBase,
                        GetFunctionEntry,
                        &StackFrame->KdHelp,
                        Use64) ) {

        rval = FALSE;

        //
        // If the frame could not be unwound or is terminal, see if
        // there is a callback frame:
        //

        if (AppVersion.Revision >= 4 && CALLBACK_STACK(StackFrame)) {

            if (AppVersion.Revision >= 6) {
                SystemRangeStart = SYSTEM_RANGE_START(StackFrame);
            } else {
                //
                // This might not really work right with old debuggers, but it keeps
                // us from looking off the end of the structure anyway.
                //
                SystemRangeStart = 0x80000000;
            }

           if (CALLBACK_STACK(StackFrame) >= SystemRangeStart) {

                //
                // it is the pointer to the stack frame that we want,
                // or -1.

                Address = CALLBACK_STACK(StackFrame);

            } else {

                //
                // if it is a positive integer, it is the offset to
                // the address in the thread.
                // Look up the pointer:
                //

                if (Use64) {
                    rval = ReadMemory(hProcess,
                                      (CALLBACK_THREAD(StackFrame) +
                                                     CALLBACK_STACK(StackFrame)),
                                      &Address,
                                      sizeof(ULONG64),
                                      &cb);
                } else {
                    rval = ReadMemory(hProcess,
                                      (CALLBACK_THREAD(StackFrame) +
                                                     CALLBACK_STACK(StackFrame)),
                                      &dw,
                                      sizeof(DWORD),
                                      &cb);
                    Address = (ULONG64)(LONG64)(LONG)dw;
                }

                if (!rval || Address == 0) {
                    Address = (ULONG64)-1;
                    CALLBACK_STACK(StackFrame) = (DWORD)-1;
                }

            }

            if ( (Address == (ULONG64)-1) ||
                !(rf64 = LookupFunctionEntry(hProcess, CALLBACK_FUNC(StackFrame), ReadMemory, GetModuleBase, GetFunctionEntry, Use64 )) ) {

                rval = FALSE;

            } else {

                if (Use64) {
                    ReadMemory(hProcess,
                               (Address + CALLBACK_NEXT(StackFrame)),
                               &CALLBACK_STACK(StackFrame),
                               sizeof(ULONG64),
                               &cb);
                    StackFrame->AddrPC.Offset = ALPHA_RF_PROLOG_END_ADDRESS(rf64);
                } else {
                    ReadMemory(hProcess,
                               (Address + CALLBACK_NEXT(StackFrame)),
                               &dw,
                               sizeof(DWORD),
                               &cb);
                    CALLBACK_STACK(StackFrame) = dw;
                    StackFrame->AddrPC.Offset = ALPHA_RF_PROLOG_END_ADDRESS((PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY)rf64);
                }

                StackFrame->AddrFrame.Offset = Address;
                Context->IntSp = Address;

                rval = TRUE;
            }
        }
    }

    //
    // get the return address
    //
    ContextSave = *Context;
    StackFrame->AddrReturn.Offset = StackFrame->AddrPC.Offset;

    if (!WalkAlphaGetStackFrame( hProcess,
                        &StackFrame->AddrReturn.Offset,
                        &qw,
                        &ContextSave,
                        ReadMemory,
                        GetModuleBase,
                        GetFunctionEntry,
                        &StackFrame->KdHelp,
                        Use64) ) {

        StackFrame->AddrReturn.Offset = 0;

    }

    //
    // get the arguments to the function
    //
    StackFrame->Params[0] = ContextSave.IntA0;
    StackFrame->Params[1] = ContextSave.IntA1;
    StackFrame->Params[2] = ContextSave.IntA2;
    StackFrame->Params[3] = ContextSave.IntA3;

    return rval;
}


PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY
LookupFunctionEntry(
    HANDLE                            hProcess,
    ULONG64                           ControlPc,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  GetFunctionEntry,
    BOOL                              Use64
    )
/*++

Routine Description:

    This function searches the currently active function tables (static and dynamic)
    for an entry that corresponds to the specified Address.

    This function mirrors RtlLookupFunctionEntry with changes required to make it work
    from a separate process and capable of searching 32- or 64-bit function tables

Arguments:

    hProcess - Proces handle

    ControlPc - Address of an instruction within the specified function.

    ReadMemory - Routine to read the target process memory

    Use64 - TRUE:  Target process is 64 bit
            FALSE: Target process is 32 bit

Return Value:

    If there is no entry in the function table for the specified ControlPc, then
    NULL is returned. Otherwise, the address of the primary function table
    entry that corresponds to the specified PC is returned.

    This function always returns a 64-bit function entry. 32-bit function entries
    are converted to the 64-bit equivalent.

--*/

{
    PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY FunctionEntry;

#if DBG
    if (DebugFunctionEntries) {
        dbPrint("\nLookupFunctionEntry(ControlPc=%.8I64x,Use64=%d)\n", ControlPc, Use64 );
    }
#endif

    // Look for a static or dynamic function entry

    FunctionEntry = LookupDirectFunctionEntry( hProcess, ControlPc, ReadMemory, GetModuleBase, GetFunctionEntry, Use64 );

    if (FunctionEntry != NULL) {

        //
        // The capability exists for more than one function entry
        // to map to the same function. This permits a function to
        // have discontiguous code segments described by separate
        // function table entries. If the ending prologue address
        // is not within the limits of the begining and ending
        // address of the function able entry, then the prologue
        // ending address is the address of the primary function
        // table entry that accurately describes the ending prologue
        // address.
        //

        if ((ALPHA_RF_PROLOG_END_ADDRESS(FunctionEntry) <  ALPHA_RF_BEGIN_ADDRESS(FunctionEntry)) ||
            (ALPHA_RF_PROLOG_END_ADDRESS(FunctionEntry) >= ALPHA_RF_END_ADDRESS(FunctionEntry))) {
#if DBG
            ShowRuntimeFunction(FunctionEntry, "LookupFunctionEntry: secondary entry");
#endif
            // Officially the PrologEndAddress field in secondary function entries
            // doesn't have the exception mode bits there have been some versions
            // of alpha tools that put them there. Strip them off to be safe.

            FunctionEntry = FetchFunctionEntry( hProcess, ALPHA_RF_PROLOG_END_ADDRESS(FunctionEntry), ReadMemory, Use64 );
            if (!FunctionEntry) {
                return NULL;
            }
            FunctionEntry = PromoteFunctionEntry( FunctionEntry );

        } else if (ALPHA_RF_IS_FIXED_RETURN(FunctionEntry)) {
            ULONG64 FixedReturn = FIXED_RETURN(FunctionEntry);

#if DBG
            ShowRuntimeFunction(FunctionEntry, "LookupFunctionEntry: fixed return entry");
#endif
            // Recursively call LookupFunctionEntry to ensure we get a primary function entry here.
            // Check for incorrectly formed function entry where the fixed return points to itself.

            if ((FixedReturn <  ALPHA_RF_BEGIN_ADDRESS(FunctionEntry)) ||
                (FixedReturn >= ALPHA_RF_END_ADDRESS(FunctionEntry))) {
                FunctionEntry = LookupFunctionEntry( hProcess, FIXED_RETURN(FunctionEntry), ReadMemory, GetModuleBase, GetFunctionEntry, Use64 );
            }
        }
#if DBG
        ShowRuntimeFunction(FunctionEntry, "LookupFunctionEntry: primary entry");
#endif
    }

#if DBG
    if (DebugFunctionEntries) {
        if (FUNCTION_ENTRY_ADDRESS(FunctionEntry)) {
            dbPrint("LookupFunctionEntry: returning FunctionEntry=%.8I64x %s\n",
                FUNCTION_ENTRY_ADDRESS(FunctionEntry),
                FUNCTION_ENTRY_DESCRIPTION(FunctionEntry) );
        } else {
            dbPrint("LookupFunctionEntry: returning FunctionEntry=%.8I64x %s\n",
                (ULONG64)(LONG64)(LONG_PTR)FunctionEntry,
                FUNCTION_ENTRY_DESCRIPTION(FunctionEntry) );
        }
    }
#endif
    return FunctionEntry;
}


PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY
LookupDirectFunctionEntry (
    HANDLE                            hProcess,
    ULONG64                           ControlPc,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  GetFunctionEntry,
    BOOL                              Use64
    )
/*++

Routine Description:

    This function searches the currently active function tables (static and dynamic)
    for an entry that corresponds to the specified PC value.

    This function mirrors RtlLookupDirectFunctionEntry with changes required to make it work
    from a separate process and capable of searching 32- or 64-bit function tables

Arguments:

    ControlPc - Supplies the address of an instruction within the specified
        function.

Return Value:

    If there is no entry in the function table for the specified PC, then
    NULL is returned. Otherwise, the address of the function table entry
    that corresponds to the specified PC is returned.

--*/

{
    PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY FunctionEntry;
    BOOLEAN InImage;

    //
    // look for function entry in static function tables
    //

    FunctionEntry = LookupStaticFunctionEntry( hProcess, ControlPc, ReadMemory, GetModuleBase, GetFunctionEntry, Use64, &InImage );

    //
    // If not in static image range and no static function entry
    // found use FunctionEntryCallback routine (if present) for
    // dynamic function entry or some other source of pdata (e.g.
    // saved pdata information for ROM images)
    //

    if (FunctionEntry == NULL) {
        PPROCESS_ENTRY  ProcessEntry = FindProcessEntry( hProcess );
        if (ProcessEntry) {
            if (!InImage) {
                if (ProcessEntry->pFunctionEntryCallback32) {
                    PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY FunctionEntry32;

                    FunctionEntry32 = ProcessEntry->pFunctionEntryCallback32(
                                            hProcess,
                                            (ULONG)ControlPc,
                                            (PVOID)ProcessEntry->FunctionEntryUserContext
                                            );
                    if (FunctionEntry32) {
                        LastDynamicFunctionEntry.Process = hProcess;
                        LastDynamicFunctionEntry.Address = 0;
#if DBG
                        LastDynamicFunctionEntry.Description = "from FunctionEntryCallback32";
#endif
                        ConvertAlphaRf32To64( FunctionEntry32, &LastDynamicFunctionEntry.Value );
                        FunctionEntry = &LastDynamicFunctionEntry.Value;
                    }

                } else if (ProcessEntry->pFunctionEntryCallback64) {
                    FunctionEntry = ProcessEntry->pFunctionEntryCallback64(
                                            hProcess,
                                            ControlPc,
                                            ProcessEntry->FunctionEntryUserContext
                                            );
                    if (FunctionEntry) {
                        LastDynamicFunctionEntry.Process = hProcess;
                        LastDynamicFunctionEntry.Address = 0;
#if DBG
                        LastDynamicFunctionEntry.Description = "from FunctionEntryCallback64";
#endif
                        LastDynamicFunctionEntry.Value = *FunctionEntry;
                        FunctionEntry = &LastDynamicFunctionEntry.Value;
                    }
                }

                if (FunctionEntry) {
#if DBG
                    if (DebugFunctionEntries) dbPrint("  LookupDirectFunctionEntry: got dynamic entry\n");
#endif
                } else if (GetFunctionEntry != NULL) {
                    // VC 6 didn't supply a GetModuleBase callback so this code is to make
                    // stack walking backward compatible.
                    //
                    // If we don't have a function by now, use the old-style function entry
                    // callback and let VC give it to us. Note that MSDN documentation indicates
                    // that this callback should return a 3-field IMAGE_FUNCTION_ENTRY structure,
                    // but VC 6 actually returns the 5-field IMAGE_RUNTIME_FUNCTION_ENTRY. Since
                    // the purpose of this hack is to make VC 6 work just go with the
                    // way VC 6 does it rather than what MSDN says.


                    PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY UserFunctionEntry;
                    UserFunctionEntry = GetFunctionEntry( hProcess, ControlPc );

                    if (UserFunctionEntry) {
                        LastUserFunctionEntry.Process = hProcess;
                        LastUserFunctionEntry.Address = 0;
                        LastUserFunctionEntry.Value = *UserFunctionEntry;
                        FunctionEntry = &LastUserFunctionEntry.Value;
#if DBG
                        LastUserFunctionEntry.Description = "from LookupDirectFunctionEntry";
                        if (DebugFunctionEntries) dbPrint("  LookupDirectFunctionEntry: got user callback entry\n");
#endif
                    }
                }
            } else {
                // Nothing has turned up a function entry but we do have a module base address.
                // One possibility is that this is the kernel debugger and the pdata section is not
                // paged in. The last ditch attempt for a function entry will be an internal dbghelp
                // call to get the pdata entry from the debug info. This is not great because the data
                // in the debug section is incomplete and potentially out of date, but in most cases it
                // works and makes it possible to get user-mode stack traces in the kernel debugger.

                PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY UserFunctionEntry;
                UserFunctionEntry = GetAlphaFunctionEntryFromDebugInfo( ProcessEntry, ControlPc );

                if (UserFunctionEntry) {
                    LastUserFunctionEntry.Process = hProcess;
                    LastUserFunctionEntry.Address = 0;
                    LastUserFunctionEntry.Value = *UserFunctionEntry;
                    FunctionEntry = &LastUserFunctionEntry.Value;
#if DBG
                    LastUserFunctionEntry.Description = "from GetAlphaFunctionEntryFromDebugInfo";
                    if (DebugFunctionEntries) dbPrint("  LookupDirectFunctionEntry: got function entry from symbol file\n");
#endif
                }
            }
        }
    }

    return FunctionEntry;
}


PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY
LookupStaticFunctionEntry(
    HANDLE                            hProcess,
    ULONG64                           ControlPc,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  GetFunctionEntry,
    BOOL                              Use64,
    PBOOLEAN                          InImage
    )

/*++

Routine Description:

    This function searches the currently active static function tables for an
    entry that corresponds to the specified PC value.

Arguments:

    ControlPc - Supplies the address of an instruction within the specified
        function.

    InImage - Address to recieve a flag indicating whether the ControlPc
        was in the range of a static function table

Return Value:

    If there is no entry in the static function tables for the specified PC,
    then NULL is returned. Otherwise, the address of the function table entry
    that corresponds to the specified PC is returned.

--*/

{
    ULONG64 FunctionTable;
    ULONG64 NextFunctionTableEntry;
    PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY FunctionEntry;
    ULONG SizeOfExceptionTable;
    LONG High;
    ULONG64 ImageBase;
    LONG Low;
    LONG Middle;
    ULONG Index;

    // First check the most recent primary and secondary function entry cache

    if (LastPrimaryFunctionEntry.Process == hProcess &&
        ControlPc >= LastPrimaryFunctionEntry.Value.BeginAddress &&
        ControlPc <  ALPHA_RF_END_ADDRESS(&LastPrimaryFunctionEntry.Value)) {
        return &LastPrimaryFunctionEntry.Value;
    }

    if (LastSecondaryFunctionEntry.Process == hProcess &&
        ControlPc >= LastSecondaryFunctionEntry.Value.BeginAddress &&
        ControlPc <  ALPHA_RF_END_ADDRESS(&LastSecondaryFunctionEntry.Value)) {
        return &LastSecondaryFunctionEntry.Value;
    }

    // Next check the array of recently fetched function entries

    for (Index = 0; Index < LocalFunctionEntryCount; Index++) {
        if (LocalFunctionEntry[Index].Process == hProcess &&
            ControlPc >= LocalFunctionEntry[Index].Value.BeginAddress &&
            ControlPc <  ALPHA_RF_END_ADDRESS(&LocalFunctionEntry[Index].Value)) {

            return &LocalFunctionEntry[Index].Value;
        }
    }

    //
    // Search for the image that includes the specified PC value.
    //

    ImageBase = GetModuleBase( hProcess, ControlPc );

#if DBG
    if (DebugFunctionEntries) {
        dbPrint("  LookupStaticEntry(ControlPc=%.8I64x) ImageBase = %.8I64x\n",
                 ControlPc, ImageBase);
    }
#endif

    //
    // If an image is found that includes the specified PC, then locate the
    // function table for the image.
    //

    *InImage = (ImageBase != 0);
    FunctionEntry = NULL;
    if (ImageBase) {
        FunctionTable = FunctionTableBase( hProcess, ReadMemory, Use64, ImageBase, &SizeOfExceptionTable );

        //
        // If a function table is located, then search the function table
        // for a function table entry for the specified PC.
        //

        if (FunctionTable) {

            //
            // Initialize search indicies.
            //

            Low = 0;
            if (Use64) {
                High = (SizeOfExceptionTable / sizeof(IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY)) - 1;
            } else {
                High = (SizeOfExceptionTable / sizeof(IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY)) - 1;
            }

            //
            // Perform binary search on the function table for a function table
            // entry that subsumes the specified PC.
            //

            while (High >= Low) {

                //
                // Compute next probe index and test entry. If the specified PC
                // is greater than of equal to the beginning address and less
                // than the ending address of the function table entry, then
                // return the address of the function table entry. Otherwise,
                // continue the search.
                //

                Middle = (Low + High) >> 1;

                if (Use64) {
                    NextFunctionTableEntry = FunctionTable + Middle*sizeof(IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY);
                } else {
                    NextFunctionTableEntry = FunctionTable + Middle*sizeof(IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY);
                }

                //
                // Fetch the function entry and bail if there is an error reading it
                //
                FunctionEntry = FetchFunctionEntry( hProcess, NextFunctionTableEntry, ReadMemory, Use64 );
                if (!FunctionEntry) {
                    return NULL;
                }
                if (ControlPc < ALPHA_RF_BEGIN_ADDRESS(FunctionEntry)) {
                    High = Middle - 1;

                } else if (ControlPc >= ALPHA_RF_END_ADDRESS(FunctionEntry)) {
                    Low = Middle + 1;

                } else {
                    return PromoteFunctionEntry( FunctionEntry );
                }
            } // while (High >= Low)
        } // FunctionTable != NULL
    } // ImageBase != NULL
    return NULL;
}

VOID
GetUnwindFunctionEntry(
    HANDLE                                hProcess,
    ULONG64                               ControlPc,
    PREAD_PROCESS_MEMORY_ROUTINE64        ReadMemory,
    PGET_MODULE_BASE_ROUTINE64            GetModuleBase,
    PFUNCTION_TABLE_ACCESS_ROUTINE64      GetFunctionEntry,
    BOOL                                  Use64,
    PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY FunctionEntry,
    PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY UnwindFunctionEntry,
    PULONG                                StackAdjust,
    PULONG64                              FixedReturn
    )
/*++

Routine Description:

    This function returns a function entry (RUNTIME_FUNCTION) suitable
    for unwinding from ControlPc. It encapsulates the handling of primary
    and secondary function entries so that this processing is not duplicated
    in VirtualUnwind and other similar functions.

Arguments:

    ControlPc - Supplies the address where control left the specified
        function.

    FunctionEntry - Supplies the address of the function table entry for the
        specified function.

    UnwindFunctionEntry - Supplies the address of a function table entry which
        will be setup with appropriate fields for unwinding from ControlPc

Return Value:

    None.

--*/

{
    ULONG EntryType = 0;
    PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY SecondaryFunctionEntry = NULL;
    ULONG64 AlternateProlog;

    *FixedReturn = 0;
    *StackAdjust = 0;

#if DBG
    if (ControlPc & 0x3) {
        dbPrint("GetUnwindFunctionEntry: invalid PC for unwinding (low bits set): %16.8I64x.\n", ControlPc);
    }
#endif

    // FunctionEntry should never be null, but if it is create one that
    // looks like a leaf entry for ControlPc

    if (FunctionEntry == NULL) {
#if DBG
        dbPrint("\nGetUnwindFunctionEntry: Null function table entry for unwinding.\n");
#endif
        UnwindFunctionEntry->BeginAddress     = ControlPc;
        UnwindFunctionEntry->EndAddress       = ControlPc+4;
        UnwindFunctionEntry->ExceptionHandler = 0;
        UnwindFunctionEntry->HandlerData      = 0;
        UnwindFunctionEntry->PrologEndAddress = ControlPc;
        return;
    }

    // Save the most recent primary function entry

    LastPrimaryFunctionEntry = *(PLOCAL_FUNCTION_ENTRY)FunctionEntry;

    // Reference the copy of the function entry passed in so FetchFunctionEntry's
    // buffered function entries don't overwrite the primary

    FunctionEntry = &LastPrimaryFunctionEntry.Value;

    //
    // Because of the secondary-to-primary function entry indirection applied by
    // LookupFunctionEntry() ControlPc may not be within the range described
    // by the supplied function entry. Call LookupDirectFunctionEntry()
    // to recover the actual (secondary) function entry.  If we don't get a
    // valid associated function entry then process the unwind with the one
    // supplied, trusting that the caller has supplied the given entry intentionally.
    //
    // A secondary function entry is a RUNTIME_FUNCTION entry where
    // PrologEndAddress is not in the range of BeginAddress to EndAddress.
    // There are three types of secondary function entries. They are
    // distinquished by the Entry Type field (2 bits):
    //
    // ALPHA_RF_NOT_CONTIGUOUS - discontiguous code
    // ALPHA_RF_ALT_ENT_PROLOG - alternate entry point prologue
    // ALPHA_RF_NULL_CONTEXT   - null-context code
    //

    if ((ControlPc <  ALPHA_RF_BEGIN_ADDRESS(FunctionEntry)) ||
        (ControlPc >= ALPHA_RF_END_ADDRESS(FunctionEntry))) {

        // ControlPC is not in the range of the supplied function entry.
        // Get the actual function entry which is expected to be the
        // associated secondary function entry or a fixed return primary function.
#if DBG
        if (DebugFunctionEntries) {
            dbPrint("\nGetUnwindFunctionEntry:LookupDirectFunctionEntry(ControlPc=%.8I64x,Use64=%d)\n", ControlPc, Use64 );
        }
#endif
        SecondaryFunctionEntry = LookupDirectFunctionEntry( hProcess, ControlPc, ReadMemory, GetModuleBase, GetFunctionEntry, Use64 );

        if (SecondaryFunctionEntry) {

#if DBG
            ShowRuntimeFunction(SecondaryFunctionEntry, "GetUnwindFunctionEntry: LookupDirectFunctionEntry");
#endif

            // If this is a null-context tail region then unwind with a null-context-like descriptor

            if ((ControlPc >= ALPHA_RF_END_ADDRESS(SecondaryFunctionEntry)-(ALPHA_RF_NULL_CONTEXT_COUNT(SecondaryFunctionEntry)*4)) &&
                (ControlPc <  ALPHA_RF_END_ADDRESS(SecondaryFunctionEntry))) {

                // Use the secondary function entry with PrologEndAddress = BeginAddress.
                // This ensures that the prologue is not reverse executed.

                UnwindFunctionEntry->BeginAddress     = ALPHA_RF_BEGIN_ADDRESS(SecondaryFunctionEntry);
                UnwindFunctionEntry->EndAddress       = ALPHA_RF_END_ADDRESS(SecondaryFunctionEntry);
                UnwindFunctionEntry->ExceptionHandler = 0;
                UnwindFunctionEntry->HandlerData      = 0;
                UnwindFunctionEntry->PrologEndAddress = ALPHA_RF_BEGIN_ADDRESS(SecondaryFunctionEntry);
                return;
            }

            if ((SecondaryFunctionEntry->PrologEndAddress < ALPHA_RF_BEGIN_ADDRESS(SecondaryFunctionEntry)) ||
                (SecondaryFunctionEntry->PrologEndAddress > ALPHA_RF_END_ADDRESS(SecondaryFunctionEntry))) {

                // Got a secondary function entry as expected. But if indirection doesn't point
                // to FunctionEntry then ignore it and use the caller supplied FunctionEntry.

                if (ALPHA_RF_PROLOG_END_ADDRESS(SecondaryFunctionEntry) != FUNCTION_ENTRY_ADDRESS(FunctionEntry)) {
    #if DBG
                    ShowRuntimeFunction(SecondaryFunctionEntry,
                                        "GetUnwindFunctionEntry: unexpected secondary function entry from LookupDirectFunctionEntry");
    #endif
                    SecondaryFunctionEntry = NULL;
                }
            } else if (ALPHA_RF_IS_FIXED_RETURN(SecondaryFunctionEntry)) {
                // Got a fixed return entry. Switch to using the fixed return entry as the primary.

                    FunctionEntry = SecondaryFunctionEntry;
                    SecondaryFunctionEntry = NULL;

            } else {

                // Got a primary function entry. Ignore it and use caller supplied FunctionEntry.
    #if DBG
                ShowRuntimeFunction(SecondaryFunctionEntry,
                                    "GetUnwindFunctionEntry: unexpected primary function entry from LookupDirectFunctionEntry");
    #endif
                SecondaryFunctionEntry = NULL;
            }
#if DBG
        } else {
            ShowRuntimeFunction(SecondaryFunctionEntry, "GetUnwindFunctionEntry: LookupDirectFunctionEntry returned NULL");
#endif
        }
    } else {

        // ControlPC is in the range of the supplied function entry.

        // If this is a null-context tail region then unwind with a null-context-like descriptor

        if ((ControlPc >= ALPHA_RF_END_ADDRESS(FunctionEntry)-(ALPHA_RF_NULL_CONTEXT_COUNT(FunctionEntry)*4)) &&
            (ControlPc <  ALPHA_RF_END_ADDRESS(FunctionEntry))) {

            // Use the secondary function entry with PrologEndAddress = BeginAddress.
            // This ensures that the prologue is not reverse executed.

            UnwindFunctionEntry->BeginAddress     = ALPHA_RF_BEGIN_ADDRESS(FunctionEntry);
            UnwindFunctionEntry->EndAddress       = ALPHA_RF_END_ADDRESS(FunctionEntry);
            UnwindFunctionEntry->ExceptionHandler = 0;
            UnwindFunctionEntry->HandlerData      = 0;
            UnwindFunctionEntry->PrologEndAddress = ALPHA_RF_BEGIN_ADDRESS(FunctionEntry);
            return;
        }

        // Check if it is a secondary function entry. This shouldn't happen because
        // LookupFunctionEntry is always supposed to return a primary function entry.
        // But if we get passed a secondary, then switch to it's primary. However note
        // that we've gone through this pass

        if ((FunctionEntry->PrologEndAddress < ALPHA_RF_BEGIN_ADDRESS(FunctionEntry)) ||
            (FunctionEntry->PrologEndAddress > ALPHA_RF_END_ADDRESS(FunctionEntry))) {

            SecondaryFunctionEntry = FunctionEntry;
            FunctionEntry = FetchFunctionEntry( hProcess, ALPHA_RF_PROLOG_END_ADDRESS(SecondaryFunctionEntry), ReadMemory, Use64 );
#if DBG
            ShowRuntimeFunction(SecondaryFunctionEntry, "GetUnwindFunctionEntry: received secondary function entry");
#endif
        }
    }

    // FunctionEntry is now the primary function entry and if SecondaryFunctionEntry is
    // not NULL then it is the secondary function entry that contains the ControlPC. Setup a
    // copy of the FunctionEntry suitable for unwinding. By default use the supplied FunctionEntry.

    if (SecondaryFunctionEntry) {

        // Save the most secondary function entry

        LastSecondaryFunctionEntry = *(PLOCAL_FUNCTION_ENTRY)SecondaryFunctionEntry;

        // Extract the secondary function entry type.

        EntryType = ALPHA_RF_ENTRY_TYPE(SecondaryFunctionEntry);

        if (EntryType == ALPHA_RF_NOT_CONTIGUOUS) {
            // The exception happened in the body of the procedure but in a non-contiguous
            // section of code. Regardless of what entry point was used, it is normally valid
            // to unwind using the primary entry point prologue. The only exception is when an
            // alternate prologue is specified However, there may be an
            // alternate prologue end addresss specified in which case unwind using this
            // block as though it were the primary.

            AlternateProlog = ALT_PROLOG(SecondaryFunctionEntry);

            if ((AlternateProlog >= ALPHA_RF_BEGIN_ADDRESS(SecondaryFunctionEntry)) &&
                (AlternateProlog <  ALPHA_RF_END_ADDRESS(SecondaryFunctionEntry))) {

                // If the control PC is in the alternate prologue, use the secondary.
                // The control Pc is not in procedure context.

                if ((ControlPc >= ALPHA_RF_BEGIN_ADDRESS(SecondaryFunctionEntry)) &&
                    (ControlPc <  ALPHA_RF_END_ADDRESS(SecondaryFunctionEntry))) {

                    UnwindFunctionEntry->BeginAddress     = ALPHA_RF_BEGIN_ADDRESS(SecondaryFunctionEntry);
                    UnwindFunctionEntry->EndAddress       = ALPHA_RF_END_ADDRESS(SecondaryFunctionEntry);
                    UnwindFunctionEntry->ExceptionHandler = 0;
                    UnwindFunctionEntry->HandlerData      = 0;
                    UnwindFunctionEntry->PrologEndAddress = AlternateProlog;
                    return;
                }
            }

            // Fall out of the if statement to pick up the primary function entry below.
            // This code is in-procedure-context and subject to the primary's prologue
            // and exception handlers.

        } else if (EntryType == ALPHA_RF_ALT_ENT_PROLOG) {
            // Exception occured in an alternate entry point prologue.
            // Use the secondary function entry with a fixed-up PrologEndAddress.

            UnwindFunctionEntry->BeginAddress     = ALPHA_RF_BEGIN_ADDRESS(SecondaryFunctionEntry);
            UnwindFunctionEntry->EndAddress       = ALPHA_RF_END_ADDRESS(SecondaryFunctionEntry);
            UnwindFunctionEntry->ExceptionHandler = 0;
            UnwindFunctionEntry->HandlerData      = 0;
            UnwindFunctionEntry->PrologEndAddress = ALPHA_RF_END_ADDRESS(UnwindFunctionEntry);

            // Check for an alternate prologue.

            AlternateProlog = ALT_PROLOG(SecondaryFunctionEntry);
            if (AlternateProlog >= UnwindFunctionEntry->BeginAddress &&
                AlternateProlog <  UnwindFunctionEntry->EndAddress ) {
                // The prologue is only part of the procedure
                UnwindFunctionEntry->PrologEndAddress = AlternateProlog;
            }

            return;

        } else if (EntryType == ALPHA_RF_NULL_CONTEXT) {

            // Exception occured in null-context code associated with a primary function.
            // Use the secondary function entry with a PrologEndAddress = BeginAddress.
            // There is no prologue for null-context code.

            *StackAdjust = ALPHA_RF_STACK_ADJUST(SecondaryFunctionEntry);
            UnwindFunctionEntry->BeginAddress     = ALPHA_RF_BEGIN_ADDRESS(SecondaryFunctionEntry);
            UnwindFunctionEntry->EndAddress       = ALPHA_RF_END_ADDRESS(SecondaryFunctionEntry);
            UnwindFunctionEntry->ExceptionHandler = 0;
            UnwindFunctionEntry->HandlerData      = 0;
            UnwindFunctionEntry->PrologEndAddress = ALPHA_RF_BEGIN_ADDRESS(SecondaryFunctionEntry);
            return;
        }
    }

    // FunctionEntry is only null if there was an error fetching it from a passed in
    // secondary function entry.

    if (FunctionEntry == NULL) {
#if DBG
        dbPrint("\nGetUnwindFunctionEntry: Error in FetchFunctionEntry.\n");
#endif
        UnwindFunctionEntry->BeginAddress     = ControlPc;
        UnwindFunctionEntry->EndAddress       = ControlPc+4;
        UnwindFunctionEntry->ExceptionHandler = 0;
        UnwindFunctionEntry->HandlerData      = 0;
        UnwindFunctionEntry->PrologEndAddress = ControlPc;
        return;
    }

#if DBG
    if (ALPHA_RF_BEGIN_ADDRESS(FunctionEntry) >= ALPHA_RF_END_ADDRESS(FunctionEntry)) {
        ShowRuntimeFunction(FunctionEntry, "GetUnwindFunctionEntry: Warning - BeginAddress < EndAddress.");
    } else if (FunctionEntry->PrologEndAddress < ALPHA_RF_BEGIN_ADDRESS(FunctionEntry)) {
        ShowRuntimeFunction(FunctionEntry, "GetUnwindFunctionEntry: Warning - PrologEndAddress < BeginAddress.");
    } else if (FunctionEntry->PrologEndAddress > ALPHA_RF_END_ADDRESS(FunctionEntry)) {
        ShowRuntimeFunction(FunctionEntry, "GetUnwindFunctionEntry: Warning - PrologEndAddress > EndAddress.");
    }
#endif

    // Use the primary function entry

    *UnwindFunctionEntry = *FunctionEntry;
    UnwindFunctionEntry->EndAddress = ALPHA_RF_END_ADDRESS(UnwindFunctionEntry);  // Remove null-context count

    // If the primary has a fixed return address, pull that out now.

    if (ALPHA_RF_IS_FIXED_RETURN(FunctionEntry)) {
        *FixedReturn = FIXED_RETURN(FunctionEntry);
        UnwindFunctionEntry->ExceptionHandler = 0;
        UnwindFunctionEntry->HandlerData      = 0;
    }
}

PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY
FetchFunctionEntry (
    HANDLE                            hProcess,
    ULONG64                           Address,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    BOOL                              Use64
    )
/*++

Routine Description:

    Read a function entry from the target process.

--*/
{
    PLOCAL_FUNCTION_ENTRY CachedFunctionEntry;
    IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY FunctionEntry32;
    ULONG Index;
    DWORD cb;
    BOOL bReadMemory;

    // First check the most recent primary and secondary function entry cache

    if (LastPrimaryFunctionEntry.Process == hProcess &&
        LastPrimaryFunctionEntry.Address == Address ) {
        return &LastPrimaryFunctionEntry.Value;
    }

    if (LastSecondaryFunctionEntry.Process == hProcess &&
        LastSecondaryFunctionEntry.Address == Address ) {
        return &LastSecondaryFunctionEntry.Value;
    }

    // Next check the array of recently fetched function entries

    for (Index = 0; Index < LocalFunctionEntryCount; Index++) {
        if (LocalFunctionEntry[Index].Process == hProcess &&
            LocalFunctionEntry[Index].Address == Address ) {

            return &LocalFunctionEntry[Index].Value;
        }
    }

    // If not in the cache, replace the the entry that LocalFunctionEntryNext
    // points to. LocalFunctionEntryNext cycles through the last part of the
    // table and function entries we want to keep are promoted to the first
    // part of the table so they don't get overwritten by new ones being read
    // as part of the binary search through function entry tables.

    if (LocalFunctionEntryCount < LFE_MAX) {
        LocalFunctionEntryCount++;
        LocalFunctionEntryNext = LocalFunctionEntryCount;
    } else {
        LocalFunctionEntryNext++;
        if (LocalFunctionEntryNext >= LFE_MAX) {
            LocalFunctionEntryNext = LFE_NEW;
        }
    }

    CachedFunctionEntry = &LocalFunctionEntry[LocalFunctionEntryNext-1];

    if (Use64) {
        bReadMemory = ReadMemory(hProcess, Address, &CachedFunctionEntry->Value, sizeof(IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY), &cb);
    } else {
        if (bReadMemory = ReadMemory(hProcess, Address, &FunctionEntry32, sizeof(IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY), &cb)) {
            ConvertAlphaRf32To64( &FunctionEntry32, &CachedFunctionEntry->Value );
        }
    }

    // If successful, update cache entry and return its pointer
    // if failure, invalidate cache and return null
    if (bReadMemory) {
        CachedFunctionEntry->Address = Address;
        CachedFunctionEntry->Process = hProcess;
#if DBG
        CachedFunctionEntry->Description = "from target process";
#endif
        return &CachedFunctionEntry->Value;
    } else {
        CachedFunctionEntry->Address = 0;
        CachedFunctionEntry->Process = NULL;
#if DBG
        dbPrint("Can't read function entry from target process at: %I64x\n", Address);
#endif
        return NULL;
    }
}

PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY
PromoteFunctionEntry (
    PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY Address
    )
{
    ULONG Index;
    ULONG Move;
    PLOCAL_FUNCTION_ENTRY Entry = (PLOCAL_FUNCTION_ENTRY)Address;

    if (Entry >= &LocalFunctionEntry[1] &&
        Entry <  &LocalFunctionEntry[LocalFunctionEntryCount]) {

        Index = Entry - LocalFunctionEntry;

        // make sure it's promoted out of the new entry area
        if (Index >= LFE_NEW) {
            Move = Index - (LFE_NEW - 3);
        } else {
            Move = Index >= 3? 3 : 1;
        }

        if (Index > Move) {
            LOCAL_FUNCTION_ENTRY Temp = LocalFunctionEntry[Index];
            LocalFunctionEntry[Index] = LocalFunctionEntry[Index-Move];
            LocalFunctionEntry[Index-Move] = Temp;
            Index -= Move;
        }
        return &LocalFunctionEntry[Index].Value;
    }
    return Address;
}

ULONG64
FunctionTableBase(
    HANDLE                            hProcess,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    BOOL                              Use64,
    ULONG64                           Base,
    PULONG                            Size
    )
/*++

Routine Description:

    Return the address of an image's function entry table given the base
    address of the module.

--*/
{
    ULONG64 NtHeaders;
    ULONG64 ExceptionDirectoryEntryAddress;
    IMAGE_DATA_DIRECTORY ExceptionData;
    IMAGE_DOS_HEADER DosHeaderData;
    DWORD cb;

    // Read DOS header to calculate the address of the NT header.

    if (!ReadMemory( hProcess, Base, &DosHeaderData, sizeof(DosHeaderData), &cb ))
        return 0;
    if (DosHeaderData.e_magic != IMAGE_DOS_SIGNATURE)
        return 0;

    NtHeaders = Base + DosHeaderData.e_lfanew;

    if (Use64) {
        ExceptionDirectoryEntryAddress = NtHeaders +
               offsetof(IMAGE_NT_HEADERS64,OptionalHeader) +
               offsetof(IMAGE_OPTIONAL_HEADER64,DataDirectory) +
               IMAGE_DIRECTORY_ENTRY_EXCEPTION * sizeof(IMAGE_DATA_DIRECTORY);
    } else {
        ExceptionDirectoryEntryAddress = NtHeaders +
               offsetof(IMAGE_NT_HEADERS32,OptionalHeader) +
               offsetof(IMAGE_OPTIONAL_HEADER32,DataDirectory) +
               IMAGE_DIRECTORY_ENTRY_EXCEPTION * sizeof(IMAGE_DATA_DIRECTORY);
    }

    // Read NT header to get the image data directory.

    if (!ReadMemory( hProcess, ExceptionDirectoryEntryAddress, &ExceptionData, sizeof(IMAGE_DATA_DIRECTORY), &cb ))
        return 0;

    *Size = ExceptionData.Size;
    return Base + ExceptionData.VirtualAddress;
}

#if DBG
void
ShowRuntimeFunction(
    PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY FunctionEntry,
    PSTR Label
    )
{
    BOOL Secondary = FALSE;
    BOOL FixedReturn = FALSE;
    ULONG EntryType = 0;
    ULONG NullCount = 0;

    if (DebugFunctionEntries) {
        if (FUNCTION_ENTRY_ADDRESS(FunctionEntry))
            dbPrint("    %.8I64x: ", FUNCTION_ENTRY_ADDRESS(FunctionEntry) );
        else
            dbPrint("    ");
        if (Label) dbPrint(Label);
        dbPrint("\n", FunctionEntry );
        if (FunctionEntry) {
            if ((ALPHA_RF_PROLOG_END_ADDRESS(FunctionEntry) < ALPHA_RF_BEGIN_ADDRESS(FunctionEntry)) ||
                (ALPHA_RF_PROLOG_END_ADDRESS(FunctionEntry) > ALPHA_RF_END_ADDRESS(FunctionEntry))) {
                Secondary = TRUE;
                EntryType = ALPHA_RF_ENTRY_TYPE(FunctionEntry);
                if (EntryType > MAXENTRYTYPE) EntryType = MAXENTRYTYPE;
            } else if (ALPHA_RF_IS_FIXED_RETURN(FunctionEntry)) {
                FixedReturn = TRUE;
            }
            NullCount = ALPHA_RF_NULL_CONTEXT_COUNT(FunctionEntry);

            dbPrint("    BeginAddress     = %16.8I64x\n", FunctionEntry->BeginAddress);
            dbPrint("    EndAddress       = %16.8I64x", FunctionEntry->EndAddress);
            if (NullCount) {
                dbPrint(" %d null-context instructions", NullCount);
            }
            dbPrint("\n");
            dbPrint("    ExceptionHandler = %16.8I64x", FunctionEntry->ExceptionHandler);
            if (FunctionEntry->ExceptionHandler != 0) {
                if (Secondary) {
                    ULONG64 AlternateProlog = ALT_PROLOG(FunctionEntry);

                    switch( EntryType ) {
                    case ALPHA_RF_NOT_CONTIGUOUS:
                    case ALPHA_RF_ALT_ENT_PROLOG:

                        if ((AlternateProlog >= ALPHA_RF_BEGIN_ADDRESS(FunctionEntry)) &&
                            (AlternateProlog <= FunctionEntry->EndAddress)) {
                                dbPrint(" alternate PrologEndAddress");
                        }
                        break;
                    case ALPHA_RF_NULL_CONTEXT:
                        dbPrint(" stack adjustment");
                    }
                } else if (FixedReturn) {
                    dbPrint(" fixed return address");
                }
            }
            dbPrint("\n");
            dbPrint("    HandlerData      = %16.8I64x", FunctionEntry->HandlerData);
            if (Secondary) {
                dbPrint(" type %d: %s", EntryType, EntryTypeName[EntryType] );
            }
            dbPrint("\n");
            dbPrint("    PrologEndAddress = %16.8I64x\n",   FunctionEntry->PrologEndAddress );
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\walki64.c ===
/*++

Copyright (c) 1996  Intel Corporation
Copyright (c) 1993  Microsoft Corporation

Module Name:

    walki64.c

Abstract:

    This file implements the IA64 stack walking api.

Author:

Environment:

    User Mode

--*/

#define _IMAGEHLP_SOURCE_
#define _IA64REG_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "private.h"
#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"
#include "symbols.h"
#include <stdlib.h>

BOOL
WalkIa64Init(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PIA64_CONTEXT                     Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    );

BOOL
WalkIa64Next(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PIA64_CONTEXT                     Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    );

BOOL
GetStackFrameIa64(
    HANDLE                            hProcess,
    PULONG64                          ReturnAddress,
    PULONG64                          FramePointer,
    PULONG64                          BStorePointer,
    PIA64_CONTEXT                     Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    );

#define CALLBACK_STACK(f)  (f->KdHelp.ThCallbackStack)
#define CALLBACK_BSTORE(f)  (f->KdHelp.ThCallbackBStore)
#define CALLBACK_NEXT(f)   (f->KdHelp.NextCallback)
#define CALLBACK_FUNC(f)   (f->KdHelp.KiCallUserMode)
#define CALLBACK_THREAD(f) (f->KdHelp.Thread)


ULONGLONG
GetImageBase (
    HANDLE  hProcess,
    ULONG64 ControlPc
    )
{
    PPROCESS_ENTRY  ProcessEntry;
    PMODULE_ENTRY   mi;

    __try {

        ProcessEntry = FindProcessEntry( hProcess );
        if (!ProcessEntry) {
            SetLastError( ERROR_INVALID_HANDLE );
            return (ULONGLONG) NULL;
        }

        mi = GetModuleForPC( ProcessEntry, ControlPc, FALSE );
        if (mi == NULL) {
            SetLastError( ERROR_MOD_NOT_FOUND );
            return (ULONGLONG) NULL;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {

        ImagepSetLastErrorFromStatus( GetExceptionCode() );
        return (ULONGLONG) NULL;

    }

    return (mi->BaseOfDll);
}

WalkIa64(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PIA64_CONTEXT                     Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    )
{
    BOOL rval;

    if (StackFrame->Virtual) {

        rval = WalkIa64Next( hProcess,
                             StackFrame,
                             Context,
                             ReadMemory,
                             FunctionTableAccess,
                             GetModuleBase
                           );

    } else {

        rval = WalkIa64Init( hProcess,
                             StackFrame,
                             Context,
                             ReadMemory,
                             FunctionTableAccess,
                             GetModuleBase
                           );

    }

    return rval;
}

ULONGLONG
VirtualUnwindIa64 (
    HANDLE hProcess,
    ULONGLONG ImageBase,
    DWORD64 ControlPc,
    PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY FunctionEntry,
    PIA64_CONTEXT ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemory
    );


BOOL
GetStackFrameIa64(
    HANDLE                            hProcess,
    PULONG64                          ReturnAddress,
    PULONG64                          FramePointer,
    PULONG64                          BStorePointer,
    PIA64_CONTEXT                     Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    )
{
    ULONGLONG                          ImageBase;
    PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY rf;
    ULONG64                            dwRa = (ULONG64)Context->BrRp;
    BOOL                               rval = TRUE;


    rf = (PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY) FunctionTableAccess( hProcess, *ReturnAddress );

    if (rf) {

        //
        // The Rp value coming out of mainCRTStartup is set by some run-time
        // routine to be 0; this serves to cause an error if someone actually
        // does a return from the mainCRTStartup frame.
        //

        ImageBase = GetModuleBase (hProcess, *ReturnAddress);
        dwRa = (ULONG64)VirtualUnwindIa64( hProcess, ImageBase, *ReturnAddress, rf, Context, ReadMemory );
        if (!dwRa) {
            rval = FALSE;
        }

        if ((dwRa == *ReturnAddress) &&
               (*FramePointer == Context->IntSp) &&
               (*(FramePointer+1) == Context->RsBSP)) {
            rval = FALSE;
        }

        *ReturnAddress = dwRa;
        *FramePointer  = Context->IntSp;
        *BStorePointer = Context->RsBSP;

    } else {

        SHORT BsFrameSize;
        SHORT TempFrameSize;

        if ((dwRa == *ReturnAddress) &&
               (*FramePointer == Context->IntSp) &&
               (*(FramePointer+1) == Context->RsBSP)) {
            rval = FALSE;
        }

        *ReturnAddress = Context->BrRp;
        *FramePointer  = Context->IntSp;
        *BStorePointer = Context->RsBSP;
        Context->StIFS = Context->RsPFS;
        BsFrameSize = (SHORT)(Context->StIFS >> IA64_PFS_SIZE_SHIFT) & IA64_PFS_SIZE_MASK;
        TempFrameSize = BsFrameSize - (SHORT)((Context->RsBSP >> 3) & IA64_NAT_BITS_PER_RNAT_REG);
        while (TempFrameSize > 0) {
            BsFrameSize++;
            TempFrameSize -= IA64_NAT_BITS_PER_RNAT_REG;
        }
        Context->RsBSPSTORE = Context->RsBSP -= BsFrameSize * sizeof(ULONGLONG);
    }

    return rval;
}


BOOL
WalkIa64Init(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PIA64_CONTEXT                     Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    )
{
    IA64_KSWITCH_FRAME SwitchFrame;
    IA64_CONTEXT       ContextSave;
    DWORD64            PcOffset;
    DWORD64            FrameOffset;
    DWORD64            BStoreOffset;
    DWORD              cb;
    ULONG              Index;
    BOOL               Result;


    if (StackFrame->AddrFrame.Offset) {
        if (ReadMemory( hProcess,
                        StackFrame->AddrFrame.Offset+IA64_STACK_SCRATCH_AREA,
                        &SwitchFrame,
                        sizeof(IA64_KSWITCH_FRAME),
                        &cb )) {

            SHORT BsFrameSize;
            SHORT TempFrameSize;

            //
            // successfully read a switch frame from the stack
            //

            Context->IntSp = StackFrame->AddrFrame.Offset;
            Context->Preds = SwitchFrame.SwitchPredicates;
            Context->StIIP = SwitchFrame.SwitchRp;
            Context->StFPSR = SwitchFrame.SwitchFPSR;
            Context->BrRp = SwitchFrame.SwitchRp;
            Context->RsPFS = SwitchFrame.SwitchPFS;
            Context->StIFS = SwitchFrame.SwitchPFS;
            BsFrameSize = (SHORT)(SwitchFrame.SwitchPFS >> IA64_PFS_SIZE_SHIFT) & IA64_PFS_SIZE_MASK;
            TempFrameSize = BsFrameSize - (SHORT)((SwitchFrame.SwitchBsp >> 3) & IA64_NAT_BITS_PER_RNAT_REG);
            while (TempFrameSize > 0) {
                BsFrameSize++;
                TempFrameSize -= IA64_NAT_BITS_PER_RNAT_REG;
            }
            Context->RsBSP = SwitchFrame.SwitchBsp - BsFrameSize * sizeof(ULONGLONG);

            Context->FltS0 = SwitchFrame.SwitchExceptionFrame.FltS0;
            Context->FltS1 = SwitchFrame.SwitchExceptionFrame.FltS1;
            Context->FltS2 = SwitchFrame.SwitchExceptionFrame.FltS2;
            Context->FltS3 = SwitchFrame.SwitchExceptionFrame.FltS3;
            Context->FltS4 = SwitchFrame.SwitchExceptionFrame.FltS4;
            Context->FltS5 = SwitchFrame.SwitchExceptionFrame.FltS5;
            Context->FltS6 = SwitchFrame.SwitchExceptionFrame.FltS6;
            Context->FltS7 = SwitchFrame.SwitchExceptionFrame.FltS7;
            Context->FltS8 = SwitchFrame.SwitchExceptionFrame.FltS8;
            Context->FltS9 = SwitchFrame.SwitchExceptionFrame.FltS9;
            Context->FltS10 = SwitchFrame.SwitchExceptionFrame.FltS10;
            Context->FltS11 = SwitchFrame.SwitchExceptionFrame.FltS11;
            Context->FltS12 = SwitchFrame.SwitchExceptionFrame.FltS12;
            Context->FltS13 = SwitchFrame.SwitchExceptionFrame.FltS13;
            Context->FltS14 = SwitchFrame.SwitchExceptionFrame.FltS14;
            Context->FltS15 = SwitchFrame.SwitchExceptionFrame.FltS15;
            Context->FltS16 = SwitchFrame.SwitchExceptionFrame.FltS16;
            Context->FltS17 = SwitchFrame.SwitchExceptionFrame.FltS17;
            Context->FltS18 = SwitchFrame.SwitchExceptionFrame.FltS18;
            Context->FltS19 = SwitchFrame.SwitchExceptionFrame.FltS19;
            Context->IntS0 = SwitchFrame.SwitchExceptionFrame.IntS0;
            Context->IntS1 = SwitchFrame.SwitchExceptionFrame.IntS1;
            Context->IntS2 = SwitchFrame.SwitchExceptionFrame.IntS2;
            Context->IntS3 = SwitchFrame.SwitchExceptionFrame.IntS3;
            Context->IntNats = SwitchFrame.SwitchExceptionFrame.IntNats;
            Context->BrS0 = SwitchFrame.SwitchExceptionFrame.BrS0;
            Context->BrS1 = SwitchFrame.SwitchExceptionFrame.BrS1;
            Context->BrS2 = SwitchFrame.SwitchExceptionFrame.BrS2;
            Context->BrS3 = SwitchFrame.SwitchExceptionFrame.BrS3;
            Context->BrS4 = SwitchFrame.SwitchExceptionFrame.BrS4;
            Context->ApEC = SwitchFrame.SwitchExceptionFrame.ApEC;
            Context->ApLC = SwitchFrame.SwitchExceptionFrame.ApLC;

        } else {
            return FALSE;
        }
    }

    ZeroMemory( StackFrame, sizeof(*StackFrame) );

    StackFrame->Virtual = TRUE;

    StackFrame->AddrPC.Offset       = Context->StIIP;
    StackFrame->AddrPC.Mode         = AddrModeFlat;

    StackFrame->AddrFrame.Offset    = Context->IntSp;
    StackFrame->AddrFrame.Mode      = AddrModeFlat;

    StackFrame->AddrBStore.Offset    = Context->RsBSP;
    StackFrame->AddrBStore.Mode      = AddrModeFlat;

    ContextSave = *Context;
    PcOffset    = StackFrame->AddrPC.Offset;
    FrameOffset = StackFrame->AddrFrame.Offset;
    BStoreOffset = StackFrame->AddrBStore.Offset;

    if (!GetStackFrameIa64( hProcess,
                        &PcOffset,
                        &FrameOffset,
                        &BStoreOffset,
                        &ContextSave,
                        ReadMemory,
                        FunctionTableAccess,
                        GetModuleBase) ) {

        StackFrame->AddrReturn.Offset = Context->BrRp;

    } else {

        StackFrame->AddrReturn.Offset = PcOffset;
    }

    StackFrame->AddrReturn.Mode     = AddrModeFlat;

    //
    // get the arguments to the function
    //

    Index = (ULONG)(ContextSave.RsBSP & 0x1F8) >> 3;
    if (Index > 59) {

        DWORD i, j;
        DWORD64 Params[5];

        Result = ReadMemory (hProcess, ContextSave.RsBSP,
                             Params, 40, &cb);
        if (Result) {
            j = 0;
            for (i = 0; i < 5; i++, Index++) {
                if (Index != 63) {
                    StackFrame->Params[j++] = Params[i];
                }
            }
        }

    } else {
        Result = ReadMemory (hProcess, ContextSave.RsBSP,
                             StackFrame->Params, 32, &cb);
    }

    if (!Result) {
        StackFrame->Params[0] =
        StackFrame->Params[1] =
        StackFrame->Params[2] =
        StackFrame->Params[3] = 0;
    }

    return TRUE;
}


BOOL
WalkIa64Next(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    StackFrame,
    PIA64_CONTEXT                     Context,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    )
{
    DWORD           cb;
    IA64_CONTEXT    ContextSave;
    BOOL            rval = TRUE;
    BOOL            Result;
    DWORD64         StackAddress;
    DWORD64         BStoreAddress;
    PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY rf;
    DWORD64         qw;
    ULONG           Index;


    if (!GetStackFrameIa64( hProcess,
                        &StackFrame->AddrPC.Offset,
                        &StackFrame->AddrFrame.Offset,
                        &StackFrame->AddrBStore.Offset,
                        Context,
                        ReadMemory,
                        FunctionTableAccess,
                        GetModuleBase) ) {

        rval = FALSE;

        //
        // If the frame could not be unwound or is terminal, see if
        // there is a callback frame:
        //

        if (AppVersion.Revision >= 4 && CALLBACK_STACK(StackFrame)) {

            if (CALLBACK_STACK(StackFrame) & 0x80000000) {

                //
                // it is the pointer to the stack frame that we want
                //

                StackAddress = CALLBACK_STACK(StackFrame);

            } else {

                //
                // if it is a positive integer, it is the offset to
                // the address in the thread.
                // Look up the pointer:
                //

                rval = ReadMemory(hProcess,
                                  (CALLBACK_THREAD(StackFrame) +
                                                 CALLBACK_STACK(StackFrame)),
                                  &StackAddress,
                                  sizeof(DWORD64),
                                  &cb);

                if (!rval || StackAddress == 0) {
                    StackAddress = (DWORD64)-1;
                    CALLBACK_STACK(StackFrame) = (DWORD)-1;
                }

            }

            if ( (StackAddress == (DWORD64)-1) ||
                !(rf = (PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY)
                     FunctionTableAccess(hProcess, CALLBACK_FUNC(StackFrame))) ) {

                rval = FALSE;

            } else {

                ReadMemory(hProcess,
                           (StackAddress + CALLBACK_NEXT(StackFrame)),
                           &CALLBACK_STACK(StackFrame),
                           sizeof(DWORD64),
                           &cb);

                StackFrame->AddrPC.Offset = rf->BeginAddress;  // ?????
                StackFrame->AddrFrame.Offset = StackAddress;
                Context->IntSp = StackAddress;

                rval = TRUE;
            }

        }
    }

    //
    // get the return address
    //
    ContextSave = *Context;
    StackFrame->AddrReturn.Offset = StackFrame->AddrPC.Offset;

    if (!GetStackFrameIa64( hProcess,
                        &StackFrame->AddrReturn.Offset,
                        &qw,
                        &qw,
                        &ContextSave,
                        ReadMemory,
                        FunctionTableAccess,
                        GetModuleBase) ) {


        StackFrame->AddrReturn.Offset = 0;

    }

    //
    // get the arguments to the function
    //

    Index = (ULONG)(ContextSave.RsBSP & 0x1F8) >> 3;
    if (Index > 59) {

        DWORD i, j;
        DWORD64 Params[5];

        Result = ReadMemory (hProcess, ContextSave.RsBSP,
                             Params, 40, &cb);
        if (Result) {
            j = 0;
            for (i = 0; i < 5; i++, Index++) {
                if (Index != 63) {
                    StackFrame->Params[j++] = Params[i];
                }
            }
        }

    } else {
        Result = ReadMemory (hProcess, ContextSave.RsBSP,
                             StackFrame->Params, 32, &cb);
    }

    if (!Result) {
        StackFrame->Params[0] =
        StackFrame->Params[1] =
        StackFrame->Params[2] =
        StackFrame->Params[3] = 0;
    }

    return rval;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\walk.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    walk.c

Abstract:

    This function implements the stack walking api.

Author:

    Wesley Witt (wesw) 1-Oct-1993

Environment:

    User Mode

--*/

#include <private.h>



BOOL
ReadMemoryRoutineLocal(
    HANDLE  hProcess,
    DWORD64 qwBaseAddress,
    LPVOID  lpBuffer,
    DWORD   nSize,
    LPDWORD lpNumberOfBytesRead
    );

LPVOID
FunctionTableAccessRoutineLocal(
    HANDLE  hProcess,
    DWORD64 AddrBase
    );

DWORD64
GetModuleBaseRoutineLocal(
    HANDLE  hProcess,
    DWORD64 ReturnAddress
    );

DWORD64
TranslateAddressRoutineLocal(
    HANDLE    hProcess,
    HANDLE    hThread,
    LPADDRESS64 lpaddr
    );

PREAD_PROCESS_MEMORY_ROUTINE    ImagepUserReadMemory32;
PFUNCTION_TABLE_ACCESS_ROUTINE  ImagepUserFunctionTableAccess32;
PGET_MODULE_BASE_ROUTINE        ImagepUserGetModuleBase32;
PTRANSLATE_ADDRESS_ROUTINE      ImagepUserTranslateAddress32;
IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY AlphaFunctionEntry64;

BOOL
ImagepReadMemoryThunk(
    HANDLE  hProcess,
    DWORD64 qwBaseAddress,
    LPVOID  lpBuffer,
    DWORD   nSize,
    LPDWORD lpNumberOfBytesRead
    )
{
    return ImagepUserReadMemory32(
                        hProcess,
                        (DWORD)qwBaseAddress,
                        lpBuffer,
                        nSize,
                        lpNumberOfBytesRead
                        );
}

LPVOID
ImagepFunctionTableAccessThunk(
    HANDLE  hProcess,
    DWORD64 AddrBase
    )
{
    return ImagepUserFunctionTableAccess32(
                hProcess,
                (DWORD)AddrBase
                );
}

PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY
AlphaFunctionTableAccessThunk(
    HANDLE  hProcess,
    DWORD64 AddrBase
    )
{
    PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY FunctionEntry32;
    
    FunctionEntry32 = (PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY)
                        ImagepUserFunctionTableAccess32(
                            hProcess,
                            (DWORD)AddrBase
                            );
    
    if (FunctionEntry32) {
        ConvertAlphaRf32To64( FunctionEntry32, &AlphaFunctionEntry64 );

        return &AlphaFunctionEntry64;
    }

    return NULL;
}

DWORD64
ImagepGetModuleBaseThunk(
    HANDLE  hProcess,
    DWORD64 ReturnAddress
    )
{
    return (ULONG64)(LONG64)(LONG)ImagepUserGetModuleBase32(
                hProcess,
                (DWORD)ReturnAddress
                );
}

DWORD64
ImagepTranslateAddressThunk(
    HANDLE    hProcess,
    HANDLE    hThread,
    LPADDRESS64 lpaddr
    )
{
    return 0;
}

void
StackFrame32To64(
    LPSTACKFRAME StackFrame32,
    LPSTACKFRAME64 StackFrame64
    )
{
    Address32To64(&StackFrame32->AddrPC, &StackFrame64->AddrPC );
    Address32To64(&StackFrame32->AddrReturn, &StackFrame64->AddrReturn );
    Address32To64(&StackFrame32->AddrFrame, &StackFrame64->AddrFrame );
    Address32To64(&StackFrame32->AddrStack, &StackFrame64->AddrStack );
    StackFrame64->FuncTableEntry = StackFrame32->FuncTableEntry;
    StackFrame64->Far = StackFrame32->Far;
    StackFrame64->Virtual = StackFrame32->Virtual;
    StackFrame64->Params[0] = StackFrame32->Params[0];
    StackFrame64->Params[1] = StackFrame32->Params[1];
    StackFrame64->Params[2] = StackFrame32->Params[2];
    StackFrame64->Params[3] = StackFrame32->Params[3];
    StackFrame64->Reserved[0] = StackFrame32->Reserved[0];
    StackFrame64->Reserved[1] = StackFrame32->Reserved[1];
    StackFrame64->Reserved[2] = StackFrame32->Reserved[2];
    KdHelp32To64(&StackFrame32->KdHelp, &StackFrame64->KdHelp);
}

void
StackFrame64To32(
    LPSTACKFRAME64 StackFrame64,
    LPSTACKFRAME StackFrame32
    )
{
    Address64To32(&StackFrame64->AddrPC, &StackFrame32->AddrPC );
    Address64To32(&StackFrame64->AddrReturn, &StackFrame32->AddrReturn );
    Address64To32(&StackFrame64->AddrFrame, &StackFrame32->AddrFrame );
    Address64To32(&StackFrame64->AddrStack, &StackFrame32->AddrStack );
    StackFrame32->FuncTableEntry = StackFrame64->FuncTableEntry;
    StackFrame32->Far = StackFrame64->Far;
    StackFrame32->Virtual = StackFrame64->Virtual;
    StackFrame32->Params[0] = (ULONG)StackFrame64->Params[0];
    StackFrame32->Params[1] = (ULONG)StackFrame64->Params[1];
    StackFrame32->Params[2] = (ULONG)StackFrame64->Params[2];
    StackFrame32->Params[3] = (ULONG)StackFrame64->Params[3];
    StackFrame32->Reserved[0] = (ULONG)StackFrame64->Reserved[0];
    StackFrame32->Reserved[1] = (ULONG)StackFrame64->Reserved[1];
    StackFrame32->Reserved[2] = (ULONG)StackFrame64->Reserved[2];
}

BOOL
StackWalk(
    DWORD                             MachineType,
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME                    StackFrame32,
    LPVOID                            ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE    ReadMemory32,
    PFUNCTION_TABLE_ACCESS_ROUTINE  FunctionTableAccess32,
    PGET_MODULE_BASE_ROUTINE        GetModuleBase32,
    PTRANSLATE_ADDRESS_ROUTINE      TranslateAddress32
    )
{
    BOOL rval;
    BOOL UseSym = FALSE;
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory;
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess;
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase;
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress;
    STACKFRAME64                      StackFrame;

    // Alpha stack walking no longer requires the FunctionTableAccess callback
    // except for backward compatability with debuggers that didn't specify
    // a GetModuleBase callback. If the GetModuleBase routine is provided
    // then set FunctionTableAccess to NULL to prevent a mixture of the
    // callback and read-from-image methods of accessing function table entries.

    if (MachineType == IMAGE_FILE_MACHINE_ALPHA) {
        if (GetModuleBase32 == NULL && FunctionTableAccess32) {
            FunctionTableAccess = AlphaFunctionTableAccessThunk;
            ImagepUserFunctionTableAccess32 = FunctionTableAccess32;
        } else {
            FunctionTableAccess = NULL;
        }
    } else {
        if (FunctionTableAccess32) {
            ImagepUserFunctionTableAccess32 = FunctionTableAccess32;
            FunctionTableAccess = ImagepFunctionTableAccessThunk;
        } else {
            FunctionTableAccess = FunctionTableAccessRoutineLocal;
            UseSym = TRUE;
        }
    }

    if (GetModuleBase32) {
        ImagepUserGetModuleBase32 = GetModuleBase32;
        GetModuleBase = ImagepGetModuleBaseThunk;
    } else {
        GetModuleBase = GetModuleBaseRoutineLocal;
        UseSym = TRUE;
    }

    if (ReadMemory32) {
        ImagepUserReadMemory32 = ReadMemory32;
        ReadMemory = ImagepReadMemoryThunk;
    } else {
        ReadMemory = ReadMemoryRoutineLocal;
    }

    if (TranslateAddress32) {
        ImagepUserTranslateAddress32 = TranslateAddress32;
        TranslateAddress = ImagepTranslateAddressThunk;
    } else {
        TranslateAddress = TranslateAddressRoutineLocal;
    }

    if (UseSym) {
        //
        // We are using the code in symbols.c
        // hProcess better be a real valid process handle
        //

        //
        // Always call syminitialize.  It's a nop if process
        // is already loaded.
        //
        if (!SymInitialize( hProcess, NULL, FALSE )) {
            return FALSE;
        }

    }

    StackFrame32To64(StackFrame32, &StackFrame);

    switch (MachineType) {
        case IMAGE_FILE_MACHINE_I386:
            rval = WalkX86( hProcess,
                            hThread,
                            &StackFrame,
                            ReadMemory,
                            FunctionTableAccess,
                            GetModuleBase,
                            TranslateAddress
                            );
            break;

        case IMAGE_FILE_MACHINE_ALPHA:
            rval = WalkAlpha( hProcess,
                              &StackFrame,
                              (PCONTEXT) ContextRecord,
                              ReadMemory,
                              GetModuleBase,
                              FunctionTableAccess,
                              FALSE
                              );
            break;

        case IMAGE_FILE_MACHINE_IA64:
        case IMAGE_FILE_MACHINE_ALPHA64:
        default:
            rval = FALSE;
            break;
    }
    if (rval) {
        StackFrame64To32(&StackFrame, StackFrame32);
    }

    return rval;
}


BOOL
StackWalk64(
    DWORD                             MachineType,
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME64                    StackFrame,
    LPVOID                            ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{
    BOOL rval;
    BOOL UseSym = FALSE;

    if (!FunctionTableAccess) {
        FunctionTableAccess = FunctionTableAccessRoutineLocal;
        UseSym = TRUE;
    }

    if (!GetModuleBase) {
        GetModuleBase = GetModuleBaseRoutineLocal;
        UseSym = TRUE;
    }

    if (!ReadMemory) {
        ReadMemory = ReadMemoryRoutineLocal;
    }

    if (!TranslateAddress) {
        TranslateAddress = TranslateAddressRoutineLocal;
    }

    if (UseSym) {
        //
        // We are using the code in symbols.c
        // hProcess better be a real valid process handle
        //

        //
        // Always call syminitialize.  It's a nop if process
        // is already loaded.
        //
        if (!SymInitialize( hProcess, NULL, FALSE )) {
            return FALSE;
        }

    }

    switch (MachineType) {
        case IMAGE_FILE_MACHINE_I386:
            rval = WalkX86( hProcess,
                            hThread,
                            StackFrame,
                            ReadMemory,
                            FunctionTableAccess,
                            GetModuleBase,
                            TranslateAddress
                            );
            break;

        case IMAGE_FILE_MACHINE_IA64:
            rval = WalkIa64( hProcess,
                             StackFrame,
                             (PCONTEXT) ContextRecord,
                             ReadMemory,
                             FunctionTableAccess,
                             GetModuleBase
                             );
            break;

        case IMAGE_FILE_MACHINE_ALPHA:
            rval = WalkAlpha( hProcess,
                              StackFrame,
                              (PCONTEXT) ContextRecord,
                              ReadMemory,
                              GetModuleBase,
                              FunctionTableAccess,
                              FALSE
                              );
            break;

        case IMAGE_FILE_MACHINE_ALPHA64:
            rval = WalkAlpha( hProcess,
                              StackFrame,
                              (PCONTEXT) ContextRecord,
                              ReadMemory,
                              GetModuleBase,
                              FunctionTableAccess,
                              TRUE
                              );
            break;

        default:
            rval = FALSE;
            break;
    }

    return rval;
}


BOOL
ReadMemoryRoutineLocal(
    HANDLE  hProcess,
    DWORD64 qwBaseAddress,
    LPVOID  lpBuffer,
    DWORD   nSize,
    LPDWORD lpNumberOfBytesRead
    )
{
    return ReadProcessMemory( hProcess,
                              (LPVOID)(ULONG_PTR)qwBaseAddress,
                              lpBuffer,
                              nSize,
                              lpNumberOfBytesRead );
}


LPVOID
FunctionTableAccessRoutineLocal(
    HANDLE  hProcess,
    DWORD64 AddrBase
    )
{
    return SymFunctionTableAccess64(hProcess, AddrBase);
}

DWORD64
GetModuleBaseRoutineLocal(
    HANDLE  hProcess,
    DWORD64 ReturnAddress
    )
{
    IMAGEHLP_MODULE64 ModuleInfo = {0};
    ModuleInfo.SizeOfStruct = sizeof(ModuleInfo);

    if (SymGetModuleInfo64(hProcess, ReturnAddress, &ModuleInfo)) {
        return ModuleInfo.BaseOfImage;
    } else {
        return 0;
    }
}


DWORD64
TranslateAddressRoutineLocal(
    HANDLE    hProcess,
    HANDLE    hThread,
    LPADDRESS64 paddr
    )
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\tools\makefile.inc ===
obj\$(TARGET_DIRECTORY)\bind.res: ..\bind.rc

obj\$(TARGET_DIRECTORY)\binplace.res: ..\binplace.rc

obj\$(TARGET_DIRECTORY)\checkfix.res: ..\checkfix.rc

obj\$(TARGET_DIRECTORY)\dbgdump.res: ..\dbgdump.rc

obj\$(TARGET_DIRECTORY)\editsym.res: ..\binplace.rc

obj\$(TARGET_DIRECTORY)\imagecfg.res: ..\imagecfg.rc

obj\$(TARGET_DIRECTORY)\imagechk.res: ..\imagechk.rc

obj\$(TARGET_DIRECTORY)\impchk.res: ..\impchk.rc

obj\$(TARGET_DIRECTORY)\rebase.res: ..\rebase.rc

obj\$(TARGET_DIRECTORY)\smashlck.res: ..\smashlck.rc

obj\$(TARGET_DIRECTORY)\splitsym.res: ..\splitsym.rc

obj\$(TARGET_DIRECTORY)\stripcv.res: ..\stripcv.rc

obj\$(TARGET_DIRECTORY)\undname.res: ..\undname.rc

obj\$(TARGET_DIRECTORY)\verfix.res: ..\verfix.rc

obj\$(TARGET_DIRECTORY)\editsym.res: ..\editsym.rc

obj\$(TARGET_DIRECTORY)\upddbg.res: ..\upddbg.rc

obj\$(TARGET_DIRECTORY)\certify.res: ..\certify.rc

obj\$(TARGET_DIRECTORY)\imhlptst.res: ..\imhlptst.rc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\imagehlp\makefile.inc ===
#OBJECTS = $(OBJECTS) $(BASEDIR)\private\ntos\rtl\user\obj\$(TARGET_DIRECTORY)\imagedir.obj

obj\$(TARGET_DIRECTORY)\imagehlp.res: ..\imagehlp.rc

..\debug.c ..\undname.c: $(BASEDIR)\public\sdk\inc\ntverp.h

$(O)\pimagehlp.def : ..\imagehlp.src
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc..\imagehlp.src > $@
$(CPPXX: =
)
-DPRIVATE=
<<NOKEEP

$(O)\pimagehlp.lib : $(O)\pimagehlp.def $(IMPLIB_DEPEND)
    -$(LIB_NAME) -out:$@ @<<
$(LIBRARIAN_FLAGS: =
)
-def:$(O)\pimagehlp.def
$(LIBRARY_OBJS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\whackdbg.c ===
#include <windows.h>
#include <stdio.h>

int __cdecl
main(
    int argc,
    char *argv[]
    )
{
    HANDLE hMappedFile;
    HANDLE hFile;
    int i;
    PIMAGE_SECTION_HEADER ImageSectHdr;
    PIMAGE_FILE_HEADER ImageHdr;

    if (argc <= 1) {
        puts("Usage: whackdbg <object>\n"
             "\twhere <object> is an obj that contains CV .debug$? sections that s/b zero'd out\n");
        return 1;
    }

    argv++;
    while (--argc) {
        hFile = CreateFile(
                    *argv,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );
        if ( hFile == INVALID_HANDLE_VALUE )
            goto clean0;

        hMappedFile = CreateFileMapping(
                        hFile,
                        NULL,
                        PAGE_READWRITE,
                        0,
                        0,
                        NULL
                        );
        if ( !hMappedFile ) {
            goto clean1;
        }

        ImageHdr = (PIMAGE_FILE_HEADER) MapViewOfFile( hMappedFile, FILE_MAP_WRITE, 0, 0, 0 );

        CloseHandle(hMappedFile);

        // We're going to do very minimal testing here.  Basically if it starts with
        // a i386 or alpha machine signature, we'll assume it's an object and party on
        // it...

        if ((ImageHdr->Machine != IMAGE_FILE_MACHINE_I386) &&
            (ImageHdr->Machine != IMAGE_FILE_MACHINE_ALPHA))
        {
            goto clean2;
        }

        ImageSectHdr = (PIMAGE_SECTION_HEADER)((ULONG)ImageHdr + IMAGE_SIZEOF_FILE_HEADER);
        for (i=0;i < ImageHdr->NumberOfSections; i++) {
            if ((strcmp(ImageSectHdr->Name, ".debug$T") == 0) ||
                (strcmp(ImageSectHdr->Name, ".debug$S") == 0) ||
                (strcmp(ImageSectHdr->Name, ".debug$P") == 0)
               )
            {
                ImageSectHdr->SizeOfRawData = 0;
            }
            ImageSectHdr++;
        }

        FlushViewOfFile((PUCHAR)ImageHdr, 0);
clean2:
        UnmapViewOfFile((PUCHAR)ImageHdr);
clean1:
        CloseHandle(hFile);
clean0:
        argv++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\i386\chksum.asm ===
title  "Compute Checksum"

;/*++
;
; Copyright (c) 1992  Microsoft Corporation
;
; Module Name:
;
;    chksum.asm
;
; Abstract:
;
;    This module implements a fucntion to compute the checksum of a buffer.
;
; Author:
;
;    David N. Cutler (davec) 27-Jan-1992
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;--*/

        .386
        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include callconv.inc
        include ks386.inc
        .list

        .code

;++
;
; USHORT
; ChkSum(
;   IN ULONG cksum,
;   IN PUSHORT buf,
;   IN ULONG len
;   )
;
; Routine Description:
;
;    This function computes the checksum of the specified buffer.
;
; Arguments:
;
;    cksum - Suppiles the initial checksum value.
;
;    buf - Supplies a pointer to the buffer that is checksumed.
;
;    len - Supplies the of the buffer in words.
;
; Return Value:
;
;    The computed checksum is returned as the function value.
;
;--

cksum   equ     8                       ; stack offset to initial checksum
buf     equ     12                      ; stack offset to source address
len     equ     16                      ; stack offset to length in words

cPublicProc ChkSum,3

	push	esi                     ; save nonvolatile register
        mov     ecx,[esp + len]         ; get length in words
        mov     esi,[esp + buf]         ; get source address
        mov     eax,[esp + cksum]       ; get initial checksum
        shl     ecx,1                   ; convert to length in bytes
        jz      cks80                   ; if z set, no words to checksum

;
; Compute checksum in cascading order of block size until 128 byte blocks
; are all that is left, then loop on 128-bute blocks.
;

        test    esi,02h                 ; check if source dword aligned
        jz      short cks10             ; if z set, source is dword aligned
        sub     edx,edx                 ; get initial word for alignment
        mov     dx,[esi + 0]            ;
        add     eax,edx                 ; update partial checkcum
        adc     eax,0                   ; add carry
        add     esi,2                   ; update source address
        sub     ecx,2                   ; reduce length in bytes
cks10:  mov     edx,ecx                 ; isolate residual bytes
        and     edx,07h                 ;
        sub     ecx,edx                 ; subtract residual bytes
        jz      cks60                   ; if z set, no 8-byte blocks
        test    ecx,08h                 ; test if initial 8-byte block
        jz      short cks20             ; if z set, no initial 8-byte block
        add     eax,[esi + 0]           ; compute 8-byte checksum
        adc     eax,[esi + 4]           ;
        adc     eax,0                   ; add carry
        add     esi,8                   ; update source address
        sub     ecx,8                   ; reduce length of checksum
        jz      cks60                   ; if z set, end of 8-byte blocks
cks20:  test    ecx,010h                ; test if initial 16-byte block
        jz      short cks30             ; if z set, no initial 16-byte block
        add     eax,[esi + 0]           ; compute 16-byte checksum
        adc     eax,[esi + 4]           ;
        adc     eax,[esi + 8]           ;
        adc     eax,[esi + 12]          ;
        adc     eax,0                   ; add carry
        add     esi,16                  ; update source address
        sub     ecx,16                  ; reduce length of checksum
        jz      cks60                   ; if z set, end of 8-byte blocks
cks30:  test    ecx,020h                ; test if initial 32-byte block
        jz      short cks40             ; if z set, no initial 32-byte block
        add     eax,[esi + 0]           ; compute 32-byte checksum
        adc     eax,[esi + 4]           ;
        adc     eax,[esi + 8]           ;
        adc     eax,[esi + 12]          ;
        adc     eax,[esi + 16]          ;
        adc     eax,[esi + 20]          ;
        adc     eax,[esi + 24]          ;
        adc     eax,[esi + 28]          ;
        adc     eax,0                   ; add carry
        add     esi,32                  ; update source address
        sub     ecx,32                  ; reduce length of checksum
        jz      cks60                   ; if z set, end of 8-byte blocks
cks40:  test    ecx,040h                ; test if initial 64-byte block
        jz      cks50                   ; if z set, no initial 64-byte block
        add     eax,[esi + 0]           ; compute 64-byte checksum
        adc     eax,[esi + 4]           ;
        adc     eax,[esi + 8]           ;
        adc     eax,[esi + 12]          ;
        adc     eax,[esi + 16]          ;
        adc     eax,[esi + 20]          ;
        adc     eax,[esi + 24]          ;
        adc     eax,[esi + 28]          ;
        adc     eax,[esi + 32]          ;
        adc     eax,[esi + 36]          ;
        adc     eax,[esi + 40]          ;
        adc     eax,[esi + 44]          ;
        adc     eax,[esi + 48]          ;
        adc     eax,[esi + 52]          ;
        adc     eax,[esi + 56]          ;
        adc     eax,[esi + 60]          ;
        adc     eax,0                   ; add carry
        add     esi,64                  ; update source address
        sub     ecx,64                  ; reduce length of checksum
        jz      short cks60             ; if z set, end of 8-byte blocks
cks50:  add     eax,[esi + 0]           ; compute 64-byte checksum
        adc     eax,[esi + 4]           ;
        adc     eax,[esi + 8]           ;
        adc     eax,[esi + 12]          ;
        adc     eax,[esi + 16]          ;
        adc     eax,[esi + 20]          ;
        adc     eax,[esi + 24]          ;
        adc     eax,[esi + 28]          ;
        adc     eax,[esi + 32]          ;
        adc     eax,[esi + 36]          ;
        adc     eax,[esi + 40]          ;
        adc     eax,[esi + 44]          ;
        adc     eax,[esi + 48]          ;
        adc     eax,[esi + 52]          ;
        adc     eax,[esi + 56]          ;
        adc     eax,[esi + 60]          ;
        adc     eax,[esi + 64]          ;
        adc     eax,[esi + 68]          ;
        adc     eax,[esi + 72]          ;
        adc     eax,[esi + 76]          ;
        adc     eax,[esi + 80]          ;
        adc     eax,[esi + 84]          ;
        adc     eax,[esi + 88]          ;
        adc     eax,[esi + 92]          ;
        adc     eax,[esi + 96]          ;
        adc     eax,[esi + 100]         ;
        adc     eax,[esi + 104]         ;
        adc     eax,[esi + 108]         ;
        adc     eax,[esi + 112]         ;
        adc     eax,[esi + 116]         ;
        adc     eax,[esi + 120]         ;
        adc     eax,[esi + 124]         ;
        adc     eax,0                   ; add carry
        add     esi,128                 ; update source address
        sub     ecx,128                 ; reduce length of checksum
        jnz     short cks50             ; if z clear, not end of 8-byte blocks

;
; Compute checksum on 2-byte blocks.
;

cks60:  test    edx,edx                 ; check if any 2-byte blocks
        jz      short cks80             ; if z set, no 2-byte blocks
cks70:  sub     ecx,ecx                 ; load 2-byte block
        mov     cx,[esi + 0]            ;
        add     eax,ecx                 ; compue 2-byte checksum
        adc     eax,0                   ;
        add     esi,2                   ; update source address
        sub     edx,2                   ; reduce length of checksum
        jnz     short cks70             ; if z clear, more 2-bytes blocks

;
; Fold 32-but checksum into 16-bits
;

cks80:  mov     edx,eax                 ; copy checksum value
        shr     edx,16                  ; isolate high order bits
        and     eax,0ffffh              ; isolate low order bits
        add     eax,edx                 ; sum high and low order bits
        mov     edx,eax                 ; isolate possible carry
        shr     edx,16                  ;
        add     eax,edx                 ; add carry
        and     eax,0ffffh              ; clear possible carry bit
	pop     esi                     ; restore nonvolatile register
        stdRET  ChkSum

stdENDP ChkSum

	end

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\imagehlp\walkx86.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    walkx86.c

Abstract:

    This file implements the Intel x86 stack walking api.  This api allows for
    the presence of "real mode" stack frames.  This means that you can trace
    into WOW code.

Author:

    Wesley Witt (wesw) 1-Oct-1993

Environment:

    User Mode

--*/

#define _IMAGEHLP_SOURCE_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "private.h"
#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"
#include <objbase.h>
#include <wx86dll.h>
#include <symbols.h>



#define SAVE_EBP(f)        (f->Reserved[0])
#define TRAP_TSS(f)        (f->Reserved[1])
#define TRAP_EDITED(f)     (f->Reserved[1])
#define SAVE_TRAP(f)       (f->Reserved[2])
#define CALLBACK_STACK(f)  (f->KdHelp.ThCallbackStack)
#define CALLBACK_NEXT(f)   (f->KdHelp.NextCallback)
#define CALLBACK_FUNC(f)   (f->KdHelp.KiCallUserMode)
#define CALLBACK_THREAD(f) (f->KdHelp.Thread)
#define CALLBACK_FP(f)     (f->KdHelp.FramePointer)
#define CALLBACK_DISPATCHER(f) (f->KdHelp.KeUserCallbackDispatcher)
#define SYSTEM_RANGE_START(f) (f->KdHelp.SystemRangeStart)

#define STACK_SIZE         (sizeof(DWORD))
#define FRAME_SIZE         (STACK_SIZE * 2)

#define STACK_SIZE16       (sizeof(WORD))
#define FRAME_SIZE16       (STACK_SIZE16 * 2)
#define FRAME_SIZE1632     (STACK_SIZE16 * 3)

#define MAX_STACK_SEARCH   64   // in STACK_SIZE units
#define MAX_JMP_CHAIN      64   // in STACK_SIZE units
#define MAX_CALL           7    // in bytes
#define MIN_CALL           2    // in bytes

#define PUSHBP             0x55
#define MOVBPSP            0xEC8B


#define DoMemoryRead(addr,buf,sz,br) \
    ReadMemoryInternal( hProcess, hThread, addr, buf, sz, \
                        br, ReadMemory, TranslateAddress )


BOOL
WalkX86Init(
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME64                    lpstkfrm,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    );

BOOL
WalkX86Next(
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME64                    lpstkfrm,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    );

BOOL
ReadMemoryInternal(
    HANDLE                          hProcess,
    HANDLE                          hThread,
    LPADDRESS64                     lpBaseAddress,
    LPVOID                          lpBuffer,
    DWORD                           nSize,
    LPDWORD                         lpNumberOfBytesRead,
    PREAD_PROCESS_MEMORY_ROUTINE64  ReadMemory,
    PTRANSLATE_ADDRESS_ROUTINE64    TranslateAddress
    );

BOOL
IsFarCall(
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME64                    lpstkfrm,
    BOOL                              *Ok,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    );

BOOL
ReadTrapFrame(
    HANDLE                            hProcess,
    DWORD64                           TrapFrameAddress,
    PX86_KTRAP_FRAME                  TrapFrame,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory
    );

BOOL
TaskGate2TrapFrame(
    HANDLE                            hProcess,
    USHORT                            TaskRegister,
    PX86_KTRAP_FRAME                  TrapFrame,
    PULONG64                          off,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory
    );



BOOL
WalkX86(
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME64                    StackFrame,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{
    BOOL rval;

    if (StackFrame->Virtual) {

        rval = WalkX86Next( hProcess,
                            hThread,
                            StackFrame,
                            ReadMemory,
                            FunctionTableAccess,
                            GetModuleBase,
                            TranslateAddress
                          );

    } else {

        rval = WalkX86Init( hProcess,
                            hThread,
                            StackFrame,
                            ReadMemory,
                            FunctionTableAccess,
                            GetModuleBase,
                            TranslateAddress
                          );

    }

    return rval;
}

BOOL
ReadMemoryInternal(
    HANDLE                          hProcess,
    HANDLE                          hThread,
    LPADDRESS64                     lpBaseAddress,
    LPVOID                          lpBuffer,
    DWORD                           nSize,
    LPDWORD                         lpNumberOfBytesRead,
    PREAD_PROCESS_MEMORY_ROUTINE64  ReadMemory,
    PTRANSLATE_ADDRESS_ROUTINE64    TranslateAddress
    )
{
    ADDRESS64 addr;

    addr = *lpBaseAddress;
    if (addr.Mode != AddrModeFlat) {
        TranslateAddress( hProcess, hThread, &addr );
    }
    return ReadMemory( hProcess,
                       addr.Offset,
                       lpBuffer,
                       nSize,
                       lpNumberOfBytesRead
                       );
}

DWORD64
SearchForReturnAddress(
    HANDLE                            hProcess,
    DWORD64                           uoffStack,
    DWORD64                           funcAddr,
    DWORD                             funcSize,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    BOOL                              AcceptUnreadableCallSite
    )
{
    DWORD64        uoffRet;
    DWORD64        uoffBestGuess = 0;
    DWORD          cdwIndex;
    DWORD          cdwIndexMax;
    INT            cbIndex;
    INT            cbLimit;
    DWORD          cBytes;
    DWORD          cJmpChain = 0;
    DWORD64        uoffT;
    DWORD          cb;
    BYTE           jmpBuffer[ sizeof(WORD) + sizeof(DWORD) ];
    LPWORD         lpwJmp = (LPWORD)&jmpBuffer[0];
    BYTE           code[MAX_CALL];
    DWORD          stack [ MAX_STACK_SEARCH ];
    BOPINSTR BopInstr;

    //
    // this function is necessary for 4 reasons:
    //
    //      1) random compiler bugs where regs are saved on the
    //         stack but the fpo data does not account for them
    //
    //      2) inline asm code that does a push
    //
    //      3) any random code that does a push and it isn't
    //         accounted for in the fpo data
    //
    //      4) non-void non-fpo functions
    //         *** This case is not neccessary when the compiler
    //          emits FPO records for non-FPO funtions.  Unfortunately
    //          only the NT group uses this feature.
    //

    if (!ReadMemory(hProcess,
                    uoffStack,
                    stack,
                    sizeof(stack),
                    &cb)) {
        return 0;
    }


    cdwIndexMax = cb / STACK_SIZE;

    if ( !cdwIndexMax ) {
        return 0;
    }

    for ( cdwIndex=0; cdwIndex<cdwIndexMax; cdwIndex++,uoffStack+=STACK_SIZE ) {

        uoffRet = (DWORD64)(LONG64)(LONG)stack[cdwIndex];

        //
        // Don't try looking for Code in the first 64K of an NT app.
        //
        if ( uoffRet < 0x00010000 ) {
            continue;
        }

        //
        // if it isn't part of any known address space it must be bogus
        //

        if (GetModuleBase( hProcess, uoffRet ) == 0) {
            continue;
        }

        //
        // Check for a BOP instruction.
        //
        if (ReadMemory(hProcess,
                       uoffRet - sizeof(BOPINSTR),
                       &BopInstr,
                       sizeof(BOPINSTR),
                       &cb)) {

            if (cb == sizeof(BOPINSTR) &&
                BopInstr.Instr1 == 0xc4 && BopInstr.Instr2 == 0xc4) {
                return uoffStack;
            }
        }

        //
        // Read the maximum number of bytes a call could be from the istream
        //
        cBytes = MAX_CALL;
        if (!ReadMemory(hProcess,
                        uoffRet - cBytes,
                        code,
                        cBytes,
                        &cb)) {

            //
            // if page is not present, we will ALWAYS screw up by
            // continuing to search.  If alloca was used also, we
            // are toast.  Too Bad.
            //
            if (cdwIndex == 0 && AcceptUnreadableCallSite) {
                return uoffStack;
            } else {
                continue;
            }
        }



        //
        // With 32bit code that isn't FAR:32 we don't have to worry about
        // intersegment calls.  Check here to see if we had a call within
        // segment.  If it is we can later check it's full diplacement if
        // necessary and see if it calls the FPO function.  We will also have
        // to check for thunks and see if maybe it called a JMP indirect which
        // called the FPO function. We will fail to find the caller if it was
        // a case of tail recursion where one function doesn't actually call
        // another but rather jumps to it.  This will only happen when a
        // function who's parameter list is void calls another function who's
        // parameter list is void and the call is made as the last statement
        // in the first function.  If the call to the first function was an
        // 0xE8 call we will fail to find it here because it didn't call the
        // FPO function but rather the FPO functions caller.  If we don't get
        // specific about our 0xE8 checks we will potentially see things that
        // look like return addresses but aren't.
        //

        if (( cBytes >= 5 ) && ( ( code[ 2 ] == 0xE8 ) || ( code[ 2 ] == 0xE9 ) )) {

            // We do math on 32 bit so we can ignore carry, and then sign extended
            uoffT = (ULONG64)(LONG64)(LONG)((DWORD)uoffRet + *( (UNALIGNED DWORD *) &code[3] ));

            //
            // See if it calls the function directly, or into the function
            //
            if (( uoffT >= funcAddr) && ( uoffT < (funcAddr + funcSize) ) ) {
                return uoffStack;
            }


            while ( cJmpChain < MAX_JMP_CHAIN ) {

                if (!ReadMemory(hProcess,
                                uoffT,
                                jmpBuffer,
                                sizeof(jmpBuffer),
                                &cb)) {
                    break;
                }

                if (cb != sizeof(jmpBuffer)) {
                    break;
                }

                //
                // Now we are going to check if it is a call to a JMP, that may
                // jump to the function
                //
                // If it is a relative JMP then calculate the destination
                // and save it in uoffT.  If it is an indirect JMP then read
                // the destination from where the JMP is inderecting through.
                //
                if ( *(LPBYTE)lpwJmp == 0xE9 ) {

                    // We do math on 32 bit so we can ignore carry, and then
                    // sign extended
                    uoffT = (ULONG64)(LONG64)(LONG) ((ULONG)uoffT +
                            *(UNALIGNED DWORD *)( jmpBuffer + sizeof(BYTE) ) + 5);

                } else if ( *lpwJmp == 0x25FF ) {

                    if ((!ReadMemory(hProcess,
                                     (ULONG64)(LONG64)(LONG) (
                                         *(UNALIGNED DWORD *)
                                         ((LPBYTE)lpwJmp+sizeof(WORD))),
                                     &uoffT,
                                     sizeof(DWORD),
                                     &cb)) || (cb != sizeof(DWORD))) {
                        uoffT = 0;
                        break;
                    }
                    uoffT =  (DWORD64)(LONG64)(LONG)uoffT;

                } else {
                    break;
                }

                //
                // If the destination is to the FPO function then we have
                // found the return address and thus the vEBP
                //
                if ( uoffT == funcAddr ) {
                    return uoffStack;
                }

                cJmpChain++;
            }

            //
            // We cache away the first 0xE8 call or 0xE9 jmp that we find in
            // the event we cant find anything else that looks like a return
            // address.  This is meant to protect us in the tail recursion case.
            //
            if ( !uoffBestGuess ) {
                uoffBestGuess = uoffStack;
            }
        }


        //
        // Now loop backward through the bytes read checking for a multi
        // byte call type from Grp5.  If we find an 0xFF then we need to
        // check the byte after that to make sure that the nnn bits of
        // the mod/rm byte tell us that it is a call.  It it is a call
        // then we will assume that this one called us because we can
        // no longer accurately determine for sure whether this did
        // in fact call the FPO function.  Since 0xFF calls are a guess
        // as well we will not check them if we already have an earlier guess.
        // It is more likely that the first 0xE8 called the function than
        // something higher up the stack that might be an 0xFF call.
        //
        if ( !uoffBestGuess && cBytes >= MIN_CALL ) {

            cbLimit = MAX_CALL - (INT)cBytes;

            for (cbIndex = MAX_CALL - MIN_CALL;
                 cbIndex >= cbLimit;  //MAX_CALL - (INT)cBytes;
                 cbIndex--) {

                if ( ( code [ cbIndex ] == 0xFF ) &&
                    ( ( code [ cbIndex + 1 ] & 0x30 ) == 0x10 )){

                    return uoffStack;

                }
            }
        }
    }

    //
    // we found nothing that was 100% definite so we'll return the best guess
    //
    return uoffBestGuess;
}


BOOL
GetFpoFrameBase(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    lpstkfrm,
    PFPO_DATA                         pFpoData,
    BOOL                              fFirstFrame,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase
    )
{
    DWORD          Addr32;
    X86_KTRAP_FRAME    TrapFrame;
    DWORD64        OldFrameAddr;
    DWORD64        FrameAddr;
    DWORD64        StackAddr;
    DWORD64        ModuleBase;
    DWORD64        FuncAddr;
    DWORD          cb;
    DWORD64        StoredEbp;
    PFPO_DATA      PreviousFpoData = (PFPO_DATA)lpstkfrm->FuncTableEntry;

    //
    // calculate the address of the beginning of the function
    //
    ModuleBase = GetModuleBase( hProcess, lpstkfrm->AddrPC.Offset );
    if (!ModuleBase) {
        return FALSE;
    }

    FuncAddr = ModuleBase+pFpoData->ulOffStart;

    //
    // If this isn't the first/current frame then we can add back the count
    // bytes of locals and register pushed before beginning to search for
    // vEBP.  If we are beyond prolog we can add back the count bytes of locals
    // and registers pushed as well.  If it is the first frame and EIP is
    // greater than the address of the function then the SUB for locals has
    // been done so we can add them back before beginning the search.  If we
    // are right on the function then we will need to start our search at ESP.
    //

    if ( !fFirstFrame ) {

        OldFrameAddr = lpstkfrm->AddrFrame.Offset;
        FrameAddr = 0;

        //
        // if this is a non-fpo or trap frame, get the frame base now:
        //

        if (pFpoData->cbFrame != FRAME_FPO) {

            if (!PreviousFpoData || PreviousFpoData->cbFrame == FRAME_NONFPO) {

                //
                // previous frame base is ebp and points to this frame's ebp
                //
                ReadMemory(hProcess,
                           OldFrameAddr,
                           &Addr32,
                           sizeof(DWORD),
                           &cb);

                FrameAddr = (DWORD64)(LONG64)(LONG)Addr32;
            }

            //
            // if that didn't work, try for a saved ebp
            //
            if (!FrameAddr && SAVE_EBP(lpstkfrm)) {

                FrameAddr = SAVE_EBP(lpstkfrm);

            }

            //
            // this is not an FPO frame, so the saved EBP can only have come
            // from this or a lower frame.
            //

            SAVE_EBP(lpstkfrm) = 0;
        }

        //
        // still no frame base - either this frame is fpo, or we couldn't
        // follow the ebp chain.
        //

        if (FrameAddr == 0) {
            FrameAddr = OldFrameAddr;

            //
            // skip over return address from prev frame
            //
            FrameAddr += FRAME_SIZE;

            //
            // skip over this frame's locals and saved regs
            //
            FrameAddr += ( pFpoData->cdwLocals * STACK_SIZE );
            FrameAddr += ( pFpoData->cbRegs * STACK_SIZE );

            if (PreviousFpoData) {
                //
                // if the previous frame had an fpo record, we can account
                // for its parameters
                //
                FrameAddr += PreviousFpoData->cdwParams * STACK_SIZE;

            }
        }

        //
        // if this is an FPO frame
        // and the previous frame was non-fpo,
        // and this frame passed the inherited ebp to the previous frame,
        //  save its ebp
        //
        // (if this frame used ebp, SAVE_EBP will be set after verifying
        // the frame base)
        //
        if (pFpoData->cbFrame == FRAME_FPO &&
            (!PreviousFpoData || PreviousFpoData->cbFrame == FRAME_NONFPO) &&
            !pFpoData->fUseBP) {

            SAVE_EBP(lpstkfrm) = 0;

            if (ReadMemory(hProcess,
                           OldFrameAddr,
                           &Addr32,
                           sizeof(DWORD),
                           &cb)) {

                SAVE_EBP(lpstkfrm) = (DWORD64)(LONG64)(LONG)Addr32;
            }
        }


    } else {

        OldFrameAddr = lpstkfrm->AddrFrame.Offset;
        if (pFpoData->cbFrame == FRAME_FPO && !pFpoData->fUseBP) {
            //
            // this frame didn't use EBP, so it actually belongs
            // to a non-FPO frame further up the stack.  Stash
            // it in the save area for the next frame.
            //
            SAVE_EBP(lpstkfrm) = lpstkfrm->AddrFrame.Offset;
        }

        if (pFpoData->cbFrame == FRAME_TRAP ||
            pFpoData->cbFrame == FRAME_TSS) {

            FrameAddr = lpstkfrm->AddrFrame.Offset;

        } else if (lpstkfrm->AddrPC.Offset == FuncAddr) {

            FrameAddr = lpstkfrm->AddrStack.Offset;

        } else if (lpstkfrm->AddrPC.Offset >= FuncAddr+pFpoData->cbProlog) {

            FrameAddr = lpstkfrm->AddrStack.Offset +
                        ( pFpoData->cdwLocals * STACK_SIZE ) +
                        ( pFpoData->cbRegs * STACK_SIZE );

        } else {

            FrameAddr = lpstkfrm->AddrStack.Offset +
                        ( pFpoData->cdwLocals * STACK_SIZE );

        }

    }


    if (pFpoData->cbFrame == FRAME_TRAP) {

        //
        // read a kernel mode trap frame from the stack
        //

        if (!ReadTrapFrame( hProcess,
                            FrameAddr,
                            &TrapFrame,
                            ReadMemory )) {
            return FALSE;
        }

        SAVE_TRAP(lpstkfrm) = FrameAddr;
        TRAP_EDITED(lpstkfrm) = TrapFrame.SegCs & X86_FRAME_EDITED;

        lpstkfrm->AddrReturn.Offset = (DWORD64)(LONG64)(LONG)(TrapFrame.Eip);
        lpstkfrm->AddrReturn.Mode = AddrModeFlat;
        lpstkfrm->AddrReturn.Segment = 0;

        return TRUE;
    }

    if (pFpoData->cbFrame == FRAME_TSS) {

        //
        // translate a tss to a kernel mode trap frame
        //

        StackAddr = FrameAddr;

        TaskGate2TrapFrame( hProcess, X86_KGDT_TSS, &TrapFrame, &StackAddr, ReadMemory );

        TRAP_TSS(lpstkfrm) = X86_KGDT_TSS;
        SAVE_TRAP(lpstkfrm) = StackAddr;

        lpstkfrm->AddrReturn.Offset = (DWORD64)(LONG64)(LONG)(TrapFrame.Eip);
        lpstkfrm->AddrReturn.Mode = AddrModeFlat;
        lpstkfrm->AddrReturn.Segment = 0;

        return TRUE;
    }

    if ((pFpoData->cbFrame != FRAME_FPO) &&
        (pFpoData->cbFrame != FRAME_NONFPO) ) {
        //
        // we either have a compiler or linker problem, or possibly
        // just simple data corruption.
        //
        return FALSE;
    }

    //
    // go look for a return address.  this is done because, eventhough
    // we have subtracted all that we can from the frame pointer it is
    // possible that there is other unknown data on the stack.  by
    // searching for the return address we are able to find the base of
    // the fpo frame.
    //
    FrameAddr = SearchForReturnAddress( hProcess,
                                        FrameAddr,
                                        FuncAddr,
                                        pFpoData->cbProcSize,
                                        ReadMemory,
                                        GetModuleBase,
                                        PreviousFpoData != NULL
                                        );
    if (!FrameAddr) {
        return FALSE;
    }

    if (pFpoData->fUseBP && pFpoData->cbFrame == FRAME_FPO) {

        //
        // this function used ebp as a general purpose register, but
        // before doing so it saved ebp on the stack.  the prolog code
        // always saves ebp last so it is always at the top of the stack.
        //
        // we must retrieve this ebp and save it for possible later
        // use if we encounter a non-fpo frame
        //

        if (fFirstFrame && lpstkfrm->AddrPC.Offset < FuncAddr+pFpoData->cbProlog) {

            SAVE_EBP(lpstkfrm) = OldFrameAddr;

        } else {

            StackAddr = FrameAddr -
                ( ( pFpoData->cbRegs + pFpoData->cdwLocals ) * STACK_SIZE );

            SAVE_EBP(lpstkfrm) = 0;
            if (ReadMemory(hProcess,
                           StackAddr,
                           &Addr32,
                           sizeof(DWORD),
                           &cb)) {

                SAVE_EBP(lpstkfrm) = (DWORD64)(LONG64)(LONG)Addr32;
            }

        }
    }

    //
    // subtract the size for an ebp register if one had
    // been pushed.  this is done because the frames that
    // are virtualized need to appear as close to a real frame
    // as possible.
    //

    lpstkfrm->AddrFrame.Offset = FrameAddr - STACK_SIZE;

    return TRUE;
}


BOOL
ReadTrapFrame(
    HANDLE                            hProcess,
    DWORD64                           TrapFrameAddress,
    PX86_KTRAP_FRAME                  TrapFrame,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory
    )
{
    DWORD cb;

    if (!ReadMemory(hProcess,
                    TrapFrameAddress,
                    TrapFrame,
                    sizeof(*TrapFrame),
                    &cb)) {
        return FALSE;
    }

    if (cb < sizeof(*TrapFrame)) {
        if (cb < sizeof(*TrapFrame) - 20) {
            //
            // shorter then the smallest possible frame type
            //
            return FALSE;
        }

        if ((TrapFrame->SegCs & 1) &&  cb < sizeof(*TrapFrame) - 16 ) {
            //
            // too small for inter-ring frame
            //
            return FALSE;
        }

        if (TrapFrame->EFlags & X86_EFLAGS_V86_MASK) {
            //
            // too small for V86 frame
            //
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
GetSelector(
    HANDLE                            hProcess,
    USHORT                            Processor,
    PX86_DESCRIPTOR_TABLE_ENTRY       pDescriptorTableEntry,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory
    )
{
    ULONG_PTR   Address;
    PVOID       TableBase;
    USHORT      TableLimit;
    ULONG       Index;
    X86_LDT_ENTRY   Descriptor;
    ULONG       bytesread;


    //
    // Fetch the address and limit of the GDT
    //
    Address = (ULONG_PTR)&(((PX86_KSPECIAL_REGISTERS)0)->Gdtr.Base);
    ReadMemory( hProcess, Address, &TableBase, sizeof(TableBase), (LPDWORD)-1  );
    Address = (ULONG_PTR)&(((PX86_KSPECIAL_REGISTERS)0)->Gdtr.Limit);
    ReadMemory( hProcess, Address, &TableLimit, sizeof(TableLimit),  (LPDWORD)-1  );

    //
    // Find out whether this is a GDT or LDT selector
    //
    if (pDescriptorTableEntry->Selector & 0x4) {

        //
        // This is an LDT selector, so we reload the TableBase and TableLimit
        // with the LDT's Base & Limit by loading the descriptor for the
        // LDT selector.
        //

        if (!ReadMemory(hProcess,
                        (ULONG64)TableBase+X86_KGDT_LDT,
                        &Descriptor,
                        sizeof(Descriptor),
                        &bytesread)) {
            return FALSE;
        }

        TableBase = (PVOID)(DWORD_PTR)((ULONG)Descriptor.BaseLow +    // Sundown: zero-extension from ULONG to PVOID.
                    ((ULONG)Descriptor.HighWord.Bits.BaseMid << 16) +
                    ((ULONG)Descriptor.HighWord.Bytes.BaseHi << 24));

        TableLimit = Descriptor.LimitLow;  // LDT can't be > 64k

        if(Descriptor.HighWord.Bits.Granularity) {

            //
            //  I suppose it's possible, although silly, to have an
            //  LDT with page granularity.
            //
            TableLimit <<= X86_PAGE_SHIFT;
        }
    }

    Index = (USHORT)(pDescriptorTableEntry->Selector) & ~0x7;
                                                    // Irrelevant bits
    //
    // Check to make sure that the selector is within the table bounds
    //
    if (Index >= TableLimit) {

        //
        // Selector is out of table's bounds
        //

        return FALSE;
    }

    if (!ReadMemory(hProcess,
                    (ULONG64)TableBase+Index,
                    &(pDescriptorTableEntry->Descriptor),
                    sizeof(pDescriptorTableEntry->Descriptor),
                    &bytesread)) {
        return FALSE;
    }

    return TRUE;
}


BOOL
TaskGate2TrapFrame(
    HANDLE                            hProcess,
    USHORT                            TaskRegister,
    PX86_KTRAP_FRAME                  TrapFrame,
    PULONG64                          off,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory
    )
{
    X86_DESCRIPTOR_TABLE_ENTRY desc;
    ULONG                    bytesread;
    struct  {
        ULONG   r1[8];
        ULONG   Eip;
        ULONG   EFlags;
        ULONG   Eax;
        ULONG   Ecx;
        ULONG   Edx;
        ULONG   Ebx;
        ULONG   Esp;
        ULONG   Ebp;
        ULONG   Esi;
        ULONG   Edi;
        ULONG   Es;
        ULONG   Cs;
        ULONG   Ss;
        ULONG   Ds;
        ULONG   Fs;
        ULONG   Gs;
    } TaskState;


    //
    // Get the task register
    //

    desc.Selector = TaskRegister;
    if (!GetSelector(hProcess, 0, &desc, ReadMemory)) {
        return FALSE;
    }

    if (desc.Descriptor.HighWord.Bits.Type != 9  &&
        desc.Descriptor.HighWord.Bits.Type != 0xb) {
        //
        // not a 32bit task descriptor
        //
        return FALSE;
    }

    //
    // Read in Task State Segment
    //

    *off = ((ULONG)desc.Descriptor.BaseLow +
           ((ULONG)desc.Descriptor.HighWord.Bytes.BaseMid << 16) +
           ((ULONG)desc.Descriptor.HighWord.Bytes.BaseHi  << 24) );

    if (!ReadMemory(hProcess,
                    (ULONG64)(LONG64)(LONG)(*off),
                    &TaskState,
                    sizeof(TaskState),
                    &bytesread)) {
        return FALSE;
    }

    //
    // Move fields from Task State Segment to TrapFrame
    //

    ZeroMemory( TrapFrame, sizeof(*TrapFrame) );

    TrapFrame->Eip    = TaskState.Eip;
    TrapFrame->EFlags = TaskState.EFlags;
    TrapFrame->Eax    = TaskState.Eax;
    TrapFrame->Ecx    = TaskState.Ecx;
    TrapFrame->Edx    = TaskState.Edx;
    TrapFrame->Ebx    = TaskState.Ebx;
    TrapFrame->Ebp    = TaskState.Ebp;
    TrapFrame->Esi    = TaskState.Esi;
    TrapFrame->Edi    = TaskState.Edi;
    TrapFrame->SegEs  = TaskState.Es;
    TrapFrame->SegCs  = TaskState.Cs;
    TrapFrame->SegDs  = TaskState.Ds;
    TrapFrame->SegFs  = TaskState.Fs;
    TrapFrame->SegGs  = TaskState.Gs;
    TrapFrame->HardwareEsp = TaskState.Esp;
    TrapFrame->HardwareSegSs = TaskState.Ss;

    return TRUE;
}

BOOL
ProcessTrapFrame(
    HANDLE                            hProcess,
    LPSTACKFRAME64                    lpstkfrm,
    PFPO_DATA                         pFpoData,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess
    )
{
    X86_KTRAP_FRAME TrapFrame;
    DWORD64         StackAddr;

    if (((PFPO_DATA)lpstkfrm->FuncTableEntry)->cbFrame == FRAME_TSS) {
        StackAddr = SAVE_TRAP(lpstkfrm);
        TaskGate2TrapFrame( hProcess, X86_KGDT_TSS, &TrapFrame, &StackAddr, ReadMemory );
    } else {
        if (!ReadTrapFrame( hProcess,
                            SAVE_TRAP(lpstkfrm),
                            &TrapFrame,
                            ReadMemory)) {
            SAVE_TRAP(lpstkfrm) = 0;
            return FALSE;
        }
    }

    pFpoData = (PFPO_DATA)
               FunctionTableAccess(hProcess,
                                   (DWORD64)(LONG64)(LONG)TrapFrame.Eip);

    if (!pFpoData) {
        lpstkfrm->AddrFrame.Offset = (DWORD64)(LONG64)(LONG)TrapFrame.Ebp;
        SAVE_EBP(lpstkfrm) = 0;
    } else {
        if ((TrapFrame.SegCs & X86_MODE_MASK) ||
            (TrapFrame.EFlags & X86_EFLAGS_V86_MASK)) {
            //
            // User-mode frame, real value of Esp is in HardwareEsp
            //
            lpstkfrm->AddrFrame.Offset = (DWORD64)(LONG64)(LONG)(TrapFrame.HardwareEsp - STACK_SIZE);
            lpstkfrm->AddrStack.Offset = (DWORD64)(LONG64)(LONG)TrapFrame.HardwareEsp;

        } else {
            //
            // We ignore if Esp has been edited for now, and we will print a
            // separate line indicating this later.
            //
            // Calculate kernel Esp
            //

            if (((PFPO_DATA)lpstkfrm->FuncTableEntry)->cbFrame == FRAME_TRAP) {
                //
                // plain trap frame
                //
                if ((TrapFrame.SegCs & X86_FRAME_EDITED) == 0) {
                    lpstkfrm->AddrStack.Offset = (DWORD64)(LONG64)(LONG)TrapFrame.TempEsp;
                } else {
                    lpstkfrm->AddrStack.Offset = (ULONG64)(LONG64)(LONG_PTR)
                        (& (((PX86_KTRAP_FRAME)SAVE_TRAP(lpstkfrm))->HardwareEsp) );
                }
            } else {
                //
                // tss converted to trap frame
                //
                lpstkfrm->AddrStack.Offset = (DWORD64)(LONG64)(LONG)TrapFrame.HardwareEsp;
            }
        }
    }

    lpstkfrm->AddrFrame.Offset = (DWORD64)(LONG64)(LONG)TrapFrame.Ebp;
    lpstkfrm->AddrPC.Offset = (DWORD64)(LONG64)(LONG)TrapFrame.Eip;

    SAVE_TRAP(lpstkfrm) = 0;
    lpstkfrm->FuncTableEntry = pFpoData;

    return TRUE;
}

BOOL
IsFarCall(
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME64                    lpstkfrm,
    BOOL                              *Ok,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{
    BOOL       fFar = FALSE;
    ULONG      cb;
    ADDRESS64  Addr;

    *Ok = TRUE;

    if (lpstkfrm->AddrFrame.Mode == AddrModeFlat) {
        DWORD      dwStk[ 3 ];
        //
        // If we are working with 32 bit offset stack pointers, we
        //      will say that the return address if far if the address
        //      treated as a FAR pointer makes any sense,  if not then
        //      it must be a near return
        //

        if (lpstkfrm->AddrFrame.Offset &&
            DoMemoryRead( &lpstkfrm->AddrFrame, dwStk, sizeof(dwStk), &cb )) {
            //
            //  See if segment makes sense
            //

            Addr.Offset   = (DWORD64)(LONG64)(LONG)(dwStk[1]);
            Addr.Segment  = (WORD)dwStk[2];
            Addr.Mode = AddrModeFlat;

            if (TranslateAddress( hProcess, hThread, &Addr ) && Addr.Offset) {
                fFar = TRUE;
            }
        } else {
            *Ok = FALSE;
        }
    } else {
        WORD       wStk[ 3 ];
        //
        // For 16 bit (i.e. windows WOW code) we do the following tests
        //      to check to see if an address is a far return value.
        //
        //      1.  if the saved BP register is odd then it is a far
        //              return values
        //      2.  if the address treated as a far return value makes sense
        //              then it is a far return value
        //      3.  else it is a near return value
        //

        if (lpstkfrm->AddrFrame.Offset &&
            DoMemoryRead( &lpstkfrm->AddrFrame, wStk, 6, &cb )) {

            if ( wStk[0] & 0x0001 ) {
                fFar = TRUE;
            } else {

                //
                //  See if segment makes sense
                //

                Addr.Offset   = wStk[1];
                Addr.Segment  = wStk[2];
                Addr.Mode = AddrModeFlat;

                if (TranslateAddress( hProcess, hThread, &Addr  ) && Addr.Offset) {
                    fFar = TRUE;
                }
            }
        } else {
            *Ok = FALSE;
        }
    }
    return fFar;
}


BOOL
SetNonOff32FrameAddress(
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME64                    lpstkfrm,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{
    BOOL    fFar;
    WORD    Stk[ 3 ];
    ULONG   cb;
    BOOL    Ok;

    fFar = IsFarCall( hProcess, hThread, lpstkfrm, &Ok, ReadMemory, TranslateAddress );

    if (!Ok) {
        return FALSE;
    }

    if (!DoMemoryRead( &lpstkfrm->AddrFrame, Stk, fFar ? FRAME_SIZE1632 : FRAME_SIZE16, &cb )) {
        return FALSE;
    }

    if (SAVE_EBP(lpstkfrm) > 0) {
        lpstkfrm->AddrFrame.Offset = SAVE_EBP(lpstkfrm) & 0xffff;
        lpstkfrm->AddrPC.Offset = Stk[1];
        if (fFar) {
            lpstkfrm->AddrPC.Segment = Stk[2];
        }
        SAVE_EBP(lpstkfrm) = 0;
    } else {
        if (Stk[1] == 0) {
            return FALSE;
        } else {
            lpstkfrm->AddrFrame.Offset = Stk[0];
            lpstkfrm->AddrFrame.Offset &= 0xFFFFFFFE;
            lpstkfrm->AddrPC.Offset = Stk[1];
            if (fFar) {
                lpstkfrm->AddrPC.Segment = Stk[2];
            }
        }
    }

    return TRUE;
}

VOID
GetFunctionParameters(
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME64                    lpstkfrm,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{
    BOOL                Ok;
    DWORD               cb;
    ADDRESS64           ParmsAddr;
    DWORD               Params[4];


    ParmsAddr = lpstkfrm->AddrFrame;

    //
    // calculate the frame size
    //
    if (lpstkfrm->AddrPC.Mode == AddrModeFlat) {

        ParmsAddr.Offset += FRAME_SIZE;

    } else
    if ( IsFarCall( hProcess, hThread, lpstkfrm, &Ok,
                    ReadMemory, TranslateAddress ) ) {

        lpstkfrm->Far = TRUE;
        ParmsAddr.Offset += FRAME_SIZE1632;

    } else {

        lpstkfrm->Far = FALSE;
        ParmsAddr.Offset += STACK_SIZE;

    }

    //
    // read the memory
    //
    if (DoMemoryRead( &ParmsAddr, Params, STACK_SIZE*4, &cb )) {
        lpstkfrm->Params[0] = (DWORD64)(LONG64)(LONG)(Params[0]);
        lpstkfrm->Params[1] = (DWORD64)(LONG64)(LONG)(Params[1]);
        lpstkfrm->Params[2] = (DWORD64)(LONG64)(LONG)(Params[2]);
        lpstkfrm->Params[3] = (DWORD64)(LONG64)(LONG)(Params[3]);
    } else {
        lpstkfrm->Params[0] =
        lpstkfrm->Params[1] =
        lpstkfrm->Params[2] =
        lpstkfrm->Params[3] = 0;
    }
}

VOID
GetReturnAddress(
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME64                    lpstkfrm,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{
    ULONG               cb;
    DWORD               stack[2];


    if (SAVE_TRAP(lpstkfrm)) {
        //
        // if a trap frame was encountered then
        // the return address was already calculated
        //
        return;
    }

    if (lpstkfrm->AddrPC.Mode == AddrModeFlat) {

        //
        // read the frame from the process's memory
        //
        if (!DoMemoryRead( &lpstkfrm->AddrFrame, stack, FRAME_SIZE, &cb )) {
            //
            // if we could not read the memory then set
            // the return address to zero so that the stack trace
            // will terminate
            //

            stack[1] = 0;

        }

        lpstkfrm->AddrReturn.Offset = (DWORD64)(LONG64)(LONG)(stack[1]);

    } else {

        lpstkfrm->AddrReturn.Offset = lpstkfrm->AddrPC.Offset;
        lpstkfrm->AddrReturn.Segment = lpstkfrm->AddrPC.Segment;

    }
}

BOOL
WalkX86_Fpo_Fpo(
    HANDLE                            hProcess,
    HANDLE                            hThread,
    PFPO_DATA                         pFpoData,
    LPSTACKFRAME64                    lpstkfrm,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{
    BOOL rval;

    rval = GetFpoFrameBase( hProcess,
                            lpstkfrm,
                            pFpoData,
                            FALSE,
                            ReadMemory,
                            GetModuleBase );

    lpstkfrm->FuncTableEntry = pFpoData;

    return rval;
}

BOOL
WalkX86_Fpo_NonFpo(
    HANDLE                            hProcess,
    HANDLE                            hThread,
    PFPO_DATA                         pFpoData,
    LPSTACKFRAME64                    lpstkfrm,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{
    DWORD       stack[FRAME_SIZE+STACK_SIZE];
    DWORD       cb;
    DWORD64     FrameAddr;
    DWORD64     FuncAddr;
    DWORD       FuncSize;
    BOOL        AcceptUnreadableCallsite = FALSE;

    //
    // if the previous frame was an seh frame then we must
    // retrieve the "real" frame pointer for this frame.
    // the seh function pushed the frame pointer last.
    //

    if (((PFPO_DATA)lpstkfrm->FuncTableEntry)->fHasSEH) {

        if (DoMemoryRead( &lpstkfrm->AddrFrame, stack, FRAME_SIZE+STACK_SIZE, &cb )) {

            lpstkfrm->AddrFrame.Offset = (DWORD64)(LONG64)(LONG)(stack[2]);
            lpstkfrm->AddrStack.Offset = (DWORD64)(LONG64)(LONG)(stack[2]);
            WalkX86Init(hProcess,
                        hThread,
                        lpstkfrm,
                        ReadMemory,
                        FunctionTableAccess,
                        GetModuleBase,
                        TranslateAddress);

            return TRUE;
        }
    }

    //
    // If a prior frame has stored this frame's EBP, just use it.
    //

    if (SAVE_EBP(lpstkfrm)) {

        lpstkfrm->AddrFrame.Offset = SAVE_EBP(lpstkfrm);
        FrameAddr = lpstkfrm->AddrFrame.Offset + 4;
        AcceptUnreadableCallsite = TRUE;

    } else {

        //
        // Skip past the FPO frame base and parameters.
        //
        lpstkfrm->AddrFrame.Offset +=
            (FRAME_SIZE + (((PFPO_DATA)lpstkfrm->FuncTableEntry)->cdwParams * 4));

        //
        // Now this is pointing to the bottom of the non-FPO frame.
        // If the frame has an fpo record, use it:
        //

        if (pFpoData) {
            FrameAddr = lpstkfrm->AddrFrame.Offset +
                            4* (pFpoData->cbRegs + pFpoData->cdwLocals);
            AcceptUnreadableCallsite = TRUE;
        } else {
            //
            // We don't know if the non-fpo frame has any locals, but
            // skip past the EBP anyway.
            //
            FrameAddr = lpstkfrm->AddrFrame.Offset + 4;
        }
    }

    //
    // at this point we may not be sitting at the base of the frame
    // so we now search for the return address and then subtract the
    // size of the frame pointer and use that address as the new base.
    //

    if (pFpoData) {
        FuncAddr = GetModuleBase(hProcess,lpstkfrm->AddrPC.Offset) + pFpoData->ulOffStart;
        FuncSize = pFpoData->cbProcSize;

    } else {
        FuncAddr = lpstkfrm->AddrPC.Offset - MAX_CALL;
        FuncSize = MAX_CALL;
    }



    FrameAddr = SearchForReturnAddress( hProcess,
                                        FrameAddr,
                                        FuncAddr,
                                        FuncSize,
                                        ReadMemory,
                                        GetModuleBase,
                                        AcceptUnreadableCallsite
                                        );
    if (FrameAddr) {
        lpstkfrm->AddrFrame.Offset = FrameAddr - STACK_SIZE;
    }

    if (!DoMemoryRead( &lpstkfrm->AddrFrame, stack, FRAME_SIZE, &cb )) {
        //
        // a failure means that we likely have a bad address.
        // returning zero will terminate that stack trace.
        //
        stack[0] = 0;
    }

    SAVE_EBP(lpstkfrm) = (DWORD64)(LONG64)(LONG)(stack[0]);

    lpstkfrm->FuncTableEntry = pFpoData;

    return TRUE;
}

BOOL
WalkX86_NonFpo_Fpo(
    HANDLE                            hProcess,
    HANDLE                            hThread,
    PFPO_DATA                         pFpoData,
    LPSTACKFRAME64                    lpstkfrm,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{
    BOOL           rval;

    rval = GetFpoFrameBase( hProcess,
                            lpstkfrm,
                            pFpoData,
                            FALSE,
                            ReadMemory,
                            GetModuleBase );

    lpstkfrm->FuncTableEntry = pFpoData;

    return rval;
}

BOOL
WalkX86_NonFpo_NonFpo(
    HANDLE                            hProcess,
    HANDLE                            hThread,
    PFPO_DATA                         pFpoData,
    LPSTACKFRAME64                    lpstkfrm,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{
    DWORD       stack[FRAME_SIZE*4];
    DWORD       cb;

    //
    // a previous function in the call stack was a fpo function that used ebp as
    // a general purpose register.  ul contains the ebp value that was good  before
    // that function executed.  it is that ebp that we want, not what was just read
    // from the stack.  what was just read from the stack is totally bogus.
    //
    if (SAVE_EBP(lpstkfrm)) {

        lpstkfrm->AddrFrame.Offset = SAVE_EBP(lpstkfrm);
        SAVE_EBP(lpstkfrm) = 0;

    } else {

        //
        // read the first 2 dwords off the stack
        //
        if (!DoMemoryRead( &lpstkfrm->AddrFrame, stack, FRAME_SIZE, &cb )) {
            return FALSE;
        }

        lpstkfrm->AddrFrame.Offset = (DWORD64)(LONG64)(LONG)(stack[0]);
    }

    lpstkfrm->FuncTableEntry = pFpoData;

    return TRUE;
}

BOOL
WalkX86Next(
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME64                    lpstkfrm,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{
    PFPO_DATA      pFpoData = NULL;
    BOOL           rVal = TRUE;
    DWORD64        Address;
    DWORD          cb;
    DWORD64        ThisPC;
    DWORD64        ModuleBase;
    DWORD64        SystemRangeStart;


    if (AppVersion.Revision >= 6) {
        SystemRangeStart = (ULONG64)(LONG64)(LONG_PTR)(SYSTEM_RANGE_START(lpstkfrm));
    } else {
        //
        // This might not really work right with old debuggers, but it keeps
        // us from looking off the end of the structure anyway.
        //
        SystemRangeStart = 0xFFFFFFFF80000000;
    }


    ThisPC = lpstkfrm->AddrPC.Offset;

    //
    // the previous frame's return address is this frame's pc
    //
    lpstkfrm->AddrPC = lpstkfrm->AddrReturn;

    if (lpstkfrm->AddrPC.Mode != AddrModeFlat) {
        //
        // the call stack is from either WOW or a DOS app
        //
        SetNonOff32FrameAddress( hProcess,
                                 hThread,
                                 lpstkfrm,
                                 ReadMemory,
                                 FunctionTableAccess,
                                 GetModuleBase,
                                 TranslateAddress
                               );
        goto exit;
    }

    //
    // if the last frame was the usermode callback dispatcher,
    // switch over to the kernel stack:
    //

    ModuleBase = GetModuleBase(hProcess, ThisPC);

    if ((AppVersion.Revision >= 4) &&
        (CALLBACK_STACK(lpstkfrm) != 0) &&
        (pFpoData = (PFPO_DATA)lpstkfrm->FuncTableEntry) &&
        (CALLBACK_DISPATCHER(lpstkfrm) == ModuleBase + pFpoData->ulOffStart) )  {


      NextCallback:

        rVal = FALSE;

        //
        // find callout frame
        //

        if ((ULONG64)(LONG64)(LONG_PTR)(CALLBACK_STACK(lpstkfrm)) >= SystemRangeStart) {

            //
            // it is the pointer to the stack frame that we want,
            // or -1.

            Address = (ULONG64)(LONG64)(LONG) CALLBACK_STACK(lpstkfrm);

        } else {

            //
            // if it is below SystemRangeStart, it is the offset to
            // the address in the thread.
            // Look up the pointer:
            //

            rVal = ReadMemory(hProcess,
                              (CALLBACK_THREAD(lpstkfrm) +
                                 CALLBACK_STACK(lpstkfrm)),
                              &Address,
                              sizeof(DWORD),
                              &cb);

            Address = (ULONG64)(LONG64)(LONG)Address;

            if (!rVal || Address == 0) {
                Address = 0xffffffff;
                CALLBACK_STACK(lpstkfrm) = 0xffffffff;
            }

        }

        if ((Address == 0xffffffff) ||
            !(pFpoData = (PFPO_DATA) FunctionTableAccess( hProcess,
                                                 CALLBACK_FUNC(lpstkfrm))) ) {
            rVal = FALSE;

        } else {

            lpstkfrm->FuncTableEntry = pFpoData;

            lpstkfrm->AddrPC.Offset = CALLBACK_FUNC(lpstkfrm) +
                                                    pFpoData->cbProlog;

            lpstkfrm->AddrStack.Offset = Address;

            ReadMemory(hProcess,
                       Address + CALLBACK_FP(lpstkfrm),
                       &lpstkfrm->AddrFrame.Offset,
                       sizeof(DWORD),
                       &cb);

            lpstkfrm->AddrFrame.Offset = (ULONG64)(LONG64)(LONG)
                                         lpstkfrm->AddrFrame.Offset;

            ReadMemory(hProcess,
                       Address + CALLBACK_NEXT(lpstkfrm),
                       &CALLBACK_STACK(lpstkfrm),
                       sizeof(DWORD),
                       &cb);

            SAVE_TRAP(lpstkfrm) = 0;

            rVal = WalkX86Init(
                hProcess,
                hThread,
                lpstkfrm,
                ReadMemory,
                FunctionTableAccess,
                GetModuleBase,
                TranslateAddress
                );

        }

        return rVal;

    }

    //
    // if there is a trap frame then handle it
    //
    if (SAVE_TRAP(lpstkfrm)) {
        rVal = ProcessTrapFrame(
            hProcess,
            lpstkfrm,
            pFpoData,
            ReadMemory,
            FunctionTableAccess
            );
        if (!rVal) {
            return rVal;
        }
        rVal = WalkX86Init(
            hProcess,
            hThread,
            lpstkfrm,
            ReadMemory,
            FunctionTableAccess,
            GetModuleBase,
            TranslateAddress
            );
        return rVal;
    }

    //
    // if the PC address is zero then we're at the end of the stack
    //
    //if (GetModuleBase(hProcess, lpstkfrm->AddrPC.Offset) == 0)

    if (lpstkfrm->AddrPC.Offset < 65536) {

        //
        // if we ran out of stack, check to see if there is
        // a callback stack chain
        //
        if (AppVersion.Revision >= 4 && CALLBACK_STACK(lpstkfrm) != 0) {
            goto NextCallback;
        }

        return FALSE;
    }


    //
    // check to see if the current frame is an fpo frame
    //
    pFpoData = (PFPO_DATA) FunctionTableAccess(hProcess, lpstkfrm->AddrPC.Offset);


    if (pFpoData && pFpoData->cbFrame != FRAME_NONFPO) {

        if (lpstkfrm->FuncTableEntry && ((PFPO_DATA)lpstkfrm->FuncTableEntry)->cbFrame != FRAME_NONFPO) {

            rVal = WalkX86_Fpo_Fpo( hProcess,
                                  hThread,
                                  pFpoData,
                                  lpstkfrm,
                                  ReadMemory,
                                  FunctionTableAccess,
                                  GetModuleBase,
                                  TranslateAddress
                                );

        } else {

            rVal = WalkX86_NonFpo_Fpo( hProcess,
                                     hThread,
                                     pFpoData,
                                     lpstkfrm,
                                     ReadMemory,
                                     FunctionTableAccess,
                                     GetModuleBase,
                                     TranslateAddress
                                   );

        }
    } else {
        if (lpstkfrm->FuncTableEntry && ((PFPO_DATA)lpstkfrm->FuncTableEntry)->cbFrame != FRAME_NONFPO) {

            rVal = WalkX86_Fpo_NonFpo( hProcess,
                                     hThread,
                                     pFpoData,
                                     lpstkfrm,
                                     ReadMemory,
                                     FunctionTableAccess,
                                     GetModuleBase,
                                     TranslateAddress
                                   );

        } else {

            rVal = WalkX86_NonFpo_NonFpo( hProcess,
                                        hThread,
                                        pFpoData,
                                        lpstkfrm,
                                        ReadMemory,
                                        FunctionTableAccess,
                                        GetModuleBase,
                                        TranslateAddress
                                      );

        }
    }

exit:
    lpstkfrm->AddrFrame.Mode = lpstkfrm->AddrPC.Mode;
    lpstkfrm->AddrReturn.Mode = lpstkfrm->AddrPC.Mode;

    GetFunctionParameters( hProcess, hThread, lpstkfrm,
                           ReadMemory, GetModuleBase, TranslateAddress );

    GetReturnAddress( hProcess, hThread, lpstkfrm,
                      ReadMemory, GetModuleBase, TranslateAddress );

    return rVal;
}

BOOL
WalkX86Init(
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME64                    lpstkfrm,
    PREAD_PROCESS_MEMORY_ROUTINE64    ReadMemory,
    PFUNCTION_TABLE_ACCESS_ROUTINE64  FunctionTableAccess,
    PGET_MODULE_BASE_ROUTINE64        GetModuleBase,
    PTRANSLATE_ADDRESS_ROUTINE64      TranslateAddress
    )
{
    UCHAR               code[3];
    DWORD               stack[FRAME_SIZE*4];
    PFPO_DATA           pFpoData = NULL;
    ULONG               cb;

    lpstkfrm->Virtual = TRUE;
    lpstkfrm->Reserved[0] =
    lpstkfrm->Reserved[1] =
    lpstkfrm->Reserved[2] = 0;
    lpstkfrm->AddrReturn = lpstkfrm->AddrPC;

    if (lpstkfrm->AddrPC.Mode != AddrModeFlat) {
        goto exit;
    }

    lpstkfrm->FuncTableEntry = pFpoData = (PFPO_DATA)
        FunctionTableAccess(hProcess, lpstkfrm->AddrPC.Offset);

    if (pFpoData && pFpoData->cbFrame != FRAME_NONFPO) {

        GetFpoFrameBase( hProcess,
                         lpstkfrm,
                         pFpoData,
                         TRUE,
                         ReadMemory,
                         GetModuleBase );

    } else {

        //
        // this code determines whether eip is in the function prolog
        //
        if (!DoMemoryRead( &lpstkfrm->AddrPC, code, 3, &cb )) {
            //
            // assume a call to a bad address if the memory read fails
            //
            code[0] = PUSHBP;
        }
        if ((code[0] == PUSHBP) || (*(LPWORD)&code[0] == MOVBPSP)) {
            SAVE_EBP(lpstkfrm) = lpstkfrm->AddrFrame.Offset;
            lpstkfrm->AddrFrame.Offset = lpstkfrm->AddrStack.Offset;
            if (lpstkfrm->AddrPC.Mode != AddrModeFlat) {
                lpstkfrm->AddrFrame.Offset &= 0xffff;
            }
            if (code[0] == PUSHBP) {
                if (lpstkfrm->AddrPC.Mode == AddrModeFlat) {
                    lpstkfrm->AddrFrame.Offset -= STACK_SIZE;
                } else {
                    lpstkfrm->AddrFrame.Offset -= STACK_SIZE16;
                }
            }
        } else {
            //
            // read the first 2 dwords off the stack
            //
            if (DoMemoryRead( &lpstkfrm->AddrFrame, stack, FRAME_SIZE, &cb )) {

                SAVE_EBP(lpstkfrm) = (ULONG64)(LONG64)(LONG)stack[0];

            }

            if (lpstkfrm->AddrPC.Mode != AddrModeFlat) {
                lpstkfrm->AddrFrame.Offset &= 0x0000FFFF;
            }
        }

    }

exit:
    lpstkfrm->AddrFrame.Mode = lpstkfrm->AddrPC.Mode;

    GetFunctionParameters( hProcess, hThread, lpstkfrm,
                           ReadMemory, GetModuleBase, TranslateAddress );

    GetReturnAddress( hProcess, hThread, lpstkfrm,
                      ReadMemory, GetModuleBase, TranslateAddress );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\api.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    api.h

Abstract:

    This header file is used to cause the correct machine/platform specific
    data structures to be used when compiling for a non-hosted platform.

Author:

    Wesley Witt (wesw) 2-Aug-1993

Environment:

    User Mode

--*/



#undef i386
#undef _X86_
#undef MIPS
#undef _MIPS_
#undef ALPHA
#undef _ALPHA_
#undef PPC
#undef _PPC_

//
// Get rid of as much of Windows as possible
//

#define  NOGDICAPMASKS
#define  NOVIRTUALKEYCODES
#define  NOWINMESSAGES
#define  NOWINSTYLES
#define  NOSYSMETRICS
#define  NOMENUS
#define  NOICONS
#define  NOKEYSTATES
#define  NOSYSCOMMANDS
#define  NORASTEROPS
#define  NOSHOWWINDOW
#define  OEMRESOURCE
#define  NOATOM
#define  NOCLIPBOARD
#define  NOCOLOR
#define  NOCTLMGR
#define  NODRAWTEXT
#define  NOGDI
#define  NOKERNEL
#define  NOUSER
#define  NOMB
#define  NOMEMMGR
#define  NOMETAFILE
#define  NOMINMAX
#define  NOMSG
#define  NOOPENFILE
#define  NOSCROLL
#define  NOSERVICE
#define  NOSOUND
#define  NOTEXTMETRIC
#define  NOWH
#define  NOWINOFFSETS
#define  NOCOMM
#define  NOKANJI
#define  NOHELP
#define  NOPROFILER
#define  NODEFERWINDOWPOS

#define ADDRESS_NOT_VALID 0
#define ADDRESS_VALID 1
#define ADDRESS_TRANSITION 2


//-----------------------------------------------------------------------------------------
//
// intel x86
//
//-----------------------------------------------------------------------------------------
#if defined(TARGET_i386)

#pragma message( "Compiling for target = x86" )

#define EXR_ADDRESS_BIAS 0

#define _X86_

#if defined(HOST_MIPS)
#define MIPS
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntos.h>
#include <ntdbg.h>
#include <iop.h>
#include <windows.h>
#include <dbghelp.h>
#include <wdbgexts.h>
#include <stdlib.h>
#include <string.h>

#if defined(HOST_MIPS)
#undef MIPS
#undef R4000
#undef R3000
#endif
#define i386

#ifdef POOL_TAGGING
#undef ExAllocatePool
#undef ExAllocatePoolWithQuota
#endif

#ifndef __cplusplus
#include <mi.h>
#endif

#ifdef POOL_TAGGING
#undef ExAllocatePool
#undef ExAllocatePoolWithQuota
#endif

#undef i386
#if defined(HOST_MIPS)
#define R4000
#define R3000
#define MIPS
#endif

#if defined(HOST_MIPS)
#undef _cdecl
#define _cdecl
#endif

#if defined(HOST_ALPHA)
#undef _cdecl
#define _cdecl
#endif

#if defined(HOST_PPC)
#undef _cdecl
#define _cdecl
#endif

#if !defined(HOST_i386)
#undef _X86_
#endif

#else

//-----------------------------------------------------------------------------------------
//
// unknown platform
//
//-----------------------------------------------------------------------------------------
#error "Unsupported target CPU"

#endif


//-----------------------------------------------------------------------------------------
//
//  api declaration macros & api access macros
//
//-----------------------------------------------------------------------------------------

extern WINDBG_EXTENSION_APIS ExtensionApis;

#define KD_OBJECT_HEADER_TO_NAME_INFO( roh, loh ) (POBJECT_HEADER_NAME_INFO) \
    (((loh)->Flags & OB_FLAG_NAMED_OBJECT) ? OBJECT_HEADER_TO_OBJECT_HEADER_NAME_INFO(roh) : NULL)

//-----------------------------------------------------------------------------------------
//
//  prototypes for internal non-exported support functions
//
//-----------------------------------------------------------------------------------------

//
// get data from DebuggerData or GetExpression as appropriate
//

char ___SillyString[];
#ifdef __cplusplus
extern "C"
#endif
KDDEBUGGER_DATA32 KdDebuggerData;

#define GetNtDebuggerData(NAME)                                    \
    (HaveDebuggerData()?                                           \
        ( ( (KdDebuggerData.Header.OwnerTag = KDBG_TAG),           \
            (KdDebuggerData.Header.Size = sizeof(KdDebuggerData)), \
            Ioctl( IG_GET_DEBUGGER_DATA, &KdDebuggerData, sizeof(KdDebuggerData))),  \
        (ULONG) KdDebuggerData.NAME)                               \
        :                                                          \
        GetExpression( (strcpy(___SillyString, #NAME), ___SillyString) ))


#define GetNtDebuggerDataValue(NAME)                                   \
    (HaveDebuggerData()?                                               \
        GetUlongFromAddress(                                           \
          (((KdDebuggerData.Header.OwnerTag = KDBG_TAG),                \
           (KdDebuggerData.Header.Size = sizeof(KdDebuggerData)),      \
           Ioctl( IG_GET_DEBUGGER_DATA, &KdDebuggerData, sizeof(KdDebuggerData))),  \
        (ULONG)KdDebuggerData.NAME))                                   \
        :                                                              \
        GetUlongValue( (strcpy(___SillyString, #NAME), ___SillyString) ))

BOOL
HaveDebuggerData(
    VOID
    );

BOOL
ReadPcr(
    USHORT  Processor,
    PVOID   Pcr,
    PULONG  AddressOfPcr,
    HANDLE  hThread
    );

ULONG
GetUlongFromAddress (
    ULONG Location
    );

ULONG
GetUlongValue (
    PCHAR String
    );

#ifndef __cplusplus
ULONG
MiGetFrameFromPte (
    PMMPTE lpte
    );
#endif

#define move(dst, src)\
try {\
    ReadMemory((DWORD) (src), &(dst), sizeof(dst), NULL);\
} except (EXCEPTION_EXECUTE_HANDLER) {\
    return;\
}

#define moveBlock(dst, src, size)\
try {\
    ReadMemory((DWORD) (src), &(dst), (size), NULL);\
} except (EXCEPTION_EXECUTE_HANDLER) {\
    return;\
}


#define _KB (PAGE_SIZE/1024)


//
//  Read remote memory to local space, saving the remote pointer
//

__inline BOOLEAN
ReadAtAddress(
    PVOID RemoteAddress,
    PVOID LocalAddress,
    ULONG ObjectSize,
    PVOID *SavedRemoteAddress OPTIONAL
    )
{
    ULONG _r;
    PVOID Temp;

    Temp = RemoteAddress;

    if (!ReadMemory( (ULONG)RemoteAddress, LocalAddress, ObjectSize, &_r ) || (_r < ObjectSize)) {

        dprintf("Can't Read Memory at %08lx\n", RemoteAddress);
        return FALSE;
    }

    if (SavedRemoteAddress) {

        *SavedRemoteAddress = Temp;
    }

    return TRUE;
}

//
//  Splay helpers similar to the regular RTL
//

#define DbgRtlParent(Links) (           \
    (PRTL_SPLAY_LINKS)(Links).Parent \
    )

#define DbgRtlLeftChild(Links) (           \
    (PRTL_SPLAY_LINKS)(Links).LeftChild \
    )

#define DbgRtlRightChild(Links) (           \
    (PRTL_SPLAY_LINKS)(Links).RightChild \
    )

__inline BOOLEAN
DbgRtlIsRightChild(
    RTL_SPLAY_LINKS Links,
    PRTL_SPLAY_LINKS pLinks,
    PRTL_SPLAY_LINKS Parent
    )
{
    if (DbgRtlParent(Links) == pLinks) {

        return FALSE;
    }

    if (!ReadAtAddress(DbgRtlParent(Links), Parent, sizeof(RTL_SPLAY_LINKS), NULL)) {

        return FALSE;
    }

    if (DbgRtlRightChild(*Parent) == pLinks) {

        return TRUE;
    }

    return FALSE;
}

__inline BOOLEAN
DbgRtlIsLeftChild(
    RTL_SPLAY_LINKS Links,
    PRTL_SPLAY_LINKS pLinks,
    PRTL_SPLAY_LINKS Parent
    )
{
    if (DbgRtlParent(Links) == pLinks) {

        return FALSE;
    }

    if (!ReadAtAddress(DbgRtlParent(Links), Parent, sizeof(RTL_SPLAY_LINKS), NULL)) {

        return FALSE;
    }

    if (DbgRtlLeftChild(*Parent) == pLinks) {

        return TRUE;
    }

    return FALSE;
}

/////////////////////////////////////////////
//
//  KdExts.c
//
/////////////////////////////////////////////
BOOLEAN
IsCheckedBuild(
    PBOOLEAN Checked
    );

/////////////////////////////////////////////
//
//  Cxr.c
//
/////////////////////////////////////////////
VOID
DumpCxr(
    PCONTEXT Context
    );


/////////////////////////////////////////////
//
//  CritSec.c
//
/////////////////////////////////////////////

PLIST_ENTRY
DumpCritSec(
    HANDLE  hCurrentProcess,
    DWORD   dwAddrCritSec,
    BOOLEAN bDumpIfUnowned
    );



/////////////////////////////////////////////
//
//  Device.c
//
/////////////////////////////////////////////

VOID
DumpDevice(
    PVOID DeviceAddress,
    ULONG FieldWidth,
    BOOLEAN FullDetail
    );

/////////////////////////////////////////////
//
// Devnode.c
//
/////////////////////////////////////////////

typedef struct _FLAG_NAME {
    ULONG Flag;
    PUCHAR Name;
} FLAG_NAME, *PFLAG_NAME;

VOID
DumpFlags(
         ULONG Depth,
         LPSTR FlagDescription,
         ULONG Flags,
         PFLAG_NAME FlagTable
         );

VOID
xdprintf(
        ULONG  Depth,
        PCCHAR S,
        ...
        );

BOOLEAN
xReadMemory (
            PVOID S,
            PVOID D,
            ULONG Len
            );

/////////////////////////////////////////////
//
//  Driver.c
//
/////////////////////////////////////////////

VOID
DumpDriver(
    PVOID DriverAddress,
    ULONG FieldWidth,
    ULONG Flags
    );

/////////////////////////////////////////////
//
//  Help.c
//
/////////////////////////////////////////////

VOID
SpecificHelp (
    VOID
    );



/////////////////////////////////////////////
//
//  Locks.c
//
/////////////////////////////////////////////

VOID
DumpStaticFastMutex (
    IN PCHAR Name
    );

/////////////////////////////////////////////
//
//  Memory.c
//
/////////////////////////////////////////////
#ifndef __cplusplus
VOID
MemoryUsage (
    IN PMMPFN PfnArray,
    IN ULONG LowPage,
    IN ULONG HighPage,
    IN ULONG IgnoreInvalidFrames
    );

/////////////////////////////////////////////
//
//  Mi.c
//
/////////////////////////////////////////////

ULONG
MiGetFrameFromPte (
    IN PMMPTE lpte
    );

ULONG
MiGetFreeCountFromPteList (
    IN PMMPTE Pte
    );

ULONG
MiGetNextFromPteList (
    IN PMMPTE Pte
    );

ULONG
MiGetPageFromPteList (
    IN ULONG Pte
    );

PMMPTE
DbgGetPdeAddress(
    IN PVOID VirtualAddress
    );

PMMPTE
DbgGetPteAddress(
    IN PVOID VirtualAddress
    );

PVOID
DbgGetVirtualAddressMappedByPte(
    IN PMMPTE Pte
    );

ULONG
DbgGetPteSize(
    VOID
    );
#endif
/////////////////////////////////////////////
//
//  Registry.c
//
/////////////////////////////////////////////
USHORT
GetKcbName(
    DWORD KcbAddr,
    PWCHAR NameBuffer,
    ULONG  BufferSize
);


/////////////////////////////////////////////
//
//  Object.c
//
/////////////////////////////////////////////
#if defined( __cplusplus )
extern "C" {
#endif
extern ULONG EXPRLastDump;
#if defined( __cplusplus )
}
#endif

typedef BOOLEAN (*ENUM_TYPE_ROUTINE)(
    IN PVOID            pObjectHeader,
    IN POBJECT_HEADER   ObjectHeader,
    IN PVOID            Parameter
    );

//
// Object Table Entry Structure
//
typedef struct _OBJECT_TABLE_ENTRY {
    ULONG       NonPagedObjectHeader;
    ACCESS_MASK GrantedAccess;
} OBJECT_TABLE_ENTRY, *POBJECT_TABLE_ENTRY;
#define LOG_OBJECT_TABLE_ENTRY_SIZE 1

BOOLEAN
FetchObjectManagerVariables(
    BOOLEAN ForceReload
    );

PVOID
FindObjectByName(
    IN PUCHAR Path,
    IN PVOID RootObject
    );

POBJECT_TYPE
FindObjectType(
    IN PUCHAR TypeName
    );

BOOLEAN
DumpObject(
    IN char     *Pad,
    IN PVOID    Object,
    IN POBJECT_HEADER OptObjectHeader OPTIONAL,
    IN ULONG    Flags
    );

BOOLEAN
WalkObjectsByType(
    IN PUCHAR               ObjectTypeName,
    IN ENUM_TYPE_ROUTINE    EnumRoutine,
    IN PVOID                Parameter
    );

BOOLEAN
CaptureObjectName(
    IN PVOID            pObjectHeader,
    IN POBJECT_HEADER   ObjectHeader,
    IN PWSTR            Buffer,
    IN ULONG            BufferSize
    );

VOID
DumpObjectName(
   PVOID ObjectAddress
   );


/////////////////////////////////////////////
//
//  Process.c
//
/////////////////////////////////////////////

extern UCHAR *WaitReasonList[];

PVOID
GetCurrentProcessAddress(
    DWORD    Processor,
    HANDLE hCurrentThread,
    PETHREAD CurrentThread
    );

PVOID
GetCurrentThreadAddress(
    USHORT Processor,
    HANDLE hCurrentThread
    );

BOOL
DumpProcess (
    IN char * pad,
    IN PKPROCESS ProcessContents,
    IN PKPROCESS RealProcessBase,
    IN ULONG Flags,
    IN PCHAR ImageFileName
    );

BOOL
DumpThread (
    IN ULONG Processor,
    IN char *Pad,
    IN PETHREAD Thread,
    IN PETHREAD RealThreadBase,
    IN ULONG Flags
    );

VOID
dumpSymbolicAddress(
    ULONG Address,
    PUCHAR Buffer,
    BOOL AlwaysShowHex
    );

BOOLEAN
FetchProcessStructureVariables(
    VOID
    );

PVOID
LookupUniqueId(
    HANDLE UniqueId
    );

ULONG
GetAddressState(
    IN PVOID VirtualAddress
    );

typedef struct _PROCESS_COMMIT_USAGE {
    UCHAR ImageFileName[ 16 ];
    ULONG CommitCharge;
    ULONG NumberOfPrivatePages;
    ULONG NumberOfLockedPages;
} PROCESS_COMMIT_USAGE, *PPROCESS_COMMIT_USAGE;

PPROCESS_COMMIT_USAGE
GetProcessCommit (
    PULONG TotalCommitCharge,
    PULONG NumberOfProcesses
    );



/////////////////////////////////////////////
//
//  Util.c
//
/////////////////////////////////////////////

VOID
DumpImageName(
    IN PKPROCESS ProcessContents
    );

typedef VOID
(*PDUMP_SPLAY_NODE_FN)(
    PVOID RemoteAddress,
    ULONG Level
    );

ULONG
DumpSplayTree(
    IN PVOID pSplayLinks,
    IN PDUMP_SPLAY_NODE_FN DumpNodeFn
    );

VOID
DumpUnicode(
    UNICODE_STRING u
    );

BOOLEAN
IsHexNumber(
   const char *szExpression
   );

BOOLEAN
IsDecNumber(
   const char *szExpression
   );

#ifndef __cplusplus
typedef 
BOOLEAN 
(WINAPI *POOLFILTER) (
    PCHAR Tag,
    PCHAR Filter,
    ULONG Flags,
    PPOOL_HEADER PoolHeader,
    ULONG BlockSize,
    PVOID Data,
    PVOID Context
    );


void SearchPool(
    ULONG TagName,
    ULONG RestartAddr,
    POOLFILTER Filter,
    PVOID Context 
    );

BOOLEAN
CheckSingleFilter (
    PCHAR Tag,
    PCHAR Filter
    );
#endif

/////////////////////////////////////////////
//
//  Exsup.c
//
/////////////////////////////////////////////

VOID
InterpretExceptionData(
    PLAST_EXCEPTION_LOG LogRecord,
    PVOID *Terminator,
    PVOID *Filter,
    PVOID *Handler
    );



//
// Miscellaneous includes for semi-private NT definitions
//

#include <heap.h>
#include <pool.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\dlls.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dlls.c

Abstract:

    WinDbg Extension Api

Author:

    Ramon J San Andres (ramonsa) 5-Nov-1993

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

VOID
DllsExtension(
    PCSTR lpArgumentString,
    PPEB ProcessPeb
    );


DECLARE_API( dlls )

/*++

Routine Description:

    Dump user mode dlls (Kernel debugging)

Arguments:

    args - [address [detail]]

Return Value:

    None

--*/

{
    PVOID Process;
    EPROCESS ProcessContents;
    PEB ThePeb;

    Process = GetCurrentProcessAddress( dwProcessor, hCurrentThread, NULL );

    if ( !ReadMemory( (DWORD)Process,
                      &ProcessContents,
                      sizeof(EPROCESS),
                      NULL) ) {
        dprintf("%08lx: Unable to read _EPROCESS\n", Process );
        memset( &ThePeb, 0, sizeof( ThePeb ) );
        }
    else
    if ( !ReadMemory( (DWORD)ProcessContents.Peb,
                      &ThePeb,
                      sizeof(ThePeb),
                      NULL) ) {
        dprintf("    Unabled to read Process PEB\n" );
        memset( &ThePeb, 0, sizeof( ThePeb ) );
        }

    DllsExtension( args, &ThePeb );
}

#include "..\\ntsdexts\\dllsext.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\common.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    common.inc

Abstract:

    This is an include file for makefile.inc in each of the
    directories which has c files that are wrappers for the
    files in this directory.  The WRAPPEDCOBJECTS macro contains
    a list of the objects which are dependent on the files
    in this directory.

    SRCDIR must be defined in each makefile.inc, and will
    always point to the directory that this file is in.


Author:

    Wesley Witt (wesw) 10-Aug-1993

!ENDIF


WRAPPEDCOBJECTS =      \
    obj\*\calldata.obj \
    obj\*\crt.obj      \
    obj\*\device.obj   \
    obj\*\driver.obj   \
    obj\*\errorlog.obj \
    obj\*\exceptn.obj  \
    obj\*\filelock.obj \
    obj\*\filecach.obj \
    obj\*\gflag.obj    \
    obj\*\handle.obj   \
    obj\*\heap.obj     \
    obj\*\help.obj     \
    obj\*\igrep.obj    \
    obj\*\iospace.obj  \
    obj\*\locks.obj    \
    obj\*\lookasid.obj \
    obj\*\lpc.obj      \
    obj\*\memory.obj   \
    obj\*\object.obj   \
    obj\*\physical.obj \
    obj\*\pool.obj     \
    obj\*\process.obj  \
    obj\*\pte.obj      \
    obj\*\ptov.obj     \
    obj\*\ready.obj    \
    obj\*\registry.obj \
    obj\*\srb.obj      \
    obj\*\time.obj     \
    obj\*\token.obj    \
    obj\*\tunnel.obj   \
    obj\*\util.obj     \
    obj\*\vad.obj      \
    obj\*\wsle.obj     \
    obj\*\kdexts.obj

$(WRAPPEDCOBJECTS:*=i386):  $(SRCDIR)\$$(@B).c
$(WRAPPEDCOBJECTS:*=mips):  $(SRCDIR)\$$(@B).c
$(WRAPPEDCOBJECTS:*=ppc):  $(SRCDIR)\$$(@B).c
$(WRAPPEDCOBJECTS:*=alpha): $(SRCDIR)\$$(@B).c

..\atom.c: ..\..\ntsdexts\atomext.c

..\kuser.c: ..\..\ntsdexts\kuserext.c

..\peb.c: ..\..\ntsdexts\pebext.c

..\gflag.c: ..\..\ntsdexts\gflagext.c

..\heap.c: ..\..\ntsdexts\heapext.c

..\trace.c: ..\..\ntsdexts\traceext.c

..\dlls.c: ..\..\ntsdexts\dllsext.c

..\image.c: ..\..\ntsdexts\imageext.c

..\kdexts.c: $(BASEDIR)\public\sdk\inc\ntverp.h

help.c: ..\help.c

pte.c: ..\pte.c

obj\$(TARGET_DIRECTORY)\$(TARGETNAME).def: ..\kdextdef.src $(TARGETNAME).def
    copy ..\kdextdef.src+$(TARGETNAME).def obj\$(TARGET_DIRECTORY)\$(TARGETNAME).def
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\device.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    device.c

Abstract:

    WinDbg Extension Api

Author:

    Wesley Witt (wesw) 15-Aug-1993

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

#define FLAG_NAME(flag)           {flag, #flag}

DECLARE_API( devobj )

/*++

Routine Description:

    Dump a device object.

Arguments:

    args - the location of the device object to dump.

Return Value:

    None

--*/

{
    ULONG deviceToDump ;
    char deviceExprBuf[256] ;
    char *deviceExpr ;

    //
    // !devobj DeviceAddress DumpLevel
    //    where DeviceAddress can be an expression or device name
    //    and DumpLevel is a hex mask
    //
    strcpy(deviceExprBuf, "\\Device\\") ;
    deviceExpr = deviceExprBuf+strlen(deviceExprBuf) ;
    deviceToDump = 0 ;

    strcpy(deviceExpr, args) ;
    //
    // sscanf(args, "%s %lx", deviceExpr, &Flags);
    //

    //
    // The debugger will treat C0000000 as a symbol first, then a number if
    // no match comes up. We sanely reverse this ordering.
    //
    if (IsHexNumber(deviceExpr)) {

        sscanf(deviceExpr, "%lx", &deviceToDump) ;

    } else if (deviceExpr[0] == '\\') {

        deviceToDump = (ULONG) FindObjectByName( deviceExpr, NULL);

    } else if (isalpha(deviceExpr[0])) {

        //
        // Perhaps it's an object. Try with \\Device\\ prepended...
        //
        deviceToDump = (ULONG) FindObjectByName((PUCHAR) deviceExprBuf, NULL);
    }

    if (deviceToDump == 0) {

        //
        // Last try, is it an expression to evaluate?
        //
        deviceToDump = GetExpression( deviceExpr ) ;
    }


    if(deviceToDump == 0) {
        dprintf("Device object %s not found\n", args);
        return;
    }

    DumpDevice((PVOID) deviceToDump, 0, TRUE);
}


VOID
DumpDevice(
    PVOID DeviceAddress,
    ULONG FieldLength,
    BOOLEAN FullDetail
    )

/*++

Routine Description:

    Displays the driver name for the device object if FullDetail == FALSE.
    Otherwise displays more information about the device and the device queue.

Arguments:

    DeviceAddress - address of device object to dump.
    FieldLength   - Width of printf field for driver name (eg %11s).
    FullDetail    - TRUE means the device object name, driver name, and
                    information about Irps queued to the device.

Return Value:

    None

--*/

{
    ULONG                      result;
    ULONG                      i;
    DEVICE_OBJECT              deviceObject;
    PLIST_ENTRY                nextEntry;
    PVOID                      queueAddress;
    PIRP                       irp;
    KDEVICE_QUEUE_ENTRY        queueEntry;
    CHAR                       symbol[256];
    ULONG                      displacement;

    if ((!ReadMemory( (DWORD)DeviceAddress,
                     &deviceObject,
                     sizeof(deviceObject),
                     &result)) || (result < sizeof(deviceObject))) {
        dprintf("%08lx: Could not read device object\n", DeviceAddress);
        return;
    }

    if (deviceObject.Type != IO_TYPE_DEVICE) {
        dprintf("%08lx: is not a device object\n", DeviceAddress);
        return;
    }

    if (FullDetail == TRUE) {

        //
        // Dump the device name if present.
        //
        dprintf("Device object (%08lx) is for:\n ", DeviceAddress);

        DumpObjectName(DeviceAddress) ;
    }

    DumpDriver((PVOID) deviceObject.DriverObject, FieldLength, 0);

    if (FullDetail == TRUE) {
        //
        // Dump Irps related to driver.
        //

        GetSymbol((LPVOID)deviceObject.DriverObject,symbol,&displacement);

        dprintf(" DriverObject %08lx %s\n", deviceObject.DriverObject, symbol);

        dprintf("Current Irp %08lx RefCount %d Type %08lx Flags %08lx\n",
                deviceObject.CurrentIrp,
                deviceObject.ReferenceCount,
                deviceObject.DeviceType,
                deviceObject.Flags);

        if (deviceObject.MountedOrSelfDevice != DeviceAddress) {
            dprintf("Mounted %08lx ", deviceObject.MountedOrSelfDevice);
        }

        dprintf("DevExt %08lx\n", deviceObject.DeviceExtension);

        if (deviceObject.DeviceQueue.Busy) {

            ULONG listHead = (ULONG) DeviceAddress;

            listHead += FIELD_OFFSET(DEVICE_OBJECT, DeviceQueue.DeviceListHead);

            if ((ULONG) deviceObject.DeviceQueue.DeviceListHead.Flink == listHead) {
                dprintf("Device queue is busy -- Queue empty.\n");
            } else if (IsListEmpty(&deviceObject.DeviceQueue.DeviceListHead)) {
                dprintf("Device queue is busy -- Queue empty\n");
            } else if(deviceObject.DeviceQueue.DeviceListHead.Flink ==
                 deviceObject.DeviceQueue.DeviceListHead.Blink) {
                dprintf("Device queue is busy - Queue flink = blink\n");
            } else {
                dprintf("DeviceQueue: ");
                nextEntry = deviceObject.DeviceQueue.DeviceListHead.Flink;
                i = 0;

                while ((PCH) nextEntry != (PCH)
                    ((PCH) DeviceAddress +
                         ((PCH) &deviceObject.DeviceQueue.DeviceListHead.Flink -
                              (PCH) &deviceObject))) {
                    queueAddress = CONTAINING_RECORD(nextEntry,
                                                     KDEVICE_QUEUE_ENTRY,
                                                     DeviceListEntry);

                    if ((!ReadMemory((DWORD)queueAddress,
                                     &queueEntry,
                                     sizeof(queueEntry),
                                     &result)) || (result < sizeof(queueEntry))) {
                        dprintf("%08lx: Could not read queue entry\n", DeviceAddress);
                        return;
                    }

                    nextEntry = queueEntry.DeviceListEntry.Flink;

                    irp = CONTAINING_RECORD(queueAddress,
                                            IRP,
                                            Tail.Overlay.DeviceQueueEntry);

                    dprintf("%08lx%s",
                            irp,
                            (i & 0x03) == 0x03 ? "\n\t     " : " ");
                    if (CheckControlC()) {
                        break;
                    }
                }
                dprintf("\n");
            }
        } else {
            dprintf("Device queue is not busy.\n");
        }
    }
}

VOID
DumpObjectName(
   PVOID ObjectAddress
   )
{
   POBJECT_HEADER_NAME_INFO   pNameInfo;
   OBJECT_HEADER_NAME_INFO    NameInfo;
   PUCHAR                     buffer;
   OBJECT_STRING              objectString;
   ULONG                      result;

   pNameInfo = OBJECT_TO_OBJECT_HEADER_NAME_INFO(ObjectAddress);
   if (ReadMemory((DWORD)pNameInfo,
                  &NameInfo,
                  sizeof(NameInfo),
                  &result) && (result == sizeof(NameInfo))) {
       buffer = LocalAlloc(LPTR, NameInfo.Name.MaximumLength);
       if (buffer != NULL) {
           objectString.MaximumLength = NameInfo.Name.MaximumLength;
           objectString.Length = NameInfo.Name.Length;
           objectString.Buffer = (POSTR)buffer;
           if (ReadMemory((DWORD)NameInfo.Name.Buffer,
                          buffer,
                          objectString.Length,
                          &result) && (result == objectString.Length)) {
               dprintf("%Z", &objectString);
           }
           LocalFree(buffer);
       }
   }
}

VOID
DumpFlags(
    ULONG Depth,
    LPSTR FlagDescription,
    ULONG Flags,
    PFLAG_NAME FlagTable
    )
{
    ULONG i;
    ULONG mask = 0;
    ULONG count = 0;

    UCHAR prolog[64];

    sprintf(prolog, "%s (%#010x)  ", FlagDescription, Flags);

    xdprintf(Depth, "%s", prolog);

    if (Flags == 0) {
        dprintf("\n");
        return;
    }

    memset(prolog, ' ', strlen(prolog));

    for (i = 0; FlagTable[i].Name != 0; i++) {

        PFLAG_NAME flag = &(FlagTable[i]);

        mask |= flag->Flag;

        if ((Flags & flag->Flag) == flag->Flag) {

            //
            // print trailing comma
            //

            if (count != 0) {

                dprintf(", ");

                //
                // Only print two flags per line.
                //

                if ((count % 2) == 0) {
                    dprintf("\n");
                    xdprintf(Depth, "%s", prolog);
                }
            }

            dprintf("%s", flag->Name);

            count++;
        }
    }

    dprintf("\n");

    if ((Flags & (~mask)) != 0) {
        xdprintf(Depth, "%sUnknown flags %#010lx\n", prolog, (Flags & (~mask)));
    }

    return;
}


BOOLEAN
xReadMemory(
    PVOID S,
    PVOID D,
    ULONG Len
    )
{
    ULONG result;

    return (ReadMemory((DWORD)S, D, Len, &result) && (result == Len));
}

static CCHAR DebugBuffer[300];

VOID
xdprintf(
    ULONG  Depth,
    PCCHAR S,
    ...
    )
{
    va_list ap;
    ULONG   i;

    for (i=0; i<Depth; i++) {
        dprintf ("  ");
    }

    va_start(ap, S);

    vsprintf(DebugBuffer, S, ap);

    dprintf(DebugBuffer);

    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\crt.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    crt.c

Abstract:

    This file implements certain crt apis that are not present in
    libcntpr.lib. This implementation is NOT multi-thread safe.

Author:

    Wesley Witt (wesw) 6-Feb-1994

Environment:

    User Mode

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <time.h>
#include <stdio.h>


typedef VOID     (NTAPI *PRtlSecondsSince1970ToTime)(ULONG,PLARGE_INTEGER);
typedef NTSTATUS (NTAPI *PRtlSystemTimeToLocalTime)(PLARGE_INTEGER,PLARGE_INTEGER);
typedef VOID     (NTAPI *PRtlTimeToTimeFields)(PLARGE_INTEGER,PTIME_FIELDS);

HINSTANCE                  hModNtdll;
PRtlSecondsSince1970ToTime pRtlSecondsSince1970ToTime;
PRtlSystemTimeToLocalTime  pRtlSystemTimeToLocalTime;
PRtlTimeToTimeFields       pRtlTimeToTimeFields;


void * __cdecl
malloc(
    size_t sz
    )
{

    return LocalAlloc( LPTR, sz );

}

void __cdecl
free(
    void * ptr
    )
{

    LocalFree( ptr );

}

char * __cdecl
strtok(
    char * string,
    const char * control
    )
{
        unsigned char *str = string;
        const unsigned char *ctrl = control;

        unsigned char map[32];
        int count;
        char *token;

        static char *nextoken;


        /* Clear control map */
        for (count = 0; count < 32; count++)
                map[count] = 0;

        /* Set bits in delimiter table */
        do {
                map[*ctrl >> 3] |= (1 << (*ctrl & 7));
        } while (*ctrl++);

        /* If string==NULL, continue with previous string */
        if (!str) {
            str = nextoken;
        }

        /* Find beginning of token (skip over leading delimiters). Note that
         * there is no token iff this loop sets string to point to the terminal
         * null (*string == '\0') */
        while ( (map[*str >> 3] & (1 << (*str & 7))) && *str )
                str++;

        token = str;

        /* Find the end of the token. If it is not the end of the string,
         * put a null there. */
        for ( ; *str ; str++ )
                if ( map[*str >> 3] & (1 << (*str & 7)) ) {
                        *str++ = '\0';
                        break;
                }

        /* Update nextoken (or the corresponding field in the per-thread data
         * structure */

        nextoken = str;

        /* Determine if a token has been found. */
        if ( token == str )
                return NULL;
        else
                return token;
}


char * __cdecl
ctime(
    const time_t *timp
    )
{
    static char    mnames[] = { "JanFebMarAprMayJunJulAugSepOctNovDec" };
    static char    buf[32];

    LARGE_INTEGER  MyTime;
    TIME_FIELDS    TimeFields;



    if (!hModNtdll) {
        hModNtdll = GetModuleHandle( "ntdll.dll" );
        if (!hModNtdll) {
            sprintf( buf, "0x%08x", (ULONG)*timp );
            return buf;
        }
        pRtlSecondsSince1970ToTime = (PRtlSecondsSince1970ToTime)GetProcAddress( hModNtdll, "RtlSecondsSince1970ToTime" );
        pRtlSystemTimeToLocalTime  = (PRtlSystemTimeToLocalTime)GetProcAddress( hModNtdll, "RtlSystemTimeToLocalTime" );
        pRtlTimeToTimeFields       = (PRtlTimeToTimeFields)GetProcAddress( hModNtdll, "RtlTimeToTimeFields" );
    }
    if (pRtlSecondsSince1970ToTime == NULL ||
        pRtlSystemTimeToLocalTime  == NULL ||
        pRtlTimeToTimeFields       == NULL  ) {
        sprintf( buf, "0x%08x", (ULONG)*timp );
        return buf;
    }

    pRtlSecondsSince1970ToTime( (ULONG)*timp, &MyTime );
    pRtlSystemTimeToLocalTime( &MyTime, &MyTime );
    pRtlTimeToTimeFields( &MyTime, &TimeFields );

    strncpy( buf, &mnames[(TimeFields.Month - 1) * 3], 3 );
    sprintf( &buf[3], " %02d %02d:%02d:%02d %04d",
             TimeFields.Day, TimeFields.Hour, TimeFields.Minute,
             TimeFields.Second, TimeFields.Year );

    return buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\dbgprint.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dbgprint.c

Abstract:

    WinDbg Extension Api

Author:

    Wesley Witt (wesw) 15-Aug-1993

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

DECLARE_API( dbgprint )

/*++

Routine Description:

    This routine dumps the DbgPrint buffer.

Arguments:

    args - not used

Return Value:

    None

--*/

{
    ULONG BufferBase;
    ULONG BufferEnd;
    ULONG WritePointer;
    PUCHAR LocalBuffer;
    PUCHAR LocalBufferEnd;
    PUCHAR p;
    PUCHAR Start;
    ULONG result;



    BufferBase = GetNtDebuggerData( KdPrintCircularBuffer );
    BufferEnd = GetNtDebuggerData( KdPrintCircularBufferEnd );
    WritePointer = GetNtDebuggerDataValue( KdPrintWritePointer );

    if (!BufferBase || !BufferEnd || !WritePointer) {
        dprintf("Can't find DbgPrint buffer\n");
        goto exit;
    }

    LocalBuffer = LocalAlloc(LPTR, BufferEnd - BufferBase);

    if (!LocalBuffer) {
        dprintf("Could not allocate memory for local copy of DbgPrint buffer\n");
        goto exit;
    }

    if ((!ReadMemory(BufferBase,
                     LocalBuffer,
                     BufferEnd - BufferBase,
                     &result)) || (result < BufferEnd - BufferBase)) {
        dprintf("%08lx: Could not read DbgPrint buffer\n", BufferBase);
        goto exit;
    }

    LocalBufferEnd = LocalBuffer + BufferEnd - BufferBase;
    Start = LocalBuffer + (WritePointer - BufferBase);

    p = Start;
    do {
        //
        // consume NULs
        //
        while (p < LocalBufferEnd && *p == 0) {
            p++;
        }

        if (p < LocalBufferEnd) {
            //
            // print a string and consume it
            //
            dprintf("%s", p);
            while (p < LocalBufferEnd && *p != 0) {
                p++;
            }
        }
    } while (p < LocalBufferEnd);

    //
    // repeat until we hit the start
    //

    p = LocalBuffer;

    while (p < Start && *p == 0) {
        p++;
    }
    if (p < Start) {
        dprintf("%s", p);
        while (p < Start && *p != 0) {
            p++;
        }
    }

exit:
    if (LocalBuffer) {
        LocalFree( LocalBuffer );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\driver.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    driver.c

Abstract:

    WinDbg Extension Api

Author:

    Wesley Witt (wesw) 15-Aug-1993

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include <time.h>

DumpImage(
    ULONG Base,
    BOOL DoHeaders,
    BOOL DoSections
    );

PUCHAR DispatchRoutineTable[]=
{
    "IRP_MJ_CREATE",
    "IRP_MJ_CREATE_NAMED_PIPE",
    "IRP_MJ_CLOSE",
    "IRP_MJ_READ",
    "IRP_MJ_WRITE",
    "IRP_MJ_QUERY_INFORMATION",
    "IRP_MJ_SET_INFORMATION",
    "IRP_MJ_QUERY_EA",
    "IRP_MJ_SET_EA",
    "IRP_MJ_FLUSH_BUFFERS",
    "IRP_MJ_QUERY_VOLUME_INFORMATION",
    "IRP_MJ_SET_VOLUME_INFORMATION",
    "IRP_MJ_DIRECTORY_CONTROL",
    "IRP_MJ_FILE_SYSTEM_CONTROL",
    "IRP_MJ_DEVICE_CONTROL",
    "IRP_MJ_INTERNAL_DEVICE_CONTROL",
    "IRP_MJ_SHUTDOWN",
    "IRP_MJ_LOCK_CONTROL",
    "IRP_MJ_CLEANUP",
    "IRP_MJ_CREATE_MAILSLOT",
    "IRP_MJ_QUERY_SECURITY",
    "IRP_MJ_SET_SECURITY",
    "IRP_MJ_POWER",
    "IRP_MJ_SYSTEM_CONTROL",
    "IRP_MJ_DEVICE_CHANGE",
    "IRP_MJ_QUERY_QUOTA",
    "IRP_MJ_SET_QUOTA",
    "IRP_MJ_PNP",
    NULL
} ;

//
// Change this value and update the above table if IRP_MJ_MAXIMUM_FUNCTION
// is increased.
//
#define IRP_MJ_MAXIMUM_FUNCTION_HANDLED 0x1b

DECLARE_API( drvobj )

/*++

Routine Description:

    Dump a driver object.

Arguments:

    args - the location of the driver object to dump.

Return Value:

    None

--*/

{
    ULONG driverToDump;
    ULONG Flags;
    char driverExprBuf[256] ;
    char *driverExpr ;

    //
    // !drvobj DriverAddress DumpLevel
    //    where DriverAddress can be an expression or driver name
    //    and DumpLevel is a hex mask
    //
    strcpy(driverExprBuf, "\\Driver\\") ;
    driverExpr = driverExprBuf+strlen(driverExprBuf) ;
    Flags = 1;
    driverToDump = 0 ;

    sscanf(args, "%s %lx", driverExpr, &Flags);

    //
    // The debugger will treat C0000000 as a symbol first, then a number if
    // no match comes up. We sanely reverse this ordering.
    //
    if (IsHexNumber(driverExpr)) {

        sscanf(driverExpr, "%lx", &driverToDump) ;

    } else if (driverExpr[0] == '\\') {

        driverToDump = (ULONG) FindObjectByName( driverExpr, NULL);
    
    } else if (isalpha(driverExpr[0])) {

        //
        // Perhaps it's an object. Try with \\Driver\\ prepended...
        // 
        driverToDump = (ULONG) FindObjectByName((PUCHAR) driverExprBuf, NULL);
    }
                      
    if (driverToDump == 0) {
           
        //
        // Last try, is it an expression to evaluate?
        //
        driverToDump = GetExpression( driverExpr ) ;
    }

    if(driverToDump == 0) {
        dprintf("Driver object %s not found\n", args);
        return;
    }

    dprintf("Driver object (%08lx) is for:\n", driverToDump);
    DumpDriver((PVOID) driverToDump, 0, Flags);
}

VOID
DumpDriver(
    PVOID DriverAddress,
    ULONG FieldWidth,
    ULONG Flags
    )

/*++

Routine Description:

    Displays the driver name and the list of device objects created by
    the driver.

Arguments:

    DriverAddress - addres of the driver object to dump.
    FieldWidth    - Width of printf field (eg %11s) for driver name. 
                    Use 0 for full display.
    Flags         - Bit 0, Dump out device objects owned by driver
                    Bit 1, Dump out dispatch routines for driver

Return Value:

    None

--*/

{
    DRIVER_OBJECT    driverObject;
    ULONG            result;
    ULONG            i,j;
    PUCHAR           buffer;
    PVOID            deviceAddress;
    DEVICE_OBJECT    deviceObject;
    UNICODE_STRING   unicodeString;
    ULONG            displacement;
    UCHAR            component[512];
    PUCHAR           *dispatchTableText ;
    LPVOID           *p;

    if ((!ReadMemory( (DWORD) DriverAddress,
                     &driverObject,
                     sizeof(driverObject),
                     &result)) || result < sizeof(driverObject)) {
        return;
    }

    if (Flags&0x2) {
           
        dprintf ("\nDispatch routines:\n");        
        dispatchTableText = DispatchRoutineTable ;
        for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION_HANDLED; i++) {
            
            GetSymbol((LPVOID)(driverObject.MajorFunction[i]), component, &displacement);
            
            //
            // Forms are:
            // [1b] IRP_MJ_PNP            C0000000  DispatchHandler+30
            // [1b] IRP_MJ_PNP            C0000000  DispatchHandler
            // [1b] ???                   C0000000  <either of above>  
            //
            if (*dispatchTableText) {
               dprintf("[%02x] %s", i, *dispatchTableText) ;
               j=strlen(*dispatchTableText) ;
            } else {
               dprintf("[%02x] ???") ;
               j=3 ;
            }

            while(j++<35) dprintf(" ") ;
            dprintf("%8.8x\t%s", driverObject.MajorFunction[i], component) ;
            
            if (displacement) {
          
                dprintf("+0x%x\n", displacement) ;
            } else {
     
                dprintf("\n") ;
            }  
            
            if (*dispatchTableText) {
               
                dispatchTableText++ ;
            }
        }
        dprintf("\n");
    }
}

UCHAR *PagedOut = {"Header Paged Out"};

DECLARE_API( drivers )

/*++

Routine Description:

    Displays physical memory usage by driver.

Arguments:

    None.

Return Value:

    None.

--*/

{
    LIST_ENTRY List;
    PLIST_ENTRY Next;
    ULONG ListHead;
    NTSTATUS Status = 0;
    ULONG Result;
    PLDR_DATA_TABLE_ENTRY DataTable;
    LDR_DATA_TABLE_ENTRY DataTableBuffer;
    WCHAR UnicodeBuffer[128];
    UNICODE_STRING BaseName;
    PIMAGE_NT_HEADERS NtHeader;
    PIMAGE_DOS_HEADER DosHeader;
    ULONG SizeOfData;
    ULONG SizeOfCode;
    ULONG SizeOfLocked;
    ULONG TotalCode = 0;
    ULONG TotalData = 0;
    ULONG TotalValid = 0;
    ULONG TotalTransition = 0;
    ULONG DosHeaderSize;
    ULONG TimeDateStamp;
    PUCHAR time;
    ULONG Flags;

    Flags = 0;
    sscanf(args,"%lx",&Flags);

    ListHead = GetNtDebuggerData( PsLoadedModuleList );

    if (!ListHead) {
        dprintf("Couldn't get offset of PsLoadedModuleListHead\n");
        return;
    } else {
        if ((!ReadMemory((DWORD)ListHead,
                         &List,
                         sizeof(LIST_ENTRY),
                         &Result)) || (Result < sizeof(LIST_ENTRY))) {
            dprintf("Unable to get value of PsLoadedModuleListHead\n");
            return;
        }
    }

    dprintf("Loaded System Driver Summary\n\n");
    if (Flags & 1) {
        dprintf("Base       Code Size       Data Size       Resident  Standby   Driver Name\n");
    } else if (Flags & 2) {
        dprintf("Base       Code  Data  Locked  Resident  Standby  Loader Entry  Driver Name\n");
    } else {
        dprintf("Base       Code Size       Data Size       Driver Name       Creation Time\n");
    }

    Next = List.Flink;
    if (Next == NULL) {
        dprintf("PsLoadedModuleList is NULL!\n");
        return;
    }

    while ((ULONG)Next != ListHead) {
        if (CheckControlC()) {
            return;
        }
        DataTable = CONTAINING_RECORD(Next,
                                      LDR_DATA_TABLE_ENTRY,
                                      InLoadOrderLinks);
        if ((!ReadMemory((DWORD)DataTable,
                         &DataTableBuffer,
                         sizeof(LDR_DATA_TABLE_ENTRY),
                         &Result)) || (Result < sizeof(LDR_DATA_TABLE_ENTRY))) {
            dprintf("Unable to read LDR_DATA_TABLE_ENTRY at %08lx - status %08lx\n",
                    DataTable,
                    Status);
            return;
        }

        //
        // Get the base DLL name.
        //
        if ((!ReadMemory((DWORD)DataTableBuffer.BaseDllName.Buffer,
                         UnicodeBuffer,
                         DataTableBuffer.BaseDllName.Length,
                         &Result)) || (Result < DataTableBuffer.BaseDllName.Length)) {
            dprintf("Unable to read name string at %08lx - status %08lx\n",
                    DataTable,
                    Status);
            return;
        }

        BaseName.Buffer = UnicodeBuffer;
        BaseName.Length = BaseName.MaximumLength = (USHORT)Result;

        DosHeader = (PIMAGE_DOS_HEADER)DataTableBuffer.DllBase;

        if ((!ReadMemory((DWORD)&DosHeader->e_lfanew,
                         &DosHeaderSize,
                         sizeof(ULONG),
                         &Result)) || (Result < sizeof(ULONG))) {
            //dprintf("Unable to read DosHeader at %08lx - status %08lx\n",
            //        &DosHeader->e_lfanew,
            //        Status);

            SizeOfCode = 0;
            SizeOfData = 0;
            SizeOfLocked = -1;
            time = PagedOut;
        } else {

            NtHeader = (PIMAGE_NT_HEADERS)((ULONG)DosHeader + DosHeaderSize);

            if ((!ReadMemory((DWORD)&(NtHeader->OptionalHeader.SizeOfCode),
                             &SizeOfCode,
                             sizeof(ULONG),
                             &Result)) || (Result < sizeof(ULONG))) {
                dprintf("Unable to read DosHeader at %08lx - status %08lx\n",
                        &(NtHeader->OptionalHeader.SizeOfCode),
                        Status);
                goto getnext;
            }

            if ((!ReadMemory((DWORD)&(NtHeader->OptionalHeader.SizeOfInitializedData),
                             &SizeOfData,
                             sizeof(ULONG),
                             &Result)) || (Result < sizeof(ULONG))) {
                dprintf("Unable to read DosHeader at %08lx - status %08lx\n",
                        &(NtHeader->OptionalHeader.SizeOfCode),
                        Status);
                goto getnext;
            }

            if ((!ReadMemory((DWORD)&(NtHeader->FileHeader.TimeDateStamp),
                             &TimeDateStamp,
                             sizeof(ULONG),
                             &Result)) || (Result < sizeof(ULONG))) {
                dprintf("Unable to read DosHeader at %08lx - status %08lx\n",
                        &(NtHeader->FileHeader.TimeDateStamp),
                        Status);
                goto getnext;
            }

            time = ctime((time_t *)&TimeDateStamp);
            time[strlen(time)-1] = 0;
        }

        if (Flags & 1) {
            PCHAR Va;
            PCHAR EndVa;
            ULONG States[3] = {0,0,0};

            Va = DataTableBuffer.DllBase;
            EndVa = Va + DataTableBuffer.SizeOfImage;

            while (Va < EndVa) {
                States[GetAddressState((PVOID)Va)] += PAGE_SIZE/1024;
                Va += PAGE_SIZE;
            }
            dprintf("%08lx %6lx (%4ld kb) %6lx (%4ld kb) (%5ld kb %5ld kb) %12wZ\n",
                     DataTableBuffer.DllBase,
                     SizeOfCode,
                     SizeOfCode / 1024,
                     SizeOfData,
                     SizeOfData / 1024,
                     States[ADDRESS_VALID],
                     States[ADDRESS_TRANSITION],
                     &BaseName);
            TotalValid += States[ADDRESS_VALID];
            TotalTransition += States[ADDRESS_TRANSITION];
        } else if (Flags & 2) {
            ULONG i;
            ULONG SizeToLock;
            PMMPTE PointerPte;
            PMMPTE LastPte;
            PVOID BaseAddress;
            PCHAR Va;
            PCHAR EndVa;
            ULONG States[3] = {0,0,0};
            PIMAGE_SECTION_HEADER NtSection;
            IMAGE_SECTION_HEADER NtSectionData;
            IMAGE_FILE_HEADER FileHeader;

            Va = DataTableBuffer.DllBase;
            EndVa = Va + DataTableBuffer.SizeOfImage;

            while (Va < EndVa) {
                States[GetAddressState((PVOID)Va)] += PAGE_SIZE/1024;
                Va += PAGE_SIZE;
            }

            SizeOfLocked = 0;

            //
            // Read the sections in the executable header to see which are
            // locked.  Don't bother looking for refcounted PFNs.
            //
        
            NtHeader = (PIMAGE_NT_HEADERS)((ULONG)DosHeader + DosHeaderSize);

            if ((!ReadMemory((DWORD)&(NtHeader->FileHeader),
                             &FileHeader,
                             sizeof(FileHeader),
                             &Result)) || (Result < sizeof(ULONG))) {
                dprintf("Unable to read FileHeader at %08lx - status %08lx\n",
                        &(NtHeader->FileHeader),
                        Status);
                goto getnext;
            }

            NtSection = (PIMAGE_SECTION_HEADER)((ULONG_PTR)NtHeader +
                                sizeof(ULONG) +
                                sizeof(IMAGE_FILE_HEADER) +
                                FileHeader.SizeOfOptionalHeader
                                );
        
            for (i = 0; i < FileHeader.NumberOfSections; i += 1) {
        
                if ((!ReadMemory((DWORD)NtSection,
                                 &NtSectionData,
                                 sizeof(NtSectionData),
                                 &Result)) || (Result < sizeof(ULONG))) {
                    dprintf("Unable to read NtSectionData at %08lx - status %08lx\n",
                            NtSection,
                            Status);
                    goto getnext;
                }

                if ((NtSectionData.NumberOfLinenumbers == 1) ||
                    (NtSectionData.NumberOfLinenumbers == 2)) {

                    BaseAddress = (PVOID)(NtSectionData.PointerToRelocations);
                    SizeToLock = NtSectionData.SizeOfRawData;
                    PointerPte = DbgGetPteAddress(BaseAddress);
                    LastPte = DbgGetPteAddress((PVOID)((PCHAR)BaseAddress + SizeToLock - 1));
                    SizeOfLocked += (LastPte - PointerPte + 1);
                }

                NtSection += 1;
            }

#if 0
        dprintf("Base       Code  Data  Locked  Resident  Standby  Loader Entry  Driver Name\n");
#endif

            dprintf("%08lx %6lx %6lx %6lx  %6lx   %6lx    %8lx      %12wZ\n",
                     DataTableBuffer.DllBase,
                     SizeOfCode,
                     SizeOfData,
                     SizeOfLocked,
                     States[ADDRESS_VALID],
                     States[ADDRESS_TRANSITION],
                     DataTable,
                     &BaseName);
            TotalValid += States[ADDRESS_VALID];
            TotalTransition += States[ADDRESS_TRANSITION];
        } else {
             dprintf("%08lx %6lx (%4ld kb) %5lx (%3ld kb) %12wZ  %s\n",
                      DataTableBuffer.DllBase,
                      SizeOfCode,
                      SizeOfCode / 1024,
                      SizeOfData,
                      SizeOfData / 1024,
                      &BaseName,
                      time);
        }

        if (Flags & 4) {
            DumpImage((ULONG)DataTableBuffer.DllBase,
                     (Flags & 2) == 2,
                     (Flags & 4) == 4
                     );
        }

        TotalCode += SizeOfCode;
        TotalData += SizeOfData;
getnext:
        Next = DataTableBuffer.InLoadOrderLinks.Flink;
    }

    dprintf("TOTAL:   %6lx (%4ld kb) %6lx (%4ld kb) (%5ld kb %5ld kb)\n",
            TotalCode,
            TotalCode / 1024,
            TotalData,
            TotalData / 1024,
            TotalValid,
            TotalTransition);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\exceptn.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    exceptn.c

Abstract:

    WinDbg Extension Api

Author:

    Wesley Witt (wesw) 15-Aug-1993

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

VOID
DumpExr(
    PEXCEPTION_RECORD Exr
    );

VOID
DumpCxr(
    PCONTEXT Context
    );

DECLARE_API( exr )

/*++

Routine Description:

    Dumps an exception record

Arguments:

    arg - Supplies the address in hex.

Return Value:

    None.

--*/

{
    ULONG Address;
    EXCEPTION_RECORD    Exr;
    NTSTATUS status=0;
    ULONG result;

    sscanf(args,"%lX",&Address);

    Address += EXR_ADDRESS_BIAS;            // non-zero for ppc

    if ((!ReadMemory((DWORD)Address,
                     (PVOID)&Exr,
                     sizeof(EXCEPTION_RECORD),
                     &result)) || (result < sizeof(EXCEPTION_RECORD))) {
        dprintf("unable to get exception record  - status %lx\n", status);
        return;
    }
    dprintf("Exception Record @ %08lX:\n", Address);
    DumpExr(&Exr);
}

DECLARE_API( exrlog )
{
    ULONG LogCount;
    ULONG Address;
    ULONG result;
    PLAST_EXCEPTION_LOG LogPointer;
    PLAST_EXCEPTION_LOG MaxLogRecord;
    LAST_EXCEPTION_LOG LogRecord;
    ULONG MaxExceptionLog;
    CHAR Buffer[256];
    ULONG displacement;
    PUCHAR s;
    PVOID Finally;
    PVOID Filter;
    PVOID Handler;

    Address = GetExpression( "nt!RtlpExceptionLogCount" );
    if (Address == 0) {
        dprintf("exrlog: No symbol for RtlpExceptionLogCount.\n");
        return;
    }
    if ((!ReadMemory(Address,
                     (PVOID)&LogCount,
                     sizeof(ULONG),
                     &result)) || (result < sizeof(ULONG))) {
        dprintf("exrlog: Unable to read log\n");
        return;
    }

    Address = GetExpression( "nt!RtlpExceptionLogSize" );
    if (Address == 0) {
        dprintf("exrlog: No symbol for RtlpExceptionSize.\n");
        return;
    }
    if ((!ReadMemory(Address,
                     (PVOID)&MaxExceptionLog,
                     sizeof(ULONG),
                     &result)) || (result < sizeof(ULONG))) {
        dprintf("exrlog: Unable to read log\n");
        return;
    }

    Address = GetExpression( "nt!RtlpExceptionLog" );
    if (Address == 0) {
        dprintf("exrlog: No symbol for RtlpExceptionLog.\n");
        return;
    }
    if ((!ReadMemory(Address,
                     (PVOID)&LogPointer,
                     sizeof(ULONG),
                     &result)) || (result < sizeof(ULONG))) {
        dprintf("exrlog: Unable to read log pointer\n");
        return;
    }

    if (LogPointer == 0 || MaxExceptionLog == 0) {
        dprintf("exrlog: Exception logging is not enabled.\n");
        return;
    }

    MaxLogRecord = LogPointer + MaxExceptionLog;
    LogPointer += LogCount;

    for (LogCount = 0; LogCount < MaxExceptionLog; LogCount++) {

        if ((!ReadMemory((ULONG)LogPointer,
                         (PVOID)&LogRecord,
                         sizeof(LogRecord),
                         &result)) || (result < sizeof(LogRecord))) {
            dprintf("exrlog: Unable to read log entry at %08x\n", LogPointer);
        }
        if (++LogPointer >= MaxLogRecord) {
            LogPointer -= MaxExceptionLog;
        }

        dprintf("\n% 2d: ----------------------------------\n", LogCount);

        DumpExr(&LogRecord.ExceptionRecord);

        dprintf("\n");

        InterpretExceptionData(&LogRecord, &Finally, &Filter, &Handler);

        GetSymbol(Filter, Buffer, &displacement);
        dprintf("Filter:  %08lx", Filter);
        if (*Buffer) {
            dprintf(" (%s+0x%x)\n", Buffer, displacement);
        } else {
            dprintf("\n");
        }

        GetSymbol(Handler, Buffer, &displacement);
        dprintf("Handler: %08lx", Handler);
        if (*Buffer) {
            dprintf(" (%s+0x%x)\n", Buffer, displacement);
        } else {
            dprintf("\n");
        }

        GetSymbol(Finally, Buffer, &displacement);
        dprintf("Finally: %08lx", Finally);
        if (*Buffer) {
            dprintf(" (%s+0x%x)\n", Buffer, displacement);
        } else {
            dprintf("\n");
        }

        switch( LogRecord.Disposition ) {
            case ExceptionContinueExecution:
                s = "ExceptionContinueExecution";
                break;

            case ExceptionContinueSearch:
                s = "ExceptionContinueSearch";
                break;

            case ExceptionNestedException:
                s = "ExceptionNestedException";
                break;

            case 0xffffffff:
                s = "Executed Handler";
                break;
        }
        dprintf("Disposition: %d (%s)\n\n", LogRecord.Disposition, s);

        DumpCxr(&LogRecord.ContextRecord);

    }


}

VOID
DumpExr(
    PEXCEPTION_RECORD Exr
    )
{
    ULONG   i;
    CHAR Buffer[256];
    ULONG displacement;

    GetSymbol((LPVOID)Exr->ExceptionAddress, Buffer, &displacement);

    if (*Buffer) {
        dprintf("ExceptionAddress: %08lx (%s+0x%x)\n",
                 Exr->ExceptionAddress,
                 Buffer,
                 displacement);
    } else {
        dprintf("ExceptionAddress: %08lx\n", Exr->ExceptionAddress);
    }
    dprintf("   ExceptionCode: %08lx\n", Exr->ExceptionCode);
    dprintf("  ExceptionFlags: %08lx\n", Exr->ExceptionFlags);

    dprintf("NumberParameters: %d\n", Exr->NumberParameters);
    if (Exr->NumberParameters > EXCEPTION_MAXIMUM_PARAMETERS) {
        Exr->NumberParameters = EXCEPTION_MAXIMUM_PARAMETERS;
    }
    for (i = 0; i < Exr->NumberParameters; i++) {
        dprintf("   Parameter[%d]: %08lx\n", i, Exr->ExceptionInformation[i]);
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\heap.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    heap.c

Abstract:

    WinDbg Extension Api

Author:

    Ramon J San Andres (ramonsa) 5-Nov-1993

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

VOID
HeapExtension(
    IN PCSTR lpArgumentString,
    IN ULONG_PTR SystemRangeStart
    );


DECLARE_API( heap )

/*++

Routine Description:

    Dump user mode heap (Kernel debugging)

    If an address if not given or an address of 0 is given, then the
    process heap is dumped.  If the address is -1, then all the heaps of
    the process are dumped.  If detail is specified, it defines how much
    detail is shown.  A detail of 0, just shows the summary information
    for each heap.  A detail of 1, shows the summary information, plus
    the location and size of all the committed and uncommitted regions.
    A detail of 3 shows the allocated and free blocks contained in each
    committed region.  A detail of 4 includes all of the above plus
    a dump of the free lists.

Arguments:

    args - [address [detail]]

Return Value:

    None

--*/

{
    HeapExtension( args, (ULONG_PTR)MM_SYSTEM_RANGE_START );
}

#include "..\\ntsdexts\\heapext.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\fscache.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    fscache.c

Abstract:

    WinDbg Extension Api

--*/

#include "precomp.h"
#pragma hdrstop
#include "fscache.h"

VOID
DumpFsCacheLruList()
{
    PLIST_ENTRY LruList;
    LIST_ENTRY LruListNode;
    ULONG result;
    PFSCACHE_ELEMENT Element;
    PLIST_ENTRY ListEntry;
    FSCACHE_ELEMENT ElementNode;
    FSCACHE_EXTENSION CacheExtension;

    LruList = (PLIST_ENTRY)GetNtDebuggerData(FscLruList);

    if (!ReadMemory((DWORD)LruList, &LruListNode, sizeof(LIST_ENTRY), &result)) {
        dprintf("cannot read FscLruList\n");
        return;
    }

    ListEntry = LruListNode.Blink;

    while (ListEntry != LruList) {

        Element = CONTAINING_RECORD(ListEntry, FSCACHE_ELEMENT, ListEntry);

        if (!ReadMemory((DWORD)Element, &ElementNode, sizeof(FSCACHE_ELEMENT), &result)) {
            dprintf("cannot read element %p\n", Element);
            return;
        }

        if (ElementNode.CacheExtension == NULL) {
            dprintf("%p:    free,     buffer=%p\n",
                Element,
                PAGE_ALIGN(ElementNode.CacheBuffer)
                );
        } else {
            dprintf("%p: %c%c usage=%02x, buffer=%p block=%08x ",
                Element,
                ElementNode.ReadInProgress ? 'R' : 'P',
                ElementNode.ReadWaiters ? 'W' : ' ',
                ElementNode.UsageCount,
                PAGE_ALIGN(ElementNode.CacheBuffer),
                ElementNode.BlockNumber);

            if (ReadMemory((DWORD)ElementNode.CacheExtension, &CacheExtension,
                sizeof(FSCACHE_EXTENSION), &result)) {
                DumpObjectName(CacheExtension.TargetDeviceObject);
            }
            dprintf("\n");
        }

        ListEntry = (PLIST_ENTRY)ElementNode.ListEntry.Blink;
    }
}


DECLARE_API(fscache)
{
    DumpFsCacheLruList();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\gflag.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    gflag.c

Abstract:

    WinDbg Extension Api

Author:

    Ramon J San Andres (ramonsa) 5-Nov-1993

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

VOID
GFlagExtension(
    IN PVOID pNtGlobalFlag,
    IN ULONG ValidBits,
    IN PCSTR lpArgumentString
    );


DECLARE_API( gflag )

/*++

Routine Description:

    see syntax in ..\ntsdexts\gflagext.c

Arguments:

Return Value:

    None

--*/

{
    dprintf( "NtGlobalFlag at %x\n", GetExpression("nt!NtGlobalFlag") );

    GFlagExtension( (PVOID)GetExpression("nt!NtGlobalFlag"), FLG_VALID_BITS, args );
}

#include "..\\ntsdexts\\gflagext.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\gentable.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    GenTable.c

Abstract:

    WinDbg Extension Api for walking RtlGenericTable structures
    Contains no direct ! entry points, but has makes it possible to
    enumerate through generic tables.  The standard Rtl functions
    cannot be used by debugger extensions because they dereference
    pointers to data on the machine being debugged.  The function
    KdEnumerateGenericTableWithoutSplaying implemented in this
    module can be used within kernel debugger extensions.  The
    enumeration function RtlEnumerateGenericTable has no parallel
    in this module, since splaying the tree is an intrusive operation,
    and debuggers should try not to be intrusive.

Author:

    Keith Kaplan [KeithKa]    09-May-96

Environment:

    User Mode.

Revision History:

--*/


PRTL_SPLAY_LINKS
KdParent (
    IN PRTL_SPLAY_LINKS pLinks
    );

PRTL_SPLAY_LINKS
KdLeftChild (
    IN PRTL_SPLAY_LINKS pLinks
    );

PRTL_SPLAY_LINKS
KdRightChild (
    IN PRTL_SPLAY_LINKS pLinks
    );

BOOLEAN
KdIsLeftChild (
    IN PRTL_SPLAY_LINKS Links
    );

BOOLEAN
KdIsRightChild (
    IN PRTL_SPLAY_LINKS Links
    );

BOOLEAN
KdIsGenericTableEmpty (
    IN PRTL_GENERIC_TABLE Table
    );

PRTL_SPLAY_LINKS
KdRealSuccessor (
    IN PRTL_SPLAY_LINKS Links
    );

PVOID
KdEnumerateGenericTableWithoutSplaying (
    IN PRTL_GENERIC_TABLE pTable,
    IN PVOID *RestartKey
    );



=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\gentable.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    GenTable.c

Abstract:

    WinDbg Extension Api for walking RtlGenericTable structures
    Contains no direct ! entry points, but has makes it possible to
    enumerate through generic tables.  The standard Rtl functions
    cannot be used by debugger extensions because they dereference
    pointers to data on the machine being debugged.  The function
    KdEnumerateGenericTableWithoutSplaying implemented in this
    module can be used within kernel debugger extensions.  The
    enumeration function RtlEnumerateGenericTable has no parallel
    in this module, since splaying the tree is an intrusive operation,
    and debuggers should try not to be intrusive.

Author:

    Keith Kaplan [KeithKa]    09-May-96

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop



PRTL_SPLAY_LINKS
KdParent (
    IN PRTL_SPLAY_LINKS pLinks
    )

/*++

Routine Description:

    Analogous to RtlParent macro, but works in the kernel debugger.
    The description of RtlParent follows:

    The macro function Parent takes as input a pointer to a splay link in a
    tree and returns a pointer to the splay link of the parent of the input
    node.  If the input node is the root of the tree the return value is
    equal to the input value.

Arguments:

    Links - Pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - Pointer to the splay link of the  parent of the input
                       node.  If the input node is the root of the tree the
                       return value is equal to the input value.

--*/

{
    ULONG Result;
    RTL_SPLAY_LINKS Links;

    if ( !ReadMemory( (DWORD) pLinks,
                      &Links,
                      sizeof( Links ),
                      &Result) ) {
        dprintf( "%08lx: Unable to read pLinks\n", pLinks );
        return NULL;
    }

    return Links.Parent;
}



PRTL_SPLAY_LINKS
KdLeftChild (
    IN PRTL_SPLAY_LINKS pLinks
    )

/*++

Routine Description:

    Analogous to RtlLeftChild macro, but works in the kernel debugger.
    The description of RtlLeftChild follows:

    The macro function LeftChild takes as input a pointer to a splay link in
    a tree and returns a pointer to the splay link of the left child of the
    input node.  If the left child does not exist, the return value is NULL.

Arguments:

    Links - Pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - Pointer to the splay link of the left child of the input node.
                       If the left child does not exist, the return value is NULL.

--*/

{
    ULONG Result;
    RTL_SPLAY_LINKS Links;

    if ( !ReadMemory( (DWORD) pLinks,
                      &Links,
                      sizeof( Links ),
                      &Result) ) {
        dprintf( "%08lx: Unable to read pLinks\n", pLinks );
        return NULL;
    }

    return Links.LeftChild;
}



PRTL_SPLAY_LINKS
KdRightChild (
    IN PRTL_SPLAY_LINKS pLinks
    )

/*++

Routine Description:

    Analogous to RtlRightChild macro, but works in the kernel debugger.
    The description of RtlRightChild follows:

    The macro function RightChild takes as input a pointer to a splay link
    in a tree and returns a pointer to the splay link of the right child of
    the input node.  If the right child does not exist, the return value is
    NULL.

Arguments:

    Links - Pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - Pointer to the splay link of the right child of the input node.
                       If the right child does not exist, the return value is NULL.

--*/

{
    ULONG Result;
    RTL_SPLAY_LINKS Links;

    if ( !ReadMemory( (DWORD) pLinks,
                      &Links,
                      sizeof( Links ),
                      &Result) ) {
        dprintf( "%08lx: Unable to read pLinks\n", pLinks );
        return NULL;
    }

    return Links.RightChild;
}



BOOLEAN
KdIsLeftChild (
    IN PRTL_SPLAY_LINKS Links
    )

/*++

Routine Description:

    Analogous to RtlIsLeftChild macro, but works in the kernel debugger.
    The description of RtlIsLeftChild follows:

    The macro function IsLeftChild takes as input a pointer to a splay link
    in a tree and returns TRUE if the input node is the left child of its
    parent, otherwise it returns FALSE.

Arguments:

    Links - Pointer to a splay link in a tree.

Return Value:

    BOOLEAN - TRUE if the input node is the left child of its parent,
              otherwise it returns FALSE.

--*/
{

    return (KdLeftChild(KdParent(Links)) == (PRTL_SPLAY_LINKS)(Links));

}



BOOLEAN
KdIsRightChild (
    IN PRTL_SPLAY_LINKS Links
    )

/*++

Routine Description:

    Analogous to RtlIsRightChild macro, but works in the kernel debugger.
    The description of RtlIsRightChild follows:

    The macro function IsRightChild takes as input a pointer to a splay link
    in a tree and returns TRUE if the input node is the right child of its
    parent, otherwise it returns FALSE.

Arguments:

    Links - Pointer to a splay link in a tree.

Return Value:

    BOOLEAN - TRUE if the input node is the right child of its parent,
              otherwise it returns FALSE.

--*/
{

    return (KdRightChild(KdParent(Links)) == (PRTL_SPLAY_LINKS)(Links));

}



BOOLEAN
KdIsGenericTableEmpty (
    IN PRTL_GENERIC_TABLE Table
    )

/*++

Routine Description:

    Analogous to RtlIsGenericTableEmpty, but works in the kernel debugger.
    The description of RtlIsGenericTableEmpty follows:

    The function IsGenericTableEmpty will return to the caller TRUE if
    the input table is empty (i.e., does not contain any elements) and
    FALSE otherwise.

Arguments:

    Table - Supplies a pointer to the Generic Table.

Return Value:

    BOOLEAN - if enabled the tree is empty.

--*/

{

    //
    // Table is empty if the root pointer is null.
    //

    return ((Table->TableRoot)?(FALSE):(TRUE));

}



PRTL_SPLAY_LINKS
KdRealSuccessor (
    IN PRTL_SPLAY_LINKS Links
    )

/*++

Routine Description:

    Analogous to RtlRealSuccessor, but works in the kernel debugger.
    The description of RtlRealSuccessor follows:

    The RealSuccessor function takes as input a pointer to a splay link
    in a tree and returns a pointer to the successor of the input node within
    the entire tree.  If there is not a successor, the return value is NULL.

Arguments:

    Links - Supplies a pointer to a splay link in a tree.

Return Value:

    PRTL_SPLAY_LINKS - returns a pointer to the successor in the entire tree

--*/

{
    PRTL_SPLAY_LINKS Ptr;

    /*
      first check to see if there is a right subtree to the input link
      if there is then the real successor is the left most node in
      the right subtree.  That is find and return P in the following diagram

                  Links
                     \
                      .
                     .
                    .
                   /
                  P
                   \
    */

    if ((Ptr = KdRightChild(Links)) != NULL) {

        while (KdLeftChild(Ptr) != NULL) {
            Ptr = KdLeftChild(Ptr);
        }

        return Ptr;

    }

    /*
      we do not have a right child so check to see if have a parent and if
      so find the first ancestor that we are a left decendent of. That
      is find and return P in the following diagram

                       P
                      /
                     .
                      .
                       .
                      Links
    */

    Ptr = Links;
    while (KdIsRightChild(Ptr)) {
        Ptr = KdParent(Ptr);
    }

    if (KdIsLeftChild(Ptr)) {
        return KdParent(Ptr);
    }

    //
    //  otherwise we are do not have a real successor so we simply return
    //  NULL
    //

    return NULL;

}



PVOID
KdEnumerateGenericTableWithoutSplaying (
    IN PRTL_GENERIC_TABLE pTable,
    IN PVOID *RestartKey
    )

/*++

Routine Description:

    Analogous to RtlEnumerateGenericTableWithoutSplaying, but works in the
    kernel debugger.  The description of RtlEnumerateGenericTableWithoutSplaying
    follows:

    The function EnumerateGenericTableWithoutSplaying will return to the
    caller one-by-one the elements of of a table.  The return value is a
    pointer to the user defined structure associated with the element.
    The input parameter RestartKey indicates if the enumeration should
    start from the beginning or should return the next element.  If the
    are no more new elements to return the return value is NULL.  As an
    example of its use, to enumerate all of the elements in a table the
    user would write:

        *RestartKey = NULL;

        for (ptr = EnumerateGenericTableWithoutSplaying(Table, &RestartKey);
             ptr != NULL;
             ptr = EnumerateGenericTableWithoutSplaying(Table, &RestartKey)) {
                :
        }

Arguments:

    Table - Pointer to the generic table to enumerate.

    RestartKey - Pointer that indicates if we should restart or return the next
                element.  If the contents of RestartKey is NULL, the search
                will be started from the beginning.

Return Value:

    PVOID - Pointer to the user data.

--*/

{

    ULONG Result;
    RTL_GENERIC_TABLE Table;

    if ( !ReadMemory( (DWORD) pTable,
                      &Table,
                      sizeof( Table ),
                      &Result) ) {
        dprintf( "%08lx: Unable to read pTable\n", pTable );
        return NULL;
    }

    if (KdIsGenericTableEmpty(&Table)) {

        //
        // Nothing to do if the table is empty.
        //

        return NULL;

    } else {

        //
        // Will be used as the "iteration" through the tree.
        //
        PRTL_SPLAY_LINKS NodeToReturn;

        //
        // If the restart flag is true then go to the least element
        // in the tree.
        //

        if (*RestartKey == NULL) {

            //
            // We just loop until we find the leftmost child of the root.
            //

            for (
                NodeToReturn = Table.TableRoot;
                KdLeftChild(NodeToReturn);
                NodeToReturn = KdLeftChild(NodeToReturn)
                ) {
                ;
            }

            *RestartKey = NodeToReturn;

        } else {

            //
            // The caller has passed in the previous entry found
            // in the table to enable us to continue the search.  We call
            // KdRealSuccessor to step to the next element in the tree.
            //

            NodeToReturn = KdRealSuccessor(*RestartKey);

            if (NodeToReturn) {

                *RestartKey = NodeToReturn;

            }

        }

        //
        // If there actually is a next element in the enumeration
        // then the pointer to return is right after the list links.
        //

        return ((NodeToReturn)?
                   ((PVOID)((PLIST_ENTRY)((PVOID)(NodeToReturn+1))+1))
                  :((PVOID)(NULL)));

    }

}


//+---------------------------------------------------------------------------
//
//  Function:   gentable 
//
//  Synopsis:   dump a generic splay table only showing ptrs
//
//  Arguments:  
//
//  Returns:    
//
//  History:    5-14-1999   benl   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

DECLARE_API( gentable ) 
{
    PVOID              RestartKey;
    PVOID              Ptr;
    PRTL_GENERIC_TABLE Table;
    ULONG              RowOfData[4];
    INT_PTR            Address;
    ULONG              Result;

    Table = (PRTL_GENERIC_TABLE) GetExpression(args);

    RestartKey = NULL;

    dprintf( "node:       parent     left       right\n" );
//            0x12345678: 0x12345678 0x12345678 0x12345678
    for (Ptr = KdEnumerateGenericTableWithoutSplaying(Table, &RestartKey);
         Ptr != NULL;
         Ptr = KdEnumerateGenericTableWithoutSplaying(Table, &RestartKey)) {
            
        if (Ptr) {
            Address = (INT_PTR)Ptr - sizeof( RTL_SPLAY_LINKS ) - sizeof( LIST_ENTRY );

            if ( !ReadMemory( (DWORD) Address, &RowOfData, sizeof( RowOfData ), &Result) ) {
                dprintf( "%08lx: Unable to read link\n", Address );
            } else {
                dprintf( "0x%x: 0x%08x 0x%08x 0x%08x\n", Address, RowOfData[0], RowOfData[1], RowOfData[2] );
            }

            if ( !ReadMemory( (DWORD) Ptr, &RowOfData, sizeof( RowOfData ), &Result) ) {
                dprintf( "%08lx: Unable to read userdata\n", Ptr );
            } else {
                dprintf( "            0x%08x 0x%08x 0x%08x 0x%08x\n", RowOfData[0], RowOfData[1], RowOfData[2] );
            }
        }

        if (CheckControlC() ) {
            return;
        }

    }

} // DECLARE_API


=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\igrep.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    igrep.c

Abstract:

    WinDbg Extension Api

Author:

    Ramon J San Andres (ramonsa) 5-Nov-1993

Environment:

    User Mode.

Revision History:

--*/



CHAR igrepLastPattern[256];
DWORD igrepSearchStartAddress;
DWORD igrepLastPc;



DECLARE_API( igrep )

/*++

Routine Description:

    Grep for disassembled pattern

Arguments:

    args - [pattern [addr]]

Return Value:

    None

--*/

{
    DWORD dwNextGrepAddr;
    DWORD dwCurrGrepAddr;
    CHAR SourceLine[256];
    BOOL NewPc;
    DWORD d;
    LPSTR pc;
    LPSTR Pattern;
    LPSTR Expression;
    CHAR Symbol[256];
    DWORD Displacement;


    if ( igrepLastPc && igrepLastPc == dwCurrentPc ) {
        NewPc = FALSE;
    } else {
        igrepLastPc = dwCurrentPc;
        NewPc = TRUE;
    }

    //
    // check for pattern.
    //

    pc = args;
    Pattern = NULL;
    Expression = NULL;
    if ( *pc ) {
        Pattern = pc;
        while (*pc > ' ') {
            pc++;
        }

        //
        // check for an expression
        //

        if ( *pc != '\0' ) {
            *pc = '\0';
            pc++;
            if ( *pc <= ' ') {
                while (*pc <= ' '){
                    pc++;
                }
            }
            if ( *pc ) {
                Expression = pc;
            }
        }
    }

    if ( Pattern ) {
        strcpy(igrepLastPattern,Pattern);

        if ( Expression ) {
            igrepSearchStartAddress = GetExpression(Expression);
            if ( !igrepSearchStartAddress ) {
                igrepSearchStartAddress = igrepLastPc;
                return;
            }
        } else {
            igrepSearchStartAddress = igrepLastPc;
        }
    }

    dwNextGrepAddr = igrepSearchStartAddress;
    dwCurrGrepAddr = dwNextGrepAddr;
    d = Disassm(&dwNextGrepAddr,SourceLine,FALSE);
    while(d) {
        if (strstr(SourceLine,igrepLastPattern)) {
            igrepSearchStartAddress = dwNextGrepAddr;
            GetSymbol((LPVOID)dwCurrGrepAddr,Symbol,&Displacement);
            dprintf("%s",SourceLine);
            return;
        }
        if ( CheckControlC() ) {
            return;
        }
        dwCurrGrepAddr = dwNextGrepAddr;
        d = Disassm(&dwNextGrepAddr,SourceLine,FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\handle.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    handle.c

Abstract:

    WinDbg Extension Api

Author:

    Ramon J San Andres (ramonsa) 5-Nov-1993

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

BOOL
DumpHandles (
    IN HANDLE       HandleToDump,
    IN PVOID        pObjectType,
    IN ULONG        Flags
    );

BOOLEAN
DumpHandle(
   IN PVOID                Object,
   IN HANDLE               Handle,
   IN PVOID                pObjectType,
   IN ULONG                Flags
   );

DECLARE_API( handle  )

/*++

Routine Description:

    Dump the active handles

Arguments:

    args - [handle-to-dump [flags [process [TypeName]]]]
            if handle-to-dump is 0 dump all

Return Value:

    None

--*/

{

    ULONG        ProcessToDump;
    HANDLE       HandleToDump;
    ULONG        Flags;
    ULONG        Result;
    ULONG        nArgs;
    char         TypeName[ MAX_PATH ];
    PVOID        pObjectType;

    HandleToDump  = (HANDLE)0xFFFFFFFF;
    Flags         = 0x3; //by default dump bodies and objects for in use entries
    ProcessToDump = 0xFFFFFFFF;
    pObjectType   = NULL;

    nArgs = sscanf(args,"%lx %lx %lx",&HandleToDump,&Flags,&pObjectType);

    if (HandleToDump == (HANDLE)0xFFFFFFFF) {
        HandleToDump = 0;
    }

    if (HandleToDump != 0) {
        Flags |= 0x4;
    }

    if (pObjectType != 0) {
        dprintf("Searching for handles of type 0x%lx\n", pObjectType);
    }

    DumpHandles (HandleToDump, pObjectType, Flags);

    return;
}



//+---------------------------------------------------------------------------
//
//  Function:   DumpHandles
//
//  Synopsis:   Dump the handle table for the given process
//
//  Arguments:  [ProcessContents] -- process to dump
//              [RealProcessBase] -- base address of the process
//              [HandleToDump]    -- handle to look for - if 0 dump all
//              [pObjectType]     -- object type to look for
//              [Flags]           -- flags passed thru to DumpHandle
//
//  Returns:    TRUE if successful
//
//  History:    1-12-1998   benl   Created
//
//  Notes: Each segment of table has 0xFF or 8 bits worth of entries
//         the handle number's lowest 2 bit are application defined
//         so the indexes are gotten from the 3 8 bits ranges after
//         the first 2 bits
//
//----------------------------------------------------------------------------

BOOL
DumpHandles (
    IN HANDLE       HandleToDump,
    IN PVOID        pObjectType,
    IN ULONG        Flags
    )

{
    POBJECT_HANDLE_TABLE    HandleTablePointer;
    OBJECT_HANDLE_TABLE     HandleTable;
    ULONG                   ulRead;
    ULONG                   ulTopLevel;
    PVOID*                  rgEntries[OB_HANDLES_PER_TABLE];
    ULONG                   ulHandleNum = ((ULONG)HandleToDump & ~(sizeof(ULONG) - 1));

    HandleTablePointer = (POBJECT_HANDLE_TABLE)GetNtDebuggerData(ObpObjectHandleTable);

    if (!ReadMemory((DWORD)HandleTablePointer,
                    &HandleTable,
                    sizeof(OBJECT_HANDLE_TABLE),
                    &ulRead)) {

        dprintf("%08lx: Unable to read handle table\n", HandleTablePointer);
        return FALSE;
    }

    dprintf("Handle Table at %x with %d %s in use\n",
            HandleTablePointer,
            HandleTable.HandleCount,
            (HandleTable.HandleCount == 1) ? "Entry" : "Entries");

    if (ulHandleNum != 0) {

        if (ulHandleNum >= (ULONG)HandleTable.NextHandleNeedingPool) {
            dprintf("Invalid handle: 0x%x\n", ulHandleNum);
            return FALSE;
        }

        if (!ReadMemory((DWORD)(HandleTable.RootTable) +
                        (ulHandleNum >> OB_HANDLES_PER_TABLE_SHIFT),
                        &ulTopLevel,
                        sizeof(ulTopLevel),
                        &ulRead)) {
            dprintf("%08lx: Unable to read handle table\n",
                    (DWORD)(HandleTable.RootTable) +
                    (ulHandleNum >> OB_HANDLES_PER_TABLE_SHIFT));
            return FALSE;
        }

        if (!ulTopLevel) {
            dprintf("Invalid handle: 0x%x\n", ulHandleNum);
            return FALSE;
        }

        if (!ReadMemory(ulTopLevel +
                        (ulHandleNum & (OB_HANDLES_PER_TABLE * sizeof(PVOID) - 1)),
                        (PVOID)rgEntries,
                        sizeof(PVOID),
                        &ulRead)) {
            dprintf("%08lx: Unable to read handle table\n",
                    ulTopLevel);
            return FALSE;
        }

        DumpHandle(rgEntries[0], HandleToDump, pObjectType, Flags);

    } else {

        while (ulHandleNum < (ULONG)HandleTable.NextHandleNeedingPool) {

            if ((ulHandleNum & (OB_HANDLES_PER_TABLE * sizeof(PVOID) - 1)) == 0) {

                if (!ReadMemory((DWORD)(HandleTable.RootTable) +
                                (ulHandleNum >> OB_HANDLES_PER_TABLE_SHIFT),
                                &ulTopLevel,
                                sizeof(ulTopLevel),
                                &ulRead)) {
                    dprintf("%08lx: Unable to read handle table\n",
                            (DWORD)(HandleTable.RootTable) +
                            (ulHandleNum >> OB_HANDLES_PER_TABLE_SHIFT));
                    return FALSE;
                }

                if (!ulTopLevel) {
                    dprintf("%08lx: Unable to read handle table\n",
                            (DWORD)(HandleTable.RootTable) +
                            (ulHandleNum >> OB_HANDLES_PER_TABLE_SHIFT));
                    return FALSE;
                }

                if (!ReadMemory(ulTopLevel,
                                (PVOID)rgEntries,
                                sizeof(rgEntries),
                                &ulRead)) {
                    dprintf("%08lx: Unable to read handle table\n",
                            ulTopLevel);
                    return FALSE;
                }
            }

            DumpHandle(rgEntries[((ulHandleNum & (OB_HANDLES_PER_TABLE * sizeof(PVOID) - 1))) >> 2],
                (HANDLE)ulHandleNum, pObjectType, Flags);

            ulHandleNum += sizeof(ULONG);
        }

    } //endif on a specific handle

    return TRUE;
} // DumpHandles


//+---------------------------------------------------------------------------
//
//  Function:   DumpHandle
//
//  Synopsis:   Dump a particular Handle
//
//  Arguments:  [pHandleTableEntry] --  entry to dump
//              [Handle]            --  handle number of entry
//              [pObjectType]       --  only dump if object type matches this
//                                      if NULL dump everything
//              [Flags]             --  flags if 0x2 also dump the object
//                                            if 0x4 dump free entries
//
//  Returns:
//
//  History:    1-12-1998   benl   Created
//              1-12-1998   benl   modified
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOLEAN
DumpHandle(
    IN PVOID                Object,
    IN HANDLE               Handle,
    IN PVOID                pObjectType,
    IN ULONG                Flags
    )
{
    ULONG         ulObjectHeaderAddr;
    ULONG         Result;

    ULONG         HandleAttributes;
    OBJECT_HEADER ObjectHeader;
    PVOID         ObjectBody;

    if (Object == NULL) {
        //only print if flag is set to 4
        if (Flags & 4)
        {
            dprintf("%08lx: zeroed handle\n", Handle);
        }
        return TRUE;
    }

    if (((ULONG_PTR)Object & 1) != 0) {
        //only print if flag is set to 4
        if (Flags & 4)
        {
            dprintf("%08lx: free handle\n", Handle);
        }
        return TRUE;
    }

    //actual hdr is sign extend value with the lowest 3 bits cancelled out
    //top bit marks whether entry is locked
    //lower 3 bits mark auditing, inheritance and protection
    ulObjectHeaderAddr = (ULONG)OBJECT_TO_OBJECT_HEADER(Object);

    if (!ReadMemory(ulObjectHeaderAddr,
                    &ObjectHeader,
                    sizeof(ObjectHeader),
                    &Result)) {
        dprintf("%08lx: Unable to read nonpaged object header\n",
                ulObjectHeaderAddr);
        return FALSE;
    }

    if (pObjectType != NULL && ObjectHeader.Type != pObjectType) {
        return TRUE;
    }

    ObjectBody = (PVOID) (ulObjectHeaderAddr + FIELD_OFFSET(OBJECT_HEADER, Body));
    dprintf("%08lx: Object: %08lx", Handle, ObjectBody);

    dprintf("\n");
    if (Flags & 2) {
        DumpObject( "    ",ObjectBody, &ObjectHeader,Flags );
    }

    EXPRLastDump = (ULONG)ObjectBody;
    dprintf("\n");
    return TRUE;
} // DumpHandle
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\image.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    image.c

Abstract:

    WinDbg Extension Api

Author:

    Kent Forschmiedt (kentf) 15-May-1995

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

VOID
ImageExtension(
    IN PSTR lpArgs
    );

DECLARE_API( dh )
{
    ImageExtension( (PSTR)args );
}

#include "..\\ntsdexts\\imageext.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\irpverif.h ===
VOID
DumpAllTrackedIrps(
   VOID
   );

VOID
PrintIrpStack(
    IN PIO_STACK_LOCATION IrpSp
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\help.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    .c

Abstract:

    WinDbg Extension Api

Author:

    Ramon J San Andres (ramonsa) 5-Nov-1993

Environment:

    User Mode.

Revision History:

--*/

VOID
CommonHelp (
    VOID
    );



DECLARE_API( help  )

/*++

Routine Description:

    Displays help

Arguments:

    args - [ user | kernel ]

Return Value:

    None

--*/

{
    //
    //  Display common help
    //
    CommonHelp();

    //
    //  Display platform-specific help
    //
    SpecificHelp();
}

VOID
CommonHelp (
    VOID
    )
{
    dprintf("?                            - Displays this list\n" );
    dprintf("bushnd [address]             - Dump a HAL \"BUS HANDLER\" structure\n");
    dprintf("                               [address] if specified is the handler\n");
    dprintf("                               to be dumped. If not specified, dumps\n");
    dprintf("                               the list of handlers (brief).\n");
    dprintf("ca <address> [flags]         - Dump the control area of a section\n");
    dprintf("calldata <table name>        - Dump call data hash table\n" );
    dprintf("cmreslist <CM Resource List> - Dump CM resource list\n" );
    dprintf("db <physical address>        - Display physical memory\n");
    dprintf("dd <physical address>        - Display physical memory\n");
    dprintf("dblink <address> [count] [bias] - Dumps a list via its blinks\n");
    dprintf("dflink <address> [count] [bias] - Dumps a list via its flinks\n");
    dprintf("       bias - a mask of bits to ignore in each pointer\n");
    dprintf("defwrites                    - Dumps the deferred write queue and\n");
    dprintf("                                and triages cached write throttles\n");
    dprintf("devobj <device>             - Dump the device object and Irp queue\n");
    dprintf("                   <device> - device object address or name\n");
    dprintf("devstack <device>           - Dump device stack associated with device object\n");
    dprintf("drvobj <driver> [flags]     - Dump the driver object and related information\n");
    dprintf("                   <driver> - driver object address or name\n");
    dprintf("                   flags:1  - Dump device object list\n");
    dprintf("                   flags:2  - Dump driver entry points\n");
    dprintf("drivers                     - Display information about all loaded system modules\n");
    dprintf("eb <physical address> <byte>  <byte, byte ,...> - modify physical memory\n");
    dprintf("ed <physical address> <dword> <dword,dword,...> - modify physical memory\n");
    dprintf("exqueue [flags]             - Dump the ExWorkerQueues\n");
    dprintf("        flags:     1/2/4    - same as !thread/!process\n");
    dprintf("                   10       - only critical work queue\n");
    dprintf("                   20       - only delayed work queue\n");
    dprintf("                   40       - only hypercritical work queue\n");
    dprintf("exr <address>               - Dump exception record at specified address\n");
    dprintf("filecache                   - Dumps information about the file system cache\n");
    dprintf("filetime                    - Dumps a 64-bit FILETIME as a human-readable time\n");
    dprintf("filelock <address>          - Dump a file lock structure\n");
    dprintf("fpsearch <address>          - Find a freed special pool allocation\n");
    dprintf("frag [flags]                - Kernel mode pool fragmentation\n");
    dprintf("     flags:  1 - List all fragment information\n");
    dprintf("             2 - List allocation information\n");
    dprintf("             3 - both\n");
    dprintf("gentable <address> - dumps the given rtl_generic_table\n");
    dprintf("handle <addr> <flags> <TypeName> -  Dumps handle for a process\n");
    dprintf("       flags:  -2 Dump non-paged object\n");
    dprintf("heap <addr> [flags]         - Dumps heap for a process\n");
    dprintf("       flags:  -v Verbose\n");
    dprintf("               -f Free List entries\n");
    dprintf("               -a All entries\n");
    dprintf("               -s Summary\n");
    dprintf("               -x Force a dump even if the data is bad\n");
    dprintf("       address: desired heap to dump or 0 for all\n");
    dprintf("help                         - Displays this list\n" );
    dprintf("HidPpd <address> <flags>     - Dump Preparsed Data of HID device\n");
    dprintf("ib <port>                    - Read a byte from an I/O port\n");
    dprintf("id <port>                    - Read a double-word from an I/O port\n");
    dprintf("iw <port>                    - Read a word from an I/O port\n");
    dprintf("ioreslist <IO Resource List> - Dump IO resource requirements list\n" );
    dprintf("irp <address> <dumplevel>    - Dump Irp at specified address\n");
    dprintf("                 address == 0   Dump active IRPs (checked only)\n");
    dprintf("                 dumplevel: 0   Basic stack info\n");
    dprintf("                 dumplevel: 1   Full field dump\n");
    dprintf("                 dumplevel: 2   Include tracking information (checked only)\n");
    dprintf("irpfind [pooltype] [restart addr] [<irpsearch> <address>]- Search pool for active Irps\n");
    dprintf("     pooltype is 0 for nonpaged pool (default)\n");
    dprintf("     pooltype is 1 for paged pool\n");
    dprintf("     pooltype is 2 for special pool\n");
    dprintf("     restart addr - if specfied, scan will be restarted from \n");
    dprintf("                    this location in pool\n");
    dprintf("     <irpsearch> - specifies filter criteria to find a specific irp\n");
    dprintf("           'userevent' - finds IRPs where Irp.UserEvent == <address>\n");
    dprintf("           'device' - finds IRPs with a stack location where DeviceObject == <address>\n");
    dprintf("           'fileobject' - finds IRPs where Irp.Tail.Overlay.OriginalFileObject == <address>\n");
    dprintf("           'mdlprocess' - finds IRPs where Irp.MdlAddress.Process == <address>\n");
    dprintf("           'thread' - finds IRPs where Irp.Tail.Overlay.Thread == <address>\n");
    dprintf("           'arg' - finds IRPs with one of the args == <address>\n");
    dprintf("locks [-v] <address>         - Dump kernel mode resource locks\n");
    dprintf("memusage                    - Dumps the page frame database table\n");
    dprintf("ob <port>                   - Write a byte to an I/O port\n");
    dprintf("obja <TypeName>             - Dumps an object manager object's attributes\n");
    dprintf("object <-r | Path | address | 0 TypeName>  - Dumps an object manager object\n");
    dprintf("       -r   -  Force reload of cached object pointers\n");
    dprintf("od <port>                   - Write a double-word to an I/O port\n");
    dprintf("ow <port>                   - Write a word to an I/O port\n");
    dprintf("ohcd                        - Performs checks and dumps information on the OpenHCI state,\n");
    dprintf("                              including: dumping all endpoints in the schedule, check the\n");
    dprintf("                              bandwidth tables for internal consistency, display summary bandwidth\n");
    dprintf("                              statics.\n");
    dprintf("patch                       - Enable and disable various driver flags\n");
    dprintf("pfn                         - Dumps the page frame database entry for the physical page\n");
    dprintf("pnpevent <event entry> - Dump PNP events\n");
    dprintf("       event entry: 0       - list all queued events\n");
    dprintf("                    address - list specified event\n");
    dprintf("pool <address> [detail]     - Dump kernel mode heap\n");
    dprintf("        address: 0 or blank - Only the process heap\n");
    dprintf("                         -1 - All heaps in the process\n");
    dprintf("              Otherwise for the heap address listed\n");
    dprintf("     detail:  0 - Summary Information\n");
    dprintf("              1 - Above + location/size of regions\n");
    dprintf("              2 - Print information only for address\n");
    dprintf("              3 - Above + allocated/free blocks in committed regions\n");
    dprintf("              4 - Above + free lists\n");
    dprintf("poolfind Tag [pooltype] -   - Finds occurrences of the specified Tag\n");
    dprintf("     Tag is 4 character tag, * and ? are wild cards\n");
    dprintf("     pooltype is 0 for nonpaged pool (default)\n");
    dprintf("     pooltype is 1 for paged pool\n");
    dprintf("     pooltype is 2 for special pool\n");
    dprintf("   NOTE - this can take a long time!\n");
    dprintf("poolused [flags [TAG]]      - Dump usage by pool tag\n");
    dprintf("       flags:  1 Verbose\n");
    dprintf("       flags:  2 Sort by NonPagedPool Usage\n");
    dprintf("       flags:  4 Sort by PagedPool Usage\n");
    dprintf("process [flags] [image name] - Dumps process at specified address\n");
    dprintf("                (dumps only the process with specified image name, if given)\n");
    dprintf("        flags:         1       - don't stop after cid/image information\n");
    dprintf("                       2       - dump thread wait states\n");
    dprintf("                       4       - dump only thread states, combine with 2 to get stack\n");
    dprintf("ptov PhysicalPageNumber     - Dump all valid physical<->virtual mappings\n");
    dprintf("                              for the given page directory\n");
    dprintf("range <RtlRangeList>        - Dump RTL_RANGE_LIST\n");
    dprintf("ready                       - Dumps state of all READY system threads\n");
    dprintf("sd <Address> [flags]        - Displays the SECURITY_DESCRIPTOR\n" );
    dprintf("sid <Address> [flags]       - Displays the SID\n" );
    dprintf("srb <address>               - Dump Srb at specified address\n");
    dprintf("stacks <detail-level>       - Dump summary of current kernel stacks\n");
    dprintf("            detail-level: 0    Display stack summary\n");
    dprintf("            detail-level: 1    Display stacks, no parameters\n");
    dprintf("            detail-level: 2    Display stacks, full parameters\n");
    dprintf("sysptes                     - Dumps the system PTEs\n");
    dprintf("thread [flags]              - Dump current thread, or specified thread,\n");
    dprintf("                                  or with stack containing address\n");
    dprintf("        flags:         1       - not used\n");
    dprintf("                       2       - dump thread wait states\n");
    dprintf("                       4       - dump only thread states, combine with 2 to get stack\n");
    dprintf("threadfields                - Show offsets to all fields in a thread\n");
    dprintf("time                        - Reports PerformanceCounterRate and TimerDifference\n");
    dprintf("timer                       - Dumps timer tree\n");
    dprintf("trap <address>              - Dump a trap frame\n");
    dprintf("urb <address> <flags>       - Dump a USB Request Block\n");
    dprintf("usbstruc <address> <type>   - Print out an USB HC descriptor of <type>\n");
    dprintf("                   <type>   - {OHCIReg | HCCA | OHCIHcdED | OHCIHcdTD |\n"
            "                               OHCIEndpoint | DevData | UHCDReg  }\n");
    dprintf("vad                         - Dumps VADs\n");
    dprintf("version                     - Version of extension dll\n");
    dprintf("vm                          - Dumps virtual management values\n");
    dprintf("vpd <address>               - Dumps volume parameter block\n");
    dprintf("vtop DirBase address        - Dumps physical page for virtual address\n");
    dprintf("wdmaud <address> <flags>    - Dumps wdmaud data for structures\n");
    dprintf("       flags:  1 - Ioctl History Dump given WdmaIoctlHistoryListHead\n");
    dprintf("       flags:  2 - Pending Irps given WdmaPendingIrpListHead\n");
    dprintf("       flags:  4 - Allocated MDLs given WdmaAllocatedMdlListHead\n");
    dprintf("       flags:  8 - pContext Dump given WdmaContextListHead\n");
    dprintf("       flags:100 - Verbose\n");
    dprintf("xpptree                     - Dumps the Xbox Peripheral Port Tree\n");
    dprintf("zombies                     - Find all zombie processes\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\kuser.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    kuser.c

Abstract:

    WinDbg Extension Api

Author:

    Ramon J San Andres (ramonsa) 5-Nov-1993

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

VOID
KUserExtension(
    PCSTR lpArgumentString,
    KUSER_SHARED_DATA * const SharedData
    );


DECLARE_API( kuser )

/*++

Routine Description:

    This function is called as an NTSD extension to dump the shared user mode
    page (KUSER_SHARED_DATA)

    Called as:

        !kuser

Arguments:

    None

Return Value:

    None

--*/

{
    KUserExtension( args, SharedUserData );
}

#include "..\\ntsdexts\\kuserext.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\iospace.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    kdapi.c

Abstract:

    WinDbg Extension Api

Author:

    Wesley Witt (wesw) 15-Aug-1993

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


VOID
InternalReadIoSpace(
    ULONG InputSize,
    LPSTR args
    )

/*++

Routine Description:

    Input a byte froma port.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG    IoAddress;
    ULONG    InputValue;
    UCHAR    Format[] = "%08lx: %01lx\n";
    ULONG    OriginalInputSize = InputSize;

    InputValue = 0;

    Format[9] = (UCHAR)('0' + (InputSize * 2));


    IoAddress = GetExpression( args );

    if (IoAddress == 0) {
        dprintf( "Could not evaluate address expresion (%s)\n", args );
        return;
    }

    ReadIoSpace( IoAddress, &InputValue, &InputSize );

    if (InputSize) {
        dprintf(Format, IoAddress, InputValue);
    }
    else {
        dprintf(" %08lx: \n", IoAddress);
        while (OriginalInputSize--) {
            dprintf("??");
        }
        dprintf("\n");
    }
}


DECLARE_API( ib )
{
    InternalReadIoSpace( 1, (PSTR)args );
}

DECLARE_API( iw )
{
    InternalReadIoSpace( 2, (PSTR)args );
}

DECLARE_API( id )
{
    InternalReadIoSpace( 4, (PSTR)args );
}


VOID
InternalWriteIoSpace(
    ULONG OutputSize,
    LPSTR args
    )

/*++

Routine Description:

    Input a byte froma port.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG    IoAddress = 0;
    ULONG    OutputValue = 0;
    LPSTR    p;


    p = strtok( args, " \t" );
    if (p) {
        IoAddress = GetExpression( p );
    }

    if (IoAddress == 0) {
        dprintf( "Could not evaluate address expresion (%s)\n", args );
        return;
    }

    p = strtok( NULL, " \t" );
    if (p) {
        OutputValue = GetExpression( p );
    }

    WriteIoSpace( IoAddress, OutputValue, &OutputSize );
}


DECLARE_API( ob )
{
    InternalWriteIoSpace( 1, (PSTR)args );
}

DECLARE_API( ow )
{
    InternalWriteIoSpace( 2, (PSTR)args );
}

DECLARE_API( od )
{
    InternalWriteIoSpace( 4, (PSTR)args );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\lists.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Lists.c

Abstract:

    WinDbg Extension Api

Author:

    Gary Kimura [GaryKi]    25-Mar-96

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#define ReadAtAddress(A,V,S,R)                                   \
    (ReadMemory( (ULONG)(A), &(V), (S), &R ) && (R >= (S)))

#define BIG_READ    (sizeof(ULONG) * 4)
#define SMALL_READ  (sizeof(ULONG) * 2)

VOID
DumpListByLinks (
    IN ULONG StartAddress,
    IN ULONG MaxCount,
    IN ULONG Bias,
    IN LOGICAL UseFlink
    )

/*++

Routine Description:

    Dump a list by its blinks.

Arguments:

    arg - [Address] [count] [bias]

Return Value:

    None

--*/

{
    ULONG Address;
    ULONG Buffer[4];
    ULONG ReadSize;
    ULONG BytesRead;
    ULONG Count;

    //
    //  set our starting address and then while the count is greater than zero
    //  and the starting address is not equal to the current dumping address
    //  we'll read in 4 ulongs, dump them, and then go through the flink&blink
    //  using the specified bias.
    //

    Address = StartAddress;

    ReadSize = BIG_READ;

    for (Count = 0; Count < MaxCount; ) {

        if (ReadAtAddress( Address, Buffer, ReadSize, BytesRead ) == 0) {
            ReadSize = SMALL_READ;
            if (ReadAtAddress( Address, Buffer, ReadSize, BytesRead ) == 0) {
                dprintf("Can't Read Memory at %08lx\n", Address);
                break;
            }
        }

        if (ReadSize == BIG_READ) {
            dprintf("%08lx  %08lx %08lx %08lx %08lx\n", Address, Buffer[0], Buffer[1], Buffer[2], Buffer[3]);
        }
        else {
            dprintf("%08lx  %08lx %08lx\n", Address, Buffer[0], Buffer[1]);
        }

        Count += 1;

        //
        //  the bias tells us which bits to knock out of the pointer
        //

        if (UseFlink == TRUE) {
            Address = Buffer[0] & ~Bias;
        }
        else {
            Address = Buffer[1] & ~Bias;
        }

        if (Address == StartAddress) {
            break;
        }

        if (((Count & 0xf) == 0) && CheckControlC() ) {
            break;
        }
    }

    if (Count != 0) {
        dprintf("0x%x entries dumped\n", Count);
    }

    return;
}


DECLARE_API( dflink )

/*++

Routine Description:

    Dump a list by its flinks.

Arguments:

    arg - [Address] [count] [bias]

Return Value:

    None

--*/

{
    ULONG StartAddress;
    ULONG Count;
    ULONG Bias;

    StartAddress = 0;
    Count = 0x20;
    Bias = 0;

    //
    //  read in the parameters
    //

    sscanf(args,"%lx %lx %lx",&StartAddress, &Count, &Bias);

    DumpListByLinks (StartAddress, Count, Bias, TRUE);

    return;
}


DECLARE_API( dblink )

/*++

Routine Description:

    Dump a list by its blinks.

Arguments:

    arg - [Address] [count] [bias]

Return Value:

    None

--*/

{
    ULONG StartAddress;
    ULONG Count;
    ULONG Bias;

    StartAddress = 0;
    Count = 0x20;
    Bias = 0;

    //
    //  read in the parameters
    //

    sscanf(args,"%lx %lx %lx",&StartAddress, &Count, &Bias);

    DumpListByLinks (StartAddress, Count, Bias, FALSE);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\irp.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    irp.c

Abstract:

    WinDbg Extension Api

Author:

    Ramon J San Andres (ramonsa) 5-Nov-1993

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"
#include "irpverif.h"
#pragma hdrstop

typedef struct _POOL_BLOCK_HEAD {
    POOL_HEADER Header;
    LIST_ENTRY List;
} POOL_BLOCK_HEAD, *PPOOL_BLOCK_HEADER;

typedef struct _POOL_HACKER {
    POOL_HEADER Header;
    ULONG Contents[8];
} POOL_HACKER;

typedef
BOOLEAN
(WINAPI *IRP_FILTER_ROUTINE)(
    PIRP Irp,
    PVOID FilterContext
    );

typedef struct _IRP_FILTER {
    IRP_FILTER_ROUTINE FilterRoutine;
    PVOID              FilterContext;
} IRP_FILTER, *PIRP_FILTER;

typedef struct _SEARCH_CONTEXT {
    ULONG FirstTime;
    IRP_FILTER Filter;
} SEARCH_CONTEXT, *PSEARCH_CONTEXT;

#define TAG 0
#define NONPAGED_ALLOC 1
#define NONPAGED_FREE 2
#define PAGED_ALLOC 3
#define PAGED_FREE 4
#define NONPAGED_USED 5
#define PAGED_USED 6

#define IRPBUFSIZE  (sizeof(IRP) + (5 * sizeof(IO_STACK_LOCATION)))

VOID
DumpIrp(
    PVOID IrpToDump,
    ULONG DumpLevel
    );

BOOLEAN
IrpFilterUserEvent(
    PIRP Irp,
    PVOID FilterContext
    );

BOOLEAN
IrpFilterDevice(
    PIRP Irp,
    PVOID FilterContext
    );

BOOLEAN
IrpFilterFileObject(
    PIRP Irp,
    PVOID FilterContext
    );

BOOLEAN
IrpFilterThread(
    PIRP Irp,
    PVOID FilterContext
    );

BOOLEAN
IrpFilterMdlProcess(
    PIRP Irp,
    PVOID FilterContext
    );

BOOLEAN
IrpFilterArg(
    PIRP Irp,
    PVOID FilterContext
    );

DECLARE_API( irp )

/*++

Routine Description:

   Dumps the specified Irp

Arguments:

    args - Address

Return Value:

    None

--*/

{
    ULONG irpToDump;
    ULONG dumpLevel = 0 ;
    BOOLEAN isCheckedBuild ;
    char irpExprBuf[256] ;
    char dumpLevelBuf[256] ;

    if (!*args) {
        irpToDump = EXPRLastDump;
    } else {

        //
        // !Irp IrpAddress DumpLevel
        //    where IrpAddress can be an expression
        //    and DumpLevel is a decimal level of any non-decimal string for 1
        irpExprBuf[0] = '\0' ;
        dumpLevelBuf[0] = '\0' ;

        sscanf(args, "%s %s", irpExprBuf, dumpLevelBuf);

        if (irpExprBuf) {

            if (IsHexNumber(irpExprBuf)) {

               sscanf(irpExprBuf, "%lx", &irpToDump) ;
            } else {

               irpToDump = GetExpression( irpExprBuf ) ;
               if (irpToDump==0) {

                  dprintf("An error occured trying to evaluate the expression\n") ;
                  return ;
               }
            }

            if (IsDecNumber(dumpLevelBuf)) {

               sscanf(dumpLevelBuf, "%d", &dumpLevel) ;
            } else if (dumpLevelBuf[0]) {

               dumpLevel = 1 ;
            } else {

               dumpLevel = 0 ;
            }
        }
    }

    if (irpToDump == 0) {

       if (IsCheckedBuild(&isCheckedBuild) && isCheckedBuild) {

          //DumpAllTrackedIrps() ;

       } else {

          dprintf("Free build - use !irpfind to scan memory for any active IRPs\n") ;
       }

    } else {

       DumpIrp((PUCHAR)irpToDump, (ULONG) dumpLevel);
    }
}


DECLARE_API( irpzone )

/*++

Routine Description:

    Dumps both the small irp zone and the large irp zone.  Only irps that
    are currently allocated are dumped.  "args" controls the type of dump.
    If "args" is present then the Irp is sent to the DumpIrp routine to be
    disected.  Otherwise, only the irp, its thread and the driver holding the
    irp (i.e. the driver of the last stack) is printed.

Arguments:

    args - a string pointer.  If anything is in the string it indicates full
           information (i.e. call DumpIrp).

Return Value:

    None.

--*/

{
    ULONG   listAddress;
    BOOLEAN fullOutput = FALSE;

    dprintf("irpzone is no longer supported.  Use irpfind to search "   \
            "nonpaged pool for active Irps\n");

    return;

}



VOID
DumpIrp(
    PVOID IrpToDump,
    ULONG DumpLevel
    )

/*++

Routine Description:

    This routine dumps an Irp.  It does not check to see that the address
    supplied actually locates an Irp.  This is done to allow for dumping
    Irps post mortem, or after they have been freed or completed.

Arguments:

    IrpToDump - the address of the irp.
    DumpLevel - 0 Summary
                1 Extended information
                2 Debug tracking info iff available

Return Value:

    None

--*/

{
    IO_STACK_LOCATION   irpStack;
    PCHAR               buffer;
    ULONG               irpStackAddress;
    ULONG               result;
    IRP                 irp;
    CCHAR               irpStackIndex;
    LARGE_INTEGER       runTime ;
    BOOLEAN             isCheckedBuild, delayed ;

    if ( !ReadMemory( (DWORD) IrpToDump,
                      &irp,
                      sizeof(irp),
                      &result) ) {
        dprintf("%08lx: Could not read Irp\n", IrpToDump);
        return;
    }

    if (irp.Type != IO_TYPE_IRP) {
        dprintf("IRP signature does not match, probably not an IRP\n");
        return;
    }

    dprintf("Irp is active with %d stacks %d is current (= %#08lx)\n",
            irp.StackCount,
            irp.CurrentLocation,
            irp.Tail.Overlay.CurrentStackLocation);

    if ((irp.UserBuffer != NULL) && (irp.Type == IO_TYPE_IRP)) {
        dprintf(" UserBuffer = %08lx ", irp.UserBuffer);
    } else {
        dprintf(" No UserBuffer ");
    }

    dprintf("Thread %08lx:  ", irp.Tail.Overlay.Thread);

    if (irp.StackCount > 30) {
        dprintf("Too many Irp stacks to be believed (>30)!!\n");
        return;
    } else {
        if (irp.CurrentLocation > irp.StackCount) {
            dprintf("Irp is completed.  ");
        } else {
            dprintf("Irp stack trace.  ");
        }
    }

    if (irp.PendingReturned) {
        dprintf("Pending has been returned\n");
    } else {
        dprintf("\n");
    }

    if (DumpLevel>0)
    {
        dprintf("Flags = %08lx\n", irp.Flags);
        dprintf("ThreadListEntry.Flink = %08lx\n", irp.ThreadListEntry.Flink);
        dprintf("ThreadListEntry.Blink = %08lx\n", irp.ThreadListEntry.Blink);
        dprintf("IoStatus.Status = %08lx\n", irp.IoStatus.Status);
        dprintf("IoStatus.Information = %08lx\n", irp.IoStatus.Information);
        dprintf("Cancel = %02lx\n", irp.Cancel);
        dprintf("UserIosb = %08lx\n", irp.UserIosb);
        dprintf("UserEvent = %08lx\n", irp.UserEvent);
        dprintf("Overlay.AsynchronousParameters.UserApcRoutine = %08lx\n", irp.Overlay.AsynchronousParameters.UserApcRoutine);
        dprintf("Overlay.AsynchronousParameters.UserApcContext = %08lx\n", irp.Overlay.AsynchronousParameters.UserApcContext);
        dprintf(
            "Overlay.AllocationSize = %08lx - %08lx\n",
            irp.Overlay.AllocationSize.HighPart,
            irp.Overlay.AllocationSize.LowPart);
        dprintf("UserBuffer = %08lx\n", irp.UserBuffer);
        dprintf("&Tail.Overlay.DeviceQueueEntry = %08lx\n", &irp.Tail.Overlay.DeviceQueueEntry);
        dprintf("Tail.Overlay.Thread = %08lx\n", irp.Tail.Overlay.Thread);
        dprintf("Tail.Overlay.ListEntry.Flink = %08lx\n", irp.Tail.Overlay.ListEntry.Flink);
        dprintf("Tail.Overlay.ListEntry.Blink = %08lx\n", irp.Tail.Overlay.ListEntry.Blink);
        dprintf("Tail.Overlay.CurrentStackLocation = %08lx\n", irp.Tail.Overlay.CurrentStackLocation);
        dprintf("Tail.Overlay.OriginalFileObject = %08lx\n", irp.Tail.Overlay.OriginalFileObject);
        dprintf("Tail.Apc = %08lx\n", irp.Tail.Apc);
        dprintf("Tail.CompletionKey = %08lx\n", irp.Tail.CompletionKey);
    }

    irpStackAddress = (ULONG)IrpToDump + sizeof(irp);

    buffer = LocalAlloc(LPTR, 256);
    if (buffer == NULL) {
        dprintf("Can't allocate 256 bytes\n");
        return;
    }

    dprintf("     cmd  flg cl Device   File     Completion-Context\n");
    for (irpStackIndex = 1; irpStackIndex <= irp.StackCount; irpStackIndex++) {

        if ( !ReadMemory( (DWORD) irpStackAddress,
                          &irpStack,
                          sizeof(irpStack),
                          &result) ) {
            dprintf("%08lx: Could not read IrpStack\n", irpStackAddress);
            goto exit;
        }

        dprintf("%c[%3x,%2x]  %2x %2x %08lx %08lx %08lx-%08lx %s %s %s %s\n",
                irpStackIndex == irp.CurrentLocation ? '>' : ' ',
                irpStack.MajorFunction,
                irpStack.MinorFunction,
                irpStack.Flags,
                irpStack.Control,
                irpStack.DeviceObject,
                irpStack.FileObject,
                irpStack.CompletionRoutine,
                irpStack.Context,
                (irpStack.Control & SL_INVOKE_ON_SUCCESS) ? "Success" : "",
                (irpStack.Control & SL_INVOKE_ON_ERROR)   ? "Error"   : "",
                (irpStack.Control & SL_INVOKE_ON_CANCEL)  ? "Cancel"  : "",
                (irpStack.Control & SL_PENDING_RETURNED)  ? "pending"  : "");

        if (irpStack.DeviceObject != NULL) {
            dprintf("\t      ");
            DumpDevice(irpStack.DeviceObject, 0, FALSE);
        }

        if (irpStack.CompletionRoutine != NULL) {

            GetSymbol((LPVOID)irpStack.CompletionRoutine, buffer, &result);
            dprintf("\t%s\n", buffer);
        } else {
            dprintf("\n");
        }

        dprintf("\t\t\tArgs: %08lx %08lx %08lx %08lx\n",
                irpStack.Parameters.Others.Argument1,
                irpStack.Parameters.Others.Argument2,
                irpStack.Parameters.Others.Argument3,
                irpStack.Parameters.Others.Argument4);
        irpStackAddress += sizeof(irpStack);
        if (CheckControlC()) {
           goto exit;
        }
    }

    if (DumpLevel>=2) {

       if (IsCheckedBuild(&isCheckedBuild) && isCheckedBuild) {

       } else {

          dprintf("Extra information not available in free build.\n") ;
       }
    }

exit:
    LocalFree(buffer);
}


//+---------------------------------------------------------------------------
//
//  Function:   CheckForIrp
//
//  Synopsis:   Matches pool chunk against an irp
//
//  Arguments:  [Tag]            -- 
//              [Filter]         -- 
//              [Flags]          -- 0 nonpaged pool 1 paged pool 2 special pool 4 dump irp
//              [PoolTrackTable] -- 
//              [PoolHeader]     -- 
//              [BlockSize]      -- 
//              [Data]           -- 
//
//  Returns:    
//
//  History:    7-28-1999   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOLEAN WINAPI CheckForIrp(
    PCHAR Tag,
    PCHAR Filter,
    ULONG Flags,
    PPOOL_HEADER PoolHeader,
    ULONG BlockSize,
    PVOID Data,
    PVOID Context
    )
{
    PIRP Irp;
    ULONG Result;
    PIO_STACK_LOCATION irpSp;
    PSEARCH_CONTEXT SearchContext = (PSEARCH_CONTEXT)Context;

    Irp = (PIRP) malloc( BlockSize );

    if(Irp == NULL) {
        dprintf("Unable to allocate irp sized buffer\n");
        return FALSE;
    }


    //
    //  If its a big pool page (no header) or special pool (Flags == 0x2) or
    //  its in regular pool and not free then try to dump 
    //  

    if ( ((PoolHeader == NULL) || 
          (Flags & 0x2) || 
          (PoolHeader->PoolType != 0)) 
        
        && (CheckSingleFilter( Tag, Filter ))) {

        if(ReadMemory((ULONG_PTR)Data,
                      Irp,
                      sizeof(DWORD),
                      &Result)) {

            if(Irp->Type == IO_TYPE_IRP)    {

                if (Flags & 0x4) {
                    if (SearchContext->FirstTime) {

                        dprintf("  Irp    [ Thread ] irpStack: (Mj,Mn)   DevObj  [Driver]\n");
                        SearchContext->FirstTime = FALSE;
                    }
                    dprintf("%08lx: ", Data);
                    DumpIrp((PUCHAR)Data, 0);
                    dprintf("\n");
                } else {
                    if((ReadMemory((ULONG_PTR)Data,
                                   Irp,
                                   BlockSize,
                                   &Result)) &&
                       (SearchContext->Filter.FilterRoutine == NULL) ||
                       (SearchContext->Filter.FilterRoutine(Irp, SearchContext->Filter.FilterContext))) {

                        if (SearchContext->FirstTime) {

                            dprintf("  Irp    [ Thread ] irpStack: (Mj,Mn)   DevObj  [Driver]\n");
                            SearchContext->FirstTime = FALSE;
                        }

                        irpSp = (PIO_STACK_LOCATION)
                                    (((PCHAR) Irp + sizeof(IRP)) +
                                    (Irp->CurrentLocation - 1) *
                                    sizeof(IO_STACK_LOCATION));

                        dprintf("%08lx [%08lx] ", Data,
                                Irp->Tail.Overlay.Thread);

                        if(Irp->CurrentLocation > Irp->StackCount) {
                            dprintf("Irp is complete (CurrentLocation "
                                    "%d > StackCount %d)",
                                    Irp->CurrentLocation,
                                    Irp->StackCount);
                        } else {
                            dprintf("irpStack: (%2x,%2x)",
                                    irpSp->MajorFunction,
                                    irpSp->MinorFunction);

                            dprintf("  %08lx [", irpSp->DeviceObject);
                            DumpDevice(irpSp->DeviceObject, 0, FALSE);
                            dprintf("]");
                        }

                        dprintf("\n");
                    }
                }
            } else {
                // dprintf("%08lx (size %04lx) uninitialized or overwritten IRP\n",
                //         irpAddress,
                //         PoolBlock.Header.BlockSize << POOL_BLOCK_SHIFT);
            }
        } else {
            dprintf("Possible IRP @ %lx - unable to read addr\n", Data );
        }

        free( Irp );
        return TRUE;

    } else {
#ifdef SHOW_PROGRESS
        dprintf("%c", turnTable[turn]);
        turn = (turn + 1) % 4;
#endif
    }
    
    free( Irp );
    return FALSE;
} // CheckForIrp


DECLARE_API(irpfind)

/*++

Routine Description:

    finds Irps in non-paged pool

Arguments:

    args -

Return Value:

    None

--*/


{
    PCHAR       RestartAddr = 0;
    ULONG       TagName;
    UCHAR       Field[20];
    ULONG       Match=0;
    SEARCH_CONTEXT Context;

    Context.FirstTime = TRUE;
    Context.Filter.FilterRoutine = NULL;
    Field[0] = '\0';
    if (args) {
        sscanf(args, "%x %19s %x", &RestartAddr, &Field, &Match);
    }
    if ((_stricmp(Field, "userevent") == 0) &&
        (Match != 0)) {
        Context.Filter.FilterRoutine = IrpFilterUserEvent;
        Context.Filter.FilterContext = (PVOID)Match;
        dprintf("Looking for IRP with UserEvent == %08lx\n",Match);
    } else if ((_stricmp(Field, "device") == 0) &&
        (Match != 0)) {
        Context.Filter.FilterRoutine = IrpFilterDevice;
        Context.Filter.FilterContext = (PVOID)Match;
        dprintf("Looking for IRPs with device object == %08lx\n",Match);
    } else if ((_stricmp(Field, "fileobject") == 0) &&
        (Match != 0)) {
        Context.Filter.FilterRoutine = IrpFilterFileObject;
        Context.Filter.FilterContext = (PVOID)Match;
        dprintf("Looking for IRPs with file object == %08lx\n",Match);
    } else if ((_stricmp(Field, "thread") == 0) &&
        (Match != 0)) {
        Context.Filter.FilterRoutine = IrpFilterThread;
        Context.Filter.FilterContext = (PVOID)Match;
        dprintf("Looking for IRPs with thread == %08lx\n",Match);
    } else if ((_stricmp(Field, "arg") == 0) &&
        (Match != 0)) {
        Context.Filter.FilterRoutine = IrpFilterArg;
        Context.Filter.FilterContext = (PVOID)Match;
        dprintf("Looking for IRPs with arg == %08lx\n",Match);
    }

    TagName = '?prI';

    SearchPool( TagName, (ULONG)RestartAddr, &CheckForIrp, &Context );
    return;
}


BOOLEAN
IrpFilterUserEvent(
    IN PIRP Irp,
    IN PVOID FilterContext
    )
/*++

Routine Description:

    Checks to see if the userevent field of an IRP matches the supplied
    parameter

Arguments:

    Irp - Supplies the irp to filter

    FilterContext - supplies the user event

Return Value:

    TRUE if the specified irp has userevent == FilterContext
    FALSE otherwise

--*/

{
    PKEVENT pEvent = (PKEVENT)FilterContext;

    if (Irp->UserEvent == pEvent) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


BOOLEAN
IrpFilterDevice(
    IN PIRP Irp,
    IN PVOID FilterContext
    )
/*++

Routine Description:

    Checks to see if the specified IRP matches the supplied
    device object

Arguments:

    Irp - Supplies the irp to filter

    FilterContext - supplies the device object

Return Value:

    TRUE if the specified irp has a device == FilterContext
    FALSE otherwise

--*/

{
    PIO_STACK_LOCATION IrpStack = (PIO_STACK_LOCATION)(Irp+1);
    LONG i;

    if (Irp->StackCount > 30) {
        return(FALSE);
    }

    for (i=0; i<Irp->StackCount; i++) {
        if (IrpStack[i].DeviceObject == FilterContext) {
            return(TRUE);
        }
    }
    return(FALSE);
}


BOOLEAN
IrpFilterFileObject(
    IN PIRP Irp,
    IN PVOID FilterContext
    )
/*++

Routine Description:

    Checks to see if the Tail.Overlay.OriginalFileObject field of an IRP matches the 
    supplied parameter

Arguments:

    Irp - Supplies the irp to filter

    FilterContext - supplies the file object

Return Value:

    TRUE if the specified irp has userevent == FilterContext
    FALSE otherwise

--*/

{
    PFILE_OBJECT pFile = (PFILE_OBJECT)FilterContext;

    if (Irp->Tail.Overlay.OriginalFileObject == pFile) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


BOOLEAN
IrpFilterThread(
    IN PIRP Irp,
    IN PVOID FilterContext
    )
/*++

Routine Description:

    Checks to see if the Tail.Overlay.OriginalFileObject field of an IRP matches the 
    supplied parameter

Arguments:

    Irp - Supplies the irp to filter

    FilterContext - supplies the file object

Return Value:

    TRUE if the specified irp has userevent == FilterContext
    FALSE otherwise

--*/

{
    PETHREAD pThread = (PETHREAD)FilterContext;

    if (Irp->Tail.Overlay.Thread == pThread) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


BOOLEAN
IrpFilterArg(
    IN PIRP Irp,
    IN PVOID FilterContext
    )
/*++

Routine Description:

    Checks to see if the specified IRP matches the supplied
    argument

Arguments:

    Irp - Supplies the irp to filter

    FilterContext - supplies the argument to match

Return Value:

    TRUE if the specified irp has argument == FilterContext
    FALSE otherwise

--*/

{
    PIO_STACK_LOCATION IrpStack = (PIO_STACK_LOCATION)(Irp+1);
    LONG i;

    if (Irp->StackCount > 30) {
        return(FALSE);
    }

    for (i=0; i<Irp->StackCount; i++) {
        if ((IrpStack[i].Parameters.Others.Argument1 == FilterContext) ||
            (IrpStack[i].Parameters.Others.Argument2 == FilterContext) ||
            (IrpStack[i].Parameters.Others.Argument3 == FilterContext) ||
            (IrpStack[i].Parameters.Others.Argument4 == FilterContext)) {
            return(TRUE);
        }
    }
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\kdexts.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    Wesley Witt (wesw) 26-Aug-1993

Environment:

    User Mode

--*/

#include "precomp.h"
#pragma hdrstop

#include <ntverp.h>
#include <dbghelp.h>

//
// globals
//
EXT_API_VERSION         ApiVersion = { (VER_PRODUCTVERSION_W >> 8), (VER_PRODUCTVERSION_W & 0xff), EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS   ExtensionApis;
ULONG                   STeip;
ULONG                   STebp;
ULONG                   STesp;
USHORT                  SavedMajorVersion;
USHORT                  SavedMinorVersion;

DBGKD_GET_VERSION32     KernelVersionPacket;


//
// this string is for supporting both the old and the new way of getting
// data from the kernel.  Maybe it will go away soon.
//
char ___SillyString[200];



DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
}

VOID
CheckVersion(
    VOID
    )
{
#if 0
    //
    // This check is broken. Even if it wasn't broken, it is way too annoying.
    //
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
#endif
}

BOOLEAN
IsCheckedBuild(
    PBOOLEAN Checked
    )
{
   USHORT majorVersion ;

   if (!HaveDebuggerData()) {

      //
      // Can't tell.
      //
      return FALSE ;
   }

   //
   // 0xC for checked, 0xF for free.
   //
   *Checked = (KernelVersionPacket.MajorVersion == 0xc) ;
   return TRUE ;
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

BOOL
HaveDebuggerData(
    VOID
    )
{
    static int havedata = 0;

    if (havedata == 0) {
        if (!Ioctl( IG_GET_KERNEL_VERSION, &KernelVersionPacket, sizeof(KernelVersionPacket))) {
            havedata = 2;
        } else if (KernelVersionPacket.MajorVersion == 0) {
            havedata = 2;
        } else {
            havedata = 1;
        }
    }

    return (havedata == 1) &&
           ((KernelVersionPacket.Flags & DBGKD_VERS_FLAG_DATA) != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\patch.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    assert.c

Abstract:

    WinDbg Extension Api

Author:

    Adrian J. Oney (adriao) 07-28-1998

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#include "patchp.h"
#pragma hdrstop

DECLARE_API( patch )

/*++

Routine Description:

    Implements !Patch, a handy way to set flags in binaries...

Arguments:

    None.

Return Value:

    None.

--*/

{
    PATCH_TREE patchTree ;
    PATCHSET PatchSet ;
    PDRIVERENTRY DriverPatches ;
    int i ;

    //
    // Build the patch tree
    //
    PatchBuildTree(&patchTree) ;

    PatchSet.InProgress = FALSE ;

    //
    // Look at the commandline, and either bring up help, the menu, or apply
    // any assertions passed in.
    //
    if (args[0]=='?') {

       dprintf("!Patch <patchname>[?] [<patchname>[?]*] [genreg]\n") ;
       dprintf("or !Patch with no parameters to bring up a menu of options.\n") ;

    } else if (args[0]=='!') {

       dprintf("*Commencing debug mode -\n") ;
       PatchTreePrint(&patchTree) ;
       dprintf("*  Building patch set\n") ;
       PatchSetBuild(&patchTree, ((char *) args)+1, &PatchSet) ;
       PatchSetPrint(&PatchSet) ;
       dprintf("*  Building mod set\n") ;
       DriverPatches = ModSetBuild(&PatchSet, TRUE) ;
       dprintf("*  Fixing up mod set\n") ;
       ModSetFixupAddresses(DriverPatches) ;
       ModSetPrint(DriverPatches) ;

    } else if (args[0]) {

       //
       // First, turn the options on the command-line into a link'd and sorted
       // set of asserts to process.
       //
       PatchSetBuild(&patchTree, (char *) args, &PatchSet) ;

       //
       // Now, compile a set of patches from that list.
       //
       DriverPatches = ModSetBuild(&PatchSet, FALSE) ;

       //
       // Now fix them up relative to the current symbol set
       //
       ModSetFixupAddresses(DriverPatches) ;

       //
       // Finally, slam them into memory.
       //
       if (ModSetApply(DriverPatches)) {

          dprintf("Patches applied.\n") ;
       }

    } else {

       PatchTreeMenuPrint(&patchTree) ;
    }

    PatchTreeFree(&patchTree) ;
    return;
}

//
// These functions walk an assertion tree.
//
VOID
PatchTreeWalk(
   PPATCH_TREE PatchTree,
   PPATCH_WALKCALLBACK PreCallback,
   PPATCH_WALKCALLBACK PostCallback,
   PVOID Context,
   BOOL ZeroWalkFlags
   )
{
   PPATCH_CATEGORY category, oldCategory ;

   if (ZeroWalkFlags) {

      PatchTreeWalk(
         PatchTree,
         PatchTreeWalkZeroFlags,
         NULL,
         NULL,
         FALSE
         ) ;
   }

   category = PatchTree->FirstCategory ;
   while(category) {

      if (PreCallback) {
         PreCallback(category, NULL, 0, Context) ;
      }
      if (category->Child) {

         PatchTreeWalkHelper(
            category->Child,
            PreCallback,
            PostCallback,
            1,
            Context
            ) ;
      }
      oldCategory = category ;
      category = category->Sibling ;
      if (PostCallback) {
         PostCallback(category, NULL, 0, Context) ;
      }
   }
}

VOID
PatchTreeWalkHelper(
   PPATCH_ENTRY Entry,
   PPATCH_WALKCALLBACK PreCallback,
   PPATCH_WALKCALLBACK PostCallback,
   ULONG Depth,
   PVOID Context
   )
{
   PPATCH_ENTRY nextEntry ;

   if (PreCallback) {
      PreCallback(NULL, Entry, Depth, Context) ;
   }

   if (Entry->Child) {
      PatchTreeWalkHelper(Entry->Child, PreCallback, PostCallback, Depth+1, Context) ;
   }

   nextEntry = Entry->Sibling ;
   if (PostCallback) {
      PostCallback(NULL, Entry, Depth, Context) ;
   }

   if (nextEntry) {
      PatchTreeWalkHelper(nextEntry, PreCallback, PostCallback, Depth, Context) ;
   }
}

VOID
PatchTreeWalkZeroFlags(
   PPATCH_CATEGORY  Category,
   PPATCH_ENTRY     Entry,
   ULONG            Depth,
   PVOID            Context
   )
{
   if (Entry) {
      Entry->WalkFlags = 0 ;
   }
}


//
// These functions free a given tree...
//
VOID
PatchTreeFreeCallback(
   PPATCH_CATEGORY  Category,
   PPATCH_ENTRY     Entry,
   ULONG            Depth,
   PVOID            Context
   )
{
   if (Category) {
      free(Category) ;
   }
   if (Entry) {
      if (Entry->Action) {
         free(Entry->Action) ;
      }
      free(Entry) ;
   }
}

VOID
PatchTreeFree(
   PPATCH_TREE PatchTree
   )
{
   PatchTreeWalk(PatchTree, NULL, PatchTreeFreeCallback, NULL, FALSE) ;
}

//
// These functions print out a given assertion tree...
//
VOID
AssertPrintListStyle(
   LIST_STYLE ListStyle
   )
{
   switch(ListStyle)
   {
      case LISTSTYLE_NONE:          dprintf("None") ;         break;
      case LISTSTYLE_EXCLUSIVE:     dprintf("Exclusive") ;    break;
      case LISTSTYLE_NON_EXCLUSIVE: dprintf("NonExclusive") ; break;
      default:                      dprintf("????") ;         break;
   }
}

VOID
PatchTreePrintCallback(
   PPATCH_CATEGORY  Category,
   PPATCH_ENTRY     Entry,
   ULONG            Depth,
   PVOID            Context
   )
{
   char szIndent[1024] ;

   if (Category) {

      dprintf("\nCategory: %x\n", Category) ;
      dprintf("  Category Name: %s\n", Category->CategoryName) ;
      dprintf("  ListStyle: ") ;
      AssertPrintListStyle(Category->ChildStyle) ;
      dprintf("\n") ;
      dprintf("  Sibling: %x  - Child: %x\n",
         Category->Sibling,
         Category->Child
         ) ;
   }

   if (Entry) {

      memset(szIndent, ' ', Depth*2) ;
      szIndent[Depth*2]='\0' ;

      dprintf("%sEntry: %x", szIndent, Entry) ;
      switch(Entry->EntryType) {
         case ENTRYTYPE_PATCH:
            dprintf(" (Patch)") ;
            break;
         case ENTRYTYPE_PATCH_COLLECTION:
            dprintf(" (Collection)") ;
            break;
      }
      dprintf("\n") ;
      dprintf("%s  Action: %s\n", szIndent, Entry->Action) ;
      dprintf("%s  Shortcut: %s\n", szIndent, Entry->ShortcutName) ;
      dprintf("%s  MenuDescription: %s\n", szIndent, Entry->MenuDescription) ;
      dprintf("%s  LengthyDescription: %s\n", szIndent, Entry->LengthyDescription) ;
      dprintf("%s  ListStyle: ", szIndent) ;
      AssertPrintListStyle(Entry->ChildStyle) ;
      dprintf("\n") ;
      dprintf("%s  WalkNext: %x  - WalkFlags: %x\n", szIndent,
         Entry->WalkNext, Entry->WalkFlags) ;
      dprintf("%s  Parent: %x  - Sibling: %x  - Child: %x\n", szIndent,
         Entry->Parent, Entry->Sibling, Entry->Child) ;
   }
}

VOID
PatchTreePrint(
   PPATCH_TREE PatchTree
   )
{
   PatchTreeWalk(PatchTree, PatchTreePrintCallback, NULL, NULL, FALSE) ;
}

VOID
PatchSetPrint(
   PPATCHSET PatchSet
   )
{
   PPATCH_ENTRY entry ;

   entry = PatchSet->PatchEntry ;
   dprintf("GenReg: %s\n", (PatchSet->GenReg) ? "TRUE" : "FALSE" ) ;

   while(entry) {
      ASSERT(entry->WalkFlags&1) ;
      PatchTreePrintCallback(NULL, entry, 0, NULL) ;
      entry = entry->WalkNext ;
   }
}

//
// These functions select a given set of items from an assertion tree.
//
VOID
PatchSetBuild(
   PPATCH_TREE PatchTree,
   char *szCommandLine,
   PPATCHSET PatchSet
   )
{
   char szTokenList[1024] ;
   char *szOffset ;
   char szGenReg[]=" GENREG " ; // Must be caps
   int i, j ;
   BOOL bOuterPass = FALSE ;

   //
   // Build a token list with ' ' on either side
   //
   i=strlen(szCommandLine) ;
   memcpy(szTokenList+1, szCommandLine, i) ;
   szTokenList[0]=' ' ;
   strcpy(szTokenList+1+i, " ") ;
   _strupr(szTokenList+1) ;

   PatchSet->TokenList = szTokenList ;
   if (PatchSet->InProgress == FALSE) {
      PatchSet->InProgress = TRUE ;
      PatchSet->PatchEntry = NULL ;
      PatchSet->PatchTree = PatchTree ;
      bOuterPass = TRUE ;
   }

   PatchTreeWalk(PatchTree, PatchSetBuildTreeCallback, NULL, PatchSet, bOuterPass) ;

   //
   // Now the list is built, look for any remaining tokens...
   //
   szOffset = strstr(PatchSet->TokenList, szGenReg) ;
   PatchSet->GenReg = (szOffset != NULL) ;
   while(szOffset) {
      memset(szOffset, ' ', sizeof(szGenReg)) ;
      szOffset = strstr(PatchSet->TokenList, szGenReg) ;
   }

   //
   // Any tokens remaining?
   //
   szOffset = strtok(PatchSet->TokenList, " ") ;
   while(szOffset&&bOuterPass) {
      //
      // This token was *not* found...
      //
      dprintf("Could not find !Patch %s, mispelling perhaps?\n", szOffset) ;
      szOffset = strtok(NULL, " ") ;
   }

   PatchSet->TokenList = NULL ;
}

VOID
PatchSetBuildTreeCallback(
   PPATCH_CATEGORY  Category,
   PPATCH_ENTRY     Entry,
   ULONG            Depth,
   PVOID            Context
   )
{
   PPATCHSET patchSet = (PPATCHSET) Context ;
   char *szOffset ;
   char szToken[1024] ;
   int i ;

   if ((!Entry)||
       ((Entry->EntryType!=ENTRYTYPE_PATCH)&&
        (Entry->EntryType!=ENTRYTYPE_PATCH_COLLECTION))||
       (!Entry->ShortcutName)||
       (Entry->WalkFlags&1)) {

      //
      // If not an assert, no shortcut, or previously marked, bail
      //
      return ;
   }

   //
   // Our token list is guarenteed to have two spaces on either edge, as is
   // each shortcut name...
   //
   strcpy(szToken, Entry->ShortcutName) ;
   i=strlen(szToken) ;
   _strupr(szToken) ;
   ASSERT(szToken[0]==' ') ;
   ASSERT(szToken[i-1]==' ') ;
   ASSERT(patchSet->TokenList[0]==' ') ;
   ASSERT(patchSet->TokenList[strlen(patchSet->TokenList)-1]==' ') ;

   szOffset = strstr(patchSet->TokenList, szToken) ;

   if (!szOffset) {

      //
      // This token wasn't in the list. Quickly see this is a request for
      // more information.
      //
      szToken[i-1]='?' ;
      szToken[i+0]=' ' ;
      szToken[i+1]='\0' ;

      //dprintf("> [ %s %s ]\n", patchSet->TokenList, szToken) ;
      szOffset = strstr(patchSet->TokenList, szToken) ;
      if (szOffset) {

         do {
            memset(szOffset, ' ', i) ; // doesn't need to be i+1
            szOffset = strstr(patchSet->TokenList, szToken) ;
         } while(szOffset) ;

         PatchSetBuildTreeCallback2(Entry, patchSet, Entry->EntryType, TRUE) ;
      }

      return ;
   }

   //
   // Token was found. Wipe out that entry from the token list...
   //
   while(szOffset) {
      memset(szOffset, ' ', i) ;
      szOffset = strstr(patchSet->TokenList, szToken) ;
   }

   PatchSetBuildTreeCallback2(Entry, patchSet, Entry->EntryType, FALSE) ;
}

VOID
PatchSetBuildTreeCallback2(
   PPATCH_ENTRY     Entry,
   PPATCHSET        PatchSet,
   ENTRY_TYPE       EntryType,
   BOOL             IsQuestion
   )
{
   PPATCH_ENTRY childEntry, parentEntry, *nextEntry ;
   char szToken[1024] ;
   char *szLastTokenList ;
   int i ;

   if (IsQuestion) {

      //
      // The user typed in !Patch foo? Help tell our user about this assert.
      //
      dprintf("!Patch%s- %s\n",
         Entry->ShortcutName,
         Entry->MenuDescription
         ) ;

      if (Entry->LengthyDescription) {
         dprintf("\n%s\n", Entry->LengthyDescription) ;
      }
      if (Entry->EntryType==ENTRYTYPE_PATCH_COLLECTION) {
         dprintf("\nThe following are enabled by !Patch%s- %s\n",
            Entry->ShortcutName,
            Entry->Action
            ) ;
      } else {
         dprintf("\nPatch: %s\n", Entry->Action) ;
      }

      parentEntry = Entry->Parent ;
      if (parentEntry) {
         dprintf("The following asserts are also automatically applied:") ;
         //
         // There could be a collection in the list, but we won't bother
         // expanding those...
         //
         do {

            if (parentEntry->ShortcutName) {
               strcpy(szToken, parentEntry->ShortcutName) ;
               i=strlen(szToken) ;
               szToken[i-1]='\0' ;
               dprintf("%s", szToken) ;
            }
            parentEntry = parentEntry->Parent ;
         } while(parentEntry) ;
         dprintf("\n") ;
      }
      return ;
   }

   //
   // Mark it found.
   //
   Entry->WalkFlags|=1 ;
   Entry->WalkNext = NULL ;
   //dprintf("[ Marking %s ]\n", Entry->ShortcutName) ;

   //
   // Process any collections...
   //
   if (Entry->EntryType==ENTRYTYPE_PATCH_COLLECTION) {

      szLastTokenList = PatchSet->TokenList ;
      PatchSetBuild(PatchSet->PatchTree, Entry->Action, PatchSet) ;
      PatchSet->TokenList = szLastTokenList ;
   }

   //
   // Link it and its' ancestors in if that is not already done...
   //
   parentEntry = Entry->Parent ;
   childEntry = Entry ;
   while(parentEntry&&(!(parentEntry->WalkFlags&1))) {

      parentEntry->WalkNext = childEntry ;
      parentEntry->WalkFlags |= 1 ;
      //dprintf("[ Marking %s .]\n", parentEntry->ShortcutName) ;
      childEntry = parentEntry ;
      parentEntry = parentEntry->Parent ;
   }

   //
   // Add this to the list...
   //
   nextEntry = &PatchSet->PatchEntry ;
   while(*nextEntry) {
      nextEntry = (PPATCH_ENTRY *) (&(*nextEntry)->WalkNext) ;
   }
   *nextEntry = childEntry ;
}


PDRIVERENTRY
ModSetBuild(
   PPATCHSET PatchSet,
   BOOL DebugMode
   )
{
   PPATCH_ENTRY patchEntry ;
   PDRIVERENTRY driverPatchList = NULL, driver ;
   PDRIVERENTRY *driverTail ;
   char szModuleName[512] ;
   DRIVERMOD driverPatch ;
   PDRIVERMOD patch, *patchTail ;
   ULONG ulMore ;

   patchEntry = PatchSet->PatchEntry ;
   ulMore = 0 ;
   while(patchEntry) {

      if (DebugMode) {
         dprintf("Trying patch entry %x delta %x\n", patchEntry, ulMore) ;
      }
      if ((patchEntry->EntryType == ENTRYTYPE_PATCH)&&
          ModEntryParse(patchEntry->Action, DebugMode, szModuleName, &driverPatch, &ulMore)) {

         if (DebugMode) {
            dprintf("Parsed: %s\n", szModuleName) ;
            dprintf("  Symbol:  %s\n", driverPatch.szSymbolicName) ;
            dprintf("  Flags:   %x\n", driverPatch.PatchFlags) ;
            dprintf("  AndMask: %x\n", driverPatch.AndPatch) ;
            dprintf("  OrMask:  %x\n", driverPatch.OrPatch) ;
         }

         driver = driverPatchList;
         driverTail = &driverPatchList ;
         while(driver) {
            driverTail = &driver->Sibling ;
            if (!_stricmp(szModuleName, driver->szModuleName)) {
               break;
            }
            driver = driver->Sibling ;
         }
         if (!driver) {
            driver = (PDRIVERENTRY) malloc(sizeof(DRIVERENTRY)) ;
            strcpy(driver->szModuleName, szModuleName) ;
            driver->FirstPatch = NULL ;
            driver->Sibling = NULL ;
            driver->Checksum = 0 ;
            *driverTail = driver ;
            driverTail = &driver->Sibling ;
         }
         patch = driver->FirstPatch ;
         patchTail = &driver->FirstPatch ;
         while(patch) {
            patchTail = &patch->Sibling ;
            if (!_stricmp(driverPatch.szSymbolicName, patch->szSymbolicName)) {
               break;
            }
            patch = patch->Sibling ;
         }
         if (!patch) {
            patch = (PDRIVERMOD) malloc(sizeof(DRIVERMOD)) ;
            *patch = driverPatch ;
            patch->Sibling = NULL ;
            *patchTail = patch ;
            patchTail = &patch->Sibling ;
         } else {
            ModEntryMerge(patch, &driverPatch) ;
         }
         if (DebugMode) {
            ModSetPrint(driverPatchList) ;
         }
      }
      if (!ulMore) {
         patchEntry = (PPATCH_ENTRY) patchEntry->WalkNext ;
      }
   }
   return driverPatchList ;
}

BOOL
ModEntryParse(
   char *Action,
   BOOL DebugMode,
   char *szModuleDestination,
   PDRIVERMOD DriverPatchDest,
   PULONG pulMore
   )
{
   char *szOffset, *szOffset2 ;
   ULONG patchFlags, patchValue ;
   char szAction[1024], c ;
   int i, j ;

   if (!Action) {
      *pulMore = 0 ;
      return FALSE ;
   }
   strcpy(szAction, Action+*pulMore) ;
   if (DebugMode) {
      dprintf("Parsing %s\n", szAction) ;
   }
   szOffset = strtok(szAction, " !") ;
   if (!szOffset) {
      dprintf("Parse fail (1)\n") ;
      *pulMore = 0 ;
      return FALSE ;
   }

   //dprintf(":%s\n", szOffset) ;

   if      (!_stricmp(szOffset, "eb")) patchFlags = PATCHFLAG_BYTE_PATCH ;
   else if (!_stricmp(szOffset, "ew")) patchFlags = PATCHFLAG_WORD_PATCH ;
   else if (!_stricmp(szOffset, "ed")) patchFlags = PATCHFLAG_DWORD_PATCH ;
   else                                patchFlags = PATCHVALUE_INVALID ;

   if (patchFlags!=PATCHVALUE_INVALID) {
      szOffset = strtok(NULL, "!") ;
      //dprintf(":%s\n", szOffset) ;
   } else {
      patchFlags = PATCHFLAG_DWORD_PATCH ;
   }

   strcpy(szModuleDestination, szOffset) ;
   szOffset+=strlen(szOffset)+1 ;
   i = strcspn(szOffset, "|=& ") ;
   if (!szOffset[i]) {
      dprintf("Parse fail (2)\n") ;
      *pulMore = 0 ;
      return FALSE ;
   }

   strncpy(DriverPatchDest->szSymbolicName, szOffset, i) ;
   DriverPatchDest->szSymbolicName[i]='\0' ;
   //dprintf(":%s\n", DriverPatchDest->szSymbolicName) ;

   szOffset+=i+1 ;
   i = strcspn(szOffset, " 1234567890ABCDEFabcdef") ;

   c=szOffset[i] ;
   szOffset[i]='\0' ;
   //dprintf(":%s\n", szOffset) ;

   if (!c) {
      dprintf("Parse fail (3)\n") ;
      *pulMore = 0 ;
      return FALSE ;
   }

   szOffset2 = strtok(szOffset, " ") ;
   if (!szOffset2) {
      dprintf("Parse fail (4)\n") ;
      *pulMore = 0 ;
      return FALSE ;
   }

   if      (!strcmp(szOffset2, "|=")) j=0 ;
   else if (!strcmp(szOffset2, "&=")) j=1 ;
   else if (!strcmp(szOffset2, "=" )) j=2 ;
   else {
      dprintf("Parse fail (5)\n") ;
      *pulMore = 0 ;
      return FALSE ;
   }

   szOffset[i]=c ;
   if (sscanf(szOffset+i, "%x", &patchValue)!=1) {
      dprintf("Parse fail (6)\n") ;
      *pulMore = 0 ;
      return FALSE ;
   }
   szOffset+=i ;
   i = strcspn(szOffset, ";") ;
   if (szOffset[i]&&szOffset[i+1]) {
      *pulMore = *pulMore + szOffset - szAction + i+1 ;
   } else {
      *pulMore = 0 ;
   }

   switch(j) {

      case 0:
         DriverPatchDest->AndPatch = 0xFFFFFFFF ;
         DriverPatchDest->OrPatch = patchValue ;
         break;

      case 1:
         DriverPatchDest->AndPatch = patchValue ;
         DriverPatchDest->OrPatch =  0 ;
         break;

      case 2:
         DriverPatchDest->AndPatch = 0 ;
         DriverPatchDest->OrPatch =  patchValue ;
         break;
   }
   DriverPatchDest->ulModuleOffset = 0 ;
   DriverPatchDest->PatchFlags = patchFlags ;
   return TRUE ;
}

VOID
ModEntryMerge(
   PDRIVERMOD DriverPatchDest,
   PDRIVERMOD DriverPatchNew
   )
{
   ASSERT(PATCHFLAG_BYTE_PATCH == sizeof(BYTE)-1) ;
   ASSERT(PATCHFLAG_WORD_PATCH == sizeof(WORD)-1) ;
   ASSERT(PATCHFLAG_DWORD_PATCH == sizeof(DWORD)-1) ;

   while(APPLIED_PATCH_SIZE(DriverPatchDest) < APPLIED_PATCH_SIZE(DriverPatchNew)) {

      //
      // Promote the destination
      //
      DriverPatchDest->PatchFlags++ ;
      DriverPatchDest->AndPatch <<= 8 ;
      DriverPatchDest->AndPatch |= 0xFF ;
      DriverPatchDest->OrPatch <<= 8 ;
   }

   if (!DriverPatchNew->AndPatch) {
      //
      // It's a set, just obliterate the previous OR mask...
      //
      DriverPatchDest->OrPatch = 0 ;
   }

   DriverPatchDest->AndPatch &= DriverPatchNew->AndPatch ;
   DriverPatchDest->OrPatch |= DriverPatchNew->OrPatch ;
}

VOID
ModSetPrint(
   PDRIVERENTRY DriverPatchHead
   )
{
   PDRIVERENTRY driver = DriverPatchHead ;
   PDRIVERMOD patch ;

   while(driver) {
      dprintf("Driver: %s  Checksum: %x  Base: %x\n", driver->szModuleName, driver->Checksum, driver->BaseAddress) ;
      patch = driver->FirstPatch ;
      while(patch) {
         dprintf("  Symbol:  %s\n", patch->szSymbolicName) ;
         dprintf("  Offset:  %x\n", patch->ulModuleOffset) ;
         dprintf("  Flags:   %x\n", patch->PatchFlags) ;
         dprintf("  AndMask: %x\n", patch->AndPatch) ;
         dprintf("  OrMask:  %x\n", patch->OrPatch) ;
         patch=patch->Sibling ;
      }
      driver=driver->Sibling ;
   }
}

VOID
ModSetFixupAddresses(
   PDRIVERENTRY DriverPatchHead
   )
{
   PDRIVERENTRY driver = DriverPatchHead ;
   PDRIVERMOD patch ;
   ULONG displacement, checksum ;
   PVOID address, baseAddress ;
   char szVariableName[512] ;

   while(driver) {
      patch = driver->FirstPatch ;
      while(patch) {

         //
         // First get the virtual address. We do this because we can't simply
         // get an offset.
         //
         sprintf(szVariableName, "%s!%s", driver->szModuleName, patch->szSymbolicName) ;
         address = (PVOID) GetExpression( szVariableName );

         if (address) {
            if (ModSetGetDriverInfo(driver->szModuleName, &baseAddress, &checksum)) {
               driver->Checksum = checksum ;
               driver->BaseAddress = (ULONG) baseAddress ;
               patch->ulModuleOffset = (PUCHAR) address - (PUCHAR) baseAddress ;
               patch->PatchFlags |= PATCHFLAG_FIXUPS_COMPLETE ;
            }
         } else {
            dprintf("Couldn't resolve symbol %s, try !reload maybe?\n", szVariableName) ;
         }
         patch=patch->Sibling ;
      }
      driver=driver->Sibling ;
   }
}

BOOL
ModSetGetDriverInfo(
   char *szModuleName,
   PVOID *ModuleBaseAddress,
   PULONG Checksum
   )
{
   LIST_ENTRY List;
   PLIST_ENTRY Next;
   ULONG ListHead;
   ULONG Result;
   PLDR_DATA_TABLE_ENTRY DataTable;
   LDR_DATA_TABLE_ENTRY DataTableBuffer;
   WCHAR UnicodeBuffer[128];
   char szNtos[]="ntoskrnl" ;
   char szFilename[260] ;
   char *pszDot ;
   IMAGE_DOS_HEADER DosHeader;
   ULONG cb;
   ULONG Offset;
   IMAGE_NT_HEADERS imageNtHeaders;
   PIMAGE_FILE_HEADER imageFileHdr;
   PIMAGE_OPTIONAL_HEADER imageOptionalHdr;

   //
   // Adjust for "nt" passed in by our caller, who means ntoskrnl
   //
   if (!_strcmpi(szModuleName, "nt")) {
      szModuleName = szNtos ;
   }

   ListHead = GetNtDebuggerData( PsLoadedModuleList );

   if (!ListHead) {
      dprintf("Couldn't get offset of PsLoadedModuleListHead\n");
      return FALSE;
   } else {
      if ((!ReadMemory((DWORD)ListHead,
                       &List,
                       sizeof(LIST_ENTRY),
                       &Result)) || (Result < sizeof(LIST_ENTRY))) {
         dprintf("Unable to get value of PsLoadedModuleListHead\n");
         return FALSE;
      }
   }

   Next = List.Flink;
   if (Next == NULL) {
      dprintf("PsLoadedModuleList is NULL!\n");
      return FALSE;
   }

   while ((ULONG)Next != ListHead) {

      DataTable = CONTAINING_RECORD(Next,
                                    LDR_DATA_TABLE_ENTRY,
                                    InLoadOrderLinks);
      if ((!ReadMemory((DWORD)DataTable,
                       &DataTableBuffer,
                       sizeof(LDR_DATA_TABLE_ENTRY),
                       &Result)) || (Result < sizeof(LDR_DATA_TABLE_ENTRY))) {
         dprintf("Unable to read LDR_DATA_TABLE_ENTRY at %08lx\n",
                 DataTable);
         return FALSE;
      }

      //
      // Get the base DLL name.
      //
      if ((!ReadMemory((DWORD)DataTableBuffer.BaseDllName.Buffer,
                       UnicodeBuffer,
                       DataTableBuffer.BaseDllName.Length,
                       &Result)) || (Result < DataTableBuffer.BaseDllName.Length)) {
         dprintf("Unable to read name string at %08lx\n",
                 DataTable);
         return FALSE;
      }

      UnicodeBuffer[Result] = UNICODE_NULL ;

      //
      // Is this the driver we passed in?
      //
      sprintf(szFilename, "%S", UnicodeBuffer) ;
      pszDot = strchr(szFilename, '.') ;
      *pszDot = '\0' ;
      if (!_strcmpi(szFilename, szModuleName)) {

         //
         // We have a match, record the base and find the Checksum.
         //
         *ModuleBaseAddress = DataTableBuffer.DllBase ;

         if (!ReadMemory((DWORD) DataTableBuffer.DllBase, &DosHeader, sizeof(DosHeader), &cb)) {
            dprintf("Can't read file header: error == %d\n", GetLastError());
            return FALSE ;
         }

         if (cb != sizeof(DosHeader) || DosHeader.e_magic != IMAGE_DOS_SIGNATURE) {
            dprintf("No file header.\n");
            return FALSE;
         }

         Offset = ((ULONG) DataTableBuffer.DllBase) + DosHeader.e_lfanew;

         if (!ReadMemory((DWORD) Offset, &imageNtHeaders, sizeof(imageNtHeaders), &cb)) {
            dprintf("Can't read optional header: error == %d\n", GetLastError());
            return FALSE;
         }

         if (cb != sizeof(imageNtHeaders)) {
             dprintf("Bad file header.\n");
             return FALSE;
         }

         imageFileHdr = &imageNtHeaders.FileHeader;
         imageOptionalHdr = &imageNtHeaders.OptionalHeader;

         if (imageFileHdr->SizeOfOptionalHeader != sizeof(IMAGE_OPTIONAL_HEADER)) {
            dprintf("Cannot get Checksum, invalid optional header.\n");
            return FALSE;
         }

         *Checksum = imageOptionalHdr->CheckSum ;
         return TRUE ;
      }

      Next = DataTableBuffer.InLoadOrderLinks.Flink;
   }
   dprintf("Unable to locate module %s\n", szModuleName) ;
   return FALSE ;
}

BOOL
ModSetApply(
   PDRIVERENTRY DriverPatchHead
   )
{
   PDRIVERENTRY driver = DriverPatchHead ;
   PDRIVERMOD patch ;
   ULONG displacement, checksum ;
   PVOID address, baseAddress ;
   ULONG Results, patchAddress ;
   BOOL bSuccess ;
   BYTE bytePatch ;
   WORD wordPatch ;
   DWORD dwordPatch ;
   BOOL appliedAtLeastOnePatch = FALSE ;

   while(driver) {
      patch = driver->FirstPatch ;
      while(patch) {

         if (patch->PatchFlags&PATCHFLAG_FIXUPS_COMPLETE) {

            patchAddress = (driver->BaseAddress + patch->ulModuleOffset) ;

            if (patch->AndPatch) {

               switch(APPLIED_PATCH_SIZE(patch)) {

                  case PATCHFLAG_BYTE_PATCH:
                     bSuccess = (ReadMemory((DWORD) patchAddress, &bytePatch, sizeof(BYTE), &Results)&&
                                 (Results == sizeof(BYTE))) ;
                     bytePatch &= (BYTE) (patch->AndPatch&0xFF) ;
                     break;

                  case PATCHFLAG_WORD_PATCH:
                     bSuccess = (ReadMemory((DWORD) patchAddress, &wordPatch, sizeof(WORD), &Results)&&
                                 (Results == sizeof(WORD))) ;
                     wordPatch &= (WORD) (patch->AndPatch&0xFFFF) ;
                     break;

                  case PATCHFLAG_DWORD_PATCH:
                     bSuccess = (ReadMemory((DWORD) patchAddress, &dwordPatch, sizeof(DWORD), &Results)&&
                                 (Results == sizeof(DWORD))) ;
                     dwordPatch &= (DWORD) patch->AndPatch ;
                     break;

                  default:
                     bSuccess = FALSE ;
               }

            } else {

               bytePatch = 0 ;
               wordPatch = 0 ;
               dwordPatch = 0 ;
               bSuccess = TRUE ;
            }

            if (!bSuccess) {
               dprintf("Cannot patch %s!%s, read failed\n", driver->szModuleName, patch->szSymbolicName);

            } else {

               switch(APPLIED_PATCH_SIZE(patch)) {

                  case PATCHFLAG_BYTE_PATCH:
                     bytePatch |= (BYTE) (patch->OrPatch&0xFF) ;
                     bSuccess = (WriteMemory( (ULONG)patchAddress, &bytePatch, sizeof(BYTE), &Results ) &&
                        (Results == sizeof(BYTE))) ;
                     break;

                  case PATCHFLAG_WORD_PATCH:
                     wordPatch |= (WORD) (patch->OrPatch&0xFFFF) ;
                     bSuccess = (WriteMemory( (ULONG)patchAddress, &wordPatch, sizeof(WORD), &Results ) &&
                        (Results == sizeof(WORD))) ;
                     break;

                  case PATCHFLAG_DWORD_PATCH:
                     dwordPatch |= (DWORD) patch->OrPatch ;
                     bSuccess = (WriteMemory( (ULONG)patchAddress, &dwordPatch, sizeof(DWORD), &Results ) &&
                        (Results == sizeof(DWORD))) ;
                     break;

                  default:
                     bSuccess = FALSE ;
               }

               if (!bSuccess) {
                  dprintf("Cannot patch %s!%s, write failed\n", driver->szModuleName, patch->szSymbolicName);
               }
            }

            appliedAtLeastOnePatch |= bSuccess ;
         }

         patch=patch->Sibling ;
      }
      driver=driver->Sibling ;
   }
   return appliedAtLeastOnePatch ;
}

VOID
PatchTreeMenuPrintCallback(
   PPATCH_CATEGORY  Category,
   PPATCH_ENTRY     Entry,
   ULONG            Depth,
   PVOID            Context
   )
{
   char szIndent[1024] ;
   int i ;

   if (Category) {

      dprintf("\nCategory: %s\n", Category->CategoryName) ;
      i=strlen(Category->CategoryName) ;
      i+=sizeof("Category: ") ;
      while(--i) dprintf("-") ;
      dprintf("\n") ;
   }

   if (Entry) {

      memset(szIndent, ' ', Depth*2) ;
      szIndent[Depth*2]='\0' ;

      if (Entry->ShortcutName) {

         dprintf("%s!Patch%s- %s\n",
            szIndent,
            Entry->ShortcutName,
            Entry->MenuDescription
            ) ;
      } else {

         dprintf("%s%s\n",
            szIndent,
            Entry->MenuDescription
            ) ;
      }

      if (Entry->ChildStyle == LISTSTYLE_EXCLUSIVE) {
         dprintf("%s  And up to one of:\n", szIndent) ;
      }
   }
}

VOID
PatchTreeMenuPrint(
   PPATCH_TREE PatchTree
   )
{
   PatchTreeWalk(PatchTree, PatchTreeMenuPrintCallback, NULL, NULL, FALSE) ;
   dprintf("\n") ;
   dprintf("Selecting an indented assert automatically enables all higher asserts\n") ;
   dprintf("Type !Patch <assertname>? to get more information on an assert.\n") ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\ohcd.cpp ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    OHCD.cpp

Abstract:

    WinDbg Extension Api

Author:

    Mitchell Dernis (mitchd) 10/11/2000

Environment:

    User Mode.

Revision History:

--*/

#define _NTSYSTEM_
#include "api.h"
#include "x86api.h"
#include <usbd.h>

#define OHCD_ISOCHRONOUS_SUPPORTED
extern "C"
{
    #include <ohcd.h>
    #include <isoch.h>
}

struct KD_OHCD_ENDPOINT
{
    ULONG  OriginalAddress;
    ULONG  Flags;
    ULONG  ScheduleIndex; // Periodic Only
    ULONG  ScheduleOrder; // All lists.
    union {
        OHCD_ENDPOINT       Endpoint;
        OHCD_ISOCH_ENDPOINT IsochEndpoint;
    };
};

#define KDEPF_CONTROL_LIST          0x00000001
#define KDEPF_BULK_LIST             0x00000002
#define KDEPF_PERIODIC_TABLE        0x00000004
#define KDEPF_PENDING_CLOSE_LIST    0x00000008
#define KDEPF_NOT_IN_PHYSICAL_LIST  0x00000010
#define KDEPF_NOT_IN_VIRTUAL_LIST   0x00000020
#define KDEPF_WRONG_PHYSICAL_LIST   0x00000040
#define KDEPF_WRONG_LIST_TYPE       0x00000080
#define KDEPF_WRONG_PERIODIC_TYPE   0x00000100
#define KDEPF_BAD_ENDPOINT          0x00000200

UCHAR g_DeviceTreeBuffer[sizeof(CDeviceTree)];
CDeviceTree *g_pDeviceTree;
IUsbDevice  *g_pDevices;
USBD_HOST_CONTROLLER     *g_pUsbdHostController;
OHCD_DEVICE_EXTENSION    *g_pOhcdExtension;
OHCI_OPERATIONAL_REGISTERS  g_OperationalRegisters;
OHCI_HCCA                 g_HCCA;
#define MAX_ENDPOINTS_EXPECTED 150
KD_OHCD_ENDPOINT          g_EndpointBuffer[MAX_ENDPOINTS_EXPECTED];
ULONG                     g_EndpointCount;

UCHAR g_HcBuffer[sizeof(USBD_HOST_CONTROLLER)+sizeof(OHCD_DEVICE_EXTENSION)];

//
//  Bandwidth expected at each node in the schedule
//

ULONG g_ExpectedBandwidth[64];
ULONG g_ExpectedChildrenBandwidth[64];
ULONG g_ExpectedParentBandwidth[64];

//
//  Forward Declarations
//
void DumpHostController(ULONG ulHC);
void FindEndpoints();
void DumpEndpoints();
ULONG OHCD_CalculateBandwidth(ULONG MaxPacketSize, BOOL LowSpeed, BOOL Isoch);
void PerformBandwidthCheck();

//
// USBD function definitions
//

DECLARE_API( ohcd )

/*++

Routine Description:

  Validates and dumps the endpoint schedule.

  1) The physical address schedule is validated against the virtual address
  schedule, descrepencies are noted.

  2) Function addresses are validated against the free address list,
  and against the device tree.

  3) Checks the bandwidth data in the schedule for internal consistency.  Reports
  problems.  Including dumping important register information.

  4) Dumps all the endpoints in the transfer schedule.  They are displayed sorted first by
  Function Address and then by endpoint address.  Fairly complete information is provided.

  5) Checks and dumps the number of endpoints in the preallocated list.
  
  6) Summary of types of corruption found.


Arguments:

    args - flags

Return Value:

    None

--*/

{
    UNREFERENCED_PARAMETER (dwProcessor);
    UNREFERENCED_PARAMETER (dwCurrentPc);
    UNREFERENCED_PARAMETER (hCurrentThread);
    UNREFERENCED_PARAMETER (hCurrentProcess);
    UNREFERENCED_PARAMETER (args);
    
    //
    //  Dump Title Header
    //
    dprintf("OpenHCD Endpoint Schedule and Information Dump-----\n");
    
    //
    // First find and load the device tree, it is the only global
    // we can start walking from.
    //

    ULONG ulDeviceTreeAddress = GetExpression( "g_DeviceTree" );
    if(!ulDeviceTreeAddress)
    {
        dprintf("Could not find xapi!g_DeviceTree\n");
        return;
    }

    //
    //  Read in the device tree
    //
    if(FALSE == ReadMemory(ulDeviceTreeAddress, (PVOID)g_DeviceTreeBuffer, sizeof(CDeviceTree), NULL))
    {
       dprintf("Error reading device tree.\n");
       return;
    }
    g_pDeviceTree = (CDeviceTree *)g_DeviceTreeBuffer;

    //
    //  Read in the devices (we need these to find the host controllers,
    //  and later to verify that endpoint address are used by actual
    //  devices.)
    //

    g_pDevices = (IUsbDevice *) new UCHAR[g_pDeviceTree->m_NodeCount*sizeof(IUsbDevice)];
    if(NULL == g_pDevices)
    {
        dprintf("Couldn't allocate memory for XPP devices.");
    }
    
    if(FALSE == ReadMemory((ULONG)g_pDeviceTree->m_Devices, (PVOID)g_pDevices, g_pDeviceTree->m_NodeCount*sizeof(IUsbDevice), NULL))
    {
       dprintf("Error reading devices.\n");
       return;
    }

    //
    //  Count Host Controllers (The first nodes of the
    //  tree would be root hubs
    ULONG ulHostControllerCount = 0;
    while(UDN_TYPE_ROOT_HUB == g_pDevices[ulHostControllerCount].m_Type)
    {
        ulHostControllerCount++;
    }
    dprintf("Host Controllers Found: %d\n", ulHostControllerCount);
    for(ULONG i=0; i<ulHostControllerCount; i++)
    {
        DumpHostController(i);
    }

    //
    //  Free any buffers allocated during this call.
    //
    delete g_pDevices;
}

void DumpHostController(ULONG ulHC)
{

    ULONG ulHCAddress = (ULONG) g_pDevices[ulHC].m_HostController;
    dprintf("--Host Controller @0x%0.8x----------------------\n", ulHCAddress);

    //
    //  Read in the host controller info (The USBD and OHCD portions are one
    //  big block.
    //
    if(FALSE == ReadMemory(ulHCAddress, (PVOID)g_HcBuffer, sizeof(USBD_HOST_CONTROLLER)+sizeof(OHCD_DEVICE_EXTENSION), NULL))
    {
       dprintf("Error reading host controller data.\n");
       return;
    }

    g_pUsbdHostController = (PUSBD_HOST_CONTROLLER)&g_HcBuffer;
    g_pOhcdExtension = (POHCD_DEVICE_EXTENSION)g_pUsbdHostController->HcdExtension;

    //
    //  Read in the OHCD operational registers
    //
    if(FALSE == ReadMemory((ULONG)g_pOhcdExtension->OperationalRegisters, (PVOID)&g_OperationalRegisters, sizeof(OHCI_OPERATIONAL_REGISTERS), NULL))
    {
       dprintf("Error reading operational registers.\n");
       return;
    }

    //
    //  Read in the HCCA area
    //
    if(FALSE == ReadMemory((ULONG)g_pOhcdExtension->HCCA, (PVOID)&g_HCCA, sizeof(OHCI_HCCA), NULL))
    {
       dprintf("Error reading HCCA data.\n");
       return;
    }
    
    //**
    //**  Now we can go on the endpoint hunt.
    //**  (As we find them, check that they appear in the physical
    //**  address table as well.)
    //**
    
    FindEndpoints();
    DumpEndpoints();
    PerformBandwidthCheck();
}


void FindEndpoints()
//
//  Walk all the lists, and read the endpoint data into our global array of endpoints.
//
{
    
    g_EndpointCount = 0;
    
    //
    //  Walk the control endpoint list
    //

    ULONG ulOrder = 0;
    ULONG ulEndpointAddress = (ULONG)g_pOhcdExtension->Schedule.ControlHead;
    while(ulEndpointAddress)
    {
        g_EndpointBuffer[g_EndpointCount].OriginalAddress = ulEndpointAddress;
        g_EndpointBuffer[g_EndpointCount].Flags = KDEPF_CONTROL_LIST;
        g_EndpointBuffer[g_EndpointCount].ScheduleOrder = ulOrder++;
        if(FALSE == ReadMemory(ulEndpointAddress, &g_EndpointBuffer[g_EndpointCount].Endpoint, sizeof(OHCD_ENDPOINT), NULL))
        {
            dprintf("Error Reading Endpoint in Control List: Bad Address (0x%0.8x)\n", ulEndpointAddress);
            g_EndpointBuffer[g_EndpointCount].Flags |= KDEPF_BAD_ENDPOINT;
            g_EndpointCount++;
            break;
        }
        ulEndpointAddress = (ULONG) g_EndpointBuffer[g_EndpointCount].Endpoint.Next;
        g_EndpointCount++;
        if(MAX_ENDPOINTS_EXPECTED == g_EndpointCount)
        {
            dprintf("Debug extension found more than %d endpoints.  Increase MAX_ENDPOINTS_EXPECTED and recompile kd extension dll.\n", MAX_ENDPOINTS_EXPECTED);
            return;
        }
    }

    //
    //  walk the bulk endpoint list
    //

    ulOrder = 0;
    ulEndpointAddress = (ULONG)g_pOhcdExtension->Schedule.BulkHead;
    while(ulEndpointAddress)
    {
        g_EndpointBuffer[g_EndpointCount].OriginalAddress = ulEndpointAddress;
        g_EndpointBuffer[g_EndpointCount].Flags = KDEPF_BULK_LIST;
        g_EndpointBuffer[g_EndpointCount].ScheduleOrder = ulOrder++;
        if(FALSE == ReadMemory(ulEndpointAddress, &g_EndpointBuffer[g_EndpointCount].Endpoint, sizeof(OHCD_ENDPOINT), NULL))
        {
            dprintf("Error Reading Endpoint in Bulk List: Bad Address (0x%0.8x)\n", ulEndpointAddress);
            g_EndpointBuffer[g_EndpointCount].Flags |= KDEPF_BAD_ENDPOINT;
            g_EndpointCount++;
            break;
        }
        ulEndpointAddress = (ULONG) g_EndpointBuffer[g_EndpointCount].Endpoint.Next;
        g_EndpointCount++;
        if(MAX_ENDPOINTS_EXPECTED == g_EndpointCount)
        {
            dprintf("Debug extension found more than %d endpoints.  Increase MAX_ENDPOINTS_EXPECTED and recompile kd extension dll.\n", MAX_ENDPOINTS_EXPECTED);
            return;
        }
    }
    
    //
    //  walk the periodic schedule table.
    //

    //  Loop over all the nodes.
    for(int nodeIndex = 0; nodeIndex < 64; nodeIndex++)
    {
        ulOrder = 0;
        ulEndpointAddress = (ULONG)g_pOhcdExtension->Schedule.InterruptSchedule[nodeIndex].EndpointHead;
        g_ExpectedBandwidth[nodeIndex] = 0;
        while(ulEndpointAddress)
        {
            g_EndpointBuffer[g_EndpointCount].OriginalAddress = ulEndpointAddress;
            g_EndpointBuffer[g_EndpointCount].Flags = KDEPF_PERIODIC_TABLE;
            g_EndpointBuffer[g_EndpointCount].ScheduleOrder = ulOrder++;
            g_EndpointBuffer[g_EndpointCount].ScheduleIndex = nodeIndex;
            if(0==nodeIndex)
            {
                ULONG ulLength;
                if(FALSE == ReadMemory(ulEndpointAddress, &g_EndpointBuffer[g_EndpointCount].IsochEndpoint, sizeof(OHCD_ISOCH_ENDPOINT), &ulLength))
                {
                    if(ulLength >= sizeof(OHCD_ENDPOINT) && (0==g_EndpointBuffer[g_EndpointCount].Endpoint.HcEndpointDescriptor.Control.Format))
                    {
                            dprintf("Error: Non-isoch endpoint (0x%0.8x) found in isoch node of schedule.\n", ulEndpointAddress);
                            g_EndpointBuffer[g_EndpointCount].Flags |= KDEPF_WRONG_PERIODIC_TYPE;
                    } else
                    {
                        dprintf("Error Reading Isoch Endpoint in Periodic Table: (0x%0.8x)\n", ulEndpointAddress);
                        g_EndpointBuffer[g_EndpointCount].Flags |= KDEPF_BAD_ENDPOINT;
                        g_EndpointCount++;
                        break;
                    }
                }
                
                g_ExpectedBandwidth[0] += OHCD_CalculateBandwidth(
                                                    (ULONG)g_EndpointBuffer[g_EndpointCount].Endpoint.HcEndpointDescriptor.Control.MaximumPacketSize,
                                                    g_EndpointBuffer[g_EndpointCount].Endpoint.HcEndpointDescriptor.Control.Speed,
                                                    TRUE
                                                    );


            } else
            {
                if(FALSE == ReadMemory(ulEndpointAddress, &g_EndpointBuffer[g_EndpointCount].Endpoint, sizeof(OHCD_ENDPOINT), NULL))
                {
                    dprintf("Error Reading Endpoint in Periodic Schedule(node = %d): Bad Address (0x%0.8x)\n", nodeIndex, ulEndpointAddress);
                    g_EndpointBuffer[g_EndpointCount].Flags |= KDEPF_BAD_ENDPOINT;
                    g_EndpointCount++;
                    break;
                }
                g_ExpectedBandwidth[nodeIndex] += OHCD_CalculateBandwidth(
                                                    (ULONG)g_EndpointBuffer[g_EndpointCount].Endpoint.HcEndpointDescriptor.Control.MaximumPacketSize,
                                                    g_EndpointBuffer[g_EndpointCount].Endpoint.HcEndpointDescriptor.Control.Speed,
                                                    FALSE
                                                    );
            }
            ULONG ulLastEndpointAddress = ulEndpointAddress;
            ulEndpointAddress = (ULONG) g_EndpointBuffer[g_EndpointCount].Endpoint.Next;

            //
            //  Check for errant tail pointer
            //

            if(ulLastEndpointAddress == (ULONG)g_pOhcdExtension->Schedule.InterruptSchedule[nodeIndex].EndpointTail)
            {
                if(0 != ulEndpointAddress)
                {
                    dprintf("Error: Node %d, the tail pointer points to an endpoint before the end of the list.\n",  nodeIndex);
                    dprintf("  Tail Pointer = 0x%0.8x, next endpoint is 0x%0.8x\n", g_pOhcdExtension->Schedule.InterruptSchedule[nodeIndex].EndpointTail, ulEndpointAddress);
                }
            } else
            {
                    if(0 == ulEndpointAddress)
                    {
                        dprintf("Error: Node %d, the list ends and the tail pointer does not point to it.\n",  nodeIndex);
                        dprintf("  Tail Pointer = 0x%0.8x\n", g_pOhcdExtension->Schedule.InterruptSchedule[nodeIndex].EndpointTail);
                    }
            }

            g_EndpointCount++;
        }
    }

    //
    //  walk the pending close urb list.
    //

    URB Urb;
    ULONG ulUrbAddress;
    ulUrbAddress = (ULONG)g_pOhcdExtension->PendingCloses;
    ulOrder = 0;
    while(ulUrbAddress)
    {
        if(FALSE == ReadMemory(ulUrbAddress, &Urb, sizeof(URB_CLOSE_ENDPOINT), NULL))
        {
            dprintf("Error Reading Urb (0x%0.8x), in PendingClose list\n", ulUrbAddress);
            break;
        }

        //
        //  Now try to read the endpoint that is being closed.
        //
        ulEndpointAddress = (ULONG)Urb.CloseEndpoint.EndpointHandle;
        
        g_EndpointBuffer[g_EndpointCount].OriginalAddress = ulEndpointAddress;
        g_EndpointBuffer[g_EndpointCount].Flags = KDEPF_PENDING_CLOSE_LIST;
        g_EndpointBuffer[g_EndpointCount].ScheduleOrder = ulOrder++;
        if(FALSE == ReadMemory(ulEndpointAddress, &g_EndpointBuffer[g_EndpointCount].Endpoint, sizeof(OHCD_ENDPOINT), NULL))
        {
            dprintf("Error Reading Endpoint (0x%0.8x), in Pending Close list\n", ulEndpointAddress);
            g_EndpointBuffer[g_EndpointCount].Flags |= KDEPF_BAD_ENDPOINT;
            // NO NEED TO BREAK, BECAUSE THE urb'S ARE LINKED NOT THE ENDPOINTS
        } else if(g_EndpointBuffer[g_EndpointCount].Endpoint.HcEndpointDescriptor.Control.Format)
        //
        //  if this was really an Isoch Endpoint, read the extra bytes
        //
        {
            if(FALSE == ReadMemory(ulEndpointAddress, &g_EndpointBuffer[g_EndpointCount].IsochEndpoint, sizeof(OHCD_ISOCH_ENDPOINT), NULL))
            {
                dprintf("Error Reading Isoch Endpoint (0x%0.8x), in Pending Close list\n", ulEndpointAddress);
                g_EndpointBuffer[g_EndpointCount].Flags |= KDEPF_BAD_ENDPOINT;
            }
        }
        g_EndpointCount++;
        ulUrbAddress = (ULONG) Urb.CloseEndpoint.HcdNextClose;
    }
}


char *EndpointTypeStrings[4]=
{
    "Control",
    "Isochronous",
    "Bulk",
    "Interrupt"
};

char *EndpointDirectionStrings[4]=
{
    " - Bidirectional",
    " - IN",
    " - OUT",
    " - Bidirectional"
};

void DumpEndpoints()
{
    for(ULONG i=0; i<g_EndpointCount; i++)
    {
        //
        //  Dump Information about the endpoint
        //

        dprintf("----------------------------------------------------\n");
        dprintf("Endpoint (0x%0.8x)\n", g_EndpointBuffer[i].OriginalAddress);
        dprintf("FunctionAddress = 0x%0.2x, EndpointAddress = 0x%0.2x\n", 
            (ULONG)g_EndpointBuffer[i].Endpoint.HcEndpointDescriptor.Control.FunctionAddress,
            (ULONG)g_EndpointBuffer[i].Endpoint.HcEndpointDescriptor.Control.EndpointAddress);
        dprintf("%s%s\n", 
            EndpointTypeStrings[g_EndpointBuffer[i].Endpoint.EndpointType],
            EndpointDirectionStrings[g_EndpointBuffer[i].Endpoint.HcEndpointDescriptor.Control.Direction]
            );
        if(0==g_EndpointBuffer[i].Endpoint.HcEndpointDescriptor.Control.Format)
        {
            if(g_EndpointBuffer[i].Endpoint.HcEndpointDescriptor.Control.Skip)
            {
                dprintf("Paused(%d,%d), ", g_EndpointBuffer[i].Endpoint.PendingPauseCount,g_EndpointBuffer[i].Endpoint.PauseFrame);
            }
            if(GET_HALTED(&g_EndpointBuffer[i].Endpoint.HcEndpointDescriptor))
            {
                dprintf("Halted, ");
            }
            if(GET_TOGGLECARRY(&g_EndpointBuffer[i].Endpoint.HcEndpointDescriptor))
            {
                dprintf("DATA1\n");
            } else
            {
                dprintf("DATA0\n");
            }
        }
        dprintf("%s, MaxPacket = %d Bytes\n", 
            (g_EndpointBuffer[i].Endpoint.HcEndpointDescriptor.Control.Speed) ? "LowSpeed" : "FullSpeed",
            (ULONG)g_EndpointBuffer[i].Endpoint.HcEndpointDescriptor.Control.MaximumPacketSize);
        dprintf("TDs in use = %d\n", (ULONG)g_EndpointBuffer[i].Endpoint.TDInUseCount);
        dprintf("URBs Queued = %d\n", (ULONG)g_EndpointBuffer[i].Endpoint.QueuedUrbCount);
        dprintf("URBs Programmed = %d\n", (ULONG)g_EndpointBuffer[i].Endpoint.ProgrammedUrbCount);
        
        //
        //  Dump Information about where the endpoint was found
        //  and any problems we found with it.
        //
        if(g_EndpointBuffer[i].Flags & KDEPF_PERIODIC_TABLE)
        {
            dprintf("Endpoint %d in periodic node %d\n", g_EndpointBuffer[i].ScheduleOrder, g_EndpointBuffer[i].ScheduleIndex);
            dprintf("Bandwidth = %d bits/ms\n", (ULONG)g_EndpointBuffer[i].Endpoint.Bandwidth);
        } else
        {
            dprintf("Endpoint %d in schedule list\n", g_EndpointBuffer[i].ScheduleOrder);
        }
        

        if(g_EndpointBuffer[i].Flags & KDEPF_WRONG_LIST_TYPE)
        {
            dprintf("ERROR: Endpoint found in the wrong list type: ");
            BOOL fNeedComma = FALSE;
            if(g_EndpointBuffer[i].Flags & KDEPF_CONTROL_LIST)
            {
                dprintf("%sControl", fNeedComma ? ", " : "");
                fNeedComma = TRUE;
            }
            if(g_EndpointBuffer[i].Flags & KDEPF_BULK_LIST)
            {
                dprintf("%sBulk", fNeedComma ? ", " : "");
                fNeedComma = TRUE;
            }
            if(g_EndpointBuffer[i].Flags & KDEPF_PERIODIC_TABLE)
            {
                if(0 == g_EndpointBuffer[i].ScheduleIndex)
                {
                    dprintf("%sIsochronous", fNeedComma ? ", " : "");
                } else
                {
                    dprintf("%sInterrupt", fNeedComma ? ", " : "");
                }
                fNeedComma = TRUE;
            }
            if(g_EndpointBuffer[i].Flags & KDEPF_PENDING_CLOSE_LIST)
            {
                dprintf("%sClose Pending", fNeedComma ? ", " : "");
            }
            dprintf("\n");
        }
        if(g_EndpointBuffer[i].Flags & KDEPF_NOT_IN_PHYSICAL_LIST)
        {
            dprintf("ERROR: Not found in the physical list.\n");
        }
        if(g_EndpointBuffer[i].Flags & KDEPF_NOT_IN_VIRTUAL_LIST)
        {
            dprintf("ERROR: Not found in the virtual list.\n");
        }
        if(g_EndpointBuffer[i].Flags & KDEPF_WRONG_PHYSICAL_LIST)
        {
            dprintf("ERROR: Endpoint was in the wrong physical list.\n");
        }
        if(g_EndpointBuffer[i].Flags & KDEPF_WRONG_PHYSICAL_LIST)
        {
            dprintf("ERROR: The address for this endpoint was invalid.\n");
        }
    }
}


ULONG
OHCD_CalculateBandwidth(
    IN ULONG   MaxPacketSize,
    IN BOOL    LowSpeed,
    IN BOOL    Isoch
    )
{
    ULONG bw;
    if(Isoch)
    {
        bw = (USB_ISO_OVERHEAD_BYTES+MaxPacketSize);
    } else
    {
        bw = (USB_INTERRUPT_OVERHEAD_BYTES+MaxPacketSize);
    }
    bw = (bw*8*7)/6;
    if(LowSpeed)
    {
        bw *= 8;
    }
    return bw;
}


void PerformBandwidthCheck()
{
    int i;
    int ErrorCount;
    //
    //  Calculate Expected Parent Bandwidths
    //

    g_ExpectedParentBandwidth[0] = 0;
    for(i=1; i<64;i++)
    {
        ULONG parent = i >> 1;
        g_ExpectedParentBandwidth[i] = g_ExpectedParentBandwidth[parent] + g_ExpectedBandwidth[parent];
    }

    //
    //  Calculate Expected Children Bandwidth
    //
    for(i = 63; i >= 32; i--)
    {
        g_ExpectedChildrenBandwidth[i] = 0;
    }
    for(i = 31; i >= 1; i--)
    {
        ULONG child1 = i << 1;
        ULONG child2 = child1 + 1;
        ULONG expectedChild1Bandiwidth = g_ExpectedChildrenBandwidth[child1] + g_ExpectedBandwidth[child1];
        ULONG expectedChild2Bandiwidth = g_ExpectedChildrenBandwidth[child2] + g_ExpectedBandwidth[child2];
        if(expectedChild2Bandiwidth > expectedChild1Bandiwidth)
        {
            g_ExpectedChildrenBandwidth[i] = expectedChild2Bandiwidth;
        } else
        {
            g_ExpectedChildrenBandwidth[i] = expectedChild1Bandiwidth;
        }
    }
    g_ExpectedChildrenBandwidth[0] = g_ExpectedChildrenBandwidth[1] + g_ExpectedBandwidth[1];

    dprintf("----------- Bandwidth Check -----------------\n");
    ErrorCount = 0;
    for(i=0; i<64;i++)
    {
        BOOL fNodePrinted = FALSE;
        //
        //  Check nodes bandwidth
        //
        if(g_ExpectedBandwidth[i] != (ULONG)g_pOhcdExtension->Schedule.InterruptSchedule[i].Bandwidth)
        {
            ErrorCount++;
            dprintf("Node %d Errors:\n", i);
            fNodePrinted = TRUE;
            dprintf("    Expected Bandwidth = %d bits/ms, Recorded Bandwidth = %d bits/ms\n",
                g_ExpectedBandwidth[i],
                (ULONG)g_pOhcdExtension->Schedule.InterruptSchedule[i].Bandwidth
                );
        }
        if(g_ExpectedParentBandwidth[i] != (ULONG)g_pOhcdExtension->Schedule.InterruptSchedule[i].BandwidthParents)
        {
            ErrorCount++;
            if(!fNodePrinted)
            {
                dprintf("Node %d Errors:\n", i);
                fNodePrinted = TRUE;
            }
            dprintf("    Expected Parent Bandwidth = %d bits/ms, Recorded Parent Bandwidth = %d bits/ms\n",
                g_ExpectedParentBandwidth[i],
                (ULONG)g_pOhcdExtension->Schedule.InterruptSchedule[i].BandwidthParents
                );
        }
        if(g_ExpectedChildrenBandwidth[i] != (ULONG)g_pOhcdExtension->Schedule.InterruptSchedule[i].BandwidthChildren)
        {
            ErrorCount++;
            if(!fNodePrinted)
            {
                dprintf("Node %d Errors:\n", i);
                fNodePrinted = TRUE;
            }
            dprintf("    Expected Children Bandwidth = %d bits/ms, Recorded Children Bandwidth = %d bits/ms\n",
                g_ExpectedChildrenBandwidth[i],
                (ULONG)g_pOhcdExtension->Schedule.InterruptSchedule[i].BandwidthChildren
                );
        }
    }
    
    if(0==ErrorCount)
    {
        dprintf("Bandwidth table is consistent.\n");
    } else
    {
        dprintf("%d inconsistencies found in bandwidth table.\n", ErrorCount);
    }
    //
    //  Now Dump Available Bandwidth Summary
    //
    
    dprintf("Total Bandwidth for Host Controller = %d bits/ms\n", g_pOhcdExtension->Schedule.BandwidthTotal);
    dprintf("Bandwidth reserved for periodic transfers = %d bits/ms\n", g_pOhcdExtension->Schedule.BandwidthPeriodic);

    for(i = 1; i <= 32; i *= 2)
    {
        ULONG firstNode = i;
        ULONG lastNode = (i*2)-1;
        ULONG bestBandwidth = 12000;
        ULONG node;
        for(node = firstNode; node <= lastNode; node++)
        {
            ULONG bandwidth = g_pOhcdExtension->Schedule.InterruptSchedule[node].Bandwidth +
                              g_pOhcdExtension->Schedule.InterruptSchedule[node].BandwidthChildren +
                              g_pOhcdExtension->Schedule.InterruptSchedule[node].BandwidthParents;
            if(bandwidth < bestBandwidth) bestBandwidth = bandwidth;
        }
        dprintf("Poll Interval of %d ms: available bandwidth = %d bits/ms\n", i, g_pOhcdExtension->Schedule.BandwidthPeriodic - bestBandwidth);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\patch.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    patch.h

Abstract:

    This file contains the assertion scripts for !Patch

Author:

    Adrian J. Oney (adriao) 07-28-1998

Environment:

    User Mode.

Revision History:

--*/

#if 0

#ifndef NO_SPECIAL_IRP

//
// Every patch must belong to a category
//
BEGIN_CATEGORY("WDM Driver Correctness") ;

  //
  // Non-exclusive means the children can be turned on and off individually
  // (like check boxes). In exclusive lists, only one option can be on at
  // once (ie, radio buttons).
  //
  BEGIN_SIBLING_LIST(LISTSTYLE_NON_EXCLUSIVE) ;

  //
  // Collections are a set of one or more patches. The first parameter
  // is a list of the patches to apply.
  //
  DECLARE_COLLECTION(                                                        \
      ("IrpConsumeStacks IrpDeferCompletion IrpEditSRBs"                     \
        " IrpWatchAlloc IrpSeedStack IrpDpcComplete"),                       \
      "Irps",                                                                \
      "Assert IRP usage is correct",                                         \
      NULL                                                                   \
      );

  //
  // An entry describes a patch to code. The first parameter has the
  // following syntax
  //   ([ed | ew | eb] module!symbolic [& | |]= hexvalue;)*
  //
  // The default size is assumed to be dword/ulong. Supported operators
  // are &=, =, and |=
  //
  // The second parameter is the shortcut name (e.g. "!Patch IrpTrack")
  // The third parameter is the menu description displayed when !Patch
  //   is typed with no parameters.
  // The fourth parameter is a terse description displayed when the
  //   user requests more information (e.g. "!Patch IrpTrack?")
  //

  DECLARE_ENTRY(                                                             \
    ("ed nt!IovpTrackingFlags = %x;ed nt!IovpEnforcementLevel = 0;",         \
     ASSERTFLAG_TRACKIRPS | ASSERTFLAG_POLICEIRPS |                          \
     ASSERTFLAG_MONITORMAJORS),                                              \
    "IrpTrack",                                                              \
    "Monitor IRPs for mistakes",                                             \
    "This enables a battery of basic assertions."                            \
    );

    BEGIN_SIBLING_LIST(LISTSTYLE_NON_EXCLUSIVE) ;

    DECLARE_ENTRY(                                                           \
      ("ed nt!IovpTrackingFlags |= %x;", ASSERTFLAG_ROTATE_STATUS),          \
      "IrpRotateStatus",                                                     \
      "Rotate success codes",                                                \
      "Successful IRPs have their status codes changed as they come up the"  \
      " stack to verify drivers return the correct codes and support success"\
      " codes other than STATUS_SUCCESS."                                    \
      );

    DECLARE_ENTRY(                                                           \
      ("ed nt!IovpTrackingFlags |= %x;", ASSERTFLAG_FORCEPENDING),           \
      "IrpPendAll",                                                          \
      "Force IRPs Pending",                                                  \
      "All IRPs (except IRP_MJ_PNP.IRP_MN_REMOVE) return with STATUS_PENDING"\
      " and are marked appropriately. This is used to verify drivers"        \
      " properly handle IRPs that return before being completed."            \
      );

      BEGIN_SIBLING_LIST(LISTSTYLE_NON_EXCLUSIVE) ;

      DECLARE_ENTRY(                                                         \
        ("ed nt!IovpTrackingFlags |= %x;", ASSERTFLAG_DEFERCOMPLETION),      \
        "IrpDeferCompletion",                                                \
        "IRP completion is stalled at each stack",                           \
        "IRP completion is deferred at every stack location using a timer"   \
        " based delay at nt!IopDiagIrpDeferralTime (default 300us per stack" \
        " location."                                                         \
        );

      END_SIBLING_LIST() ;

    DECLARE_ENTRY(                                                           \
      ("ed nt!IovpTrackingFlags |= %x;", ASSERTFLAG_CONSUME_ALWAYS),         \
      "IrpConsumeStacks",                                                    \
      "Consume stack locations (undo IoSkips)",                              \
      "IoSkipCurrentStackLocation calls are unwound (ie, the stack location" \
      " is still consumed) when an IRP is forwarded to another driver in the"\
      " same driver stack. This verifies drivers don't consume too many IRP" \
      " locations."                                                          \
      );

    DECLARE_ENTRY(                                                           \
      ("ed nt!IovpTrackingFlags |= %x;", ASSERTFLAG_SURROGATE),              \
      "IrpSurrogate",                                                        \
      "Writes to IRPs after completion fault",                               \
      "The original IRP sent to IoCallDriver is replaced with a surrogate"   \
      " IRP allocated from the special pool. When that IRP has been"         \
      " completed at the top, the original is completed and the special pool"\
      " surrogate is freed. Writes to the surrogate thus cause a fault."     \
      );

      BEGIN_SIBLING_LIST(LISTSTYLE_NON_EXCLUSIVE) ;

      DECLARE_ENTRY(                                                         \
        ("ed nt!IovpTrackingFlags |= %x;", ASSERTFLAG_SMASH_SRBS),           \
        "IrpEditSRBs",                                                       \
        "Patch SRBs so writes after completion fault.",                      \
        "SCSI SRBs contain a pointer to the original IRP that must be edited"\
        " if a surrogate IRP is to be used. Note that the method for"        \
        " identifying a SRB might erroneously edit an IRP as there is no"    \
        " signature on SRBs. If this option is off no"                       \
        " IRP_MJ_INTERNAL_DEVICE_CONTROL IRPs use surrogates."               \
        );

      END_SIBLING_LIST() ;

    DECLARE_ENTRY(                                                           \
      NULL,                                                                  \
      NO_SHORTCUT,                                                           \
      "Complete IRPs at specific IRQLs.",                                    \
      NULL                                                                   \
      );

      BEGIN_SIBLING_LIST(LISTSTYLE_EXCLUSIVE) ;

      DECLARE_ENTRY(                                                         \
        ("ed nt!IovpTrackingFlags |= %x;", ASSERTFLAG_COMPLETEATDPC),        \
        "IrpDpcComplete",                                                    \
        "Complete all IRPs at IRQL2 (DPC).",                                 \
        "The CPU's IRQL is raised to DPC whenever a completion is going to"  \
        " be called."                                                        \
        );

      DECLARE_ENTRY(                                                         \
        ("ed nt!IovpTrackingFlags |= %x;",                                   \
          ASSERTFLAG_COMPLETEATPASSIVE | ASSERTFLAG_FORCEPENDING),           \
        "IrpPassiveComplete",                                                \
        "Complete all IRPs at IRQL0 (Passive).",                             \
        "IRPs are completed within a passive level work item if legal."      \
        " All IRPs are pended (!patch IrpPendAll) if this action is enabled."\
        );

      END_SIBLING_LIST() ;

    END_SIBLING_LIST() ;

  DECLARE_ENTRY(                                                             \
    ("ed nt!IovpTrackingFlags |= %x;", ASSERTFLAG_SEEDSTACK),                \
    "IrpSeedStack",                                                          \
    "Catches uninitialized variables.",                                      \
    "Prior to calling the IRP dispatch routine, the stack is seeded with"    \
    " 0xFFFFFFFF's. If this value is returned or passed down, an assert"     \
    " occurs."                                                               \
    );

  DECLARE_ENTRY(                                                             \
    ("ed nt!IovpTrackingFlags |= %x;", ASSERTFLAG_MONITOR_ALLOCS),           \
    "IrpWatchAlloc",                                                         \
    "IRPs are allocated from the special pool.",                             \
    "This feature allows IRPs touched after being freed to cause a fault."   \
    " While allocated, information is kept on the allocator of the IRP."     \
    );

  DECLARE_ENTRY(                                                             \
    ("ed nt!IovpHackFlags = 0;"),                                            \
    "IrpNoHacks",                                                            \
    "Disable all hacks for IRP asserting.",                                  \
    "To allow the system to boot and shutdown during IRP assertion"          \
    " several hacks are step around current bugs in the OS. !Patch"          \
    " IrpNoHacks disables these hacks."                                      \
    );

  DECLARE_ENTRY(                                                             \
    ("ed nt!IovpTrackingFlags = 0;"),                                        \
    "IrpNoAsserts",                                                          \
    "Turn off IRP assertions.",                                              \
    "Turns off all assertions enabled by !Patch Irps."                       \
    );

  END_SIBLING_LIST() ;

END_CATEGORY() ;
#endif // NO_SPECIAL_IRP

//
// Every patch must belong to a category
//
BEGIN_CATEGORY("Plug-n-Play Options") ;

  //
  // Non-exclusive means the children can be turned on and off individually
  // (like check boxes). In exclusive lists, only one option can be on at
  // once (ie, radio buttons).
  //
  BEGIN_SIBLING_LIST(LISTSTYLE_NON_EXCLUSIVE) ;

  DECLARE_ENTRY(                                                             \
    ("ed nt!PiDebugLevel = ff"),                                             \
    "PnpQueue",                                                              \
    "Shows Pnp remove information.",                                         \
    "This can be used to see which devices fail various queries."            \
    );

  DECLARE_ENTRY(                                                             \
    ("ed Hal!HalDebug = 3;"),                                                \
    "HalPnpVerbose",                                                         \
    "Turn on Hal Pnp Verbose Output.",                                       \
    "Useful for debugging non-ACPI IRQ Routing problems."                    \
    );

  DECLARE_ENTRY(                                                             \
    ("ed nt!PnpResDebugLevel = 3"),                                          \
    "PnpRes",                                                                \
    "Show resource assignment info.",                                        \
    "Dumps out information during resource allocation (not including"        \
    "arbiters.)"                                                             \
    );

    BEGIN_SIBLING_LIST(LISTSTYLE_EXCLUSIVE) ;

    DECLARE_ENTRY(                                                           \
      ("ed nt!PnpResDebugLevel |= 4;"),                                      \
      "PnpResFull",                                                          \
      "Even more resource info.",                                            \
      "Dumps out detailed information during resource allocation."           \
      );

    END_SIBLING_LIST() ;

  END_SIBLING_LIST() ;

END_CATEGORY() ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\kdexts\lookasid.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    LookAsid.c

Abstract:

    WinDbg Extension Api

Author:

    Gary Kimura [GaryKi]    22-Feb-96

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  A quick macro to dump a lookaside list given its variable name
//

#define Dump(S,R) { ULONG _a;                         \
    if( (_a = GetExpression( S )) == 0) {             \
        dprintf("Failed GetExpression(\"%s\")\n", S); \
    } else if ((R)) {                                 \
        ResetLookaside( _a, S );                      \
    } else {                                          \
        DumpLookaside( _a, S );                       \
    }                                                 \
}

#define GetAddressFromName(A,N) {                     \
    if (((A) = GetExpression( (N) )) == 0) {          \
        dprintf("Failed GetExpression(\"%s\")\n", N); \
        return;                                       \
    }                                                 \
}

#define ReadAtAddress(A,V,S) { ULONG _r;                           \
    if (!ReadMemory( (ULONG)(A), &(V), (S), &_r ) || (_r < (S))) { \
        dprintf("Can't Read Memory at %08lx\n", (A));              \
        return;                                                    \
    }                                                              \
}

#define WriteAtAddress(A,V,S) { ULONG _r;                           \
    if (!WriteMemory( (ULONG)(A), &(V), (S), &_r ) || (_r < (S))) { \
        dprintf("Can't Write Memory at %08lx\n", (A));              \
        return;                                                     \
    }                                                               \
}

ULONG TotalPagedPotential;
ULONG TotalPagedUsed;
ULONG TotalNPagedPotential;
ULONG TotalNPagedUsed;


VOID
DumpLookaside (
    IN ULONG Address,
    IN PUCHAR Name
    )

/*++

Routine Description:

    Dump a specific lookaside list.

Arguments:

    Address - Gives the address of the lookaside list to dump

    Name - Gives an optional name of to print next to the lookaside list

Return Value:

    None

--*/

{
    NPAGED_LOOKASIDE_LIST Lookaside;
    ULONG Results;

    ULONG AllocationHitRate;
    ULONG FreeHitRate;

    UCHAR Str[64];

    //
    //  Read the lookaside list from memory
    //

    if (!ReadMemory( (ULONG)Address, &Lookaside, sizeof(NPAGED_LOOKASIDE_LIST), &Results ) ||
        (Results < sizeof(NPAGED_LOOKASIDE_LIST))) {

        dprintf("Can't read lookaside \"%s\" at 0x%08lx\n", Name, Address);
    }

    //
    //  Dump it out.  Note that for purposes of dumping a paged and nonpaged lookaside are
    //  the same.  I.e., the fields we're interested are at identical offsets
    //

    //
    //  Compute the hit rate
    //

    AllocationHitRate = (Lookaside.L.TotalAllocates > 0 ? (((Lookaside.L.TotalAllocates - Lookaside.L.AllocateMisses)*100)/Lookaside.L.TotalAllocates) : 0);
    FreeHitRate = (Lookaside.L.TotalFrees > 0 ? (((Lookaside.L.TotalFrees - Lookaside.L.FreeMisses)*100)/Lookaside.L.TotalFrees) : 0);

    //
    //  Decide what type of pool is behind the lookaside list
    //

    switch (Lookaside.L.Type & 0x7) {
    case NonPagedPool:                  sprintf(Str, "NonPagedPool");                  break;
    case PagedPool:                     sprintf(Str, "PagedPool");                     break;
    case NonPagedPoolMustSucceed:       sprintf(Str, "NonPagedPoolMustSucceed");       break;
    case DontUseThisType:               sprintf(Str, "DontUseThisType");               break;
    case NonPagedPoolCacheAligned:      sprintf(Str, "NonPagedPoolCacheAligned");      break;
    case PagedPoolCacheAligned:         sprintf(Str, "PagedPoolCacheAligned");         break;
    case NonPagedPoolCacheAlignedMustS: sprintf(Str, "NonPagedPoolCacheAlignedMustS"); break;
    default:                            sprintf(Str, "Unknown pool type");             break;
    }

    //
    //  Add to the total usage and potential based on pool type
    //

    if (Lookaside.L.Type & 0x1) {

        TotalPagedUsed += Lookaside.L.ListHead.Depth * Lookaside.L.Size;
        TotalPagedPotential += Lookaside.L.Depth * Lookaside.L.Size;

    } else {

        TotalNPagedUsed += Lookaside.L.ListHead.Depth * Lookaside.L.Size;
        TotalNPagedPotential += Lookaside.L.Depth * Lookaside.L.Size;
    }

    //
    //  Now print everything
    //

    dprintf("\nLookaside \"%s\" @ %08lx \"%c%c%c%c\"\n", Name, Address, ((PUCHAR)&Lookaside.L.Tag)[0],
                                                                        ((PUCHAR)&Lookaside.L.Tag)[1],
                                                                        ((PUCHAR)&Lookaside.L.Tag)[2],
                                                                        ((PUCHAR)&Lookaside.L.Tag)[3]);
    dprintf("    Type     =     %04x %s", Lookaside.L.Type, Str);
    if (Lookaside.L.Type & POOL_QUOTA_FAIL_INSTEAD_OF_RAISE) { dprintf(" QuotaFailInsteadOrRaise"); }
    if (Lookaside.L.Type & POOL_RAISE_IF_ALLOCATION_FAILURE) { dprintf(" RaiseIfAllocationFailure"); }
    dprintf("\n");
    dprintf("    Current Depth  = %8ld   Max Depth  = %8ld\n", Lookaside.L.ListHead.Depth, Lookaside.L.Depth);
    dprintf("    Size           = %8ld   Max Alloc  = %8ld\n", Lookaside.L.Size, Lookaside.L.Depth * Lookaside.L.Size);
    dprintf("    AllocateMisses = %8ld   FreeMisses = %8ld\n", Lookaside.L.AllocateMisses, Lookaside.L.FreeMisses);
    dprintf("    TotalAllocates = %8ld   TotalFrees = %8ld\n", Lookaside.L.TotalAllocates, Lookaside.L.TotalFrees);
    dprintf("    Hit Rate       =      %3d%%  Hit Rate   =      %3d%%\n", AllocationHitRate, FreeHitRate);

    return;
}


VOID
ResetLookaside (
    IN ULONG Address,
    IN PUCHAR Name
    )

/*++

Routine Description:

    Resets the counters in a specific lookaside list.

Arguments:

    Address - Gives the address of the lookaside list to reset

    Name - Gives an optional name of to print in case of errors

Return Value:

    None

--*/

{
    NPAGED_LOOKASIDE_LIST Lookaside;
    ULONG Results;

    //
    //  Read the lookaside list from memory
    //

    if (!ReadMemory( (ULONG)Address, &Lookaside, sizeof(NPAGED_LOOKASIDE_LIST), &Results ) ||
        (Results < sizeof(NPAGED_LOOKASIDE_LIST))) {

        dprintf("Can't read lookaside \"%s\" at 0x%08lx\n", Name, Address);
    }

    //
    //  Zero out the counters
    //

    Lookaside.L.TotalAllocates = 0;
    Lookaside.L.AllocateMisses = 0;

    Lookaside.L.TotalFrees = 0;
    Lookaside.L.FreeMisses = 0;

    //
    //  Write it back out
    //

    if (!WriteMemory( (ULONG)Address, &Lookaside, sizeof(NPAGED_LOOKASIDE_LIST), &Results ) ||
        (Results < sizeof(NPAGED_LOOKASIDE_LIST))) {

        dprintf("Can't write lookaside \"%s\" at 0x%08lx\n", Name, Address);
    }


    return;
}


VOID
SetDepthLookaside (
    IN ULONG Address,
    IN PUCHAR Name,
    IN ULONG Depth
    )

/*++

Routine Description:

    Set the depth of a specific lookaside list.

Arguments:

    Address - Gives the address of the lookaside list to reset

    Name - Gives an optional name of to print in case of errors

    Depth - Supplies the depth to set the lookaside list to

Return Value:

    None

--*/

{
    NPAGED_LOOKASIDE_LIST Lookaside;
    ULONG Results;

    //
    //  Read the lookaside list from memory
    //

    if (!ReadMemory( (ULONG)Address, &Lookaside, sizeof(NPAGED_LOOKASIDE_LIST), &Results ) ||
        (Results < sizeof(NPAGED_LOOKASIDE_LIST))) {

        dprintf("Can't read lookaside \"%s\" at 0x%08lx\n", Name, Address);
    }

    //
    //  Set the depth
    //

    Lookaside.L.Depth = (USHORT)Depth;

    //
    //  Write it back out
    //

    if (!WriteMemory( (ULONG)Address, &Lookaside, sizeof(NPAGED_LOOKASIDE_LIST), &Results ) ||
        (Results < sizeof(NPAGED_LOOKASIDE_LIST))) {

        dprintf("Can't write lookaside \"%s\" at 0x%08lx\n", Name, Address);
    }


    return;
}


DECLARE_API( lookaside )

/*++

Routine Description:

    Dump lookaside lists

Arguments:

    arg - [Address] [options]

Return Value:

    None

--*/

{
    ULONG LookasideToDump;
    ULONG Options;
    ULONG Depth;

    //
    //  If the caller specified an address then that the the lookaside list we dump
    //

    LookasideToDump = 0;
    Options = 0;
    Depth = 0;

    sscanf(args,"%lx %lx %lx",&LookasideToDump, &Options, &Depth);

    if (LookasideToDump != 0) {

        if (Options == 0) {

            DumpLookaside( LookasideToDump, "");

        } else if (Options == 1) {

            ResetLookaside( LookasideToDump, "");

        } else if (Options == 2) {

            SetDepthLookaside( LookasideToDump, "", Depth );
        }

        return;
    }

    //
    //  Reset the counters we use to sum up the potential pool usage
    //

    TotalPagedPotential = 0;
    TotalPagedUsed = 0;
    TotalNPagedPotential = 0;
    TotalNPagedUsed = 0;

    //
    //  Otherwise we'll dump a built in set of lookaside lists
    //

    Dump("xboxkrnl!CcTwilightLookasideList", Options == 1);

    Dump("xboxkrnl!IopSmallIrpLookasideList", Options == 1);
    Dump("xboxkrnl!IopLargeIrpLookasideList", Options == 1);
    Dump("xboxkrnl!IopMdlLookasideList", Options == 1);

    Dump("xboxkrnl!FsRtlFastMutexLookasideList", Options == 1);
    Dump("xboxkrnl!TunnelLookasideList", Options == 1);

    Dump("xboxkrnl!ObpCreateInfoLookasideList", Options == 1);
    Dump("xboxkrnl!ObpNameBufferLookasideList", Options == 1);

    Dump("afd!AfdWorkQueueLookasideList", Options == 1);

    Dump("xboxkrnl!FatIrpContextLookasideList", Options == 1);

    Dump("Ntfs!NtfsIoContextLookasideList", Options == 1);
    Dump("Ntfs!NtfsIrpContextLookasideList", Options == 1);
    Dump("Ntfs!NtfsKeventLookasideList", Options == 1);
    Dump("Ntfs!NtfsScbNonpagedLookasideList", Options == 1);
    Dump("Ntfs!NtfsScbSnapshotLookasideList", Options == 1);

    Dump("Ntfs!NtfsCcbLookasideList", Options == 1);
    Dump("Ntfs!NtfsCcbDataLookasideList", Options == 1);
    Dump("Ntfs!NtfsDeallocatedRecordsLookasideList", Options == 1);
    Dump("Ntfs!NtfsFcbDataLookasideList", Options == 1);
    Dump("Ntfs!NtfsFcbIndexLookasideList", Options == 1);
    Dump("Ntfs!NtfsIndexContextLookasideList", Options == 1);
    Dump("Ntfs!NtfsLcbLookasideList", Options == 1);
    Dump("Ntfs!NtfsNukemLookasideList", Options == 1);
    Dump("Ntfs!NtfsScbDataLookasideList", Options == 1);

    if (Options != 1) {

        dprintf("\n");
        dprintf("Total NonPaged currently allocated for above lists = %8ld\n", TotalNPagedUsed);
        dprintf("Total NonPaged potential for above lists           = %8ld\n", TotalNPagedPotential);
        dprintf("Total Paged currently allocated for above lists    = %8ld\n", TotalPagedUsed);
        dprintf("Total Paged potential for above lists              = %8ld\n", TotalPagedPotential);

        TotalPagedPotential = 0;
        TotalPagedUsed = 0;
        TotalNPagedPotential = 0;
        TotalNPagedUsed = 0;
    }

/*

    //
    //  Now dump out the small pool lookaside lists or zero their
    //  counters.
    //

    if (Options == 1) {

        ULONG Address;
        ULONG Results;
        ULONG i;

        //
        //  Get the location of the nonpaged list
        //

        GetAddressFromName( Address, "ExpSmallNPagedPoolLookasideLists" );

        //
        //  Read in each list, zero out it counters and write it back out
        //

        for ( i = 0; i < POOL_SMALL_LISTS; i += 1) {

            ULONG Location;
            SMALL_POOL_LOOKASIDE LookasideList;

            Location = Address + i * sizeof(SMALL_POOL_LOOKASIDE);

            ReadAtAddress( Location, LookasideList, sizeof(SMALL_POOL_LOOKASIDE) );

            LookasideList.TotalAllocates = 0;
            LookasideList.AllocateHits = 0;
            LookasideList.TotalFrees = 0;
            LookasideList.FreeHits = 0;

            WriteAtAddress( Location, LookasideList, sizeof(SMALL_POOL_LOOKASIDE) );
        }

        //
        //  Get the location of the paged list
        //

#ifndef TARGET_PPC

        GetAddressFromName( Address, "ExpSmallPagedPoolLookasideLists" );

        //
        //  Read in each list, zero out it counters and write it back out
        //

        for (