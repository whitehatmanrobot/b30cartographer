pOver());

	//	Packed Add with Saturation
	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddsb mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddsw mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddsb mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddsw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Packed Add Unsigned with Saturation 
	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddusb mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddusw mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddusb mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("paddusw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Bitwise Logical And 
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pand mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pand mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Bitwise Logical And Not 
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pandn mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pandn mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Bitwise Logical Or
	EXPECT_TRUE(dam.VerifyCurrentInstruction("por mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("por mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Compare for Equal 
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pcmpeqb mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pcmpeqw mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pcmpeqd mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pcmpeqb mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pcmpeqw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("pcmpeqd mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Compare for Greater Than

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pcmpgtb mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pcmpgtw mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pcmpgtd mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pcmpgtb mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pcmpgtw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pcmpgtd mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Packed Multiply and Add 

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmaddwd mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmaddwd mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Packed Multiply High

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmulhw mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmulhw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Packed Multiply Low

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmullw mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pmullw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Packed Shift Left Logical

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psllw mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pslld mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psllq mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psllw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pslld mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psllq mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psllw mm0,7"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pslld mm0,7"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psllq mm0,7"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Packed Shift Right Arithmetic

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psraw mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrad mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("psraw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrad mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("psraw mm0,5"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrad mm0,5"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());	

	//	Packed Shift Right Logical
	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrlw mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrld mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrlq mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrlw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrld mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrlq mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrlw mm0,6"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrld mm0,6"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psrlq mm0,6"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Packed Subtract

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubb mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubw mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubd mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubb mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubd mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Packed Subtract with Saturation

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubsb mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubsw mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubsb mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubsw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Packed Subtract Unsigned with Saturation

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubusb mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubsw mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubusb mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("psubsw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	
	//	Unpack High Packed Data

	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpckhbw mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpckhwd mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpckhdq mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpckhbw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpckhwd mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpckhdq mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	
	//	Unpack Low Packed Data

	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpcklbw mm0,dword ptr " EBP10H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpcklwd mm0,dword ptr " EBP10H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpckldq mm0,dword ptr " EBP10H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpcklbw mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpcklwd mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("punpckldq mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	Bitwise Logical Exclusive OR

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pxor mm0,mmword ptr " EBP8));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("pxor mm0,mm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dbg.Go(0, 0, 0, WAIT_FOR_RUN));
}

void CDisAsmPP::TestKatmai()
{
	LOGTESTHEADER("TestKatmai");

	EXPECT_TRUE(dbg.Break());
	EXPECT_SUCCESS(src.Open(m_strProjectDir + "\\" + m_strProjectName + ".cpp")); 
	EXPECT_TRUE(src.Find("Test_Katmai(); // src.Find()")); 

	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(dbg.StepInto());	
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StepOver());

	//	test all registers for visibility
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movss xmm1,xmm2"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movss xmm2,xmm3"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movss xmm3,xmm4"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movss xmm4,xmm5"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movss xmm5,xmm6"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movss xmm6,xmm7"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movss xmm7,xmm0"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());


	EXPECT_TRUE(dam.VerifyCurrentInstruction("addps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

#if 0
#define EBP20H "[ebp-20h]"
#define EBP24H "[ebp-24h]"
#define GLOBALINT64 "0042d080"
#else
#define EBP20H "[mVar128]"
#define EBP24H "[i32Val]"
//#define GLOBALINT64 "004194f0"
#endif

	EXPECT_TRUE(dam.VerifyCurrentInstruction("addps xmm0,xmmword ptr " EBP20H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("addss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("addss xmm0,dword ptr " EBP24H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("andnps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("andnps xmm0,xmmword ptr " EBP20H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("andps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("andps xmm0,xmmword ptr " EBP20H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	cmpps series

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpeqps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpltps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpleps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpunordps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpneqps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpnltps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpnleps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpordps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());


	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpeqps xmm0,xmmword ptr " EBP20H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpltps xmm0,xmmword ptr " EBP20H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpleps xmm0,xmmword ptr " EBP20H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpunordps xmm0,xmmword ptr " EBP20H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpneqps xmm0,xmmword ptr " EBP20H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpnltps xmm0,xmmword ptr " EBP20H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpnleps xmm0,xmmword ptr " EBP20H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpordps xmm0,xmmword ptr " EBP20H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//	cmpss series

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpeqss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpltss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpless xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpunordss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpneqss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpnltss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpnless xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpordss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpeqss xmm0,dword ptr " EBP24H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpltss xmm0,dword ptr " EBP24H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpless xmm0,dword ptr " EBP24H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpunordss xmm0,dword ptr " EBP24H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpneqss xmm0,dword ptr " EBP24H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpnltss xmm0,dword ptr " EBP24H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpnless xmm0,dword ptr " EBP24H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpordss xmm0,dword ptr " EBP24H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());


	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpeqps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpeqss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpltps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpltss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpleps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpless xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpneqps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpneqss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpnltps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpnltss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpnleps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cmpnless xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("comiss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("comiss xmm0,dword ptr " EBP24H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtpi2ps xmm0,mmword ptr [GlobalInt64 (" GLOBALINT64 ")]"));
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtpi2ps xmm0,mmword ptr [GlobalInt64 ("));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtpi2ps xmm0,mm0"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtps2pi mm0,xmm0"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	//EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtps2pi mm0,mmword ptr [GlobalInt64 (" GLOBALINT64 ")]"));
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtps2pi mm0,mmword ptr [GlobalInt64 ("));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtsi2ss xmm0,eax"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtsi2ss xmm0,dword ptr " EBP24H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtss2si eax,xmm0"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvtss2si eax,dword ptr " EBP24H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvttps2pi mm0,xmm0"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	//EXPECT_TRUE(dam.VerifyCurrentInstruction("cvttps2pi mm0,mmword ptr [GlobalInt64 (" GLOBALINT64 ")]"));
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvttps2pi mm0,mmword ptr [GlobalInt64 ("));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvttss2si eax,xmm0"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("cvttss2si eax,dword ptr " EBP24H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("divps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("divps xmm0,xmmword ptr " EBP20H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("divss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("divss xmm0,dword ptr " EBP24H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("maxps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("maxps xmm0,xmmword ptr " EBP20H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("maxss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("maxss xmm0,dword ptr " EBP24H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("minps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("minps xmm0,xmmword ptr " EBP20H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("minss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("minss xmm0,dword ptr " EBP24H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movaps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movaps xmm0,xmmword ptr " EBP20H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movaps xmmword ptr " EBP20H ",xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movhlps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//EXPECT_TRUE(dam.VerifyCurrentInstruction("movhps xmm0,qword ptr [GlobalInt64 (" GLOBALINT64 ")]"));
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movhps xmm0,qword ptr [GlobalInt64 ("));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	//EXPECT_TRUE(dam.VerifyCurrentInstruction("movhps qword ptr [GlobalInt64 (" GLOBALINT64 ")],xmm0"));
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movhps qword ptr [GlobalInt64 ("));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	//EXPECT_TRUE(dam.VerifyCurrentInstruction("movlps xmm0,qword ptr [GlobalInt64 (" GLOBALINT64 ")]"));
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movlps xmm0,qword ptr [GlobalInt64 ("));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	//EXPECT_TRUE(dam.VerifyCurrentInstruction("movlps qword ptr [GlobalInt64 (" GLOBALINT64 ")],xmm0"));
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movlps qword ptr [GlobalInt64 ("));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movlhps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movmskps eax,xmm0"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movntps xmmword ptr " EBP20H ",xmm0"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movss xmm0,dword ptr " EBP24H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movss dword ptr " EBP24H ",xmm0"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("movups xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movups xmm0,xmmword ptr " EBP20H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("movups xmmword ptr " EBP20H ",xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("mulps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("mulps xmm0,xmmword ptr " EBP20H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("mulss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("mulss xmm0,dword ptr " EBP24H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("orps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("orps xmm0,xmmword ptr " EBP20H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("rcpps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("rcpps xmm0,xmmword ptr " EBP20H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("rcpss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("rcpss xmm0,dword ptr " EBP24H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("rsqrtps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("rsqrtps xmm0,xmmword ptr " EBP20H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("rsqrtss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("rsqrtss xmm0,dword ptr " EBP24H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("sfence"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("shufps xmm0,xmm1,72h"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("shufps xmm0,xmmword ptr " EBP20H ",73h"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("sqrtps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("sqrtps xmm0,xmmword ptr " EBP20H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("sqrtss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("sqrtss xmm0,dword ptr " EBP24H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("stmxcsr dword ptr " EBP24H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("ldmxcsr dword ptr " EBP24H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	
	EXPECT_TRUE(dam.VerifyCurrentInstruction("subps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("subps xmm0,xmmword ptr " EBP20H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("subss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("subss xmm0,dword ptr " EBP24H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("ucomiss xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("ucomiss xmm0,dword ptr " EBP24H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("unpckhps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("unpckhps xmm0,xmmword ptr " EBP20H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("unpcklps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("unpcklps xmm0,xmmword ptr " EBP20H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dam.VerifyCurrentInstruction("xorps xmm0,xmm1"));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dam.VerifyCurrentInstruction("xorps xmm0,xmmword ptr " EBP20H));
	EXPECT_TRUE(dam.SwitchBetweenASMAndSRC(TRUE));
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(dbg.Go(0, 0, 0, WAIT_FOR_RUN));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\ee\eesub.h ===
///////////////////////////////////////////////////////////////////////////////
//	EESUB.H
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CEESubSuite class
//

#ifndef __EESUB_H__
#define __EESUB_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CEESubSuite class

class CEESubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CEESubSuite)
	DECLARE_TESTLIST()
protected:
	void CleanUp(void);
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\ee\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\ee\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\exe\execase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	execase.CPP
//											 
//	Created by :			
//		VCBU QA		
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "execase.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
											   
IMPLEMENT_TEST(CexeIDETest, CDebugTestSet, "Execution base", -1, CexeSubSuite)
												 
void CexeIDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();

}

void CexeIDETest::Run()
{	 
	XSAFETY;
	
	if( SetProject("testgo01\\testgo01"))
	{	  
		XSAFETY;
		GoAndVerify();
		XSAFETY;
		RestartAndGo();
		XSAFETY;
		RestartStopDebugging();
		XSAFETY;
		StepOverFuncToBreakAtLocBP();
		XSAFETY;
		StepOverFuncToBreakOnExprTrueBP();
		XSAFETY;
		StepOverFuncToBreakOnExprChangesBP();
		XSAFETY;
	}
		
	if( SetProject("testbp01\\testbp01") )
	{	  
		XSAFETY;
		StepOutSource();
		XSAFETY;
		StepOverSource();
		XSAFETY;
		StepIntoSource();
		XSAFETY;
		StepToCursorSource();
		XSAFETY;
	}
		
	// tests against example x

	if ( SetProject("dbg\\dbg") )
	{
		XSAFETY;
//		StartDebugging();		// WinslowF

		EXPECT(StepModel());
		XSAFETY;
		EXPECT(BreakStepTrace());
		XSAFETY;
	}
	StopDbgCloseProject();
	Sleep(1000);
	
/* bug # 1347 is postponed for after V50
	if( SetProject("dbga\\dbga") )
	{	  
		XSAFETY;
		TraceIntoWndProc();
		XSAFETY;
	}
*/
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\ee\eecasepp.h ===
///////////////////////////////////////////////////////////////////////////////
//	EECASEPP.H
//
//	Created by:			
//		dverma
//
//	Description :
//		VC6 Processor Pack testcases.
//

#ifndef __EECASEPP_H__
#define __EECASEPP_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\DbgTestBase.h"
#include "eesub.h"

///////////////////////////////////////////////////////////////////////////////
//	CEEPP class

class CEEPP : public CDbgTestBase
	
	{
	DECLARE_TEST(CEEPP, CEESubSuite)

	// Operations
	public:
		virtual void PreRun(void);
		virtual void Run(void);

	// testcases.
	protected:
		void testRegVal(COExpEval& cxx, char *value, char *message);
		void testRegVal(int regid, COExpEval& cxx, char *value, char *message);
		void testRegVal(char *varname, char *vartype, COExpEval& cxx, char *value, char *message);
		void testRegVal(COExpEval& cxx, char *value1, char *value2, char *value3, char *value4, char *message);
		void testRegVal(int reg_id, COExpEval& cxx, char *value1, char *value2, char *value3, char *value4, char *message);
		void test_MMX(COExpEval& cxx, CODebug& dbg, COSource& src);
		//void test_3dNow(COExpEval& cxx, CODebug& dbg, COSource& src);
		//void test_3dNowEnhanced(COExpEval& cxx, CODebug& dbg, COSource& src);
		void test_Katmai(COExpEval& cxx, CODebug& dbg, COSource& src);

	// Attributes
	public:
		// the base name of the localized directories and files we will use.
		CString m_strProjBase;
		// the location of the unlocalized sources, under which the projects we will use will be located.
		CString m_strSrcDir;
		// the locations of the dll and exe projects, and their localized sources, that we will use for this test.
		CString m_strExeDir;
};

#endif //__EECASEPP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\exe\execase2.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	execase.CPP
//											 
//	Created by :			
//		VCBU QA		
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "execase2.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
											   
IMPLEMENT_TEST(Cexe2IDETest, CDebugTestSet, "Execution special", -1, CexeSubSuite)
												 
void Cexe2IDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

void Cexe2IDETest::Run()
{	 
	XSAFETY;
	
	if( SetProject("testgo01\\testgo01"))
	{	  
		XSAFETY;
		GoExeDoesNotExist();
		XSAFETY;
		ExitWhileDebugging();
		XSAFETY;
	}
		
	if (SetProject("dllapp\\incdll", PROJECT_DLL) && SetProject("dllapp\\powdll", PROJECT_DLL)
		&& SetProject("dllapp\\dec2", PROJECT_DLL) && SetProject("dllapp\\dllappx"))
	{
		XSAFETY;
//		StartDebugging();		// WinslowF
			
		EXPECT_TRUE(DllStepTrace());
		XSAFETY;
		EXPECT_TRUE(DllStepOut());
		XSAFETY;
		EXPECT_TRUE(DllTraceOut());
		XSAFETY;
		EXPECT_TRUE(CannotFindDll());
		XSAFETY;
		EXPECT_TRUE(StepOverFuncInUnloadedDll());
		XSAFETY;
		EXPECT_TRUE(RestartFromWithinDll());
		XSAFETY;
		EXPECT_TRUE(GoFromWithinDll());
		XSAFETY;
	}
	//	StopDbgCloseProject();
		Sleep(1000);

	if( SetProject("cons01\\cons01"))
	{	  
		XSAFETY;
		StdInOutRedirection();
		XSAFETY;
	}
 
	if( SetProject("dbga\\dbga"))
	{	  
		XSAFETY;
		NoSystemCodeStepping();
		XSAFETY;
	}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\ee\eesub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	EESUB.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CEESubSuite class
//

#include "stdafx.h"
#include "eesub.h"
#include "afxdllx.h"

#include "eecase.h"
#include "eespec.h"
#include "eecasepp.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CRetValSubSuite

IMPLEMENT_SUBSUITE(CEESubSuite, CIDESubSuite, "Expression Evaluator", "VCQA Debugger")

BEGIN_TESTLIST(CEESubSuite)
	TEST(CEEIDETest, RUN)
	TEST(CSpecialTypesTest, RUN)
	TEST(CEEPP, RUN)
END_TESTLIST()

void CEESubSuite::CleanUp(void)
	{
	::CleanUp("ee");
	}

///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\ee\eespec.h ===
///////////////////////////////////////////////////////////////////////////////
//	EECASE.H
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CEEIDETest Class
//

#ifndef __EESPECIAL_H__
#define __EESPECIAL_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\DbgTestBase.h"
#include "eesub.h"

///////////////////////////////////////////////////////////////////////////////
//	CEEIDETest class

class CSpecialTypesTest : public CDbgTestBase
	
{
	DECLARE_TEST(CSpecialTypesTest, CEESubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);
private:
	void PointerToFun(void);
	void GUIDs(void);
	//xbox - no variants
	//void Variants(void);
	void ErrorCodes(void);
	void MMXRegs(void);

	CString m_TIBValue;
};

#endif //__EESPECIAL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\ee\eecasepp.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	EECASEPP.CPP
//											 
//	Created by:			
//		dverma		
//
//	Description:								 
//		VC6 Processor Pack testcases.

#include "stdafx.h"
#include "eecasepp.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
IMPLEMENT_TEST(CEEPP, CDbgTestBase, "Processor Pack", -1, CEESubSuite)
			  
									 
void CEEPP::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}


void CEEPP::Run(void)
	
{
	/******************
	 * INITIALIZATION *
	 ******************/

	if (!CreateXboxProjectFromSource("Expr Eval PP", "src\\ExprEval PP", "ExprEval PP.cpp"))
		return;

	// all tests expect the ide to be in this initial state.
	EXPECT_TRUE(dbg.StepOver());
		
	test_MMX(cxx,dbg,src);
	test_Katmai(cxx,dbg,src);

	EXPECT_TRUE(dbg.StopDebugging(ASSUME_NORMAL_TERMINATION));
	EXPECT_SUCCESS(prj.Close());
}


//	 method to test the value of register MM0

void CEEPP::testRegVal(COExpEval& cxx, char *value, char *message)
{
	EXPR_INFO expr_info;

	cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, "unsigned __int64", "MM0", value);		
	if(cxx.VerifyExprInfo(expr_info))
		LOG->RecordSuccess("%s : %s\n", expr_info.name,message);
	else
		LOG->RecordFailure("%s : %s\n", expr_info.name,message);
}

void CEEPP::testRegVal(char *varname, char *vartype, COExpEval& cxx, char *value, char *message)
{
	EXPR_INFO expr_info;

	cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, vartype, varname, value);		
	if(cxx.VerifyExprInfo(expr_info))
		LOG->RecordSuccess("%s : %s\n", expr_info.name,message);
	else
		LOG->RecordFailure("%s : %s\n", expr_info.name,message);

}

void CEEPP::testRegVal(int regid, COExpEval& cxx, char *value, char *message)
{
	EXPR_INFO expr_info;

	switch (regid)
	{
		case 0:			
					cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, "unsigned __int64", "MM0", value);
					break;


		case 1:		
					cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, "unsigned __int64", "MM1", value);
					break;


		case 2:					
					cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, "unsigned __int64", "MM2", value);
					break;

		case 3:		
					cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, "unsigned __int64", "MM3", value);
					break;


		case 4:		
					cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, "unsigned __int64", "MM4", value);
					break;

		case 5:		
					cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, "unsigned __int64", "MM5", value);
					break;

		case 6:		
					cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, "unsigned __int64", "MM6", value);
					break;

		case 7:		
					cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, "unsigned __int64", "MM7", value);
					break;

	}

	if(cxx.VerifyExprInfo(expr_info))
		LOG->RecordSuccess("%s : %s\n", expr_info.name,message);
	else
		LOG->RecordFailure("%s : %s\n", expr_info.name,message);
}

void CEEPP::testRegVal(COExpEval& cxx, char *value1, char *value2, char *value3, char *value4, char *message)
{
	EXPR_INFO expr_info;


	//	check XMM00
	cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, "float", "XMM00", value4);		
	
	if(cxx.VerifyExprInfo(expr_info))
		LOG->RecordSuccess("%s : %s\n", expr_info.name,message);
	else
		LOG->RecordFailure("%s : %s\n", expr_info.name,message);

	//	check XMM01
	cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, "float", "XMM01", value3);		
	
	if(cxx.VerifyExprInfo(expr_info))
		LOG->RecordSuccess("%s : %s\n", expr_info.name,message);
	else
		LOG->RecordFailure("%s : %s\n", expr_info.name,message);

	//	check XMM02		
	cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, "float", "XMM02", value2);		
	
	if(cxx.VerifyExprInfo(expr_info))
		LOG->RecordSuccess("%s : %s\n", expr_info.name,message);
	else
		LOG->RecordFailure("%s : %s\n", expr_info.name,message);

	//	check XMM03
	cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, "float", "XMM03", value1);		
	
	if(cxx.VerifyExprInfo(expr_info))
		LOG->RecordSuccess("%s : %s\n", expr_info.name,message);
	else
		LOG->RecordFailure("%s : %s\n", expr_info.name,message);

}

void CEEPP::testRegVal(int reg_id, COExpEval& cxx, char *value1, char *value2, char *value3, char *value4, char *message)
{

	CString MMXijRegs[] = {	"XMM00","XMM01","XMM02","XMM03", "XMM10","XMM11","XMM12","XMM13",
							"XMM20","XMM21","XMM22","XMM23", "XMM30","XMM31","XMM32","XMM33",
							"XMM40","XMM41","XMM42","XMM43", "XMM50","XMM51","XMM52","XMM53",
							"XMM60","XMM61","XMM62","XMM63", "XMM70","XMM71","XMM72","XMM73" };
	
	EXPR_INFO expr_info;


	//	check XMM00
	cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, "float", MMXijRegs[reg_id*4], value4);		
	
	if(cxx.VerifyExprInfo(expr_info))
		LOG->RecordSuccess("%s : %s\n", expr_info.name,message);
	else
		LOG->RecordFailure("%s : %s\n", expr_info.name,message);

	//	check XMM01
	cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, "float", MMXijRegs[reg_id*4+1], value3);		
	
	if(cxx.VerifyExprInfo(expr_info))
		LOG->RecordSuccess("%s : %s\n", expr_info.name,message);
	else
		LOG->RecordFailure("%s : %s\n", expr_info.name,message);

	//	check XMM02		
	cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, "float", MMXijRegs[reg_id*4+2], value2);		
	
	if(cxx.VerifyExprInfo(expr_info))
		LOG->RecordSuccess("%s : %s\n", expr_info.name,message);
	else
		LOG->RecordFailure("%s : %s\n", expr_info.name,message);

	//	check XMM03
	cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, "float", MMXijRegs[reg_id*4+3], value1);		
	
	if(cxx.VerifyExprInfo(expr_info))
		LOG->RecordSuccess("%s : %s\n", expr_info.name,message);
	else
		LOG->RecordFailure("%s : %s\n", expr_info.name,message);


}

void CEEPP::test_MMX(COExpEval& cxx, CODebug& dbg, COSource& src)
{
	//	MMX switch has already been checked for in Run()
	
	__int64 count = 0;

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	MST.DoKeys("{ESC}");	
	EXPECT_TRUE(src.Find("test_MMX();")); 
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepInto());	
	EXPECT_TRUE(dbg.StepOver());

	char MMReg[][8] = {	"MM0", "MM1", "MM2", "MM3", "MM4", 
							"MM5", "MM6", "MM7"		};

	int num_reg = 8;
	int index = 0;

	cxx.Enable(EE_ALL_INFO);

	//	set value in watch window
	EXPECT_TRUE(dbg.ToggleHexDisplay(FALSE));
	for (index = 0; index <num_reg; index++)
	{
		EXPECT_TRUE(cxx.SetExpressionValue(MMReg[index],index*101));
	}

	//	do one stepover
	EXPECT_TRUE(dbg.StepOver());

	//	verify value in watch window
	for (index = 0; index <num_reg; index++)
	{
		char str[8];
		sprintf(str,"%d",index*101);
		testRegVal(MMReg[index], "unsigned __int64", cxx, str,"Test MMi in Watch");
	}

	//	verify value in register window
	EXPECT_TRUE(regs.Enable());
	for (index = 0; index <num_reg; index++)
	{
		EXPECT_TRUE(regs.RegisterValueIs(MMReg[index], "" , index*101, FALSE));
	}
	EXPECT_TRUE(regs.Disable());


	//	test all registers for operability
	dbg.StepOver();
	testRegVal(0, cxx,"1000","move 64 bit");

	dbg.StepOver();
	testRegVal(1, cxx,"2000","move 64 bit");

	dbg.StepOver();
	testRegVal(2, cxx,"3000","move 64 bit");

	dbg.StepOver();
	testRegVal(3, cxx,"4000","move 64 bit");

	dbg.StepOver();
	testRegVal(4, cxx,"5000","move 64 bit");

	dbg.StepOver();
	testRegVal(5, cxx,"6000","move 64 bit");

	dbg.StepOver();
	testRegVal(6, cxx,"7000","move 64 bit");

	dbg.StepOver();
	testRegVal(7, cxx,"8000","move 64 bit");
	
	//	shift left
	dbg.StepOver();
	testRegVal(cxx,"1600","Shift Left");

	dbg.StepOver();
	testRegVal(cxx,"576","Shift Left");

	//	mov 32 bit
	dbg.StepOver();
	testRegVal(cxx,"123456789","mov 32 bit");
	
	dbg.StepOver();
	testRegVal(cxx,"0","mov 32 bit");
	
	dbg.StepOver();	//	32 bits - 1
	testRegVal(cxx,"4294967295","mov 32 bit");
	
	dbg.StepOver();	//	32 bits + 1
	testRegVal(cxx,"1","mov 32 bit");
	
	dbg.StepOver();	//	33 bits
	testRegVal(cxx,"0","mov 32 bit");


	//	move 64 bit

	dbg.StepOver();
	testRegVal(cxx,"123456789","move 64 bit");

	dbg.StepOver();
	testRegVal(cxx,"4294967296","move 64 bit");
	
	dbg.StepOver();
	testRegVal(cxx,"4294967295","move 64 bit");
	
	dbg.StepOver();	
	testRegVal(cxx,"4294967297","move 64 bit");
	
	dbg.StepOver();	
	testRegVal(cxx,"8589934592","move 64 bit");

	
	//	Pack with Signed Saturation
	dbg.StepOver();
	testRegVal(cxx,"4294967297","Pack with Signed Saturation");
	
	dbg.StepOver();
	testRegVal(cxx,"4294967297","Pack with Signed Saturation");

	//	Pack with Unsigned Saturation	
	dbg.StepOver();
	testRegVal(cxx,"4294967297","Pack with Unsigned Saturation");

	//	Packed Add
	dbg.StepOver();
	testRegVal(cxx,"101","Packed Add Byte");

	dbg.StepOver();
	testRegVal(cxx,"254","Packed Add Byte");
	
	dbg.StepOver();
	testRegVal(cxx,"0","Packed Add Byte");

	dbg.StepOver();
	testRegVal(cxx,"512","Packed Add Byte");


	dbg.StepOver();
	testRegVal(cxx,"101","Packed Add Word");

	dbg.StepOver();
	testRegVal(cxx,"0","Packed Add Word");

	dbg.StepOver();
	testRegVal(cxx,"131072","Packed Add Word");

	
	dbg.StepOver();
	testRegVal(cxx,"101","Packed Add Double");

	dbg.StepOver();
	testRegVal(cxx,"0","Packed Add Double");

	dbg.StepOver();
	testRegVal(cxx,"8589934592","Packed Add Double");


	//	Packed Add with Saturation
	dbg.StepOver();
	testRegVal(cxx,"250","Packed Add with Saturation");

	dbg.StepOver();
	testRegVal(cxx,"34","Packed Add with Saturation");


	//	Packed Add Unsigned with Saturation 
	dbg.StepOver();
	testRegVal(cxx,"255","Packed Add Unsigned with Saturation");

	dbg.StepOver();
	testRegVal(cxx,"65535","Packed Add Unsigned with Saturation");


	//	Bitwise Logical And 
	dbg.StepOver();
	testRegVal(cxx,"0","Logical And");

	dbg.StepOver();
	testRegVal(cxx,"15","Logical And");


	//	Bitwise Logical And Not 
	dbg.StepOver();
	testRegVal(cxx,"0","Logical And Not");

	dbg.StepOver();
	testRegVal(cxx,"14","Logical And Not");


	//	Bitwise Logical Or
	dbg.StepOver();
	testRegVal(cxx,"79","Logical Or");


	//	Compare for Equal 
	dbg.StepOver();
	testRegVal(cxx,"18446744073709486080","Byte Compare for Equal");

	dbg.StepOver();
	testRegVal(cxx,"18446744073709551360","Byte Compare for Equal");

	dbg.StepOver();
	testRegVal(cxx,"18446744073709551615","Byte Compare for Equal");


	dbg.StepOver();
	testRegVal(cxx,"18446744073709486080","Word Compare for Equal");

	dbg.StepOver();
	testRegVal(cxx,"18446744073709551615","Word Compare for Equal");
	
	dbg.StepOver();
	testRegVal(cxx,"18446744069414584320","Double Compare for Equal");

	dbg.StepOver();
	testRegVal(cxx,"18446744073709551615","Double Compare for Equal");


	//	Compare for Greater Than
	dbg.StepOver();
	testRegVal(cxx,"0","Byte Compare for Greater Than");

	dbg.StepOver();
	testRegVal(cxx,"255","Byte Compare for Greater Than");

	dbg.StepOver();
	testRegVal(cxx,"0","Byte Compare for Greater Than");

	dbg.StepOver();
	testRegVal(cxx,"255","Byte Compare for Greater Than");

	dbg.StepOver();
	testRegVal(cxx,"65280","Byte Compare for Greater Than");

	dbg.StepOver();
	testRegVal(cxx,"65280","Byte Compare for Greater Than");

	
	dbg.StepOver();
	testRegVal(cxx,"65535","Word Compare for Greater Than");

	dbg.StepOver();
	testRegVal(cxx,"4294901760","Word Compare for Greater Than");

	
	dbg.StepOver();
	testRegVal(cxx,"4294967295","Double Compare for Greater Than");

	dbg.StepOver();
	testRegVal(cxx,"18446744069414584320","Double Compare for Greater Than");


	//	Packed Multiply and Add 
	dbg.StepOver();
	testRegVal(cxx,"1300","Packed Multiply and Add");

	dbg.StepOver();
	testRegVal(cxx,"1","Packed Multiply and Add");


	//	Packed Multiply High
	dbg.StepOver();
	testRegVal(cxx,"0","Packed Multiply High");

	dbg.StepOver();
	testRegVal(cxx,"1","Packed Multiply High");


	//	Packed Multiply Low
	dbg.StepOver();
	testRegVal(cxx,"24","Multiply Low");

	dbg.StepOver();
	testRegVal(cxx,"6550","Multiply Low");


	//	Packed Shift Left Logical
	dbg.StepOver();
	testRegVal(cxx,"368","Packed Shift Left Logical Word");

	dbg.StepOver();
	testRegVal(cxx,"131074","Packed Shift Left Logical Word");

	dbg.StepOver();
	testRegVal(cxx,"0","Packed Shift Left Logical Word");

	
	dbg.StepOver();
	testRegVal(cxx,"368","Packed Shift Left Logical Double");

	dbg.StepOver();
	testRegVal(cxx,"2","Packed Shift Left Logical Double");

	dbg.StepOver();	//	=> 2^33
	testRegVal(cxx,"8589934592","Packed Shift Left Logical Double");

	dbg.StepOver();
	testRegVal(cxx,"0","Packed Shift Left Logical Double");

	
	dbg.StepOver();
	testRegVal(cxx,"368","Packed Shift Left Logical 64");

	//	Packed Shift Right Arithmetic
	dbg.StepOver();
	testRegVal(cxx,"50","Packed Shift Right Arithmetic Word");

	dbg.StepOver();
	testRegVal(cxx,"0","Packed Shift Right Arithmetic Word");

	dbg.StepOver();
	testRegVal(cxx,"1","Packed Shift Right Arithmetic Word");

	dbg.StepOver();
	testRegVal(cxx,"0","Packed Shift Right Arithmetic Word");

	dbg.StepOver();
	testRegVal(cxx,"0","Packed Shift Right Arithmetic Word");

	
	dbg.StepOver();
	testRegVal(cxx,"50","Packed Shift Right Arithmetic Double");

	dbg.StepOver();
	testRegVal(cxx,"0","Packed Shift Right Arithmetic Double");

	dbg.StepOver();
	testRegVal(cxx,"1","Packed Shift Right Arithmetic Double");

	dbg.StepOver();
	testRegVal(cxx,"0","Packed Shift Right Arithmetic Double");

	dbg.StepOver();
	testRegVal(cxx,"0","Packed Shift Right Arithmetic Double");

	
	//	Packed Shift Right Logical
	dbg.StepOver();
	testRegVal(cxx,"16","Packed Shift Right Logical Word");

	dbg.StepOver();
	testRegVal(cxx,"0","Packed Shift Right Logical Word");

	dbg.StepOver();	//	=>0
	testRegVal(cxx,"0","Packed Shift Right Logical Word");

	dbg.StepOver();	//	=>0
	testRegVal(cxx,"0","Packed Shift Right Logical Word");

	dbg.StepOver();	//	=>1
	testRegVal(cxx,"1","Packed Shift Right Logical Word");

	
	dbg.StepOver();
	testRegVal(cxx,"16","Packed Shift Right Logical Double");

	dbg.StepOver();
	testRegVal(cxx,"0","Packed Shift Right Logical Double");

	dbg.StepOver();	//	0
	testRegVal(cxx,"0","Packed Shift Right Logical Double");

	dbg.StepOver();	//	1
	testRegVal(cxx,"1","Packed Shift Right Logical Double");

	dbg.StepOver();	//	0
	testRegVal(cxx,"0","Packed Shift Right Logical Double");

	
	dbg.StepOver();
	testRegVal(cxx,"16","Packed Shift Right Logical Q");

	dbg.StepOver();
	testRegVal(cxx,"0","Packed Shift Right Logical Q");

	//	Packed Subtract
	dbg.StepOver();
	testRegVal(cxx,"140","Packed Subtract Byte");

	dbg.StepOver();
	testRegVal(cxx,"496","Packed Subtract Byte");

	dbg.StepOver();
	testRegVal(cxx,"65636","Packed Subtract Byte");

	
	dbg.StepOver();
	testRegVal(cxx,"300","Packed Subtract Word");

	dbg.StepOver();
	testRegVal(cxx,"65650","Packed Subtract Word");

	dbg.StepOver();
	testRegVal(cxx,"4294967396","Packed Subtract Word");

	dbg.StepOver();
	testRegVal(cxx,"4295032826","Packed Subtract Word");


	dbg.StepOver();
	testRegVal(cxx,"300","Packed Subtract Double");

	dbg.StepOver();
	testRegVal(cxx,"4294967396","Packed Subtract Double");

	//	Packed Subtract with Saturation
	dbg.StepOver();
	testRegVal(cxx,"140","Byte Packed Subtract with Saturation");

	dbg.StepOver();
	testRegVal(cxx,"384","Byte Packed Subtract with Saturation");

	dbg.StepOver();
	testRegVal(cxx,"65664","Byte Packed Subtract with Saturation");

	
	dbg.StepOver();
	testRegVal(cxx,"300","Word Packed Subtract with Saturation");

	dbg.StepOver();
	testRegVal(cxx,"65650","Word Packed Subtract with Saturation");

	dbg.StepOver();
	testRegVal(cxx,"4294967396","Word Packed Subtract with Saturation");


	//	Packed Subtract Unsigned with Saturation
	dbg.StepOver();	//	all "correct" values
	testRegVal(cxx,"140","Byte Packed Subtract Unsigned with Saturation");

	dbg.StepOver();
	testRegVal(cxx,"300","Byte Packed Subtract Unsigned with Saturation");

	dbg.StepOver();
	testRegVal(cxx,"65636","Byte Packed Subtract Unsigned with Saturation");

	
	dbg.StepOver();
	testRegVal(cxx,"300","Word Packed Subtract Unsigned with Saturation");

	dbg.StepOver();
	testRegVal(cxx,"65650","Word Packed Subtract Unsigned with Saturation");

	dbg.StepOver();
	testRegVal(cxx,"4294967396","Word Packed Subtract Unsigned with Saturation");

	
	//	Unpack High Packed Data
	dbg.StepOver();
	testRegVal(cxx,"0","Unpack High Packed Data Word");

	dbg.StepOver();
	testRegVal(cxx,"0","Unpack High Packed Data Word");

	dbg.StepOver();
	testRegVal(cxx,"256","Unpack High Packed Data Word");

	dbg.StepOver();
	testRegVal(cxx,"1","Unpack High Packed Data Word");

	dbg.StepOver();
	testRegVal(cxx,"257","Unpack High Packed Data Word");
	

	dbg.StepOver();
	testRegVal(cxx,"0","Unpack High Packed Data Double");

	dbg.StepOver();
	testRegVal(cxx,"0","Unpack High Packed Data Double");

	dbg.StepOver();
	testRegVal(cxx,"65536","Unpack High Packed Data Double");

	dbg.StepOver();
	testRegVal(cxx,"1","Unpack High Packed Data Double");

	dbg.StepOver();
	testRegVal(cxx,"65537","Unpack High Packed Data Double");
	
	dbg.StepOver();
	testRegVal(cxx,"0","Unpack High Packed Data Q");

	dbg.StepOver();
	testRegVal(cxx,"0","Unpack High Packed Data Q");

	dbg.StepOver();
	testRegVal(cxx,"4294967296","Unpack High Packed Data Q");

	dbg.StepOver();
	testRegVal(cxx,"1","Unpack High Packed Data Q");

	dbg.StepOver();
	testRegVal(cxx,"4294967297","Unpack High Packed Data Q");
	
	//	Unpack Low Packed Data
	dbg.StepOver();
	testRegVal(cxx,"513","Unpack Low Packed Data Word");

	dbg.StepOver();
	testRegVal(cxx,"258","Unpack Low Packed Data Word");

	dbg.StepOver();
	testRegVal(cxx,"131073","Unpack Low Packed Data Double");

	dbg.StepOver();
	testRegVal(cxx,"65538","Unpack Low Packed Data Double");
	
	dbg.StepOver();
	testRegVal(cxx,"8589934593","Unpack Low Packed Data Q");

	dbg.StepOver();
	testRegVal(cxx,"4294967298","Unpack Low Packed Data Q");
	
	//	Bitwise Logical Exclusive OR
	dbg.StepOver();
	testRegVal(cxx,"240","Logical Exclusive OR");

	dbg.StepOver();
	testRegVal(cxx,"0","Logical Exclusive OR");

	cxx.Disable();
}
	
/*xbox void CEEPP::test_3dNow(COExpEval& cxx, CODebug& dbg, COSource& src)
{
	if (!(CMDLINE->GetBooleanValue("k6",FALSE)||CMDLINE->GetBooleanValue("k7",FALSE))) 
		return;	//	exit if 3dnow switch is not set	

	// Restart and Go to the line at which we want to begin our tests

	EXPECT_TRUE(dbg.Restart());
	MST.DoKeys("{ESC}");	
	EXPECT_TRUE(src.Find("test_3dNow();")); 
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepInto());	
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StepOver());

	cxx.Enable(EE_ALL_INFO);

	char MMijReg[][8] = {	"MM00", "MM01", "MM10", "MM11", "MM20", "MM21", "MM30", "MM31", 
							"MM40", "MM41",	"MM50", "MM51", "MM60", "MM61", "MM70", "MM71"	};

	int num_reg = 16;
	int count = 0;

	//	set value in watch window
	EXPECT_TRUE(dbg.ToggleHexDisplay(FALSE));
	for (count = 0; count <num_reg; count++)
	{
		EXPECT_TRUE(cxx.SetExpressionValue(MMijReg[count],count*50));
	}

	//	do one stepover
	EXPECT_TRUE(dbg.StepOver());

	//	verify value in watch window
	for (count = 0; count <num_reg; count++)
	{
		char str[16];
		float fVal = (float) count*50;
		sprintf(str,"%f",fVal);
		if (count==0) 
			str[8] = '\0';	//	0 is shown as 0.000000
		else
			str[7] = '\0';
		
		testRegVal(MMijReg[count], "float", cxx, str,"Test MMij in Watch");
	}

	//	verify value in register window

	EXPECT_TRUE(regs.Enable());

	for (count = 0; count < num_reg; count++)
	{
		char str[16];
		double d = count*50;		
		sprintf(str,"+%.5E",d);

		EXPECT_TRUE(regs.RegisterValueIs(MMijReg[count], str, 0, TRUE));	
	}

	EXPECT_TRUE(regs.Disable());


	//	average of unsigned int bytes
	dbg.StepOver();
	testRegVal(cxx,"1","average of unsigned int bytes");

	dbg.StepOver();
	testRegVal(cxx,"1","average of unsigned int bytes");
	
	dbg.StepOver();
	testRegVal(cxx,"1","average of unsigned int bytes");
	
	dbg.StepOver();
	testRegVal(cxx,"734423025668","average of unsigned int bytes");


	//	float to 32 bit signed int

	dbg.StepOver();
	testRegVal(cxx,"2147483647","float to 32 bit signed int");

	dbg.StepOver();
	testRegVal(cxx,"9223372034707292159","float to 32 bit signed int");
	
	dbg.StepOver();
	testRegVal(cxx,"1","float to 32 bit signed int");
	
	dbg.StepOver();
	testRegVal(cxx,"4","float to 32 bit signed int");

	//	accumulator
	dbg.StepOver();
	testRegVal(cxx,"4575657231080488962","accumulator");
	
	dbg.StepOver();
	testRegVal(cxx,"1065353218","accumulator");

	dbg.StepOver();
	testRegVal(cxx,"4575657229998358528","accumulator");

	//	add
	dbg.StepOver();
	testRegVal(cxx,"1065353218","add");
	
	dbg.StepOver();
	testRegVal(cxx,"1077936131","add");

	dbg.StepOver();
	testRegVal(cxx,"1088421892","add");

	//	compare for equal
	dbg.StepOver();
	testRegVal(cxx,"18446744073709551615","compare for equal");
	
	dbg.StepOver();
	testRegVal(cxx,"18446744069414584320","compare for equal");

	dbg.StepOver();
	testRegVal(cxx,"18446744073709551615","compare for equal");

	dbg.StepOver();
	testRegVal(cxx,"4294967295","compare for equal");

	dbg.StepOver();
	testRegVal(cxx,"0","compare for equal");

	//	compare for greater than or equal to
	dbg.StepOver();
	testRegVal(cxx,"18446744073709551615","compare for greater than or equal to");
	
	dbg.StepOver();
	testRegVal(cxx,"18446744073709551615","compare for greater than or equal to");

	dbg.StepOver();
	testRegVal(cxx,"18446744073709551615","compare for greater than or equal to");

	dbg.StepOver();
	testRegVal(cxx,"18446744069414584320","compare for greater than or equal to");

	//	compare for greater than
	dbg.StepOver();
	testRegVal(cxx,"0","compare for greater than");
	
	dbg.StepOver();
	testRegVal(cxx,"0","compare for greater than");

	dbg.StepOver();
	testRegVal(cxx,"18446744069414584320","compare for greater than");

	dbg.StepOver();
	testRegVal(cxx,"18446744073709551615","compare for greater than");

	//	maximum
	dbg.StepOver();
	testRegVal(cxx,"0","maximum");
	
	dbg.StepOver();
	testRegVal(cxx,"4575657231063711746","maximum");

	dbg.StepOver();
	testRegVal(cxx,"4575657231076294659","maximum");

	dbg.StepOver();
	testRegVal(cxx,"4611686028095258627","maximum");

	//	minimum
	dbg.StepOver();
	testRegVal(cxx,"0","minimum");
	
	dbg.StepOver();
	testRegVal(cxx,"0","minimum");

	dbg.StepOver();
	testRegVal(cxx,"4575657231072100354","minimum");

	dbg.StepOver();
	testRegVal(cxx,"1065353218","minimum");

	//	multiply
	dbg.StepOver();
	testRegVal(cxx,"0","multiply");
	
	dbg.StepOver();
	testRegVal(cxx,"0","multiply");

	dbg.StepOver();
	testRegVal(cxx,"4611686036693581830","multiply");

	//	reciprocal
	dbg.StepOver();
	testRegVal(cxx,"9187343237679939583","reciprocal");
	
	dbg.StepOver();
	testRegVal(cxx,"4539626226423168512","reciprocal");

	dbg.StepOver();
	testRegVal(cxx,"1084227265","reciprocal");

	//	reciprocal, reciprocal intermediate step 1, reciprocal intermediate step 2
	dbg.StepOver();
	testRegVal(cxx,"4539626226423168512","reciprocal step1 step 2");
	
	dbg.StepOver();
	testRegVal(1, cxx,"1065418239","reciprocal step1 step 2");

	dbg.StepOver();
	testRegVal(cxx,"1057029630","reciprocal step1 step 2");

	dbg.StepOver();
	testRegVal(cxx,"1084308863","reciprocal step1 step 2");
	
	//	reciprocal sqrt
	dbg.StepOver();
	testRegVal(cxx,"9187343237679939583","reciprocal sqrt");
	
	dbg.StepOver();
	testRegVal(cxx,"4539627325934796544","reciprocal sqrt");

	dbg.StepOver();
	testRegVal(cxx,"4515608494420437504","reciprocal sqrt");

	//	reciprocal sqrt, reciprocal sqrt intermediate step 1	
	dbg.StepOver();
	testRegVal(cxx,"4539627325934796544","reciprocal sqrt, step 1");
	
	dbg.StepOver();
	testRegVal(1, cxx,"1065369343","reciprocal sqrt, step 1");

	dbg.StepOver();
	testRegVal(cxx,"4515608494420437504","reciprocal sqrt, step 1");

	dbg.StepOver();
	testRegVal(1, cxx,"1065365418","reciprocal sqrt, step 1");	

	//	subtract
	dbg.StepOver();
	testRegVal(cxx,"0","subtract");
	
	dbg.StepOver();
	testRegVal(cxx,"0","subtract");

	dbg.StepOver();
	testRegVal(cxx,"1077936131","subtract");

	dbg.StepOver();
	testRegVal(cxx,"4575657231072100354","subtract");

	//	reverse subtraction
	dbg.StepOver();
	testRegVal(cxx,"0","reverse subtraction");
	
	dbg.StepOver();
	testRegVal(cxx,"0","reverse subtraction");

	dbg.StepOver();
	testRegVal(cxx,"1077936131","reverse subtraction");

	dbg.StepOver();
	testRegVal(cxx,"4575657231072100354","reverse subtraction");

	//	32 bit signed int to float
	dbg.StepOver();
	testRegVal(cxx,"1065353216","32 bit signed int to float");
	
	dbg.StepOver();
	testRegVal(cxx,"4629700418010611712","32 bit signed int to float");

	dbg.StepOver();
	testRegVal(cxx,"4611686019492741120","32 bit signed int to float");

	//	multiply high
	dbg.StepOver();
	testRegVal(cxx,"0","multiply high");
	
	dbg.StepOver();
	testRegVal(cxx,"0","multiply high");

	dbg.StepOver();
	testRegVal(cxx,"8590000129","multiply high");

	cxx.Disable();
}*/
     
/*xbox void CEEPP::test_3dNowEnhanced(COExpEval& cxx, CODebug& dbg, COSource& src)
{
	if (!CMDLINE->GetBooleanValue("k7",FALSE)) return;		//	exit if k7 switch is not set	

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	MST.DoKeys("{ESC}");	
	EXPECT_TRUE(src.Find("test_3dNowEnhanced();")); 
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepInto());	
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StepOver());

	cxx.Enable(EE_ALL_INFO);

	//	packed float to int word with sign extend
	dbg.StepOver();
	testRegVal(cxx,"0","packed float to int word with sign extend");

	dbg.StepOver();
	testRegVal(cxx,"30064771076","packed float to int word with sign extend");

	dbg.StepOver();
	testRegVal(cxx,"42949672960","packed float to int word with sign extend");

	dbg.StepOver();
	testRegVal(cxx,"18446744069414584319","packed float to int word with sign extend");

	dbg.StepOver();
	testRegVal(cxx,"4294934528","packed float to int word with sign extend");

	//	packed float negative accumulate
	dbg.StepOver();
	testRegVal(cxx,"0","packed float negative accumulate");

	dbg.StepOver();
	testRegVal(cxx,"4629700416936869888","packed float negative accumulate");

	dbg.StepOver();
	testRegVal(cxx,"13799029259328552960","packed float negative accumulate");

	//	packed float mixed +ve -ve accumulate
	dbg.StepOver();
	testRegVal(cxx,"0","packed float mixed +ve -ve accumulate");

	dbg.StepOver();
	testRegVal(cxx,"1077936128","packed float mixed +ve -ve accumulate");

	dbg.StepOver();
	testRegVal(cxx,"4688247221760557056","packed float mixed +ve -ve accumulate");
   
	//	packed int word to float
	//	somewhat erroneous values
	dbg.StepOver();
	testRegVal(cxx,"1065353216","packed int word to float");

	dbg.StepOver();
	testRegVal(cxx,"13835058058495000576","packed int word to float");

	dbg.StepOver();
	testRegVal(cxx,"4674736414292705280","packed int word to float");

	dbg.StepOver();
	testRegVal(cxx,"4692750811720056832","packed int word to float");

	dbg.StepOver();
	testRegVal(cxx,"3338665984","packed int word to float");

	//	packed swap double word
	dbg.StepOver();
	testRegVal(cxx,"4294967296","packed swap double word");

	dbg.StepOver();
	testRegVal(cxx,"25769803777","packed swap double word");

	dbg.StepOver();
	testRegVal(cxx,"6","packed swap double word");

	//	streaming store using byte mask
	dbg.StepOver();
	dbg.StepOver();
	dbg.StepOver();

	//	streaming store
	dbg.StepOver();
	testRegVal("count", "__int64", cxx,"10","streaming store");

	dbg.StepOver();
	testRegVal("count", "__int64", cxx,"34359738373","streaming store");

			
	//	packed avg of unsigned byte	
	dbg.StepOver();
	testRegVal(cxx,"1","packed avg of unsigned byte");

	dbg.StepOver();
	testRegVal(cxx,"1","packed avg of unsigned byte");

	dbg.StepOver();
	testRegVal(cxx,"1","packed avg of unsigned byte");

	dbg.StepOver();
	testRegVal(cxx,"734423025668","packed avg of unsigned byte");
	
	//	packed avg of unsigned word	
	dbg.StepOver();
	testRegVal(cxx,"1","packed avg of unsigned word");

	dbg.StepOver();
	testRegVal(cxx,"12293138128684057218","packed avg of unsigned word");

	dbg.StepOver();
	testRegVal(cxx,"55000","packed avg of unsigned word");

	//	extract word into int register
	dbg.StepOver();
	testRegVal("eax", "unsigned long", cxx,"0","extract word into int register");

	dbg.StepOver();
	testRegVal("eax", "unsigned long", cxx,"1","extract word into int register");

	//	insert word from int register
	dbg.StepOver();
	testRegVal(cxx,"131076","insert word from int register");

	//	packed max signed word
	dbg.StepOver();
	testRegVal(cxx,"576742223002009601","packed max signed word");

	dbg.StepOver();
	testRegVal(cxx,"1431633926","packed max signed word");
	
	//	packed max unsigned byte
	dbg.StepOver();
	testRegVal(cxx,"1834219928319","packed max unsigned byte");
	
	//	packed min signed word
	dbg.StepOver();
	testRegVal(cxx,"533958022247022591","packed min signed word");

	dbg.StepOver();
	testRegVal(cxx,"1431633921","packed min signed word");
	
	//	packed min unsigned byte	
	dbg.StepOver();
	testRegVal(cxx,"730396487935","packed min unsigned byte");
	
	//	move mask to integer register
	dbg.StepOver();
	testRegVal("eax", "unsigned long", cxx,"217","move mask to integer register");
	
	//	packed multiply high unsigned word
	dbg.StepOver();
	testRegVal(cxx,"281474976841729","packed multiply high unsigned word");

	//	prefetch non-temporal access
	dbg.StepOver();
	
	//	prefetch to all cache levels
	dbg.StepOver();
	
	//	prefetch to all cache levels except 0
	dbg.StepOver();
	
	//	prefetch to all cache levels except 0 & 1
	dbg.StepOver();

	//	packed sum of absolute byte differences
	dbg.StepOver();
	testRegVal(cxx,"35","packed sum of absolute byte differences");

	dbg.StepOver();
	testRegVal(cxx,"35","packed sum of absolute byte differences");
	
	//	packed shuffle word
	dbg.StepOver();
	testRegVal(cxx,"281479271743489","packed shuffle word");

	dbg.StepOver();
	testRegVal(cxx,"578437695752307201","packed shuffle word");

	//	sfence
	dbg.StepOver();

	cxx.Disable();
}*/


void CEEPP::test_Katmai(COExpEval& cxx, CODebug& dbg, COSource& src)
{
	if (!(CMDLINE->GetBooleanValue("kni",FALSE)||CMDLINE->GetBooleanValue("wni",FALSE))) 
		return;	//	exit if P3 switch is not set	

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	MST.DoKeys("{ESC}");	
	EXPECT_TRUE(src.Find("test_Katmai();")); 
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepInto());	
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StepOver());

	cxx.Enable(EE_ALL_INFO);

	char XMMijReg[][8] = {	"XMM00", "XMM01", "XMM02", "XMM03", 
							"XMM10", "XMM11", "XMM12", "XMM13", 
							"XMM20", "XMM21", "XMM22", "XMM23", 
							"XMM30", "XMM31", "XMM32", "XMM33", 
							"XMM40", "XMM41", "XMM42", "XMM43", 
							"XMM50", "XMM51", "XMM52", "XMM53", 
							"XMM60", "XMM61", "XMM62", "XMM63", 
							"XMM70", "XMM71", "XMM72", "XMM73"	};

	int num_reg = 32;
	int count = 0;

	//	set value in watch window
	for (count = 0; count <num_reg; count++)
	{
		cxx.SetExpressionValue(XMMijReg[count],count*50);
	}

	//	do one stepover
	EXPECT_TRUE(dbg.StepOver());

	//	verify value in watch window
	for (count = 0; count <num_reg; count++)
	{
		cxx.ExpressionValueIs(XMMijReg[count],count*50);
	}

	//	verify value in register window

	EXPECT_TRUE(regs.Enable());

	for (count = 0; count < num_reg; count++)
	{
		char str[16];
		double d = count*50;		
		sprintf(str,"+%.5E",d);

		EXPECT_TRUE(regs.RegisterValueIs(XMMijReg[count], str, 0, TRUE));	
	}

	EXPECT_TRUE(regs.Disable());


	//	verifying each register for expression evaluation
	dbg.StepOver();
	testRegVal(0, cxx,"1.00000","2.00000","3.00000","4.00000","verification xmm0");

	dbg.StepOver();
	testRegVal(1, cxx,"2.00000","3.00000","4.00000","5.00000","verification xmm1");

	dbg.StepOver();
	testRegVal(2, cxx,"3.00000","4.00000","5.00000","6.00000","verification xmm2");

	dbg.StepOver();
	testRegVal(3, cxx,"4.00000","5.00000","6.00000","7.00000","verification xmm3");

	dbg.StepOver();
	testRegVal(4, cxx,"5.00000","6.00000","7.00000","8.00000","verification xmm4");

	dbg.StepOver();
	testRegVal(5, cxx,"6.00000","7.00000","8.00000","9.00000","verification xmm5");

	dbg.StepOver();
	testRegVal(6, cxx,"7.00000","8.00000","9.00000","10.0000","verification xmm6");

	dbg.StepOver();
	testRegVal(7, cxx,"-1.00000","-2.00000","-3.00000", "6.00000","verification xmm7");


	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"3.00000","5.00000","7.00000","9.00000","addps");

	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","9.00000","addss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"0.000000","4.00000","0.000000","1.00000","andnps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"2.00000","2.00000","3.00000","3.50000","andnps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"0.000000","0.000000","0.000000","0.000000","andps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","4.00000","andps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"-1.#QNAN","-1.#QNAN","-1.#QNAN","0.000000","cmpeqps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"-1.#QNAN","-1.#QNAN","-1.#QNAN","-1.#QNAN","cmpeqps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","0.000000","cmpeqss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","-1.#QNAN","cmpeqss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"0.000000","-1.#QNAN","0.000000","0.000000","cmpltps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","0.000000","cmpltss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","0.000000","cmpltss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","-1.#QNAN","cmpltss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"-1.#QNAN","-1.#QNAN","0.000000","0.000000","cmpleps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","0.000000","cmpless");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","-1.#QNAN","cmpless");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","-1.#QNAN","cmpless");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"0.000000","-1.#QNAN","-1.#QNAN","0.000000","cmpneqps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","0.000000","cmpneqss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","-1.#QNAN","cmpneqss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"0.000000","-1.#QNAN","0.000000","-1.#QNAN","cmpnltps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","-1.#QNAN","cmpnltss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","0.000000","cmpnltss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","-1.#QNAN","cmpnltss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"0.000000","0.000000","0.000000","-1.#QNAN","cmpnleps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","-1.#QNAN","cmpnless");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","0.000000","cmpnless");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","0.000000","cmpnless");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","4.00000","comiss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","4.00000","comiss");
	
	dbg.StepOver();
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","4.00000","cvtpi2ps");

	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"8589934597","cvtps2pi");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","17.0000","cvtsi2ss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal("eax","unsigned long", cxx, "4", "cvtss2si");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"30064771077","cvttps2pi");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal("eax","unsigned long", cxx, "7", "cvttss2si");

	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"0.500000","1.00000","3.00000","4.00000","divps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","5.00000","divss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"5.00000","2.00000","9.00000","5.00000","maxps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"5.00000","2.00000","7.00000","6.00000","maxss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"5.00000","2.00000","7.00000","4.00000","maxss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"4.00000","2.00000","7.00000","3.00000","minps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","6.00000","minss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","4.00000","minss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"5.00000","6.00000","7.00000","8.00000","movaps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","5.00000","6.00000","movhlps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"6.00000","7.00000","3.00000","4.00000","movhps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","6.00000","7.00000","movlps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"5.00000","6.00000","3.00000","4.00000","movlhps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal("eax","unsigned long", cxx, "5", "movmskps");

	dbg.StepOver();
	dbg.StepOver();
	testRegVal("Var128.m128_f32[0]", "float", cxx, "-1.00000" ,"movntps");
	testRegVal("Var128.m128_f32[1]", "float", cxx, "9.00000" ,"movntps");
	testRegVal("Var128.m128_f32[2]", "float", cxx, "8.00000" ,"movntps");
	testRegVal("Var128.m128_f32[3]", "float", cxx, "7.00000" ,"movntps");

	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"0.000000","0.000000","0.000000","9.00000","movss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"5.00000","6.00000","7.00000","8.00000","movups");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"2.00000","6.00000","0.000000","10.0000","mulps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","8.00000","mulss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","3.00000","6.00000","5.00000","orps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"0.499878","0.333252","0.249939","0.199951","rcpps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","0.499878","rcpss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"0.999756","0.577271","0.499878","0.333252","rsqrtps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","0.333252","rsqrtss");
	
	dbg.StepOver();

	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"7.00000","5.00000","4.00000","2.00000","shufps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","1.73205","2.00000","3.00000","sqrtps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","3.00000","sqrtss");

	dbg.StepOver();
	testRegVal("i32Val","long", cxx, "8096", "stmxcsr");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"-1.00000","5.00000","1.00000","3.00000","subps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","8.00000","5.00000","-2.00000","subss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","4.00000","ucomiss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"1.00000","2.00000","3.00000","5.00000","ucomiss");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"5.00000","1.00000","6.00000","2.00000","unpckhps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"7.00000","3.00000","8.00000","4.00000","unpcklps");
	
	dbg.StepOver();
	dbg.StepOver();
	testRegVal(cxx,"0.000000","0.000000","1.76324e-038","2.93874e-039","xorps");

	cxx.Disable();

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\exe\exesub.h ===
///////////////////////////////////////////////////////////////////////////////
//	exesub.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CexeSubSuite class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CexeSubSuite class

class CexeSubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CexeSubSuite)
//exeSubSuite() { m_strName = "TestWizard Generated script"; m_strOwner = "VCBU QA"; }


	DECLARE_TESTLIST()
protected:
	void CleanUp(void);
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\exe\execase.h ===
///////////////////////////////////////////////////////////////////////////////
//	execase.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CexeIDETest Class
//

#ifndef __execase_H__
#define __execase_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\dbgtestbase.h"
#include "exesub.h"

///////////////////////////////////////////////////////////////////////////////
//	CexeIDETest class

class CexeIDETest : public CDbgTestBase
{
	DECLARE_TEST(CexeIDETest, CexeSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run();

// Test Cases
protected:

	// Go cases
	BOOL GoAndVerify();
	BOOL RestartAndGo();
	BOOL RestartStopDebugging();

	// Step cases
	BOOL StepIntoSource();
	BOOL StepOverSource();
	BOOL StepOutSource();
	BOOL StepToCursorSource();
	BOOL StepOverFuncToBreakAtLocBP();
	BOOL StepOverFuncToBreakOnExprTrueBP();
	BOOL StepOverFuncToBreakOnExprChangesBP();
	BOOL TraceIntoWndProc();

	BOOL StepModel();
	BOOL BreakStepTrace();

};

#endif //__execase_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\ee\eespec.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	EECASE.CPP
//											 
//	Created by :			
//		VCBU QA		
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "eespec.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
IMPLEMENT_TEST(CSpecialTypesTest, CDbgTestBase, "PtFns VARIANTs GUIDs HRs Errs MMX", -1, CEESubSuite)
									   
												 
void CSpecialTypesTest::PreRun(void)
	{
	// call the base class
	CTest::PreRun();
	}


void CSpecialTypesTest::Run(void)	
{
	/******************
	 * INITIALIZATION * non-incremental - just for PointerToFunctions
	 ******************/
#pragma message (__LOC__ "Revise incremental & add other switches when VC#8157 fixed")
	if(!SetProject("ee2\\ee2", PROJECT_XBE))
	{
		m_pLog->RecordInfo("ERROR: could not init non-incremental ee2 project");
		return;
	}

	// step into the main function
	dbg.StepInto();	
	dbg.SetSteppingMode(SRC);

	EXPECT_TRUE( src.AttachActiveEditor() );
	cxx.Enable();
	/******************************************
	 * PointerToFunc on non-incremental build *
	 ******************************************/
#pragma message (__LOC__ "Disabled PointerToFun, because VC98#8157 is postponed")
//	PointerToFun();

	/******************
	 * INITIALIZATION *
	 ******************/
	if(!SetProject("ee2\\ee2", PROJECT_EXE, fDefault, "INCREMENTAL"))
	{
		m_pLog->RecordInfo("ERROR: could not init incremental ee2 project");
		return;
	}

	// step into the main function
	dbg.StepInto();	
	dbg.SetSteppingMode(SRC);

	EXPECT_TRUE( src.AttachActiveEditor() );
	cxx.Enable();

	EXPECT_TRUE(cxx.GetExpressionValue("@TIB", m_TIBValue) );
		
	/*********
	 * TESTS *
	 *********/
#pragma message (__LOC__ "Disabled PointerToFun, because VC98#8157 is postponed")
//	PointerToFun();
	XSAFETY;
	GUIDs();
	XSAFETY;
	//xbox - no variants
	//Variants();
	//XSAFETY;
	MMXRegs();
	XSAFETY;
	ErrorCodes();

	StopDbgCloseProject();
}

//PointerToFun
void CSpecialTypesTest::PointerToFun(void)
{
 	LogTestHeader( "PointerToFunctions Test" );

	EXPECT_TRUE(bps.SetBreakpoint("pointers_to_functions") );
	EXPECT_TRUE(dbg.Go("pointers_to_functions") );
//pointers to functions
	EXPECT_TRUE( src.Find("aclass.pfnint = afuncint;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "aclass.pfnint = afuncint;") );

	EXPECT_TRUE(cxx.ExpressionValueSubstringIs("pfunint_table[0]", "ADDRESS afuncint(void *,unsigned long)") );
	EXPECT_TRUE(cxx.ExpressionValueSubstringIs("pfunvar", "ADDRESS afunvar1(char *, <no type>)") );

	EXPECT_TRUE(cxx.ExpressionValueSubstringIs("afuncint", "ADDRESS afuncint(void *, unsigned long)") );
	EXPECT_TRUE(cxx.ExpressionValueSubstringIs("afunvar1", "ADDRESS afunvar1(char *, <no type>)") );

//pointers to functions as members of class
	EXPECT_TRUE(dbg.CurrentLineIs("aclass.pfnint = afuncint;") );
	EXPECT_TRUE(dbg.StepOver() );
	EXPECT_TRUE(cxx.ExpressionValueSubstringIs("pclass->pfnint", "ADDRESS afuncint(void *, unsigned long)") );

	EXPECT_TRUE(dbg.CurrentLineIs("aclass.pfnvar = afuncvar;") );
	EXPECT_TRUE(dbg.StepOver() );
	EXPECT_TRUE(cxx.ExpressionValueSubstringIs("pclass->pfnvar", "ADDRESS afuncvar(void *, <no type>)") );

	EXPECT_TRUE(dbg.CurrentLineIs("aclass.pfnvar = (PFNVAR)afunvar1;") );
	EXPECT_TRUE(dbg.StepOver() );
	EXPECT_TRUE(cxx.ExpressionValueSubstringIs("pclass->pfnvar", "ADDRESS afunvar1(char *, <no type>)") );

	EXPECT_TRUE(dbg.CurrentLineIs("aclass.pfnvar = (PFNVAR)afunvar2;") );
	EXPECT_TRUE(dbg.StepOver() );
	EXPECT_TRUE(cxx.ExpressionValueSubstringIs("pclass->pfnvar", "ADDRESS afunvar2(int *, int, <no type>)") );
//stepping into the class member - pointer to a function
	EXPECT_TRUE( src.Find("ret=(*aclass.pfnvar)(&ret,15,&ret);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL) );
	EXPECT_TRUE( dbg.StepInto( ) );
	EXPECT_TRUE( dbg.AtSymbol("afunvar2") );

//chaek if vtable pointers are correct
	EXPECT_TRUE( src.Find("memset(class_table,0, sizeof(class_table));") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "memset(class_table,0, sizeof(class_table));") );
	EXPECT_TRUE(cxx.ExpressionValueSubstringIs("(class_table[0]).__vfptr[0]", "ADDRESS AClass::virt_method1(void)") );
	EXPECT_TRUE(cxx.ExpressionValueSubstringIs("(class_table[0]).__vfptr[1]", "ADDRESS AClass::virt_method2(long, <no type>)") );
	//NULLify all pointers by executing memset(0,...)
	EXPECT_TRUE( dbg.StepOver( ) );
	EXPECT_TRUE( cxx.ExpressionErrorIs("(class_table[0]).__vfptr[0]", "Error: cannot display value") );
	EXPECT_TRUE( cxx.ExpressionErrorIs("(class_table[0]).__vfptr[1]", "Error: cannot display value") );
	//assign the object from a class
	EXPECT_TRUE(dbg.CurrentLineIs("class_table[0] = aclass;") );
	EXPECT_TRUE( dbg.StepOver( ) );
//class assignment does override function pointers but does not override vtable
	EXPECT_TRUE(cxx.ExpressionValueSubstringIs("(aclass).__vfptr[0]", "ADDRESS AClass::virt_method1(void)") );
	EXPECT_TRUE(cxx.ExpressionValueSubstringIs("(aclass).__vfptr[1]", "ADDRESS AClass::virt_method2(long, <no type>)") );
	EXPECT_TRUE(cxx.ExpressionValueSubstringIs("class_table[0].pfnint", "ADDRESS afuncint(void *, unsigned long)") );
	EXPECT_TRUE(cxx.ExpressionValueSubstringIs("class_table[0].pfnvar", "ADDRESS afunvar2(int *, int, <no type>)") );
	EXPECT_TRUE(cxx.ExpressionErrorIs("(class_table[0]).__vfptr[0]", "Error: cannot display value") );
	EXPECT_TRUE(cxx.ExpressionErrorIs("(class_table[0]).__vfptr[1]", "Error: cannot display value") );
//function which returns a pointer to a function
	EXPECT_TRUE(bps.SetBreakpoint("fun_return_pfn") );
	EXPECT_TRUE(dbg.Go("fun_return_pfn") );
	EXPECT_TRUE(dbg.StepOut() );
//verify in autopane the string "fun_return_pfn returned"	"ADDRESS afuncint(void *, unsigned long)"
	uivar.Activate();
	ERROR_SUCCESS(uivar.SetPane(PANE_AUTO) );
	EXPR_INFO expr_info_actual[1], expr_info_expected[1];
	
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));

	
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, 
		"void (void *, unsigned long)*",
		"fun_return_pfn returned",
		"ADDRESS afuncint(void *, unsigned long)");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1) );
	EXPECT_TRUE(dbg.ShowNextStatement() ); //uivar.Activate() steals the focus
	
	bps.ClearAllBreakpoints();
}//PointerToFun


//GUIDs
//xbox - changed IID_IClassFactory2 to IID_ISequentialStream
void CSpecialTypesTest::GUIDs(void)
{
 	LogTestHeader( "GUIDs Test" );
	
	char badGUIDstring[40]; //{????????-????-????-????-????????????}
	memset(badGUIDstring,'?',sizeof(badGUIDstring));
	badGUIDstring[0]='{';badGUIDstring[37]='}';badGUIDstring[38]=0;
	badGUIDstring[9]=badGUIDstring[14]=badGUIDstring[19]=badGUIDstring[24]='-';
	
	EXPECT_TRUE(bps.SetBreakpoint("guids_and_refguids") );
	EXPECT_TRUE(dbg.Go("guids_and_refguids") );
//check some global guids initialization
	EXPECT_TRUE( cxx.ExpressionValueIs("Global_Guid", "{00000000-0000-0000-0000-000000000000}") );
	EXPECT_TRUE( cxx.ExpressionValueIs("unKnownGuid", "{F0FF0FF0-FF0F-FF0F-FF00-FF00FF00FF00}") );

//check all value (including locals) at the following checkpoint	
	EXPECT_TRUE( src.Find("pGuid =&CLSID_PSGenObject;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, /*"pGuid*/"d =&CLSID_PSGenObject;") );
	MST.DoKeys("{HOME}"); //get out of the assignment

	EXPECT_TRUE( cxx.ExpressionValueIs("Guid", "{IID_IClassFactory}") );
	EXPECT_TRUE( cxx.ExpressionValueIs("Global_Guid", "{IID_ISequentialStream}") );
	EXPECT_TRUE( cxx.ExpressionValueSubstringIs("pGuid", "ADDRESS {IID_IClassFactory}") );
	EXPECT_TRUE(cxx.ExpressionErrorIs("pBadGuid", CString("0x00000005 ") + badGUIDstring) );
	EXPECT_TRUE(cxx.ExpressionErrorIs("pBadrefId", badGUIDstring) );
	EXPECT_TRUE( cxx.ExpressionValueIs("unKnown", "{F0FF0FF0-FF0F-FF0F-FF00-FF00FF00FF00}") );

//check all REFIIDs after the checkpoint was executed
	EXPECT_TRUE( src.Find("return_Unknown();") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "return_Unknown();") );
static char* data[][2] = {
	/*
	"refiid0",		"{IID_IUnknown}",
	"refiid1",		"{IID_IDispatch}",
	"refiid2",		"{IID_IMoniker}",
	"refiid3",		"{IID_IEnumString}",
	"refiid4",		"{IID_IStream}",
	"refiid5",		"{IID_IStorage}",
	"refiid6",		"{IID_IPersistStorage}",
	"refiid7",		"{IID_IPersist}",
	"refiid8",		"{IID_IActiveScript}",
	"refiid9",		"{IID_IObjectSafety}",
	*/
	"refiid0",		"{IID_IUnknown}",
	"refiid1",		"{IID_IRpcChannel}",
	"refiid2",		"{IID_IRpcStub}",
	"refiid3",		"{IID_IStubManager}",
	"refiid4",		"{IID_IStream}",
	"refiid5",		"{IID_IEnumGeneric}",
	"refiid6",		"{IID_IEnumHolder}",
	"refiid7",		"{IID_IEnumCallback}",
	"refiid8",		"{IID_IDebug}",
	"refiid9",		"{IID_IDebugStream}"
};
	for(int i = 0; i < (sizeof(data) / (sizeof(CString) * 2)); i++)
	{
		LOG->RecordCompare(cxx.ExpressionValueIs(data[i][0], data[i][1]),
			"Expression:(%s), expected:(%s)\n", data[i][0],data[i][1]);
	}

	uivar.Activate();
	ERROR_SUCCESS(uivar.SetPane(PANE_AUTO) );
	EXPR_INFO expr_info_actual[1], expr_info_expected[1];

	EXPECT_TRUE( dbg.StepOver() );
//verify in autopane the string "const _GUID &" "return_Unknown returned"	"{IID_IUnknown}"
		
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, 
		"const _GUID &",
		"return_Unknown returned",
		"{IID_IUnknown}");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1) );

	EXPECT_TRUE( dbg.StepOver() );		
//verify in autopane the string "_GUID" "return_GUIDUnknown returned"	"{IID_IUnknown}"
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, 
		"_GUID",
		"return_GUIDUnknown returned",
		"{IID_IUnknown}");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1) );

	EXPECT_TRUE(dbg.ShowNextStatement() ); //uivar.Activate() steals the focus
	bps.ClearAllBreakpoints();
}//GUIDs


#if 0 //xbox - no variants in xbox
//VARIANTs
#include <wtypes.h> //for VT_BYREF define
void CSpecialTypesTest::Variants(void)
{
 	LogTestHeader( "VARIANTs Test" );
	char badVARIANTstring[6]; //{???}
	memset(badVARIANTstring,'?',sizeof(badVARIANTstring));
	badVARIANTstring[0]='{';badVARIANTstring[4]='}';badVARIANTstring[5]=0;

//check the variant1 before being initialized
	EXPECT_TRUE( src.Find("::VariantInit(&variant1);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "VariantInit(&variant1);") );
	EXPECT_TRUE( cxx.ExpressionValueIs("variant1", badVARIANTstring) );
	EXPECT_TRUE(dbg.StepOver() ); //initialize the variant

//	added by dverma 4/25/2000 to check date for Win NT
	char strDateVal[64];

	if (GetSystem() == SYSTEM_NT_4)	//	NT4.0
		sprintf(strDateVal,"{1/1/96 12:00:00 AM VT_DATE}");	
	else
		sprintf(strDateVal,"{1/1/1996 12:00:00 AM VT_DATE}");	
		
	//check the variant1 assigned different values
	static char* variant1data[][2] = { //"line of code identifying variant", "variant value" 
		"variant1.vt = VT_I4;",		"{1052 VT_I4}",
		"variant1.vt = VT_UI1;",	"{255 VT_UI1}",
		"variant1.vt = VT_I2;",		"{32000 VT_I2}",
		"variant1.vt = VT_R4;",		"{20.0000 VT_R4}",
		"variant1.vt = VT_R8;",		"{3.1400000000000e+100 VT_R8}",
		"variant1.vt = VT_BOOL;",	"{True VT_BOOL}",
		"variant1.vt = VT_ERROR;",	"{0x80004005 VT_ERROR}",
		"variant1.vt = VT_CY;",		"{922337203685477.5807 VT_CY}",
		"variant1.vt = VT_DATE;",	strDateVal
	};

	for(int i = 0; i < (sizeof(variant1data) / (sizeof(CString) * 2)); i++)
	{
		EXPECT_TRUE(dbg.CurrentLineIs(variant1data[i][0]) );
		dbg.StepOver(2);
		LOG->RecordCompare(cxx.ExpressionValueIs("variant1", variant1data[i][1]),
			"variant1 expected:(%s)\n",variant1data[i][1]);
	}
//check the variant2 assigned different stricte automation type values
	EXPECT_TRUE( src.Find("variant2.vt = VT_BSTR;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "variant2.vt = VT_BSTR;") );
	EXPECT_TRUE( dbg.StepOver() );
	
	//	modified by dverma 6/21/2000 - now variant shows string instead of badvalue
//	EXPECT_TRUE( cxx.ExpressionValueIs("variant2", badVARIANTstring) ); //VT_BSTR but pointing to bad address
	char tempstr[16];
	strcpy(tempstr,"{\"\" VT_BSTR}");	//	{"" VT_BSTR}
	EXPECT_TRUE( cxx.ExpressionValueIs("variant2", tempstr) ); //VT_BSTR

	EXPECT_TRUE( dbg.StepOverUntilLine("::SysFreeString(variant2.bstrVal);") );
	LOG->RecordCompare( cxx.ExpressionValueIs("variant2", "{\"BSTR test\" VT_BSTR}"),
		"variant2 shld be \"BSTR test\"");
	dbg.StepOver();

static char* variant2data[][2] = { //"line of code identifying variant", "variant value" 
	"variant2.vt = VT_UNKNOWN;",	"{0x000000ff VT_UNKNOWN}",
	"variant2.vt = VT_DISPATCH;",	"{0x000000ff VT_DISPATCH}",
	"variant2.vt = VT_ARRAY;",		"{0x000000ff VT_ARRAY}",
};
	for(i = 0; i < (sizeof(variant2data) / (sizeof(CString) * 2)); i++)
	{
		EXPECT_TRUE(dbg.CurrentLineIs(variant2data[i][0]) );
		dbg.StepOver(2);
		LOG->RecordCompare(cxx.ExpressionValueIs("variant2", variant2data[i][1]),
			"variant2 expected:(%s)\n",variant2data[i][1]);
	}
	dbg.StepOver(); //Init of global variant

	if (GetSystem() == SYSTEM_NT_4)	//	NT4.0
		sprintf(strDateVal,"{7/31/97 10:50:59 PM VT_DATE|VT_BYREF}");	
	else
		sprintf(strDateVal,"{7/31/1997 10:50:59 PM VT_DATE|VT_BYREF}");	

	//check the glob_variant assigned different VT_BYREF values
	static char* globvariantdata[][2] = { //"line of code identifying variant", "variant value" 
		"glob_variant.vt = VT_UI1|VT_BYREF;",		"{255 VT_UI1|VT_BYREF}",
		"glob_variant.vt = VT_I2|VT_BYREF;",		"{1000 VT_I2|VT_BYREF}",
		"glob_variant.vt = VT_I4|VT_BYREF;",		"{1000000 VT_I4|VT_BYREF}",
		"glob_variant.vt = VT_R4|VT_BYREF;",		"{20.0000 VT_R4|VT_BYREF}",
		"glob_variant.vt = VT_R8|VT_BYREF;",		"{10.000000000000 VT_R8|VT_BYREF}",
		"glob_variant.vt = VT_BOOL|VT_BYREF;",		"{False VT_BOOL|VT_BYREF}",
		"glob_variant.vt = VT_ERROR|VT_BYREF;",		"{0x80004001 VT_ERROR|VT_BYREF}",
		"glob_variant.vt = VT_CY|VT_BYREF;",		"{-922337203685477.5808 VT_CY|VT_BYREF}",
		"glob_variant.vt = VT_DATE|VT_BYREF;",		strDateVal,
		"glob_variant.vt = VT_UNKNOWN|VT_BYREF;",	badVARIANTstring, //pVal==5 (bad pointer)
		"glob_variant.vt = VT_DISPATCH|VT_BYREF;",	badVARIANTstring, //pVal==5 (bad pointer)
		"glob_variant.vt = VT_ARRAY|VT_BYREF;",		badVARIANTstring, //pVal==5 (bad pointer)
		"glob_variant.vt = VT_VARIANT|VT_BYREF;",	"{VT_VARIANT|VT_BYREF}",
	};


	for(i = 0; i < (sizeof(globvariantdata) / (sizeof(CString) * 2)); i++)
	{
		EXPECT_TRUE(dbg.CurrentLineIs(globvariantdata[i][0]) );
		dbg.StepOver(2);
		LOG->RecordCompare(cxx.ExpressionValueIs("glob_variant", globvariantdata[i][1]),
			"glob_variant expected:(%s)\n",globvariantdata[i][1]);
	}
	//the last variant references itself
	EXPECT_TRUE(cxx.ExpressionValueSubstringIs("glob_variant.pvarVal", "ADDRESS struct tagVARIANT  glob_variant") );
	EXPECT_TRUE(cxx.ExpressionValueSubstringIs("*glob_variant.pvarVal", "{VT_VARIANT|VT_BYREF}") );

	dbg.StepOver(); //glob_variant references variant2
	EXPECT_TRUE(cxx.ExpressionValueSubstringIs("glob_variant.pvarVal", "ADDRESS {0x000000ff VT_ARRAY}") );

//check reference to BSTR
	EXPECT_TRUE( src.Find("SysFreeString(pbstrVal);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "SysFreeString(pbstrVal);") );
	LOG->RecordCompare( cxx.ExpressionValueIs("glob_variant", "{\"PBST test\" VT_BSTR|VT_BYREF}"),
		"glob_variant shld be \"PBST test\"");
//check variant2 - non-statc, local variant
	EXPECT_TRUE( src.Find("void* anyref=&subvariant;variant2.byref = &subvariant;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "void* anyref=&subvariant;variant2.byref = &subvariant;") );
	EXPECT_TRUE(cxx.ExpressionValueIs("variant2", badVARIANTstring) ); //pointer is still bad (==0xff)
	dbg.StepOver(); 
	EXPECT_TRUE(cxx.ExpressionValueIs("variant2", badVARIANTstring) );//now the pointer is valid, pointing to subvariant, but "{VT_BYREF}" is wrong variant type, according to DOCs
	EXPECT_TRUE(cxx.ExpressionValueSubstringIs("(tagVARIANT*)variant2.byref", "ADDRESS {10 VT_I4}") );
//check simple values of variant2
static char strVT_UI2_VT_BYREF[50];
	strVT_UI2_VT_BYREF[0]='{';
	itoa(VT_UI2|VT_BYREF,strVT_UI2_VT_BYREF+1,10);
	strcat(strVT_UI2_VT_BYREF, " VT_UI2|VT_BYREF}"); //it will be a variant value pointing to itself 
static char* simpledata[][2] = { //"line of code identifying variant", "variant value" 
	"variant2.vt = VT_I1;",		"{86 'V' VT_I1}",
	"variant2.vt = VT_UI2;",	"{65535 VT_UI2}",
	"variant2.vt = VT_UI4;",	"{4294967295 VT_UI4}",
	"variant2.vt = VT_INT;",	"{-256 VT_INT}",
	"variant2.vt = VT_UINT;",	"{256 VT_UINT}",
	"variant2.vt = VT_DECIMAL|VT_BYREF;",	"{0.0000000018446744073709551616 VT_DECIMAL|VT_BYREF}",
	"variant2.vt = VT_I1|VT_BYREF;",		"{99 'c' VT_I1|VT_BYREF}", //display only 1 char as it's  marshalled
	"variant2.vt = VT_UI2|VT_BYREF;",		strVT_UI2_VT_BYREF, //bogus, pointing to itself,
	"variant2.vt = VT_UI4|VT_BYREF;",		badVARIANTstring, //pVal==5 (bad pointer),
	"variant2.vt = VT_INT|VT_BYREF;",		badVARIANTstring, //pVal==NULL (bad pointer),
	"variant2.vt = VT_UINT|VT_BYREF;",		badVARIANTstring, //pVal==0xff (bad pointer)
};

	for(i = 0; i < (sizeof(simpledata) / (sizeof(CString) * 2)); i++)
	{
		EXPECT_TRUE(dbg.CurrentLineIs(simpledata[i][0]) );
		dbg.StepOver(2);
		LOG->RecordCompare(cxx.ExpressionValueIs("variant2", simpledata[i][1]),
			"simple variant2 expected:(%s)\n",simpledata[i][1]);
	}

	uivar.Activate();
	ERROR_SUCCESS(uivar.SetPane(PANE_AUTO) );
	EXPR_INFO expr_info_actual[1], expr_info_expected[1];

	EXPECT_TRUE( dbg.StepOver() );
//check return_variant function returns the VARIANT
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 3 /*ROW_BOTTOM does not exist*/));
	
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, 
		"tagVARIANT", "return_variant returned", "{65535 VT_I4}" );
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1) );
	EXPECT_TRUE(dbg.ShowNextStatement() ); //uivar.Activate() steals the focus

}//VARIANTs
#endif

BOOL MMX_Chip()
{
#pragma warning(disable:4035)
	__asm{
		mov eax,1;
		_emit 0x0f; //CPUID
		_emit 0xa2; //CPUID
		mov eax,1;
		test edx,0x0800000;
		jnz Yes
		mov eax,0
Yes:
	}
	return;
#pragma warning(default:4035)
}

//MMXRegs
void CSpecialTypesTest::MMXRegs(void)
{
 	LogTestHeader( "MMX Test" );
	if(!MMX_Chip())
	{
		LOG->RecordInfo("No MMX chip detected - skipping the test");
		return;
	}
}//MMXRegs

//ErrorCodes
void CSpecialTypesTest::ErrorCodes(void)
{
	char lastErrorLoc[16];

	//	this code needed due to bug 65586 - dverma 4/26/2000
	if (GetSystem() == SYSTEM_WIN_MILL)
	{
		strcpy(lastErrorLoc,"dw @tib+0x74");		//	location of last error set
	}
	else
	{
		strcpy(lastErrorLoc,"@ERR");
	}


static char* data[][2] = {
	"s_ok,hr",			"S_OK",
	"s_err,hr",			"E_NOINTERFACE",
	"s_unexp,hr",		"E_UNEXPECTED",
	"s_eomem,hr",		"E_OUTOFMEMORY",
//NOTE extra space required after a full text of message
	"5,hr",				"0x00000005 Access is denied. ",
	"8,hr",				"0x00000008 Not enough storage is available to process this command. ",
	"24L,hr",			"0x00000018 The program issued a command but the command length is incorrect. ",
//this message is truncated by the debugger	
	"0x95L,hr",			"0x00000095 An attempt was made to join or substitute a drive for which a directory on the drive is the target of a previous sub",
	lastErrorLoc,				"42",
};

 	LogTestHeader( "ErrorCodes Test" );

	src.Find("_asm int 3;");	
	dbg.StepToCursor();	

	for(int i = 0; i < (sizeof(data) / (sizeof(CString) * 2)); i++)
	{
		LOG->RecordCompare(cxx.ExpressionValueIs(data[i][0], data[i][1]),
			"Expression:(%s), expected:(%s)\n", data[i][0],data[i][1]);
	}
	CString strTIBEqual = "@TIB==" + m_TIBValue;
	LOG->RecordCompare(cxx.ExpressionValueIs(strTIBEqual, "1"),
			"TIB is equal:(%s)\n", m_TIBValue);

	//TODO fill with tests for the actual value of TIB?
}//ErrorCodes
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\exe\execase2.h ===
///////////////////////////////////////////////////////////////////////////////
//	execase.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CexeIDETest Class
//

#ifndef __execase2_H__
#define __execase2_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\dbgtestbase.h"
#include "exesub.h"

///////////////////////////////////////////////////////////////////////////////
//	CexeIDETest class

class Cexe2IDETest : public CDbgTestBase
{
	DECLARE_TEST(Cexe2IDETest, CexeSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run();

// Test Cases
protected:

	// Go cases
	BOOL GoExeDoesNotExist();
	BOOL ExitWhileDebugging();

	// Step cases
	BOOL StepIntoMixed();
	BOOL StepOverMixed();
	BOOL StepOutMixed();
	BOOL StepToCursorMixed();

	BOOL DllStepTrace();
	BOOL DllStepOut();
	BOOL DllTraceOut();
	BOOL CannotFindDll();
	BOOL StepOverFuncInUnloadedDll();
	BOOL RestartFromWithinDll();
	BOOL GoFromWithinDll();
	BOOL StdInOutRedirection();
	BOOL NoSystemCodeStepping();

// Utilities
protected:
	BOOL CheckGeneralNetworkFailure();

};

#endif //__execase2_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\ee\eecase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	EECASE.CPP
//											 
//	Created by :			
//		VCBU QA		
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "eecase.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
IMPLEMENT_TEST(CEEIDETest, CDbgTestBase, "General", -1, CEESubSuite)
									   
												 
void CEEIDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}


char* data[][2] = 

{
	// note: the class "derived1" and its base classes are all declared in headers
	//       and implemented in cpp files.

	// non-inherited, non-overloaded member function.
	// public member function.
	"derived1_obj.derived1_public_func",		"ADDRESS derived1::derived1_public_func(int)",         
	"derived1_obj_ptr->derived1_public_func",	"ADDRESS derived1::derived1_public_func(int)",
	    
	// inherited, non-overloaded, non-overridden member function.
	"derived1_obj.base2_func",		"ADDRESS base2::base2_func(int)",                                
	"derived1_obj_ptr->base2_func",	"ADDRESS base2::base2_func(int)",                           
	
	// inherited, overloaded, non-overridden member function.
	"derived1_obj.base1_overloaded_func",				"ADDRESS derived1::base1_overloaded_func(char)",      
	"derived1_obj_ptr->base1_overloaded_func",			"ADDRESS derived1::base1_overloaded_func(char)", 
	"derived1_obj.base1_overloaded_func(char)",			"ADDRESS derived1::base1_overloaded_func(char)",     
	"derived1_obj_ptr->base1_overloaded_func(char)",	"ADDRESS derived1::base1_overloaded_func(char)",
	// TODO: can't get at (int) version; can't even step into it.
	//"derived1_obj.base1_overloaded_func(int)",		"ADDRESS base1::base1_overloaded_func(int)",     
	//"derived1_obj_ptr->base1_overloaded_func(int)",	"ADDRESS base1::base1_overloaded_func(int)",
	
	// inherited, non-overloaded, overridden member function.
	"derived1_obj.base1_overridden_func",		"ADDRESS derived1::base1_overridden_func(int)",
 	"derived1_obj_ptr->base1_overridden_func",	"ADDRESS derived1::base1_overridden_func(int)",

	// virtual inherited non-overloaded, overridden member function.
	// TODO: only getting addresses when these are evaluated.
	//"derived1_obj.base1_virtual_func",		"ADDRESS derived1::base1_virtual_func(int)",
	//"derived1_obj_ptr->base1_virtual_func", "ADDRESS derived1::base1_virtual_func(int)",

	// static member function.
	// TODO: can't link when defined in class.
	//"derived1::derived1_static_func", "ADDRESS derived1::derived1_static_func(int)",
	
	// static member variable.
	"derived1::derived1_static_var", "1",

	// pointer to member variable.
	// TODO: seems to point to wrong place.
	//"*ptr_to_mem_var", "3",

	// pointer to member function.
	// TODO: just get address.
	// "*ptr_to_mem_func", "ADDRESS derived1::derived1_public_func(int)",

	// class-nested enum.
	"derived1_obj.enum_class_var",		"two_class",
	"derived1_obj_ptr->enum_class_var", "two_class",
	"derived1::one_class",				"1",
	"derived1::two_class",				"2",
	"derived1::three_class",			"3",

	// non-inherited, non-static, member variable.
	// public member variable.
	"derived1_obj.derived1_public_var",			"3",
	"derived1_obj_ptr->derived1_public_var",	"3",

	// inherited member variable.
	"derived1_obj.base1_var",		"1",
	"derived1_obj_ptr->base1_var",	"1",

	// protected member function.
	"derived1_obj.derived1_protected_func",			"ADDRESS derived1::derived1_protected_func(int)",         
	"derived1_obj_ptr->derived1_protected_func",	"ADDRESS derived1::derived1_protected_func(int)",

	// private member function.
	"derived1_obj.derived1_private_func",		"ADDRESS derived1::derived1_private_func(int)",         
	"derived1_obj_ptr->derived1_private_func",	"ADDRESS derived1::derived1_private_func(int)",

	// private member variable.
	"derived1_obj.derived1_private_var",		"4",
	"derived1_obj_ptr->derived1_private_var",	"4",

	// protected member variable.
	"derived1_obj.derived1_protected_var",		"5",
	"derived1_obj_ptr->derived1_protected_var",	"5",

	// class defined in dll.
	// TODO: get "member function not present".
	//"dll_class_obj.dll_class_func",			"ADDRESS dll_class::dll_class_func(int)",
	//"dll_class_obj_ptr->dll_class_func",	"ADDRESS dll_class::dll_class_func(int)",
	//xbox "dll_class_obj.dll_class_var",			"0",
	//xbox "dll_class_obj_ptr->dll_class_var",		"0",

	// struct (declared in header, implemented in cpp file).
	"struct1_obj.struct1_func",			"ADDRESS struct1::struct1_func(int)",
	"struct1_obj_ptr->struct1_func",	"ADDRESS struct1::struct1_func(int)",
	"struct1_obj.struct1_var",			"0",
	"struct1_obj_ptr->struct1_var",		"0",

	// union (declared in header, implemented in cpp file).
	"union1_obj.union1_func",		"ADDRESS union1::union1_func(int)",
	"union1_obj_ptr->union1_func",	"ADDRESS union1::union1_func(int)",
	"union1_obj.union1_var",		"0",
	"union1_obj_ptr->union1_var",	"0",

	// class (declared and implemented in cpp file).
	// TODO: get "member function not present"
	//"class_cpp_obj.class_cpp_func",			"ADDRESS class_cpp::class_cpp_func(int)",
	//"class_cpp_obj_ptr->class_cpp_func",	"ADDRESS class_cpp::class_cpp_func(int)",
	"class_cpp_obj.class_cpp_var",			"0",
	"class_cpp_obj_ptr->class_cpp_var",		"0",

	// struct (declared and implemented in cpp file).
	// TODO: get "member function not present"
	//"struct_cpp_obj.struct_cpp_func",		"ADDRESS struct_cpp::struct_cpp_func(int)",
	//"struct_cpp_obj_ptr->struct_cpp_func",	"ADDRESS struct_cpp::struct_cpp_func(int)",
	"struct_cpp_obj.struct_cpp_var",		"0",
	"struct_cpp_obj_ptr->struct_cpp_var",	"0",

	// union (declared and implemented in cpp file).
	// TODO: get "member function not present"
	//"union_cpp_obj.union_cpp_func",			"ADDRESS union_cpp::union_cpp_func(int)",
	//"union_cpp_obj_ptr->union_cpp_func",	"ADDRESS union_cpp::union_cpp_func(int)",
	"union_cpp_obj.union_cpp_var",			"0",
	"union_cpp_obj_ptr->union_cpp_var",		"0",

	// enum (defined in cpp file)
	"enum_cpp_var",	"three_cpp",
	"one_cpp",		"1",
	"two_cpp",		"2",
	"three_cpp",	"3",

	// class (declared in pch file, implemented in cpp file).
	"class_pch_obj.class_pch_func",			"ADDRESS class_pch::class_pch_func(int)",
	"class_pch_obj_ptr->class_pch_func",	"ADDRESS class_pch::class_pch_func(int)",
	"class_pch_obj.class_pch_var",			"0",
	"class_pch_obj_ptr->class_pch_var",		"0",

	// struct (declared in pch file, implemented in cpp file).
	"struct_pch_obj.struct_pch_func",		"ADDRESS struct_pch::struct_pch_func(int)",
	"struct_pch_obj_ptr->struct_pch_func",	"ADDRESS struct_pch::struct_pch_func(int)",
	"struct_pch_obj.struct_pch_var",		"0",
	"struct_pch_obj_ptr->struct_pch_var",	"0",

	// union (declared in pch file, implemented in cpp file).
	"union_pch_obj.union_pch_func",			"ADDRESS union_pch::union_pch_func(int)",
	"union_pch_obj_ptr->union_pch_func",	"ADDRESS union_pch::union_pch_func(int)",
	"union_pch_obj.union_pch_var",			"0",
	"union_pch_obj_ptr->union_pch_var",		"0",

	// enum (defined in pch file)
	"enum_pch_var",	"two_pch",
	"one_pch",		"1",
	"two_pch",		"2",
	"three_pch",	"3",

	// class (defined locally).
	"class_local_obj.class_local_var",		"0",
	"class_local_obj_ptr->class_local_var",	"0",

	// struct (defined locally).
	"struct_local_obj.struct_local_var",		"0",
	"struct_local_obj_ptr->struct_local_var",	"0",

	// union (defined locally).
	"union_local_obj.union_local_var",		"0",
	"union_local_obj_ptr->union_local_var",	"0",

	// enum (defined locally)
	"enum_local_var",	"one_local",
	"one_local",		"1",
	"two_local",		"2",
	"three_local",		"3",

	// non-overloaded global function.
	"global_func", "ADDRESS global_func(int)",

	// overloaded global function.
	"overloaded_global_func",		"ADDRESS overloaded_global_func(char)",
	"overloaded_global_func(int)",	"ADDRESS overloaded_global_func(int)",
	"overloaded_global_func(char)",	"ADDRESS overloaded_global_func(char)",
	
	// global variable.
	"global_var", "0",

	// static local variable.
	"static_local_var", "0",

	// namespace function.
	"namespace1::namespace1_func", "ADDRESS namespace1::namespace1_func(int)",

	// namespace variable.
	"namespace1::namespace1_var", "1",
	
	// in-line function (defined in header)
	// TODO: can't find this symbol.
	//"inline_func", "ADDRESS inline_func(int)",
	
	// enum (defined in header)
	"enum1_var",	"two",
	"one",			"1",
	"two",			"2",
	"three",		"3" 
};


// in order to initialize the "tests" array like we do below we need to mimmic the EXPR_INFO
// class which uses CStrings instead of LPCSTRs. CStrings prevent such initialization.
struct EXPR_INFO2
{
	EXPR_STATE	state;
	LPCSTR		type;
	LPCSTR		name;
	LPCSTR		value;
};


// initialize the data for all the tests (state, type, name, and value of each expression).
EXPR_INFO2 tests[] =

{
	// local const primitive.
	{NOT_EXPANDABLE,	"const int",	"const_int",	"0"},
	{COLLAPSED,			"const int *",	"pconst_int",	"ADDRESS"},
	{NOT_EXPANDABLE,	"const int",	"*pconst_int",	"0"},
	{NOT_EXPANDABLE,	"const int",	"int_const",	"0"},
	{COLLAPSED,			"const int *",	"pint_const",	"ADDRESS"},
	{NOT_EXPANDABLE,	"const int",	"*pint_const",	"0"},

	// global const primitive.
	{NOT_EXPANDABLE,	"const int",	"gconst_int",	"0"},
	{COLLAPSED,			"const int *",	"gpconst_int",	"ADDRESS gconst_int"},
	{NOT_EXPANDABLE,	"const int",	"*gpconst_int", "0"},
	{NOT_EXPANDABLE,	"const int",	"gint_const",	"0"},
	{COLLAPSED,			"const int *",	"gpint_const",	"ADDRESS gint_const"},
	{NOT_EXPANDABLE,	"const int",	"*gpint_const", "0"},

	// member const primitive.
	// TODO(michma - 2/13/98): fails due to bug VS98: 30574.
	//{NOT_EXPANDABLE,	"const int",	"class_cpp_obj.m_const_int",	"0"},
	{COLLAPSED,			"const int *",	"class_cpp_obj.m_pconst_int",	"ADDRESS"},
	{NOT_EXPANDABLE,	"const int",	"*class_cpp_obj.m_pconst_int",	"0"},
	// TODO(michma - 2/13/98): fails due to bug VS98: 30574.
	//{NOT_EXPANDABLE,	"const int",	"class_cpp_obj.m_int_const",	"0"},
	{COLLAPSED,			"const int *",	"class_cpp_obj.m_pint_const",	"ADDRESS"},
	{NOT_EXPANDABLE,	"const int",	"*class_cpp_obj.m_pint_const",	"0"},

	// local const struct.
	// TODO(michma - 2/13/98): fails due to bug VS98:30574.
	//{COLLAPSED, "const struct_cpp",	"const_struct_cpp",		"{...}"},
	{COLLAPSED, "const struct_cpp *",	"pconst_struct_cpp",	"ADDRESS"},
	{COLLAPSED, "const struct_cpp",		"*pconst_struct_cpp",	"{...}"},
	// TODO(michma - 2/13/98): fails due to bug VS98: 30574.
	//{COLLAPSED, "const struct_cpp",	"struct_cpp_const",		"{...}"},
	{COLLAPSED, "const struct_cpp *",	"pstruct_cpp_const",	"ADDRESS"},
	{COLLAPSED, "const struct_cpp",		"*pstruct_cpp_const",	"{...}"},

	// global const struct.
	// TODO(michma - 2/13/98): fails due to bug VS98: 30574.
	//{COLLAPSED, "const struct_cpp",	"gconst_struct_cpp",	"{...}"},
	{COLLAPSED, "const struct_cpp *",	"gpconst_struct_cpp",	"ADDRESS gconst_struct_cpp"},
	{COLLAPSED, "const struct_cpp",		"*gpconst_struct_cpp",	"{...}"},
	// TODO(michma - 2/13/98): fails due to bug VS98: 30574.
	//{COLLAPSED, "const struct_cpp",	"gstruct_cpp_const",	"{...}"},
	{COLLAPSED, "const struct_cpp *",	"gpstruct_cpp_const",	"ADDRESS gstruct_cpp_const"},
	{COLLAPSED, "const struct_cpp",		"*gpstruct_cpp_const",	"{...}"},

	// member const struct.
	// TODO(michma - 2/13/98): fails due to bug VS98: 30574.
	//{COLLAPSED, "const struct_cpp",	"class_cpp_obj.m_const_struct_cpp",		"{...}"},
	{COLLAPSED, "const struct_cpp *",	"class_cpp_obj.m_pconst_struct_cpp",	"ADDRESS"},
	{COLLAPSED, "const struct_cpp",		"*class_cpp_obj.m_pconst_struct_cpp",	"{...}"},
	// TODO(michma - 2/13/98): fails due to bug VS98:30574.
	//{COLLAPSED, "const struct_cpp",	"class_cpp_obj.m_struct_cpp_const",		"{...}"},
	{COLLAPSED, "const struct_cpp *",	"class_cpp_obj.m_pstruct_cpp_const",	"ADDRESS"},
	{COLLAPSED, "const struct_cpp",		"*class_cpp_obj.m_pstruct_cpp_const",	"{...}"}
};


void CEEIDETest::Run(void)
	
{
	/******************
	 * INITIALIZATION *
	 ******************/

	/*xbox
	if(!InitProject("ee\\dll", PROJECT_DLL))
	{
		m_pLog->RecordInfo("ERROR: could not init dll project");
		return;
	}
	*/

	if(!InitProject("ee\\ee", PROJECT_XBE))
	{
		m_pLog->RecordInfo("ERROR: could not init ee project");
		return;
	}

	// step to the "return" in ee.exe (all objects will be in scope).
	src.Open("ee.cpp");
	src.Find("run to here before evaluating");	
	dbg.StepToCursor();	
	cxx.Enable();

	// evaluate all the expressions.
	for(int i = 0; i < (sizeof(data) / (sizeof(CString) * 2)); i++)
	{
		if(cxx.ExpressionValueIs(data[i][0], data[i][1]))
			LOG->RecordSuccess("%s\n", data[i][0]);
		else
			LOG->RecordFailure("%s\n", data[i][0]);
	}

	cxx.Disable();

	// we need to enable the ee differently for these tests since we want to check all expression info, not just values.
	cxx.Enable(EE_ALL_INFO);
	// we only want to randomly run each test once.
	RandomNumberCheckList rncl(sizeof(tests) / sizeof(EXPR_INFO2));
	// indexes into the test array.
	int iTest;
	
	// randomly run each test once.
	while((iTest = rncl.GetNext()) != -1)
	
	{
		// transfer EXPR_INFO2 data to EXPR_INFO object.
		EXPR_INFO expr_info;
		cxx.FillExprInfo(expr_info, tests[iTest].state, tests[iTest].type, tests[iTest].name, tests[iTest].value);
		
		if(cxx.VerifyExprInfo(expr_info))
			LOG->RecordSuccess("%s\n", expr_info.name);
		else
			LOG->RecordFailure("%s\n", expr_info.name);
	}

	cxx.Disable();
	prj.Close();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\exe\execase3.h ===
///////////////////////////////////////////////////////////////////////////////
//	EXECASE3.H
//
//	Created by:			Date:
//		MichMa				2/2/98
//
//	Description :
//		Declaration of the CExe3Cases Class
//

#ifndef __EXECASE3_H__
#define __EXECASE3_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\dbgtestbase.h"
#include "exesub.h"


///////////////////////////////////////////////////////////////////////////////
//	CExe3Cases class

class CExe3Cases : public CDbgTestBase

{
	DECLARE_TEST(CExe3Cases, CexeSubSuite)

public:

	// Operations
	virtual void PreRun(void);
	virtual void Run(void);

	// Utils
	void InitTestState(void);

	// Test Cases
	void StartDebuggingBreakRestartAndStep(void);
	void StepIntoFuncThroughIndirectCall(void);
	void StepIntoWhenInstructionPtrAdvancedButNotSourcePtr(void);
	void StepIntoWhenInstructionAndSourcePtrsAdvanceWithFocusInAsm(void);
	void StepIntoWhenInstructionAndSourcePtrsAdvanceWithFocusInSource(void);
	void StepOverToLineWithLocationBP(void);
	void StepOverFuncInMixedMode(void);
	void StepOverFuncWhichWillHitMessageBP(void);
	void StepOutOfFuncWhichWillHitExpressionTrueBP(void);
	void StepOutOfFuncWhichWillHitExpressionChangedBP(void);
	void StepOutOfFuncWhichWillHitMessageBP(void);
	void GoUntilExceptionIsRaised(void);
	void StopDebuggingWhileDebuggeeIsRunning(void);
	void StepToCursorInAsm(void);
	void StepToCursorAtLineWithLocationBP(void);
	void SetNextStatementInSource(void);
	void SetNextStatementInAsm(void);
	void ShowNextStatementWhenCursorNotOnStatementAndSourceInForeground(void);
	void ShowNextStatementWhenScrollingRequiredAndSourceInForeground(void);
	void ShowNextStatementInAsm(void);
	void StepIntoSpecificNonNested(void);
	void StepIntoSpecificNested(void);
	void StepIntoSpecificWhenBPSetInInnerFunc(void);
	void LoadCOFFExports(void);
};

#endif //__EXECASE3_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\exe\exesub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CexeSubSuite class
//

#include "stdafx.h"
#include "exesub.h"
#include "afxdllx.h"

#include "exe_base.h"
#include "exe_dlls.h"
#include "exe_bp.h"
#include "exe_spec.h"
#include "execase3.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CexeSubSuite

IMPLEMENT_SUBSUITE(CexeSubSuite, CIDESubSuite, "Execution", "VCQA Debugger")

BEGIN_TESTLIST(CexeSubSuite)
	TEST(Cexe_baseIDETest, RUN)
	TEST(Cexe_bpIDETest, RUN)
#pragma message("Cexe_specialIDETest is DONTRUN!  Fix!!!")
	TEST(Cexe_specialIDETest, DONTRUN)
#pragma message("CExe3Cases is DONTRUN!  Fix!!!")
	TEST(CExe3Cases, DONTRUN)
END_TESTLIST()

void CexeSubSuite::CleanUp(void)
	{
	::CleanUp("testbp01");
	::CleanUp("testgo01");
	::CleanUp("dbg");
	::CleanUp("dbga");
	::CleanUp("dllapp");
	}

///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\exe\execase3.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	EXECASE3.CPP
//											 
//	Created by:			Date:			
//		MichMa				2/2/98	
//
//	Description:								 
//		Implementation of CExe3Cases		 

#include "stdafx.h"
#include "execase3.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
											   
IMPLEMENT_TEST(CExe3Cases, CDbgTestBase, "Execution Pri1", -1, CexeSubSuite)


// each function that runs a test has this prototype.
typedef void (CExe3Cases::*PTR_TEST_FUNC)(void); 

// we randomly pick out of the following list of tests and run them.
// insert functions for new tests to the end of the list.
PTR_TEST_FUNC tests[] = 
{
	&CExe3Cases::StartDebuggingBreakRestartAndStep,
	&CExe3Cases::StepIntoFuncThroughIndirectCall,
	&CExe3Cases::StepIntoWhenInstructionPtrAdvancedButNotSourcePtr,
	&CExe3Cases::StepIntoWhenInstructionAndSourcePtrsAdvanceWithFocusInAsm,
	&CExe3Cases::StepIntoWhenInstructionAndSourcePtrsAdvanceWithFocusInSource,
	&CExe3Cases::StepOverToLineWithLocationBP,
	&CExe3Cases::StepOverFuncInMixedMode,
	&CExe3Cases::StepOverFuncWhichWillHitMessageBP,
	&CExe3Cases::StepOutOfFuncWhichWillHitExpressionTrueBP,
	&CExe3Cases::StepOutOfFuncWhichWillHitExpressionChangedBP,
	&CExe3Cases::StepOutOfFuncWhichWillHitMessageBP,
	&CExe3Cases::GoUntilExceptionIsRaised,
	&CExe3Cases::StopDebuggingWhileDebuggeeIsRunning,
	&CExe3Cases::StepToCursorInAsm,
	&CExe3Cases::StepToCursorAtLineWithLocationBP,
	&CExe3Cases::SetNextStatementInSource,
	&CExe3Cases::SetNextStatementInAsm,
	&CExe3Cases::ShowNextStatementWhenCursorNotOnStatementAndSourceInForeground,
	&CExe3Cases::ShowNextStatementWhenScrollingRequiredAndSourceInForeground,
	&CExe3Cases::ShowNextStatementInAsm,
	&CExe3Cases::StepIntoSpecificNonNested,
	&CExe3Cases::StepIntoSpecificNested,
	&CExe3Cases::StepIntoSpecificWhenBPSetInInnerFunc,
	//xbox - we dont do this, but check with jlange anyway
	//&CExe3Cases::LoadCOFFExports
};


void CExe3Cases::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}


void CExe3Cases::Run(void)
{
	if (!CreateXboxProjectFromSource("execution pri1", "src\\execution pri1",
				"execution pri1 exe.cpp"))
			return;

	// all tests expect the ide to be in this initial state.
	InitTestState();

	// we only want to randomly run each test once.

	RandomNumberCheckList rncl(sizeof(tests) / sizeof(PTR_TEST_FUNC));
	// indexes into the test function array.
	int iTest;
	
	if(CMDLINE->GetBooleanValue("random", TRUE))
	{
		// randomly run each test once.
		while((iTest = rncl.GetNext()) != -1)
			(this->*(tests[iTest]))();
	}
	else
	{
		// run each test in sequence.
		for(iTest = 0; iTest < sizeof(tests) / sizeof(PTR_TEST_FUNC); iTest++)
			(this->*(tests[iTest]))();
	}
}


void CExe3Cases::StartDebuggingBreakRestartAndStep(void)
{	
	LogTestHeader("StartDebuggingBreakRestartAndStep");
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, NOWAIT));
	Sleep(3000); // emmang@xbox - give the app some time
	EXPECT_TRUE(dbg.Break());
	EXPECT_TRUE(dbg.CurrentLineIs("loop line"));
	EXPECT_TRUE(stk.CurrentFunctionIs("main"));
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of main()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("main"));
	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE(dbg.CurrentLineIs("second line of main()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("main"));
	InitTestState();
}


void CExe3Cases::StepIntoFuncThroughIndirectCall(void)
{	
	LogTestHeader("StepIntoFuncThroughIndirectCall");
	EXPECT_TRUE(src.Find("pFuncCalledIndirectly();"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of FuncCalledIndirectly()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("FuncCalledIndirectly"));
	InitTestState();
}


void CExe3Cases::StepIntoWhenInstructionPtrAdvancedButNotSourcePtr(void)
{
	LogTestHeader("StepIntoWhenInstructionPtrAdvancedButNotSourcePtr");
	EXPECT_TRUE(dam.Enable());
	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE(dam.InstructionIs("mov"));
	EXPECT_TRUE(dbg.SetSteppingMode(SRC));
	EXPECT_TRUE(dbg.CurrentLineIs("first line of main()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("main"));
	InitTestState();
}


void CExe3Cases::StepIntoWhenInstructionAndSourcePtrsAdvanceWithFocusInAsm(void)
{
	LogTestHeader("StepIntoWhenInstructionAndSourcePtrsAdvanceWithFocusInAsm");
	EXPECT_TRUE(src.Find("_asm"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(dam.Enable());
	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE(dam.InstructionIs("pop"));
	EXPECT_TRUE(dbg.SetSteppingMode(SRC));
	EXPECT_TRUE(dbg.CurrentLineIs("pop eax"));
	EXPECT_TRUE(stk.CurrentFunctionIs("main"));
	InitTestState();
}


void CExe3Cases::StepIntoWhenInstructionAndSourcePtrsAdvanceWithFocusInSource(void)
{
	LogTestHeader("StepIntoWhenInstructionAndSourcePtrsAdvanceWithFocusInSource");
	EXPECT_TRUE(src.Find("_asm"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(dam.Enable());
	EXPECT_TRUE(dbg.SetSteppingMode(SRC));
	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE(dbg.CurrentLineIs("pop eax"));
	EXPECT_TRUE(dbg.SetSteppingMode(ASM));
	EXPECT_TRUE(dam.InstructionIs("pop"));
	EXPECT_TRUE(stk.CurrentFunctionIs("main"));
	EXPECT_TRUE(dbg.SetSteppingMode(SRC));
	InitTestState();
}


void CExe3Cases::StepOverToLineWithLocationBP(void)
{	
	LogTestHeader("StepOverToLineWithLocationBP");
	// note that initial state has current line at first line of main().
	EXPECT_TRUE(src.Find("second line of main()"));
	EXPECT_VALIDBP(bps.SetBreakpoint());
	EXPECT_TRUE(dbg.StepOver());
	// make sure the bp is still there.
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("second line of main()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("main"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	InitTestState();
}


void CExe3Cases::StepOverFuncInMixedMode(void)
{
	LogTestHeader("StepOverFuncInMixedMode");
	EXPECT_TRUE(src.Find("Func();"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(dam.Enable());
	EXPECT_TRUE(dbg.StepOver());
	// we want to check the source line immediately above the current instruction. 
	CString strDAMLine = dam.GetLines(-1, 1);
	EXPECT_TRUE(strDAMLine.Find("line after call to Func()") != -1);
	// now verify the source window.
	EXPECT_TRUE(dbg.SetSteppingMode(SRC));
	EXPECT_TRUE(dbg.CurrentLineIs("line after call to Func()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("main"));
	InitTestState();
}


void CExe3Cases::StepOutOfFuncWhichWillHitExpressionTrueBP(void)
{
	LogTestHeader("StepOutOfFuncWhichWillHitExpressionTrueBP");
	EXPECT_TRUE(src.Find("first line of Func()"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_VALIDBP(bps.SetBreakOnExpr("gintVar == 1", COBP_TYPE_IF_EXP_TRUE));
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("line after expression bp hit"));
	EXPECT_TRUE(stk.CurrentFunctionIs("Func"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	// TODO(michma): we need to do this extra step because of bug 38172.
	EXPECT_TRUE(dbg.StepInto());
	InitTestState();
}


void CExe3Cases::StepOutOfFuncWhichWillHitExpressionChangedBP(void)
{
	LogTestHeader("StepOutOfFuncWhichWillHitExpressionChangedBP");
	EXPECT_TRUE(src.Find("first line of Func()"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_VALIDBP(bps.SetBreakOnExpr("gintVar", COBP_TYPE_IF_EXP_CHANGED));
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("line after expression bp hit"));
	EXPECT_TRUE(stk.CurrentFunctionIs("Func"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	// TODO(michma): we need to do this extra step because of bug 38172.
	EXPECT_TRUE(dbg.StepInto());
	InitTestState();
}


void CExe3Cases::GoUntilExceptionIsRaised(void)
{
	LogTestHeader("GoUntilExceptionIsRaised");
	// this will cause a divide by 0 error.
	EXPECT_TRUE(cxx.SetExpressionValue("gintDenominator", 0));
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, NOWAIT));
	EXPECT_TRUE(dbg.HandleMsg(MSG_EXCEPTION_DIVIDE_BY_ZERO));
	EXPECT_TRUE(dbg.CurrentLineIs("int i = 1 / gintDenominator;"));
	EXPECT_TRUE(stk.CurrentFunctionIs("main"));
	InitTestState();
}


void CExe3Cases::StopDebuggingWhileDebuggeeIsRunning(void)
{
	LogTestHeader("StopDebuggingWhileDebuggeeIsRunning");
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, WAIT_FOR_RUN));
	EXPECT_TRUE(dbg.StopDebugging());
	InitTestState();
}


void CExe3Cases::StepToCursorInAsm(void)
{
	LogTestHeader("StepToCursorInAsm");
	// debug to a place where we know for sure what the asm is.
	EXPECT_TRUE(src.Find("_asm"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(dam.Enable());
	// attach the COSource object to the asm view so we can navigate it.
	src.AttachActive();
	// the instruction we want to step to is 2 lines down in the listing.
	src.TypeTextAtCursor("{DOWN 2}");
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(dam.InstructionIs("pop"));
	EXPECT_TRUE(stk.CurrentFunctionIs("main"));
	EXPECT_TRUE(dbg.SetSteppingMode(SRC));
	InitTestState();
}


void CExe3Cases::StepToCursorAtLineWithLocationBP(void)
{	
	LogTestHeader("StepToCursorAtLineWithLocationBP");
	// note that initial state has current line at first line of main().
	EXPECT_TRUE(src.Find("second line of main()"));
	EXPECT_VALIDBP(bps.SetBreakpoint());
	EXPECT_TRUE(dbg.StepToCursor());
	// make sure the bp is still there.
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("second line of main()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("main"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	InitTestState();
}


void CExe3Cases::ShowNextStatementWhenCursorNotOnStatementAndSourceInForeground(void)
{
	LogTestHeader("ShowNextStatementWhenCursorNotOnStatementAndSourceInForeground");
	EXPECT_TRUE(src.Find("first line of source file"));
	EXPECT_TRUE(dbg.ShowNextStatement());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of main()"));
	InitTestState();
}


void CExe3Cases::ShowNextStatementWhenScrollingRequiredAndSourceInForeground(void)
{
	LogTestHeader("ShowNextStatementWhenScrollingRequiredAndSourceInForeground");
	EXPECT_TRUE(src.Find("END: for tests that require scrolling code out of view."));
	EXPECT_TRUE(dbg.ShowNextStatement());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of main()"));
	InitTestState();
}


void CExe3Cases::ShowNextStatementInAsm(void)
{
	LogTestHeader("ShowNextStatementInAsm");
	// debug to a place where we know for sure what the asm is.
	EXPECT_TRUE(src.Find("_asm"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(dam.Enable());
	// attach the COSource object to the asm view so we can navigate it.
	src.AttachActive();
	// move the cursor down a page.
	src.TypeTextAtCursor("{PGDN}");
	EXPECT_TRUE(dbg.ShowNextStatement());
	EXPECT_TRUE(dam.InstructionIs("push"));
	EXPECT_TRUE(dbg.SetSteppingMode(SRC));
	InitTestState();
}


void CExe3Cases::StepOverFuncWhichWillHitMessageBP(void)
{
	LogTestHeader("StepOverFuncWhichWillHitMessageBP");
	EXPECT_TRUE(src.Find("SendMessageFunc();"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_VALIDBP(bps.SetBreakOnMsg("WndProc", "WM_NULL"));
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of WndProc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("WndProc"));
	// value of WM_NULL message is 0.
	EXPECT_TRUE(cxx.ExpressionValueIs("msg", 0));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	InitTestState();
}


void CExe3Cases::StepOutOfFuncWhichWillHitMessageBP(void)

{
		LogTestHeader("StepOutOfFuncWhichWillHitMessageBP");
		EXPECT_TRUE(src.Find("first line of SendMessageFunc()"));
		EXPECT_TRUE(dbg.StepToCursor());
		EXPECT_VALIDBP(bps.SetBreakOnMsg("WndProc", "WM_NULL"));
		EXPECT_TRUE(dbg.StepOut());
		EXPECT_TRUE(dbg.CurrentLineIs("first line of WndProc()"));
		EXPECT_TRUE(stk.CurrentFunctionIs("WndProc"));
	
		// michma - 3/1/99: due to bug vc98:60437.
		if(GetSystem() | SYSTEM_NT_5)
			{ EXPECT_TRUE(dbg.StepOver()); }

		// value of WM_NULL message is 0.
		EXPECT_TRUE(cxx.ExpressionValueIs("msg", 0));
		EXPECT_TRUE(bps.ClearAllBreakpoints());
		InitTestState();
}


void CExe3Cases::SetNextStatementInSource(void)
{
	LogTestHeader("SetNextStatementInSource");
	// step to a point where the next statement is an infinite loop.
	EXPECT_TRUE(src.Find("loop line"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(src.Find("returned from main()"));
	EXPECT_TRUE(bps.SetBreakpoint());
	// set the next statement to one after the infinite loop.
	EXPECT_TRUE(src.Find("return from main()"));
	EXPECT_TRUE(dbg.SetNextStatement());
	// now instead of hitting the infinite loop the app should terminate.
	// EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, WAIT_FOR_TERMINATION));
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("returned from main()"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	InitTestState();
}


void CExe3Cases::SetNextStatementInAsm(void)
{
	LogTestHeader("SetNextStatementInAsm");
	// step to a point where the next statement is an infinite loop.
	EXPECT_TRUE(src.Find("loop line"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(src.Find("returned from main()"));
	EXPECT_TRUE(bps.SetBreakpoint());
	EXPECT_TRUE(dam.Enable());
	// attach the COSource object to the asm view so we can navigate it.
	src.AttachActive();
	// set the next instruction to one after the infinite loop (in the main return).
	src.TypeTextAtCursor("{DOWN 6}");
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.SetSteppingMode(SRC));
	// now instead of hitting the infinite loop the app should terminate.
	// EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, WAIT_FOR_TERMINATION));
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("returned from main()"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	InitTestState();
}


void CExe3Cases::StepIntoSpecificNonNested(void)
{
	LogTestHeader("StepIntoSpecificNonNested");
	EXPECT_TRUE(src.Find("Func();"));
	EXPECT_TRUE(dbg.StepToCursor());
	// put cursor on function name.
	EXPECT_TRUE(src.Find("Func();"));
	src.TypeTextAtCursor("{LEFT}{RIGHT}");
	EXPECT_TRUE(dbg.StepIntoSpecific());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of Func()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("Func"));
	InitTestState();
}


void CExe3Cases::StepIntoSpecificNested(void)
{
	LogTestHeader("StepIntoSpecificNested");
	EXPECT_TRUE(src.Find("OuterFunc(InnerFunc());"));
	EXPECT_TRUE(dbg.StepToCursor());
	// put cursor on inner function name.
	EXPECT_TRUE(src.Find("InnerFunc()"));
	src.TypeTextAtCursor("{LEFT}{RIGHT}");
	EXPECT_TRUE(dbg.StepIntoSpecific());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of InnerFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("InnerFunc"));
	EXPECT_TRUE(dbg.StepOut());
	// put cursor on outer function name.
	EXPECT_TRUE(src.Find("OuterFunc("));
	src.TypeTextAtCursor("{LEFT}{RIGHT}");
	EXPECT_TRUE(dbg.StepIntoSpecific());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of OuterFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("OuterFunc"));
	InitTestState();
}


void CExe3Cases::StepIntoSpecificWhenBPSetInInnerFunc(void)
{
	LogTestHeader("StepIntoSpecificWhenBPSetInInnerFunc");
	EXPECT_TRUE(src.Find("OuterFunc(InnerFunc());"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_VALIDBP(bps.SetBreakpoint("InnerFunc"));
	// put cursor on outer function name.
	EXPECT_TRUE(src.Find("OuterFunc("));
	src.TypeTextAtCursor("{LEFT}{RIGHT}");
	EXPECT_TRUE(dbg.StepIntoSpecific());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of InnerFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("InnerFunc"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	InitTestState();
}


void CExe3Cases::LoadCOFFExports(void)

{
	// this feature isn't supported on win9x.
	if(!((GetSystem() & SYSTEM_WIN_95) || (GetSystem() & SYSTEM_WIN_98) || (GetSystem() & SYSTEM_WIN_MILL)))
	
	{
		LogTestHeader("LoadCOFFExports");
		// Load COFF/Exports setting can only be toggled between sessions.
		EXPECT_TRUE(dbg.StopDebugging());

		// michma - 9/1/99: there should be a CODebug::ToggleLoadCOFFExports function for this, but since this is a one-time test addition for 
		// an old product, i don't want to take the time.
		
		// turn the option on.
		UIOptionsTabDlg uiopt;
		uiopt.Display();
		uiopt.ShowPage(TAB_DEBUG, 6);
		MST.WCheckCheck("&Load COFF && Exports");
		uiopt.OK();

		EXPECT_TRUE(dbg.StepInto());
		// instead of just KERNEL32 plus some address, we should now see a function name in the 3rd frame.
		if(GetSystem() & SYSTEM_NT_5)
			{EXPECT_TRUE(stk.FunctionIs("SetUnhandledExceptionFilter", 2));}
		else
			{EXPECT_TRUE(stk.FunctionIs("GetProcessPriorityBoost", 2));}
		
		// turn the option off.
		EXPECT_TRUE(dbg.StopDebugging());
		uiopt.Display();
		uiopt.ShowPage(TAB_DEBUG, 6);
 		MST.WCheckUnCheck("&Load COFF && Exports");
		uiopt.OK();

		EXPECT_TRUE(dbg.StepInto());
		// the function name should be gone now.
		if(GetSystem() & SYSTEM_NT_5)
			{EXPECT_TRUE(!stk.FunctionIs("SetUnhandledExceptionFilter", 2));}
		else
			{EXPECT_TRUE(!stk.FunctionIs("GetProcessPriorityBoost", 2));}
	}
}


void CExe3Cases::InitTestState(void)
{
	EXPECT_TRUE(dbg.Restart());
	// attach the COSource object to the source file that the debugger opened.
	src.AttachActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\exe\exe_base.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	exe_base.CPP
//											 
//	Created by :			
//		VCBU QA		

#include <process.h>
#include "stdafx.h"
#include "exe_base.h"	

#if defined(_MIPS_) || defined(_ALPHA_)
#define _CHAIN_2 "chain_2"
#define _CHAIN_3 "chain_3"
#else
#define _CHAIN_2 "_chain_2"
#define _CHAIN_3 "_chain_3"
#endif

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
											   
IMPLEMENT_TEST(Cexe_baseIDETest, CDbgTestBase, "Execution Base", -1, CexeSubSuite)
												 
void Cexe_baseIDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();

}

void Cexe_baseIDETest::Run()
{	 
	XSAFETY;
	
	if( SetProject("testgo01\\testgo01", PROJECT_XBE))
	{	  
		bps.ClearAllBreakpoints();
		XSAFETY;
		GoAndVerify();
		XSAFETY;
		RestartAndGo();
		XSAFETY;
		RestartStopDebugging();
		XSAFETY;
	}
	else
		m_pLog->RecordFailure("SetProject failed for \"testgo01\"." );
		
	if( SetProject("testbp01\\testbp01", PROJECT_XBE) )
	{	  
		bps.ClearAllBreakpoints();
		XSAFETY;
		StepOutSource();
		XSAFETY;
		StepOverSource();
		XSAFETY;
		StepIntoSource();
		XSAFETY;
		StepToCursorSource();
		XSAFETY;
	}
	else
		m_pLog->RecordFailure("SetProject failed for \"testbp01\"." );

		
	/* xbox TODO - port this
	if ( SetProject("dbg\\dbg", PROJECT_XBE) )
	{
		bps.ClearAllBreakpoints();
		XSAFETY;
		EXPECT(StepModel());
		XSAFETY;
		StopDbgCloseProject();
	}
	else
		m_pLog->RecordFailure("SetProject failed for \"dbg\"." );
	*/

		
// TODO(michma - 3/26/98): apparently this test wasn't finished.
/*		
	if ( SetProject("spcfc01\\spcfc01") )
	{
		XSAFETY;
		StaticFuncStepTrace();
		XSAFETY;
	}
	else
		m_pLog->RecordFailure("SetProject failed for \"spcfc01\"." );
*/
}


///////////////////////////////////////////////////////////////////////////////
//	Test Cases
///////////////////////////////////////////////////////////////////////////////

BOOL Cexe_baseIDETest::GoAndVerify( )
{
 	LogTestHeader( "GoAndVerify" );
	m_pLog->RecordInfo( " Run an app and verify it ran " );

	// changed from WAIT_FOR_TERMINATION for xbox
	EXPECT_TRUE( dbg.Go(NULL, NULL, NULL, WAIT_FOR_RUN) );
	Sleep(2000);
	EXPECT_TRUE( dbg.StopDebugging() );
	return (TRUE);
}

BOOL Cexe_baseIDETest::RestartAndGo( )
{
 	LogTestHeader( "RestartAndGo" );
	m_pLog->RecordInfo( " Restart, verify stop and Go " );

	EXPECT_TRUE( dbg.Restart() );
	if( UIWB.GetPcodeSwitch() )
	{
		EXPECT_TRUE( dbg.CurrentLineIs( "int iGo = TestG();" ) );
	}
	else
	{
		EXPECT_TRUE( dbg.CurrentLineIs( "{" ) );
	}

	//xbox
	//EXPECT_TRUE( dbg.Go(NULL, NULL, NULL, WAIT_FOR_TERMINATION) );
	EXPECT_TRUE( dbg.StopDebugging() );
	return (TRUE);
}


BOOL Cexe_baseIDETest::RestartStopDebugging( )
{
 	LogTestHeader( "RestartStopDebugging" );
	m_pLog->RecordInfo( "Restart, StopDebugging and verify" );

	EXPECT_TRUE( dbg.StepInto(1, NULL, "{") );
	EXPECT_TRUE( dbg.StepOver(1) );
    EXPECT_TRUE( dbg.Restart() );
	EXPECT_TRUE( dbg.CurrentLineIs( "{" ) );
	EXPECT_TRUE( dbg.StopDebugging() );
	//xbox
	//EXPECT_TRUE( dbg.Wait(WAIT_FOR_TERMINATION) );

/*	#if defined( _M_IX86 ) || defined( _MAC )  // WinslowF - for OEM compatibility
		EXPECT_TRUE( VerifyProjectRan(0) );
	#else
		EXPECT_TRUE( VerifyProjectRan(1) );
	#endif
*/
	EXPECT_TRUE( dbg.StepOver(1) );
	EXPECT_TRUE( dbg.StopDebugging() );
	//xbox
	//EXPECT_TRUE( dbg.Wait(WAIT_FOR_TERMINATION) );

	WriteLog(PASSED, "Restart-StopDebugging-StartDebugging was handled as expected" );
	return (TRUE);
}


BOOL Cexe_baseIDETest::StepOutSource(   )
{
 	LogTestHeader( "StepOutSource" );

	COSource		src;	// WinslowF - added to call GoToLine. It's not in UIWB any more.

	bps.ClearAllBreakpoints();
    dbg.Restart();
	EXPECT_TRUE( dbg.CurrentLineIs( "{" ) );

	CString strSource = "bp__ulul.c";

	// Open source
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource);

	EXPECT_TRUE( src.Find("ul = (ulong)counter;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "ul = (ulong)counter;") );

	EXPECT_TRUE( dbg.StepOut(1, NULL, "ul = CFncULUL(ul);", "TestBP()") );

	return (TRUE);
}


BOOL Cexe_baseIDETest::StepOverSource(   )
{
 	LogTestHeader( "StepOverSource" );

    //xbox EXPECT_TRUE( dbg.Go(NULL,NULL,NULL,WAIT_FOR_TERMINATION) );
    EXPECT_TRUE( dbg.Restart() );

	CString strSource = "testbp.c";
	bps.ClearAllBreakpoints();

	// Open source
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource);

	EXPECT_TRUE( src.Find("ul = CFncULUL(ul);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "ul = CFncULUL(ul);") );

	EXPECT_TRUE( dbg.StepOver(1, NULL, "f = CFncFF(f);") );

	return (TRUE);
}


BOOL Cexe_baseIDETest::StepIntoSource(   )
{
 	LogTestHeader( "StepIntoSource" );

	bps.ClearAllBreakpoints();
    dbg.Restart();

	if( !UIWB.GetPcodeSwitch() )
	{
	    EXPECT_TRUE( dbg.CurrentLineIs( "{" ) );
		EXPECT_TRUE( dbg.StepInto() );
	}

    EXPECT_TRUE( dbg.CurrentLineIs( "int iBP = TestBP();" ) );

	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "TestBP()") );

	MST.DoKeys("{up}");
    EXPECT_TRUE( dbg.CurrentLineIs( "int TestBP()" ) );

	EXPECT_TRUE( src.Find("s = CFncSSRecurse(10);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "s = CFncSSRecurse(10);") );

	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "CFncSSRecurse") );

	MST.DoKeys("{up}");
    EXPECT_TRUE( dbg.CurrentLineIs( "CFncSSRecurse(short NTimes)" ) );

	EXPECT_TRUE( src.Find("NTimes = (short)CFncSSRecurse((short)(NTimes-1));") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "NTimes = (short)CFncSSRecurse((short)(NTimes-1));") );

	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "CFncSSRecurse") );
	EXPECT_TRUE( stk.FunctionIs("CFncSSRecurse",1) );

	MST.DoKeys("{up}");
    EXPECT_TRUE( dbg.CurrentLineIs( "CFncSSRecurse(short NTimes)" ) );

	dbg.StopDebugging();

	return (TRUE);
}

BOOL Cexe_baseIDETest::StepToCursorSource(   )
{
 	LogTestHeader( "StepToCursorSource" );

	CString strSource = "bp__ldld.c";
	bps.ClearAllBreakpoints();

	// Open source
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource);

	EXPECT_TRUE( src.Find("ul = (ulong)counter;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "ul = (ulong)counter;") );

	EXPECT_TRUE( src.Find("d  = (double)counter;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "d  = (double)counter;") );
	dbg.StopDebugging();
	return (TRUE);
}


/*
** A number of tests lumped together.  Some involve step/trace/stepout
** with different level of debug information or without debug 
** information.  
** 
*/

BOOL Cexe_baseIDETest::StepModel(   )
{
 	LogTestHeader( "StepModel" );

	int count;
	BOOL fOkay;

	/*
	** test Step_Out of func with debug info into func w/out debug info	
	** also test to Step_Out of func w/out debug info into func w/ partial info
	** also test to Step_Out of func w/partial debug info into func w/full info
	** also test to Step_Out of func with debug info into func w/debug info
	**
	** ChainMain is expected to be compiled with full debug information
	** chain_1 is expected to be compiled with full debug information
	** chain_2 is expected to be compiled with partial debug information
	** chain_3 is expected to be compiled without debug information
	** chain_4 is expected to be compiled with full debug information
	*/

	dbg.Restart();

	/* 
	** test tracing into function with partial debug information.
	*/
 
	bps.SetBreakpoint("{chain_1}START");
	dbg.Go();
	dbg.AtSymbol("START");
	fOkay = dbg.StepInto(1,NULL, NULL, "chain_2");
	WriteLog( fOkay ? PASSED : FAILED, "Trace from full cvinfo into module w/only partial cvinfo");
	if (!fOkay)
		return fOkay;	
 
	/* 
	** test tracing out of function w/out cvinfo into func w/ partial.
	** ; test instruction level tracing
	*/

	EXPECT_TRUE ( bps.SetBreakpoint(_CHAIN_3) != NULL );
	EXPECT_TRUE ( dbg.Go(NULL, NULL, "chain_3") );
	EXPECT_TRUE ( dbg.StepInto(2, NULL, NULL, "chain_3") );
	EXPECT_TRUE ( bps.DisableAllBreakpoints() );

	count=0;
	while ( (count<25) && (stk.GetFunction().Find("chain_3") != -1))
	{
		count++;
		dbg.StepOver();   // step over chain_4 ...
	} 
	fOkay = stk.CurrentFunctionIs("chain_2");
	WriteLog( fOkay ? PASSED : FAILED, "instruction level tracing from no cvinfo to partial cvinfo");
	if (!fOkay)
		return fOkay;	

	dbg.SetSteppingMode(SRC);

 	/* 
	** test tracing into function w/out cvinfo
	*/

	bps.ClearAllBreakpoints();
	EXPECT_TRUE ( bps.SetBreakpoint("{WndProc}TagCallNoCVInfo") != NULL );

	dbg.Go();   // will hit the throw
	dbg.Go(); 	// go again to get to the breakpoint
	dbg.AtSymbol("TagCallNoCVInfo");
	dbg.SetSteppingMode(SRC);

	// attempt to trace into func, but func doesn't have cvinfo so 
	// trace should actually stepover
	fOkay = dbg.StepInto(1, NULL, NULL, "WndProc");
	WriteLog(fOkay ? PASSED : FAILED, "Source level trace of func call w/out cvinfo");
	if (!fOkay)
		return FALSE;	

	src.Find("TagCallNoCVInfo:", TRUE);
	if (dbg.SetNextStatement(NULL) == FALSE)
	{
		m_pLog->RecordFailure("Unable to Set_Next_Statement");
		return FALSE;	
	}
	if (dbg.SetSteppingMode(ASM) == FALSE)
	{
		m_pLog->RecordFailure("Unable to set stepping mode to ASM");
		return FALSE;	// ( FALSE, GetTestDesc() );
	}

	// don't know exactly how many instructions so allow a few traces 
	count=0;
	do 
	{
		count++;
		dbg.StepInto();
	} while( (count<17) && (!dbg.AtSymbol(_CHAIN_3)) );
	EXPECT_TRUE ( dbg.AtSymbol(_CHAIN_3) );
	// now only have dissassembly.  keep tracing until get back to mixed.
	do 
	{
		dbg.StepInto();
	} while (!dbg.AtSymbol("chain_4"));
	fOkay = dbg.AtSymbol("chain_4");
	WriteLog(fOkay ? PASSED : FAILED, "Instruction level trace from no cvinfo to full cvinfo");
	
	dbg.SetSteppingMode(SRC);
	bps.ClearAllBreakpoints();
	return TRUE;	
}

BOOL Cexe_baseIDETest::StaticFuncStepTrace( )
{
 	LogTestHeader( "StaticFuncStepTrace" );

	bps.ClearAllBreakpoints();

    dbg.Restart();
    EXPECT_TRUE( dbg.CurrentLineIs( "{" ) );
	
 	LogTestHeader( "SRC: Trace into Static member function and trace out" );

	EXPECT_TRUE( src.Find("try_array(iA);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "try_array(iA);") );
	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "try_array(Array<int>") );
	EXPECT_TRUE( dbg.StepOver(4, NULL, "iA.static_func(mid);") );
	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "Array<int>::static_func") );
	EXPECT_TRUE( dbg.StepInto(3, NULL, NULL, "try_array(Array<int>") );

	EXPECT_TRUE( dbg.StepOut(1, NULL, NULL, "main") );

	// repeat for double type of the template function
	EXPECT_TRUE( src.Find("try_array(dA);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "try_array(dA);") );
	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "try_array(Array<double>") );
	EXPECT_TRUE( dbg.StepOver(4, NULL, "iA.static_func(mid);") );
	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "Array<double>::static_func") );
	EXPECT_TRUE( dbg.StepInto(3, NULL, NULL, "try_array(Array<double>") );

	// Once more with a nested call
	EXPECT_TRUE( dbg.StepOut(1, NULL, NULL, "main") );
	EXPECT_TRUE( dbg.StepOver(1, NULL, "iA.static_func(iA.getSize());") );
	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "Array<int>::getSize") );
	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "main") );
	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "Array<int>::static_func") );
	EXPECT_TRUE( dbg.StepInto(3, NULL, NULL, "main") );

	// Step over static member function
	EXPECT_TRUE( dbg.StepOver(1, NULL, "dA.static_func(iA.getSize());") );
	EXPECT_TRUE( dbg.StepOver(1, NULL, "int iGo = TestG();", "main") );

	// foo calls foo_Include
	EXPECT_TRUE( src.Find("Int=foo(Local);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "Int=foo(Local);", "TestG") );
	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "foo") );
	EXPECT_TRUE( dbg.StepInto(2, NULL, NULL, "foo_Include") );
	EXPECT_TRUE( dbg.StepInto(5, NULL, NULL, "foo") );
	EXPECT_TRUE( dbg.StepInto(3, NULL, NULL, "TestG") );
	EXPECT_TRUE( dbg.StepInto(2, NULL, NULL, "foo_Include") );
	EXPECT_TRUE( dbg.StepOut(1, NULL, NULL, "TestG") );

	// Step over static function
	EXPECT_TRUE( dbg.StepOver(3, NULL, "nest_func(foo_Include(foo(Global)));") );

	// trace again through nested calls of static functions
	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "foo") );
	EXPECT_TRUE( dbg.StepInto(2, NULL, NULL, "foo_Include") );
	EXPECT_TRUE( dbg.StepInto(5, NULL, NULL, "foo") );
	EXPECT_TRUE( dbg.StepInto(3, NULL, NULL, "TestG") );
	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "foo_Include") );
	EXPECT_TRUE( dbg.StepOut(1, NULL, NULL, "TestG") );

	// Test a couple situations in Disassmebly
    dbg.Restart();
    EXPECT_TRUE( dbg.CurrentLineIs( "{" ) );
	
 	LogTestHeader( "DAM: Trace into Static member function and trace out" );

	EXPECT_TRUE( src.Find("try_array(iA);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "try_array(iA);") );
	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "try_array(Array<int>") );
	EXPECT_TRUE( dbg.StepOver(4, NULL, "iA.static_func(mid);") );
	dbg.SetSteppingMode(ASM);

	//trace in
	int count=0;
	while ( (count<25) && (!stk.CurrentFunctionIs("Array<int>::static_func")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE ( stk.CurrentFunctionIs("Array<int>::static_func") );

	//trace out
	count=0;
	while ( (count<25) && (!stk.CurrentFunctionIs("try_array(Array<int>")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE ( stk.CurrentFunctionIs("try_array(Array<int>") );

	EXPECT_TRUE( dbg.StepOut(1, NULL, NULL, "main") );
	dbg.SetSteppingMode(SRC);

	// Step over static member function in DAM
 	LogTestHeader( "DAM: Step Over Static member function" );
	EXPECT_TRUE( src.Find("dA.static_func(iA.getSize());") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "dA.static_func(iA.getSize());") );
	dbg.SetSteppingMode(ASM);
	count=0;
	while ( (count<25) && (!dbg.CurrentLineIs( "static_func" )) )
	{
		count++;
		dbg.StepOver();
		Sleep(100);
	} 
	EXPECT_TRUE ( dbg.CurrentLineIs( "static_func" ) );
	EXPECT_TRUE( dbg.StepOver(1, NULL, NULL, "main") );

	dbg.SetSteppingMode(SRC);

 	LogTestHeader( "DAM: Step Over simple Static function" );
	EXPECT_TRUE( src.Find("Int=foo(Local);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "Int=foo(Local);") );
	dbg.SetSteppingMode(ASM);
	count=0;
	while ( (count<25) && (!dbg.CurrentLineIs( "foo" )) )
	{
		count++;
		dbg.StepOver();
		Sleep(100);
	} 
	EXPECT_TRUE ( dbg.CurrentLineIs( "foo" ) );
	EXPECT_TRUE( dbg.StepOver(1, NULL, NULL, "TestG") );

	dbg.SetSteppingMode(SRC);

 	LogTestHeader( "DAM: Trace into simple Static function and trace out" );

	EXPECT_TRUE( src.Find("nest_func(foo_Include(foo(Global)));") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "nest_func(foo_Include(foo(Global)));") );
	dbg.SetSteppingMode(ASM);

	//trace from TestG into foo
	count=0;
	while ( (count<25) && (!stk.CurrentFunctionIs("foo")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE ( stk.CurrentFunctionIs("foo") );

	//trace from foo into foo_Include
	count=0;
	while ( (count<25) && (!stk.CurrentFunctionIs("foo_Include")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE ( stk.CurrentFunctionIs("foo_Include") );

	//trace out	from foo_Include back to foo
	count=0;
	while ( (count<25) && (!stk.CurrentFunctionIs("foo")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE ( stk.CurrentFunctionIs("foo") );

	//trace out	from foo back to TestG
	count=0;
	while ( (count<25) && (!stk.CurrentFunctionIs("TestG")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE ( stk.CurrentFunctionIs("TestG") );

	//trace from TestG into foo_Include
	count=0;
	while ( (count<25) && (!stk.CurrentFunctionIs("foo_Include")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE ( stk.CurrentFunctionIs("foo_Include") );

	//trace out	from foo_Include back to TestG
	count=0;
	while ( (count<25) && (!stk.CurrentFunctionIs("TestG")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE ( stk.CurrentFunctionIs("TestG") );

	dbg.StopDebugging();

	return TRUE;	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\exe\exe_base.h ===
///////////////////////////////////////////////////////////////////////////////
//	exe_base.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CexeIDETest Class
//

#ifndef __exe_base_H__
#define __exe_base_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\dbgtestbase.h"
#include "exesub.h"

///////////////////////////////////////////////////////////////////////////////
//	CexeIDETest class

class Cexe_baseIDETest : public CDbgTestBase
{
	DECLARE_TEST(Cexe_baseIDETest, CexeSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run();

// Test Cases
protected:

	// Go cases
	BOOL GoAndVerify();
	BOOL RestartAndGo();
	BOOL RestartStopDebugging();

	// Step cases
	BOOL StepIntoSource();
	BOOL StepOverSource();
	BOOL StepOutSource();
	BOOL StepToCursorSource();
	BOOL StepModel();
	BOOL StaticFuncStepTrace();

};

#endif //__exe_base_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\exe\exe_bp.h ===
///////////////////////////////////////////////////////////////////////////////
//	exe_bp.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CexeIDETest Class
//

#ifndef __exe_bp_H__
#define __exe_bp_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\dbgtestbase.h"
#include "exesub.h"

///////////////////////////////////////////////////////////////////////////////
//	Cexe_bpIDETest class

class Cexe_bpIDETest : public CDbgTestBase
{
	DECLARE_TEST(Cexe_bpIDETest, CexeSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run();

// Test Cases
protected:

	BOOL StepOverFuncToBreakAtLocBP();
	BOOL StepOverFuncToBreakOnExprTrueBP();
	BOOL StepOverFuncToBreakOnExprChangesBP();
	BOOL BreakStepTrace();
	BOOL StepBPLineSRC();
	BOOL StepBPLineDAM();
};

#endif //__exe_bp_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\exe\exe_dlls.h ===
///////////////////////////////////////////////////////////////////////////////
//	exe_dlls.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the Cexe_dllsIDETest Class
//

#ifndef __exe_dlls_H__
#define __exe_dlls_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\dbgtestbase.h"
#include "exesub.h"

///////////////////////////////////////////////////////////////////////////////
//	CexeIDETest class

class Cexe_dllsIDETest : public CDbgTestBase
{
	DECLARE_TEST(Cexe_dllsIDETest, CexeSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run();

// Test Cases
protected:

	BOOL DllStepTrace();
	BOOL DllStepOut();
	BOOL DllTraceOut();
	BOOL StepOverFuncInUnloadedDll();
	BOOL RestartFromWithinDll();
	BOOL GoFromWithinDll();

};

#endif //__exe_dlls_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\exe\gocases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	GoCases.cpp
//
//	Created by :			Date :
//		YefimS			11/21/93
//
//	Description :
//		Implementation of Go cases
//

#include <process.h>
#include "stdafx.h"
#include "execase.h"

///////////////////////////////////////////////////////////////////////////////
//	Test Cases
///////////////////////////////////////////////////////////////////////////////

BOOL CexeIDETest::GoAndVerify( )
{
 	LogTestHeader( "GoAndVerify" );
	m_pLog->RecordInfo( " Run an app and verify it ran " );

	EXPECT_TRUE( dbg.Go(NULL, NULL, NULL, WAIT_FOR_TERMINATION) );
	return (TRUE);
}

BOOL CexeIDETest::RestartAndGo( )
{
 	LogTestHeader( "RestartAndGo" );
	m_pLog->RecordInfo( " Restart, verify stop and Go " );

	EXPECT_TRUE( dbg.Restart() );
	if( UIWB.GetPcodeSwitch() )
	{
		EXPECT_TRUE( dbg.CurrentLineIs( "int iGo = TestG();" ) );
	}
	else
	{
		EXPECT_TRUE( dbg.CurrentLineIs( "{" ) );
	}

	EXPECT_TRUE( dbg.Go(NULL, NULL, NULL, WAIT_FOR_TERMINATION) );

	return (TRUE);
}


BOOL CexeIDETest::RestartStopDebugging( )
{
 	LogTestHeader( "RestartStopDebugging" );
	m_pLog->RecordInfo( "Restart, StopDebugging and verify" );

    EXPECT_TRUE( dbg.Restart() );

	if( UIWB.GetPcodeSwitch() )
	{
	//dbg.SetSteppingMode(SRC);  //Temporary workaround: 
		EXPECT_TRUE( dbg.CurrentLineIs( "int iGo = TestG();" ) );
	}
	else
	{
		EXPECT_TRUE( dbg.CurrentLineIs( "{" ) );
	}
	EXPECT_TRUE( dbg.StopDebugging() );
	#if defined( _M_IX86 ) || defined( _MAC )  // WinslowF - for OEM compatibility
		EXPECT_TRUE( VerifyProjectRan(0) );
	#else
		EXPECT_TRUE( VerifyProjectRan(1) );
	#endif

	WriteLog(PASSED, "Stop Debugging was handled as expected" );
	return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\exe\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\exe\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\exe\exe_spec.h ===
///////////////////////////////////////////////////////////////////////////////
//	exe_spec.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the Cexe_specialIDETest Class
//

#ifndef __exe_spec_H__
#define __exe_spec_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\dbgtestbase.h"
#include "exesub.h"

///////////////////////////////////////////////////////////////////////////////
//	CexeIDETest class

class Cexe_specialIDETest : public CDbgTestBase
{
	DECLARE_TEST(Cexe_specialIDETest, CexeSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run();

// Test Cases
protected:

	BOOL GoExeDoesNotExist();
	BOOL ExitWhileDebugging();

	BOOL CannotFindDll();
	BOOL StdInOutRedirection();
	BOOL NoSystemCodeStepping();
	BOOL TraceIntoWndProc();

// Utilities
protected:
	BOOL CheckGeneralNetworkFailure();

};

#endif //__exe_spec_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\mem\mem1.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	ME1CASES.CPP
//
//	Created by :			Date :
//		YefimS			11/21/93
//
//	Description :
//		Implementation of the CmemIDETest class
//

#include <process.h>
#include "stdafx.h"
#include "memcase.h"

///////////////////////////////////////////////////////////////////////////////
//	Test Cases
///////////////////////////////////////////////////////////////////////////////

BOOL CmemIDETest::GoAfterScrollMemoryWnd( )
{
//	DESC( "Restart, Scroll MemoryWnd and Go", "GoAfterScrollMemoryWnd" );

	BOOL retval = TRUE;
	COSource		src;	// WinslowF - added to call GoToLine. It's not in UIWB any more.

	CODebug codebug;
	EXPECT( codebug.Restart() );

	int i;
	UIMemory umw = UIDebug::ShowDockWindow( IDW_MEMORY_WIN, TRUE );
	EXPECT( umw.IsActive() );

	EXPECT ( umw.GoToAddress("0x16") == ERROR_SUCCESS);

	EXPECT ( umw.GoToAddress("0x7f0000") == ERROR_SUCCESS);
	
	for ( i = 0; i < 200; i++)
	{
		MST.DoKeys ("+{pgdn}");
	}

   if ( !UIWB.VerifySubstringAtLine( "  ?? ??" ) )
	{
		// REVIEW(michma - 3/16/98): VerifySubstringAtLine causes focus to go to source window due to new DoKeyshWnd call.
	    umw = UIDebug::ShowDockWindow( IDW_MEMORY_WIN, TRUE );
		EXPECT ( umw.GoToAddress("0x2000000") == ERROR_SUCCESS);
	}
		
   if ( !UIWB.VerifySubstringAtLine( "  ?? ??" ) )
	{
		// REVIEW(michma - 3/16/98): VerifySubstringAtLine causes focus to go to source window due to new DoKeyshWnd call.
	    umw = UIDebug::ShowDockWindow( IDW_MEMORY_WIN, TRUE );
		EXPECT ( umw.GoToAddress("0xffffffff") == ERROR_SUCCESS);
	}
		
   if ( !UIWB.VerifySubstringAtLine( "  ?? ??" ) )
	{
   	m_pLog->RecordInfo("0x02000000 : The app is too big: test case should be revised" );
		retval = FALSE;
	}

   EXPECT( codebug.Go(NULL,NULL,NULL,WAIT_FOR_TERMINATION) );

   WriteLog(PASSED, "Scrolling Memory Window didn't corrupt Debugging" );

//codebug.StopDebugging();
	return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\exe\exe_spec.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	exe_spec.CPP
//											 
//	Created by :			
//		VCBU QA		

#include <process.h>
#include "stdafx.h"
#include "exe_spec.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
IMPLEMENT_TEST(Cexe_specialIDETest, CDbgTestBase, "Execution Special", -1, CexeSubSuite)
												 
void Cexe_specialIDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

void Cexe_specialIDETest::Run()
{	 
	XSAFETY;
	
	if( SetProject("testgo01\\testgo01", PROJECT_XBE))
	{	  
		bps.ClearAllBreakpoints();
		XSAFETY;
		GoExeDoesNotExist();
		XSAFETY;
		// TODO(michma): this has broken since chris' performance chagnes. 2/24/98
		//ExitWhileDebugging();
		XSAFETY;
	}

/*	It doesn't work now: the msg dialog is hidden behind the IDE and even Spy++ cannot see it	
	if (SetProject("dllapp\\incdll", PROJECT_DLL) && SetProject("dllapp\\powdll", PROJECT_DLL)
		&& SetProject("dllapp\\dec2", PROJECT_DLL) && SetProject("dllapp\\dllappx"))
	{
		XSAFETY;
		bps.ClearAllBreakpoints();
		EXPECT_TRUE(CannotFindDll());
		XSAFETY;
	}
*/
 
	if(0) //xbox TODO SetProject("dbga\\dbga"))
	{	  
		XSAFETY;
		if(!(GetSystem() & SYSTEM_NT))
		{
			NoSystemCodeStepping();
			XSAFETY;
		}

/* bug # 1347 is postponed for after V50
		TraceIntoWndProc();
		XSAFETY;
*/
	}

	// close the project in preparation for the next group of tests.
	COProject prj;
	prj.Attach();
	prj.Close();

}


///////////////////////////////////////////////////////////////////////////////
//	Test Cases
///////////////////////////////////////////////////////////////////////////////

BOOL Cexe_specialIDETest::GoExeDoesNotExist( )
{
 	LogTestHeader( "GoExeDoesNotExist" );
	m_pLog->RecordInfo( "Try to execute nonexisting PCTarget, correct the path and GO" );

	char* szTARGET_EXT = ".xbe";
	char* szREMOTE_TARGET_EXT = "";

	CString stOldTarget = m_strProjectName + szTARGET_EXT ;
	CString stAbsPathTarget =  m_strProjectDir + "\\" + m_strProjectName + szTARGET_EXT ;
	CString stNewTarget = m_strProjectDir + "\\kit\\" + m_strProjectName + szTARGET_EXT;
	CString stBadTarget = m_strProjectDir + "\\..\\" + m_strProjectName + szTARGET_EXT ;

	// Rename the target and run
	CopyFile(stAbsPathTarget, m_strProjectDir + "\\foo" + szTARGET_EXT, FALSE);
	DeleteFile(stAbsPathTarget);
	EXPECT_TRUE(dbg.Go(NULL,NULL,NULL,0) );

	if( WaitMsgBoxText("does not exist", 10) )
	{
		WriteLog( PASSED, "01 : The MsgBox \"... does not exist...\" was found as expected" );
		MST.WButtonClick( "OK" ); // MST.WButtonClick( "No" );
	}
	else
	{
		if( WaitMsgBoxText("not found", 10) )
		{
			WriteLog( PASSED, "01 : The MsgBox \"...File not found\" was found as expected" );
			MST.WButtonClick( "OK" );
		}
		else
		{
			WriteLog( FAILED, "01 : The MsgBox \"...File not found\" was not found" );
			WriteLog( FAILED, "01 : The MsgBox \"... does not exist...\" was not found" );
			EXPECT_TRUE( FALSE );	 	
		}
	}
	
	// Set incorrect path\target 
	EXPECT_TRUE(prj.SetLocalTarget(stBadTarget) == ERROR_SUCCESS);
	EXPECT_TRUE(dbg.Go(NULL,NULL,NULL,0));

	if( WaitMsgBoxText("or do not exist", 10)) 
	{
		WriteLog( PASSED, "The MsgBox \"One or more targets are out of date...\" was found" );
		MST.WButtonClick( "No" );
	}

/*	EXPECT_TRUE( WaitMsgBoxText("not be opened", 10));
	EXPECT_TRUE( WaitMsgBoxText("not exist", 10));
	MST.WButtonClick( "OK" );
*/
 	if( WaitMsgBoxText("does not exist", 10) )
	{
		WriteLog( PASSED, "01 : The MsgBox \"... does not exist...\" was found as expected" );
		MST.WButtonClick( "OK" ); // MST.WButtonClick( "No" );
	}
	else
	{
		if( WaitMsgBoxText("not found", 10) )
		{
			WriteLog( PASSED, "01 : The MsgBox \"...File not found\" was found as expected" );
			MST.WButtonClick( "OK" );
		}
		else
		{
			WriteLog( FAILED, "01 : The MsgBox \"...File not found\" was not found" );
			WriteLog( FAILED, "01 : The MsgBox \"... does not exist...\" was not found" );
			EXPECT_TRUE( FALSE );	 	
		}
	}

	// Set correct new path\target and run
	CreateDirectory(m_strProjectDir + "\\kit", 0);          
	CopyFile(m_strProjectDir + "\\foo" + szTARGET_EXT, stNewTarget, FALSE);
	EXPECT(prj.SetLocalTarget(stNewTarget) == ERROR_SUCCESS );
	//xbox - we cant terminate
	//EXPECT_TRUE( dbg.Go(NULL, NULL, NULL, WAIT_FOR_TERMINATION) );
	EXPECT_TRUE( dbg.Go() );

	if( WaitMsgBoxText("or do not exist", 10))
	{
		WriteLog( PASSED, "01 : The MsgBox \"One or more targets are out of date...\" was found as expected" );
		MST.WButtonClick( "No" );
		while(MST.WFndWndC("or do not exist", "Static", FW_PART));
	}

	// REVIEW (michma): why does UIWB.WaitForRun() never return?
	//UIWB.WaitForRun();
	// Sleep(10000);
	CString TitleRun = (CString)"[" + GetLocString(IDSS_DBG_RUN) + "]";
	MST.WFndWndWait(TitleRun, FW_PART, 10);

//	UIWB.WaitForTermination();
	//xbox - cant do this
	//dbg.Wait(WAIT_FOR_TERMINATION);
	EXPECT_TRUE( dbg.StopDebugging() );

/*	EXPECT_TRUE( VerifyProjectRan() );
*/
	// Remove temporary file and dir
	DeleteFile(stNewTarget);
	RemoveDirectory(m_strProjectDir + "\\kit");         

	// Set correct AbsPath\target 
	EXPECT( prj.SetLocalTarget(stAbsPathTarget) == ERROR_SUCCESS );

	// Exe is still out of place
	EXPECT_TRUE(dbg.Go(NULL,NULL,NULL,0) );
	if( WaitMsgBoxText("does not exist", 10) )
	{
		WriteLog( PASSED, "The MsgBox \"... does not exist...\" was found as expected" );
		MST.WButtonClick( "OK" ); // MST.WButtonClick( "No" );
	}
	else
	{
		if( WaitMsgBoxText("not found", 10) )
		{
			WriteLog( PASSED, "The MsgBox \"...File not found\" was found as expected" );
			MST.WButtonClick( "OK" );
		}
		else
		{
			WriteLog( FAILED, "The MsgBox \"...File not found\" was not found" );
			WriteLog( FAILED, "The MsgBox \"... does not exist...\" was not found" );
			EXPECT_TRUE( FALSE );	 	
		}
	}

	// Exe is back in place
	CopyFile(m_strProjectDir + "\\foo" + szTARGET_EXT, stAbsPathTarget, FALSE);
	DeleteFile(m_strProjectDir + "\\foo" + szTARGET_EXT);
	Sleep(1000);
	//xbox - we don't terminate
	//EXPECT_TRUE( dbg.Go(NULL, NULL, NULL, WAIT_FOR_TERMINATION) );
	EXPECT_TRUE( dbg.Go() );
	EXPECT_TRUE( dbg.StopDebugging() );

	// Restore initial target
	EXPECT_TRUE( prj.SetLocalTarget(stOldTarget) == ERROR_SUCCESS );

	// Verify restoration is OK
	//EXPECT_TRUE( dbg.Go(NULL, NULL, NULL, WAIT_FOR_TERMINATION) );
	EXPECT_TRUE( dbg.Go() );
	EXPECT_TRUE( dbg.StopDebugging() );

	return (TRUE);
}

BOOL Cexe_specialIDETest::CheckGeneralNetworkFailure( )
{
	if( WaitMsgBoxText("General Network Failure", 10) )
	{
		MST.DoKeys( KEY_Enter );
		return (FALSE);      
	}
	else
	{
		return (TRUE);      
	}
}


BOOL Cexe_specialIDETest::ExitWhileDebugging( )
{
 	LogTestHeader( "ExitWhileDebugging" );

	m_pLog->RecordInfo( "Restart, Exit IDE and verify: ExitWhileDebugging" );
	dbg.Restart();
	dbg.SetSteppingMode(SRC);  //Temporary workaround: bug #15556
	CString strLine = "{";

	if( UIWB.GetPcodeSwitch() )
		strLine = "int iGo = TestG();";

    EXPECT_TRUE( dbg.CurrentLineIs( strLine ) );
	UIWB.DoCommand(ID_APP_EXIT, DC_MNEMONIC);
	
	if( WaitMsgBoxText("command will stop the debugger", 10) )
	{
		WriteLog( PASSED, "01 : The MsgBox \"command will stop the debugger\" was found as expected" );
		MST.WButtonClick( "Cancel" );
	}
	else
	{
		WriteLog( FAILED, "01 : The MsgBox \"command will stop the debugger\" was not found as expected" );
		EXPECT_TRUE( FALSE );	 	
	}
 
	UIWB.DoCommand(ID_APP_EXIT, DC_MNEMONIC);

	if( WaitMsgBoxText("command will stop the debugger", 10) )
	{
		WriteLog( PASSED, "02 : The MsgBox \"command will stop the debugger\" was found as expected" );
		MST.WButtonClick( "OK" );
	}
	else
	{
		WriteLog( FAILED, "02 : The MsgBox \"command will stop the debugger\" was not found as expected" );
		EXPECT_TRUE( FALSE );	 	
	}

	if( WaitMsgBoxText("want to save", 10) )
	{
		MST.WButtonClick( "No" );
	}

	while(GetSubSuite()->GetIDE()->IsLaunched());

	// REVIEW(briancr): use RTTI for this cast, or at least to validate it
	GetSubSuite()->GetIDE()->Launch();
	WriteLog( PASSED, "03 : The IDE was closed and reopened as expected" );
	return (TRUE);
}


BOOL Cexe_specialIDETest::CannotFindDll( )
{
 	LogTestHeader( "CannotFindDll" );
	m_pLog->RecordInfo( "Try to start debugging exe which cannot find associated Dll, correct the path and debug" );

	// Verify we can start debugging
	dbg.Restart();
	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "WinMain") );
	dbg.StopDebugging();

	// Rename dec2.dll to dec22.dll and start debugging
	CopyFile(m_strProjectDir + "\\dec2.dll", m_strProjectDir + "\\dec22.dll", FALSE);
	DeleteFile(m_strProjectDir + "\\dec2.dll");
	EXPECT_TRUE(dbg.StepInto(1,NULL,NULL,NULL,0) );

//	dbg.CancelMsg(MSG_DLL_NOT_FOUND);	 // it got out of the CODebug ?
/*	if( WaitMsgBoxText("not found", 10) )
	{
		WriteLog( PASSED, "01 : The MsgBox \"...not found...\" was found" );
		MST.WButtonClick( "OK" ); 
	}
	else
	{
		if( WaitMsgBoxText("Could not execute", 10) )
		{
			WriteLog( PASSED, "01 : The MsgBox \"Could not execute...\" was found as expected" );
			MST.DoKeys( KEY_Enter );
			if( WaitMsgBoxText("Cannot execute", 10) )
			{
				WriteLog( PASSED, "01 : The MsgBox \"Cannot execute...\" was found as expected" );
				MST.DoKeys( KEY_Enter );
			}
		}
		else
		{
			WriteLog( FAILED, "The MsgBox \"...not found\" was not found" );
			WriteLog( FAILED, "The MsgBox \"Could not execute...\" was not found" );
			EXPECT_TRUE( FALSE );	 	
		}
	}
	
	if( WaitMsgBoxText("not found", 10) )
	{
		WriteLog( PASSED, "01 : The MsgBox \"...not found...\" was found" );
		MST.WButtonClick( "OK" ); 
	}
	else
	{
		if( WaitMsgBoxText("Could not execute", 10) )
		{
			WriteLog( PASSED, "01 : The MsgBox \"Could not execute...\" was found as expected" );
			MST.DoKeys( KEY_Enter );
			if( WaitMsgBoxText("Cannot execute", 10) )
			{
				WriteLog( PASSED, "01 : The MsgBox \"Cannot execute...\" was found as expected" );
				MST.DoKeys( KEY_Enter );
			}
		}
		else
		{
			WriteLog( FAILED, "The MsgBox \"...not found\" was not found" );
			WriteLog( FAILED, "The MsgBox \"Could not execute...\" was not found" );
			EXPECT_TRUE( FALSE );	 	
		}
	}
*/	
/*	
	if( WaitMsgBoxText("Could not execute", 10) )
	{
		WriteLog( PASSED, "01 : The MsgBox \"Could not execute...\" was found as expected" );
		MST.DoKeys( KEY_Enter );
	}
	else
	{
		WriteLog( FAILED, "01 : The MsgBox \"Could not execute...\" was not found" );
		EXPECT_TRUE( FALSE );	 	
	}
*/	
	// Restore initial Dll
	CopyFile(m_strProjectDir + "\\dec22.dll", m_strProjectDir + "\\dec2.dll", FALSE);
	DeleteFile(m_strProjectDir + "\\dec22.dll");
	EXPECT_TRUE( dbg.StepInto(1, NULL, "{", "WinMain") );
	dbg.StopDebugging();

	return (TRUE);
}

BOOL Cexe_specialIDETest::TraceIntoWndProc()
{
 	LogTestHeader( "TraceIntoWndProc" );
	bps.ClearAllBreakpoints();

	UIWB.OpenFile( m_strProjectDir + "\\" + "main2.c");
	EXPECT_TRUE( src.Find("SendMessage(") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "SendMessage(") );
//	EXPECT_TRUE( dbg.StepInto(1, NULL, "{", "WndProc") );
	EXPECT_TRUE( dbg.StepInto(1, NULL, "{") );
	EXPECT_TRUE( stk.CurrentFunctionIs("WndProc")	);
	EXPECT_TRUE( dbg.StepInto(1, NULL, "SAVELABEL(TagCallOtherMain);", "WndProc") );

	dbg.StopDebugging();
	return (TRUE);
}

BOOL Cexe_specialIDETest::NoSystemCodeStepping()
{
 	LogTestHeader( "NoSystemCodeStepping" );
	bps.ClearAllBreakpoints();
	BOOL ret = TRUE;

	UIWB.OpenFile( m_strProjectDir + "\\" + "main2.c");
	EXPECT_TRUE( src.Find("SAVELABEL(TagCreateCase);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "SAVELABEL(TagCreateCase);", "WndProc") );
	EXPECT_TRUE( dbg.StepOut(1, NULL, NULL, NULL, 0) );

//	if( WaitMsgBoxText("Cannot step through system code", 280) )
	if( WaitMsgBoxText("Can't trace into system DLLs", 280) )
	{
		WriteLog( PASSED, "The MsgBox \"Can't trace into system DLLs\" was found as expected" );
		MST.WButtonClick( "OK" ); 
	}
	else
	{
		WriteLog( FAILED, "The MsgBox \"Can't trace into system DLLs\" was not found" );
		ret = FALSE;	 	
	}
	dbg.StopDebugging();
	return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\exe\exe_bp.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	exe_bp.CPP
//											 
//	Created by :			
//		VCBU QA		
//
//	Description :								 
//		TestWizard Generated script		 

#include <process.h>
#include "stdafx.h"
#include "exe_bp.h"	

#if defined(_MIPS_) || defined(_ALPHA_)
#define _CHAIN_2 "chain_2"
#define _CHAIN_3 "chain_3"
#else
#define _CHAIN_2 "_chain_2"
#define _CHAIN_3 "_chain_3"
#endif

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
											   
IMPLEMENT_TEST(Cexe_bpIDETest, CDbgTestBase, "Execution and Breakpoints", -1, CexeSubSuite)
												 
void Cexe_bpIDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

void Cexe_bpIDETest::Run()
{	 
	XSAFETY;
	
	if( SetProject("testgo01\\testgo01", PROJECT_XBE))
	{	  
		EXPECT_TRUE(bps.ClearAllBreakpoints());
		XSAFETY;
		StepOverFuncToBreakAtLocBP();
		XSAFETY;
		StepOverFuncToBreakOnExprTrueBP();
		XSAFETY;
		StepOverFuncToBreakOnExprChangesBP();
		XSAFETY;
		StepBPLineSRC();
		XSAFETY;
		StepBPLineDAM();
		XSAFETY;
	}
		
	/* For the dbg project:
	** ChainMain is expected to be compiled with full debug information
	** chain_1 is expected to be compiled with full debug information
	** chain_2 is expected to be compiled with partial debug information
	** chain_3 is expected to be compiled without debug information
	** chain_4 is expected to be compiled with full debug information
	*/
	if (0) //xbox TODO SetProject("dbg\\dbg") )
	{
		EXPECT_TRUE(bps.ClearAllBreakpoints());
		XSAFETY;
		EXPECT(BreakStepTrace());
		XSAFETY;
	}
	StopDbgCloseProject();
	Sleep(1000);
	
}


///////////////////////////////////////////////////////////////////////////////
//	Test Cases

/*
** A number of tests lumped together.  Some involve different level of debug
** information or without debug information.  Also a test or two
** involving step/stepout and breakpoints which are important enough
** to have in the stepping model tests.
*/

BOOL Cexe_bpIDETest::BreakStepTrace(   )
{ 	
 	LogTestHeader( "BreakStepTrace" );

 	/*
	** test Step_Out of func which fires a bp in a nested func in secondary module.
	** test to Step_Out of func with debug info into func w/out debug info	
	** also test to Step_Out of func w/out debug info into func w/ partial info
	** also test to Step_Out of func w/partial debug info into func w/full info
	** also test to Step_Out of func with debug info into func w/debug info
	*/

	bp *bp;
	BOOL fSuccess;
	
	dbg.StopDebugging();
	bp=bps.SetBreakpoint("WndProc");
	dbg.Go();  								// execute to function WndProc 
	EXPECT_TRUE ( dbg.VerifyAtSymbol("WndProc") );
	// Step past prolog
	dbg.StepOver(); 						
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	// set breakpoint on label
	bp = bps.SetBreakpoint("TagCallChainMain"); 	
	// execute to bp at label
	dbg.Go();  								
	EXPECT_TRUE ( dbg.AtSymbol("{WndProc}TagCallChainMain") );
	EXPECT_TRUE ( dbg.StepInto(1,"ChainMain") );

	/* 
	** test tracing out of static function.
	** test Step_Out of func which fires a bp in a nested func in 
	** secondary module.
	*/

	EXPECT_TRUE ( bps.SetBreakpoint("chain_4") != NULL );
	EXPECT_TRUE ( bps.SetBreakpoint("chain_5") != NULL );
	dbg.Go();
	EXPECT_TRUE ( dbg.AtSymbol("chain_4") );

	// attempt to step out but fire on breakpoint in nested function call
	// proper location is chain_5
	fSuccess = dbg.StepOut(1, NULL, NULL, "chain_5"); 
	WriteLog( fSuccess ? PASSED : FAILED, "StepOut and fire on breakpoint in nested function");
	if (!fSuccess)
		return fSuccess;			
	
	dbg.StepInto();
	EXPECT_TRUE ( fSuccess &= dbg.StepOut(1, NULL, NULL, "chain_4") );

	EXPECT_TRUE ( fSuccess &= dbg.StepOut(1, NULL, NULL, "chain_3") );
	WriteLog( fSuccess ? PASSED : FAILED, "StepOut from full to none cvinfo");

	fSuccess = dbg.StepOut(1, NULL, NULL, "chain_2");  
	WriteLog( fSuccess ? PASSED : FAILED, "StepOut from none to partial cvinfo");

	if (!fSuccess)
		return fSuccess;	
	fSuccess = dbg.StepOut(1, NULL, NULL, "chain_1");  
	WriteLog( fSuccess ? PASSED : FAILED, "StepOut from partial cvinfo to full cvinfo");

	if (!fSuccess)
		return fSuccess;	
	fSuccess = dbg.StepOut(1, NULL, NULL, "ChainMain"); 
	WriteLog( fSuccess ? PASSED : FAILED, "StepOut from full cvinfo to full cvinfo");
	if (!fSuccess)
		return fSuccess;	
/*	
	// attempt to step over function but which generates an exception.
	// ToDo: Yefims: this should go to NLG test
	bps.SetBreakpoint("{OtherMain}TagStepEH");
	dbg.Go();
	dbg.StepOver();
#if defined( _MIPS_ ) || defined(_ALPHA_)
	EXPECT_TRUE(stk.CurrentFunctionIs("NTDLL!"));
#else
	EXPECT_TRUE(stk.CurrentFunctionIs("KERNEL32!"));
#endif
	dbg.StepOut();
	dbg.StepOut();
	//TODO: where should we be?
 */
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	return TRUE;	
}									


BOOL Cexe_bpIDETest::StepOverFuncToBreakAtLocBP()
{
 	LogTestHeader( "StepOverFuncToBreakAtLocBP" );

	UIWB.OpenFile( m_strProjectDir + "\\" + "testgo.c");

	EXPECT_TRUE( src.Find("Int=foo(Local);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "Int=foo(Local);") );
	EXPECT_TRUE( src.Find("return Parameter;") );
	EXPECT_TRUE( bps.SetBreakpoint() != NULL );
	EXPECT_TRUE( dbg.StepOver(1, NULL, "return Parameter;") );

	EXPECT_TRUE( src.Find("nest_func();") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "nest_func();") );
	EXPECT_TRUE( bps.SetBreakpoint("func") != NULL );
	EXPECT_TRUE( dbg.StepOver(1, NULL, NULL, "func") );

	EXPECT_TRUE(bps.ClearAllBreakpoints());
	dbg.StopDebugging();
	return (TRUE);
}

BOOL Cexe_bpIDETest::StepOverFuncToBreakOnExprTrueBP()
{
 	LogTestHeader( "StepOverFuncToBreakOnExprTrueBP" );

	UIWB.OpenFile( m_strProjectDir + "\\" + "testgo.c");

	EXPECT_TRUE( src.Find("Int = foo_Include(Int);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "Int = foo_Include(Int);") );
	EXPECT_TRUE( bps.SetBreakOnExpr("{foo_Include}number==34", COBP_TYPE_IF_EXP_TRUE) != NULL );
	dbg.StepOver(1, NULL, NULL, NULL, 0);
	if( WaitMsgBoxText("Break when '{foo_Include}number==34'", 280) )
	{
		WriteLog( PASSED, "The MsgBox \"Break when '{foo_Include}number==34'\" was found as expected" );
		// REVIEW(michma - 6/3/99): there is this weird problem on w2k where the data breakpoint hit msg box
		// isn't active right away. doesn't repro manually, only when performed through cafe.
		// so we need to reactivate the IDE for the OK button to become active so we can dismiss the dlg.
		UIWB.Activate();
		MST.WButtonClick( "OK" );
		while(MST.WButtonExists("OK"));
		EXPECT_TRUE_COMMENT( TRUE, "BreakOnExprTrue" );	 	
	}
	else
	{
		WriteLog( FAILED, "The MsgBox \"Break when '{foo_Include}number==34'\" was not found" );
		EXPECT_TRUE( FALSE );	 	
	}
	EXPECT_TRUE( dbg.CurrentLineIs( "if(number == 3)" ) );
	EXPECT_TRUE( cxx.ExpressionValueIs("number == 34",1) );

	UIWB.OpenFile( m_strProjectDir + "\\" + "testgo.c");
	EXPECT_TRUE( src.Find("Int=recur_func();") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "Int=recur_func();") );
	EXPECT_TRUE( bps.SetBreakOnExpr("{recur_func}x==2", COBP_TYPE_IF_EXP_TRUE) != NULL );
	dbg.StepOver(1, NULL, NULL, NULL, 0);
	if( WaitMsgBoxText("Break when '{recur_func}x==2'", 280) )
	{
		WriteLog( PASSED, "The MsgBox \"Break when '{recur_func}x==2'\" was found as expected" );
		// REVIEW(michma - 6/3/99): there is this weird problem on w2k where the data breakpoint hit msg box
		// isn't active right away. doesn't repro manually, only when performed through cafe.
		// so we need to reactivate the IDE for the OK button to become active so we can dismiss the dlg.
		UIWB.Activate();
		MST.WButtonClick( "OK" );
		while(MST.WButtonExists("OK"));
		EXPECT_TRUE_COMMENT( TRUE, "BreakOnExprTrue" );	 	
	}
	else
	{
		WriteLog( FAILED, "The MsgBox \"Break when '{recur_func}x==2'\" was not found" );
		EXPECT_TRUE( FALSE );	 	
	}
	EXPECT_TRUE( dbg.CurrentLineIs( "if (x<9) recur_func();" ) );
	EXPECT_TRUE( cxx.ExpressionValueIs("x==2",1) );
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	// TODO(michma): we need to do this extra step because of bug 38172.
	EXPECT_TRUE(dbg.StepInto());

	dbg.StopDebugging();
	return (TRUE);
}

BOOL Cexe_bpIDETest::StepOverFuncToBreakOnExprChangesBP()
{
 	LogTestHeader( "StepOverFuncToBreakOnExprChangesBP" );

	UIWB.OpenFile( m_strProjectDir + "\\" + "testgo.c");
	EXPECT_TRUE( src.Find("Int=recur_func();") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "Int=recur_func();") );
	EXPECT_TRUE( bps.SetBreakOnExpr("{recur_func}x", COBP_TYPE_IF_EXP_CHANGED) != NULL );
	dbg.StepOver(1, NULL, NULL, NULL, 0);
	if( WaitMsgBoxText("Break when '{recur_func}x'", 280) )
	{
		WriteLog( PASSED, "The MsgBox \"Break when '{recur_func}x'\" was found as expected" );
		// REVIEW(michma - 6/3/99): there is this weird problem on w2k where the data breakpoint hit msg box
		// isn't active right away. doesn't repro manually, only when performed through cafe.
		// so we need to reactivate the IDE for the OK button to become active so we can dismiss the dlg.
		UIWB.Activate();
		MST.WButtonClick( "OK" );
		while(MST.WButtonExists("OK"));
		EXPECT_TRUE_COMMENT( TRUE, "BreakOnExprChanged" );	 	
	}
	else
	{
		WriteLog( FAILED, "The MsgBox \"Break when '{recur_func}x'\" was not found" );
		EXPECT_TRUE( FALSE );	 	
	}
	EXPECT_TRUE( dbg.CurrentLineIs( "if (x<9) recur_func();" ) );
	EXPECT_TRUE( cxx.ExpressionValueIs("x==2",1) );
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	// TODO(michma): we need to do this extra step because of bug 38172.
	EXPECT_TRUE(dbg.StepInto());

	dbg.StopDebugging();
	return (TRUE);
}

BOOL Cexe_bpIDETest::StepBPLineSRC()
{
 	LogTestHeader( "StepBPLineSRC" );

 	LogTestHeader( "StepOver to BPLine: foo_Include" );
	UIWB.OpenFile( m_strProjectDir + "\\" + "testg.h");
	EXPECT_TRUE( src.Find("if(number == 3)") );
	EXPECT_TRUE( bps.SetBreakpoint() != NULL );
	UIBreakpoints bpd;
	bpd.Activate();
	EXPECT_TRUE_COMMENT ( bpd.BreakpointIsSet("26", "testg.h"), "BP is set at line 26 in testg.h" );
	bpd.Close();
	UIWB.OpenFile( m_strProjectDir + "\\" + "testgo.c");
	EXPECT_TRUE( src.Find("foo_Include(Int);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "foo_Include(Int);") );
	EXPECT_TRUE( dbg.StepInto(2, NULL, "number*=2;") );
	EXPECT_TRUE( dbg.StepOver(1, NULL, "if(number == 3)") );
	bpd.Activate();
	EXPECT_TRUE_COMMENT ( bpd.BreakpointIsSet("26", "testg.h"), "BP is set at line 26 in testg.h" );
	bpd.Close();
	EXPECT_TRUE(bps.ClearAllBreakpoints());

 	LogTestHeader( "StepOut to BPLine" );
	CString strLine = "146";
	CString strLocation = (CString)"{,testgo.c,}@" + strLine;
	EXPECT_TRUE( bps.SetBreakpoint(strLocation) != NULL );
	bpd.Activate();
	EXPECT_TRUE( bpd.BreakpointIsSet(strLine, "testgo.c") );
	bpd.Close();
	EXPECT_TRUE( dbg.StepOut(1, NULL, "foo_Include(Int);") );
	bpd.Activate();
	EXPECT_TRUE( bpd.BreakpointIsSet(strLine, "testgo.c") );
	bpd.Close();
	EXPECT_TRUE(bps.ClearAllBreakpoints());

 	LogTestHeader( "StepInto to BPLine: recur_func" );
	EXPECT_TRUE( src.Find("if (x<9) recur_func();") );
	EXPECT_TRUE( bps.SetBreakpoint() != NULL );
	bpd.Activate();
	EXPECT_TRUE_COMMENT ( bpd.BreakpointIsSet("56", "testgo.c"), "BP is set at line 56 in testgo.c" );
	bpd.Close();
	EXPECT_TRUE( dbg.StepOver(1, NULL, "Int=recur_func();") );
	EXPECT_TRUE( dbg.StepInto(3, NULL, "if (x<9) recur_func();") );
	strLine = "56";
	bpd.Activate();
	EXPECT_TRUE_COMMENT ( bpd.BreakpointIsSet(strLine, "testgo.c"), "BP is set at line 56 in testgo.c" );
	bpd.Close();
	EXPECT_TRUE(bps.ClearAllBreakpoints());

 	LogTestHeader( "StepToCursor to BPLine: TestG" );
	EXPECT_TRUE( src.Find("nest_func();") );
	EXPECT_TRUE( bps.SetBreakpoint() != NULL );
	bpd.Activate();
	EXPECT_TRUE_COMMENT ( bpd.BreakpointIsSet("150", "testgo.c"), "BP is set at line 150 in testgo.c" );
	bpd.Close();
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "nest_func();") );
	strLine = "150";
	bpd.Activate();
	EXPECT_TRUE ( bpd.BreakpointIsSet(strLine, "testgo.c") );
	bpd.Close();
	EXPECT_TRUE(bps.ClearAllBreakpoints());

	dbg.StopDebugging();
	return (TRUE);
}

BOOL Cexe_bpIDETest::StepBPLineDAM()
{
 	LogTestHeader( "StepBPLineDAM" );
	UIBreakpoints bpd;

 	LogTestHeader( "StepOver to BPLine" );
	UIWB.OpenFile( m_strProjectDir + "\\" + "testgo.c");
	EXPECT_TRUE( src.Find("foo_Include(Int);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "foo_Include(Int);") );
	EXPECT_TRUE( dbg.StepInto(2, NULL, "number*=2;") );
	dbg.SetSteppingMode(ASM);
	MST.DoKeys("{down 2}");
	EXPECT_TRUE( bps.SetBreakpoint() != NULL );
	bpd.Activate();
	EXPECT_TRUE ( bpd.BreakpointIsSet("0x") );
	bpd.Close();
	EXPECT_TRUE( dbg.StepOver(2) );
	bpd.Activate();
	EXPECT_TRUE ( bpd.BreakpointIsSet("0x") );
	bpd.Close();
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	EXPECT_TRUE( dbg.StepOut(1) );

 	LogTestHeader( "StepInto to BPLine" );
	dbg.SetSteppingMode(SRC);
	EXPECT_TRUE( src.Find("if (x<9) recur_func();") );
	EXPECT_TRUE( bps.SetBreakpoint() != NULL );
	bpd.Activate();
	EXPECT_TRUE_COMMENT ( bpd.BreakpointIsSet("56", "testgo.c"), "BP is set at line 56 in testgo.c" );
	bpd.Close();
	EXPECT_TRUE( dbg.StepOver(1, NULL, "Int=recur_func();") );
	EXPECT_TRUE( dbg.StepInto(2, NULL, "x++;") );
	dbg.SetSteppingMode(ASM);
	EXPECT_TRUE( dbg.StepInto(3) );
	CString strLine = "56";
	bpd.Activate();
	EXPECT_TRUE ( bpd.BreakpointIsSet(strLine, "testgo.c") );
	bpd.Close();
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	MST.DoKeys("{down}");
	EXPECT_TRUE( bps.SetBreakpoint() != NULL );
	bpd.Activate();
	EXPECT_TRUE ( bpd.BreakpointIsSet("0x") );
	bpd.Close();
	EXPECT_TRUE( dbg.StepInto(1) );
	bpd.Activate();
	EXPECT_TRUE ( bpd.BreakpointIsSet("0x") );
	bpd.Close();
	EXPECT_TRUE(bps.ClearAllBreakpoints());

 	LogTestHeader( "StepToCursor to BPLine" );
	dbg.SetSteppingMode(SRC);
	EXPECT_TRUE( src.Find("nest_func();") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "nest_func();") );
	dbg.SetSteppingMode(ASM);
	MST.DoKeys("{down 3}");
	EXPECT_TRUE( bps.SetBreakpoint() != NULL );
	bpd.Activate();
	EXPECT_TRUE ( bpd.BreakpointIsSet("0x") );
	bpd.Close();
	EXPECT_TRUE( dbg.StepToCursor(0) );
	bpd.Activate();
	EXPECT_TRUE ( bpd.BreakpointIsSet("0x") );
	bpd.Close();
	EXPECT_TRUE(bps.ClearAllBreakpoints());

	dbg.StopDebugging();
	return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\exe\exe_dlls.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	exe_dlls.CPP
//											 
//	Created by :			
//		VCBU QA		

#include "stdafx.h"
#include "exe_dlls.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
											   
IMPLEMENT_TEST(Cexe_dllsIDETest, CDbgTestBase, "Execution DLLs", -1, CexeSubSuite)
												 
void Cexe_dllsIDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

void Cexe_dllsIDETest::Run()
{	 
	XSAFETY;
	
	if (SetProject("dllapp\\incdll", PROJECT_DLL) && SetProject("dllapp\\powdll", PROJECT_DLL)
		&& SetProject("dllapp\\dec2", PROJECT_DLL) && SetProject("dllapp\\dllappx"))
	{
		XSAFETY;
//		StartDebugging();		// WinslowF
		bps.ClearAllBreakpoints();
			
		EXPECT_TRUE(DllStepTrace());
		XSAFETY;
		EXPECT_TRUE(DllStepOut());
		XSAFETY;
		EXPECT_TRUE(DllTraceOut());
		XSAFETY;
		EXPECT_TRUE(StepOverFuncInUnloadedDll());
		XSAFETY;
		EXPECT_TRUE(RestartFromWithinDll());
		XSAFETY;
		EXPECT_TRUE(GoFromWithinDll());
		XSAFETY;
	}
	//	StopDbgCloseProject();
	
}

///////////////////////////////////////////////////////////////////////////////
//	Test Cases

/*
** Stepping model test(s) involving DLL's.
** Step Loadlibrary and then trace into the virtual explicit dll.
**
*/ 

BOOL Cexe_dllsIDETest::DllStepTrace(   )
{
 	LogTestHeader( "DllStepTrace" );

	BOOL fSuccess;
	int count;

	/* 
	** test step/trace of LoadLibrary
	** (for portability reasons this needs to be isolated)
	*/
	dbg.Restart();
	bps.ClearAllBreakpoints();
	EXPECT_TRUE ( fSuccess = (bps.SetBreakpoint("{Dec,,dec2.dll}TagLoadLib") != NULL) );
	EXPECT_TRUE ( fSuccess &= dbg.Go("{Dec,,dec2.dll}TagLoadLib") );
	dbg.StepInto();  // step load library call which does a symbol load
	// REVIEW:  is there anything interesting to verify?
	EXPECT_TRUE( fSuccess &= (dbg.VerifyNotification("Loaded symbols", 3, 20, TRUE) && dbg.VerifyNotification("powdll.dll", 1, 20, TRUE)) );

	/* 
	** test tracing into function contained in a virtual dll. (for 
	** portability reasons this needs to be isolated)
	*/
	count=0;
	while ( (count<10) && (!dbg.AtSymbol("{Dec,,dec2.dll}TagCallPow")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE(fSuccess &= (dbg.AtSymbol("TagCallPow") && stk.CurrentFunctionIs("Dec")) );
	EXPECT_TRUE(fSuccess &= dbg.StepInto(1, NULL, NULL, "dPow"));

	dbg.StopDebugging();
	EXPECT_TRUE ( fSuccess &= dbg.Go("{Dec,,dec2.dll}TagLoadLib") );
	dbg.StepOver();  // step over load library call which does a symbol load
	EXPECT_TRUE( fSuccess &= (dbg.VerifyNotification("Loaded symbols", 3, 20, TRUE) && dbg.VerifyNotification("powdll.dll", 1, 20, TRUE)) );

	dbg.StopDebugging();
	EXPECT_TRUE(fSuccess &= (bps.SetBreakpoint("{Dec,,dec2.dll}TagCallPow") != NULL) );
	dbg.Go();
	EXPECT_TRUE ( fSuccess &= dbg.Go("{Dec,,dec2.dll}TagCallPow") );
	EXPECT_TRUE(fSuccess &= (bps.SetBreakpoint("dPow") != NULL));
	EXPECT_TRUE ( fSuccess &= dbg.StepOver(1, "dPow") );
	return fSuccess;	
}

BOOL Cexe_dllsIDETest::DllStepOut(   )
{
 	LogTestHeader( "DllStepOut" );
	BOOL fSuccess = TRUE;
	dbg.Restart();
	bps.ClearAllBreakpoints();
	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint("{Dec,,dec2.dll}Dec") != NULL ));
	EXPECT_TRUE ( fSuccess &= dbg.Go(NULL, NULL, "Dec") );
	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint("{Dec,,dec2.dll}@54") != NULL ));
	
	// StepOut of implibed DLL into DLL
	EXPECT_TRUE ( fSuccess &= dbg.Go(NULL, "Inc(wBar);") );
	EXPECT_TRUE ( fSuccess &= dbg.StepInto(1, NULL, NULL, "Inc") ); 
	EXPECT_TRUE_COMMENT ( fSuccess &= dbg.StepOut(1, NULL, NULL, "Dec"), "StepOut of implibed DLL into DLL (source mode)" ); 

	// StepOut of not implibed DLL into DLL
	int count=0;
	while ( (count<25) && (!dbg.AtSymbol("{Dec,,dec2.dll}TagCallPow")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE(fSuccess &= (dbg.AtSymbol("TagCallPow") && stk.CurrentFunctionIs("Dec")));
	EXPECT_TRUE(fSuccess &= dbg.StepInto(1, NULL, NULL, "dPow"));
	EXPECT_TRUE_COMMENT ( fSuccess &= dbg.StepOut(1, NULL, NULL, "Dec"), "StepOut of not implibed DLL into DLL (source mode)" ); 

	// StepOut of implibed DLL into EXE
	EXPECT_TRUE_COMMENT ( fSuccess &= dbg.StepOut(1, NULL, NULL, "MainWndProc"), "StepOut of implibed DLL into EXE (source mode)" ); 

	// ASM mode
	dbg.Restart();
	dbg.SetSteppingMode(ASM);
	EXPECT_TRUE ( fSuccess &= dbg.Go(NULL, NULL, "Dec") );

	// StepOut of implibed DLL into DLL
	EXPECT_TRUE_COMMENT ( fSuccess &= dbg.Go(NULL, NULL, "Dec"), "At line 54" );
	count=0;
	while ( (count<25) && (!stk.CurrentFunctionIs("Inc")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE ( fSuccess &= stk.CurrentFunctionIs("Inc") );
	EXPECT_TRUE ( fSuccess &= dbg.StepInto(3, NULL, NULL, "Inc") ); 
	EXPECT_TRUE_COMMENT ( fSuccess &= dbg.StepOut(1, NULL, NULL, "Dec"), "StepOut of implibed DLL into DLL (mixed mode)" ); 

	// StepOut of not implibed DLL into DLL
	EXPECT_TRUE(fSuccess &= (bps.SetBreakpoint("{Dec,,dec2.dll}TagCallPow") != NULL));
	dbg.Go();
	count=0;
	while ( (count<25) && (!stk.CurrentFunctionIs("dPow")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE ( fSuccess &= stk.CurrentFunctionIs("dPow") );
	EXPECT_TRUE ( fSuccess &= dbg.StepInto(2, NULL, NULL, "dPow") ); 
	EXPECT_TRUE_COMMENT ( fSuccess &= dbg.StepOut(1, NULL, NULL, "Dec"), "StepOut of not implibed DLL into DLL (mixed mode)" ); 

	// StepOut of implibed DLL into EXE
	EXPECT_TRUE_COMMENT ( fSuccess &= dbg.StepOut(1, NULL, NULL, "MainWndProc"), "StepOut of implibed DLL into EXE (mixed mode)" ); 

	dbg.StopDebugging();
	return fSuccess;	
}

BOOL Cexe_dllsIDETest::DllTraceOut(   )
{
 	LogTestHeader( "DllTraceOut" );
	BOOL fSuccess = TRUE;
	dbg.Restart();
	bps.ClearAllBreakpoints();
	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint("{Dec,,dec2.dll}Dec") != NULL ));
	EXPECT_TRUE ( fSuccess &= dbg.Go(NULL, NULL, "Dec") );
	
	// TraceOut of implibed DLL into DLL
	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint("{Dec,,dec2.dll}@54") != NULL ));
	EXPECT_TRUE ( fSuccess &= dbg.Go(NULL, "Inc(wBar);") );
	EXPECT_TRUE ( fSuccess &= dbg.StepInto(1, NULL, NULL, "Inc") ); 
	int count=0;
	while ( (count<25) && (!stk.CurrentFunctionIs("Dec")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE_COMMENT ( fSuccess &= stk.CurrentFunctionIs("Dec"), "TraceOut of implibed DLL into DLL" );

	// TraceOut of not implibed DLL into DLL
	count=0;
	while ( (count<25) && (!dbg.AtSymbol("{Dec,,dec2.dll}TagCallPow")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE(fSuccess &= (dbg.AtSymbol("TagCallPow") && stk.CurrentFunctionIs("Dec")));
	EXPECT_TRUE(fSuccess &= dbg.StepInto(1, NULL, NULL, "dPow"));
	count=0;
	while ( (count<25) && (!stk.CurrentFunctionIs("Dec")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE_COMMENT ( fSuccess &= stk.CurrentFunctionIs("Dec"), "TraceOut of not implibed DLL into DLL" );

	dbg.StopDebugging();
	return fSuccess;	
}

BOOL Cexe_dllsIDETest::GoFromWithinDll(   )
{
 	LogTestHeader( "GoFromWithinDll" );
	BOOL fSuccess = TRUE;
	dbg.Restart();
	bps.ClearAllBreakpoints();

	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint("{Dec,,dec2.dll}Dec") != NULL ));
	EXPECT_TRUE ( fSuccess &= dbg.Go(NULL, NULL, "Dec") );
	UIWB.OpenFile( m_strProjectDir + "\\" + "dllappx.c");
	EXPECT_TRUE( fSuccess &= src.Find("BPWithLengthTest();") );
	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint() != NULL ));
	EXPECT_TRUE( dbg.Go(NULL, "BPWithLengthTest();", "MainWndProc") );
	bps.ClearAllBreakpoints();
	dbg.Restart();

	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint("{Inc,,incdll.dll}Inc") != NULL ));
	EXPECT_TRUE ( fSuccess &= dbg.Go(NULL, NULL, "Inc") );
	UIWB.OpenFile( m_strProjectDir + "\\" + "dec2.c");
	EXPECT_TRUE( fSuccess &= src.Find("dValue = dpfnPow( 10, 3 );") );
	EXPECT_TRUE( fSuccess &= dbg.StepToCursor(0, NULL, "dValue = dpfnPow( 10, 3 );") );
	
	EXPECT_TRUE(fSuccess &= (dbg.AtSymbol("TagCallPow") && stk.CurrentFunctionIs("Dec")));
	EXPECT_TRUE(fSuccess &= dbg.StepInto(2, NULL, NULL, "dPow"));
	UIWB.OpenFile( m_strProjectDir + "\\" + "dllappx.c");
	EXPECT_TRUE( fSuccess &= src.Find("BPWithLengthTest();") );
	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint() != NULL ));
	EXPECT_TRUE( fSuccess &= dbg.Go(NULL, "BPWithLengthTest();", "MainWndProc") );

	dbg.StopDebugging();
	return fSuccess;	
}

BOOL Cexe_dllsIDETest::RestartFromWithinDll(   )
{
 	LogTestHeader( "RestartFromWithinDll" );
	BOOL fSuccess = TRUE;
	dbg.Restart();
	bps.ClearAllBreakpoints();

	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint("{Dec,,dec2.dll}Dec") != NULL ));
	EXPECT_TRUE ( fSuccess &= dbg.Go(NULL, NULL, "Dec") );
	EXPECT_TRUE( fSuccess &= dbg.Restart() );
	bps.ClearAllBreakpoints();

	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint("{Inc,,incdll.dll}Inc") != NULL ));
	EXPECT_TRUE ( fSuccess &= dbg.Go(NULL, NULL, "Inc") );
	EXPECT_TRUE( fSuccess &= dbg.Restart() );
	bps.ClearAllBreakpoints();
	
	UIWB.OpenFile( m_strProjectDir + "\\" + "dec2.c");
	EXPECT_TRUE( fSuccess &= src.Find("dValue = dpfnPow( 10, 3 );") );
	EXPECT_TRUE( fSuccess &= dbg.StepToCursor(0, NULL, "dValue = dpfnPow( 10, 3 );") );
	EXPECT_TRUE(fSuccess &= (dbg.AtSymbol("TagCallPow") && stk.CurrentFunctionIs("Dec")));
	EXPECT_TRUE(fSuccess &= dbg.StepInto(2, NULL, NULL, "dPow"));
	EXPECT_TRUE( fSuccess &= dbg.Restart() );

	dbg.StopDebugging();
	return fSuccess;	
}

BOOL Cexe_dllsIDETest::StepOverFuncInUnloadedDll(   )
{
 	LogTestHeader( "StepOverFuncInUnloadedDll" );
	BOOL fSuccess = TRUE;
	dbg.Restart();
	bps.ClearAllBreakpoints();

	UIWB.OpenFile( m_strProjectDir + "\\" + "dllappx.c");
	EXPECT_TRUE( fSuccess &= src.Find("Dec( &wValue );") );
	EXPECT_TRUE( fSuccess &= dbg.StepToCursor(0, NULL, "Dec( &wValue );", "MainWndProc") );
	EXPECT_TRUE(fSuccess &= dbg.StepOver(1, NULL, NULL, "MainWndProc"));
	EXPECT_TRUE( fSuccess &= (dbg.VerifyNotification("Loaded symbols", 3, 20, TRUE) && dbg.VerifyNotification("powdll.dll", 1, 20, TRUE)) );

	dbg.StopDebugging();
	return fSuccess;	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\mem\mem2.cpp ===
/*
** MEM.CPP
**
**	Created by :			Date :
**		waltcr				2/2/94
**
**	Description :
**		memory tests
*/

#include "stdafx.h"
#include "memcase.h"

/*
** start debugging and do some initialization.  
*/

///////////////////////////////////////////////////////////////////////////////
//	Test Cases
							
/* 
** The memory window address and format is set in StartDebugging.
** Execute to location after value of Global is known.  
** Verify the memory window correlty displays the bytes.
**
*/

BOOL CmemIDETest::MemExpectBytes(   )
{	
	bps.ClearAllBreakpoints();
	dbg.StepInto();
	uimem = UIDebug::ShowDockWindow(IDW_MEMORY_WIN);
	uimem.GoToAddress("Global");
	dbg.Restart();
	bps.SetBreakOnExpr("{foo}END","Global==3",COBP_TYPE_IF_EXP_TRUE);
	EXPECT_TRUE(dbg.Go("END",NULL, "foo"));
	uimem = UIDebug::ShowDockWindow(IDW_MEMORY_WIN);
	uimem.GoToAddress("Global");  
	CString Bytes = uimem.GetCurrentData(4);
	EXPECT_TRUE(Bytes == "03 00 00 00 ");

	// TODO: not fully implemented, always return true for now. 
	return TRUE;
}


#if 0
// TODO
BOOL CMemCases::ReadWriteMemory(   )
{

//	DESC("Read and Write Memory Window Test", "Memory");


	/* 
	** prepare and perform read memory test
	*/

	
	// set memory address ealier in the debug session, now confirm
	// first confirm at correct address

	
	/* 
	** prepare and perform write memory test
	*/

	// now write to the address and verify it takes

}
#endif


BOOL CmemIDETest::MemoryFormats(   )
{
	int m;
	BOOL fOkay = TRUE;

	UIMemory uimem = UIDebug::ShowDockWindow(IDW_MEMORY_WIN);
	for (m=1;m<=14;m++ )
		fOkay &= UIWB.SetMemoryFormat((MEM_FORMAT)m);

	if (fOkay)
		WriteLog(PASSED, "Memory Format Cycle");
	else
		WriteLog(FAILED, "Memory Format Cycle");

	return fOkay;  // REVIEW
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\exe\step3.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STEP3.CPP
//
//	Created by :			Date :
//		YefimS			01/06/94
//
//	Description :
//		Implementation of the CST1TestCases class
//

#include <process.h>
#include "stdafx.h"
#include "execase2.h"

///////////////////////////////////////////////////////////////////////////////
//	Test Cases
///////////////////////////////////////////////////////////////////////////////


BOOL Cexe2IDETest::StepToCursorMixed(   )
{
 	LogTestHeader( "StepToCursorMixed" );

	CString strSource = "bp__ldld.c";

	// Open source
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource);

	EXPECT_TRUE( src.Find("c10[counter]  = (char)counter;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "c10[counter]  = (char)counter;") );
	dbg.SetSteppingMode(ASM);
	CString strLine = "c10[counter]  = (char)counter;";
	MST.DoKeys("{up}");

	EXPECT_TRUE_COMMENT( dbg.CurrentLineIs( strLine ), "DAM: expected line 'c10[counter]  = (char)counter;' " );

	MST.DoKeys("{down 3}");
	dbg.StepToCursor();
	if( UIWB.GetPcodeSwitch() )
		strLine = "LdfL8";
	else
		strLine = "move.b";

    EXPECT_TRUE( dbg.CurrentLineIs( strLine ) );

	return (TRUE);
}


BOOL Cexe2IDETest::StepOutMixed(   )
{
 	LogTestHeader( "StepOutMixed" );

	CString strSource = "bp__ldld.c";

	// Open source
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource);

	EXPECT_TRUE( src.Find("c10[counter]  = (char)counter;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "c10[counter]  = (char)counter;") );

	dbg.SetSteppingMode(ASM);
	CString strLine = "c10[counter]  = (char)counter;";
	MST.DoKeys("{up}");
    EXPECT_TRUE( dbg.CurrentLineIs( strLine ) );

	MST.DoKeys("{down 3}");
	dbg.StepToCursor();

	if( UIWB.GetPcodeSwitch() )
		strLine = "LdfL8";
	else
		strLine = "move.b";

    EXPECT_TRUE( dbg.CurrentLineIs( strLine ) );

	dbg.StepOut();
  	EXPECT_TRUE( stk.CurrentFunctionIs( "TestBP()" ) );

	if( UIWB.GetPcodeSwitch() )
		strLine = "Call";
	else
		strLine = "jsr"; 
	MST.DoKeys("{up}");

    EXPECT_TRUE( dbg.CurrentLineIs( strLine ) );

	strLine = "ld = CFncLDLD(ld);"; 
	MST.DoKeys("{up}");
	MST.DoKeys("{up}");
	if( !UIWB.GetPcodeSwitch() )
	{
		MST.DoKeys("{up}");
		MST.DoKeys("{up}");
		MST.DoKeys("{up}");
	}

    EXPECT_TRUE( dbg.CurrentLineIs( strLine ) );
	return (TRUE);
}



BOOL Cexe2IDETest::StepOverMixed(   )
{
 	LogTestHeader( "StepOverMixed" );

	CString strSource = "testbp.c";
	CString strLine;

	// Open source
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource);

	dbg.StepOver();
	dbg.SetSteppingMode(ASM);

	if( UIWB.GetPcodeSwitch() )
		strLine = "Call";
	else
		strLine = "jsr"; 

	EXPECT_TRUE( dbg.StepOver(1, NULL, strLine) );

	dbg.StepOver();
	MST.DoKeys("{up}");
    EXPECT_TRUE( dbg.CurrentLineIs( strLine ) );
	return (TRUE);
}



BOOL Cexe2IDETest::StepIntoMixed(   )
{
 	LogTestHeader( "StepIntoMixed" );
	COSource		src;	// WinslowF - added to call GoToLine. It's not in UIWB any more.

	CString strSource = "testbp.c";

    dbg.Restart();
	dbg.SetSteppingMode(SRC);
	CString strLine = "{";
	if( UIWB.GetPcodeSwitch() )
		strLine = "int iBP = TestBP();";
    EXPECT_TRUE( dbg.CurrentLineIs( strLine ) );

	// Open source
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource);
	EXPECT_TRUE( src.Find("f = CFncFF(f);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "f = CFncFF(f);") );
	dbg.SetSteppingMode(ASM);

	if( UIWB.GetPcodeSwitch() )
		strLine = "Call";
	else
		strLine = "jsr"; 

	EXPECT_TRUE( dbg.StepInto(1, NULL, strLine, "TestBP()") );

	dbg.StepInto(3);
  	EXPECT_TRUE( stk.CurrentFunctionIs( "CFncSSRecurse" ) );

	MST.DoKeys("{up}");
	if( UIWB.GetPcodeSwitch() )
		strLine = "Cuc = (uchar)NTimes;";
	else
		strLine = "{"; 

    EXPECT_TRUE( dbg.CurrentLineIs( strLine ) );

	if( UIWB.GetPcodeSwitch() )
		MST.DoKeys("{up 5}");
	
	strLine = "CFncSSRecurse(short NTimes)"; 
	MST.DoKeys("{up}");
    EXPECT_TRUE( dbg.CurrentLineIs( strLine ) );

	EXPECT(dbg.StopDebugging());
	return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\exe\gocases2.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	GoCases2.cpp
//
//	Created by :			Date :
//		YefimS			11/21/93
//
//	Description :
//		Implementation of Go cases
//

#include <process.h>
#include "stdafx.h"
#include "execase2.h"

///////////////////////////////////////////////////////////////////////////////
//	Test Cases
///////////////////////////////////////////////////////////////////////////////

BOOL Cexe2IDETest::GoExeDoesNotExist( )
{
 	LogTestHeader( "GoExeDoesNotExist" );
	m_pLog->RecordInfo( "Try to execute nonexisting PCTarget, correct the path and GO" );

	char* szTARGET_EXT = ".exe";
	char* szREMOTE_TARGET_EXT = "";

	CString stOldTarget = m_strProjectName + szTARGET_EXT ;
	CString stAbsPathTarget =  m_strProjectDir + "\\" + m_strProjectName + szTARGET_EXT ;
	CString stNewTarget = m_strProjectDir + "\\kit\\" + m_strProjectName + szTARGET_EXT;
	CString stBadTarget = m_strProjectDir + "\\..\\" + m_strProjectName + szTARGET_EXT ;

	// Rename the target and run
	CopyFile(stAbsPathTarget, m_strProjectDir + "\\foo" + szTARGET_EXT, FALSE);
	DeleteFile(stAbsPathTarget);
	EXPECT_TRUE(dbg.Go(NULL,NULL,NULL,0) );

	if( WaitMsgBoxText("does not exist", 10) )
	{
		WriteLog( PASSED, "01 : The MsgBox \"... does not exist...\" was found as expected" );
		MST.WButtonClick( "OK" ); // MST.WButtonClick( "No" );
	}
	else
	{
		if( WaitMsgBoxText("not found", 10) )
		{
			WriteLog( PASSED, "01 : The MsgBox \"...File not found\" was found as expected" );
			MST.WButtonClick( "OK" );
		}
		else
		{
			WriteLog( FAILED, "01 : The MsgBox \"...File not found\" was not found" );
			WriteLog( FAILED, "01 : The MsgBox \"... does not exist...\" was not found" );
			EXPECT_TRUE( FALSE );	 	
		}
	}
	
	// Set incorrect path\target 
	EXPECT_TRUE(proj.SetLocalTarget(stBadTarget) == ERROR_SUCCESS);
	EXPECT_TRUE(dbg.Go(NULL,NULL,NULL,0));

	if( WaitMsgBoxText("or do not exist", 10)) 
	{
		WriteLog( PASSED, "The MsgBox \"One or more targets are out of date...\" was found" );
		MST.WButtonClick( "No" );
	}

/*	EXPECT_TRUE( WaitMsgBoxText("not be opened", 10));
	EXPECT_TRUE( WaitMsgBoxText("not exist", 10));
	MST.WButtonClick( "OK" );
*/
 	if( WaitMsgBoxText("does not exist", 10) )
	{
		WriteLog( PASSED, "01 : The MsgBox \"... does not exist...\" was found as expected" );
		MST.WButtonClick( "OK" ); // MST.WButtonClick( "No" );
	}
	else
	{
		if( WaitMsgBoxText("not found", 10) )
		{
			WriteLog( PASSED, "01 : The MsgBox \"...File not found\" was found as expected" );
			MST.WButtonClick( "OK" );
		}
		else
		{
			WriteLog( FAILED, "01 : The MsgBox \"...File not found\" was not found" );
			WriteLog( FAILED, "01 : The MsgBox \"... does not exist...\" was not found" );
			EXPECT_TRUE( FALSE );	 	
		}
	}

	// Set correct new path\target and run
	CreateDirectory(m_strProjectDir + "\\kit", 0);          
	CopyFile(m_strProjectDir + "\\foo" + szTARGET_EXT, stNewTarget, FALSE);
	EXPECT(proj.SetLocalTarget(stNewTarget) == ERROR_SUCCESS );
	EXPECT_TRUE(dbg.Go(NULL,NULL,NULL,0) );

	if( WaitMsgBoxText("or do not exist", 10))
	{
		WriteLog( PASSED, "01 : The MsgBox \"One or more targets are out of date...\" was found as expected" );
		MST.WButtonClick( "No" );
		while(MST.WFndWndC("or do not exist", "Static", FW_PART));
	}

	// REVIEW (michma): why does UIWB.WaitForRun() never return?
	//UIWB.WaitForRun();
	// Sleep(10000);
	CString TitleRun = (CString)"[" + GetLocString(IDSS_DBG_RUN) + "]";
	MST.WFndWndWait(TitleRun, FW_PART, 10);
	
	UIWB.WaitForTermination();

/*	EXPECT_TRUE( VerifyProjectRan() );
*/
	// Remove temporary file and dir
	DeleteFile(stNewTarget);
	RemoveDirectory(m_strProjectDir + "\\kit");         

	// Set correct AbsPath\target 
	EXPECT( proj.SetLocalTarget(stAbsPathTarget) == ERROR_SUCCESS );

	// Exe is still out of place
	EXPECT_TRUE(dbg.Go(NULL,NULL,NULL,0) );
	if( WaitMsgBoxText("does not exist", 10) )
	{
		WriteLog( PASSED, "The MsgBox \"... does not exist...\" was found as expected" );
		MST.WButtonClick( "OK" ); // MST.WButtonClick( "No" );
	}
	else
	{
		if( WaitMsgBoxText("not found", 10) )
		{
			WriteLog( PASSED, "The MsgBox \"...File not found\" was found as expected" );
			MST.WButtonClick( "OK" );
		}
		else
		{
			WriteLog( FAILED, "The MsgBox \"...File not found\" was not found" );
			WriteLog( FAILED, "The MsgBox \"... does not exist...\" was not found" );
			EXPECT_TRUE( FALSE );	 	
		}
	}

	// Exe is back in place
	CopyFile(m_strProjectDir + "\\foo" + szTARGET_EXT, stAbsPathTarget, FALSE);
	DeleteFile(m_strProjectDir + "\\foo" + szTARGET_EXT);
	Sleep(1000);
	EXPECT_TRUE( dbg.Go(NULL, NULL, NULL, WAIT_FOR_TERMINATION) );

	// Restore initial target
	EXPECT_TRUE( proj.SetLocalTarget(stOldTarget) == ERROR_SUCCESS );

	// Verify restoration is OK
	EXPECT_TRUE( dbg.Go(NULL, NULL, NULL, WAIT_FOR_TERMINATION) );

	return (TRUE);
}

BOOL Cexe2IDETest::CheckGeneralNetworkFailure( )
{
	if( WaitMsgBoxText("General Network Failure", 10) )
	{
		MST.DoKeys( KEY_Enter );
		return (FALSE);      
	}
	else
	{
		return (TRUE);      
	}
}


BOOL Cexe2IDETest::ExitWhileDebugging( )
{
 	LogTestHeader( "ExitWhileDebugging" );

	m_pLog->RecordInfo( "Restart, Exit IDE and verify: ExitWhileDebugging" );
	dbg.Restart();
	dbg.SetSteppingMode(SRC);  //Temporary workaround: bug #15556
	CString strLine = "{";

	if( UIWB.GetPcodeSwitch() )
		strLine = "int iGo = TestG();";

    EXPECT_TRUE( dbg.CurrentLineIs( strLine ) );
	UIWB.DoCommand(ID_APP_EXIT, DC_MNEMONIC);
	
	if( WaitMsgBoxText("command will stop the debugger", 10) )
	{
		WriteLog( PASSED, "01 : The MsgBox \"command will stop the debugger\" was found as expected" );
		MST.WButtonClick( "Cancel" );
	}
	else
	{
		WriteLog( FAILED, "01 : The MsgBox \"command will stop the debugger\" was not found as expected" );
		EXPECT_TRUE( FALSE );	 	
	}
 
	UIWB.DoCommand(ID_APP_EXIT, DC_MNEMONIC);

	if( WaitMsgBoxText("command will stop the debugger", 10) )
	{
		WriteLog( PASSED, "02 : The MsgBox \"command will stop the debugger\" was found as expected" );
		MST.WButtonClick( "OK" );
	}
	else
	{
		WriteLog( FAILED, "02 : The MsgBox \"command will stop the debugger\" was not found as expected" );
		EXPECT_TRUE( FALSE );	 	
	}

	if( WaitMsgBoxText("want to save", 10) )
	{
		MST.WButtonClick( "No" );
	}

	while(GetSubSuite()->GetIDE()->IsLaunched());

	// REVIEW(briancr): use RTTI for this cast, or at least to validate it
	GetSubSuite()->GetIDE()->Launch();
	WriteLog( PASSED, "03 : The IDE was closed and reopened as expected" );
	return (TRUE);
}


BOOL Cexe2IDETest::CannotFindDll( )
{
 	LogTestHeader( "CannotFindDll" );
	m_pLog->RecordInfo( "Try to start debugging exe which cannot find associated Dll, correct the path and debug" );

	// Verify we can start debugging
	dbg.Restart();
	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "WinMain") );
	dbg.StopDebugging();

	// Rename dec2.dll to dec22.dll and start debugging
	CopyFile(m_strProjectDir + "\\dec2.dll", m_strProjectDir + "\\dec22.dll", FALSE);
	DeleteFile(m_strProjectDir + "\\dec2.dll");
	EXPECT_TRUE(dbg.StepInto(1,NULL,NULL,NULL,0) );

	if( WaitMsgBoxText("not found", 10) )
	{
		WriteLog( PASSED, "01 : The MsgBox \"...not found...\" was found" );
		MST.WButtonClick( "OK" ); 
	}
	else
	{
		if( WaitMsgBoxText("Could not execute", 10) )
		{
			WriteLog( PASSED, "01 : The MsgBox \"Could not execute...\" was found as expected" );
			MST.DoKeys( KEY_Enter );
			if( WaitMsgBoxText("Cannot execute", 10) )
			{
				WriteLog( PASSED, "01 : The MsgBox \"Cannot execute...\" was found as expected" );
				MST.DoKeys( KEY_Enter );
			}
		}
		else
		{
			WriteLog( FAILED, "The MsgBox \"...not found\" was not found" );
			WriteLog( FAILED, "The MsgBox \"Could not execute...\" was not found" );
			EXPECT_TRUE( FALSE );	 	
		}
	}
	
	if( WaitMsgBoxText("not found", 10) )
	{
		WriteLog( PASSED, "01 : The MsgBox \"...not found...\" was found" );
		MST.WButtonClick( "OK" ); 
	}
	else
	{
		if( WaitMsgBoxText("Could not execute", 10) )
		{
			WriteLog( PASSED, "01 : The MsgBox \"Could not execute...\" was found as expected" );
			MST.DoKeys( KEY_Enter );
			if( WaitMsgBoxText("Cannot execute", 10) )
			{
				WriteLog( PASSED, "01 : The MsgBox \"Cannot execute...\" was found as expected" );
				MST.DoKeys( KEY_Enter );
			}
		}
		else
		{
			WriteLog( FAILED, "The MsgBox \"...not found\" was not found" );
			WriteLog( FAILED, "The MsgBox \"Could not execute...\" was not found" );
			EXPECT_TRUE( FALSE );	 	
		}
	}
	
/*	
	if( WaitMsgBoxText("Could not execute", 10) )
	{
		WriteLog( PASSED, "01 : The MsgBox \"Could not execute...\" was found as expected" );
		MST.DoKeys( KEY_Enter );
	}
	else
	{
		WriteLog( FAILED, "01 : The MsgBox \"Could not execute...\" was not found" );
		EXPECT_TRUE( FALSE );	 	
	}
*/	
	// Restore initial Dll
	CopyFile(m_strProjectDir + "\\dec22.dll", m_strProjectDir + "\\dec2.dll", FALSE);
	DeleteFile(m_strProjectDir + "\\dec22.dll");
	EXPECT_TRUE( dbg.StepInto(1, NULL, "{", "WinMain") );
	dbg.StopDebugging();

	return (TRUE);
}

BOOL Cexe2IDETest::StdInOutRedirection()
{
 	LogTestHeader( "StdInOutRedirection" );
	m_pLog->RecordInfo( "Redirect Std Input and Output to files and debug console app" );

	// Redirect std input from file cons01.inp and check values
	CString progargs = "< cons01.inp";
	EXPECT_TRUE( proj.SetProgramArguments(progargs) == ERROR_SUCCESS );

	UIWB.OpenFile( m_strProjectDir + "\\" + "cons01.cpp");
	EXPECT_TRUE( src.Find("cin >> Char;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "cin >> Char;") );
	dbg.StepOver(1, NULL, NULL, NULL, 0);
	EXPECT_TRUE( cxx.ExpressionValueIs("Char=='a'",1) );

	dbg.StepOver(1, NULL, NULL, NULL, 0);
	EXPECT_TRUE( cxx.ExpressionValueIs("Array1d[1]",888) );

	EXPECT_TRUE( src.Find("cin >> String;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "cin >> String;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("Array2d[0][2]",7) );

	dbg.StepOver(1, NULL, NULL, NULL, 0);
	CString stringValue = "ADDRESS \"!ZYXWVUTSRQPONMLKJIHGFEDCBA\"";
	EXPECT_TRUE( cxx.ExpressionValueIs("String",stringValue) );

	dbg.StopDebugging();

	// Redirect std output into file cons01.out
	progargs = "> cons01.out";
	EXPECT_TRUE( proj.SetProgramArguments(progargs) == ERROR_SUCCESS );

	DeleteFile(m_strProjectDir + "\\cons01.out");
	UIWB.OpenFile( m_strProjectDir + "\\" + "cons01.cpp");
	EXPECT_TRUE( src.Find("cout << Char;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "cout << Char;") );
	EXPECT_TRUE( dbg.StepOver(1, NULL, "cout << Array1d[0] << Array1d[1] << Array1d[2] ;") );
	EXPECT_TRUE( src.Find("cin >> Char;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "cin >> Char;") );

	dbg.StopDebugging();

	// Redirect both std input (cons01.inp) and output (cons01.out)
	// and check values and output
	DeleteFile(m_strProjectDir + "\\cons01.out");
	progargs = "< cons01.inp > cons01.out";
	EXPECT_TRUE( proj.SetProgramArguments(progargs) == ERROR_SUCCESS );

	UIWB.OpenFile( m_strProjectDir + "\\" + "cons01.cpp");
	EXPECT_TRUE( src.Find("cin >> Char;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "cin >> Char;") );
	dbg.StepOver(1, NULL, NULL, NULL, 0);
	EXPECT_TRUE( cxx.ExpressionValueIs("Char=='a'",1) );

	dbg.StepOver(1, NULL, NULL, NULL, 0);
	EXPECT_TRUE( cxx.ExpressionValueIs("Array1d[1]",888) );

	EXPECT_TRUE( src.Find("cin >> String;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "cin >> String;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("Array2d[0][2]",7) );

	dbg.StepOver(1, NULL, NULL, NULL, 0);
	EXPECT_TRUE( cxx.ExpressionValueIs("String",stringValue) );

	EXPECT_TRUE( dbg.Go(NULL, NULL, NULL, WAIT_FOR_TERMINATION) );
	UIWB.OpenFile( m_strProjectDir + "\\" + "cons01.out");
	EXPECT_TRUE( src.Find("s111222333112233445566778899this is a string") );

	return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\exe\stepcase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STEPCASE.CPP
//
//	Created by :			Date :
//		YefimS			01/06/94
//
//	Description :
//		Implementation of the CST1TestCases class
//

#include <process.h>
#include "stdafx.h"
#include "execase.h"
#include "execase2.h"

///////////////////////////////////////////////////////////////////////////////
//	Test Cases
///////////////////////////////////////////////////////////////////////////////

BOOL CexeIDETest::StepOutSource(   )
{
 	LogTestHeader( "StepOutSource" );

	COSource		src;	// WinslowF - added to call GoToLine. It's not in UIWB any more.

	bps.ClearAllBreakpoints();
    dbg.Restart();
	if( UIWB.GetPcodeSwitch() )
	{
		EXPECT_TRUE( dbg.CurrentLineIs( "int iBP = TestBP();" ) );
	}
	else
		EXPECT_TRUE( dbg.CurrentLineIs( "{" ) );

	CString strSource = "bp__ulul.c";

	// Open source
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource);

	EXPECT_TRUE( src.Find("ul = (ulong)counter;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "ul = (ulong)counter;") );

	EXPECT_TRUE( dbg.StepOut(1, NULL, "ul = CFncULUL(ul);", "TestBP()") );

	return (TRUE);
}


BOOL CexeIDETest::StepOverSource(   )
{
 	LogTestHeader( "StepOverSource" );

    EXPECT_TRUE( dbg.Go(NULL,NULL,NULL,WAIT_FOR_TERMINATION) );

	CString strSource = "testbp.c";
	bps.ClearAllBreakpoints();

	// Open source
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource);

	EXPECT_TRUE( src.Find("ul = CFncULUL(ul);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "ul = CFncULUL(ul);") );

	EXPECT_TRUE( dbg.StepOver(1, NULL, "f = CFncFF(f);") );

	return (TRUE);
}


BOOL CexeIDETest::StepIntoSource(   )
{
 	LogTestHeader( "StepIntoSource" );

	bps.ClearAllBreakpoints();
    dbg.Restart();

	if( !UIWB.GetPcodeSwitch() )
	{
	    EXPECT_TRUE( dbg.CurrentLineIs( "{" ) );
		EXPECT_TRUE( dbg.StepInto() );
	}

    EXPECT_TRUE( dbg.CurrentLineIs( "int iBP = TestBP();" ) );

	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "TestBP()") );

	MST.DoKeys("{up}");
    EXPECT_TRUE( dbg.CurrentLineIs( "int TestBP()" ) );

	EXPECT_TRUE( src.Find("s = CFncSSRecurse(10);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "s = CFncSSRecurse(10);") );

	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "CFncSSRecurse") );

	MST.DoKeys("{up}");
    EXPECT_TRUE( dbg.CurrentLineIs( "CFncSSRecurse(short NTimes)" ) );

	EXPECT_TRUE( src.Find("NTimes = (short)CFncSSRecurse((short)(NTimes-1));") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "NTimes = (short)CFncSSRecurse((short)(NTimes-1));") );

	EXPECT_TRUE( dbg.StepInto(1, NULL, NULL, "CFncSSRecurse") );
	EXPECT_TRUE( stk.FunctionIs("CFncSSRecurse",1) );

	MST.DoKeys("{up}");
    EXPECT_TRUE( dbg.CurrentLineIs( "CFncSSRecurse(short NTimes)" ) );

	dbg.StopDebugging();

	return (TRUE);
}

BOOL CexeIDETest::StepToCursorSource(   )
{
 	LogTestHeader( "StepToCursorSource" );

	CString strSource = "bp__ldld.c";
	bps.ClearAllBreakpoints();

	// Open source
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource);

	EXPECT_TRUE( src.Find("ul = (ulong)counter;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "ul = (ulong)counter;") );

	EXPECT_TRUE( src.Find("d  = (double)counter;") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "d  = (double)counter;") );
	dbg.StopDebugging();
	return (TRUE);
}

BOOL CexeIDETest::StepOverFuncToBreakAtLocBP()
{
 	LogTestHeader( "StepOverFuncToBreakAtLocBP" );
	bps.ClearAllBreakpoints();

	UIWB.OpenFile( m_strProjectDir + "\\" + "testgo.c");

	EXPECT_TRUE( src.Find("Int=foo(Local);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "Int=foo(Local);") );
	EXPECT_TRUE( src.Find("return Parameter;") );
	EXPECT_TRUE( bps.SetBreakpoint() != NULL );
	EXPECT_TRUE( dbg.StepOver(1, NULL, "return Parameter;") );

	EXPECT_TRUE( src.Find("nest_func();") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "nest_func();") );
	EXPECT_TRUE( bps.SetBreakpoint("func") != NULL );
//	EXPECT_TRUE( dbg.StepOver(1, NULL, "int func() {") );
	EXPECT_TRUE( dbg.StepOver(1, NULL, NULL, "func") );

	dbg.StopDebugging();
	return (TRUE);
}

BOOL CexeIDETest::StepOverFuncToBreakOnExprTrueBP()
{
 	LogTestHeader( "StepOverFuncToBreakOnExprTrueBP" );
	bps.ClearAllBreakpoints();

	UIWB.OpenFile( m_strProjectDir + "\\" + "testgo.c");

	EXPECT_TRUE( src.Find("Int = foo_Include(Int);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "Int = foo_Include(Int);") );
	EXPECT_TRUE( bps.SetBreakOnExpr("{foo_Include}number==34", COBP_TYPE_IF_EXP_TRUE) != NULL );
	dbg.StepOver(1, NULL, NULL, NULL, 0);
	if( WaitMsgBoxText("Break when '{foo_Include}number==34'", 280) )
	{
		WriteLog( PASSED, "The MsgBox \"Break when '{foo_Include}number==34'\" was found as expected" );
		MST.WButtonClick( "OK" ); 
		EXPECT_TRUE_COMMENT( TRUE, "BreakOnExprTrue" );	 	
	}
	else
	{
		WriteLog( FAILED, "The MsgBox \"Break when '{foo_Include}number==34'\" was not found" );
		EXPECT_TRUE( FALSE );	 	
	}
	EXPECT_TRUE( dbg.CurrentLineIs( "if(number == 3)" ) );
	EXPECT_TRUE( cxx.ExpressionValueIs("number == 34",1) );

	UIWB.OpenFile( m_strProjectDir + "\\" + "testgo.c");
	EXPECT_TRUE( src.Find("Int=recur_func();") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "Int=recur_func();") );
	EXPECT_TRUE( bps.SetBreakOnExpr("{recur_func}x==2", COBP_TYPE_IF_EXP_TRUE) != NULL );
	dbg.StepOver(1, NULL, NULL, NULL, 0);
	if( WaitMsgBoxText("Break when '{recur_func}x==2'", 280) )
	{
		WriteLog( PASSED, "The MsgBox \"Break when '{recur_func}x==2'\" was found as expected" );
		MST.WButtonClick( "OK" ); 
		EXPECT_TRUE_COMMENT( TRUE, "BreakOnExprTrue" );	 	
	}
	else
	{
		WriteLog( FAILED, "The MsgBox \"Break when '{recur_func}x==2'\" was not found" );
		EXPECT_TRUE( FALSE );	 	
	}
	EXPECT_TRUE( dbg.CurrentLineIs( "if (x<9) recur_func();" ) );
	EXPECT_TRUE( cxx.ExpressionValueIs("x==2",1) );

	dbg.StopDebugging();
	return (TRUE);
}

BOOL CexeIDETest::StepOverFuncToBreakOnExprChangesBP()
{
 	LogTestHeader( "StepOverFuncToBreakOnExprChangesBP" );
	bps.ClearAllBreakpoints();

	UIWB.OpenFile( m_strProjectDir + "\\" + "testgo.c");
	EXPECT_TRUE( src.Find("Int=recur_func();") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "Int=recur_func();") );
	EXPECT_TRUE( bps.SetBreakOnExpr("{recur_func}x", COBP_TYPE_IF_EXP_CHANGED) != NULL );
	dbg.StepOver(1, NULL, NULL, NULL, 0);
	if( WaitMsgBoxText("Break when '{recur_func}x'", 280) )
	{
		WriteLog( PASSED, "The MsgBox \"Break when '{recur_func}x'\" was found as expected" );
		MST.WButtonClick( "OK" ); 
		EXPECT_TRUE_COMMENT( TRUE, "BreakOnExprChanged" );	 	
	}
	else
	{
		WriteLog( FAILED, "The MsgBox \"Break when '{recur_func}x'\" was not found" );
		EXPECT_TRUE( FALSE );	 	
	}
	EXPECT_TRUE( dbg.CurrentLineIs( "if (x<9) recur_func();" ) );
	EXPECT_TRUE( cxx.ExpressionValueIs("x==2",1) );

	dbg.StopDebugging();
	return (TRUE);
}

BOOL CexeIDETest::TraceIntoWndProc()
{
 	LogTestHeader( "TraceIntoWndProc" );
	bps.ClearAllBreakpoints();

	UIWB.OpenFile( m_strProjectDir + "\\" + "main2.c");
	EXPECT_TRUE( src.Find("SendMessage(") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "SendMessage(") );
//	EXPECT_TRUE( dbg.StepInto(1, NULL, "{", "WndProc") );
	EXPECT_TRUE( dbg.StepInto(1, NULL, "{") );
	EXPECT_TRUE( stk.CurrentFunctionIs("WndProc")	);
	EXPECT_TRUE( dbg.StepInto(1, NULL, "SAVELABEL(TagCallOtherMain);", "WndProc") );

	dbg.StopDebugging();
	return (TRUE);
}

BOOL Cexe2IDETest::NoSystemCodeStepping()
{
 	LogTestHeader( "NoSystemCodeStepping" );
	bps.ClearAllBreakpoints();
	BOOL ret = TRUE;

	UIWB.OpenFile( m_strProjectDir + "\\" + "main2.c");
	EXPECT_TRUE( src.Find("SAVELABEL(TagCreateCase);") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "SAVELABEL(TagCreateCase);", "WndProc") );
	EXPECT_TRUE( dbg.StepOut(1, NULL, NULL, NULL, 0) );

//	if( WaitMsgBoxText("Cannot step through system code", 280) )
	if( WaitMsgBoxText("Can't trace into system DLLs", 280) )
	{
		WriteLog( PASSED, "The MsgBox \"Can't trace into system DLLs\" was found as expected" );
		MST.WButtonClick( "OK" ); 
	}
	else
	{
		WriteLog( FAILED, "The MsgBox \"Can't trace into system DLLs\" was not found" );
		ret = FALSE;	 	
	}
	dbg.StopDebugging();
	return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\exe\step2.cpp ===
/*
** STEP.CPP
**
**	Created by :			Date :
**		waltcr				8/14/94
**
**	Description :
**		Step/trace/go tests
*/


#include "stdafx.h"
#include "execase.h"
#include "execase2.h"

#if defined(_MIPS_) || defined(_ALPHA_)
#define _CHAIN_2 "chain_2"
#define _CHAIN_3 "chain_3"
#else
#define _CHAIN_2 "_chain_2"
#define _CHAIN_3 "_chain_3"
#endif

///////////////////////////////////////////////////////////////////////////////
//	Test Cases

/*
** A number of tests lumped together.  Some involve different level of debug
** information or without debug information.  Also a test or two
** involving step/stepout and breakpoints which are important enough
** to have in the stepping model tests.
** 
*/

BOOL CexeIDETest::BreakStepTrace(   )
{ 	
 	LogTestHeader( "BreakStepTrace" );

 	/*
	** test Step_Out of func which fires a bp in a nested func in secondary module.
	** test to Step_Out of func with debug info into func w/out debug info	
	** also test to Step_Out of func w/out debug info into func w/ partial info
	** also test to Step_Out of func w/partial debug info into func w/full info
	** also test to Step_Out of func with debug info into func w/debug info
	**
	** ChainMain is expected to be compiled with full debug information
	** chain_1 is expected to be compiled with full debug information
	** chain_2 is expected to be compiled with partial debug information
	** chain_3 is expected to be compiled without debug information
	** chain_4 is expected to be compiled with full debug information
	*/

	bp *bp;
	BOOL fSuccess;
	
	bps.ClearAllBreakpoints();
	dbg.StopDebugging();
	bp=bps.SetBreakpoint("WndProc");
	dbg.Go();  								// execute to function WndProc 
	EXPECT_TRUE ( dbg.VerifyAtSymbol("WndProc") );
	dbg.SetSteppingMode(SRC);
	// Step past prolog
	dbg.StepOver(); 						
	bps.ClearAllBreakpoints();
	// set breakpoint on label
	bp = bps.SetBreakpoint("TagCallChainMain"); 	
	// execute to bp at label
	dbg.Go();  								
	EXPECT_TRUE ( dbg.AtSymbol("{WndProc}TagCallChainMain") );
	EXPECT_TRUE ( dbg.StepInto(1,"ChainMain") );

	/* 
	** test tracing out of static function.
	** test Step_Out of func which fires a bp in a nested func in 
	** secondary module.
	*/

	EXPECT_TRUE ( bps.SetBreakpoint("chain_4") != NULL );
	EXPECT_TRUE ( bps.SetBreakpoint("chain_5") != NULL );
	dbg.Go();
	EXPECT_TRUE ( dbg.AtSymbol("chain_4") );

	// attempt to step out but fire on breakpoint in nested function call
	// proper location is chain_5
	fSuccess = dbg.StepOut(1, NULL, NULL, "chain_5"); 
	WriteLog( fSuccess ? PASSED : FAILED, "StepOut and fire on breakpoint in nested function");
	if (!fSuccess)
		return fSuccess;			
	
	dbg.StepInto();
	EXPECT_TRUE ( fSuccess &= dbg.StepOut(1, NULL, NULL, "chain_4") );

	// window already open, but it would be interesting to close and confirm 
	// dam is opened and gets focus, but that would be using whitebox testing 
	// which is considered voodoo.
	// should go back to chain_3, but wait till after next test to verify
	EXPECT_TRUE ( fSuccess &= dbg.StepOut(1, NULL, NULL, "chain_3") );

	// Proper location is w/in func chain_2
	fSuccess = dbg.StepOut(1, NULL, NULL, "chain_2");  
	WriteLog( fSuccess ? PASSED : FAILED, "StepOut from full to none and then none to partial cvinfo");
	if (!fSuccess)
		return fSuccess;	
	// proper location is w/in func chain_1
	fSuccess = dbg.StepOut(1, NULL, NULL, "chain_1");  
	WriteLog( fSuccess ? PASSED : FAILED, "StepOut from partial cvinfo to full cvinfo");
	if (!fSuccess)
		return fSuccess;	
	// proper location is chainmain
	fSuccess = dbg.StepOut(1, NULL, NULL, "ChainMain"); 
	WriteLog( fSuccess ? PASSED : FAILED, "StepOut from full cvinfo to full cvinfo");
	if (!fSuccess)
		return fSuccess;	
	
	// attempt to step over function but which generates an exception.
	
	bps.SetBreakpoint("{OtherMain}TagStepEH");
	dbg.Go();
	dbg.StepOver();
#if defined( _MIPS_ ) || defined(_ALPHA_)
	EXPECT_TRUE(stk.CurrentFunctionIs("NTDLL!"));
#else
	EXPECT_TRUE(stk.CurrentFunctionIs("KERNEL32!"));
#endif
	dbg.StepOut();
	dbg.StepOut();
	//TODO: where should we be?

	return TRUE;	
}									


/*
** A number of tests lumped together.  Some involve step/trace/stepout
** with different level of debug information or without debug 
** information.  
** 
*/

BOOL CexeIDETest::StepModel(   )
{
 	LogTestHeader( "StepModel" );

	int count;
	BOOL fOkay;

	/*
	** test Step_Out of func with debug info into func w/out debug info	
	** also test to Step_Out of func w/out debug info into func w/ partial info
	** also test to Step_Out of func w/partial debug info into func w/full info
	** also test to Step_Out of func with debug info into func w/debug info
	**
	** ChainMain is expected to be compiled with full debug information
	** chain_1 is expected to be compiled with full debug information
	** chain_2 is expected to be compiled with partial debug information
	** chain_3 is expected to be compiled without debug information
	** chain_4 is expected to be compiled with full debug information
	*/

	dbg.Restart();

	/* 
	** test tracing into function with partial debug information.
	*/
 
	bps.SetBreakpoint("{chain_1}START");
	dbg.Go();
	dbg.AtSymbol("START");
	fOkay = dbg.StepInto(1,NULL, NULL, "chain_2");
	WriteLog( fOkay ? PASSED : FAILED, "Trace from full cvinfo into module w/only partial cvinfo");
	if (!fOkay)
		return fOkay;	
 
	/* 
	** test tracing out of function w/out cvinfo into func w/ partial.
	** ; test instruction level tracing
	*/

	EXPECT_TRUE ( bps.SetBreakpoint(_CHAIN_3) != NULL );
	EXPECT_TRUE ( dbg.Go(NULL, NULL, "chain_3") );
	EXPECT_TRUE ( dbg.StepInto(2, NULL, NULL, "chain_3") );
	EXPECT_TRUE ( bps.DisableAllBreakpoints() );

	count=0;
	while ( (count<25) && (stk.GetFunction().Find("chain_3") != -1))
	{
		count++;
		dbg.StepOver();   // step over chain_4 ...
	} 
	fOkay = stk.CurrentFunctionIs("chain_2");
	WriteLog( fOkay ? PASSED : FAILED, "instruction level tracing from no cvinfo to partial cvinfo");
	if (!fOkay)
		return fOkay;	

	dbg.SetSteppingMode(SRC);

 	/* 
	** test tracing into function w/out cvinfo
	*/

	bps.ClearAllBreakpoints();
	EXPECT_TRUE ( bps.SetBreakpoint("{WndProc}TagCallNoCVInfo") != NULL );

	dbg.Go();   // will hit the throw
	dbg.Go(); 	// go again to get to the breakpoint
	dbg.AtSymbol("TagCallNoCVInfo");
	dbg.SetSteppingMode(SRC);

	// attempt to trace into func, but func doesn't have cvinfo so 
	// trace should actually stepover
	fOkay = dbg.StepInto(1, NULL, NULL, "WndProc");
	WriteLog(fOkay ? PASSED : FAILED, "Source level trace of func call w/out cvinfo");
	if (!fOkay)
		return FALSE;	
	// CAFE REVIEW: the stepinto and check of wndproc is not returning 
	// focus to src window.  should it?  For now next line sets it back.
	dbg.SetSteppingMode(SRC);
	src.Find("TagCallNoCVInfo:", TRUE);
	if (dbg.SetNextStatement(NULL) == FALSE)
	{
		m_pLog->RecordFailure("Unable to Set_Next_Statement");
		return FALSE;	
	}
	if (dbg.SetSteppingMode(ASM) == FALSE)
	{
		m_pLog->RecordFailure("Unable to set stepping mode to ASM");
		return FALSE;	// ( FALSE, GetTestDesc() );
	}

	// don't know exactly how many instructions so allow a few traces 
	count=0;
	do 
	{
		count++;
		dbg.StepInto();
	} while( (count<17) && (!dbg.AtSymbol(_CHAIN_3)) );
	EXPECT_TRUE ( dbg.AtSymbol(_CHAIN_3) );
	// now only have dissassembly.  keep tracing until get back to mixed.
	do 
	{
		dbg.StepInto();
	} while (!dbg.AtSymbol("chain_4"));
	fOkay = dbg.AtSymbol("chain_4");
	WriteLog(fOkay ? PASSED : FAILED, "Instruction level trace from no cvinfo to full cvinfo");
	
	dbg.SetSteppingMode(SRC);
	bps.ClearAllBreakpoints();
	return TRUE;	
}


/*
** Stepping model test(s) involving DLL's.
** Step Loadlibrary and then trace into the virtual explicit dll.
**
*/ 

BOOL Cexe2IDETest::DllStepTrace(   )
{
 	LogTestHeader( "DllStepTrace" );

	BOOL fSuccess;
	int count;

	/* 
	** test step/trace of LoadLibrary
	** (for portability reasons this needs to be isolated)
	*/
	dbg.Restart();
	bps.ClearAllBreakpoints();
	EXPECT_TRUE ( fSuccess = (bps.SetBreakpoint("{Dec,,dec2.dll}TagLoadLib") != NULL) );
	EXPECT_TRUE ( fSuccess &= dbg.Go("{Dec,,dec2.dll}TagLoadLib") );
	dbg.StepInto();  // step load library call which does a symbol load
	// REVIEW:  is there anything interesting to verify?
	EXPECT_TRUE( fSuccess &= (dbg.VerifyNotification("Loaded symbols", 3, 20, TRUE) && dbg.VerifyNotification("powdll.dll", 3, 20, TRUE)) );

	/* 
	** test tracing into function contained in a virtual dll. (for 
	** portability reasons this needs to be isolated)
	*/
	count=0;
	while ( (count<10) && (!dbg.AtSymbol("{Dec,,dec2.dll}TagCallPow")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE(fSuccess &= (dbg.AtSymbol("TagCallPow") && stk.CurrentFunctionIs("Dec")) );
	EXPECT_TRUE(fSuccess &= dbg.StepInto(1, NULL, NULL, "dPow"));

	dbg.StopDebugging();
	EXPECT_TRUE ( fSuccess &= dbg.Go("{Dec,,dec2.dll}TagLoadLib") );
	dbg.StepOver();  // step over load library call which does a symbol load
	EXPECT_TRUE( fSuccess &= (dbg.VerifyNotification("Loaded symbols", 3, 20, TRUE) && dbg.VerifyNotification("powdll.dll", 3, 20, TRUE)) );

	dbg.StopDebugging();
	EXPECT_TRUE(fSuccess &= (bps.SetBreakpoint("{Dec,,dec2.dll}TagCallPow") != NULL) );
	dbg.Go();
	EXPECT_TRUE ( fSuccess &= dbg.Go("{Dec,,dec2.dll}TagCallPow") );
	EXPECT_TRUE(fSuccess &= (bps.SetBreakpoint("dPow") != NULL));
	EXPECT_TRUE ( fSuccess &= dbg.StepOver(1, "dPow") );
	return fSuccess;	
}

BOOL Cexe2IDETest::DllStepOut(   )
{
 	LogTestHeader( "DllStepOut" );
	BOOL fSuccess = TRUE;
	dbg.Restart();
	bps.ClearAllBreakpoints();
	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint("{Dec,,dec2.dll}Dec") != NULL ));
	EXPECT_TRUE ( fSuccess &= dbg.Go(NULL, NULL, "Dec") );
	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint("{Dec,,dec2.dll}@54") != NULL ));
	
	// StepOut of implibed DLL into DLL
	EXPECT_TRUE ( fSuccess &= dbg.Go(NULL, "Inc(wBar);") );
	EXPECT_TRUE ( fSuccess &= dbg.StepInto(1, NULL, NULL, "Inc") ); 
	EXPECT_TRUE_COMMENT ( fSuccess &= dbg.StepOut(1, NULL, NULL, "Dec"), "StepOut of implibed DLL into DLL (source mode)" ); 

	// StepOut of not implibed DLL into DLL
	int count=0;
	while ( (count<25) && (!dbg.AtSymbol("{Dec,,dec2.dll}TagCallPow")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE(fSuccess &= (dbg.AtSymbol("TagCallPow") && stk.CurrentFunctionIs("Dec")));
	EXPECT_TRUE(fSuccess &= dbg.StepInto(1, NULL, NULL, "dPow"));
	EXPECT_TRUE_COMMENT ( fSuccess &= dbg.StepOut(1, NULL, NULL, "Dec"), "StepOut of not implibed DLL into DLL (source mode)" ); 

	// StepOut of implibed DLL into EXE
	EXPECT_TRUE_COMMENT ( fSuccess &= dbg.StepOut(1, NULL, NULL, "MainWndProc"), "StepOut of implibed DLL into EXE (source mode)" ); 

	// ASM mode
	dbg.Restart();
	dbg.SetSteppingMode(ASM);
	EXPECT_TRUE ( fSuccess &= dbg.Go(NULL, NULL, "Dec") );

	// StepOut of implibed DLL into DLL
	EXPECT_TRUE_COMMENT ( fSuccess &= dbg.Go(NULL, NULL, "Dec"), "At line 54" );
	count=0;
	while ( (count<25) && (!stk.CurrentFunctionIs("Inc")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE ( fSuccess &= stk.CurrentFunctionIs("Inc") );
	EXPECT_TRUE ( fSuccess &= dbg.StepInto(3, NULL, NULL, "Inc") ); 
	EXPECT_TRUE_COMMENT ( fSuccess &= dbg.StepOut(1, NULL, NULL, "Dec"), "StepOut of implibed DLL into DLL (mixed mode)" ); 

	// StepOut of not implibed DLL into DLL
	EXPECT_TRUE(fSuccess &= (bps.SetBreakpoint("{Dec,,dec2.dll}TagCallPow") != NULL));
	dbg.Go();
	count=0;
	while ( (count<25) && (!stk.CurrentFunctionIs("dPow")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE ( fSuccess &= stk.CurrentFunctionIs("dPow") );
	EXPECT_TRUE ( fSuccess &= dbg.StepInto(2, NULL, NULL, "dPow") ); 
	EXPECT_TRUE_COMMENT ( fSuccess &= dbg.StepOut(1, NULL, NULL, "Dec"), "StepOut of not implibed DLL into DLL (mixed mode)" ); 

	// StepOut of implibed DLL into EXE
	EXPECT_TRUE_COMMENT ( fSuccess &= dbg.StepOut(1, NULL, NULL, "MainWndProc"), "StepOut of implibed DLL into EXE (mixed mode)" ); 

	dbg.StopDebugging();
	return fSuccess;	
}

BOOL Cexe2IDETest::DllTraceOut(   )
{
 	LogTestHeader( "DllTraceOut" );
	BOOL fSuccess = TRUE;
	dbg.Restart();
	bps.ClearAllBreakpoints();
	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint("{Dec,,dec2.dll}Dec") != NULL ));
	EXPECT_TRUE ( fSuccess &= dbg.Go(NULL, NULL, "Dec") );
	
	// TraceOut of implibed DLL into DLL
	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint("{Dec,,dec2.dll}@54") != NULL ));
	EXPECT_TRUE ( fSuccess &= dbg.Go(NULL, "Inc(wBar);") );
	EXPECT_TRUE ( fSuccess &= dbg.StepInto(1, NULL, NULL, "Inc") ); 
	int count=0;
	while ( (count<25) && (!stk.CurrentFunctionIs("Dec")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE_COMMENT ( fSuccess &= stk.CurrentFunctionIs("Dec"), "TraceOut of implibed DLL into DLL" );

	// TraceOut of not implibed DLL into DLL
	count=0;
	while ( (count<25) && (!dbg.AtSymbol("{Dec,,dec2.dll}TagCallPow")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE(fSuccess &= (dbg.AtSymbol("TagCallPow") && stk.CurrentFunctionIs("Dec")));
	EXPECT_TRUE(fSuccess &= dbg.StepInto(1, NULL, NULL, "dPow"));
	count=0;
	while ( (count<25) && (!stk.CurrentFunctionIs("Dec")))
	{
		count++;
		dbg.StepInto();
		Sleep(100);
	} 
	EXPECT_TRUE_COMMENT ( fSuccess &= stk.CurrentFunctionIs("Dec"), "TraceOut of not implibed DLL into DLL" );

	dbg.StopDebugging();
	return fSuccess;	
}

BOOL Cexe2IDETest::GoFromWithinDll(   )
{
 	LogTestHeader( "GoFromWithinDll" );
	BOOL fSuccess = TRUE;
	dbg.Restart();
	bps.ClearAllBreakpoints();

	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint("{Dec,,dec2.dll}Dec") != NULL ));
	EXPECT_TRUE ( fSuccess &= dbg.Go(NULL, NULL, "Dec") );
	UIWB.OpenFile( m_strProjectDir + "\\" + "dllappx.c");
	EXPECT_TRUE( fSuccess &= src.Find("BPWithLengthTest();") );
	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint() != NULL ));
	EXPECT_TRUE( dbg.Go(NULL, "BPWithLengthTest();", "MainWndProc") );
	bps.ClearAllBreakpoints();
	dbg.Restart();

	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint("{Inc,,incdll.dll}Inc") != NULL ));
	EXPECT_TRUE ( fSuccess &= dbg.Go(NULL, NULL, "Inc") );
	UIWB.OpenFile( m_strProjectDir + "\\" + "dec2.c");
	EXPECT_TRUE( fSuccess &= src.Find("dValue = dpfnPow( 10, 3 );") );
	EXPECT_TRUE( fSuccess &= dbg.StepToCursor(0, NULL, "dValue = dpfnPow( 10, 3 );") );
	
	EXPECT_TRUE(fSuccess &= (dbg.AtSymbol("TagCallPow") && stk.CurrentFunctionIs("Dec")));
	EXPECT_TRUE(fSuccess &= dbg.StepInto(2, NULL, NULL, "dPow"));
	UIWB.OpenFile( m_strProjectDir + "\\" + "dllappx.c");
	EXPECT_TRUE( fSuccess &= src.Find("BPWithLengthTest();") );
	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint() != NULL ));
	EXPECT_TRUE( fSuccess &= dbg.Go(NULL, "BPWithLengthTest();", "MainWndProc") );

	dbg.StopDebugging();
	return fSuccess;	
}

BOOL Cexe2IDETest::RestartFromWithinDll(   )
{
 	LogTestHeader( "RestartFromWithinDll" );
	BOOL fSuccess = TRUE;
	dbg.Restart();
	bps.ClearAllBreakpoints();

	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint("{Dec,,dec2.dll}Dec") != NULL ));
	EXPECT_TRUE ( fSuccess &= dbg.Go(NULL, NULL, "Dec") );
	EXPECT_TRUE( fSuccess &= dbg.Restart() );
	bps.ClearAllBreakpoints();

	EXPECT_TRUE ( fSuccess &= (bps.SetBreakpoint("{Inc,,incdll.dll}Inc") != NULL ));
	EXPECT_TRUE ( fSuccess &= dbg.Go(NULL, NULL, "Inc") );
	EXPECT_TRUE( fSuccess &= dbg.Restart() );
	bps.ClearAllBreakpoints();
	
	UIWB.OpenFile( m_strProjectDir + "\\" + "dec2.c");
	EXPECT_TRUE( fSuccess &= src.Find("dValue = dpfnPow( 10, 3 );") );
	EXPECT_TRUE( fSuccess &= dbg.StepToCursor(0, NULL, "dValue = dpfnPow( 10, 3 );") );
	EXPECT_TRUE(fSuccess &= (dbg.AtSymbol("TagCallPow") && stk.CurrentFunctionIs("Dec")));
	EXPECT_TRUE(fSuccess &= dbg.StepInto(2, NULL, NULL, "dPow"));
	EXPECT_TRUE( fSuccess &= dbg.Restart() );

	dbg.StopDebugging();
	return fSuccess;	
}

BOOL Cexe2IDETest::StepOverFuncInUnloadedDll(   )
{
 	LogTestHeader( "StepOverFuncInUnloadedDll" );
	BOOL fSuccess = TRUE;
	dbg.Restart();
	bps.ClearAllBreakpoints();

	UIWB.OpenFile( m_strProjectDir + "\\" + "dllappx.c");
	EXPECT_TRUE( fSuccess &= src.Find("Dec( &wValue );") );
	EXPECT_TRUE( fSuccess &= dbg.StepToCursor(0, NULL, "Dec( &wValue );", "MainWndProc") );
	EXPECT_TRUE(fSuccess &= dbg.StepOver(1, NULL, NULL, "MainWndProc"));
	EXPECT_TRUE( fSuccess &= (dbg.VerifyNotification("Loaded symbols", 3, 20, TRUE) && dbg.VerifyNotification("powdll.dll", 3, 20, TRUE)) );

	dbg.StopDebugging();
	return fSuccess;	
}

// TODO ?

/* 
** attempt to step over function but which fires on a conditional bp.
*/


/* 
** test tracing constructor.
*/


/* 
** test tracing into function contained in a secondary module.
*/


/* 
** test tracing into function contained in a virtual c++ function.
*/


/* 
** test tracing into function through indirect call.
*/


/* 
** perform test Step_Out of main/winmain.  (is this really a core test?
*/


/* 
** test to Step_Out of func w/partial info into func w/out debug info
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\mem\memsub.h ===
///////////////////////////////////////////////////////////////////////////////
//	memsub.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CmemSubSuite class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CmemSubSuite class

class CmemSubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CmemSubSuite)
//	CmemSubSuite() { m_strName = "TestWizard Generated script"; m_strOwner = "VCBU QA"; }


	DECLARE_TESTLIST()
protected:
	void CleanUp(void);
	void SetUp(BOOL bCleanUp);
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\mem\memsub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CmemSubSuite class
//

#include "stdafx.h"
#include "memsub.h"
#include "afxdllx.h"
#include "..\..\DbgTestBase.h"

#include "memcase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;


/////////////////////////////////////////////////////////////////////////////
// CmemSubSuite

IMPLEMENT_SUBSUITE(CmemSubSuite, CIDESubSuite, "Memory Window", "VCQA Debugger")

BEGIN_TESTLIST(CmemSubSuite)
	TEST(CmemIDETest, RUN)
END_TESTLIST()

void CmemSubSuite::CleanUp(void)
	{
	::CleanUp("testgo01");
	::CleanUp("dbg");
	}

void CmemSubSuite::SetUp(BOOL bCleanUp)
{
	CIDESubSuite::SetUp(bCleanUp);
	// TODO(michma - 9/2/98): re-enable when memory leak bugs are fixed.
	ExpectedMemLeaks(-1);
}
///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\mem\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\mem\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"
//#include "..\src\support\dbg\cowatch.h"
//#include "..\src\support\dbg\coauto.h"



#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\namespce\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\namespce\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\mem\memcase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	memcase.CPP
//											 
//	Created by :			
//		DKLEM
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "memcase.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
											   
//#define VERIFY_TEST_SUCCESS(TestCase)\
//	TestCase == ERROR_SUCCESS

//IMPLEMENT_TEST(999, CmemIDETest, CDbgTestBase, "Memory", -1, CmemSubSuite)
IMPLEMENT_TEST(CmemIDETest, CDbgTestBase, "Memory", -1, CmemSubSuite)
//IMPLEMENT_TEST(CmemIDETest, CDebugTestSet, "Memory", -1, CmemSubSuite)


// Information about a test to be put in the test header
#define LOGTESTHEADER(strTestName) 	m_strLogInfo.Format("# - %d.  %s. Total # - %d, Passed - %d %%", ++m_TestNumber, strTestName, m_TotalNumberOfTests, (m_TestNumber*100)/m_TotalNumberOfTests);  \
									LogTestHeader(m_strLogInfo);


// Globals that are used in the Memory Tests
	char			chJustChar; 
	char			sJustString [20]; 
	unsigned char	uchJustUnsignedChar;
	short int		nsJustShort;
	unsigned short	unsJustUnsignedShort;
	int				nJustInt;
	unsigned int	unJustUnsignedInt;
	long int		lJustLongInt;
	unsigned long	ulJustUnsignedLongInt;	
	float			fJustFloat;
	double			dJustDouble;
	long double		dlJustLongDouble;
	__int64			sfJustSixtyFourInt;
	unsigned __int64 sfJustSixtyFourUnsignedInt;

	// Arrays for the Column test
	const int number_of_columns_to_be_tested = 3;

	char			asJustString [number_of_columns_to_be_tested + 2] = "Mamb";
	char			asLongString[8*number_of_columns_to_be_tested + 2] = "Mamba-Tumba-Rumba-Shurum";
	short int		ansJustShort[number_of_columns_to_be_tested + 1] = { -123, 12, -34, 45};
	unsigned short	aunsJustUnsignedShort[number_of_columns_to_be_tested + 1] = { 22987, 126, 334, 645};
	int				anJustInt[number_of_columns_to_be_tested + 1] = { -65555, 112, -354, 4451};
	unsigned int	aunJustUnsignedInt[number_of_columns_to_be_tested + 1] = { 655551, 2112, 9834, 45008};
	long int		alJustLongInt[number_of_columns_to_be_tested + 1] = { -77777, 120087, 3477, 99045};
	unsigned long	aulJustUnsignedLongInt[number_of_columns_to_be_tested + 1]  = { 999999, 77712, 36544, 22245};
	float			afJustFloat[number_of_columns_to_be_tested + 1] = { (float) 123.14, (float) 23.16, (float) 60.70, (float) 2.93};
	double			adJustDouble[number_of_columns_to_be_tested + 1] = { -777e50,  77e22,  12e5,  54e10};
	long double		adlJustLongDouble[number_of_columns_to_be_tested + 1] = { -999e70, 89e3,  18e2,  -4e17};
	__int64			asfJustSixtyFourInt[number_of_columns_to_be_tested + 1] = { -1234567890987654909, 1, -2, -3 };
	unsigned __int64 asfJustSixtyFourUnsignedInt[number_of_columns_to_be_tested + 1] = { 9876543212345678123, 12, 45, 1};

void CmemIDETest::InitializeGlobalsThatAreUsedInTheMemoryTests(void)
{
	chJustChar = 'M'; 
	strcpy(sJustString, "Mamba-hara-mambu-ru"); /* 19 chars in the string */
	uchJustUnsignedChar = 'u';
	nsJustShort = -123;
	unsJustUnsignedShort = 22987;
	nJustInt = -65555;
	unJustUnsignedInt = 655551;
	lJustLongInt = -77777;
	ulJustUnsignedLongInt  = 999999;	
	fJustFloat = (float) 123.14;
	dJustDouble = -777e50;
	dlJustLongDouble = -999e70;
	sfJustSixtyFourInt = -1234567890987654909;
	sfJustSixtyFourUnsignedInt = 9876543212345678123;
}


// each function that runs a test has this prototype.
typedef void (CmemIDETest::*PTR_TEST_FUNC)(void); 

// we randomly pick out of the following list of tests and run them.
// insert functions for new tests to the end of the list.

PTR_TEST_FUNC tests[] = {
	&CmemIDETest::GoToSymbol,	
	&CmemIDETest::EditInWatchVerifyInMemoryWindow,
	&CmemIDETest::VerifyEditAllFormats,
// TODO: (dklem 08/12/98) Uncomment the following 1 line when #4360 and #7452 and #7594 gets fixed. Fixed in 8307.0
// There is no Columns option in 60
//*	&CmemIDETest::VerifyColumns,
	&CmemIDETest::ReEvaluateExpression,
	&CmemIDETest::GoToOverloadedSymbol,
	&CmemIDETest::RestoringMWTroughtDebuggingSessions,
	&CmemIDETest::GoToMaxMinAddress,
	&CmemIDETest::GoToInvalidAddress,
// TODO: (dklem 08/12/98) Uncomment the following 1 line when #5190 gets fixed
	&CmemIDETest::EditEIP,
// TODO: (dklem 08/12/98) Uncomment the following 2 lines when #4360 and #7452 and #7594 gets fixed. Fixed in 8307.0
	&CmemIDETest::NavigatingPointer,
	&CmemIDETest::ContextMenuOnToolBar,
// TODO: (dklem 08/12/98) Uncomment the following 1 line when #5454 gets fixed. Fixed in 8239.4
	&CmemIDETest::VerifyMultipleUndoRedo,
//////////////////////////////////////////////////////////////////
// TODO: (dklem 08/12/98) Uncomment the following 1 line when #4360 and #7452 and #7594 gets fixed. Fixed in 8307.0
//*	&CmemIDETest::CycleThroughMemoryFormats,
// TODO: (dklem 08/12/98) Uncomment the following 1 line when #5555 and #7456 get fixed. Fixed in 8307.0
// TODO: (dklem 11/10/98) Uncomment the following 1 line when #9430 is fixed.
//*	&CmemIDETest::PgUpDownCtrlHomeEnd,
	// emmang@xbox - I believe VerifyEditing is a bad test, doesnt work on Win32 either
	// &CmemIDETest::VerifyEditing,

	//	added by dverma
	&CmemIDETest::VerifyVCPPReg
};


void CmemIDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();

}

void CmemIDETest::Run()
{

	/******************
	 * INITIALIZATION *
	 ******************/

	if (!CreateXboxProjectFromSource("mem", "src\\mem",
				"mem.cpp"))
			return;

	// all tests expect the ide to be in this initial state.
	EXPECT_TRUE(dbg.StepOver());

	EXPECT_TRUE(mem.Enable());

	// In the tests it is assumed that the initial memory window has Docking View turned on
	EXPECT_TRUE(uimem.EnableDockingView(TRUE));


	m_TestNumber = 0;
	m_TotalNumberOfTests = sizeof(tests) / sizeof(PTR_TEST_FUNC);
	
	// we only want to randomly run each test once.
	RandomNumberCheckList rncl(sizeof(tests) / sizeof(PTR_TEST_FUNC));
	// indexes into the test function array.
	int iTest;
	
	// randomly run each test once.
	while((iTest = rncl.GetNext()) != -1)
	//for(iTest = 0; iTest < sizeof(tests) / sizeof(PTR_TEST_FUNC); iTest++)
		(this->*(tests[iTest]))();

	VerifyDockingView();
	dbg.StopDebugging(ASSUME_NORMAL_TERMINATION) ;	

}


void CmemIDETest::GoToSymbol(void)
{
	LOGTESTHEADER("GoToSymbol");
	CString address;

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.ShowNextStatement()); // emmang@xbox - hack to move focus to editor and away from mem, else src.Find() dails
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	InitializeGlobalsThatAreUsedInTheMemoryTests();

	EXPECT_TRUE(mem.MemoryDataIs("nJustInt", nJustInt));
	// Get current address (which is addres for nJustInt)
	EXPECT_TRUE(ee.GetExpressionValue("&nJustInt", address));
	// Change the address and check that it contains correct data
	EXPECT_TRUE(mem.MemoryDataIs("dJustDouble", dJustDouble));
	uimem.EnableToolBar(FALSE);
	EXPECT_TRUE(mem.MemoryDataIs(address, nJustInt));	

	EXPECT_TRUE(dbg.ToggleHexDisplay(TRUE));

	// Toggle Hex mode and do the previous tests to verify that hex mode doesn't affect them
	
	EXPECT_TRUE(mem.MemoryDataIs("nJustInt", nJustInt));
	// Get current address (which is addres for nJustInt)
	EXPECT_TRUE(ee.GetExpressionValue("&nJustInt", address));
	// Change the address and check that it contains correct data
	EXPECT_TRUE(mem.MemoryDataIs("dJustDouble", dJustDouble));
	uimem.EnableToolBar(TRUE);
	EXPECT_TRUE(mem.MemoryDataIs(address, nJustInt));	

	// Toggle Hex mode back
	EXPECT_TRUE(dbg.ToggleHexDisplay(FALSE));

	// Resize and Move
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(mem.Disable());

}

void CmemIDETest::VerifyEditAllFormats(void)
{

	LOGTESTHEADER("VerifyEditAllFormats");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.ShowNextStatement()); // emmang@xbox - hack to move focus to editor and away from mem, else src.Find() dails
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	InitializeGlobalsThatAreUsedInTheMemoryTests();

/*
	MEM_FORMAT_WCHAR Memory Format is not tested here.
*/

	//Try all types using the same schema
	// 1. Check data
	// 2. Update data in memory window
	// 3. Check data in memory and via expression

	EXPECT_TRUE(mem.MemoryDataIs("chJustChar", chJustChar));	
	chJustChar += 2;
	EXPECT_TRUE(mem.SetMemoryData("chJustChar", chJustChar, MEM_FORMAT_ASCII));	
	EXPECT_TRUE(mem.MemoryDataIs("chJustChar", chJustChar));	
	EXPECT_TRUE(cxx.ExpressionValueIs("chJustChar", chJustChar));	

	EXPECT_TRUE(mem.MemoryDataIs("uchJustUnsignedChar", uchJustUnsignedChar));	
	uchJustUnsignedChar += 2;
	EXPECT_TRUE(mem.SetMemoryData("uchJustUnsignedChar", uchJustUnsignedChar, MEM_FORMAT_ASCII));	
	EXPECT_TRUE(mem.MemoryDataIs("uchJustUnsignedChar", uchJustUnsignedChar));	
	EXPECT_TRUE(cxx.ExpressionValueIs("uchJustUnsignedChar", uchJustUnsignedChar));	

	// Check the Byte Memory Format
	EXPECT_TRUE(mem.SetMemoryData("uchJustUnsignedChar", "65", MEM_FORMAT_BYTE));
	uchJustUnsignedChar = 'e';  // Correspondes to 0x65
	EXPECT_TRUE(mem.MemoryDataIs("uchJustUnsignedChar", uchJustUnsignedChar));	


	EXPECT_TRUE(mem.MemoryDataIs("sJustString", sJustString, MEM_FORMAT_ASCII, strlen(sJustString)));	
	strcpy(sJustString, _strrev(sJustString));
	EXPECT_TRUE(mem.SetMemoryData("sJustString", sJustString, MEM_FORMAT_ASCII));	
	EXPECT_TRUE(mem.MemoryDataIs("sJustString", sJustString));	
	CString csExpectedString("ADDRESS ");
	csExpectedString = csExpectedString + "\"" + sJustString + "\"";
	EXPECT_TRUE(cxx.ExpressionValueIs("sJustString", csExpectedString));
	// Since there are too many crashes after editing we want to resize after editing each format
	// TODO: (dklem 11/04/98) Uncomment the following line when #8915 is fixed. 
	MinimalTestResizeMoveWindow();
	

	EXPECT_TRUE(mem.MemoryDataIs("nsJustShort", nsJustShort));	
	nsJustShort *= 2;
// TODO: (dklem 08/12/98) Uncomment the following 3 lines when #4734 gets fixed
//	EXPECT_TRUE(mem.SetMemoryData("nsJustShort", nsJustShort, MEM_FORMAT_SHORT));	
//	EXPECT_TRUE(mem.MemoryDataIs("nsJustShort", nsJustShort));	
//	EXPECT_TRUE(cxx.ExpressionValueIs("nsJustShort", nsJustShort));	
	// Since there are too many crashes after editing we want to resize after editing each format
	// TODO: (dklem 11/04/98) Uncomment the following line when #4734 and #8915 are fixed. 
	 MinimalTestResizeMoveWindow();


	EXPECT_TRUE(mem.MemoryDataIs("unsJustUnsignedShort", unsJustUnsignedShort));	
	unsJustUnsignedShort *= 2;
	EXPECT_TRUE(mem.SetMemoryData("unsJustUnsignedShort", unsJustUnsignedShort, MEM_FORMAT_SHORT_UNSIGNED));	
	EXPECT_TRUE(mem.MemoryDataIs("unsJustUnsignedShort", unsJustUnsignedShort));	
	EXPECT_TRUE(cxx.ExpressionValueIs("unsJustUnsignedShort", unsJustUnsignedShort));	
	// Since there are too many crashes after editing we want to resize after editing each format
	// TODO: (dklem 11/04/98) Uncomment the following line when #8915 is fixed. 
	MinimalTestResizeMoveWindow();

	// Check the Short Hex Memory Format
	// TODO: (dklem 10/20/98) Uncomment the following 3 lines when #8198 gets fixed.  Fixed int 8307.0
	EXPECT_TRUE(mem.SetMemoryData("unsJustUnsignedShort", "0113", MEM_FORMAT_SHORT_HEX));	
	unsJustUnsignedShort = 275;
	EXPECT_TRUE(mem.MemoryDataIs("unsJustUnsignedShort", unsJustUnsignedShort));	
	// Since there are too many crashes after editing we want to resize after editing each format
	// TODO: (dklem 11/04/98) Uncomment the following line when #8915 is fixed. 
	MinimalTestResizeMoveWindow();

	EXPECT_TRUE(mem.MemoryDataIs("nJustInt", nJustInt));	
	nJustInt += 1002;
// TODO: (dklem 08/12/98) Uncomment the following 3 lines when #4734 gets fixed
//	EXPECT_TRUE(mem.SetMemoryData("nJustInt", nJustInt, MEM_FORMAT_LONG));	
//	EXPECT_TRUE(mem.MemoryDataIs("nJustInt", nJustInt));	
//	EXPECT_TRUE(cxx.ExpressionValueIs("nJustInt", nJustInt));	
	// Since there are too many crashes after editing we want to resize after editing each format
	// TODO: (dklem 11/04/98) Uncomment the following line when #8915 and #4734 are fixed. 
	MinimalTestResizeMoveWindow();

	EXPECT_TRUE(mem.MemoryDataIs("unJustUnsignedInt", unJustUnsignedInt));	
	unJustUnsignedInt -= 157;
	EXPECT_TRUE(mem.SetMemoryData("unJustUnsignedInt", unJustUnsignedInt, MEM_FORMAT_LONG_UNSIGNED));	
	EXPECT_TRUE(mem.MemoryDataIs("unJustUnsignedInt", unJustUnsignedInt));	
	EXPECT_TRUE(cxx.ExpressionValueIs("unJustUnsignedInt", unJustUnsignedInt));	
	// Since there are too many crashes after editing we want to resize after editing each format
	// TODO: (dklem 11/04/98) Uncomment the following line when #8915 is fixed. 
	MinimalTestResizeMoveWindow();

	EXPECT_TRUE(mem.MemoryDataIs("lJustLongInt", lJustLongInt));	
	lJustLongInt += 12345;
// TODO: (dklem 08/12/98) Uncomment the following 3 lines when #4734 gets fixed
//	EXPECT_TRUE(mem.SetMemoryData("lJustLongInt", lJustLongInt, MEM_FORMAT_LONG));	
//	EXPECT_TRUE(mem.MemoryDataIs("lJustLongInt", lJustLongInt));	
//	EXPECT_TRUE(cxx.ExpressionValueIs("lJustLongInt", lJustLongInt));	
	// Since there are too many crashes after editing we want to resize after editing each format
	// TODO: (dklem 11/04/98) Uncomment the following line when #8915 and #4734 are fixed. 
	MinimalTestResizeMoveWindow();

	EXPECT_TRUE(mem.MemoryDataIs("ulJustUnsignedLongInt", ulJustUnsignedLongInt));	
	ulJustUnsignedLongInt -= 76543;
	EXPECT_TRUE(mem.SetMemoryData("ulJustUnsignedLongInt", ulJustUnsignedLongInt, MEM_FORMAT_LONG_UNSIGNED));	
	EXPECT_TRUE(mem.MemoryDataIs("ulJustUnsignedLongInt", ulJustUnsignedLongInt));	
	EXPECT_TRUE(cxx.ExpressionValueIs("ulJustUnsignedLongInt", ulJustUnsignedLongInt));	
	// Since there are too many crashes after editing we want to resize after editing each format
	// TODO: (dklem 11/04/98) Uncomment the following line when #8915 is fixed. 
	MinimalTestResizeMoveWindow();

	// Check the Long Hex Memory Format
	EXPECT_TRUE(mem.SetMemoryData("ulJustUnsignedLongInt", "000be293", MEM_FORMAT_LONG_HEX));	
	ulJustUnsignedLongInt = 778899;
	EXPECT_TRUE(mem.MemoryDataIs("ulJustUnsignedLongInt", ulJustUnsignedLongInt));	
	// Since there are too many crashes after editing we want to resize after editing each format
	// TODO: (dklem 11/04/98) Uncomment the following line when #8915 is fixed. 
	MinimalTestResizeMoveWindow();

// TODO: (dklem 08/12/98) Uncomment the following 15 lines when #4727 gets fixed.
//	Note: the code in Comem for the float, double and long double is NYI because memory window behavior when 
//	changing (typing) these types is not defined yet.
	EXPECT_TRUE(mem.MemoryDataIs("fJustFloat", fJustFloat));	
	fJustFloat *= (float) 1.981;
	EXPECT_TRUE(mem.SetMemoryData("fJustFloat", fJustFloat, MEM_FORMAT_REAL));	
	EXPECT_TRUE(mem.MemoryDataIs("fJustFloat", fJustFloat));	
	EXPECT_TRUE(cxx.ExpressionValueIs("fJustFloat", fJustFloat));	
	// Since there are too many crashes after editing we want to resize after editing each format
	// TODO: (dklem 11/04/98) Uncomment the following line when #8915 is fixed. 
	MinimalTestResizeMoveWindow();

	EXPECT_TRUE(mem.MemoryDataIs("dJustDouble", dJustDouble));	
	dJustDouble /= 3.923;
//  TODO: (dklem 09/02/98) Uncomment the following 2 lines when #6156 gets fixed
	EXPECT_TRUE(mem.SetMemoryData("dJustDouble", dJustDouble, MEM_FORMAT_REAL_LONG));	
	EXPECT_TRUE(mem.MemoryDataIs("dJustDouble", dJustDouble));	
// TODO: (dklem 09/02/98) Uncomment the following 1 line when #6097 gets fixed.	
//	EXPECT_TRUE(cxx.ExpressionValueIs("dJustDouble", dJustDouble));	
	// Since there are too many crashes after editing we want to resize after editing each format
	// TODO: (dklem 11/04/98) Uncomment the following line when #8915 is fixed. 
	MinimalTestResizeMoveWindow();

	EXPECT_TRUE(mem.MemoryDataIs("dlJustLongDouble", dlJustLongDouble));	
	dlJustLongDouble /= (-103.923);
//  TODO: (dklem 09/02/98) Uncomment the following 2 lines when #6156 gets fixed
	EXPECT_TRUE(mem.SetMemoryData("dlJustLongDouble", dlJustLongDouble, MEM_FORMAT_REAL_LONG));	
	EXPECT_TRUE(mem.MemoryDataIs("dlJustLongDouble", dlJustLongDouble));	

	// Check that E-000 can not be set
	CString csBytes = "{+}1.11111E-000";
	EXPECT_TRUE(mem.SetMemoryBytes("fJustFloat", csBytes, MEM_FORMAT_REAL));
	csBytes	= mem.ExtractMemoryData(MEM_FORMAT_REAL, "fJustFloat", 1);
	csBytes.TrimRight(" ");
	EXPECT_TRUE("+1.11111E+000" == csBytes);

	csBytes = "{+}1.11111E-";
	EXPECT_TRUE(mem.SetMemoryBytes("fJustFloat", csBytes, MEM_FORMAT_REAL));
	csBytes	= mem.ExtractMemoryData(MEM_FORMAT_REAL, "fJustFloat", 1);
	csBytes.TrimRight(" ");
	EXPECT_TRUE("+1.11111E+000" == csBytes);

//  TODO: (dklem 09/02/98) Uncomment the following 10 lines when #6156 gets fixed
	csBytes = "{+}2.22222222222222E-000";
	EXPECT_TRUE(mem.SetMemoryBytes("dJustDouble", csBytes, MEM_FORMAT_REAL_LONG));
	csBytes	= mem.ExtractMemoryData(MEM_FORMAT_REAL_LONG, "dJustDouble", 1);
	csBytes.TrimRight(" ");
	EXPECT_TRUE("+2.22222222222222E+000" == csBytes);

	csBytes = "{+}2.22222222222222E-";
	EXPECT_TRUE(mem.SetMemoryBytes("dJustDouble", csBytes, MEM_FORMAT_REAL_LONG));
	csBytes	= mem.ExtractMemoryData(MEM_FORMAT_REAL_LONG, "dJustDouble", 1);
	csBytes.TrimRight(" ");
	EXPECT_TRUE("+2.22222222222222E+000" == csBytes);


// TODO: (dklem 09/02/98) Uncomment the following 1 line when #6097 gets fixed.	
//	EXPECT_TRUE(cxx.ExpressionValueIs("dlJustLongDouble", dlJustLongDouble));	

	EXPECT_TRUE(mem.MemoryDataIs("sfJustSixtyFourInt", sfJustSixtyFourInt));	
	sfJustSixtyFourInt += 12345987987;
// TODO: (dklem 08/12/98) Uncomment the following 3 lines when #4734 gets fixed
//	EXPECT_TRUE(mem.SetMemoryData("sfJustSixtyFourInt", sfJustSixtyFourInt, MEM_FORMAT_INT64));	
//	EXPECT_TRUE(mem.MemoryDataIs("sfJustSixtyFourInt", sfJustSixtyFourInt));	
// TODO: (dklem 08/12/98) ExpressionValueIs NYI for __in64
//	EXPECT_TRUE(cxx.ExpressionValueIs("sfJustSixtyFourInt", sfJustSixtyFourInt));	
	// Since there are too many crashes after editing we want to resize after editing each format
	// TODO: (dklem 11/04/98) Uncomment the following line when #8915 and #4734 are fixed. 
	MinimalTestResizeMoveWindow();

	EXPECT_TRUE(mem.MemoryDataIs("sfJustSixtyFourUnsignedInt", sfJustSixtyFourUnsignedInt));	
	sfJustSixtyFourUnsignedInt -= 765430009987;

// TODO: (dklem 08/12/98) Uncomment the following 2 lines when #4780 gets fixed
//	EXPECT_TRUE(mem.SetMemoryData("sfJustSixtyFourUnsignedInt", sfJustSixtyFourUnsignedInt, MEM_FORMAT_INT64_UNSIGNED));	
//	EXPECT_TRUE(mem.MemoryDataIs("sfJustSixtyFourUnsignedInt", sfJustSixtyFourUnsignedInt));	
// TODO: (dklem 08/12/98) ExpressionValueIs NYI for __in64
//	EXPECT_TRUE(cxx.ExpressionValueIs("sfJustSixtyFourUnsignedInt", sfJustSixtyFourUnsignedInt));	
	// Since there are too many crashes after editing we want to resize after editing each format
	// TODO: (dklem 11/04/98) Uncomment the following line when #8915 and #4780 fixed. 
	MinimalTestResizeMoveWindow();

	// Check the Long Hex Memory Format
//  TODO: (dklem 09/02/98) Uncomment the following 3 lines when #6156 gets fixed
	EXPECT_TRUE(mem.SetMemoryData("sfJustSixtyFourUnsignedInt", "002386d8905a5967", MEM_FORMAT_INT64_HEX));	
	sfJustSixtyFourUnsignedInt = 9999888877771111;
	EXPECT_TRUE(mem.MemoryDataIs("sfJustSixtyFourUnsignedInt", sfJustSixtyFourUnsignedInt));	

	// Resize and Move
	// TODO: (dklem 11/03/98) Uncomment the following line when #8915 is fixed. 
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(mem.Disable());

}


void CmemIDETest::EditInWatchVerifyInMemoryWindow(void)
{

	LOGTESTHEADER("EditInWatchVerifyInMemoryWindow");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.ShowNextStatement()); // emmang@xbox - hack to move focus to editor and away from mem, else src.Find() dails
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	InitializeGlobalsThatAreUsedInTheMemoryTests();

	chJustChar += 2;
	EXPECT_TRUE(cxx.SetExpressionValue("chJustChar", (int) chJustChar));	
	EXPECT_TRUE(mem.MemoryDataIs("chJustChar", chJustChar));	

	uchJustUnsignedChar += 2;
	EXPECT_TRUE(cxx.SetExpressionValue("uchJustUnsignedChar", (int) uchJustUnsignedChar));	
	EXPECT_TRUE(mem.MemoryDataIs("uchJustUnsignedChar", uchJustUnsignedChar));	

	nsJustShort *= 2;
	EXPECT_TRUE(cxx.SetExpressionValue("nsJustShort", nsJustShort));	
	EXPECT_TRUE(mem.MemoryDataIs("nsJustShort", nsJustShort));	

	unsJustUnsignedShort *= 2;
	EXPECT_TRUE(cxx.SetExpressionValue("unsJustUnsignedShort", unsJustUnsignedShort));	
	EXPECT_TRUE(mem.MemoryDataIs("unsJustUnsignedShort", unsJustUnsignedShort));	
	
	nJustInt += 1002;
	EXPECT_TRUE(cxx.SetExpressionValue("nJustInt", nJustInt));	
	EXPECT_TRUE(mem.MemoryDataIs("nJustInt", nJustInt));	

	unJustUnsignedInt -= 157;
	EXPECT_TRUE(cxx.SetExpressionValue("unJustUnsignedInt", unJustUnsignedInt));	
	EXPECT_TRUE(mem.MemoryDataIs("unJustUnsignedInt", unJustUnsignedInt));	

	lJustLongInt += 12345;
	EXPECT_TRUE(cxx.SetExpressionValue("lJustLongInt", lJustLongInt));	
	EXPECT_TRUE(mem.MemoryDataIs("lJustLongInt", lJustLongInt));	

	ulJustUnsignedLongInt -= 76543;
	EXPECT_TRUE(cxx.SetExpressionValue("ulJustUnsignedLongInt", ulJustUnsignedLongInt));	
	EXPECT_TRUE(mem.MemoryDataIs("ulJustUnsignedLongInt", ulJustUnsignedLongInt));	

	fJustFloat = (float) 438.981;
	EXPECT_TRUE(cxx.SetExpressionValue("fJustFloat", fJustFloat));	
	EXPECT_TRUE(mem.MemoryDataIs("fJustFloat", fJustFloat));	

	dJustDouble = 3.923e22;
	EXPECT_TRUE(cxx.SetExpressionValue("dJustDouble", dJustDouble));	
	EXPECT_TRUE(mem.MemoryDataIs("dJustDouble", dJustDouble));	

	dlJustLongDouble = 1.237e71;
	EXPECT_TRUE(cxx.SetExpressionValue("dlJustLongDouble", dlJustLongDouble));	
	EXPECT_TRUE(mem.MemoryDataIs("dlJustLongDouble", dlJustLongDouble));	

	sfJustSixtyFourInt += 12345987987;
	EXPECT_TRUE(cxx.SetExpressionValue("sfJustSixtyFourInt", sfJustSixtyFourInt));	
	EXPECT_TRUE(mem.MemoryDataIs("sfJustSixtyFourInt", sfJustSixtyFourInt));	

	sfJustSixtyFourUnsignedInt -= 765430009987;
	EXPECT_TRUE(cxx.SetExpressionValue("sfJustSixtyFourUnsignedInt", sfJustSixtyFourUnsignedInt));	
	EXPECT_TRUE(mem.MemoryDataIs("sfJustSixtyFourUnsignedInt", sfJustSixtyFourUnsignedInt));	

	// Resize and Move
	// TODO: (dklem 11/03/98) Uncomment the following line when #8915 is fixed. 
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(mem.Disable());
}


void CmemIDETest::VerifyColumns(void)
{
	LOGTESTHEADER("VerifyColumns");

	char str[64];

	// Make the last element in each array equal to 0 in order to make comparison.  
	// This means that GetMemoryData(,,, count = number_of_columns_to_be_tested + 1) should return 0 for the last element
	// We do not do this while initilazing arrays in order to easily copy/paste this part from debugee
	// if data change
	asJustString [number_of_columns_to_be_tested] = '\0';
	ansJustShort[number_of_columns_to_be_tested] = 0;
	aunsJustUnsignedShort[number_of_columns_to_be_tested] =  0;
	anJustInt[number_of_columns_to_be_tested] = 0;
	aunJustUnsignedInt[number_of_columns_to_be_tested] = 0;
	alJustLongInt[number_of_columns_to_be_tested] = 0;
	aulJustUnsignedLongInt[number_of_columns_to_be_tested] = 0;
	afJustFloat[number_of_columns_to_be_tested] = (float) 0.;
	adJustDouble[number_of_columns_to_be_tested] = 0.;
	adlJustLongDouble[number_of_columns_to_be_tested] = 0.;
	asfJustSixtyFourInt[number_of_columns_to_be_tested] = 0;
	asfJustSixtyFourUnsignedInt[number_of_columns_to_be_tested] = 0;
	
	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.ShowNextStatement()); // emmang@xbox - hack to move focus to editor and away from mem, else src.Find() dails
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	InitializeGlobalsThatAreUsedInTheMemoryTests();

	EXPECT_TRUE(mem.Enable());
	EXPECT_TRUE(mem.SetColumns(itoa(number_of_columns_to_be_tested, str, 10)));

/*
	MEM_FORMAT_WCHAR Memory Format is not tested here.
*/

// TODO: (dklem 08/12/98) Uncomment the following 1 line when #4361 gets fixed. Fixed in 8239.4
// TODO: (dklem 10/07/98) Uncomment the following 1 line when #7580 gets fixed
//	EXPECT_TRUE(mem.MemoryDataIs("asJustString", asJustString, MEM_FORMAT_ASCII, number_of_columns_to_be_tested + 1));	

	EXPECT_TRUE(mem.MemoryDataIs("ansJustShort", ansJustShort, MEM_FORMAT_SHORT, number_of_columns_to_be_tested + 1));
	EXPECT_TRUE(mem.MemoryDataIs("aunsJustUnsignedShort", aunsJustUnsignedShort, MEM_FORMAT_SHORT_UNSIGNED, number_of_columns_to_be_tested + 1));
	EXPECT_TRUE(mem.MemoryDataIs("anJustInt", anJustInt, MEM_FORMAT_LONG, number_of_columns_to_be_tested + 1));
	EXPECT_TRUE(mem.MemoryDataIs("aunJustUnsignedInt", aunJustUnsignedInt, MEM_FORMAT_LONG_UNSIGNED, number_of_columns_to_be_tested + 1));
	EXPECT_TRUE(mem.MemoryDataIs("alJustLongInt", alJustLongInt, MEM_FORMAT_LONG, number_of_columns_to_be_tested + 1));
	EXPECT_TRUE(mem.MemoryDataIs("aulJustUnsignedLongInt", aulJustUnsignedLongInt, MEM_FORMAT_LONG_UNSIGNED, number_of_columns_to_be_tested + 1));
	EXPECT_TRUE(mem.MemoryDataIs("afJustFloat", afJustFloat, MEM_FORMAT_REAL, number_of_columns_to_be_tested + 1));
	EXPECT_TRUE(mem.MemoryDataIs("adJustDouble", adJustDouble, MEM_FORMAT_REAL_LONG, number_of_columns_to_be_tested + 1));
	EXPECT_TRUE(mem.MemoryDataIs("adlJustLongDouble", adlJustLongDouble, MEM_FORMAT_REAL_LONG, number_of_columns_to_be_tested + 1));	
	EXPECT_TRUE(mem.MemoryDataIs("asfJustSixtyFourInt", asfJustSixtyFourInt, MEM_FORMAT_INT64, number_of_columns_to_be_tested + 1));	
	// TODO: (dklem 11/04/98) Uncomment the following line when #7580 is fixed
	//EXPECT_TRUE(mem.MemoryDataIs("asfJustSixtyFourUnsignedInt", asfJustSixtyFourUnsignedInt, MEM_FORMAT_INT64_UNSIGNED, number_of_columns_to_be_tested + 1));	

//	Test MEM_FORMAT_BYTE format
	EXPECT_TRUE(mem.MemoryDataIs("asJustString", "4d 61 6d  Mam", MEM_FORMAT_BYTE, number_of_columns_to_be_tested * 4 + 1));
//	Test HEX formats
	EXPECT_TRUE(mem.MemoryDataIs("asLongString", "614d  626d  2d61        ", MEM_FORMAT_SHORT_HEX, (number_of_columns_to_be_tested + 1)));
	EXPECT_TRUE(mem.MemoryDataIs("asLongString", "626d614d  75542d61  2d61626d            ", MEM_FORMAT_LONG_HEX, (number_of_columns_to_be_tested + 1)));
	EXPECT_TRUE(mem.MemoryDataIs("asLongString", "75542d61626d614d  626d75522d61626d  6d75727568532d61                    ", MEM_FORMAT_INT64_HEX, (number_of_columns_to_be_tested + 1)));

	// Resize and Move
	// TODO: (dklem 11/03/98) Uncomment the following line when #7985 is fixed
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(mem.Disable());

}


void CmemIDETest::ReEvaluateExpression(void)
{

	LOGTESTHEADER("ReEvaluateExpression");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.ShowNextStatement()); // emmang@xbox - hack to move focus to editor and away from mem, else src.Find() dails
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	InitializeGlobalsThatAreUsedInTheMemoryTests();

	EXPECT_TRUE(mem.MemoryDataIs("nJustInt", nJustInt));
	// TODO fro 60.  Toggle evaluation doesn't work in 60
	//EXPECT_TRUE(0 == uimem.GetCurrentAddress().CompareNoCase( uimem.GetCurrentSymbol().Right(8) ) );
	EXPECT_TRUE(uimem.ToogleReEvaluation());
	EXPECT_TRUE(mem.MemoryDataIs("nJustInt", nJustInt));
	EXPECT_TRUE("nJustInt" == uimem.GetCurrentSymbol());
	EXPECT_TRUE(uimem.ToogleReEvaluation());

	// Resize and Move
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(mem.Disable());

}



void CmemIDETest::GoToOverloadedSymbol(void)
{

	LOGTESTHEADER("GoToOverloadedSymbol");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.ShowNextStatement()); // emmang@xbox - hack to move focus to editor and away from mem, else src.Find() dails
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	InitializeGlobalsThatAreUsedInTheMemoryTests();

	EXPECT_TRUE(mem.Enable());
	CString address = mem.GetAddress("FuncWithArg");
	EXPECT_TRUE(dam.Enable());
	EXPECT_TRUE(dam.GotoSymbol(address));

	// TODO: (dklem 10/06/98) Change uidam.GetInstruction() to dam.GetInstruction() when #6013 gets fixed
	CString Instruction = uidam.GetInstruction(-1, 1, FALSE);
	//CString csInstruction = dam.GetInstruction();

	EXPECT_TRUE(-1 != Instruction.Find("int FuncWithArg(int nArg)"));
	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));

	// Resize and Move
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(mem.Disable());

}

void CmemIDETest::RestoringMWTroughtDebuggingSessions(void)
{

	LOGTESTHEADER("RestoringMWTroughtDebuggingSessions");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.ShowNextStatement()); // emmang@xbox - hack to move focus to editor and away from mem, else src.Find() dails
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	InitializeGlobalsThatAreUsedInTheMemoryTests();

	EXPECT_TRUE(mem.MemoryDataIs("unJustUnsignedInt", unJustUnsignedInt));
	CString address = uimem.GetCurrentAddress();

	EXPECT_TRUE(dbg.Restart());
	// TODO (dklem 01/29/99) Restarting doesn't preserve "unJustUnsignedInt" in the address box
	// So the next line is commented.
	// EXPECT_TRUE(0 == address.CompareNoCase(uimem.GetCurrentSymbol().Right(8)));

	// Resize and Move
	// TODO: (dklem 11/04/98) Uncomment the following line when #8915 is fixed. 
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(mem.Disable());
}


void CmemIDETest::GoToMaxMinAddress(void)
{

	LOGTESTHEADER("GoToMaxMinAddress");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.ShowNextStatement()); // emmang@xbox - hack to move focus to editor and away from mem, else src.Find() dails
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	InitializeGlobalsThatAreUsedInTheMemoryTests();

	CString csAddress, csSymbol;

	EXPECT_TRUE("00000000" == (csAddress = mem.GetAddress("00000000")));
	EXPECT_TRUE("00000000" == (csSymbol = uimem.GetCurrentSymbol()));

	LOG->RecordInfo("CurrentAddress is %s", csAddress);
	LOG->RecordInfo("CurrentSymbol is %s", csSymbol);

	csAddress = mem.GetAddress("FFFFFFFF");
	csSymbol = uimem.GetCurrentSymbol();
	EXPECT_TRUE(0 == csAddress.CompareNoCase("FFFFFFFF"));
	EXPECT_TRUE(0 == csSymbol.CompareNoCase("FFFFFFFF"));

	LOG->RecordInfo("CurrentAddress is %s", csAddress);
	LOG->RecordInfo("CurrentSymbol is %s", csSymbol);

	// Resize and Move
	// TODO: (dklem 11/03/98) Uncomment the following line when #7985 is fixed
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(mem.Disable());
}

void CmemIDETest::GoToInvalidAddress(void)
{

	LOGTESTHEADER("GoToInvalidAddress");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.ShowNextStatement()); // emmang@xbox - hack to move focus to editor and away from mem, else src.Find() dails
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	InitializeGlobalsThatAreUsedInTheMemoryTests();

	EXPECT_TRUE(mem.MemoryDataIs("nJustInt", nJustInt));
	
	EXPECT_TRUE(0 == mem.GetAddress("FFFFFFFFF5").CompareNoCase("FFFFFFF5"));
	EXPECT_TRUE(0 == uimem.GetCurrentSymbol().CompareNoCase("FFFFFFFFF5"));

	EXPECT_TRUE(0 == mem.GetAddress("PRIVET").CompareNoCase("FFFFFFF5"));
	EXPECT_TRUE(0 == uimem.GetCurrentSymbol().CompareNoCase("PRIVET"));

	uimem.EnableToolBar(FALSE);
	EXPECT_TRUE(ERROR_SUCCESS == uimem.GoToAddress("PRIVET"));

	// TODO: (dklem 08/12/98) Write a code for cheking  if "Invalid address" dialog comes up - see next 1 line - when #4379 gets fixed
	//EXPECT_TRUE(MST.WFndWnd("Add Dialog Caption", FW_NOCASE | FW_EXIST));

	EXPECT_TRUE(0 == uimem.GetCurrentAddress().CompareNoCase("FFFFFFF5"));


	uimem.EnableToolBar(TRUE);

	// Resize and Move
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(mem.Disable());
}



void CmemIDETest::EditEIP(void)
{

	LOGTESTHEADER("EditEIP");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.ShowNextStatement()); // emmang@xbox - hack to move focus to editor and away from mem, else src.Find() dails
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	InitializeGlobalsThatAreUsedInTheMemoryTests();

	EXPECT_TRUE(dam.Enable());
	CString Instruction = uidam.GetInstruction(2, 1);
	if(Instruction.GetAt(0) == 'F')
	{
		EXPECT_TRUE(mem.SetMemoryData("EIP", "AF"/*Instruction*/, MEM_FORMAT_BYTE));	
	}
	else
	{
		EXPECT_TRUE(mem.SetMemoryData("EIP", "FF"/*Instruction*/, MEM_FORMAT_BYTE));	
	}

	EXPECT_TRUE(dam.Enable());
	EXPECT_TRUE(Instruction != uidam.GetInstruction(0, 1));

	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));

	// Resize and Move
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(mem.Disable());
}

void CmemIDETest::NavigatingPointer(void)
{
	LOGTESTHEADER("NavigatingPointer");
	
	//char str[64];
	//int nRegEIP;
	int number_of_columns_to_be_tested_for60 = 1;

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.ShowNextStatement()); // emmang@xbox - hack to move focus to editor and away from mem, else src.Find() dails
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	InitializeGlobalsThatAreUsedInTheMemoryTests();

	EXPECT_TRUE(uimem.ToogleReEvaluation());

	EXPECT_TRUE(mem.Enable());
	// Get the address
	CString cstr = mem.ExtractMemoryData(MEM_FORMAT_LONG_HEX, "pnJustIntPtr", 1);
	// Navigate to address
	EXPECT_TRUE(mem.MemoryDataIs(cstr, nJustInt));


	// Get the address
	cstr = mem.ExtractMemoryData(MEM_FORMAT_LONG_HEX, "pvJustVoidPtrStr", 1);
	EXPECT_TRUE(mem.MemoryDataIs(cstr, sJustString, MEM_FORMAT_ASCII, strlen(sJustString)));
	// There is no columns feature in 60
	//EXPECT_TRUE(mem.SetColumns(itoa(number_of_columns_to_be_tested_for60, str, 10)));

	cstr = mem.ExtractMemoryData(MEM_FORMAT_LONG_HEX, "pvJustVoidPtrShort", 1);
	EXPECT_TRUE(mem.MemoryDataIs(cstr, ansJustShort, MEM_FORMAT_SHORT, number_of_columns_to_be_tested_for60));

	cstr = mem.ExtractMemoryData(MEM_FORMAT_LONG_HEX, "pvJustVoidPtrInt", 1);
	EXPECT_TRUE(mem.MemoryDataIs(cstr, anJustInt, MEM_FORMAT_LONG, number_of_columns_to_be_tested_for60));
	
	cstr = mem.ExtractMemoryData(MEM_FORMAT_LONG_HEX, "pvJustVoidPtrFloat", 1);
	EXPECT_TRUE(mem.MemoryDataIs(cstr, afJustFloat, MEM_FORMAT_REAL, number_of_columns_to_be_tested_for60));

	cstr = mem.ExtractMemoryData(MEM_FORMAT_LONG_HEX, "pvJustVoidPtrDouble", 1);
	EXPECT_TRUE(mem.MemoryDataIs(cstr, adJustDouble, MEM_FORMAT_REAL_LONG, number_of_columns_to_be_tested_for60));
	
	cstr = mem.ExtractMemoryData(MEM_FORMAT_LONG_HEX, "pvJustVoidPtrInt64", 1);
	EXPECT_TRUE(mem.MemoryDataIs(cstr, asfJustSixtyFourUnsignedInt, MEM_FORMAT_INT64, number_of_columns_to_be_tested_for60));

	EXPECT_TRUE(uimem.ToogleReEvaluation());

	// Check that setting EIP = 0 in the address edit box doesn't have side effects.  Related to bug 8940.  Fixed in 8303.1
	EXPECT_TRUE(dbg.Restart());

	// TODO (dklem 02/01/99) ERROR in 60 - Putting EIP = 0 in memory window stops debugee
	// Moreover EIP = 0 is memorized so there is no way to debug the app other than delet an opt file.
	/*
	EXPECT_TRUE(uimem.ToogleReEvaluation());
	nRegEIP = regs.GetRegister(EIP);
	itoa(nRegEIP, str, 10);
	uimem.Activate();
	EXPECT_TRUE(ERROR_SUCCESS == uimem.GoToAddress("EIP = 0"));
	//EXPECT_TRUE(mem.GetMemoryData((LPCSTR), tmp_str, MEM_FORMAT_ASCII)); 

	COApplication appDialog;
	if(!appDialog.Attach("Microsoft Visual C++", 10))
	{
		LOG->RecordFailure("The dialog \"Microsoft Visual C++ (invalid expression)\" did not come up");
		return;
	}
	else
		// Hit OK to close dialog
		appDialog.SendKeys("ENTER");

	
	// Check that this hasn't changed EIP
	EXPECT_TRUE(cxx.ExpressionValueIs("EIP", str));

	EXPECT_TRUE(uimem.ToogleReEvaluation());
	*/

	// Resize and Move
	// TODO: (dklem 11/03/98) Uncomment the following line when #7985 is fixed
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(mem.Disable());

}


void CmemIDETest::ContextMenuOnToolBar(void)
{
	LOGTESTHEADER("ContextMenuOnToolBar");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.ShowNextStatement()); // emmang@xbox - hack to move focus to editor and away from mem, else src.Find() dails
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	InitializeGlobalsThatAreUsedInTheMemoryTests();

	EXPECT_TRUE(mem.Enable());
	CString csData = mem.ExtractMemoryData(MEM_FORMAT_SHORT_HEX, "asLongString", 1);
	EXPECT_TRUE(0 == csData.CompareNoCase("614d  ")); 
	int asa = csData.CompareNoCase("614d  ");

	csData = mem.ExtractMemoryData(MEM_FORMAT_LONG_HEX, "asLongString", 1);
	EXPECT_TRUE(0 == csData.CompareNoCase("626d614d  ")); 

	// Resize and Move
	// TODO: (dklem 11/03/98) Uncomment the following line when #7985 is fixed
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(mem.Disable());

}


void CmemIDETest::VerifyMultipleUndoRedo(void)
{
	LOGTESTHEADER("VerifyMultipleUndoRedo");

	char str[64];

	unsigned int unJustUnsignedIntegers[2];
	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.ShowNextStatement()); // emmang@xbox - hack to move focus to editor and away from mem, else src.Find() dails
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	InitializeGlobalsThatAreUsedInTheMemoryTests();

	EXPECT_TRUE(mem.MemoryDataIs("unJustUnsignedInt", unJustUnsignedInt));	
	
	unJustUnsignedIntegers[0] = unJustUnsignedInt - 157;
	EXPECT_TRUE(mem.SetMemoryData("unJustUnsignedInt", unJustUnsignedIntegers[0], MEM_FORMAT_LONG_UNSIGNED));	
	EXPECT_TRUE(mem.MemoryDataIs("unJustUnsignedInt", unJustUnsignedIntegers[0]));	

	// 60 doesn't support Multiple Redo/Undo
/*
	unJustUnsignedIntegers[1] = unJustUnsignedIntegers[0] * 2;
	EXPECT_TRUE(mem.SetMemoryData("unJustUnsignedInt", unJustUnsignedIntegers[1], MEM_FORMAT_LONG_UNSIGNED));	
	EXPECT_TRUE(mem.MemoryDataIs("unJustUnsignedInt", unJustUnsignedIntegers[1]));
	
	EditUndo(strlen(itoa(unJustUnsignedIntegers[1], str, 10)));
	EXPECT_TRUE(mem.MemoryDataIs("unJustUnsignedInt", unJustUnsignedIntegers[0]));	
*/
	EditUndo(strlen(itoa(unJustUnsignedIntegers[0], str, 10)));
	EXPECT_TRUE(mem.MemoryDataIs("unJustUnsignedInt", unJustUnsignedInt));	

	EditRedo(strlen(itoa(unJustUnsignedIntegers[0], str, 10)));
	EXPECT_TRUE(mem.MemoryDataIs("unJustUnsignedInt", unJustUnsignedIntegers[0]));	
/*
	EditRedo(strlen(itoa(unJustUnsignedIntegers[1], str, 10)));
	EXPECT_TRUE(mem.MemoryDataIs("unJustUnsignedInt", unJustUnsignedIntegers[1]));	
*/
	// Resize and Move
	// TODO: (dklem 11/04/98) Uncomment the following line when #8915 is fixed. 
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(mem.Disable());

}

void CmemIDETest::CycleThroughMemoryFormats(void)
{
	LOGTESTHEADER("CycleThroughMemoryFormats");

	char str[64];

	// Check that nothing bad happens when cycling and Memory window is closed
	// TODO: (dklem 08/21/98) Uncomment the following 2 lines when #5485 gets fixed. Fixed in 8239.4
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_TRUE(mem.CycleMemoryFormat(1));

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE(dbg.ShowNextStatement()); // emmang@xbox - hack to move focus to editor and away from mem, else src.Find() dails
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	InitializeGlobalsThatAreUsedInTheMemoryTests();

/*
	MEM_FORMAT_WCHAR Memory Format is not tested here.
*/
	
	EXPECT_TRUE(mem.MemoryDataIs("asLongString", asLongString, MEM_FORMAT_ASCII, strlen(asLongString)));

	EXPECT_TRUE(mem.SetColumns(itoa(number_of_columns_to_be_tested, str, 10)));

	uimem.Activate();

	EXPECT_TRUE(mem.CycleMemoryFormat(1));
	uimem.m_MemoryFormat = MEM_FORMAT_INT64_UNSIGNED;
	EXPECT_TRUE(" 8454432296767676749   7092453983987524205   7887336170996313441  " == uimem.GetCurrentData(number_of_columns_to_be_tested));
	
	EXPECT_TRUE(mem.CycleMemoryFormat(1));
	uimem.m_MemoryFormat = MEM_FORMAT_INT64_HEX;
	EXPECT_TRUE("75542d61626d614d  626d75522d61626d  6d75727568532d61  " == uimem.GetCurrentData(number_of_columns_to_be_tested));
	
	EXPECT_TRUE(mem.CycleMemoryFormat(1));
	uimem.m_MemoryFormat = MEM_FORMAT_INT64;
	EXPECT_TRUE(" 8454432296767676749   7092453983987524205   7887336170996313441  " == uimem.GetCurrentData(number_of_columns_to_be_tested));
	
	EXPECT_TRUE(mem.CycleMemoryFormat(1));
	uimem.m_MemoryFormat = MEM_FORMAT_REAL_LONG;
	EXPECT_TRUE("+1.51481173207894E+257  +1.35711012392993E+166  +1.89271628313060E+219  " == uimem.GetCurrentData(number_of_columns_to_be_tested));
	
	EXPECT_TRUE(mem.CycleMemoryFormat(1));
	uimem.m_MemoryFormat = MEM_FORMAT_REAL;
	EXPECT_TRUE("+1.09472E+021  +2.68967E+032  +1.28116E-011  " == uimem.GetCurrentData(number_of_columns_to_be_tested));
	
	EXPECT_TRUE(mem.CycleMemoryFormat(1));
	uimem.m_MemoryFormat = MEM_FORMAT_LONG_UNSIGNED;
	EXPECT_TRUE("1651335501  1968450913   761356909  " == uimem.GetCurrentData(number_of_columns_to_be_tested));
	
	EXPECT_TRUE(mem.CycleMemoryFormat(1));
	uimem.m_MemoryFormat = MEM_FORMAT_LONG_HEX;
	EXPECT_TRUE("626d614d  75542d61  2d61626d  " == uimem.GetCurrentData(number_of_columns_to_be_tested));
	
	EXPECT_TRUE(mem.CycleMemoryFormat(1));
	uimem.m_MemoryFormat = MEM_FORMAT_LONG;
	EXPECT_TRUE(" 1651335501   1968450913    761356909  " == uimem.GetCurrentData(number_of_columns_to_be_tested));
	
	EXPECT_TRUE(mem.CycleMemoryFormat(1));
	uimem.m_MemoryFormat = MEM_FORMAT_SHORT_UNSIGNED;
	EXPECT_TRUE("24909  25197  11617  " == uimem.GetCurrentData(number_of_columns_to_be_tested));
	
	EXPECT_TRUE(mem.CycleMemoryFormat(1));
	uimem.m_MemoryFormat = MEM_FORMAT_SHORT_HEX;
	EXPECT_TRUE("614d  626d  2d61  " == uimem.GetCurrentData(number_of_columns_to_be_tested));

	EXPECT_TRUE(mem.CycleMemoryFormat(1));
	uimem.m_MemoryFormat = MEM_FORMAT_SHORT;
	EXPECT_TRUE(" 24909   25197   11617  " == uimem.GetCurrentData(number_of_columns_to_be_tested));

	EXPECT_TRUE(mem.CycleMemoryFormat(1));
	uimem.m_MemoryFormat = MEM_FORMAT_BYTE;
	EXPECT_TRUE(0 == stricmp("4d 61 6d  Ma",uimem.GetCurrentData(number_of_columns_to_be_tested + 1)));

	// Resize and Move
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(mem.Disable());

}


void CmemIDETest::PgUpDownCtrlHomeEnd(void)
{
	LOGTESTHEADER("PgUpDownCtrlHomeEnd");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.ShowNextStatement()); // emmang@xbox - hack to move focus to editor and away from mem, else src.Find() dails
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	InitializeGlobalsThatAreUsedInTheMemoryTests();
	
	EXPECT_TRUE(mem.Enable());
	EXPECT_TRUE(mem.MemoryDataIs("chJustChar", chJustChar));	
	DoDifferentKeysInMemoryWindow();

	EXPECT_TRUE(mem.MemoryDataIs("uchJustUnsignedChar", uchJustUnsignedChar));	
	DoDifferentKeysInMemoryWindow();

	EXPECT_TRUE(mem.MemoryDataIs("nsJustShort", nsJustShort));	
	DoDifferentKeysInMemoryWindow();

	EXPECT_TRUE(mem.MemoryDataIs("unsJustUnsignedShort", unsJustUnsignedShort));	
	DoDifferentKeysInMemoryWindow();

	EXPECT_TRUE(mem.MemoryDataIs("nJustInt", nJustInt));	
	DoDifferentKeysInMemoryWindow();

	EXPECT_TRUE(mem.MemoryDataIs("unJustUnsignedInt", unJustUnsignedInt));	
	DoDifferentKeysInMemoryWindow();

	EXPECT_TRUE(mem.MemoryDataIs("lJustLongInt", lJustLongInt));	
	DoDifferentKeysInMemoryWindow();

	EXPECT_TRUE(mem.MemoryDataIs("ulJustUnsignedLongInt", ulJustUnsignedLongInt));	
	DoDifferentKeysInMemoryWindow();

	EXPECT_TRUE(mem.MemoryDataIs("fJustFloat", fJustFloat));	
	DoDifferentKeysInMemoryWindow();

	EXPECT_TRUE(mem.MemoryDataIs("dJustDouble", dJustDouble));	
	DoDifferentKeysInMemoryWindow();

	EXPECT_TRUE(mem.MemoryDataIs("dlJustLongDouble", dlJustLongDouble));	
	DoDifferentKeysInMemoryWindow();

	EXPECT_TRUE(mem.MemoryDataIs("sfJustSixtyFourInt", sfJustSixtyFourInt));	
	DoDifferentKeysInMemoryWindow();

	EXPECT_TRUE(mem.MemoryDataIs("sfJustSixtyFourUnsignedInt", sfJustSixtyFourUnsignedInt));	
	DoDifferentKeysInMemoryWindow();

	// Resize and Move
	// TODO: (dklem 11/03/98) Uncomment the following line when #7985 is fixed
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(mem.Disable());

}

void CmemIDETest::DoDifferentKeysInMemoryWindow(void)
{
	CString csInitialAddress, csNewAddress, csNewAddress1;

	csInitialAddress = uimem.GetCurrentAddress();
	
	// Check PhUp and PgDown
	MST.DoKeys("{PGUP}");
	csNewAddress = uimem.GetCurrentAddress();
	EXPECT_TRUE(csNewAddress < csInitialAddress);

	MST.DoKeys("{PGDN}");
	csNewAddress = uimem.GetCurrentAddress();
	EXPECT_TRUE(csNewAddress == csInitialAddress);

	MST.DoKeys("{PGDN}");
	csNewAddress = uimem.GetCurrentAddress();
	EXPECT_TRUE(csNewAddress > csInitialAddress);

	MST.DoKeys("{PGUP}");
	csNewAddress = uimem.GetCurrentAddress();
	EXPECT_TRUE(csNewAddress == csInitialAddress);

	// Check Ctrl+End and Ctrl+Home
	MST.DoKeys("^{END}");
	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and copy first 8 characters to clipboard
	GetClipText(csNewAddress);
	EXPECT_TRUE(csNewAddress > csInitialAddress);

	MST.DoKeys("^{HOME}");
	csNewAddress = uimem.GetCurrentAddress();
	EXPECT_TRUE(csNewAddress == csInitialAddress);

	// Check Arrows Up and Down
	MST.DoKeys("{HOME}{UP}");
	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and copy first 8 characters to clipboard
	GetClipText(csNewAddress);
	EXPECT_TRUE(csNewAddress < csInitialAddress);

	MST.DoKeys("{HOME}{UP}");
	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and copy first 8 characters to clipboard
	GetClipText(csNewAddress1);
	EXPECT_TRUE(csNewAddress1 < csNewAddress);

	MST.DoKeys("{HOME}{DOWN}");
	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and copy first 8 characters to clipboard
	GetClipText(csNewAddress1);
	EXPECT_TRUE(csNewAddress1 == csNewAddress);

	MST.DoKeys("{HOME}{DOWN}");
	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and copy first 8 characters to clipboard
	GetClipText(csNewAddress1);
	EXPECT_TRUE(csNewAddress1 == csInitialAddress);

	MST.DoKeys("{HOME}{DOWN}");
	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and copy first 8 characters to clipboard
	GetClipText(csNewAddress);
	EXPECT_TRUE(csNewAddress > csInitialAddress);

	MST.DoKeys("{HOME}{DOWN}");
	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and copy first 8 characters to clipboard
	GetClipText(csNewAddress1);
	EXPECT_TRUE(csNewAddress1 > csNewAddress);

	MST.DoKeys("{HOME}{UP}");
	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and copy first 8 characters to clipboard
	GetClipText(csNewAddress1);
	EXPECT_TRUE(csNewAddress1 == csNewAddress);

	MST.DoKeys("{HOME}{UP}");
	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and copy first 8 characters to clipboard
	GetClipText(csNewAddress1);
	EXPECT_TRUE(csNewAddress1 == csInitialAddress);

	// Resize and Move
	// TODO: (dklem 11/03/98) Uncomment the following line when #7985 is fixed
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(mem.Disable());

}

void CmemIDETest::VerifyDockingView(void)
{
	LOGTESTHEADER("VerifyDockingView");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.ShowNextStatement()); // emmang@xbox - hack to move focus to editor and away from mem, else src.Find() dails
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	InitializeGlobalsThatAreUsedInTheMemoryTests();

	EXPECT_TRUE(uimem.EnableDockingView(FALSE));
	EXPECT_TRUE(!uimem.IsDockingViewEnabled());
	// TODO: (dklem 09/08/98) Uncomment the following 1 line when #6346 gets fixed
	// The bug #6346 is Memory leak while resizing Memory window.  This leak is not that bad in the Release version
	// Try to uncomment the next line and run the tests againts the Retail version when #7982 and #7985 are fixed. #7982 Fixed int 8307.0
	TestResizeMoveWindow(FALSE, TRUE);	

	EXPECT_TRUE(uimem.EnableDockingView(TRUE));
	EXPECT_TRUE(uimem.IsDockingViewEnabled());
	// TODO: (dklem 09/08/98) Uncomment the following 1 line when #6346 gets fixed
	// The bug #6346 is Memory leak while resizing Memory window.  This leak is not that bad in the Release version
	// Try to uncomment the next line and run the tests againts the Retail version when #7982 and #7985 are fixed. #7982 Fixed int 8307.0
	TestResizeMoveWindow(TRUE, TRUE);	

}

void CmemIDETest::VerifyEditing(void)
{
	LOGTESTHEADER("VerifyEditing");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.ShowNextStatement()); // emmang@xbox - hack to move focus to editor and away from mem, else src.Find() dails
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	InitializeGlobalsThatAreUsedInTheMemoryTests();

	uimem.Activate();

	EXPECT_TRUE(mem.MemoryDataIs("sfJustSixtyFourUnsignedInt", sfJustSixtyFourUnsignedInt));
	CString csInitialAddress = uimem.GetCurrentAddress();

// TODO: (dklem 09/02/98) Uncomment the following commented portion when #5440 gets fixed. Fixed in 8323.0

	// Check deleting address
	//MST.DoKeys("^{HOME}");
	INFO(Deleting address)
	MST.DoKeys("{HOME}");
	MST.DoKeys("{DEL 2}");
	MST.DoKeys("^+{RIGHT}");
	MST.DoKeys("{DEL}");

	// Check deleting data
	//MST.DoKeys("^{HOME}");
	INFO(Deleting data)
	MST.DoKeys("{HOME}");
	MST.DoKeys("{TAB}");
	MST.DoKeys("{DEL}");
	MST.DoKeys("^+{RIGHT}");
	MST.DoKeys("{DEL}");

	//MST.DoKeys("^{HOME}");
	INFO(Deleting data again?)
	MST.DoKeys("{HOME}");
	MST.DoKeys("{TAB}");
	MST.DoKeys("^+{RIGHT}");
	MST.DoKeys("{DEL}");

	// Data and address should not change
	EXPECT_TRUE(csInitialAddress == uimem.GetCurrentAddress());
	EXPECT_TRUE(mem.MemoryDataIs("sfJustSixtyFourUnsignedInt", sfJustSixtyFourUnsignedInt));	

	if(csInitialAddress != "12345678")
		clipboard.SetText("12345678");
	else
		clipboard.SetText("32154678");

	// Check pasting address
	//MST.DoKeys("^{HOME}");
	MST.DoKeys("{HOME}");
	MST.DoKeys("^+{RIGHT}");
	MST.DoKeys("^V");

	// Check pasting data
	//MST.DoKeys("^{HOME}");
	MST.DoKeys("{HOME}");
	MST.DoKeys("{TAB}");
	MST.DoKeys("^+{RIGHT}");
	MST.DoKeys("^V");

	// Data and address should not change
	EXPECT_TRUE(csInitialAddress == uimem.GetCurrentAddress());
	EXPECT_TRUE(mem.MemoryDataIs("sfJustSixtyFourUnsignedInt", sfJustSixtyFourUnsignedInt));	

	// Resize and Move
	// TODO: (dklem 11/04/98) Uncomment the following line when #8915 is fixed. 
	MinimalTestResizeMoveWindow();
	EXPECT_TRUE(mem.Disable());

}

void CmemIDETest::MinimalTestResizeMoveWindow()
{

	BOOL bInitiallyMaximized;
	// TODO: (dklem 11/11/98) enable this test by removing the following 1 line when #6346 is fixed
	// Set HKLM\Software\Microsoft\DevStudio\6.1\NoSafeDup to DWORD(1) to turn it off.  (Debug only).

	// TODO: (dklem 09/08/98) Uncomment the following 4 lines when #6346 gets fixed
	// The bug #6346 is Memory leak while resizing Memory window.  This leak is not that bad in the Release version
	// Try to uncomment the next 4 lines and run the tests againts the Retail version when #7982 and #7985 are fixed. #7982 Fixed int 8307.0
	TestResizeMoveWindow(TRUE, FALSE);
	uimem.ToggleDockingView();

	uimem.Activate();
	HWND hwnd = uimem.HWnd();

	if(IsZoomed(hwnd))
	{
		bInitiallyMaximized = TRUE;
		ShowWindow(hwnd, SW_RESTORE);
	}
	else 
		bInitiallyMaximized = FALSE;

	TestResizeMoveWindow(FALSE, FALSE);
	uimem.ToggleDockingView();

	// Restore the MEM window before turning Docking View on
	if(bInitiallyMaximized)
		ShowWindow(hwnd, SW_MAXIMIZE);
}

void CmemIDETest::TestResizeMoveWindow(BOOL bIsDocked, BOOL bFullTest)
{
	int nPositionMoved;
	uimem.Activate();

	BOOL DragFullWindows = TRUE;
	EXPECT_TRUE(GetDragFullWindows(&DragFullWindows));

	// Try minimum hor and ver sizes
	// TODO: (dklem 09/04/98) Uncomment the following 2 lines when #6246 gets fixed
	nPositionMoved = uimem. ResizeWindow(bIsDocked, SLeft, DRight, -1, DragFullWindows);
	uimem.ResizeWindow(bIsDocked, SLeft, DLeft, nPositionMoved, DragFullWindows);

	nPositionMoved = uimem.ResizeWindow(bIsDocked, SBottom, DUp, -1, DragFullWindows);
	uimem.ResizeWindow(bIsDocked, SBottom, DDown, nPositionMoved, DragFullWindows);

	// Move the window
	nPositionMoved = uimem.MoveWindow(bIsDocked, DRight, 20, DragFullWindows);
	nPositionMoved = uimem.MoveWindow(bIsDocked, DDown, 20, DragFullWindows);
	nPositionMoved = uimem.MoveWindow(bIsDocked, DLeft, 20, DragFullWindows);
	nPositionMoved = uimem.MoveWindow(bIsDocked, DUp, 20, DragFullWindows);

	if(!bFullTest) return;

	// Try to go beyond screen borders
	nPositionMoved = uimem.ResizeWindow(bIsDocked, SLeft, DLeft, -1, DragFullWindows);
	if(!DragFullWindows)
	{
		EXPECT_TRUE(uimem.ToggleDockingView());
		EXPECT_TRUE(uimem.ToggleDockingView());
		uimem.Activate();
	}
	uimem.ResizeWindow(bIsDocked, SLeft, DRight, nPositionMoved, DragFullWindows);

	nPositionMoved = uimem.ResizeWindow(bIsDocked, SRight, DRight, -1, DragFullWindows);
	if(!DragFullWindows)
	{
		EXPECT_TRUE(uimem.ToggleDockingView());
		EXPECT_TRUE(uimem.ToggleDockingView());
		uimem.Activate();
	}
	uimem.ResizeWindow(bIsDocked, SRight, DLeft, nPositionMoved, DragFullWindows);

	nPositionMoved = uimem.ResizeWindow(bIsDocked, SBottom, DDown, -1, DragFullWindows);
	if(!DragFullWindows)
	{
		EXPECT_TRUE(uimem.ToggleDockingView());
		EXPECT_TRUE(uimem.ToggleDockingView());
		uimem.Activate();
	}
	uimem.ResizeWindow(bIsDocked, SBottom, DUp, nPositionMoved, DragFullWindows);

	// TODO: (dklem 09/04/98) Uncomment the following 2 lines when #6245 gets fixed. Fixed int 8307.0
	nPositionMoved = uimem.ResizeWindow(bIsDocked, STop, DUp, -1, DragFullWindows);
	if(!DragFullWindows)
	{
		EXPECT_TRUE(uimem.ToggleDockingView());
		EXPECT_TRUE(uimem.ToggleDockingView());
		uimem.Activate();
	}
	uimem.ResizeWindow(bIsDocked, STop, DDown, nPositionMoved, DragFullWindows);

	// I like to move it move it
	nPositionMoved = uimem.MoveWindow(bIsDocked, DRight, -1, DragFullWindows);
	// If we move it to far, the title bar is not available, we need to reactivate memory window
	uimem.ToggleDockingView();
	uimem.ToggleDockingView();
	uimem.Activate();
	uimem.MoveWindow(bIsDocked, DLeft, nPositionMoved, DragFullWindows);

	nPositionMoved = uimem.MoveWindow(bIsDocked, DLeft, -1, DragFullWindows);
	uimem.ToggleDockingView();
	uimem.ToggleDockingView();
	uimem.Activate();
	uimem.MoveWindow(bIsDocked, DRight, nPositionMoved, DragFullWindows);

	nPositionMoved = uimem.MoveWindow(bIsDocked, DDown, -1, DragFullWindows);
	uimem.ToggleDockingView();
	uimem.ToggleDockingView();
	uimem.Activate();
	uimem.MoveWindow(bIsDocked, DUp, nPositionMoved, DragFullWindows);

	// TODO: (dklem 09/04/98) Uncomment the following 5 lines when #6261 gets fixed
	nPositionMoved = uimem.MoveWindow(bIsDocked, DUp, -1, DragFullWindows);
	uimem.ToggleDockingView();
	uimem.ToggleDockingView();
	uimem.Activate();
	uimem.MoveWindow(bIsDocked, DDown, nPositionMoved, DragFullWindows);
}


//	added by dverma for VCPP
void CmemIDETest::VerifyRegArray(CString Arr[],int Num_items)
{
	unsigned __int64 *data = new unsigned __int64;

	mem.Enable();

	for (int count = 0; count< Num_items; count++)
		mem.GetMemoryData(Arr[count], data, MEM_FORMAT_INT64_UNSIGNED, 1);

	mem.Disable();
}

//	added by dverma for VCPP
void CmemIDETest::VerifyVCPPReg(void)
{
	LOG->RecordInfo("Verifying Processor Pack Registers");
	
	CString MMXRegs[] = {"MM0","MM1","MM2","MM3","MM4","MM5","MM6","MM7"};
	CString MMXijRegs[] = {	"MM00","MM10","MM20","MM30","MM40","MM50","MM60","MM70",
							"MM01","MM11","MM21","MM31","MM41","MM51","MM61","MM71"};

	CString XMMRegs[] = {"XMM0","XMM1","XMM2","XMM3","XMM4","XMM5","XMM6","XMM7"};
	CString XMMijRegs[] = {	"XMM00","XMM01","XMM02","XMM03", "XMM10","XMM11","XMM12","XMM13",
							"XMM20","XMM21","XMM22","XMM23", "XMM30","XMM31","XMM32","XMM33",
							"XMM40","XMM41","XMM42","XMM43", "XMM50","XMM51","XMM52","XMM53",
							"XMM60","XMM61","XMM62","XMM63", "XMM70","XMM71","XMM72","XMM73" };

	CString XMM0DRegs[] = {	"XMM0DL","XMM0DH","XMM1DL","XMM1DH","XMM2DL","XMM2DH",
							"XMM3DL","XMM3DH","XMM4DL","XMM4DH","XMM5DL","XMM5DH",
							"XMM6DL","XMM6DH","XMM7DL","XMM7DH" };

	CString XMM0IRegs[] = {	"XMM0IL","XMM0IH","XMM1IL","XMM1IH","XMM2IL","XMM2IH",
							"XMM3IL","XMM3IH","XMM4IL","XMM4IH","XMM5IL","XMM5IH",
							"XMM6IL","XMM6IH","XMM7IL","XMM7IH" };

	
	VerifyRegArray(MMXRegs,8);
		
	//	3dnow system
	if (0) // CMDLINE->GetBooleanValue("k6",FALSE)||CMDLINE->GetBooleanValue("k7",FALSE))
	{
		VerifyRegArray(MMXijRegs,16);
	}

	//	P3 system
	if (1) // kni instruction set CMDLINE->GetBooleanValue("kni",FALSE)||CMDLINE->GetBooleanValue("wni",FALSE))
	{
		VerifyRegArray(XMMRegs,8);
		VerifyRegArray(XMMijRegs,32);
		VerifyRegArray(XMM0DRegs,16);
		VerifyRegArray(XMM0IRegs,16);
	}

	LOG->RecordInfo("Processor Pack Verification Successful");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\namespce\namesub.h ===
///////////////////////////////////////////////////////////////////////////////
//	Namesub.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CNameSpceSubSuite class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CNameSpceSubSuite class

class CNameSpceSubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CNameSpceSubSuite)
	DECLARE_TESTLIST()
protected:
	void CleanUp(void);
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\mem\memcase.h ===
///////////////////////////////////////////////////////////////////////////////
//	memcase.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CmemIDETest Class
//

#ifndef __memcase_H__
#define __memcase_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\DbgTestBase.h"
#include "memsub.h"

///////////////////////////////////////////////////////////////////////////////
//	CmemIDETest class

class CmemIDETest : public CDbgTestBase
{
	DECLARE_TEST(CmemIDETest, CmemSubSuite)

// Data
private:
	// the base name of the localized directories and files we will use.
	CString m_strProjBase;
	// the location of the unlocalized sources, under which the projects we will use will be located.
	CString m_strSrcDir;
	// the locations of the dll and exe projects, and their localized sources, that we will use for this test.
	CString m_strExeDir;

public:  // Operations
	virtual void PreRun(void);
	virtual void Run();

// Test cases
public:

	void GoToSymbol (void);
	void VerifyEditAllFormats(void);
	void EditInWatchVerifyInMemoryWindow(void);
	void VerifyColumns(void);
	void ReEvaluateExpression(void);
	void GoToOverloadedSymbol(void);
	void RestoringMWTroughtDebuggingSessions(void);
	void GoToMaxMinAddress(void);
	void GoToInvalidAddress(void);
	void EditEIP(void);
	void NavigatingPointer(void);
	void ContextMenuOnToolBar(void);
	void VerifyMultipleUndoRedo(void);
	void CycleThroughMemoryFormats(void);
	void PgUpDownCtrlHomeEnd(void);
	void VerifyDockingView(void);
	void VerifyEditing(void);
	void VerifyVCPPReg(void);
	void VerifyRegArray(CString Arr[],int Num_items);	

private:
	void InitializeGlobalsThatAreUsedInTheMemoryTests(void);
	void DoDifferentKeysInMemoryWindow(void);
	
// Old tests.  TODO (Dklem 07-30) remove them
	void GoAfterScrollMemoryWnd(void);
	void MemExpectBytes(void);
	void MemoryFormats(void);
	void TestResizeMoveWindow(BOOL bIsDocked, BOOL bFullTest);
	void MinimalTestResizeMoveWindow(void);

private:
	int m_TestNumber;
	int m_TotalNumberOfTests;
	CString m_strLogInfo;


};

#endif //__memcase_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\namespce\namesub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CNameSpceSubSuite class
//

#include "stdafx.h"
#include "Namesub.h"
#include "afxdllx.h"

#include "Namecase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CNameSpceSubSuite

IMPLEMENT_SUBSUITE(CNameSpceSubSuite, CIDESubSuite, "Namespace", "VCQA Debugger")

BEGIN_TESTLIST(CNameSpceSubSuite)
	TEST(CNameSpceIDETest, RUN)
END_TESTLIST()

void CNameSpceSubSuite::CleanUp(void)
	{
	::CleanUp("namspace");
	}

///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\namespce\namecase.h ===
///////////////////////////////////////////////////////////////////////////////
//	Namecase.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CNameSpceIDETest Class
//

#ifndef __Namecase_H__
#define __Namecase_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\dbgtestbase.h"
#include "namesub.h"

///////////////////////////////////////////////////////////////////////////////
//	CNameSpceIDETest class

class CNameSpceIDETest : public CDbgTestBase
{
	DECLARE_TEST(CNameSpceIDETest, CNameSpceSubSuite)

	// Operations
	public:
		virtual void PreRun(void);
		virtual void Run(void);

	// Test cases
	private:
		void EvaluateNamespaceVarOutsideNamespace(void);
		void EvaluateNamespaceFuncOutsideNamespace(void);
		void EvaluateNestedNamespaceVarOutsideNamespace(void);
		void EvaluateNamespaceMemberInsideNamespace(void);
		void GoToLocationBpOnNamespaceFunc(void);
		void GoToDataBpOnNamespaceVar(void);
		void NavigateMemoryWndToNamespaceVar(void);
		void VerifyReturnValueInfoIncludesNamespace(void);
		void NavigateStackOutOfAndBackIntoNamespaceFunc(void);
		void ImplicitlyReferenceNamespaceMemberAfterUsingDirective(void);
		void ImplicitlyReferenceNamespaceMemberInsideNamespace(void);

	// Data
	private:
		EXPR_INFO expr_info_actual[4], expr_info_expected[4];
	};

#endif //__Namecase_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\nlg\nlgcase2.h ===
///////////////////////////////////////////////////////////////////////////////
//	NLGcase.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CNLGIDETest Class
//

#ifndef __NLGcase2_H__
#define __NLGcase2_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\dbgtestbase.h"
#include "nlgsub.h"

///////////////////////////////////////////////////////////////////////////////
//	CNLGIDETest class

class CNLG2IDETest : public CDbgTestBase
{
	DECLARE_TEST(CNLG2IDETest, CNLGSubSuite)

// Attributes
public:

// Operations
public:
	virtual void PreRun(void);
	virtual void Run();

	BOOL IsUnhandledException(CString except_text);

// Test Cases
protected:
	// EH
	BOOL EH_StepIntoThrow( );
	BOOL EH_StepIntoReThrow( );
	BOOL EH_CatchInDLL( );
	BOOL EH_CatchFromDLL( );
	BOOL EH_ReThrowInCtor( );

	// SEH
	BOOL SEH_ExceptionContinueSearch( );
	BOOL SEH_StepIntoRaiseException( );

	// Setjmp/Longjmp
	BOOL LJMP_StepIntoLongJmp( );

// utilities

};

#endif //__NLGcase_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\nlg\nlgcase.h ===
///////////////////////////////////////////////////////////////////////////////
//	NLGcase.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CNLGIDETest Class
//

#ifndef __NLGcase_H__
#define __NLGcase_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\dbgtestbase.h"
#include "nlgsub.h"

///////////////////////////////////////////////////////////////////////////////
//	CNLGIDETest class

class CNLGIDETest : public CDbgTestBase
{
	DECLARE_TEST(CNLGIDETest, CNLGSubSuite)

// Attributes
public:

// Operations
public:
	virtual void PreRun(void);
	virtual void Run();

	BOOL IsUnhandledException(CString except_text);

// Test Cases
protected:
	// EH
	BOOL EH_StepOverThrow( );
	BOOL EH_TryNoThrow( );
	BOOL EH_StepOverTry_StepOverCatch( );
	BOOL EH_StepOverReThrow( );
	BOOL EH_BreakInCatch( );
	BOOL EH_StepOverThrowFunc( );
	BOOL EH_StepOutThrowFunc( );
	BOOL EH_StepToCursorOverThrowIntoCatch( );
	BOOL EH_BreakInCtor( );
	BOOL EH_BreakInDtor( );

	// SEH
	BOOL SEH_TryNoException( );
	BOOL SEH_ExceptionContinueExecution( );
	BOOL SEH_ExceptionExecuteHandler( );
	BOOL SEH_TryFinallyNoException( );
	BOOL SEH_TryFinallyException( );
	BOOL SEH_BreakInFilter( );
	BOOL SEH_StepOver__try( );
	BOOL SEH_BreakInExcept( );
	BOOL SEH_BreakInFinally( );
	BOOL SEH_StepToCursorOver__tryIntoExcept( );
	BOOL SEH_StepToCursorOver__tryIntoFinally( );

	// Setjmp/Longjmp
	BOOL LJMP_StepOverLongJmp( );
	BOOL LJMP_StepOverFuncWithLongJmp( );
	BOOL LJMP_StepOutFuncWithLongJmp( );

// utilities

};

#endif //__NLGcase_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\namespce\namecase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	Namecase.CPP
//											 
//	Created by :			
//		VCBU QA		
//
//	Description :								 
//		TestWizard Generated script.	 

#include "stdafx.h"
#include "Namecase.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
										   
IMPLEMENT_TEST(CNameSpceIDETest, CDbgTestBase, "Namespace", -1, CNameSpceSubSuite)

												 
void CNameSpceIDETest::PreRun(void)
	{
	// call the base class
	CTest::PreRun();
	}


void CNameSpceIDETest::Run(void)
	
	{
	/******************
	 * INITIALIZATION *
	 ******************/
	//if(!InitProject("namspace\\namspace", PROJECT_XBE))
	if(!CreateXboxProjectFromSource("namespace", "src\\namspace", "namspace.cpp"))
	{
		m_pLog->RecordInfo("ERROR: could not init namspace project");
		return;
	}

	// this is the initial state each test expects.
	//	  - step passed prolog of main().
	if(!dbg.StepOver(2))
	{
		m_pLog->RecordInfo("ERROR: could not step passed main()'s prolog");
		return;
	}

	/*********
	 * TESTS *
	 *********/
	EvaluateNamespaceFuncOutsideNamespace();
	EvaluateNamespaceVarOutsideNamespace();
	EvaluateNestedNamespaceVarOutsideNamespace();
	EvaluateNamespaceMemberInsideNamespace();
	GoToLocationBpOnNamespaceFunc();
	GoToDataBpOnNamespaceVar();
	NavigateMemoryWndToNamespaceVar();
	VerifyReturnValueInfoIncludesNamespace();
	NavigateStackOutOfAndBackIntoNamespaceFunc();
	ImplicitlyReferenceNamespaceMemberAfterUsingDirective();
	ImplicitlyReferenceNamespaceMemberInsideNamespace();
	} 


/************************************************************************
 * evaluate explicitly referenced namespace variable outside namespace. *
 ************************************************************************/
void CNameSpceIDETest::EvaluateNamespaceVarOutsideNamespace(void)
	{
	LogTestHeader("EvaluateNamespaceVarOutsideNamespace");
	EXPECT_TRUE(cxx.ExpressionValueIs("n1::i", 1));
	}


/******************************************************
 * evaluate explicitly referenced namespace function. *
 ******************************************************/
void CNameSpceIDETest::EvaluateNamespaceFuncOutsideNamespace(void)
	{
	LogTestHeader("EvaluateNamespaceFuncOutsideNamespace");
	EXPECT_TRUE(cxx.ExpressionValueIs("n1::func()", "<void>"));
	}


/*************************************************************
 * evaluate explicitly referenced nested namespace variable. *
 *************************************************************/
void CNameSpceIDETest::EvaluateNestedNamespaceVarOutsideNamespace(void)
	{
	LogTestHeader("EvaluateNestedNamespaceVarOutsideNamespace");
	EXPECT_TRUE(cxx.ExpressionValueIs("n1::n2::i", 2));
	}


/*********************************************************************
 * evaluate explicitly referenced namespace member inside namespace. *
 *********************************************************************/
void CNameSpceIDETest::EvaluateNamespaceMemberInsideNamespace(void)
	{
	LogTestHeader("EvaluateNamespaceMemberInsideNamespace");
	// step into namespace function (n1::func()).
	EXPECT_TRUE(src.Find("func();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE(cxx.ExpressionValueIs("n1::i", 1));
	// restore stack to initial state.
	EXPECT_TRUE(dbg.StepOut());
	}


/********************************************************************************
 * set location bp on explicitly referenced namespace function, go, verify hit. *
 ********************************************************************************/
void CNameSpceIDETest::GoToLocationBpOnNamespaceFunc(void)
	
	{
	LogTestHeader("GoToLocationBpOnNamespaceFunc");
	EXPECT_TRUE(dbg.Restart());
	EXPECT_VALIDBP(bps.SetBreakpoint("n1::func"));

	if(0) //GetUserTargetPlatforms() == PLATFORM_WIN32_MIPS || GetUserTargetPlatforms() == PLATFORM_WIN32_ALPHA)	
		dbg.Go();
	else
		{EXPECT_TRUE(dbg.Go(NULL, "first line of n1::func()"));}
	
	// restore stack and bp list to initial state.
	EXPECT_TRUE(dbg.StepOut());
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	}


/****************************************************************************
 * set data bp on explicitly referenced namespace variable, go, verify hit. *
 ****************************************************************************/
void CNameSpceIDETest::GoToDataBpOnNamespaceVar(void)
	{
	LogTestHeader("GoToDataBpOnNamespaceVar");
	EXPECT_TRUE(dbg.Restart());
	EXPECT_VALIDBP(bps.SetBreakOnExpr("n1::j", COBP_TYPE_IF_EXP_CHANGED));
	EXPECT_TRUE(dbg.Go(NULL, "line after n1::j changed"));
	// restore bp list to initial state.
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	}


/***********************************************************************
 * navigate memory window to explicitly referenced namespace variable. *
 ***********************************************************************/
void CNameSpceIDETest::NavigateMemoryWndToNamespaceVar(void)
	{
	LogTestHeader("NavigateMemoryWndToNamespaceVar");
	EXPECT_TRUE(mem.MemoryDataIs("n1::i", 1));
	RestoreFocusToSrcWnd();
	}


/**************************************************************************************
 * verify return value info includes namespace when stepping over namespace function. *
 **************************************************************************************/
void CNameSpceIDETest::VerifyReturnValueInfoIncludesNamespace(void)
	{
	LogTestHeader("VerifyReturnValueInfoIncludesNamespace");
	// step over namespace function (n1::func()).
	EXPECT_TRUE(src.Find("func();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.SetPane(PANE_AUTO));
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, ROW_LAST, 1));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "void", "n1::func returned", "<void>");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}


/******************************************************
 * navigate stack into and out of namespace function. *
 ******************************************************/
/***********************************************************************
 * verify stack window includes namespace when for namespace function. *
 ***********************************************************************/
void CNameSpceIDETest::NavigateStackOutOfAndBackIntoNamespaceFunc(void)
	
	{
	LogTestHeader("NavigateStackOutOfAndBackIntoNamespaceFunc");
	
	// step into namespace function (n1::func()).
	EXPECT_TRUE(src.Find("func();"));
	EXPECT_TRUE(dbg.SetNextStatement());

	if(0) //GetUserTargetPlatforms() == PLATFORM_WIN32_MIPS || GetUserTargetPlatforms() == PLATFORM_WIN32_ALPHA)	
		{EXPECT_TRUE(dbg.StepInto(2));}
	else
		{EXPECT_TRUE(dbg.StepInto(3));}

	// navigate to main() and back to namespace function.
	EXPECT_TRUE(stk.NavigateStack(1)>0);
	EXPECT_TRUE(stk.NavigateStack(0)>0);
	EXPECT_TRUE(stk.CurrentFunctionIs("n1::func()"));

	// verify locals pane updated.
	uivar.Activate();
	EXPECT_SUCCESS(uivar.SetPane(PANE_LOCALS));
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "local", "3");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));

	// restore stack to initial state.
	EXPECT_TRUE(dbg.StepOut());
	RestoreFocusToSrcWnd();
	}


/***********************************************************
 * verify debugger doesnt recognize implicitly referenced *
 * namespace member after using directive.                 *
 ***********************************************************/
void CNameSpceIDETest::ImplicitlyReferenceNamespaceMemberAfterUsingDirective(void)
	{
	LogTestHeader("ImplicitlyReferenceNamespaceMemberAfterUsingDirective");
	// should evaluate ::i instead of n1::i.
	EXPECT_TRUE(cxx.ExpressionValueIs("i", 0));
	}


/**********************************************************************************************
 * verify debugger doesnt recognize implicitly referenced namespace member inside namespace. *
 **********************************************************************************************/
void CNameSpceIDETest::ImplicitlyReferenceNamespaceMemberInsideNamespace(void)
	{
	LogTestHeader("ImplicitlyReferenceNamespaceMemberInsideNamespace");
	// step into namespace function (n1::func()).	
	EXPECT_TRUE(src.Find("func();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepInto());
	// should evaluate ::i instead of n1::i.
	EXPECT_TRUE(cxx.ExpressionValueIs("i", 0));
	// restore stack to initial state.
	EXPECT_TRUE(dbg.StepOut());
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\nlg\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\nlg\nlgsub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CNLGSubSuite class
//

#include "stdafx.h"
#include "NLGsub.h"
#include "afxdllx.h"

#include "NLGcase.h"
#include "NLGcase2.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;


/////////////////////////////////////////////////////////////////////////////
// CNLGSubSuite

IMPLEMENT_SUBSUITE(CNLGSubSuite, CIDESubSuite, "Non-Local Goto", "VCQA Debugger")

BEGIN_TESTLIST(CNLGSubSuite)
	TEST(CNLGIDETest, RUN)
	TEST(CNLG2IDETest, RUN)
END_TESTLIST()

void CNLGSubSuite::CleanUp(void)
	{
	::CleanUp("nlg");
	::CleanUp("seh01");
	}

///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\nlg\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\nlg\nlgcase2.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	NLGcase2.CPP
//											 
//	Created by :			
//		VCBU QA		
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "NLGcase2.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
											   
IMPLEMENT_TEST(CNLG2IDETest, CDbgTestBase, "NonLocalGoto Special", -1, CNLGSubSuite)
												 
void CNLG2IDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

void CNLG2IDETest::Run()
{	 
	XSAFETY;
	SetProject("nlg\\nlg", PROJECT_XBE);
	XSAFETY;

	// EH
#ifdef DO_EH_CASES
	EH_StepIntoThrow( );
	XSAFETY;
/* bug # 9231postponed till after V50
	EH_StepIntoReThrow( );
	XSAFETY;
*/


//	EH_CatchInDLL( );  // plan to do it
//	XSAFETY;
//	EH_CatchFromDLL( );
//	XSAFETY;
//	EH_ReThrowInCtor( );  // may do it later
//	XSAFETY;
#endif

	if(1) //xbox if( GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{
	// Setjmp/Longjmp
		LJMP_StepIntoLongJmp( );
		XSAFETY;
	
	// SEH
		SetProject("seh01\\seh01", PROJECT_XBE);
		XSAFETY;
/* bug # 9263  */
		SEH_StepIntoRaiseException( );  // too weird on Chicago: no CRT support
		XSAFETY;
		SEH_ExceptionContinueSearch( );
		XSAFETY;
	}
}
 
///////////////////////////////////////////////////////////////////////////////
//	Test Cases
///////////////////////////////////////////////////////////////////////////////


// EH

BOOL CNLG2IDETest::EH_StepIntoThrow( )
{
	LogTestHeader( "EH_StepIntoThrow" );
   	bps.ClearAllBreakpoints();
 	bps.SetBreakpoint("Case3");
	dbg.Go("Case3");
	int nSteps = 4;
	int i;

	EXPECT_TRUE( dbg.StepOver(nSteps, NULL, "throw t;") );
	EXPECT_TRUE(dbg.StepInto(1, NULL, "ThrowObject::ThrowObject( const ThrowObject& src) {"));
	EXPECT_TRUE(dbg.StepOut(1, NULL, "throw t;"));
	EXPECT_TRUE(dbg.StepInto(1, NULL, NULL, NULL, 0));

	if( WaitMsgBoxText("Directory does not exist", 10))
	{
		MST.WButtonClick( "OK" );
		while(MST.WFndWndC("Directory does not exist", "Static", FW_PART));
	}
	if (MST.WFndWnd("Browse for Folder", FW_NOCASE | FW_FOCUS | FW_PART)
		|| MST.WFndWnd("Find Source", FW_NOCASE | FW_FOCUS | FW_PART))
		MST.WButtonClick( "Cancel" );
	
	if ( !stk.CurrentFunctionIs( "eh01()" )	)
	{
		MST.DoKeys("{up}");
		EXPECT_TRUE( dbg.CurrentLineIs( "_CxxThrowException:" ) && stk.CurrentFunctionIs( "_CxxThrowException" ) );

		EXPECT_TRUE( dbg.StepOut(1, NULL, NULL, NULL, 0) );

		if( GetSystem() & SYSTEM_WIN ) 
		{
			for (i = 0; i < 9; i++)
			{
				if( WaitMsgBoxText("Directory does not exist", 10))
				{
					MST.WButtonClick( "OK" );
					while(MST.WFndWndC("Directory does not exist", "Static", FW_PART));
				}
				if (MST.WFndWnd("Browse for Folder", FW_NOCASE | FW_FOCUS | FW_PART)
					|| MST.WFndWnd("Find Source", FW_NOCASE | FW_FOCUS | FW_PART))
				{
					MST.WButtonClick( "Cancel" );
					dbg.StepOut(1, NULL, NULL, NULL, 0);
				}
			}
		}
		dbg.SetSteppingMode(SRC); 
	}

	EXPECT_TRUE( dbg.CurrentLineIs( "catch( ... ){ // after Case3" ) );

	EXPECT_TRUE(dbg.VerifyNotification("First-Chance Exception in nlg.exe", 2, 20, TRUE));
	dbg.SetSteppingMode(SRC);

	dbg.StopDebugging();
	return TRUE;
}

BOOL CNLG2IDETest::EH_StepIntoReThrow( )
{
	LogTestHeader( "EH_StepIntoReThrow" );
   	bps.ClearAllBreakpoints();
 	bps.SetBreakpoint("Case7");
	dbg.Go("Case7");

	int nSteps = 6;
	EXPECT_TRUE( dbg.StepOver(nSteps, NULL, "throw t;") );

	nSteps = 2;
	EXPECT_TRUE( dbg.StepOver(nSteps, NULL, "throw;") );

	EXPECT_TRUE(dbg.StepInto(1, NULL, NULL, NULL, 0));

/*	if( GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{
		if( WaitMsgBoxText("Directory does not exist", 10))
		{
			MST.WButtonClick( "OK" );
			while(MST.WFndWndC("Directory does not exist", "Static", FW_PART));
		}
		if (MST.WFndWndWait("Browse for Folder", FW_NOCASE | FW_FOCUS | FW_PART, 1)
			|| MST.WFndWndWait("Find Source", FW_NOCASE | FW_FOCUS | FW_PART, 1))
				MST.WButtonClick( "Cancel" );
	
		MST.DoKeys("{up}");
		EXPECT_TRUE( dbg.CurrentLineIs( "_CxxThrowException:" ) );

		EXPECT_TRUE(dbg.StepOut(1, NULL, NULL, NULL, 0) );
		if( WaitMsgBoxText("Directory does not exist", 10))
		{
			MST.WButtonClick( "OK" );
			while(MST.WFndWndC("Directory does not exist", "Static", FW_PART));
		}
		if (MST.WFndWndWait("Browse for Folder", FW_NOCASE | FW_FOCUS | FW_PART, 1)
			|| MST.WFndWndWait("Find Source", FW_NOCASE | FW_FOCUS | FW_PART, 1))
				MST.WButtonClick( "Cancel" );

//		EXPECT_TRUE(dbg.StepOut(3, NULL, NULL, NULL, 0) && dbg.SetSteppingMode(SRC) );
	 	bps.SetBreakpoint("{,eh02.cpp,}.49");
		dbg.Go(NULL, NULL, NULL, 0);
		dbg.SetSteppingMode(SRC);
		MST.WFndWnd("eh02.cpp", FW_NOCASE | FW_FOCUS | FW_PART);
		MST.DoKeys("{up}");
	} 
*/	
	EXPECT_TRUE( dbg.CurrentLineIs( "catch( ThrowObject o ) {" ) );
 	
	EXPECT_TRUE(dbg.VerifyNotification("First-Chance Exception in nlg.exe", 8, 20, TRUE));

	dbg.StopDebugging();
	return TRUE;
}



BOOL CNLG2IDETest::EH_CatchInDLL( )
{
	return TRUE;
}

BOOL CNLG2IDETest::EH_CatchFromDLL( )
{
	return TRUE;
}


//BOOL CNLG2IDETest::EH_ReThrowInCtor( )
//{
//	LogTestHeader( "EH_ReThrowInCtor" );
//	dbg.Restart();
//   	bps.SetBreakpoint("{,ehutil.cpp,}.23");		// throw in Ctor
//	EXPECT_TRUE( dbg.Go(NULL, "throw m_i;") );
// 	EXPECT_TRUE( stk.CurrentFunctionIs( "ThrowObject::ThrowObject()" ) );
//	CString func = stk.GetFunction(1);
//	EXPECT_TRUE( func.Find( "Case8()" ) != -1 );
//
//	EXPECT_TRUE( dbg.Go(NULL, "m_i = i;") );
//	EXPECT_TRUE( stk.CurrentFunctionIs( "ThrowObject::ThrowObject(int 1)" ) );
//	func = stk.GetFunction(1);
//	EXPECT_TRUE( func.Find( "Case8()" ) != -1 );
//
//	EXPECT_TRUE(dbg.StepOver(1, NULL, "++counter; // Should execute"));
//	EXPECT_TRUE( stk.CurrentFunctionIs( "Case8() line 58" ) );
//
//	// F10 n times should get to line 68 in eh01.cpp
//   	EXPECT_TRUE(dbg.StepOver(2));
//	if( WaitMsgBoxText( "Browse for Folder", 10 ) )
//			MST.WButtonClick( "Cancel" );
//
//	// Verify we are in DAM 
// 	UIDAM dam;
//	EXPECT_TRUE( dam.IsActive() );
//	
//	EXPECT_TRUE( dbg.CurrentLineIs( "__NLG_Return" ) )
//   	func = stk.GetFunction(0);
//	EXPECT_TRUE( func.Find( "_CallSettingFrame" ) != -1 );
//   	func = stk.GetFunction(1);
//	EXPECT_TRUE( func.Find( "eh01()" ) != -1 );
//   	EXPECT_TRUE(bps.SetBreakpoint("{eh01}.64");
//	EXPECT_TRUE( dbg.Go(NULL, "catch( ... ) {") );
//	EXPECT_TRUE(dbg.StepOver(1, NULL, "++caseNum; // Should execute"));
//
////	EXPECT_TRUE( src.GetCurrentLine() == 68 );
//
//   	bps.ClearAllBreakpoints();
//
//	return TRUE;
//}


// SEH

BOOL CNLG2IDETest::SEH_ExceptionContinueSearch( )
{
 	LogTestHeader( "SEH_ExceptionContinueSearch" );
  	bps.ClearAllBreakpoints();
	bps.SetBreakpoint("SehCase5");
	dbg.Go("SehCase5");
	EXPECT_TRUE(dbg.StepOver(4, NULL, "IntDivideByZero();"));
	EXPECT_TRUE(dbg.StepOver(1, NULL, NULL, NULL, 0));
	EXPECT_TRUE( IsUnhandledException("Integer Divide by Zero") );
	EXPECT_TRUE( dbg.VerifyNotification("Integer Divide by Zero", 6, 20, TRUE) );
	dbg.SetSteppingMode(SRC);
	EXPECT_TRUE( dbg.CurrentLineIs( "k = i/j;" ) );
	MST.DoKeys("{down}");
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver(1, NULL, "++counter;"));

	// processor pack code-gen difference.
	if(1) //xbox - CMDLINE->GetBooleanValue("PP", FALSE))
		{EXPECT_TRUE(dbg.StepOver(1, NULL, "++counter; // should execute"));}
	else
		{EXPECT_TRUE(dbg.StepOver(2, NULL, "++counter; // should execute"));}

	dbg.StopDebugging();
	return TRUE;
}


BOOL CNLG2IDETest::SEH_StepIntoRaiseException( )
{
 	LogTestHeader( "SEH_StepIntoRaiseException" );
  	bps.ClearAllBreakpoints();
	bps.SetBreakpoint("SehCase3");
	dbg.Go("SehCase3");
	dbg.SetSteppingMode(SRC);
	EXPECT_TRUE(dbg.StepInto(4, NULL, "RaiseIntDivideByZero();"));
	EXPECT_TRUE(dbg.StepInto(1, "RaiseIntDivideByZero"));
	//xbox - EXPECT_TRUE(dbg.StepInto(3, NULL, "++counter; // Should continue here"));
	// emmang@xbox.com - we can't really step into the RaiseException() call;
	// on VC, the StepInto behaves just like a StepOver because it is a 
	// call to the kernel.  On Xbox, we can really step into it because
	// it is merely a lib call, but if we do we get a Find Source dlg box
	EXPECT_TRUE(dbg.StepOver(3, NULL, "++counter; // Should continue here"));


	// processor pack code-gen difference.
	if(1) //xbox - CMDLINE->GetBooleanValue("PP", FALSE))
		{EXPECT_TRUE(dbg.StepInto(1, NULL, "++counter; // should execute"));}
	else
		{EXPECT_TRUE(dbg.StepInto(2, NULL, "++counter; // should execute"));}

	bps.SetBreakpoint("SehCase4");
	dbg.Go("SehCase4");
	EXPECT_TRUE(dbg.StepInto(5, "IntDivideByZero"));
	EXPECT_TRUE(dbg.StepInto(4, NULL, "__except( ++counter, ExecuteHandler() ) {"));
	EXPECT_TRUE(dbg.StepInto(1, NULL, "++counter; // should execute"));
	bps.ClearAllBreakpoints();
	dbg.StopDebugging();
	return TRUE;
}


// Setjmp/Longjmp

BOOL CNLG2IDETest::LJMP_StepIntoLongJmp( )
{
 	LogTestHeader( "LJMP_StepIntoLongJmp" );
 	bps.ClearAllBreakpoints();
 	bps.SetBreakpoint("{,ljmp01.cpp,}.32");
	dbg.SetSteppingMode(SRC);

	// xbox additions
	EXPECT_TRUE(dbg.StepInto()); // begin debugging
	EXPECT_TRUE(dbg.StepOver()); // skip the opening bracket
	EXPECT_TRUE(dbg.SetNextStatement("ljmp01();"));

	EXPECT_TRUE( dbg.Go(NULL, "longjmp( mark, -1 );") );
	
	EXPECT_TRUE(dbg.StepInto(1, NULL, NULL, NULL, 0));

	if( WaitMsgBoxText("Directory does not exist", 10))
	{
		MST.WButtonClick( "OK" );
		while(MST.WFndWndC("Directory does not exist", "Static", FW_PART));
	}
	if (MST.WFndWndWait("Browse for Folder", FW_NOCASE | FW_FOCUS | FW_PART, 1)
		|| MST.WFndWndWait("Find Source", FW_NOCASE | FW_FOCUS | FW_PART, 1))
			MST.WButtonClick( "Cancel" );
	if ( stk.CurrentFunctionIs( "ljmp01()" ) )
	{
		EXPECT_TRUE( dbg.CurrentLineIs( "jmpret = setjmp( mark );" ) );
	}
	else
	{
		EXPECT_TRUE( stk.CurrentFunctionIs( "_longjmp()" ) );

		EXPECT_TRUE(dbg.StepOut(1, NULL, NULL, NULL, 0) && 
				dbg.SetSteppingMode(SRC) && 
				dbg.CurrentLineIs( "jmpret = setjmp( mark );" ) );
	}

	return TRUE;
}


BOOL CNLG2IDETest::IsUnhandledException(CString except_text)
{
	if( WaitMsgBoxText( except_text, 10 ) )
	{
		MST.WButtonClick( "OK" );
		return TRUE;
	}
	else
		return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\registers\regsub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CRegistersSubSuite class
//

#include "stdafx.h"
#include "Regsub.h"
#include "afxdllx.h"
#include "..\..\DbgTestBase.h"

#include "Regcase.h"
#include "RegistersPP.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CRegistersSubSuite

IMPLEMENT_SUBSUITE(CRegistersSubSuite, CIDESubSuite, "Registers", "VCQA Debugger")

BEGIN_TESTLIST(CRegistersSubSuite)
	TEST(CRegistersIDETest, RUN)
	TEST(CRegistersPP, RUN)
END_TESTLIST()

void CRegistersSubSuite::CleanUp(void)
	{
	::CleanUp("testgo01");
	}

///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization

void CRegistersSubSuite::SetUp(BOOL bCleanUp)

{
	CIDESubSuite::SetUp(bCleanUp);
	// TODO(michma - 9/2/98): re-enable when memory leak bugs are fixed.
	ExpectedMemLeaks(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\registers\regsub.h ===
///////////////////////////////////////////////////////////////////////////////
//	Regsub.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CRegistersSubSuite class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CRegistersSubSuite class

class CRegistersSubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CRegistersSubSuite)
//	CRegistersSubSuite() { m_strName = "TestWizard Generated script"; m_strOwner = "VCBU QA"; }


	DECLARE_TESTLIST()
protected:
	void CleanUp(void);
	void SetUp(BOOL bCleanUp);
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\nlg\nlgsub.h ===
///////////////////////////////////////////////////////////////////////////////
//	NLGsub.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CNLGSubSuite class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CNLGSubSuite class

class CNLGSubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CNLGSubSuite)
//	CNLGSubSuite() { m_strName = "TestWizard Generated script"; m_strOwner = "VCBU QA"; }


	DECLARE_TESTLIST()
protected:
	void CleanUp(void);
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\nlg\nlgcase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	NLGcase.CPP
//											 
//	Created by :			
//		VCBU QA		
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "NLGcase.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
											   
IMPLEMENT_TEST(CNLGIDETest, CDbgTestBase, "NonLocalGoto Base", -1, CNLGSubSuite)

#define MSCPP_EXCEPTION "Microsoft C++ Exception"
	
CString GetLocExceptString(LPCSTR strExe)
{
	CString strTemp;
	if (GetLang() == CAFE_LANG_JAPANESE)
	{
		strTemp.Format("O ()  %s", strExe);
	}
	else
		strTemp.Format("First-chance exception in %s", strExe);

	return strTemp;
}

void CNLGIDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

void CNLGIDETest::Run()
{	 
	XSAFETY;
	SetProject("nlg\\nlg", PROJECT_XBE);
	XSAFETY;

	if (1) // bug in xbox CRT means skip exception handling for now
	{
		// EH
		EH_StepOverThrow( );
		XSAFETY;
		EH_TryNoThrow( );
		XSAFETY;
		EH_StepOverTry_StepOverCatch( );
		XSAFETY;

		//if( GetSystem() != SYSTEM_CHICAGO )  // bug #10127
		/* bug # 9231  postponed till after V50
		EH_StepOverReThrow( );
		XSAFETY;
		*/

		EH_BreakInCatch( );
		XSAFETY;
		EH_StepOverThrowFunc( );
		XSAFETY;
		EH_StepOutThrowFunc( );
		XSAFETY;
		EH_StepToCursorOverThrowIntoCatch( );
		XSAFETY;
		EH_BreakInCtor( );
		XSAFETY;
		EH_BreakInDtor( );
		XSAFETY;
	}

	if (1)
	{
		// Setjmp/Longjmp
		LJMP_StepOverLongJmp( );
		XSAFETY;
		LJMP_StepOverFuncWithLongJmp( );
		XSAFETY;
		LJMP_StepOutFuncWithLongJmp( );
		XSAFETY;
	}
	
        
	// SEH
	if (1)
	{
		SetProject("seh01\\seh01", PROJECT_XBE);
		XSAFETY;
		SEH_TryNoException( );
		XSAFETY;
		SEH_ExceptionContinueExecution( );
		XSAFETY;
		SEH_ExceptionExecuteHandler( );
		XSAFETY;

		SEH_TryFinallyNoException( );
		XSAFETY;

		SEH_TryFinallyException( ); 
		XSAFETY;
 
		/* bug # 9258 postponed till after V50
		SEH_BreakInFilter( );
		XSAFETY;
		*/
		SEH_StepOver__try( );
		XSAFETY;
		SEH_BreakInExcept( );
		XSAFETY;
		SEH_BreakInFinally( );
		XSAFETY;
		SEH_StepToCursorOver__tryIntoExcept( );
		XSAFETY;
		SEH_StepToCursorOver__tryIntoFinally( );
		XSAFETY;
	}

}
 
///////////////////////////////////////////////////////////////////////////////
//	Test Cases
///////////////////////////////////////////////////////////////////////////////


// EH

BOOL CNLGIDETest::EH_StepOverThrow( )
{
	LogTestHeader( "EH_StepOverThrow" );
   	bps.ClearAllBreakpoints();
 	bps.SetBreakpoint("Case1");
	dbg.Go("Case1");
	dbg.SetSteppingMode(SRC);
	MST.DoKeys("{down 3}");

	EXPECT_TRUE( dbg.StepToCursor(0,NULL,"throw t;")	 )	;

	EXPECT_TRUE(dbg.StepOver(1, NULL, "catch( ... ) // after Case1"));

	if(1) //xbox GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{
		EXPECT_TRUE(dbg.VerifyNotification(GetLocExceptString("nlg.xbe"), 1, 20, TRUE) &&
					dbg.VerifyNotification(MSCPP_EXCEPTION, 1, 20, TRUE) );
	}
	dbg.StopDebugging();
	return TRUE;
}


BOOL CNLGIDETest::EH_TryNoThrow( )
{
 	LogTestHeader( "EH_TryNoThrow" );
  	bps.ClearAllBreakpoints();
	bps.SetBreakpoint("Case2");
	dbg.Go("Case2");
	int nSteps;

	/*xbox
	switch(GetUserTargetPlatforms())
	{
		case PLATFORM_WIN32_X86:
			// processor pack code-gen difference.
			if(CMDLINE->GetBooleanValue("PP", FALSE))
				nSteps = 3;
			else
				nSteps = 4;
			break;
        case PLATFORM_WIN32_ALPHA:
            nSteps = 4;
            break;
	}
	*/
	nSteps = 4; //xbox - we always use the processor pack (changed 3/27/2001)

	EXPECT_TRUE( dbg.StepOver(nSteps, NULL, "++counter; // Should execute") );
	EXPECT_TRUE( dbg.StepOver(1, NULL, "}") );
	
	return TRUE;
}

BOOL CNLGIDETest::EH_StepOverTry_StepOverCatch( )
{
 	LogTestHeader( "EH_StepOverTry_StepOverCatch" );
  	bps.ClearAllBreakpoints();
   	bps.SetBreakpoint("Case4");
	dbg.Go("Case4");
	dbg.SetSteppingMode(SRC);
	EXPECT_TRUE(dbg.StepOver(1, NULL, "try { ++counter; ThrowObject t(4); throw t; }"));

	EXPECT_TRUE(dbg.StepOver(1, NULL, "catch( ThrowObject c ) { ++counter; /* Should execute */ }"));
	if(1) //xbox GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{
		EXPECT_TRUE( dbg.VerifyNotification(MSCPP_EXCEPTION, 3, 20, TRUE) );
		dbg.SetSteppingMode(SRC);
		MST.WFndWnd("eh01.cpp", FW_NOCASE | FW_FOCUS | FW_PART);
	}

	// changed 1 to 2 (emmang@xbox)
	EXPECT_TRUE(dbg.StepOver(2, NULL, "++counter; // Should execute"));

	dbg.StopDebugging();
  	return TRUE;
}


BOOL CNLGIDETest::EH_StepOverReThrow( )
{
 	LogTestHeader( "EH_StepOverReThrow" );
  	bps.ClearAllBreakpoints();
 	bps.SetBreakpoint("Case6");
	dbg.Go("Case6");
	dbg.SetSteppingMode(SRC);
	int nSteps = 6;
	EXPECT_TRUE( dbg.StepOver(nSteps, NULL, "throw t;") );
	EXPECT_TRUE(dbg.StepOver(3, NULL, "throw c;"));

/*	if( GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{ 
		EXPECT_TRUE(dbg.StepOver(1, NULL, NULL, NULL, 0));
	
		if( WaitMsgBoxText("Directory does not exist", 10))
		{
			MST.WButtonClick( "OK" );
			while(MST.WFndWndC("Directory does not exist", "Static", FW_PART));
		}
		if (MST.WFndWnd("Browse for Folder", FW_NOCASE | FW_FOCUS | FW_PART)
			|| MST.WFndWnd("Find Source", FW_NOCASE | FW_FOCUS | FW_PART))
				MST.WButtonClick( "Cancel" );
	
		EXPECT_TRUE( stk.CurrentFunctionIs( "CallCatchBlock" ) );
		
		EXPECT_TRUE(dbg.StepOut(1, NULL, NULL, NULL, 0) );
		if( WaitMsgBoxText("Directory does not exist", 10))
		{
			MST.WButtonClick( "OK" );
			while(MST.WFndWndC("Directory does not exist", "Static", FW_PART));
		}
		if (MST.WFndWnd("Browse for Folder", FW_NOCASE | FW_FOCUS | FW_PART)
			|| MST.WFndWnd("Find Source", FW_NOCASE | FW_FOCUS | FW_PART))
				MST.WButtonClick( "Cancel" );
		int i;
		for(i = 0; i< 5; i++)
		{ 
			if (MST.WFndWndWait("Browse for Folder", FW_NOCASE | FW_FOCUS | FW_PART, 1)
				|| MST.WFndWndWait("Find Source", FW_NOCASE | FW_FOCUS | FW_PART, 1))
					MST.WButtonClick( "Cancel" );
		}

		EXPECT_TRUE(dbg.StepOut(1, NULL, NULL, NULL, 0) );

		for(i = 0; i< 5; i++)	// WinslowF - to handle multiple dlg boxes on NT
		{ 
			if (MST.WFndWndWait("Browse for Folder", FW_NOCASE | FW_FOCUS | FW_PART, 1)
				|| MST.WFndWndWait("Find Source", FW_NOCASE | FW_FOCUS | FW_PART, 1))
					MST.WButtonClick( "Cancel" );
		}

/* Doesn't work for Win95
		EXPECT_TRUE(dbg.StepOut(3, NULL, NULL, NULL, 0) && 
				dbg.SetSteppingMode(SRC) && 
				dbg.CurrentLineIs( "catch( ThrowObject o ) {" ) );
*/
/*	 	bps.SetBreakpoint("{,eh01.cpp,}@157");
		dbg.Go(NULL, NULL, NULL, 0);
		dbg.SetSteppingMode(SRC);
		MST.DoKeys("{up}");
		EXPECT_TRUE( dbg.CurrentLineIs( "catch( ThrowObject o ) {" ) );
	}
	else
	{
*/		EXPECT_TRUE(dbg.StepOver(1, NULL, "catch( ThrowObject o ) {"));
//	}

	if(1) //xbox GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{
		EXPECT_TRUE(dbg.VerifyNotification(GetLocExceptString("nlg.xbe"), 5, 20, TRUE));
		EXPECT_TRUE(dbg.VerifyNotification(MSCPP_EXCEPTION, 6, 20, TRUE) );
		dbg.SetSteppingMode(SRC);
		MST.WFndWnd("eh01.cpp", FW_NOCASE | FW_FOCUS | FW_PART);
	}

//	dbg.StopDebugging();
 	bps.SetBreakpoint("Case7");
	dbg.Go("Case7");

	nSteps = 6;
	EXPECT_TRUE( dbg.StepOver(nSteps, NULL, "throw t;") );

	nSteps = 2;
	EXPECT_TRUE( dbg.StepOver(nSteps, NULL, "throw;") );
	if( GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{
		EXPECT_TRUE(dbg.VerifyNotification(GetLocExceptString("nlg.xbe"), 7, 20, TRUE) );
		dbg.SetSteppingMode(SRC);
		MST.WFndWnd("eh01.cpp", FW_NOCASE | FW_FOCUS | FW_PART);
	}

	EXPECT_TRUE(dbg.StepOver(1, NULL, "catch( ThrowObject o ) {"));
	if( GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{
		EXPECT_TRUE(dbg.VerifyNotification(MSCPP_EXCEPTION, 8, 20, TRUE) );
		dbg.SetSteppingMode(SRC);
	}

	dbg.StopDebugging();
	return TRUE;
}

BOOL CNLGIDETest::EH_BreakInCatch( )
{
 	LogTestHeader( "EH_BreakInCatch" );
	dbg.Restart();
  	bps.ClearAllBreakpoints();
   	bps.SetBreakpoint("{,eh01.cpp,}@20");
   	bps.SetBreakpoint("{,eh01.cpp,}@31");
   	bps.SetBreakpoint("{,eh01.cpp,}@132");
	dbg.SetSteppingMode(SRC);
	EXPECT_TRUE( dbg.Go(NULL, "Case2();") );
	EXPECT_TRUE( dbg.Go(NULL, "Case4();") );
	EXPECT_TRUE( dbg.Go(NULL, "++counter; // Should execute") );

   	bps.ClearAllBreakpoints();

	return TRUE;
}


BOOL CNLGIDETest::EH_StepOverThrowFunc( )
{
 	LogTestHeader( "EH_StepOverThrowFunc" );
    bps.ClearAllBreakpoints();
	dbg.StopDebugging();
  
   	bps.SetBreakpoint("{,eh01.cpp,}@14");	 
	EXPECT_TRUE( dbg.Go(NULL, "Case1();") );

// can't break at catch(){} on MIPS (v-katsuf) 
	EXPECT_TRUE(dbg.StepOver(1, NULL, "catch( ... ) // after Case1"));

   	bps.SetBreakpoint("{,eh01.cpp,}@25");	 
	dbg.SetSteppingMode(SRC);  
	EXPECT_TRUE( dbg.Go(NULL, "Case3();") );

// can't break at catch(){} on MIPS (v-katsuf) 
	EXPECT_TRUE(dbg.StepOver(1, NULL, "catch( ... ){ // after Case3"));

 	bps.SetBreakpoint("{,eh01.cpp,}@31");	 
	dbg.SetSteppingMode(SRC);  
	EXPECT_TRUE( dbg.Go(NULL, "Case4();") );
	EXPECT_TRUE(dbg.StepOver(1, NULL, "++caseNum; // should execute"));

	if(1) //xbox GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{
		EXPECT_TRUE(dbg.VerifyNotification(GetLocExceptString("nlg.xbe"), 3, 20, TRUE) );
	}

   	bps.SetBreakpoint("{,eh01.cpp,}@42");	 
	dbg.SetSteppingMode(SRC);  
	EXPECT_TRUE( dbg.Go(NULL, "Case5();") );
	EXPECT_TRUE(dbg.StepOver(1, NULL, "++caseNum; // should execute"));

   	bps.SetBreakpoint("{,eh01.cpp,}@51");	 
	dbg.SetSteppingMode(SRC);  
	EXPECT_TRUE( dbg.Go(NULL, "Case6();") );
	EXPECT_TRUE(dbg.StepOver(1, NULL, "++caseNum; // should execute"));

   	bps.SetBreakpoint("{,eh01.cpp,}@60");	 // Case7 is in different segment
	dbg.SetSteppingMode(SRC);  
	EXPECT_TRUE( dbg.Go(NULL, "Case7();") );
	EXPECT_TRUE(dbg.StepOver(1, NULL, "++caseNum; // should execute"));
	if(1) //xbox GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{
	EXPECT_TRUE(dbg.VerifyNotification(GetLocExceptString("nlg.xbe"), 7, 20, TRUE) &&
				dbg.VerifyNotification(GetLocExceptString("nlg.xbe"), 9, 20, TRUE) );
	}

    bps.ClearAllBreakpoints();
	dbg.StopDebugging();

	return TRUE;
}

BOOL CNLGIDETest::EH_StepOutThrowFunc( )
{
 	LogTestHeader( "EH_StepOutThrowFunc" );
  	bps.ClearAllBreakpoints();
 	dbg.Restart();
	dbg.SetSteppingMode(SRC);
	bps.SetBreakpoint("Case1");
	dbg.Go("Case1");
	EXPECT_TRUE(dbg.StepOut(1, NULL, "catch( ... ) // after Case1"));
	if(1) //xbox GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{
		EXPECT_TRUE(dbg.VerifyNotification(GetLocExceptString("nlg.xbe"), 1, 20, TRUE) );
	}

	bps.SetBreakpoint("Case3");
	dbg.SetSteppingMode(SRC);  
	dbg.Go("Case3");
	EXPECT_TRUE(dbg.StepOut(1, NULL, "catch( ... ){ // after Case3"));

	bps.SetBreakpoint("Case5");
	dbg.SetSteppingMode(SRC);  
	dbg.Go("Case5");
if (1) //xbox GetUserTargetPlatforms() != PLATFORM_WIN32_ALPHA )			//v-katsuf
//	EXPECT_TRUE(dbg.StepOut(1, NULL, "catch( ThrowObject o )")); // This is by design now.
	EXPECT_TRUE(dbg.StepOut(1, NULL, "++caseNum; // should execute")); 

	if(1) //xbox GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{
		EXPECT_TRUE(dbg.VerifyNotification(GetLocExceptString("nlg.xbe"), 4, 20, TRUE) );
		dbg.SetSteppingMode(SRC);  
		MST.WFndWnd("eh01.cpp", FW_NOCASE | FW_FOCUS | FW_PART);
	}
	
	bps.SetBreakpoint("Case6");
	dbg.Go("Case6");
	if(1) //xbox GetUserTargetPlatforms() != PLATFORM_WIN32_ALPHA) // bug #8481
	{
//		EXPECT_TRUE(dbg.StepOut(1, NULL, "catch( ThrowObject c )")); // This is by design now.
	}
	EXPECT_TRUE(dbg.StepOut(1, NULL, "++caseNum; // should execute")); 
	if(1) //xbox GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{
		EXPECT_TRUE(dbg.VerifyNotification(GetLocExceptString("nlg.xbe"), 5, 20, TRUE) );
//		dbg.SetSteppingMode(SRC);  
//		MST.WFndWnd("eh01.cpp", FW_NOCASE | FW_FOCUS | FW_PART);
	}

// To do : now there is a bug in CRT

	bps.ClearAllBreakpoints();
	dbg.StopDebugging();
	return TRUE;
}

BOOL CNLGIDETest::EH_StepToCursorOverThrowIntoCatch( )
{
	LogTestHeader( "EH_StepToCursorOverThrowIntoCatch" );
	bps.ClearAllBreakpoints();
	dbg.StepInto(1, NULL, NULL, NULL, 0); 
	dbg.SetSteppingMode(SRC);  

	CString strSource = "eh01.cpp";
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource);   //Review yefims
//	file.Open( m_strProjectDir + "\\" + strSource);   
	
	EXPECT_TRUE( dbg.StepToCursor(19, NULL, "++caseNum;") );

	EXPECT_TRUE( dbg.StepToCursor(31, NULL, "Case4();") );
	if(1) //xbox GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{
		EXPECT_TRUE(dbg.VerifyNotification(GetLocExceptString("nlg.xbe"), 2, 20, TRUE) );
		dbg.SetSteppingMode(SRC);  
		MST.WFndWnd(strSource, FW_NOCASE | FW_FOCUS | FW_PART);
	}

	EXPECT_TRUE( dbg.StepToCursor(108, NULL, "catch( ThrowObject c ) { ++counter;") );
	EXPECT_TRUE( dbg.StepToCursor(132, NULL, "++counter; // Should execute") );
	EXPECT_TRUE( dbg.StepToCursor(150, NULL, "throw c;") );

	EXPECT_TRUE( dbg.StepToCursor(157, NULL, "++counter; // Should execute") );
	if(1) //xbox GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{
		EXPECT_TRUE(dbg.VerifyNotification(GetLocExceptString("nlg.xbe"), 6, 20, TRUE) );
		dbg.SetSteppingMode(SRC);  
		MST.WFndWnd(strSource, FW_NOCASE | FW_FOCUS | FW_PART);
	}

	strSource = "eh02.cpp";
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource);   //Review yefims
	EXPECT_TRUE( dbg.StepToCursor(49, NULL, "++counter; // Should execute") );
	if(1) //xbox GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{
		EXPECT_TRUE(dbg.VerifyNotification(GetLocExceptString("nlg.xbe"), 8, 20, TRUE) );
		dbg.SetSteppingMode(SRC);  
	}

	dbg.StopDebugging();

	return TRUE;
}

BOOL CNLGIDETest::EH_BreakInCtor( )
{
 	LogTestHeader( "EH_BreakInCtor" );
    bps.ClearAllBreakpoints();
	dbg.Restart();
   	bps.SetBreakpoint("{,ehutil.cpp,}@10");		// Ctor
	dbg.SetSteppingMode(SRC);

	EXPECT_TRUE( dbg.Go(NULL, "m_i = i;") );
	EXPECT_TRUE( stk.CurrentFunctionIs( "ThrowObject::ThrowObject" ) );
	CString func = stk.GetFunction(1);
	EXPECT_TRUE( func.Find( "Case1()" ) != -1 );
    bps.ClearAllBreakpoints();

   	bps.SetBreakpoint("{,ehutil.cpp,}@16");		// Copy Ctor
	EXPECT_TRUE( dbg.Go(NULL, "m_i = src.m_i;") );
	EXPECT_TRUE( stk.CurrentFunctionIs( "ThrowObject::ThrowObject" ) );
	func = stk.GetFunction(1);
	EXPECT_TRUE( func.Find( "Case1()" ) != -1 );

	EXPECT_TRUE( dbg.Go(NULL, "m_i = src.m_i;") );
	func = stk.GetFunction(1);
	EXPECT_TRUE( func.Find( "Case3()" ) != -1 );

	EXPECT_TRUE( dbg.Go(NULL, "m_i = src.m_i;") );
	func = stk.GetFunction(1);
	EXPECT_TRUE( func.Find( "Case4()" ) != -1 );
	EXPECT_TRUE( dbg.StepOver(1, NULL, NULL, NULL, 0) );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 4) && cxx.ExpressionValueIs("m_iCopy", 1));

   	EXPECT_TRUE( dbg.Go(NULL, "m_i = src.m_i;") );
	func = stk.GetFunction(1);
	if(0) //FrameUnwindToState is for Win32
	{
		EXPECT_TRUE( func.Find( "FrameUnwindToState" ) != -1 );	
	}
	else
	{
		EXPECT_TRUE( func.Find( "BuildCatchObject" ) != -1 );
	}
	EXPECT_TRUE( dbg.StepOver(1, NULL, NULL, NULL, 0) );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 4) && cxx.ExpressionValueIs("m_iCopy", 2));

   	EXPECT_TRUE( dbg.Go(NULL, "m_i = src.m_i;") );
	func = stk.GetFunction(1);
	EXPECT_TRUE( func.Find( "Case5()" ) != -1 );
   
   	EXPECT_TRUE( dbg.Go(NULL, "m_i = src.m_i;") );
	func = stk.GetFunction(1);
	if(0) //FrameUnwindToState is for Win32
	{
		EXPECT_TRUE( func.Find( "FrameUnwindToState" ) != -1 );	//v-katsuf
	}
	else
	{
		EXPECT_TRUE( func.Find( "BuildCatchObject" ) != -1 );
	}
	EXPECT_TRUE( dbg.StepOver(1, NULL, NULL, NULL, 0) );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 5) && cxx.ExpressionValueIs("m_iCopy", 2));

   	EXPECT_TRUE( dbg.Go(NULL, "m_i = src.m_i;") );
	func = stk.GetFunction(1);
	EXPECT_TRUE( func.Find( "Case6()" ) != -1 );
   
   	EXPECT_TRUE( dbg.Go(NULL, "m_i = src.m_i;") );
	func = stk.GetFunction(1);
	if(0) //FrameUnwindToState is for Win32
	{
		EXPECT_TRUE( func.Find( "FrameUnwindToState" ) != -1 );	//v-katsuf
	}
	else
	{
		EXPECT_TRUE( func.Find( "BuildCatchObject" ) != -1 );
	}
	EXPECT_TRUE( dbg.StepOver(1, NULL, NULL, NULL, 0) );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 6) && cxx.ExpressionValueIs("m_iCopy", 2));

   	EXPECT_TRUE( dbg.Go(NULL, "m_i = src.m_i;") );
	func = stk.GetFunction(1);
	EXPECT_TRUE( func.Find( "Case6()" ) != -1 );
   
   	EXPECT_TRUE( dbg.Go(NULL, "m_i = src.m_i;") );
	func = stk.GetFunction(1);
	if(0) //FrameUnwindToState is for Win32
	{
		EXPECT_TRUE( func.Find( "FrameUnwindToState" ) != -1 );	//v-katsuf
	}
	else
	{
		EXPECT_TRUE( func.Find( "BuildCatchObject" ) != -1 );
	}
	EXPECT_TRUE( dbg.StepOver(1, NULL, NULL, NULL, 0) );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 6) && cxx.ExpressionValueIs("m_iCopy", 4));

   	EXPECT_TRUE( dbg.Go(NULL, "m_i = src.m_i;") );
	func = stk.GetFunction(1);
	EXPECT_TRUE( func.Find( "Case7()" ) != -1 );
   
   	EXPECT_TRUE( dbg.Go(NULL, "m_i = src.m_i;") );
	func = stk.GetFunction(1);
	if(0) //FrameUnwindToState is for Win32
	{
		EXPECT_TRUE( func.Find( "FrameUnwindToState" ) != -1 );	//v-katsuf
	}
	else
	{
		EXPECT_TRUE( func.Find( "BuildCatchObject" ) != -1 );
	}
	EXPECT_TRUE( dbg.StepOver(1, NULL, NULL, NULL, 0) );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 7) && cxx.ExpressionValueIs("m_iCopy", 2));

	bps.ClearAllBreakpoints();

	return TRUE;
}

BOOL CNLGIDETest::EH_BreakInDtor( )
{
	LogTestHeader( "EH_BreakInDtor" );
    bps.ClearAllBreakpoints();
	dbg.Restart();
   	bps.SetBreakpoint("{,ehutil.cpp,}@30");		// Dtor
	dbg.SetSteppingMode(SRC);

	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( stk.CurrentFunctionIs( "ThrowObject::~ThrowObject" ) );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 1) && cxx.ExpressionValueIs("m_iCopy", 0));

	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 3) && cxx.ExpressionValueIs("m_iCopy", 0));

	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 4) && cxx.ExpressionValueIs("m_iCopy", 0));

	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 4) && cxx.ExpressionValueIs("m_iCopy", 2));

 	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( stk.CurrentFunctionIs( "ThrowObject::~ThrowObject" ) );
 	CString func;
//	func = stk.GetFunction(1);
	func = stk.GetAllFunctions();
	if(0) //xbox
	{
		EXPECT_TRUE( func.Find( "FrameUnwindToState" ) != -1 );	
	}
	else
	{
		EXPECT_TRUE( func.Find( "__DestructExceptionObject" ) != -1 );
	}
	func = stk.GetAllFunctions();
/*	 code gen was changed ?
	EXPECT_TRUE( func.Find( "eh01() line 32" ) != -1 );
*/
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 4) && cxx.ExpressionValueIs("m_iCopy", 1));

 	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
// 	func = stk.GetFunction(1);
	func = stk.GetAllFunctions();
	if(0) //xbox
	{
		EXPECT_TRUE( func.Find( "FrameUnwindToState" ) != -1 );	//v-katsuf
	}
	else
	{
		EXPECT_TRUE( func.Find( "__DestructExceptionObject" ) != -1 );
	}
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 3) && cxx.ExpressionValueIs("m_iCopy", 1));

	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 1) && cxx.ExpressionValueIs("m_iCopy", 1));

	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 5) && cxx.ExpressionValueIs("m_iCopy", 0));

	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 5) && cxx.ExpressionValueIs("m_iCopy", 2));

 	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 5) && cxx.ExpressionValueIs("m_iCopy", 1));

	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 6) && cxx.ExpressionValueIs("m_iCopy", 0));

	if(1) //xbox GetUserTargetPlatforms() == PLATFORM_WIN32_X86 )
	{
	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 6) && cxx.ExpressionValueIs("m_iCopy", 1));
	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 6) && cxx.ExpressionValueIs("m_iCopy", 2));
	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 6) && cxx.ExpressionValueIs("m_iCopy", 4));
	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 6) && cxx.ExpressionValueIs("m_iCopy", 3));
	}
	else if(0) //xbox GetUserTargetPlatforms() == PLATFORM_WIN32_ALPHA)	
	{
	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 6) && cxx.ExpressionValueIs("m_iCopy", 2));
	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 6) && cxx.ExpressionValueIs("m_iCopy", 1));
	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 6) && cxx.ExpressionValueIs("m_iCopy", 4));
	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 6) && cxx.ExpressionValueIs("m_iCopy", 3));
	}
	else
	{
	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 6) && cxx.ExpressionValueIs("m_iCopy", 2));
	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 6) && cxx.ExpressionValueIs("m_iCopy", 4));
	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 6) && cxx.ExpressionValueIs("m_iCopy", 3));
	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 6) && cxx.ExpressionValueIs("m_iCopy", 1));
	}

 	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 7) && cxx.ExpressionValueIs("m_iCopy", 0));
 	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 7) && cxx.ExpressionValueIs("m_iCopy", 2));
 	EXPECT_TRUE( dbg.Go(NULL, "++dtorCounter;") );
	EXPECT_TRUE( cxx.ExpressionValueIs("m_i", 7) && cxx.ExpressionValueIs("m_iCopy", 1));

    bps.ClearAllBreakpoints();

	return TRUE;
}



// SEH
BOOL CNLGIDETest::SEH_TryNoException( )

{
	LogTestHeader( "SEH_TryNoException" );
   	bps.ClearAllBreakpoints();
 	dbg.Restart();
	bps.SetBreakpoint("SehCase1");
	dbg.SetSteppingMode(SRC);
	dbg.Go("SehCase1");
	EXPECT_TRUE(dbg.StepOver(4, NULL, "RaiseNoException();"));

	// processor pack code-gen difference.
	if(1) //xbox - always true, skip the check CMDLINE->GetBooleanValue("PP", FALSE))
		{EXPECT_TRUE(dbg.StepOver(1, NULL, "++counter; // should execute"));}
	else
		{EXPECT_TRUE(dbg.StepOver(2, NULL, "++counter; // should execute"));}

	EXPECT_TRUE(dbg.StepOver(1, NULL, "}"));
	dbg.StopDebugging();
	return TRUE;
}

BOOL CNLGIDETest::SEH_ExceptionContinueExecution( )

{
 	LogTestHeader( "SEH_ExceptionContinueExecution" );
  	bps.ClearAllBreakpoints();
	bps.SetBreakpoint("SehCase3");
	dbg.Go("SehCase3");
	EXPECT_TRUE(dbg.StepOver(4, NULL, "RaiseIntDivideByZero();"));
	EXPECT_TRUE(dbg.StepOver(1, NULL, "++counter; // Should continue here"));
	EXPECT_TRUE(dbg.VerifyNotification("Integer Divide by Zero", 1, 20, TRUE) );
	dbg.SetSteppingMode(SRC);

	// processor pack code-gen difference.
	if(1) //xbox - always true, skip the check CMDLINE->GetBooleanValue("PP", FALSE))
		{EXPECT_TRUE(dbg.StepOver(1, NULL, "++counter; // should execute"));}
	else
		{EXPECT_TRUE(dbg.StepOver(2, NULL, "++counter; // should execute"));}

	dbg.StopDebugging();
	return TRUE;
}

BOOL CNLGIDETest::SEH_ExceptionExecuteHandler( )
{
 	LogTestHeader( "SEH_ExceptionExecuteHandler" );
  	bps.ClearAllBreakpoints();
	bps.SetBreakpoint("SehCase4");
	dbg.Go("SehCase4");
	EXPECT_TRUE(dbg.StepOver(4, NULL, "IntDivideByZero();"));
	EXPECT_TRUE(dbg.StepOver(1, NULL, "__except( ++counter, ExecuteHandler() ) {"));
	EXPECT_TRUE(dbg.VerifyNotification(GetLocExceptString("seh01.xbe"), 2, 20, TRUE) );
	dbg.SetSteppingMode(SRC);
	EXPECT_TRUE(dbg.StepOver(1, NULL, "++counter; // should execute"));	
	dbg.StopDebugging();
	return TRUE;
}

BOOL CNLGIDETest::SEH_TryFinallyNoException( )

{
	LogTestHeader( "SEH_TryFinallyNoException" );
	bps.ClearAllBreakpoints();
	dbg.StopDebugging();
	bps.SetBreakpoint("SehCase2");
	dbg.SetSteppingMode(SRC);
	dbg.Go("SehCase2");
	EXPECT_TRUE(dbg.StepOver(4, NULL, "RaiseNoException();"));

//	EXPECT_TRUE(dbg.StepOver(2, NULL, "++counter; // should execute")); //bug 9256 postponed

	// processor pack code-gen difference.
	if(1) //xbox - always true, skip the check CMDLINE->GetBooleanValue("PP", FALSE))

	{
 		EXPECT_TRUE(dbg.StepOver(1, NULL, "}"));
		EXPECT_TRUE( stk.CurrentFunctionIs( "SehCase2() line 54" ) );
	}
	else
	{
		dbg.StepOver();
		EXPECT_TRUE(dbg.StepInto(1, NULL, "++counter; // should execute"));
		EXPECT_TRUE( stk.CurrentFunctionIs( "SehCase2() line 52" ) );
 		EXPECT_TRUE(dbg.StepOver(2, NULL, "}"));
	}

	dbg.StopDebugging();
	return TRUE;
}

BOOL CNLGIDETest::SEH_TryFinallyException( )
{
	LogTestHeader( "SEH_TryFinallyException" );
   	bps.ClearAllBreakpoints();
	bps.SetBreakpoint("SehCase6");
	dbg.SetSteppingMode(SRC);
	EXPECT_TRUE( dbg.Go("SehCase6") );
	EXPECT_TRUE(dbg.StepOver(6, NULL, "IntDivideByZero();"));
	EXPECT_TRUE(dbg.StepOver(1, NULL, "++counter; // should execute"));
	EXPECT_TRUE( dbg.VerifyNotification("Integer Divide by Zero", 1, 20, TRUE) );
	dbg.SetSteppingMode(SRC);
	//Warning:  the following line has been changed from a two step to a single stepover
	//It is uncertain if the test was always bad or code generation changed handling in some way
	//So, if you see a failure where "__except( ++counter, ExecuteHandler() is expected but 
	//the cursor is one line short, then a code gen change has occured.
	EXPECT_TRUE(dbg.StepOver(1, NULL, "__except( ++counter, ExecuteHandler() ) {"));
	EXPECT_TRUE(dbg.StepOver(1, NULL, "++counter; // should execute"));
	dbg.StopDebugging();
	return TRUE;
}

BOOL CNLGIDETest::SEH_BreakInFilter( )
{
	LogTestHeader( "SEH_BreakInFilter" );
 	dbg.Restart();
	dbg.SetSteppingMode(SRC);
  	bps.ClearAllBreakpoints();
	EXPECT_TRUE( bps.SetBreakpoint("ContinueExecution") );
	EXPECT_TRUE( bps.SetBreakpoint("ExecuteHandler") );
	EXPECT_TRUE( bps.SetBreakpoint("ContinueSearch") );

	EXPECT_TRUE( dbg.Go("ContinueExecution") );
	EXPECT_TRUE( stk.CurrentFunctionIs( "ContinueExecution()" ) );
 	CString func = stk.GetFunction(1);
	EXPECT_TRUE( func.Find( "SehCase3()" ) != -1 );
	EXPECT_TRUE(dbg.StepOut(1, NULL, "__except( ++counter, ContinueExecution() ) {"));

	EXPECT_TRUE( dbg.Go("ExecuteHandler") );
	EXPECT_TRUE( stk.CurrentFunctionIs( "ExecuteHandler()" ) );
 	func = stk.GetFunction(1);
	EXPECT_TRUE( func.Find( "SehCase4()" ) != -1 );
	EXPECT_TRUE(dbg.StepOut(1, NULL, "__except( ++counter, ExecuteHandler() ) {"));

	EXPECT_TRUE( dbg.Go("ExecuteHandler") );
	EXPECT_TRUE( stk.CurrentFunctionIs( "ExecuteHandler()" ) );
 	func = stk.GetFunction(1);
	EXPECT_TRUE( func.Find( "SehCase6()" ) != -1 );
	EXPECT_TRUE(dbg.StepOver(4, NULL, "__except( ++counter, ExecuteHandler() ) {"));

	EXPECT_TRUE( dbg.Go("ExecuteHandler") );
	EXPECT_TRUE( stk.CurrentFunctionIs( "ExecuteHandler()" ) );
 	func = stk.GetFunction(1);
	EXPECT_TRUE( func.Find( "SehCase8()" ) != -1 );
	EXPECT_TRUE(dbg.StepOut(1, NULL, "__except( ++counter, ExecuteHandler() ) {"));

	EXPECT_TRUE( dbg.Go("ContinueExecution") );
	EXPECT_TRUE( stk.CurrentFunctionIs( "ContinueExecution()" ) );
 	func = stk.GetFunction(1);
	EXPECT_TRUE( func.Find( "SehCase8()" ) != -1 );
	EXPECT_TRUE(dbg.StepOut(1, NULL, "__except( ++counter, ContinueExecution() ) {"));

	EXPECT_TRUE( dbg.Go("ContinueSearch") );
	EXPECT_TRUE( stk.CurrentFunctionIs( "ContinueSearch()" ) );
 	func = stk.GetFunction(1);
	EXPECT_TRUE( func.Find( "SehCase5()" ) != -1 );
	EXPECT_TRUE(dbg.StepOut(1, NULL, "__except( ++counter, ContinueSearch() ) {"));

	dbg.StopDebugging();
  	bps.ClearAllBreakpoints();
	return TRUE;
}

BOOL CNLGIDETest::SEH_StepOver__try( )
{
	LogTestHeader( "SEH_StepOver__try" );
	CString strSource = "seh01.cpp";
 	dbg.Restart();
	bps.ClearAllBreakpoints();
	bps.SetBreakpoint("SehCase8");
	dbg.SetSteppingMode(SRC);
	MST.WFndWnd(strSource, FW_NOCASE | FW_FOCUS | FW_PART);
	EXPECT_TRUE( dbg.Go("SehCase8") );
	EXPECT_TRUE(dbg.StepOver(4, NULL, "__try { ++counter; RaiseIntDivideByZero();"));
	EXPECT_TRUE(dbg.StepOver(1, NULL, "__finally { ++counter; /* should execute */ }"));
	EXPECT_TRUE( dbg.VerifyNotification("Integer Divide by Zero", 2, 20, TRUE) );
	dbg.SetSteppingMode(SRC);
//	MST.WFndWnd(strSource, FW_NOCASE | FW_FOCUS | FW_PART);
	EXPECT_TRUE(dbg.StepOver(1, NULL, "__except( ++counter, ExecuteHandler() ) {"));
	EXPECT_TRUE(dbg.StepOver(1, NULL, "++counter; // should execute"));

	// processor pack code-gen difference.
	if(1) //xbox - CMDLINE->GetBooleanValue("PP", FALSE))
		{EXPECT_TRUE(dbg.StepOver(1, NULL, "__try { ++counter; RaiseIntDivideByZero(); ++counter;"));}
	else
		{EXPECT_TRUE(dbg.StepOver(2, NULL, "__try { ++counter; RaiseIntDivideByZero(); ++counter;"));}

	EXPECT_TRUE(dbg.StepOver(1, NULL, "++counter; // should execute"));
	EXPECT_TRUE( dbg.VerifyNotification("Integer Divide by Zero", 3, 20, TRUE) );

	dbg.StopDebugging();
	return TRUE;
}

BOOL CNLGIDETest::SEH_BreakInExcept( )
{
	LogTestHeader( "SEH_BreakInExcept" );
 	dbg.Restart();
	dbg.SetSteppingMode(SRC);
  	bps.ClearAllBreakpoints();

	EXPECT_TRUE( bps.SetBreakpoint("{,seh01.cpp,}@91") );
	EXPECT_TRUE( bps.SetBreakpoint("{,seh01.cpp,}@136") );

	EXPECT_TRUE(dbg.Go(NULL, "++counter; // should execute")  &&
		stk.CurrentFunctionIs( "SehCase4()" ) );
	EXPECT_TRUE(dbg.Go(NULL, "++counter; // should execute")  &&
		stk.CurrentFunctionIs( "SehCase6()" ) );

	bps.ClearAllBreakpoints();

	dbg.StopDebugging();
	return TRUE;
}

BOOL CNLGIDETest::SEH_BreakInFinally( )
{
	LogTestHeader( "SEH_BreakInFinally" );
 	dbg.Restart();
	dbg.SetSteppingMode(SRC);
  	bps.ClearAllBreakpoints();

	EXPECT_TRUE( bps.SetBreakpoint("{,seh01.cpp,}@52") );
	EXPECT_TRUE( bps.SetBreakpoint("{,seh01.cpp,}@130") );

	EXPECT_TRUE(dbg.Go(NULL, "++counter; // should execute") &&
		stk.CurrentFunctionIs( "SehCase2()" ) );
	EXPECT_TRUE(dbg.Go(NULL, "++counter; // should execute") &&
		stk.CurrentFunctionIs( "SehCase6()" ) );

	bps.ClearAllBreakpoints();
	dbg.StopDebugging();
	return TRUE;
}

BOOL CNLGIDETest::SEH_StepToCursorOver__tryIntoExcept( )
{
	LogTestHeader( "SEH_StepToCursorOver__tryIntoExcept" );
 	dbg.Restart();
	dbg.SetSteppingMode(SRC);
  	bps.ClearAllBreakpoints();

	CString strSource = "seh01.cpp";
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource);   //Review yefims
//	file.Open( m_strProjectDir + "\\" + strSource);   

	EXPECT_TRUE(dbg.StepToCursor(84, NULL, "__try {"));
	EXPECT_TRUE(dbg.StepToCursor(91, NULL, "++counter; // should execute"));
	EXPECT_TRUE(dbg.StepToCursor(121, NULL, "__try {"));
	EXPECT_TRUE(dbg.StepToCursor(136, NULL, "++counter; // should execute"));

	dbg.StopDebugging();

	return TRUE;
}


BOOL CNLGIDETest::SEH_StepToCursorOver__tryIntoFinally( )
{
	LogTestHeader( "SEH_StepToCursorOver__tryIntoFinally" );
 	dbg.Restart();
	dbg.SetSteppingMode(SRC);
  	bps.ClearAllBreakpoints();

	CString strSource = "seh01.cpp";
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource);   //Review yefims
//	file.Open( m_strProjectDir + "\\" + strSource);   

	EXPECT_TRUE(dbg.StepToCursor(47, NULL, "__try {"));
	EXPECT_TRUE(dbg.StepToCursor(52, NULL, "++counter; // should execute"));
	EXPECT_TRUE(dbg.StepToCursor(123, NULL, "__try {"));
	EXPECT_TRUE(dbg.StepToCursor(130, NULL, "++counter; // should execute"));

	dbg.StopDebugging();

	return TRUE;
}


// Setjmp/Longjmp
BOOL CNLGIDETest::LJMP_StepOverLongJmp( )
{
	LogTestHeader( "LJMP_StepOverLongJmp" );
 	bps.ClearAllBreakpoints();
 	bps.SetBreakpoint("ljmp01");
	dbg.SetSteppingMode(SRC);

	// xbox additions
	EXPECT_TRUE(dbg.StepOver()); // skip the opening bracket
	EXPECT_TRUE(dbg.SetNextStatement("ljmp01();"));

	dbg.Go("ljmp01");
	MST.DoKeys("{down 15}");
	EXPECT_TRUE( dbg.StepToCursor(0,NULL,"longjmp( mark, -1 );")	 )	;
	EXPECT_TRUE(dbg.StepOver(1, NULL, "jmpret = setjmp( mark );"));
	return TRUE;
}

BOOL CNLGIDETest::LJMP_StepOverFuncWithLongJmp( )
{
 	LogTestHeader( "LJMP_StepOverFuncWithLongJmp" );
 	bps.ClearAllBreakpoints();
 	bps.SetBreakpoint("{,ljmp01.cpp,}@55");
	dbg.SetSteppingMode(SRC);

	dbg.Go(NULL, "ljmp02( mark, i );");
	EXPECT_TRUE(dbg.StepOver(1, NULL, "jmpret = setjmp( mark );"));
	return TRUE;
}

BOOL CNLGIDETest::LJMP_StepOutFuncWithLongJmp( )
{
	LogTestHeader( "LJMP_StepOutFuncWithLongJmp" );
  	bps.ClearAllBreakpoints();
 	bps.SetBreakpoint("ljmp02");
	dbg.SetSteppingMode(SRC);

	dbg.Go("ljmp02");
	EXPECT_TRUE(dbg.StepOut(1, NULL, "jmpret = setjmp( mark );"));

	dbg.StopDebugging();
	return TRUE;
}


BOOL CNLGIDETest::IsUnhandledException(CString except_text)
{
	if( WaitMsgBoxText( except_text, 10 ) )
	{
		MST.WButtonClick( "OK" );
		return TRUE;
	}
	else
		return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\registers\StdAfx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\registers\regcase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	Regcase.CPP
//											 
//	Created by :			
//		dklem
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "Regcase.h"	
#include "process.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
											   
IMPLEMENT_TEST(/*999,*/ CRegistersIDETest, CDbgTestBase, "General", -1, CRegistersSubSuite)

// each function that runs a test has this prototype.
typedef void (CRegistersIDETest::*PTR_TEST_FUNC)(void); 

// Information about a test to be put in the test header
#define LOGTESTHEADER(strTestName) 	m_strLogInfo.Format("# - %d.  %s. Total # - %d, Passed - %d %%", ++m_TestNumber, strTestName, m_TotalNumberOfTests, (m_TestNumber*100)/m_TotalNumberOfTests);  \
									LogTestHeader(m_strLogInfo);

// we randomly pick out of the following list of tests and run them.
// insert functions for new tests to the end of the list.

PTR_TEST_FUNC tests[] = 
{
	&CRegistersIDETest::VerifyEIP,
	&CRegistersIDETest::EIP_ESP_ChangeAfterStep,
	&CRegistersIDETest::VerifyFlags,
	&CRegistersIDETest::VerifyEAX,
	&CRegistersIDETest::EditRegisters,
	&CRegistersIDETest::ToggleFlags,
	&CRegistersIDETest::EditRegisterViaQuickWatch,
	&CRegistersIDETest::Registers_Dam_Watch_Memory,
	&CRegistersIDETest::Registers_Watch_Memory,
	&CRegistersIDETest::Change_EAX_Changes_RetValue,
	&CRegistersIDETest::DisplayIsAlwaysHex,
	&CRegistersIDETest::IntegrityWithSetFocusToThread,
	&CRegistersIDETest::IntegrityWithFunctionEvaluation,
	&CRegistersIDETest::BoundaryConditionsForEditingValues,
	&CRegistersIDETest::TypeInvalidValues,
	&CRegistersIDETest::FloatingPointException,
	&CRegistersIDETest::VerifyDockingView,
};

											 
void CRegistersIDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();

}

void CRegistersIDETest::Run()
{	 
	/******************
	 * INITIALIZATION *
	 ******************/

	if (!CreateXboxProjectFromSource("Registers", "src\\Registers",
				"Registers.cpp"))
			return;

	// all tests expect the ide to be in this initial state.
	EXPECT_TRUE(dbg.StepOver());
	
	// indexes into the test function array.
	int iTest;
	m_TestNumber = 0;
	m_TotalNumberOfTests = sizeof(tests) / sizeof(PTR_TEST_FUNC);
	// we only want to randomly run each test once.
	RandomNumberCheckList rncl(sizeof(tests) / sizeof(PTR_TEST_FUNC));

	// randomly run each test once.
//	while((iTest = rncl.GetNext()) != -1)
	for(iTest = 0; iTest < sizeof(tests) / sizeof(PTR_TEST_FUNC); iTest++)
		(this->*(tests[iTest]))();

	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_SUCCESS(prj.Close());
}	

///////////////////////////////////////////////////////////////////////////////
//	Test Cases
///////////////////////////////////////////////////////////////////////////////

void CRegistersIDETest::HelperFunctionVerifyEIP(char* szTestCaseName, char* szEIP)
{

	CString csDamEIP;

	EXPECT_TRUE(dam.Enable());
	csDamEIP = dam.GetInstruction();
	csDamEIP = csDamEIP.Left(8);
	EXPECT_TRUE(dam.Disable());

	// Resize and Move
	EXPECT_TRUE(regs.Enable());	
	EXPECT_TRUE(regs.RegisterValueIs(CString("EIP"), csDamEIP, -1));

	// Return EIP if requested
	if(szEIP)
		strcpy(szEIP, LPCTSTR(csDamEIP));
}


void CRegistersIDETest::VerifyEIP(void)
{

	LOGTESTHEADER("VerifyEIP");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.ShowNextStatement());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	EXPECT_TRUE(regs.Enable());

	HelperFunctionVerifyEIP("VerifyEIP", NULL);
}

void CRegistersIDETest::EIP_ESP_ChangeAfterStep(void)
{
	LOGTESTHEADER("EIP_ESP_ChangeAfterStep");

	char *pszFlags[] = {"EIP ", "ESP "};
	CString csRegValues[2];
	int ii;

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.ShowNextStatement());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	EXPECT_TRUE(regs.Enable());

	// Get initial values
	for(ii = 0; ii < sizeof(pszFlags)/sizeof(*pszFlags); ii++)
		csRegValues[ii] = regs.GetRegister(CString(pszFlags[ii]), NULL);

	// Step Into
	EXPECT_TRUE(dbg.StepInto(1));
	EXPECT_TRUE(regs.Enable());

	// Make sure that values changed
	for(ii = 0; ii < sizeof(pszFlags)/sizeof(*pszFlags); ii++)
		EXPECT_TRUE(!regs.RegisterValueIs(CString(pszFlags[ii]), csRegValues[ii], -1));

}

void CRegistersIDETest::VerifyFlags(void)
{

	LOGTESTHEADER("VerifyFlags");

	char *pszFlags[] = {"OV", "UP", "EI", "PL", "ZR", "AC", "PE", "CY"};
	BOOL bSame, bSame1;

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.ShowNextStatement());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	EXPECT_TRUE(regs.Enable());

	// Verify that all flags are in place and their value are either 0 or 1
	for(int ii = 0; ii < sizeof(pszFlags)/sizeof(*pszFlags); ii++)
	{
		bSame = regs.RegisterValueIs(CString(pszFlags[ii]), CString("0"), -1);
		bSame1 = regs.RegisterValueIs(CString(pszFlags[ii]), CString("1"), -1);
		EXPECT_TRUE(bSame || bSame1);
	}

}

void CRegistersIDETest::VerifyEAX(void)
{

	LOGTESTHEADER("VerifyEAX");
	
	CString csRetValue;
	int nRegValue;

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.ShowNextStatement());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	// Step Over the Foo(7) function
	EXPECT_TRUE(dbg.StepOver());

	// Get return value
	EXPECT_TRUE(ee.GetExpressionValue("res", csRetValue));

	EXPECT_TRUE(regs.Enable());

	// Verify that EAX is correct
	regs.GetRegister(CString("EAX"), &nRegValue);

	int x = atoi(LPCTSTR(csRetValue));

	EXPECT_TRUE(nRegValue == atoi(LPCTSTR(csRetValue)));

}

void CRegistersIDETest::EditRegisters(void)
{

	LOGTESTHEADER("EditRegisters");

	char szNewValue[128];
	CString csRegister;
/*	char szTmpStr[128];
	char *ptr;
	int nStrLen;
	BOOL bSign;
*/	
	char *pszCPURegs[] =		{"EAX", "EBX", "ECX", "EDX", "ESI", "EDI", "EIP", "ESP", "EBP", "EFL"};
	char *pszCPUSegments[] = 	{"CS", "DS", "ES", "SS", "FS", "GS" }; 
	// TODO (dklem 11/16/00) EDO was removed from the list because you can edit just low 4 bytes.  BUG # 50809 in VS7
	// TODO(michma - 3/15/00): we can't distinguish yet between normal EIP and float EIP.
	char *pszFloatingInt[] =	{"CTRL", "STAT", "TAGS", /* "EIP", */ "CS", "DS", /*"EDO "*/};
	char *pszFloatingFloat[] =	{"ST0", "ST1", "ST2", "ST3", "ST4", "ST5", "ST6", "ST7"};

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.ShowNextStatement());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	EXPECT_TRUE(regs.Enable());

	// initialize random numbers generator
	srand((unsigned)time( NULL ));


	m_pLog->RecordInfo("Testing cpu registers.");

	// Verify that all CPU registers and segments are in place and are editable
	for(int ii = 0; ii < sizeof(pszCPURegs)/sizeof(*pszCPURegs); ii++)

	{
		m_pLog->RecordInfo("Testing register %s.", pszCPURegs[ii]);

		// The next for cycle is for Multiple Undo/Redo verification
		for(int jj = 0; jj < gl_constNumberUndoRedo; jj++)
		{
			// Create a new value 
			sprintf(szNewValue, "%.8x", (int) (0xFFFFFFFF * (((float)rand()) / ((float)(RAND_MAX)))));
			strupr(szNewValue);

			// Save value for Multiple Undo/Redo verification
			strcpy(m_pszUndoRedoRegisters[jj], szNewValue);

			// Set value
			EXPECT_TRUE(regs.SetRegister(CString(pszCPURegs[ii]), CString(szNewValue), -1));

			if(0 == strcmp(pszCPURegs[ii], "EIP "))
			{
				EXPECT_TRUE(regs.Enable());
			}

			// Verify value
			EXPECT_TRUE(regs.RegisterValueIs(CString(pszCPURegs[ii]), CString(szNewValue), -1));
		}

		// TODO (dklem 11/13/00) Enable when this function available
		// HelperFunctio_MultipleUndoRedo(pszCPURegs[ii]);
	}

	m_pLog->RecordInfo("Testing CPU segments.");

	// Verify that all CPU segments and segments are in place and are editable
	for(ii = 0; ii < sizeof(pszCPUSegments)/sizeof(*pszCPUSegments); ii++)
	
	{
		m_pLog->RecordInfo("Testing register %s.", pszCPUSegments[ii]);

		// The next for cycle is for Multiple Undo/Redo verification
		for(int jj = 0; jj < gl_constNumberUndoRedo; jj++)
		{
			// Create a new value 
			sprintf(szNewValue, "%.4x", (int) (0xFFFF * (((float)rand()) / ((float)(RAND_MAX)))));
			strupr(szNewValue);

			// Save value for Multiple Undo/Redo verification
			strcpy(m_pszUndoRedoRegisters[jj], szNewValue);

			// Set value
			EXPECT_TRUE(regs.SetRegister(CString(pszCPUSegments[ii]), CString(szNewValue), -1));
			// Verify value
			EXPECT_TRUE(regs.RegisterValueIs(CString(pszCPUSegments[ii]), CString(szNewValue), -1));
		}

		// TODO (dklem 11/13/00) Enable when this function available
		// HelperFunctio_MultipleUndoRedo(pszCPUSegments[ii]);
	}

	m_pLog->RecordInfo("Testing floating point int.");

	for(ii = 0; ii < sizeof(pszFloatingInt)/sizeof(*pszFloatingInt); ii++)

	{
		m_pLog->RecordInfo("Testing register %s.", pszFloatingInt[ii]);

		// The next for cycle is for Multiple Undo/Redo verification
		for(int jj = 0; jj < gl_constNumberUndoRedo; jj++)
		{
			// Create a new value 
			if(!strcmp(pszFloatingInt[ii], "EIP ") || !strcmp(pszFloatingInt[ii], "EDO "))
				sprintf(szNewValue, "%.8x", (int) (0xFFFFFFFF * (((float)rand()) / ((float)(RAND_MAX)))));
			else
				sprintf(szNewValue, "%.4x", (int) (0xFFFF * (((float)rand()) / ((float)(RAND_MAX)))));
			strupr(szNewValue);

			// Save value for Multiple Undo/Redo verification
			strcpy(m_pszUndoRedoRegisters[jj], szNewValue);

			// Set value
			EXPECT_TRUE(regs.SetRegister(CString(pszFloatingInt[ii]), CString(szNewValue), -1));
			// Verify value
			EXPECT_TRUE(regs.RegisterValueIs(CString(pszFloatingInt[ii]), CString(szNewValue), -1));
		}

		// TODO (dklem 11/13/00) Enable when this function available
		// HelperFunctio_MultipleUndoRedo(pszFloatingInt[ii]);
	}

	// Verify that there are no IP and DO in floats
	// TODO: (dklem 10/14/99) Uncomment the following 2 lines when #50800 is fixed. FIXED in 8682 (11/16/99).
	csRegister = regs.GetRegister(CString(" IP "), NULL);
	EXPECT_TRUE(csRegister.IsEmpty());
	csRegister = regs.GetRegister(CString(" DO "), NULL);
	EXPECT_TRUE(csRegister.IsEmpty());

	// DON'T FORGET TO ADD MULTIPLE UNDO/REDO VERIFICATION FOR FLOATING POINTS
	// TODO (dklem 11/16/00) The following piece of code was commented because changing exponent changes mantissa.  BUG #63001 in VS7
/*
	// Don't forget to treat + correctly.  Otherwise it will be interpreted as Shift.
	for(ii = 0; ii < sizeof(pszFloatingFloat)/sizeof(*pszFloatingFloat); ii++)
	{
		csRegister = regs.GetRegister(CString(pszFloatingFloat[ii]), NULL);
		lstrcpyn(szNewValue, LPCTSTR(csRegister), sizeof(szNewValue));

		// Change value
		nStrLen = (int) strlen(szNewValue);
		for(int i = 0; i < nStrLen; i++)
		{
			if('0' <= szNewValue[i] && szNewValue[i] <= '9')
				szNewValue[i] = '0' + (int) (10 * (((float)rand()) / ((float)(RAND_MAX)))); 

			// Choose the sign randomly
			if('+' == szNewValue[i] || szNewValue[i] == '-')
			{
				bSign = (int) ((((float)rand()) / ((float)(RAND_MAX))) + 0.5); 

				// Verify that bSign is 1 and 0
				if(bSign)
					while(0);
				else
					while(0);
				

				// we should put {} around +.  Otherwise it would be treated as Shift
				if(bSign)
				{
					memcpy(szNewValue + i + 3, szNewValue + i + 1, nStrLen);
					strncpy(szNewValue + i, "{+}", 3);
					nStrLen +=2;
					i +=2;
					strcpy(szNewValue + nStrLen - 2, "00");
					*(szNewValue + nStrLen) = '\0';
				}
				else
					szNewValue[i] = '-';
			}


		}

		// Since STx are long doubles whose size is 10 bytes and limits are 1.2E +/- 4932 (19 digits), we put these limits
		if(4931 < atoi(szNewValue + nStrLen - 4))
			strcpy(szNewValue + nStrLen - 4, "4931");

		// Set value
		EXPECT_TRUE(regs.SetRegister(CString(pszFloatingFloat[ii]), CString(szNewValue), -1));

		// Remove {} from szNewValue
		ptr = szNewValue;
		while(NULL != (ptr = strstr(ptr, "{+}")))
		{
			strcpy(szTmpStr, ptr + 3);
			strcpy(ptr, "+");
			strcpy(ptr + 1, szTmpStr);
		}

		// Verify value
		EXPECT_TRUE(regs.RegisterValueIs(CString(pszFloatingFloat[ii]), CString(szNewValue), -1));

	}
*/
	// Test the boundary conditions
	EXPECT_TRUE(regs.SetRegister(CString(pszFloatingFloat[0]), CString("{+}1.00000000000000000e{+}0000"), -1));
	EXPECT_TRUE(regs.SetRegister(CString(pszFloatingFloat[0]), CString("{+}1"), -1));
	EXPECT_TRUE(regs.RegisterValueIs(CString(pszFloatingFloat[0]), CString("+1.00000000000000000e+0000"), -1));

	// TODO (dklem 11/17/00) The following piece was commented because of limits for STx seems to be incorrect.  BUG # 62937 in VS7
/*
	EXPECT_TRUE(regs.SetRegister(CString(pszFloatingFloat[0]), CString("{+}1.19000000000000000e{+}4932"), -1));
	EXPECT_TRUE(regs.RegisterValueIs(CString(pszFloatingFloat[0]), CString("+1.19000000000000000e+4932"), -1));

	EXPECT_TRUE(regs.SetRegister(CString(pszFloatingFloat[0]), CString("{+}1.19000000000000000e-4932"), -1));
	EXPECT_TRUE(regs.RegisterValueIs(CString(pszFloatingFloat[0]), CString("+1.19000000000000000e-4932"), -1));
*/
	EXPECT_TRUE(regs.SetRegister(CString(pszFloatingFloat[0]), CString("{+}1.21000000000000000e{+}4932"), -1));
	EXPECT_TRUE(regs.RegisterValueIs(CString(pszFloatingFloat[0]), CString("1#INF"), -1));

// TODO (dklem 11/16/00) The following piece of code was commented because changing exponent changes mantissa.  BUG #63001 in VS7
/*
	EXPECT_TRUE(regs.SetRegister(CString(pszFloatingFloat[0]), CString("{+}1.21000000000000000e-4932"), -1));
	EXPECT_TRUE(regs.RegisterValueIs(CString(pszFloatingFloat[0]), CString("1#INF"), -1));
*/
	// Should disable (close) disassembly window since changing EIP bings it up
	EXPECT_TRUE(dam.Disable());
}

void CRegistersIDETest::ToggleFlags(void)
{

	LOGTESTHEADER("ToggleFlags");

	int nRegValue;
	char szTmpStr[8];

	char *pszFlags[] = {"OV", "UP", "EI", "PL", "ZR", "AC", "PE", "CY"};


	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.ShowNextStatement());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	EXPECT_TRUE(regs.Enable());

	// Verify that all flags are in place and their value are either 0 or 1
	for(int ii = 0; ii < sizeof(pszFlags)/sizeof(*pszFlags); ii++)
	{
		// The next for cycle is for Multiple Undo/Redo verification
		for(int jj = 0; jj < gl_constNumberUndoRedo; jj++)
		{
			regs.GetRegister(CString(pszFlags[ii]), &nRegValue);

			// Swap value
			nRegValue = !nRegValue;

			// Save value for Multiple Undo/Redo verification
			strcpy(m_pszUndoRedoRegisters[jj], itoa(nRegValue, szTmpStr, 10));

			// Set value
			EXPECT_TRUE(regs.SetRegister(CString(pszFlags[ii]), CString(""), nRegValue, FALSE /* value is given as an integer */));
			EXPECT_TRUE(regs.RegisterValueIs(CString(pszFlags[ii]), CString(""), nRegValue, FALSE /* value is given as an integer */));
		}

		// TODO (dklem 11/13/00) Enable when this function available
		// HelperFunctio_MultipleUndoRedo(pszFlags[ii]);
	}

}

void CRegistersIDETest::EditRegisterViaQuickWatch(void)
{

	LOGTESTHEADER("EditRegisterViaQuickWatch");

	char *pszRegisters[] = {"EAX", "ESP"};
	char szNewValue[128], szSetValue[128];
	int ii;

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.ShowNextStatement());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	EXPECT_TRUE(regs.Enable());

	// Make sure that values changed
	for(ii = 0; ii < sizeof(pszRegisters)/sizeof(*pszRegisters); ii++)
	{
		// Create a new value 
		sprintf(szNewValue, "%.8x", (int) (0xFFFFFFFF * (((float)rand()) / ((float)(RAND_MAX)))));
		strupr(szNewValue);
		sprintf(szSetValue, "0X%s", szNewValue);

		// Change the value via quick watch window
		EXPECT_TRUE(uiqw.Activate());
		EXPECT_TRUE(uiqw.SetExpression(pszRegisters[ii]));
		EXPECT_TRUE(uiqw.Recalc());
		EXPECT_TRUE(uiqw.SetNewValue(szSetValue));
		EXPECT_TRUE(uiqw.Recalc());

		// Verify that the new value has been set correctly
		EXPECT_TRUE(regs.Enable());
		EXPECT_TRUE(regs.RegisterValueIs(CString(pszRegisters[ii]), CString(szNewValue), -1));
	}

}

void CRegistersIDETest::Registers_Dam_Watch_Memory(void)
{

	LOGTESTHEADER("Registers_Dam_Watch_Memory");

	CString csEIP1, csEIP2, csMemoryAddress;
	CString csTmpAddress;

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.ShowNextStatement());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	// Turn Hex mode on
	EXPECT_TRUE(dbg.ToggleHexDisplay(TRUE));

	// Get current EIP and EIP 7 lines down
	EXPECT_TRUE(dam.Enable());
	csEIP1 = dam.GetInstruction();
	csEIP1 = csEIP1 .Left(8);

	// We use UI layer since we CODisassembly doesn't have GetInstructionAt()
	//EXPECT_TRUE(dam.AttachActive());
	EXPECT_TRUE(dam.Enable());
	csEIP2 = uidam.GetInstruction(7, 1, FALSE);
	csEIP2  = csEIP2 .Left(8);

	// Verify EIP in the Registers window
	EXPECT_TRUE(regs.Enable());
	EXPECT_TRUE(regs.RegisterValueIs(CString("EIP"), csEIP1, -1));

	// Verify EIP in the Memory window
	EXPECT_TRUE(mem.Enable());
	csMemoryAddress = mem.GetAddress(CString("EIP"));
	EXPECT_TRUE((0 == csEIP1.CompareNoCase(csMemoryAddress.Right(8))));

	// Verify EIP in the Watch window
	csMemoryAddress.MakeLower();			// Value in the Watch appear with small letters
	csMemoryAddress.Insert(0, "0x");
	EXPECT_TRUE(watch.AddWatch(CString("EIP")));
	EXPECT_TRUE(watch.VerifyWatchInfo(CString("EIP"), csMemoryAddress,  "unsigned long", (EXPR_STATE) 0 /*NOT_EXPANABLE*/));
	EXPECT_TRUE(watch.RemoveWatch(CString("EIP")));
	EXPECT_TRUE(ee.ExpressionValueIs("EIP", csMemoryAddress));
	
	// Set new value in the Registers window
	EXPECT_TRUE(regs.Enable());
	EXPECT_TRUE(regs.SetRegister(CString("EIP"), csEIP2, -1));

	// Make sure that values changed
	EXPECT_TRUE(dam.Enable());
	csTmpAddress = dam.GetInstruction();
	csTmpAddress = csTmpAddress.Left(8);
	EXPECT_TRUE(0 == csEIP2.CompareNoCase(csTmpAddress));
	
	// Verify EIP in the Memory window
	EXPECT_TRUE(mem.Enable());
	csMemoryAddress = mem.GetAddress(CString("EIP"));
	EXPECT_TRUE((0 == csEIP2.CompareNoCase(csMemoryAddress.Right(8))));

	// Verify EIP in the Watch window
	csMemoryAddress.MakeLower();			// Value in the Watch appear with small letters
	csMemoryAddress.Insert(0, "0x");
	EXPECT_TRUE(watch.AddWatch(CString("EIP")));
	EXPECT_TRUE(watch.VerifyWatchInfo(CString("EIP"), csMemoryAddress,  "unsigned long", (EXPR_STATE) 0 /*NOT_EXPANABLE*/));
	EXPECT_TRUE(watch.RemoveWatch(CString("EIP")));
	EXPECT_TRUE(ee.ExpressionValueIs("EIP", csMemoryAddress));

	EXPECT_TRUE(mem.Disable());
	EXPECT_TRUE(dam.Disable());

	// Turn Hex mode off
	EXPECT_TRUE(dbg.ToggleHexDisplay(FALSE));

}

void CRegistersIDETest::Registers_Watch_Memory(void)
{

	LOGTESTHEADER("Registers_Watch_Memory");

	char *pszRegisters[] =		{"EAX", "EBX", "ECX", "EDX", "ESI", "EDI", "EIP", "ESP", "EBP", "EFL"};
	CString csReg, csMemoryAddress;
	char szTmpData[1024];

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.ShowNextStatement());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	// Turn Hex mode on
	EXPECT_TRUE(dbg.ToggleHexDisplay(TRUE));

	for(int ii = 0; ii < sizeof(pszRegisters)/sizeof(*pszRegisters); ii++)
	{

		for(int i = 0; i < 2; i++)
		{
			// Verify Register in the Registers window
			EXPECT_TRUE(regs.Enable());
			csReg = regs.GetRegister(CString(pszRegisters[ii]), NULL);

			// Verify Register in the Memory window
			EXPECT_TRUE(mem.Enable());
			csMemoryAddress = mem.GetAddress(CString(pszRegisters[ii]));
			EXPECT_TRUE((0 == csReg.CompareNoCase(csMemoryAddress.Right(8))));
	
			// Verify Register in the Watch window
			csMemoryAddress.MakeLower();			// Value in the Watch appear with small letters
			csMemoryAddress.Insert(0, "0x");
			EXPECT_TRUE(watch.AddWatch(CString(pszRegisters[ii])));
			EXPECT_TRUE(watch.VerifyWatchInfo(CString(pszRegisters[ii]), csMemoryAddress,  "unsigned long", (EXPR_STATE) 0 /*NOT_EXPANABLE*/));
			EXPECT_TRUE(watch.RemoveWatch(CString(pszRegisters[ii])));

			EXPECT_TRUE(ee.ExpressionValueIs(CString(pszRegisters[ii]), csMemoryAddress));

			// Set new value in the Registers window
			// Create a new value 
			sprintf(szTmpData, "%.8x", (int) (0xFFFFFFFF * (((float)rand()) / ((float)(RAND_MAX)))));
			strupr(szTmpData);
			EXPECT_TRUE(regs.Enable());
			EXPECT_TRUE(regs.SetRegister(CString(pszRegisters[ii]), CString(szTmpData), -1));
		}

		// Make sure that values changed, i = 1;

	}	

	EXPECT_TRUE(mem.Disable());
	// changing the EIP may bring the asm window up.
	EXPECT_TRUE(dam.Disable());

	// Turn Hex mode off
	EXPECT_TRUE(dbg.ToggleHexDisplay(FALSE));
}

void CRegistersIDETest::Change_EAX_Changes_RetValue(void)
{

	LOGTESTHEADER("Change_EAX_Changes_RetValue");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.ShowNextStatement());
	EXPECT_TRUE(src.Find("/* Return form Foo */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	EXPECT_TRUE(regs.Enable());

	EXPECT_TRUE(regs.SetRegister(CString("EAX"), CString("000000AF"), -1));
	// Step from function
	EXPECT_TRUE(dbg.StepOver(2));

	// Turn Hex mode off
	EXPECT_TRUE(dbg.ToggleHexDisplay(FALSE));

	// Verify res
	EXPECT_TRUE(watch.AddWatch(CString("res")));
	EXPECT_TRUE(watch.VerifyWatchInfo(CString("res"), CString("175"),  "int", (EXPR_STATE) 0 /*NOT_EXPANABLE*/));
	EXPECT_TRUE(watch.RemoveWatch(CString("res")));

}

void CRegistersIDETest::DisplayIsAlwaysHex(void)
{

	LOGTESTHEADER("DisplayIsAlwaysHex");

	char *pszCPURegs[] =		{"EAX", "EBX", "ECX", "EDX", "ESI", "EDI", "EIP", "ESP", "EBP", "EFL"};
	CString csCPURegValues[10];  // MUST BE THE SAME SIZE AS NUMBER OF REGS ABOVE
	char *pszCPUSegments[] = 	{"CS", "DS", "ES", "SS", "FS", "GS" }; 
	CString csCPUSegmentsValues[6];  // MUST BE THE SAME SIZE AS NUMBER OF REGS ABOVE
	char *pszFloatingInt[] =	{"CTRL", "STAT", "TAGS", "EIP", "CS", "DS", "EDO"};
	CString csFloatingIntValues[7];  // MUST BE THE SAME SIZE AS NUMBER OF REGS ABOVE

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.ShowNextStatement());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	// Turn Hex mode on
	EXPECT_TRUE(dbg.ToggleHexDisplay(TRUE));

	EXPECT_TRUE(regs.Enable());
	// Get initial values
	for(int ii = 0; ii < sizeof(pszCPURegs)/sizeof(*pszCPURegs); ii++)
	{
		csCPURegValues[ii] = regs.GetRegister(CString(pszCPURegs[ii]), NULL);
	}

	for(ii = 0; ii < sizeof(pszCPUSegments)/sizeof(*pszCPUSegments); ii++)
	{
		csCPUSegmentsValues[ii] = regs.GetRegister(CString(pszCPUSegments[ii]), NULL);
	}

	for(ii = 0; ii < sizeof(pszFloatingInt)/sizeof(*pszFloatingInt); ii++)
	{
		csFloatingIntValues[ii] = regs.GetRegister(CString(pszFloatingInt[ii]), NULL);
	}

	// Turn Hex mode on
	EXPECT_TRUE(dbg.ToggleHexDisplay(FALSE));

	// Make sure that values has not changed
	for(ii = 0; ii < sizeof(pszCPURegs)/sizeof(*pszCPURegs); ii++)
	{
		EXPECT_TRUE(regs.RegisterValueIs(pszCPURegs[ii], csCPURegValues[ii], -1));
	}

	for(ii = 0; ii < sizeof(pszCPUSegments)/sizeof(*pszCPUSegments); ii++)
	{

		EXPECT_TRUE(regs.RegisterValueIs(pszCPUSegments[ii], csCPUSegmentsValues[ii], -1));
	}

	for(ii = 0; ii < sizeof(pszFloatingInt)/sizeof(*pszFloatingInt); ii++)
	{
		EXPECT_TRUE(regs.RegisterValueIs(pszFloatingInt[ii], csFloatingIntValues[ii], -1));

	}

}

void CRegistersIDETest::IntegrityWithSetFocusToThread(void)
{

	LOGTESTHEADER("IntegrityWithSetFocusToThread");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.ShowNextStatement());
	EXPECT_TRUE(src.Find("/* Thread proc */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	char szOriginalEIP[512];
	char szEIP[512];

	HelperFunctionVerifyEIP("IntegrityWithSetFocusToThread", szOriginalEIP);

	// Set 'main' or 'WinMainCRTStartup' as an active thread.
	unsigned long ulThreadID;
	EXPECT_TRUE(ee.GetExpressionValue("dwMainThreadID", &ulThreadID));
	EXPECT_TRUE(threads.SetCurrentThread(ulThreadID));

	HelperFunctionVerifyEIP("IntegrityWithSetFocusToThread", szEIP);
	if (!strcmp(szOriginalEIP, szEIP))
		LOG->RecordInfo("szOriginalEIP=[%s], szEIP=[%s]", szOriginalEIP, szEIP);
	EXPECT_TRUE(0 != strcmp(szOriginalEIP, szEIP));

	// if we are deep in thread switch goo, need to navigate stack so
	// we are inside main() and can thus evaluate dwSecondaryThreadID as
	// an expression
	stk.NavigateStack("main");
	// Set 'ThreadRoutine' as an active thread
	EXPECT_TRUE(ee.GetExpressionValue("dwSecondaryThreadID" ,&ulThreadID));
	EXPECT_TRUE(threads.SetCurrentThread(ulThreadID));

	HelperFunctionVerifyEIP("IntegrityWithSetFocusToThread", szEIP);
	if (strcmp(szOriginalEIP, szEIP))
		LOG->RecordInfo("szOriginalEIP=[%s], szEIP=[%s]", szOriginalEIP, szEIP);
	EXPECT_TRUE(0 == strcmp(szOriginalEIP, szEIP));
}

void CRegistersIDETest::IntegrityWithFunctionEvaluation(void)
{

	LOGTESTHEADER("IntegrityWithFunctionEvaluation");

	CString csFooAddress;
	char szEIP[512];

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.ShowNextStatement());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	EXPECT_TRUE(dbg.StepInto(1));

	// Get Foo address from the Watch window
	EXPECT_TRUE(ee.GetExpressionValue(CString("Foo"), csFooAddress));
	csFooAddress = csFooAddress.Mid(2, 8);
	csFooAddress.MakeUpper();

	// Get EIP from the Registers and Disassembly window
	HelperFunctionVerifyEIP("IntegrityWithFunctionEvaluation", szEIP);

	// Compare
	EXPECT_TRUE(0 == strcmp(LPCTSTR(csFooAddress), szEIP));
}

void CRegistersIDETest::BoundaryConditionsForEditingValues(void)
{

	LOGTESTHEADER("BoundaryConditionsForEditingValues");

	char szOriginalEIP[512];
	char szEIP[512];

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.ShowNextStatement());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	// Get EIP from the Registers and Disassembly window
	HelperFunctionVerifyEIP("BoundaryConditionsForEditingValues", szOriginalEIP);

	// Open Disasm and try Boundary conditions
	EXPECT_TRUE(dam.Enable());
	EXPECT_TRUE(regs.Enable());
	EXPECT_TRUE(regs.SetRegister(CString("EIP"), CString("00000000"), -1));
	EXPECT_TRUE(regs.SetRegister(CString("EIP"), CString("FFFFFFFF"), -1));
	EXPECT_TRUE(regs.SetRegister(CString("EIP"), CString(szOriginalEIP), -1));

	// Close Disasm and compare EIP
	EXPECT_TRUE(dam.Disable());
	HelperFunctionVerifyEIP("BoundaryConditionsForEditingValues", szEIP);
	EXPECT_TRUE(0 == strcmp(szOriginalEIP, szEIP));

}

void CRegistersIDETest::TypeInvalidValues(void)
{

	LOGTESTHEADER("TypeInvalidValues");

	CString csRegValue;
	char *pszCPURegs[] =		{"EAX ", "EBX ", "ECX ", "EDX ", "ESI ", "EDI ", "EIP ", "ESP ", "EBP ", "EFL "};
	char *pszCPUSegments[] = 	{"CS ", "DS ", "ES ", "SS ", "FS ", "GS " }; 
	char *pszFloatingInt[] =	{"CTRL ", "STAT ", "TAGS ", "EIP ", "CS ", "DS ", "EDO "};
	char *pszFlags[] =			{"OV", "UP", "EI", "PL", "ZR", "AC", "PE" , "CY"};


	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.ShowNextStatement());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	EXPECT_TRUE(regs.Enable());
/*
	// Get initial values
	for(int ii = 0; ii < sizeof(pszCPURegs)/sizeof(*pszCPURegs); ii++)
	{
		csRegValue = regs.GetRegister(CString(pszCPURegs[ii]), NULL);
		EXPECT_TRUE(regs.SetRegister(CString(pszCPURegs[ii]), CString("JK%$#KL{"), -1));
		EXPECT_TRUE(regs.RegisterValueIs(CString(pszCPURegs[ii]), CString(csRegValue), -1));
	}

	for(ii = 0; ii < sizeof(pszCPUSegments)/sizeof(*pszCPUSegments); ii++)
	{
		csRegValue = regs.GetRegister(CString(pszCPUSegments[ii]), NULL);
		EXPECT_TRUE(regs.SetRegister(CString(pszCPUSegments[ii]), CString("JK%$"), -1));
		EXPECT_TRUE(regs.RegisterValueIs(CString(pszCPUSegments[ii]), CString(csRegValue), -1));
	}

	for(ii = 0; ii < sizeof(pszFloatingInt)/sizeof(*pszFloatingInt); ii++)
	{
		csRegValue = regs.GetRegister(CString(pszFloatingInt[ii]), NULL);
		EXPECT_TRUE(regs.SetRegister(CString(pszFloatingInt[ii]), CString("#KL{"), -1));
		EXPECT_TRUE(regs.RegisterValueIs(CString(pszFloatingInt[ii]), CString(csRegValue), -1));
	}
*/
	for(int ii = 0; ii < sizeof(pszFlags)/sizeof(*pszFlags); ii++)
	{
		csRegValue = regs.GetRegister(CString(pszFlags[ii]), NULL);

		// Try to set invalid number (2) for even flags
		if((float) (ii/2) == (float)ii/2.)
		{
			EXPECT_TRUE(regs.SetRegister(CString(pszFlags[ii]), CString("2"), -1));
		}
		// Try to set invalid letter (S) for odd flags
		else
		{
			EXPECT_TRUE(regs.SetRegister(CString(pszFlags[ii]), CString("S"), -1));
		}

		EXPECT_TRUE(regs.RegisterValueIs(CString(pszFlags[ii]), CString(csRegValue), -1));
	}
}

void CRegistersIDETest::FloatingPointException(void)
{

	LOGTESTHEADER("FloatingPointException");

	//	ADDED BY DVERMA 4/19/2000 as exception not thrown on Win ME 
	//	won't fix bug #64854 - changes to CTRL don't persist.
	DWORD sysVal = GetSystem();
	if ((sysVal == SYSTEM_WIN_95) || (sysVal == SYSTEM_WIN_98) || (sysVal == SYSTEM_WIN_MILL))
	{
		LOG->RecordInfo("FloatingPointException() - test won't run on Win 9X OS.");
		return;
	}	

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.ShowNextStatement());
	EXPECT_TRUE(src.Find("/* Exception should be here for CTRL 277 */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	EXPECT_TRUE(regs.Enable());
	EXPECT_TRUE(regs.SetRegister(CString("CTRL"), CString("0277"), -1));
	EXPECT_TRUE(dbg.StepOver(1, NULL, NULL, NULL, NOWAIT));
	// wait for the exception message to come up.
	while(!MST.WButtonExists(GetLocString(IDSS_OK)));
	MST.DoKeys("{ENTER}");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.ShowNextStatement());
	EXPECT_TRUE(src.Find("/* Exception should be here for CTRL 27B */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	EXPECT_TRUE(regs.Enable());
	EXPECT_TRUE(regs.SetRegister(CString("CTRL"), CString("027B"), -1));
	EXPECT_TRUE(dbg.StepOver(1, NULL, NULL, NULL, NOWAIT));
	// wait for the exception message to come up.
	while(!MST.WButtonExists(GetLocString(IDSS_OK)));
	MST.DoKeys("{ENTER}");
}


void CRegistersIDETest::VerifyDockingView(void)
{
	LOGTESTHEADER("VerifyDockingView");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.ShowNextStatement());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	EXPECT_TRUE(uidam.EnableDockingView(TRUE));
	EXPECT_TRUE(uidam.IsDockingViewEnabled());
	// TODO: (dklem 09/14/98) Uncomment the following line when #6572 gets fixed
	// The bug #6572 is Memory leak while resizing DAM window. This leak is not that bad in the Release version
	// Based on my tests the Debug vesion consumes ~71,000K (at the peak) while running this test suite, Release version - 23,000K (at the peak) , which is acceptable
	// Comment the next line if the Debug version of MSDEV causes Out of Memory
	// TODO(michma - 3/2/00): this isn't working yet.
	//TestResizeMoveWindow(TRUE, TRUE);	

	EXPECT_TRUE(uidam.EnableDockingView(FALSE));
	EXPECT_TRUE(!uidam.IsDockingViewEnabled());
	// TODO: (dklem 09/14/98) Uncomment the following line when #6572 gets fixed
	// The bug #6572 is Memory leak while resizing DAM window. This leak is not that bad in the Release version
	// Based on my tests the Debug vesion consumes ~71,000K (at the peak) while running this test suite, Release version - 23,000K (at the peak) , which is acceptable
	// Comment the next line if the Debug version of MSDEV causes Out of Memory
	// TODO(michma - 3/2/00): this isn't working yet.
	//TestResizeMoveWindow(FALSE, TRUE);	

	EXPECT_TRUE(uidam.ChooseContextMenuItem(CLOSE_HIDE));

}


void CRegistersIDETest::MinimalTestResizeMoveWindow()
{

// TODO remove the next line immediately
//	return;
	
	BOOL bInitiallyMaximized;

	uidam.Activate();
	HWND hwnd = uidam.HWnd();

	if(IsZoomed(hwnd))
	{
		bInitiallyMaximized = TRUE;
		ShowWindow(hwnd, SW_RESTORE);
	}
	else 
		bInitiallyMaximized = FALSE;
	
	

	// TODO: (dklem 09/14/98) Uncomment the following 4 lines when #6572 gets fixed
	// The bug #6572 is Memory leak while resizing DAM window. This leak is not that bad in the Release version
	// Based on my tests the Debug vesion consumes ~71,000K (at the peak) while running this test suite, Release version - 23,000K (at the peak) , which is acceptable
	// Comment the next 4 lines if the Debug version of MSDEV causes Out of Memory
	// TODO(michma - 3/2/00): this isn't working yet.
	//TestResizeMoveWindow(FALSE, FALSE);

	// Restore the DAM window before turning Docking View on
	if(bInitiallyMaximized)
		ShowWindow(hwnd, SW_MAXIMIZE);
	
	EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));

	// TODO(michma - 3/2/00): this isn't working yet.
	//TestResizeMoveWindow(TRUE, FALSE);
	EXPECT_TRUE(uidam.ChooseContextMenuItem(DOCKING_VIEW));
}

/*

TODO(michma - 3/2/00): this isn't working yet.

void CRegistersIDETest::TestResizeMoveWindow(BOOL bIsDocked, BOOL bFullTest)
{
	int nPositionMoved;
	uiregs.Activate();

	BOOL DragFullWindows = TRUE;
	EXPECT_TRUE(GetDragFullWindows(&DragFullWindows));

	// Try minimum hor and ver sizes
	nPositionMoved = uiregs. ResizeWindow(bIsDocked, SLeft, DRight, -1, DragFullWindows);
	uiregs.ResizeWindow(bIsDocked, SLeft, DLeft, nPositionMoved, DragFullWindows);

	nPositionMoved = uiregs.ResizeWindow(bIsDocked, SBottom, DUp, -1, DragFullWindows);
	uiregs.ResizeWindow(bIsDocked, SBottom, DDown, nPositionMoved, DragFullWindows);

	// Move the window
	nPositionMoved = uiregs.MoveWindow(bIsDocked, DRight, 20, DragFullWindows);
	nPositionMoved = uiregs.MoveWindow(bIsDocked, DDown, 20, DragFullWindows);
	nPositionMoved = uiregs.MoveWindow(bIsDocked, DLeft, 20, DragFullWindows);
	nPositionMoved = uiregs.MoveWindow(bIsDocked, DUp, 20, DragFullWindows);

	if(!bFullTest) return;

	// Try to go beyond screen borders
	nPositionMoved = uiregs.ResizeWindow(bIsDocked, SLeft, DLeft, -1, DragFullWindows);
	if(!DragFullWindows)
	{
		EXPECT_TRUE(uiregs.ChooseContextMenuItem(DOCKING_VIEW));
		EXPECT_TRUE(uiregs.ChooseContextMenuItem(DOCKING_VIEW));
		uiregs.Activate();
	}
	uiregs.ResizeWindow(bIsDocked, SLeft, DRight, nPositionMoved, DragFullWindows);

	nPositionMoved = uiregs.ResizeWindow(bIsDocked, SRight, DRight, -1, DragFullWindows);
	if(!DragFullWindows)
	{
		EXPECT_TRUE(uiregs.ChooseContextMenuItem(DOCKING_VIEW));
		EXPECT_TRUE(uiregs.ChooseContextMenuItem(DOCKING_VIEW));
		uiregs.Activate();
	}
	uiregs.ResizeWindow(bIsDocked, SRight, DLeft, nPositionMoved, DragFullWindows);

	nPositionMoved = uiregs.ResizeWindow(bIsDocked, SBottom, DDown, -1, DragFullWindows);
	if(!DragFullWindows)
	{
		EXPECT_TRUE(uiregs.ChooseContextMenuItem(DOCKING_VIEW));
		EXPECT_TRUE(uiregs.ChooseContextMenuItem(DOCKING_VIEW));
		uiregs.Activate();
	}
	uiregs.ResizeWindow(bIsDocked, SBottom, DUp, nPositionMoved, DragFullWindows);

	nPositionMoved = uiregs.ResizeWindow(bIsDocked, STop, DUp, -1, DragFullWindows);
	// If we move it to far, the title bar is not available, we need to reactivate memory window
	EXPECT_TRUE(uiregs.ChooseContextMenuItem(DOCKING_VIEW));
	EXPECT_TRUE(uiregs.ChooseContextMenuItem(DOCKING_VIEW));
	uiregs.Activate();
	uiregs.ResizeWindow(bIsDocked, STop, DDown, 10, DragFullWindows);

	// I like to move it move it
	nPositionMoved = uiregs.MoveWindow(bIsDocked, DRight, -1, DragFullWindows);
	// If we move it to far, the title bar is not available, we need to reactivate memory window
	EXPECT_TRUE(uiregs.ChooseContextMenuItem(DOCKING_VIEW));
	EXPECT_TRUE(uiregs.ChooseContextMenuItem(DOCKING_VIEW));
	uiregs.Activate();
	uiregs.MoveWindow(bIsDocked, DLeft, nPositionMoved, DragFullWindows);

	nPositionMoved = uiregs.MoveWindow(bIsDocked, DLeft, -1, DragFullWindows);
	EXPECT_TRUE(uiregs.ChooseContextMenuItem(DOCKING_VIEW));
	EXPECT_TRUE(uiregs.ChooseContextMenuItem(DOCKING_VIEW));
	uiregs.Activate();
	uiregs.MoveWindow(bIsDocked, DRight, nPositionMoved, DragFullWindows);

	nPositionMoved = uiregs.MoveWindow(bIsDocked, DDown, -1, DragFullWindows);
	EXPECT_TRUE(uiregs.ChooseContextMenuItem(DOCKING_VIEW));
	EXPECT_TRUE(uiregs.ChooseContextMenuItem(DOCKING_VIEW));
	uiregs.Activate();
	uiregs.MoveWindow(bIsDocked, DUp, nPositionMoved, DragFullWindows);

	EXPECT_TRUE(uiregs.ChooseContextMenuItem(DOCKING_VIEW));
	EXPECT_TRUE(uiregs.ChooseContextMenuItem(DOCKING_VIEW));
	uiregs.Activate();

	nPositionMoved = uiregs.MoveWindow(bIsDocked, DUp, -1, DragFullWindows);
	EXPECT_TRUE(uiregs.ChooseContextMenuItem(DOCKING_VIEW));
	EXPECT_TRUE(uiregs.ChooseContextMenuItem(DOCKING_VIEW));
	uiregs.Activate();
	uiregs.MoveWindow(bIsDocked, DDown, nPositionMoved, DragFullWindows);

}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\registers\regcase.h ===
///////////////////////////////////////////////////////////////////////////////
//	Regcase.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CRegistersIDETest Class
//

#ifndef __Regcase_H__
#define __Regcase_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\DbgTestBase.h"
#include "regsub.h"

const int gl_constNumberUndoRedo = 1;

///////////////////////////////////////////////////////////////////////////////
//	CRegistersIDETest class

class CRegistersIDETest : public CDbgTestBase
{
	DECLARE_TEST(CRegistersIDETest, CRegistersSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);

// Test Cases

	void VerifyEIP(void);
	void EIP_ESP_ChangeAfterStep(void);
	void VerifyFlags(void);
	void VerifyEAX(void);
	void EditRegisters(void);
	void ToggleFlags(void);
	void EditRegisterViaQuickWatch(void);
	void Registers_Dam_Watch_Memory(void);
	void Registers_Watch_Memory(void);
	void Change_EAX_Changes_RetValue(void);
	void DisplayIsAlwaysHex(void);
	void IntegrityWithSetFocusToThread(void);
	void IntegrityWithFunctionEvaluation(void);
	void BoundaryConditionsForEditingValues(void);
	void TypeInvalidValues(void);
	void FloatingPointException(void);
	void VerifyDockingView(void);

protected:
	void HelperFunctionVerifyEIP(char* szTestCaseName, char* szEIP);
	void MinimalTestResizeMoveWindow(void);
// TODO(michma - 3/2/00): this isn't working yet.
//	void TestResizeMoveWindow(BOOL bIsDocked, BOOL bFullTest);

private:
	char m_pszUndoRedoRegisters[gl_constNumberUndoRedo][128];
	int m_TestNumber;
	int m_TotalNumberOfTests;
	CString m_strLogInfo;
};

#endif //__Regcase_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\registers\registerspp.h ===
///////////////////////////////////////////////////////////////////////////////
//	RegistersPP.h
//
//	Created by:			
//		dverma
//
//	Description:
//		VC6 Processor Pack testcases.
//

#ifndef __RegistersPP_H__
#define __RegistersPP_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\DbgTestBase.h"
#include "regsub.h"
//#include "eesub.h"	//	for watch window access

///////////////////////////////////////////////////////////////////////////////
//	CRegistersPP class

class CRegistersPP : public CDbgTestBase

{
	DECLARE_TEST(CRegistersPP, CRegistersSubSuite)

// Attributes
public:
	// the base name of the localized directories and files we will use.
	CString m_strProjBase;
	// the location of the unlocalized sources, under which the projects we will use will be located.
	CString m_strSrcDir;
	// the locations of the dll and exe projects, and their localized sources, that we will use for this test.
	CString m_strExeDir;

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);

// Test Cases	

	void VerifyUnsupportedRegistersNotPresent(void);
	void TestMMXreg(void);
	//xbox void Test3dNowReg(void);
	void TestXMMreg(void);
	//xbox void TestWNIreg(void);
	void testRegVal(char *varname, char *vartype, char *value, char *message);
	void VerifyRegArray(CString Arr[],int Num_items);

private:
	int m_TestNumber;
	int m_TotalNumberOfTests;
	CString m_strLogInfo;
	//xbox char bSystemIsWin9X;
};

#endif //__RegistersPP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\registers\registerspp.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	RegistersPP.CPP
//											 
//	Created by:			
//		dverma
//
//	Description:								 
//		VC6 Processor Pack testcases.		 

#include "stdafx.h"
#include "RegistersPP.h"	
#include <stdlib.h>

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
											   
IMPLEMENT_TEST(/*999,*/ CRegistersPP, CDbgTestBase, "Processor Pack", -1, CRegistersSubSuite)

// each function that runs a test has this prototype.
typedef void (CRegistersPP::*PTR_TEST_FUNC)(void); 

// Information about a test to be put in the test header
#define LOGTESTHEADER(strTestName) 	m_strLogInfo.Format("# - %d.  %s. Total # - %d, Passed - %d %%", ++m_TestNumber, strTestName, m_TotalNumberOfTests, (m_TestNumber * 100) / m_TotalNumberOfTests);  \
									LogTestHeader(m_strLogInfo);

// we randomly pick out of the following list of tests and run them.
// insert functions for new tests to the end of the list.
PTR_TEST_FUNC tests[] = 
{
	&CRegistersPP::VerifyUnsupportedRegistersNotPresent,
	&CRegistersPP::TestMMXreg,
	//&CRegistersPP::Test3dNowReg,
	&CRegistersPP::TestXMMreg,
	//&CRegistersPP::TestWNIreg
};

											 
void CRegistersPP::PreRun(void)
{
	// call the base class
	CTest::PreRun();

}


void CRegistersPP::Run()

{	 
	if (!CreateXboxProjectFromSource("Registers PP", "src\\Registers PP",
				"Registers PP.cpp"))
			return;
	
	// all tests expect the ide to be in this initial state.
	EXPECT_TRUE(dbg.StepOver());

	// indexes into the test function array.
	int iTest;
	m_TestNumber = 0;
	m_TotalNumberOfTests = sizeof(tests) / sizeof(PTR_TEST_FUNC);
	
	for(iTest = 0; iTest < m_TotalNumberOfTests; iTest++)
		(this->*(tests[iTest]))();
}	

///////////////////////////////////////////////////////////////////////////////
//	Test Cases
///////////////////////////////////////////////////////////////////////////////

void CRegistersPP::testRegVal(char *varname, char *vartype, char *value, char *message)
{
	EXPR_INFO expr_info;

	cxx.FillExprInfo(expr_info, NOT_EXPANDABLE, vartype, varname, value);		
	if(cxx.VerifyExprInfo(expr_info))
		LOG->RecordSuccess("%s : %s\n", expr_info.name,message);
	else
		LOG->RecordFailure("%s : %s\n", expr_info.name,message);

}

void CRegistersPP::VerifyRegArray(CString Arr[],int Num_items)
{
	EXPECT_TRUE(regs.Enable());

	for (int count = 0; count< Num_items; count++)
		EXPECT_FALSE(regs.RegisterDisplayed(Arr[count]));	

	EXPECT_TRUE(regs.Disable());
}

void CRegistersPP::VerifyUnsupportedRegistersNotPresent(void)
{
	CString MMXijRegs[] = {	"MM00","MM10","MM20","MM30","MM40","MM50","MM60","MM70",
							"MM01","MM11","MM21","MM31","MM41","MM51","MM61","MM71"};

	CString XMMRegs[] = {"XMM0","XMM1","XMM2","XMM3","XMM4","XMM5","XMM6","XMM7"};
	CString XMMijRegs[] = {	"XMM00","XMM01","XMM02","XMM03", "XMM10","XMM11","XMM12","XMM13",
							"XMM20","XMM21","XMM22","XMM23", "XMM30","XMM31","XMM32","XMM33",
							"XMM40","XMM41","XMM42","XMM43", "XMM50","XMM51","XMM52","XMM53",
							"XMM60","XMM61","XMM62","XMM63", "XMM70","XMM71","XMM72","XMM73" };

	CString XMM0DRegs[] = {	"XMM0DL","XMM0DH","XMM1DL","XMM1DH","XMM2DL","XMM2DH",
							"XMM3DL","XMM3DH","XMM4DL","XMM4DH","XMM5DL","XMM5DH",
							"XMM6DL","XMM6DH","XMM7DL","XMM7DH" };

	//	3dnow system
	if (CMDLINE->GetBooleanValue("k6",FALSE)||CMDLINE->GetBooleanValue("k7",FALSE))
	{
		VerifyRegArray(XMMRegs,8);
		VerifyRegArray(XMMijRegs,32);
		VerifyRegArray(XMM0DRegs,16);
	}

	//	P3 system
	if (CMDLINE->GetBooleanValue("kni",FALSE)||CMDLINE->GetBooleanValue("wni",FALSE))
	{
		VerifyRegArray(MMXijRegs,16);
	}

	//	KNI systems do not have XMMiD regs
	if (CMDLINE->GetBooleanValue("kni",FALSE))
	{
		VerifyRegArray(XMM0DRegs,16);
	}
}

void CRegistersPP::TestMMXreg(void)
{
	//	MMX switch has already been checked for in Run()
	
	LOGTESTHEADER("TestMMXreg");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	MST.DoKeys("{ESC}");
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(src.Find("TestMMX();")); 
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepInto());	
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StepOver());

	CString MMXRegs[] = {"MM0","MM1","MM2","MM3","MM4","MM5","MM6","MM7"};
	CString MMXRegValues[] = {	"1111111111111111",
								"2222222222222222",
								"3333333333333333",
								"4444444444444444",
								"5555555555555555",
								"6666666666666666",
								"7777777777777777",
								"8888888888888888"};

	int num_reg = 8;
	int count = 0;

	//	step through source code
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(dbg.StepOver());
		EXPECT_TRUE(dbg.StepOver());
	}

	//	do one stepover
	//xbox if (!bSystemIsWin9X)
	EXPECT_TRUE(dbg.StepOver());

	//	now verify register values	
	EXPECT_TRUE(regs.Enable());

	for (count = 0; count< num_reg; count++)
	{
		//	test in reg window
		EXPECT_TRUE(regs.RegisterValueIs(MMXRegs[count], "" , (count+1)*100, FALSE));	
	}
	
	
	EXPECT_TRUE(cxx.Enable(EE_ALL_INFO));
	
	for (count = 0; count< num_reg; count++)
	{
		//	test in watch window
		char str[32];
		char strReg[8];
		strcpy(strReg,MMXRegs[count]);
		itoa((count+1)*100,str,10);

		testRegVal(strReg, "unsigned __int64", str,"Test MMX in Watch - Code");
	}

	//	modify register MMi in reg window
	EXPECT_TRUE(regs.Enable());
	
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.SetRegister(MMXRegs[count], MMXRegValues[count] , 0, TRUE));
	}
	
	//	do one stepover
	EXPECT_TRUE(regs.Disable());
	
	//xbox if (!bSystemIsWin9X)
	EXPECT_TRUE(dbg.StepOver());

	//	now verify register values

	EXPECT_TRUE(regs.Enable());	
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.RegisterValueIs(MMXRegs[count], MMXRegValues[count] , 0, TRUE));
	}

	EXPECT_TRUE(cxx.Enable(EE_ALL_INFO));
	EXPECT_TRUE(dbg.ToggleHexDisplay(TRUE));
	for (count = 0; count< num_reg; count++)
	{
		//	test in watch window
		char str[32];
		char strReg[8];
		strcpy(strReg,MMXRegs[count]);
		strcpy(str,"0x");
		strcat(str,MMXRegValues[count]);
		testRegVal(strReg, "unsigned __int64", str,"Test MMX in Watch - Reg Window");
	}
	EXPECT_TRUE(dbg.ToggleHexDisplay(FALSE));
}

/*
void CRegistersPP::Test3dNowReg(void)
{
	if (!(CMDLINE->GetBooleanValue("k6",FALSE)||CMDLINE->GetBooleanValue("k7",FALSE))) 
		return;	//	exit if 3dnow switch is not set	
	
	LOGTESTHEADER("Test3dNowReg");

	//	Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	MST.DoKeys("{ESC}");
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(src.Find("Test3dNow();")); 
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepInto());	
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StepOver());	
	
	CString MMXRegs[] = {"MM0","MM1","MM2","MM3","MM4","MM5","MM6","MM7"};

	CString MMXijRegs[] = {	"MM00","MM10","MM20","MM30","MM40","MM50","MM60","MM70",
							"MM01","MM11","MM21","MM31","MM41","MM51","MM61","MM71"};

	CString MMXijRegValues[] = {	"+1.11111E+001","+2.22222E+001","+3.33333E+001","+4.44444E+001","+5.55555E+001",
									"+6.66666E+001","+7.77777E+001","+8.88888E+001",
									"-1.11111E-001","-2.22222E-001","-3.33333E-001","-4.44444E-001","-5.55555E-001",
									"-6.66666E-001","-7.77777E-001","-8.88888E-001"};


	CString MMXRegVal[] = {	"BDE38E2A4131C711","BE638E2A41B1C711","BEAAAA9F4205554D","BEE38E2A4231C711",
							"BF0E38DA425E38D5","BF2AAA9F4285554D","BF471C65429B8E2F","BF638E2A42B1C711" };

	int num_reg = 8;
	int count = 0;

	//	step through source code
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(dbg.StepOver());
		EXPECT_TRUE(dbg.StepOver());
	}

	//	do one stepover
	if (!bSystemIsWin9X)
	EXPECT_TRUE(dbg.StepOver());

	//	now verify register values
	CString MMXijStepOverValues[] = {	"+1.00000E+000","+3.00000E+000","+5.00000E+000","+7.00000E+000","+9.00000E+000",
										"+1.10000E+001","+1.30000E+001","+1.50000E+001","+2.00000E+000","+4.00000E+000",
										"+6.00000E+000","+8.00000E+000","+1.00000E+001","+1.20000E+001","+1.40000E+001",
										"+1.60000E+001"	};
	
	//	test in reg window
	EXPECT_TRUE(regs.Enable());
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.RegisterValueIs(MMXijRegs[count], MMXijStepOverValues[count], 0, TRUE));
		EXPECT_TRUE(regs.RegisterValueIs(MMXijRegs[count+num_reg], MMXijStepOverValues[count+num_reg], 0, TRUE));	
	}

	//	test in watch window
	EXPECT_TRUE(cxx.Enable(EE_ALL_INFO));
	for (count = 0; count< num_reg; count++)
	{
		char str[32];
		char strReg[8];
		float f = 0.0;
	
		strcpy(strReg,MMXijRegs[count]);		
		f = (float) atof(MMXijStepOverValues[count]);
		
		if (f < 10)
			sprintf(str,"%6.5f",f);
		else
			sprintf(str,"%6.4f",f);
		
		testRegVal(strReg, "float", str,"Test MMXij in Watch - Code");
		
		strcpy(strReg,MMXijRegs[count+num_reg]);		
		f = (float) atof(MMXijStepOverValues[count+num_reg]);

		if (f < 10)
			sprintf(str,"%6.5f",f);
		else
			sprintf(str,"%6.4f",f);
		
		testRegVal(strReg, "float", str,"Test MMXij in Watch - Code");
	}



	EXPECT_TRUE(regs.Enable());

	//	initialize MMi to set MMij correctly
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.SetRegister(MMXRegs[count],"B727C5AC47C35000" , 0, TRUE));
	}

	//	verify that MMij changed correctly
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.RegisterValueIs(MMXijRegs[count], "+1.00000E+005", 0, TRUE));
		EXPECT_TRUE(regs.RegisterValueIs(MMXijRegs[count+num_reg], "-1.00000E-005", 0, TRUE));
	}

	//	modify register MMi0 & MMi1 in reg window
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.SetRegister(MMXijRegs[count], MMXijRegValues[count], 0, TRUE));
		EXPECT_TRUE(regs.SetRegister(MMXijRegs[count+num_reg], MMXijRegValues[count+num_reg], 0, TRUE));
	}

	EXPECT_TRUE(regs.Disable());

	//	do one stepover
	if (!bSystemIsWin9X)
	EXPECT_TRUE(dbg.StepOver());

	//	verify MMij values

	//	test in reg window
	EXPECT_TRUE(regs.Enable());
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.RegisterValueIs(MMXijRegs[count], MMXijRegValues[count], 0, TRUE));
		EXPECT_TRUE(regs.RegisterValueIs(MMXijRegs[count+num_reg], MMXijRegValues[count+num_reg], 0, TRUE));	
	}

	//	test in watch window
	EXPECT_TRUE(cxx.Enable(EE_ALL_INFO));
	for (count = 0; count< num_reg; count++)
	{
		char str[32];
		char strReg[8];
		float f = 0.0;
	
		strcpy(strReg,MMXijRegs[count]);		
		f = (float) atof(MMXijRegValues[count]);
		sprintf(str,"%6.4f",f);
		testRegVal(strReg, "float", str,"Test MMXij in Watch - Code");
		
		strcpy(strReg,MMXijRegs[count+num_reg]);		
		f = (float) atof(MMXijRegValues[count+num_reg]);
		sprintf(str,"%f",f);
		testRegVal(strReg, "float", str,"Test MMXij in Watch - Code");
	}

	//	verify that MMi changed correctly
	EXPECT_TRUE(regs.Enable());
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.RegisterValueIs(MMXRegs[count], MMXRegVal[count], 0, TRUE));
	}

}
*/

void CRegistersPP::TestXMMreg(void)
{
	if (!(CMDLINE->GetBooleanValue("kni",FALSE)||CMDLINE->GetBooleanValue("wni",FALSE))) 
		return;	//	exit if P3 switch is not set	

	LOGTESTHEADER("TestXMMreg");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	MST.DoKeys("{ESC}");
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(src.Find("TestXMM();")); 
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepInto());	
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StepOver());

	CString XMMRegs[] = {"XMM0","XMM1","XMM2","XMM3","XMM4","XMM5","XMM6","XMM7"};
	CString XMMRegValues[] = {	"11111111111111111111111111111111",
								"22222222222222222222222222222222",
								"33333333333333333333333333333333",
								"44444444444444444444444444444444",
								"55555555555555555555555555555555",
								"66666666666666666666666666666666",
								"77777777777777777777777777777777",
								"88888888888888888888888888888888"};

	CString XMMijRegs[] = {	"XMM00","XMM01","XMM02","XMM03", "XMM10","XMM11","XMM12","XMM13",
							"XMM20","XMM21","XMM22","XMM23", "XMM30","XMM31","XMM32","XMM33",
							"XMM40","XMM41","XMM42","XMM43", "XMM50","XMM51","XMM52","XMM53",
							"XMM60","XMM61","XMM62","XMM63", "XMM70","XMM71","XMM72","XMM73" };

	CString XMMijRegValues[] = {	"+1.00000E+001","+1.00001E+001","+1.00011E+001","+1.00111E+001",
									"+2.00000E+001","+2.00002E+001","+2.00022E+001","+2.00222E+001",
									"+3.00000E+001","+3.00003E+001","+3.00033E+001","+3.00333E+001",
									"+4.00000E+001","+4.00004E+001","+4.00044E+001","+4.00444E+001",	
									"+5.00000E+001","+5.00005E+001","+5.00055E+001","+5.00555E+001",	
									"+6.00000E+001","+6.00006E+001","+6.00066E+001","+6.00666E+001",	
									"+7.00000E+001","+7.00007E+001","+7.00077E+001","+7.00777E+001",	
									"+8.00000E+001","+8.00008E+001","+8.00088E+001","+8.00888E+001"	};

	int num_reg = 8;
	int count = 0;

	CString XMMRegTestVal[] = {	
							"4080000040400000400000003F800000",		//	4,3,2,1
							"4100000040E0000040C0000040A00000",		//	8,7,6,5
							"41400000413000004120000041100000",		//	12,11,10,9
							"41800000417000004160000041500000",		//	16,15,14,13
							"41A00000419800004190000041880000",		//	20,19,18,17
							"41C0000041B8000041B0000041A80000",		//	24,23,22,21
							"41E0000041D8000041D0000041C80000",		//	28,27,26,25
							"4200000041F8000041F0000041E80000"		//	32,31,30,29
								};

	//	step through source code
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(dbg.StepOver());
	}

	//	do one stepover
	//xbox if (!bSystemIsWin9X)
	EXPECT_TRUE(dbg.StepOver());

	//	now verify XMMi register values
	EXPECT_TRUE(regs.Enable());
	
	for (count = 0; count< num_reg; count++)
	{		
		EXPECT_TRUE(regs.RegisterValueIs(XMMRegs[count], XMMRegTestVal[count] ,0 , TRUE));
	}

	//	verify XMMij
	CString XMMijStepOverValues[] = {	
									"+1.00000E+000","+2.00000E+000","+3.00000E+000","+4.00000E+000",
									"+5.00000E+000","+6.00000E+000","+7.00000E+000","+8.00000E+000",
									"+9.00000E+000","+1.00000E+001","+1.10000E+001","+1.20000E+001",
									"+1.30000E+001","+1.40000E+001","+1.50000E+001","+1.60000E+001",	
									"+1.70000E+001","+1.80000E+001","+1.90000E+001","+2.00000E+001",	
									"+2.10000E+001","+2.20000E+001","+2.30000E+001","+2.40000E+001",	
									"+2.50000E+001","+2.60000E+001","+2.70000E+001","+2.80000E+001",	
									"+2.90000E+001","+3.00000E+001","+3.10000E+001","+3.20000E+001"	
									};

	//	test in reg window
	EXPECT_TRUE(regs.Enable());
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.RegisterValueIs(XMMijRegs[count*4], XMMijStepOverValues[count*4] , 0, TRUE));
		EXPECT_TRUE(regs.RegisterValueIs(XMMijRegs[count*4 + 1], XMMijStepOverValues[count*4 + 1] , 0, TRUE));
		EXPECT_TRUE(regs.RegisterValueIs(XMMijRegs[count*4 + 2], XMMijStepOverValues[count*4 + 2] , 0, TRUE));
		EXPECT_TRUE(regs.RegisterValueIs(XMMijRegs[count*4 + 3], XMMijStepOverValues[count*4 + 3] , 0, TRUE));
	}

	//	test in watch window
	EXPECT_TRUE(cxx.Enable(EE_ALL_INFO));
	for (count = 0; count< num_reg; count++)
	{
		char str[32];
		char strReg[8];
		float f = 0.0;
	
		strcpy(strReg,XMMijRegs[count*4]);		
		f = (float) atof(XMMijStepOverValues[count*4]);

		if (f < 10)
			sprintf(str,"%6.5f",f);
		else
			sprintf(str,"%6.4f",f);

		testRegVal(strReg, "float", str,"Test XMMij in Watch - Code");
		
		strcpy(strReg,XMMijRegs[count*4 + 1]);		
		f = (float) atof(XMMijStepOverValues[count*4 + 1]);
		
		if (f < 10)
			sprintf(str,"%6.5f",f);
		else
			sprintf(str,"%6.4f",f);
		
		testRegVal(strReg, "float", str,"Test XMMij in Watch - Code");

		strcpy(strReg,XMMijRegs[count*4+ 2]);		
		f = (float) atof(XMMijStepOverValues[count*4 + 2]);
		
		if (f < 10)
			sprintf(str,"%6.5f",f);
		else
			sprintf(str,"%6.4f",f);
		
		testRegVal(strReg, "float", str,"Test XMMij in Watch - Code");

		strcpy(strReg,XMMijRegs[count*4+ 3]);		
		f = (float) atof(XMMijStepOverValues[count*4 + 3]);
		
		if (f < 10)
			sprintf(str,"%6.5f",f);
		else
			sprintf(str,"%6.4f",f);

		testRegVal(strReg, "float", str,"Test XMMij in Watch - Code");
	}
	
	//	modify register XMMi in reg window
	EXPECT_TRUE(regs.Enable());
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.SetRegister(XMMRegs[count], XMMRegValues[count] , 0, TRUE));
	}

	//	do one stepover
	EXPECT_TRUE(regs.Disable());

	//xbox if (!bSystemIsWin9X)
	EXPECT_TRUE(dbg.StepOver());

	//	now verify XMMi register values
	EXPECT_TRUE(regs.Enable());
	
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.RegisterValueIs(XMMRegs[count], XMMRegValues[count] , 0 , TRUE));
	}

	//	initialize XMMi to set XMMij correctly
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.SetRegister(XMMRegs[count], "47C3500047C3500047C3500047C35000" , 0, TRUE));
	}

	//	verify that XMMij changed correctly
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.RegisterValueIs(XMMijRegs[count*4], "+1.00000E+005", 0, TRUE));
		EXPECT_TRUE(regs.RegisterValueIs(XMMijRegs[count*4 + 1], "+1.00000E+005", 0, TRUE));
		EXPECT_TRUE(regs.RegisterValueIs(XMMijRegs[count*4 + 2], "+1.00000E+005", 0, TRUE));
		EXPECT_TRUE(regs.RegisterValueIs(XMMijRegs[count*4 + 3], "+1.00000E+005", 0, TRUE));
	}

	//	modify register XMMij in reg window
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.SetRegister(XMMijRegs[count*4], XMMijRegValues[count*4] , 0, TRUE));
		EXPECT_TRUE(regs.SetRegister(XMMijRegs[count*4 + 1], XMMijRegValues[count*4 + 1] , 0, TRUE));
		EXPECT_TRUE(regs.SetRegister(XMMijRegs[count*4 + 2], XMMijRegValues[count*4 + 2] , 0, TRUE));
		EXPECT_TRUE(regs.SetRegister(XMMijRegs[count*4 + 3], XMMijRegValues[count*4 + 3] , 0, TRUE));
	}

	//	do one stepover
	EXPECT_TRUE(regs.Disable());

	//xbox if (!bSystemIsWin9X)
	EXPECT_TRUE(dbg.StepOver());

	//	verify XMMij values

	//	test in reg window
	EXPECT_TRUE(regs.Enable());
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.RegisterValueIs(XMMijRegs[count*4], XMMijRegValues[count*4] , 0, TRUE));
		EXPECT_TRUE(regs.RegisterValueIs(XMMijRegs[count*4 + 1], XMMijRegValues[count*4 + 1] , 0, TRUE));
		EXPECT_TRUE(regs.RegisterValueIs(XMMijRegs[count*4 + 2], XMMijRegValues[count*4 + 2] , 0, TRUE));
		EXPECT_TRUE(regs.RegisterValueIs(XMMijRegs[count*4 + 3], XMMijRegValues[count*4 + 3] , 0, TRUE));
	}

	//	test in watch window
	EXPECT_TRUE(cxx.Enable(EE_ALL_INFO));
	for (count = 0; count< num_reg; count++)
	{
		char str[32];
		char strReg[8];
		float f = 0.0;
	
		strcpy(strReg,XMMijRegs[count*4]);		
		f = (float) atof(XMMijRegValues[count*4]);
		sprintf(str,"%6.4f",f);
		testRegVal(strReg, "float", str,"Test XMMij in Watch - Code");
		
		strcpy(strReg,XMMijRegs[count*4 + 1]);		
		f = (float) atof(XMMijRegValues[count*4 + 1]);
		sprintf(str,"%6.4f",f);
		testRegVal(strReg, "float", str,"Test XMMij in Watch - Code");

		strcpy(strReg,XMMijRegs[count*4+ 2]);		
		f = (float) atof(XMMijRegValues[count*4 + 2]);
		sprintf(str,"%6.4f",f);
		testRegVal(strReg, "float", str,"Test XMMij in Watch - Code");

		strcpy(strReg,XMMijRegs[count*4+ 3]);		
		f = (float) atof(XMMijRegValues[count*4 + 3]);
		sprintf(str,"%6.4f",f);
		testRegVal(strReg, "float", str,"Test XMMij in Watch - Code");
	}

	//	verify that XMMi changed correctly

	CString XMMNewRegVal[] = {	
							"41202D77412004814120006941200000",
							"41A02D7741A0048141A0006941A00000",
							"41F0443341F006C241F0009D41F00000",
							"42202D77422004814220006942200000",
							"424838D5424805A24248008342480000",
							"42704433427006C24270009D42700000",
							"428C27C8428C03F1428C005C428C0000",
							"42A02D7742A0048142A0006942A00000"
								};	

	EXPECT_TRUE(regs.Enable());
	
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.RegisterValueIs(XMMRegs[count], XMMNewRegVal[count], 0, TRUE));
	}

}

/*
void CRegistersPP::TestWNIreg(void)
{
	if (!CMDLINE->GetBooleanValue("wni",FALSE)) return;	//	exit if wni switch is not set	

	LOGTESTHEADER("TestWNIreg");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	MST.DoKeys("{ESC}");
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(src.Find("TestXMM();")); 
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepInto());	
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StepOver());


	CString XMMRegs[] = {"XMM0","XMM1","XMM2","XMM3","XMM4","XMM5","XMM6","XMM7"};
	CString XMMRegValues[] = {	"40000000000000003FF0000000000000",
								"40100000000000004008000000000000",
								"40180000000000004014000000000000",
								"4020000000000000401C000000000000",
								"40240000000000004022000000000000",
								"40280000000000004026000000000000",
								"402C000000000000402A000000000000",
								"4030000000000000402E000000000000"};

	CString XMM0DRegs[] = {	"XMM0DL","XMM0DH","XMM1DL","XMM1DH","XMM2DL","XMM2DH",
							"XMM3DL","XMM3DH","XMM4DL","XMM4DH","XMM5DL","XMM5DH",
							"XMM6DL","XMM6DH","XMM7DL","XMM7DH" };

	CString XMM0DRegValues[] = {	"+1.00000000000000E+000","+2.00000000000000E+000","+3.00000000000000E+000",
									"+4.00000000000000E+000","+5.00000000000000E+000","+6.00000000000000E+000",
									"+7.00000000000000E+000","+8.00000000000000E+000","+9.00000000000000E+000",
									"+1.00000000000000E+001","+1.10000000000000E+001","+1.20000000000000E+001",
									"+1.30000000000000E+001","+1.40000000000000E+001","+1.50000000000000E+001",
									"+1.60000000000000E+001"	};

	CString XMM0IRegs[] = {	"XMM0IL","XMM0IH","XMM1IL","XMM1IH","XMM2IL","XMM2IH",
							"XMM3IL","XMM3IH","XMM4IL","XMM4IH","XMM5IL","XMM5IH",
							"XMM6IL","XMM6IH","XMM7IL","XMM7IH" };

	CString XMM0IRegValues[] = {	"4607182418800017408","4611686018427387904","4613937818241073152",
									"4616189618054758400","4617315517961601024","4618441417868443648",
									"4619567317775286272","4620693217682128896","4621256167635550208",
									"4621819117588971520","4622382067542392832","4622945017495814144",
									"4623507967449235456","4624070917402656768","4624633867356078080",
									"4625196817309499392"	};


	int num_reg = 8;
	int count = 0;


	//	step through source code
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(dbg.StepOver());
	}

	//	do one stepover
	if (!bSystemIsWin9X)
	EXPECT_TRUE(dbg.StepOver());

	//	now verify XMMiD register values
	
	CString XMMiDStepOverValues[] = {	
										"+2.00000047311187E+000","+5.12000122547150E+002",
										"+8.19200197219849E+003","+1.31072031677246E+005",
										"+5.24288127075195E+005","+2.09715250927734E+006",
										"+8.38861004101563E+006","+3.35544401796875E+007",
										"+6.71088803828125E+007","+1.34217760796875E+008",
										"+2.68435521656250E+008","+5.36871043437500E+008",
										"+1.07374208712500E+009","+2.14748417475000E+009",
										"+4.29496835050000E+009","+8.58993670300000E+009"
									};

	//	test in reg window
	EXPECT_TRUE(regs.Enable());
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.RegisterValueIs(XMM0DRegs[count*2], XMMiDStepOverValues[count*2] , 0, TRUE));
		EXPECT_TRUE(regs.RegisterValueIs(XMM0DRegs[count*2 + 1], XMMiDStepOverValues[count*2 + 1] , 0, TRUE));
	}


	//	verify XMMiI register values
	CString XMMiIStepOverValues[] = {	
										"4611686019492741120","4647714816524288000",
										"4665729215040061440","4683743613553737728",
										"4692750812811624448","4701758012068462592",
										"4710765211325300736","4719772410582138880",
										"4724276010211082240","4728779609839501312",
										"4733283209467920384","4737786809096339456",
										"4742290408724758528","4746794008353177600",
										"4751297607981596672","4755801207610015744"
									};


	//	test in watch window
	EXPECT_TRUE(cxx.Enable(EE_ALL_INFO));
	for (count = 0; count< num_reg; count++)
	{
		char str[32];
		char strReg[8];
	
		strcpy(strReg,XMM0IRegs[count*2]);		
		strcpy(str,XMMiIStepOverValues[count*2]);
		testRegVal(strReg, "unsigned __int64", str,"Test XMMiI in Watch - Code");
		
		strcpy(strReg,XMM0IRegs[count*2 + 1]);		
		strcpy(str,XMMiIStepOverValues[count*2 + 1]);
		testRegVal(strReg, "unsigned __int64", str,"Test XMMiI in Watch - Code");
	}


	//
	//	verify that modifying XMMi changes XMM0D & XMM0I
	//
	EXPECT_TRUE(regs.Enable());
	
	//	modify register XMMi in reg window
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.SetRegister(XMMRegs[count], XMMRegValues[count] , 0, TRUE));
	}

	EXPECT_TRUE(cxx.Enable(EE_ALL_INFO));
	for (count = 0; count< num_reg; count++)
	{
		char str[32];
		char strReg[8];
		double dbl = 0.0;
		char **strptr = NULL;
	
		//	verify XMM0D

		strcpy(strReg,XMM0DRegs[count*2]);		
		strcpy(str,XMM0DRegValues[count*2]);		
		dbl = strtod(str,strptr);
		if (dbl < 10)
			sprintf(str,"%.13f",dbl);
		else
			sprintf(str,"%.12f",dbl);
		testRegVal(strReg, "double", str,"Test XMMD in Watch - Code");
		
		strcpy(strReg,XMM0DRegs[count*2 + 1]);		
		strcpy(str,XMM0DRegValues[count*2 + 1]);		
		dbl = strtod(str,strptr);
		if (dbl < 10)
			sprintf(str,"%.13f",dbl);
		else
			sprintf(str,"%.12f",dbl);
		testRegVal(strReg, "double", str,"Test XMMD in Watch - Code");

		//	verify XMM0I

		strcpy(strReg,XMM0IRegs[count*2]);		
		strcpy(str,XMM0IRegValues[count*2]);		
		testRegVal(strReg, "unsigned __int64", str,"Test XMMI in Watch - Code");

		strcpy(strReg,XMM0IRegs[count*2 + 1]);		
		strcpy(str,XMM0IRegValues[count*2 + 1]);		
		testRegVal(strReg, "unsigned __int64", str,"Test XMMI in Watch - Code");
	}
	
	//	verify that modifying XMM0D changes XMMi

	//	XMMD values to test XMM with
	CString XMM0D_TestValues[] = {	"+5.00000000000000E+001","+5.10000000000000E+001","+5.20000000000000E+001",
									"+5.30000000000000E+001","+5.40000000000000E+001","+5.50000000000000E+001",
									"+5.60000000000000E+001","+5.70000000000000E+001","+5.80000000000000E+001",
									"+5.90000000000000E+001","+6.00000000000000E+001","+6.10000000000000E+001",
									"+6.20000000000000E+001","+6.30000000000000E+001","+6.40000000000000E+001",
									"+6.50000000000000E+001"	};

	//	corresponding XMM values
	CString XMM_D_TestValues[] = {	"40498000000000004049000000000000",
									"404A800000000000404A000000000000",
									"404B800000000000404B000000000000",
									"404C800000000000404C000000000000",
									"404D800000000000404D000000000000",
									"404E800000000000404E000000000000",
									"404F800000000000404F000000000000",
									"40504000000000004050000000000000"};
	
	EXPECT_TRUE(regs.Enable());
	
	//	modify register XMM0D in reg window
	for (count = 0; count< num_reg*2; count++)
	{
		EXPECT_TRUE(regs.SetRegister(XMM0DRegs[count], XMM0D_TestValues[count] , 0, TRUE));
	}

	//	now verify XMMi register values
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.RegisterValueIs(XMMRegs[count], XMM_D_TestValues[count] , 0, TRUE));
	}	
	
	//	verify that modifying XMM0I changes XMMi



	EXPECT_TRUE(regs.Enable());
	
	//	modify register XMM0I in watch window
	EXPECT_TRUE(dbg.ToggleHexDisplay(FALSE));

	for (count = 0; count <num_reg*2; count++)
	{
		EXPECT_TRUE(cxx.SetExpressionValue(XMM0IRegs[count],(count+1)*101));
	}

	//	cooresponding XMMi reg values
	CString XMM_I_TestValues[] = {	"00000000000000CA0000000000000065",
									"0000000000000194000000000000012F",
									"000000000000025E00000000000001F9",
									"000000000000032800000000000002C3",
									"00000000000003F2000000000000038D",
									"00000000000004BC0000000000000457",
									"00000000000005860000000000000521",
									"000000000000065000000000000005EB"};


	//	now verify XMMi register values
	for (count = 0; count< num_reg; count++)
	{
		EXPECT_TRUE(regs.RegisterValueIs(XMMRegs[count], XMM_I_TestValues[count] , 0 , TRUE));
	}	
		
	//	verify that XMM0D modifies correctly in reg & watch window
	//	modify in watch
	cxx.Enable(EE_ALL_INFO);

	//	set value in watch window
	EXPECT_TRUE(dbg.ToggleHexDisplay(FALSE));
	for (count = 0; count <num_reg*2; count++)
	{
		EXPECT_TRUE(cxx.SetExpressionValue(XMM0DRegs[count],count*11));
	}
	
	//	corresponding values in reg window

	CString XMM0DWatchValues[] = {	"+0.00000000000000E+000","+1.10000000000000E+001","+2.20000000000000E+001",
									"+3.30000000000000E+001","+4.40000000000000E+001","+5.50000000000000E+001",
									"+6.60000000000000E+001","+7.70000000000000E+001","+8.80000000000000E+001",
									"+9.90000000000000E+001","+1.10000000000000E+002","+1.21000000000000E+002",
									"+1.32000000000000E+002","+1.43000000000000E+002","+1.54000000000000E+002",
									"+1.65000000000000E+002"	};

	//	verify in reg
	EXPECT_TRUE(regs.Enable());
	
	for (count = 0; count< num_reg*2; count++)
	{
		EXPECT_TRUE(regs.RegisterValueIs(XMM0DRegs[count], XMM0DWatchValues[count] , 0 , TRUE));
	}
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\retval\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\registers\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	registers.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\retval\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\retval\retvsub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CRetValSubSuite class
//

#include "stdafx.h"
#include "RetVsub.h"
#include "afxdllx.h"
#include "..\..\dbgtestbase.h"

#include "RetVcase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CRetValSubSuite

IMPLEMENT_SUBSUITE(CRetValSubSuite, CIDESubSuite, "Return Value", "VCQA Debugger")

BEGIN_TESTLIST(CRetValSubSuite)
	TEST(CRetValIDETest, RUN)
END_TESTLIST()

void CRetValSubSuite::CleanUp(void)
	{
	::CleanUp("retval");
	}

///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\retval\retvsub.h ===
///////////////////////////////////////////////////////////////////////////////
//	RetVsub.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CRetValSubSuite class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CRetValSubSuite class

class CRetValSubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CRetValSubSuite)
	DECLARE_TESTLIST()
protected:
	void CleanUp(void);
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\retval\retvcase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	RetVcase.CPP
//											 
//	Created by :			
//		VCBU QA		
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "RetVcase.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
IMPLEMENT_TEST(CRetValIDETest, CDbgTestBase, "Return Value", -1, CRetValSubSuite)
									   
												 
void CRetValIDETest::PreRun(void)
	{
	// call the base class
	CTest::PreRun();
	}


void CRetValIDETest::Run(void)
	
	{
	/******************
	 * INITIALIZATION *
	 ******************/
	if(!SetProject("retval\\retval", PROJECT_XBE))
		{
		m_pLog->RecordInfo("ERROR: could not init retval project");
		return;
		}

	// this is the initial state each test expects.
	//	  - step passed prolog of WinMain().
	//	  - select Auto pane in variables wnd.
	//    - restore focus to source wnd.

	if(!dbg.StepOver(2))
		{
		m_pLog->RecordInfo("ERROR: could not step passed WinMain()'s prolog");
		return;
		}

	uivar.Activate();

	if(!uivar.SetPane(PANE_AUTO) == ERROR_SUCCESS)
		{
		m_pLog->RecordInfo("ERROR: could not activate Auto pane");
		return;
		}

	RestoreFocusToSrcWnd();
		
	/*********
	 * TESTS *
	 *********/
	// can't step into system code on win95.
	//if(GetSystem() != SYSTEM_CHICAGO)
		// TODO (michma): need to get passed compiler problem with EnumWindowsProc
		// before we can finish implementing this test.
		//StepOutOfCallbackFunction();
	
	StepOverFunctionsReturningNativeTypes();
	StepOverFunctionReturningClassObject();
	StepOverFunctionReturningPointerToClassObject();
// Orion 12285 is postponed:	StepOverFunctionThrowingExceptionToParent();
	//xbox StepOutOfWinMain();
	//xbox StepOverDllFunction();
	StepOverConstructorAndVirtualMemberFunction();
	StepOverFunctionWithOnlyLineNumberDebugInfo();
	StepOverFunctionWithNoDebugInfo();
	// TODO (michma): need to change retval.mak so we actually statically link to retail crt.
	// test will fail until then.
	//StepOverStaticallyLinkedNonDebugCrtFunction();
	
	StepOverWin32ApiFunction();
	StepOutOfFunctionWithF8();
	StepOutOfFunctionWithF10();
	StepOutOfFunctionWithShiftF7();
	StepOverLineWithNoFunctionCall();
	VerifyNoReturnValueDisplayedAfterGo();
	VerifyReturnValueDisappearsWhenAssigningValue();
	VerifyReturnValueDisappearsWhenNotAssigningValue();
	VerifyReturnValueStaysAfterResettingNextStatement();
	VerifyReturnValueStaysAfterStackNavigation();
	VerifyReturnValueForFastcallCallingConvention();
	StepOutOfMultipleLevelsOfRecursion();
	VerifyReturnValueFieldCannotBeEdited();
	ToggleReturnValueOffAndOn();
	VerifyNoReturnValueDisplayedAfterRestart(); 
// TODO(michma): re-enable when orion: 9820.
	//VerifyNoReturnValueDisplayedAfterStopAndRestart(); 
	} 
	     

/*****************************************************************************
 * step over function returning each native type (void, char, unsigned char, *
 * int, unsigned int, long, unsigned long, float, double, long double).      *
 *****************************************************************************/
/***************************************************************
 * verify return value for cdecl (default) calling convention. *
 ***************************************************************/
void CRetValIDETest::StepOverFunctionsReturningNativeTypes(void)

	{
	// void
	LogTestHeader("StepOverFunctionsReturningNativeTypes - void");
	EXPECT_TRUE(src.Find("func_void();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
#ifndef _M_ALPHA
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "void", "func_void returned", "<void>");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
#else
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "char", "ch", "0 '\\x00'");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "void", "func_void returned", "<void>");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));
#endif
	RestoreFocusToSrcWnd();

	// char
	LogTestHeader("StepOverFunctionsReturningNativeTypes - char");
	EXPECT_TRUE(src.Find("char ch = func_char();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "char", "ch", "127 '\x7f'");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "unsigned char", "uch", "UNKNOWN");
	FillExprInfo(expr_info_expected[2], NOT_EXPANDABLE, "char", "func_char returned", "127 '\x7f'");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 3));
	RestoreFocusToSrcWnd();

	// unsigned char
	LogTestHeader("StepOverFunctionsReturningNativeTypes - unsigned char");
	EXPECT_TRUE(src.Find("func_uchar();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "i", "UNKNOWN");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "unsigned char", "uch", "255 '\xff'");
	FillExprInfo(expr_info_expected[2], NOT_EXPANDABLE, "unsigned char", "func_uchar returned", "255 '\xff'");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 3));
	RestoreFocusToSrcWnd();

	// int
	LogTestHeader("StepOverFunctionsReturningNativeTypes - int");
	EXPECT_TRUE(src.Find("func_int();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "i", "2147483647");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "unsigned int", "ui", "UNKNOWN");
	FillExprInfo(expr_info_expected[2], NOT_EXPANDABLE, "int", "func_int returned", "2147483647");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 3));
	RestoreFocusToSrcWnd();

	// unsigned int
	LogTestHeader("StepOverFunctionsReturningNativeTypes - unsigned int");
	EXPECT_TRUE(src.Find("func_uint();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "long", "l", "UNKNOWN");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "unsigned int", "ui", "4294967295");
	FillExprInfo(expr_info_expected[2], NOT_EXPANDABLE, "unsigned int", "func_uint returned", "4294967295");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 3));
	RestoreFocusToSrcWnd();

	// long
	LogTestHeader("StepOverFunctionsReturningNativeTypes - long");
	EXPECT_TRUE(src.Find("func_long();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "long", "l", "2147483647");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "unsigned long", "ul", "UNKNOWN");
	FillExprInfo(expr_info_expected[2], NOT_EXPANDABLE, "long", "func_long returned", "2147483647");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 3));
	RestoreFocusToSrcWnd();

	// unsigned long
	LogTestHeader("StepOverFunctionsReturningNativeTypes - unsigned long");
	EXPECT_TRUE(src.Find("func_ulong();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "float", "flt", "UNKNOWN");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "unsigned long", "ul", "4294967295");
	FillExprInfo(expr_info_expected[2], NOT_EXPANDABLE, "unsigned long", "func_ulong returned", "4294967295");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 3));
	RestoreFocusToSrcWnd();

	// float
	LogTestHeader("StepOverFunctionsReturningNativeTypes - float");
	EXPECT_TRUE(src.Find("func_float();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "double", "dbl", "UNKNOWN");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "float", "flt", "3.40282e+038");
	FillExprInfo(expr_info_expected[2], NOT_EXPANDABLE, "float", "func_float returned", "3.40282e+038");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 3));
	RestoreFocusToSrcWnd();

	// double
	LogTestHeader("StepOverFunctionsReturningNativeTypes - double");
	EXPECT_TRUE(src.Find("func_double();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "double", "dbl", "1.7976931348623e+308");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "double", "ldbl", "UNKNOWN");
	FillExprInfo(expr_info_expected[2], NOT_EXPANDABLE, "double", "func_double returned", "1.7976931348623e+308");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 3));
	RestoreFocusToSrcWnd();

	// long double
	LogTestHeader("StepOverFunctionsReturningNativeTypes - long double");
	EXPECT_TRUE(src.Find("func_ldouble();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], COLLAPSED, "base", "b", "{...}");

	// 68k uses long doubles, other platforms map them to doubles.
	CString ldbl_val_str = "1.7976931348623e+308";

	CString ldbl_typ_str = "double";

	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, ldbl_typ_str, "ldbl", ldbl_val_str);
	FillExprInfo(expr_info_expected[2], NOT_EXPANDABLE, ldbl_typ_str, "func_ldouble returned", ldbl_val_str);
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 3));
	RestoreFocusToSrcWnd();
	}


/**********************************************
 * step over function returning class object. *
 **********************************************/
void CRetValIDETest::StepOverFunctionReturningClassObject(void)
	{
	LogTestHeader("StepOverFunctionReturningClassObject");
	EXPECT_TRUE(src.Find("func_class();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], COLLAPSED, "base", "b", "{...}");
	FillExprInfo(expr_info_expected[1], COLLAPSED, "base *", "pb", "ADDRESS");
	FillExprInfo(expr_info_expected[2], NOT_EXPANDABLE, "base", "func_class returned", "{...}");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 3));
	RestoreFocusToSrcWnd();
	}


/*********************************************************
 * step over function returning pointer to class object. *
 *********************************************************/
void CRetValIDETest::StepOverFunctionReturningPointerToClassObject(void)
	{
	LogTestHeader("StepOverFunctionReturningPointerToClassObject");
	EXPECT_TRUE(src.Find("func_pclass();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], COLLAPSED, "base *", "pb", "ADDRESS");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "base *", "func_pclass returned", "ADDRESS");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));
	// verify that address values displayed for both items are the same.
	EXPECT_TRUE(expr_info_actual[0].value == expr_info_actual[1].value);
	RestoreFocusToSrcWnd();
	}


/************************************************************
 * step over function that does a throw and lands execution *
 * back in the parent function, and step out of the catch.  *
 ************************************************************/
void CRetValIDETest::StepOverFunctionThrowingExceptionToParent(void)

	{
	LogTestHeader("StepOverFunctionThrowingExceptionToParent");
	EXPECT_TRUE(src.Find("try"));
	EXPECT_TRUE(dbg.SetNextStatement());
	
	// step over function that does a throw.
	EXPECT_TRUE(dbg.StepOver(2));

	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "", "", "");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	
	// step out of the catch.
	EXPECT_TRUE(dbg.StepInto());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	
	RestoreFocusToSrcWnd();
	}


/************************
 * step out of WinMain. *
 ************************/
/****************************************************************
 * verify return value for stdcall (pascal) calling convention. *
 ****************************************************************/
void CRetValIDETest::StepOutOfWinMain(void)
	{
	LogTestHeader("StepOutOfWinMain");
	// start from WinMain()'s return statement.
	EXPECT_TRUE(src.Find("return 0;"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver(2));
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, ROW_LAST));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "WinMain returned", "0");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	// restore execution to initial state (anywhere after WinMain prolog).
	RestoreFocusToSrcWnd();
	dbg.Restart();
	dbg.SetSteppingMode(SRC);
	dbg.StepOver();
	}


/***************************
 * step over dll function. *
 ***************************/
void CRetValIDETest::StepOverDllFunction(void)
	{
	LogTestHeader("StepOverDllFunction");
	EXPECT_TRUE(src.Find("dll_func();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "dll_func returned", "1");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}


/********************************************************************************
 * step over implicit constructor call (new) and virtual class member function. *
 ********************************************************************************/
void CRetValIDETest::StepOverConstructorAndVirtualMemberFunction(void)

	{	
	LogTestHeader("StepOverConstructorAndVirtualMemberFunction");
	
	// step over the constructor.
	EXPECT_TRUE(src.Find("base *pd = new derived;"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	// TODO (michma): need to change retval.mak so we statically link to retail crt.
	// (new's return value willl not be displayed).	don't forget to change ExprInfoIs' third param to 4.
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], COLLAPSED, "base *", "pd", "ADDRESS");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "int", "pd->m_var", "UNKNOWN");
	FillExprInfo(expr_info_expected[2], NOT_EXPANDABLE, "void *", "operator new returned", "ADDRESS");
	// added for xbox - research this
	FillExprInfo(expr_info_expected[3], NOT_EXPANDABLE, "void", "derived::derived returned", "<void>");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 4));

	// step over the member function.
	EXPECT_TRUE(dbg.StepOver(2));
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], COLLAPSED, "base *", "pd", "ADDRESS");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "int", "derived::m_func returned", "1");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));

	RestoreFocusToSrcWnd();
	}


/********************************************************
 * step over function with only line number debug info. *
 ********************************************************/ 
void CRetValIDETest::StepOverFunctionWithOnlyLineNumberDebugInfo(void)
	{
	LogTestHeader("StepOverFunctionWithOnlyLineNumberDebugInfo");
	EXPECT_TRUE(src.Find("line_numbers_only();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "", "", "");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}


/******************************************
 * step over function with no debug info. *
 ******************************************/
void CRetValIDETest::StepOverFunctionWithNoDebugInfo(void)
	{
	LogTestHeader("StepOverFunctionWithNoDebugInfo");
	EXPECT_TRUE(src.Find("no_debug_info();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "", "", "");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}


/*********************************************************
 * step over statically linked, non-debug, crt function. *
 *********************************************************/
void CRetValIDETest::StepOverStaticallyLinkedNonDebugCrtFunction(void)
	{
	LogTestHeader("StepOverStaticallyLinkedNonDebugCrtFunction");
	EXPECT_TRUE(src.Find("abs(-1);"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
#ifndef _M_ALPHA
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "abs returned", "1");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
#else
	FillExprInfo(expr_info_expected[0], COLLAPSED, "base *", "pd", "ADDRESS");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "int", "abs returned", "1");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));
#endif
	RestoreFocusToSrcWnd();
	}


/*****************************************************************************
 * step over Win32 API function.
 *****************************************************************************/
void CRetValIDETest::StepOverWin32ApiFunction(void)
	{
	LogTestHeader("StepOverWin32ApiFunction");
	EXPECT_TRUE(src.Find("GetLastError();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	// modified for xbox
	// FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "", "", "");
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "unsigned long", "GetLastError returned", "0");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}


/*********************************
 * step out of function with F8. * 
 *********************************/
void CRetValIDETest::StepOutOfFunctionWithF8(void)
	
	{
	LogTestHeader("StepOutOfFunctionWithF8");
	EXPECT_TRUE(src.Find("func_void();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	if( WaitMsgBoxText("This operation will move the current location", 10) )
	{
		MST.WButtonClick( "OK" ); 
	}
	
	// TODO (michma): x86 acts like mips and alpha until orion: 4423 is fixed.
	//if (m_platform == PLATFORM_WIN32_ALPHA)
	//	{EXPECT_TRUE(dbg.StepInto(2));}
	//else
		{EXPECT_TRUE(dbg.StepInto(3));}
	
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "void", "func_void returned", "<void>");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));

	RestoreFocusToSrcWnd();
	}


/**********************************
 * step out of function with F10. *
 **********************************/
void CRetValIDETest::StepOutOfFunctionWithF10(void)
	
	{
	LogTestHeader("StepOutOfFunctionWithF10");
	EXPECT_TRUE(src.Find("func_void();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	if( WaitMsgBoxText("This operation will move the current location", 10) )
	{
		MST.WButtonClick( "OK" ); 
	}
	EXPECT_TRUE(dbg.StepInto());

	// TODO (michma): x86 acts like mips and alpha until orion: 4423 is fixed.
	//if (m_platform == PLATFORM_WIN32_ALPHA)
	//	{EXPECT_TRUE(dbg.StepOver());}
	//else
		{EXPECT_TRUE(dbg.StepOver(2));}

	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "void", "func_void returned", "<void>");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));

	RestoreFocusToSrcWnd();
	}


/***************************************
 * step out of function with shift+F7. *
 ***************************************/
void CRetValIDETest::StepOutOfFunctionWithShiftF7(void)
	{
	LogTestHeader("StepOutOfFunctionWithShiftF7");
	EXPECT_TRUE(src.Find("func_void();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE(dbg.StepOut());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
#ifndef _M_ALPHA
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "void", "func_void returned", "<void>");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
#else
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "char", "ch", "0 '\\x00'");
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "void", "func_void returned", "<void>");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));
#endif
	RestoreFocusToSrcWnd();
	}


/*****************************************
 * step over line with no function call. *
 *****************************************/
void CRetValIDETest::StepOverLineWithNoFunctionCall(void)
	{
	LogTestHeader("StepOverLineWithNoFunctionCall");
	EXPECT_TRUE(src.Find("for(0;0;0);"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
#ifndef _M_ALPHA
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "", "", "");
#else
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "char", "ch", "127 '\x7f'");
#endif
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}


/********************************************************************
 * go and verify that previous function return value not displayed. *
 ********************************************************************/
void CRetValIDETest::VerifyNoReturnValueDisplayedAfterGo(void)
	{
	LogTestHeader("VerifyNoReturnValueDisplayedAfterGo");
	EXPECT_TRUE(src.Find("func_void();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(src.Find("for(0;0;0);"));
	EXPECT_TRUE(dbg.StepToCursor());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
#ifndef _M_ALPHA
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "", "", "");
#else
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "char", "ch", "127 '\x7f'");
#endif
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}


/***********************************************************************************************
 * verify that function return item disappears when stepping to next line and assigning value. *
 ***********************************************************************************************/
void CRetValIDETest::VerifyReturnValueDisappearsWhenAssigningValue(void)

	{
	LogTestHeader("VerifyReturnValueDisappearsWhenAssigningValue");
	EXPECT_TRUE(src.Find("char ch = func_char();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE(dbg.StepOut());
	
	// just stepped out of function so value hasn't been asigned yet but
	// return value should be displayed.
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "char", "ch", "UNKNOWN");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "char", "func_char returned", "127 '\x7f'");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));
	
	// return value should disappear now.
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "char", "ch", "127 '\x7f'");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "unsigned char", "uch", "UNKNOWN");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));

	RestoreFocusToSrcWnd();
	}


/**************************************************************
 * verify that function return item disappears when stepping  *
 * to line after next and not assigning value.                *
 **************************************************************/
void CRetValIDETest::VerifyReturnValueDisappearsWhenNotAssigningValue(void)

	{
	LogTestHeader("VerifyReturnValueDisappearsWhenNotAssigningValue");
	EXPECT_TRUE(src.Find("func_void();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE(dbg.StepOut());
	
	// after stepping out of function, execution resumes at next line since no value to assign.
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
#ifndef _M_ALPHA
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "void", "func_void returned", "<void>");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
#else
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "char", "ch", "127 '\x7f'");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "void", "func_void returned", "<void>");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));
#endif
	
	// return value should disappear now.
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
#ifndef _M_ALPHA
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "", "", "");
#else
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "char", "ch", "127 '\x7f'");
#endif
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));

	RestoreFocusToSrcWnd();
	}


/************************************************************************
 * verify that function return item stays after setting next statement. *
 ************************************************************************/
void CRetValIDETest::VerifyReturnValueStaysAfterResettingNextStatement(void)
	{
	LogTestHeader("VerifyReturnValueStaysAfterResettingNextStatement");
	EXPECT_TRUE(src.Find("func_void();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(src.Find("while(0);"));
	EXPECT_TRUE(dbg.SetNextStatement());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
#ifndef _M_ALPHA
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "void", "func_void returned", "<void>");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
#else
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "char", "ch", "127 '\x7f'");
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "void", "func_void returned", "<void>");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));
#endif
	RestoreFocusToSrcWnd();
	}


/**********************************************************************
 * verify that function return item stays after callstack navigation. *
 **********************************************************************/
void CRetValIDETest::VerifyReturnValueStaysAfterStackNavigation(void)
	{
	LogTestHeader("VerifyReturnValueStaysAfterStackNavigation");
	EXPECT_TRUE(src.Find("func_void();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	// EXPECT_TRUE(stk.NavigateStack(1)!=0); //may hit the Kernel module, in which case -1
	// xbox change:
	// in Win32, this causes a navigate to RETVAL! WinMainCRTStartup but in Xbox,
	// this pops up a dialog requesting the xapi source code, and somehow NavigateStack()
	// thinks it failed and returns 0; so we add a 3.5 sec wait
	stk.NavigateStack(1);
	Sleep(3500);
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, ROW_LAST));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "void", "func_void returned", "<void>");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	// restore stack to initial state. 
	EXPECT_TRUE(stk.NavigateStack(0)>0);
	RestoreFocusToSrcWnd();
	}


/*****************************************************************
 * step over function that uses the fastcall calling convention. * 
 *****************************************************************/
void CRetValIDETest::VerifyReturnValueForFastcallCallingConvention(void)
	{
	LogTestHeader("VerifyReturnValueForFastcallCallingConvention");
	EXPECT_TRUE(src.Find("fastcall_func();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "fastcall_func returned", "1");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}


/******************************************************
 * step out of multiple levels of recursive function. *
 ******************************************************/
void CRetValIDETest::StepOutOfMultipleLevelsOfRecursion(void)
	
	{
	LogTestHeader("StepOutOfMultipleLevelsOfRecursion");
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("return i; // most nested return"));
	EXPECT_TRUE(dbg.StepToCursor());
	char ret_val_str[2];

	// step out of each call (4 times).
	// YS:actually it Steps out 5 times and now it shows 2 lines for the first 4 StepOuts
	for(int ret_val_dec = 5; ret_val_dec > 0; ret_val_dec--)
	{
		EXPECT_TRUE(dbg.StepOut());
		uivar.Activate();
	 	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
		if (ret_val_dec > 1)
		{
			FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "i", itoa(ret_val_dec - 1, ret_val_str, 10));
			FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "int", "recursive_func returned", itoa(ret_val_dec, ret_val_str, 10));
		}
		else
			FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "recursive_func returned", itoa(ret_val_dec, ret_val_str, 10));
		EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	}

	RestoreFocusToSrcWnd();
	}


/**********************************
 * step out of callback function. *
 **********************************/
void CRetValIDETest::StepOutOfCallbackFunction(void)
	{
	// TODO (michma): need to get passed compiler problem with EnumWindowsProc
	// before we can finish implementing this test.
	LogTestHeader("StepOutOfCallbackFunction");
	}


/*********************************************
 * verify that Value field cannot be edited. *
 *********************************************/
void CRetValIDETest::VerifyReturnValueFieldCannotBeEdited(void)
	{
	LogTestHeader("VerifyReturnValueFieldCannotBeEdited");
	EXPECT_TRUE(src.Find("func_void();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	// attempt to set the value in the first row (containing return value) to 0.
	EXPECT_TRUE(uivar.SetValue(0, 1) == ERROR_ERROR);
	RestoreFocusToSrcWnd();
	}


/**************************************************************************************
 * restart debugging and verify that previous function return value removed at break. *
 **************************************************************************************/
void CRetValIDETest::VerifyNoReturnValueDisplayedAfterRestart(void)
	{
	LogTestHeader("VerifyNoReturnValueDisplayedAfterRestart");
	EXPECT_TRUE(src.Find("func_void();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.Restart());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, ROW_LAST));
	// nCmdShow doesn't exit in xbox, changed WinMain(...) to void __cdecl main()
	// FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "nCmdShow", "1");
	// EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "", "", "");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	// restore execution to inital state (anywhere after WinMain() prolog).
	EXPECT_TRUE(dbg.StepOver());
	RestoreFocusToSrcWnd();
	}


/*******************************************************
 * stop and restart debugging and verify that previous *
 * function return value removed at break.             *
 *******************************************************/
void CRetValIDETest::VerifyNoReturnValueDisplayedAfterStopAndRestart(void) 
	{
	LogTestHeader("VerifyNoReturnValueDisplayedAfterStopAndRestart");
	EXPECT_TRUE(src.Find("func_void();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_TRUE(dbg.Restart());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, ROW_LAST));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "nCmdShow", "1");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	// restore execution to inital state (anywhere after WinMain() prolog).
	EXPECT_TRUE(dbg.StepOver());
	RestoreFocusToSrcWnd();
	}


/************************************************************
 * toggle return value off and an via Tools.Options.Debug. *
 ************************************************************/
void CRetValIDETest::ToggleReturnValueOffAndOn(void)
	
	{
	LogTestHeader("ToggleReturnValueOffAndOn");

	dbg.ToggleReturnValue(TOGGLE_OFF);
	EXPECT_TRUE(src.Find("func_void();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "", "", "");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();

	dbg.ToggleReturnValue(TOGGLE_ON);
	EXPECT_TRUE(src.Find("func_void();"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "void", "func_void returned", "<void>");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\stack\cs_base.h ===
///////////////////////////////////////////////////////////////////////////////
//	cs_base.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the Cstack_baseIDETest Class
//

#ifndef __cs_base_H__
#define __cs_base_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\dbgtestbase.h"

///////////////////////////////////////////////////////////////////////////////
//	CstackIDETest class

class Cstack_baseIDETest :public CDbgTestBase
{
	DECLARE_TEST(Cstack_baseIDETest, CstackSubSuite)

public:  // Operations
	virtual void PreRun(void);
	virtual void Run();

	// Test Cases
protected:
	void RebuildProject(LPCSTR projName,LPCSTR pConfig);
	BOOL GeneralNavigation();
	BOOL ChainDisplay();
	BOOL SteppingAndCallStackUpdating();
	BOOL CheckLocals();
	BOOL NavigationAndModifiedLocalGlobal();
};

#endif //__cs_base_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\stack\cspecial.h ===
///////////////////////////////////////////////////////////////////////////////
//	cspecial.H
//
//	Created by :			Date :
//		YefimS					01/06/94
//
//	Description :
//		Declaration of the Cstack2IDETest class
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __CSPECIAL_H__
#define __CSPECIAL_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif


#include "..\..\dbgtestbase.h"

///////////////////////////////////////////////////////////////////////////////
//	Cstack2IDETest class

class Cstack_specialIDETest : public CDbgTestBase
{
	DECLARE_TEST(Cstack_specialIDETest, CstackSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run();

// Test Cases
protected:
	BOOL MainSequence(   );
	BOOL CheckParamList(   );
	BOOL VarParam(   );
	BOOL Recursion(   );
	BOOL Options(   );
	BOOL AdvancedParam(   );

// Utilities
protected:
	BOOL ShortRecCycle(int nParam);
	BOOL EndOfStackIsCorrect(int level);
	BOOL StackIsCorrect(int nParam, LPCSTR strLine);
};

#endif //__CSPECIAL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\stack\cs_base.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	cs_base.CPP
//											 
//	Created by :			
//		VCBU QA		
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "stacsub.h"
#include "cs_base.h"	 

#if defined(_ALPHA_)
#define _CHAIN_2 "chain_2"
#define _CHAIN_3 "chain_3"
#else
#define _CHAIN_2 "_chain_2"
#define _CHAIN_3 "_chain_3"
#endif

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
IMPLEMENT_TEST(Cstack_baseIDETest, CDbgTestBase, "CallStack Base", -1, CstackSubSuite)

void Cstack_baseIDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

void Cstack_baseIDETest::Run()
{
	XSAFETY;

//	EXPECT_EXEC( dbg.SetOwnedStack( &stk ), "Could not setup owned stack" );
//	XSAFETY;

	/*
	** For the dbg application:
	** ChainMain is expected to be compiled with full debug information
	** chain_1 is expected to be compiled with full debug information
	** chain_2 is expected to be compiled with partial debug information
	** chain_3 is expected to be compiled without debug information
	** chain_4 is expected to be compiled with full debug information
	** chain_5 is expected to be compiled with full debug information
	*/

	/*xbox TODO
	EXPECT_EXEC( SetProject( "dbg\\dbg" ), "Project could not be setup" );
	XSAFETY;
	GeneralNavigation();
	XSAFETY;
	SteppingAndCallStackUpdating();
	XSAFETY;
	ChainDisplay();
	XSAFETY;
	*/

	if( SetProject("stack01\\stack01", PROJECT_XBE) )
	{	  
		XSAFETY;
		CheckLocals();
		XSAFETY;
	}

	if( SetProject("testgo01\\testgo01", PROJECT_XBE) )
	{	  
		XSAFETY;
		NavigationAndModifiedLocalGlobal();
		XSAFETY;
	}

}

BOOL Cstack_baseIDETest::GeneralNavigation()
{
	CString fnName;	
	CString szTitle;
	UIEditor editor;
 	LogTestHeader( "GeneralNavigation Test" );
 	LogTestHeader( "Initial callstack after first stepin" );
	EXPECT_SUBTEST( dbg.StepInto( 1, "main" ) );
	EXPECT_SUBTEST( Frame( stk.GetFunction( 0 ) ).GetFunctionName( fnName ) );
	EXPECT_SUBTEST( fnName == "main" );

 	LogTestHeader( "General navigation with full debug info" );
	EXPECT_SUBTEST( NULL != bps.SetBreakpoint("chain_5") );
	EXPECT_SUBTEST( dbg.Go() );
	EXPECT_SUBTEST( dbg.AtSymbol("chain_5"));
//	UIWB.DoCommand(ID_WINDOW_CLOSE_ALL, DC_MNEMONIC);	

 	LogTestHeader( "Navigate to 'chain_5' : full debug info : current function" );
	EXPECT_TRUE( stk.NavigateStack( "chain_5" )>0 );
	MST.WFndWndWait("chain1.c", FW_FOCUS | FW_PART, 2);
	EXPECT_TRUE( src.AttachActiveEditor() );
	EXPECT_TRUE( editor.AttachActive() );
	szTitle = editor.GetTitle();
	szTitle.MakeLower();
	EXPECT_TRUE( szTitle == "chain1.c" );
	if( GetUserTargetPlatforms() == PLATFORM_WIN32_ALPHA ) {
		EXPECT_TRUE( src.GetCurrentLine() == 34 );
	}
	else {
		EXPECT_TRUE( src.GetCurrentLine() == 32 );
	}
	// bad programing practice - string constants?? WinslowF
	MST.WFndWndWait("chain1.c", FW_FOCUS | FW_PART, 2);
	EXPECT_TRUE( ERROR_SUCCESS == src.Close(FALSE) );

 	LogTestHeader( "Navigate to 'chain_4' : full debug info" );
	EXPECT_TRUE( stk.NavigateStack( "chain_4" )>0 );
	MST.WFndWndWait("chain4.c", FW_FOCUS | FW_PART, 2);
	EXPECT_TRUE( src.AttachActiveEditor() );
	EXPECT_TRUE( editor.AttachActive() );
	szTitle = editor.GetTitle();
	szTitle.MakeLower();
	EXPECT_TRUE( szTitle == "chain4.c" );
	EXPECT_TRUE( src.GetCurrentLine() == 99 );
	EXPECT_TRUE( editor.Close() );
	VerifyLocalsWndString("int", "x", "3");
	VerifyLocalsWndString("int", "Sum_4", "4", 2);

 	LogTestHeader( "Navigate to 'chain_2' : partial debug info" );
	EXPECT_TRUE( stk.NavigateStack( "DBG! chain_2" )>0 );
	MST.WFndWndWait("chain2.c", FW_FOCUS | FW_PART, 2);
	EXPECT_TRUE( src.AttachActiveEditor() );
	EXPECT_TRUE( editor.AttachActive() );
	szTitle = editor.GetTitle();
	szTitle.MakeLower();
	EXPECT_TRUE( szTitle == "chain2.c" );
	EXPECT_TRUE( src.GetCurrentLine() == 26 );
//	EXPECT_TRUE( editor.Close() ); --leave the "chain2.c" file opened

 	LogTestHeader( "Navigate to 'chain_1' : full debug info" );
	EXPECT_TRUE( stk.NavigateStack( "chain_1" )>0 );
	MST.WFndWndWait("chain1.c", FW_FOCUS | FW_PART, 2);
	EXPECT_TRUE( src.AttachActiveEditor() );
	EXPECT_TRUE( editor.AttachActive() );
	szTitle = editor.GetTitle();
	szTitle.MakeLower();
	EXPECT_TRUE( szTitle == "chain1.c" );
	EXPECT_TRUE( src.GetCurrentLine() == 24 );
	EXPECT_TRUE( editor.Close() );

 	LogTestHeader( "Navigate to 'ChainMain' : full debug info" );
	EXPECT_TRUE( stk.NavigateStack( "ChainMain" )>0 );
	MST.WFndWndWait("chain0.c", FW_FOCUS | FW_PART, 2);
	EXPECT_TRUE( src.AttachActiveEditor() );
	EXPECT_TRUE( editor.AttachActive() );
	szTitle = editor.GetTitle();
	szTitle.MakeLower();
	EXPECT_TRUE( szTitle == "chain0.c" );
	EXPECT_TRUE( src.GetCurrentLine() == 28 );
	EXPECT_TRUE( editor.Close() );

 	LogTestHeader( "Navigate to 'WndProc' : full debug info" );
	EXPECT_TRUE( stk.NavigateStack( "WndProc" )>0 );
	MST.WFndWndWait("main.c", FW_FOCUS | FW_PART, 2);
	EXPECT_TRUE( src.AttachActiveEditor() );
	EXPECT_TRUE( editor.AttachActive() );
	szTitle = editor.GetTitle();
	szTitle.MakeLower();
	EXPECT_TRUE( szTitle == "main.c" );
	EXPECT_TRUE( src.GetCurrentLine() == 117 );
	EXPECT_TRUE( editor.Close() );

 	LogTestHeader( "Navigate to 'chain_3' (DAM: no debug info)" );
	EXPECT_TRUE( stk.NavigateStack( "chain_3" )==-1 );
	EXPECT_TRUE( src.AttachActiveEditor() );
	EXPECT_TRUE( editor.AttachActive() );
	EXPECT_TRUE( editor.GetTitle() == "Disassembly" );
	// bad programing practice - string constants?? WinslowF
	MST.WFndWndWait("Disassembly", FW_FOCUS | FW_PART, 2);
	EXPECT_TRUE( ERROR_SUCCESS == src.Close(FALSE) );

 	LogTestHeader( "Once more to 'chain_5'" );
	EXPECT_TRUE( stk.NavigateStack( "chain_5" )>0 );
	MST.WFndWndWait("chain1.c", FW_FOCUS | FW_PART, 2);
	EXPECT_TRUE( src.AttachActiveEditor() );
	EXPECT_TRUE( editor.AttachActive() );
	szTitle = editor.GetTitle();
	szTitle.MakeLower();
	EXPECT_TRUE( szTitle == "chain1.c" );
	if( GetUserTargetPlatforms() == PLATFORM_WIN32_ALPHA) 
	{
		EXPECT_TRUE( src.GetCurrentLine() == 34 );
	}
	else
	{
		EXPECT_TRUE( src.GetCurrentLine() == 32 );
	}

	LogTestHeader( "Once more to 'chain_2' : source wnd opened" );
	EXPECT_TRUE( stk.NavigateStack( "DBG! chain_2" )>0 );
	MST.WFndWndWait("chain2.c", FW_FOCUS | FW_PART, 2);
	EXPECT_TRUE( src.AttachActiveEditor() );
	EXPECT_TRUE( editor.AttachActive() );
	szTitle = editor.GetTitle();
	szTitle.MakeLower();
	EXPECT_TRUE( szTitle == "chain2.c" );
	EXPECT_TRUE( src.GetCurrentLine() == 26 );
//	EXPECT_TRUE( editor.Close() );

	LogTestHeader( "Navigation within the C++ member functions" );
	UIWB.DoCommand(ID_WINDOW_CLOSE_ALL, DC_MNEMONIC);	
	EXPECT_SUBTEST( NULL != bps.SetBreakpoint("fooclass::chain2_func") );
	EXPECT_SUBTEST( dbg.Go() );
	EXPECT_SUBTEST( dbg.AtSymbol("fooclass::chain2_func"));

 	LogTestHeader( "Navigate to 'fooclass::chain1_func', no src window" );
	EXPECT_TRUE( stk.NavigateStack( "fooclass::chain1_func" )>0 );
	MST.WFndWndWait("cxx.cxx", FW_FOCUS | FW_PART, 2);
	EXPECT_TRUE( src.AttachActiveEditor() );
	EXPECT_TRUE( editor.AttachActive() );
	szTitle = editor.GetTitle();
	EXPECT_TRUE( szTitle == "cxx.cxx" );
	EXPECT_TRUE( src.GetCurrentLine() == 52 );
//	EXPECT_TRUE( editor.Close() );
	VerifyLocalsWndString("unsigned char", "local_cpp_func", "65", 2);

 	LogTestHeader( "Navigate to 'fooclass::chain2_func', src wnd opened" );
	EXPECT_TRUE( stk.NavigateStack( "fooclass::chain2_func" )>0 );
	MST.WFndWndWait("cxx.h", FW_FOCUS | FW_PART, 2);
	EXPECT_TRUE( src.AttachActiveEditor() );
	EXPECT_TRUE( editor.AttachActive() );
	szTitle = editor.GetTitle();
	EXPECT_TRUE( szTitle == "cxx.h" );
	EXPECT_TRUE( src.GetCurrentLine() == 50 );
//	EXPECT_TRUE( editor.Close() );

	dbg.StopDebugging();
	return (TRUE);
}

BOOL Cstack_baseIDETest::ChainDisplay()
{
	CString fnName;
	UIEditor editor;
	int index;
	const char* frame1;
	const char* frame6;

 	LogTestHeader( "Verify Call Stack chain display" );

	bps.ClearAllBreakpoints();

	// Get into nested function to prepare for the test
	EXPECT_TRUE( bps.SetBreakpoint("chain_5") );
	EXPECT_TRUE( dbg.Go(NULL, NULL, "chain_5") );
//	EXPECT_TRUE( dbg.Go() );
//	EXPECT_TRUE( dbg.AtSymbol("chain_5"));

 	LogTestHeader( "Navigate to 'WndProc'" );
	EXPECT_TRUE( stk.NavigateStack( "WndProc" )>0 );
	MST.WFndWndWait("main.c", FW_FOCUS | FW_PART, 2);
	EXPECT_TRUE( src.AttachActiveEditor() );
	EXPECT_TRUE( editor.AttachActive() );
	CString szTitle = editor.GetTitle();
	szTitle.MakeLower();
	EXPECT_TRUE( szTitle == "main.c" );
	EXPECT_TRUE( src.GetCurrentLine() == 117 );

	if( GetUserTargetPlatforms() == PLATFORM_WIN32_ALPHA )
	{
		frame1 = "chain_5( int 3 ) line 34";
	}
	else 
	{
		frame1 = "chain_5( int 3 ) line 32";
	}

	frame6 = "WndProc( HWND__ * %, unsigned int %, unsigned int %, long %) line 117";

	char const * const stk0[] =
	{
		{ frame1 },
		{ "chain_4( int 3 ) line 99" },
		{ "DBG! chain_3" },
		{ "DBG! chain_2 line 26" },
		{ "chain_1( int % ) line 24" },
		{ "ChainMain() line 28" },
		{ frame6 },
//		{ "WndProc( HWND__ * %, unsigned int %, unsigned int %, long %) line 117" },
		NULL
	};

	// Verify information on stack above callback
	EXPECT_SUBTEST( (index = stk.Index( "WndProc" ) ) != -1 );
	EXPECT_SUBTEST( stk.Compare( stk0, FrameList::NoFilter, 0, index ) );

	dbg.StopDebugging();

	RebuildProject("dbg\\dbg","1"); //configuration 1
	EXPECT_TRUE( dbg.Go(NULL, NULL, "chain_5") );
//	EXPECT_TRUE( dbg.Go() );
//	EXPECT_TRUE( dbg.AtSymbol("chain_5"));
	char const * const stk1[] =
	{
		{ frame1 },
		{ "chain_4( int 3 ) line 99" },
		{ "chain_3( int 3 ) line 27" },
		{ "DBG! chain_2 line 26" },
		{ "chain_1( int % ) line 24" },
		{ "ChainMain() line 28" },
		{ frame6 },
//		{ "WndProc( HWND__ * %, unsigned int %, unsigned int %, long %) line 117" },
		NULL
	};
	// Verify information on stack above callback
	EXPECT_SUBTEST( (index = stk.Index( "WndProc" ) ) != -1 );
	EXPECT_SUBTEST( stk.Compare( stk1, FrameList::NoFilter, 0, index ) );

	dbg.StopDebugging();

	XSAFETY;

	RebuildProject("dbg\\dbg","2"); //configuration 2
	EXPECT_TRUE( dbg.Go(NULL, NULL, "chain_5") );
//	EXPECT_TRUE( dbg.Go() );
//	EXPECT_TRUE( dbg.AtSymbol("chain_5"));
	char const * const stk2[] =
	{
		{ frame1 },
		{ "chain_4( int 3 ) line 99" },
		{ "DBG! chain_3" },
		{ "chain_2( int 3 ) line 26" },
		{ "chain_1( int % ) line 24" },
		{ "ChainMain() line 28" },
		{ frame6 },
//		{ "WndProc( HWND__ * %, unsigned int %, unsigned int %, long %) line 117" },
		NULL
	};
	// Verify information on stack above callback
	EXPECT_SUBTEST( (index = stk.Index( "WndProc" ) ) != -1 );
	EXPECT_SUBTEST( stk.Compare( stk2, FrameList::NoFilter, 0, index ) );

	dbg.StopDebugging();
	XSAFETY;

	return (TRUE);
}

void Cstack_baseIDETest::RebuildProject(LPCSTR projName,LPCSTR pConfig)
{
	GetSubSuite()->CleanUp();

	EXPECT_EXEC( SetProject(projName, PROJECT_EXE,fBuildOnly,pConfig), "Project could not be rebuilt" );
}

BOOL Cstack_baseIDETest::SteppingAndCallStackUpdating()
{
	CString fnName;
	UIEditor editor;

 	LogTestHeader( "SteppingAndCallStackUpdating" );

	bps.ClearAllBreakpoints();

 	LogTestHeader( "Updating of callstack during stepping" );

	UIWB.OpenFile( m_strProjectDir + "\\" + "main.c");   //Review yefims
	
	EXPECT_SUBTEST( dbg.StepToCursor(117) );

		FrameList list0;
		list0.CreateFromText( stk.GetAllFunctions() );
		EXPECT_SUBTEST( StepInUntilFrameAdded( "OtherMain" ) );

		EXPECT_SUBTEST( StepInUntilFrameAdded( "foo" ) );
		EXPECT_SUBTEST( StepInUntilFrameRemoved() );
		
		//	TODO: this is due to bug #65634
		//	remove the if line below when fixed - test fails on NT4
		if (GetSystem() != SYSTEM_NT_4)
		EXPECT_TRUE( cxx.ExpressionValueIs("foo(5, 6)", "11") ); //evaluate the function we've stepped out
		EXPECT_SUBTEST( StepInUntilFrameAdded( "BPWithLengthTest" ) );
		EXPECT_SUBTEST( StepInUntilFrameRemoved() );

		EXPECT_SUBTEST( StepInUntilFrameAdded( "Cxx_Tests" ) );
		long an_exception;
		EXPECT_TRUE( cxx.GetExpressionValue("OtherMain()", &an_exception)); //evaluate the function we're at which throws an exception (discard result)
		EXPECT_SUBTEST( StepInUntilFrameAdded( "fooclass::fooclass" ) );
		EXPECT_SUBTEST( StepInUntilFrameRemoved() );
		EXPECT_SUBTEST( StepInUntilFrameAdded( "fooclass::getID" ) );
		EXPECT_SUBTEST( StepInUntilFrameRemoved() );
		EXPECT_SUBTEST( StepInUntilFrameAdded( "fooclass::getCount" ) );
		EXPECT_SUBTEST( StepInUntilFrameRemoved() );
		EXPECT_SUBTEST( StepInUntilFrameAdded( "fooclass::operator int()" ) );
		EXPECT_TRUE( cxx.ExpressionValueIs("Cxx_Tests()", "<void>") ); //evaluate the function we're at
		EXPECT_SUBTEST( StepInUntilFrameRemoved() );
		EXPECT_SUBTEST( StepInUntilFrameAdded( "fooclass::static_func" ) );
		EXPECT_SUBTEST( StepInUntilFrameRemoved() );
		EXPECT_SUBTEST( StepInUntilFrameAdded( "fooclass::clear" ) );
		EXPECT_SUBTEST( StepInUntilFrameRemoved() );
		EXPECT_SUBTEST( StepInUntilFrameAdded( "fooclass::inline_func" ) );
		EXPECT_SUBTEST( StepInUntilFrameRemoved() );
		EXPECT_SUBTEST( StepInUntilFrameAdded( "fooclass::operator int()" ) );
		EXPECT_SUBTEST( StepInUntilFrameRemoved() );
		EXPECT_SUBTEST( dbg.StepOverUntilLine( "};") );
		EXPECT_SUBTEST( StepInUntilFrameAdded( "fooclass::~fooclass" ) );
	
		EXPECT_SUBTEST( StepInUntilFrameRemoved() );

		EXPECT_SUBTEST( StepInUntilFrameRemoved() );	// Cxx_Tests

		//	TODO: this is due to bug #65634
		//	remove the if line below when fixed - test fails on NT4
		if (GetSystem() != SYSTEM_NT_4)
		EXPECT_TRUE( cxx.ExpressionValueIs("foo2(6, 5)", "11") ); //evaluate the function we're about to step into
		EXPECT_SUBTEST( StepInUntilFrameAdded( "foo2" ) );
		EXPECT_SUBTEST( StepInUntilFrameRemoved() );

//	StopDbgCloseProject();
//	WriteLog(PASSED,"Testing of dbg.mak completed");
//	Sleep (200);

	dbg.StopDebugging();
	return (TRUE);
}

BOOL Cstack_baseIDETest::CheckLocals(   )
{
 	LogTestHeader( "CheckLocals" );

	CString strSource = "cstack.c";
	dbg.StepInto();

	// Open source
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource);   //Review yefims
//	file.Open( m_strProjectDir + "\\" + strSource);   
	MST.WFndWnd(strSource, FW_FOCUS);

	EXPECT_TRUE( src.Find("VoidProcNoParam();") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "VoidProcNoParam();") );

	MST.WFndWnd(strSource, FW_FOCUS);
	EXPECT_TRUE( dbg.StepInto() );

	CString strFunc = "VoidProcNoParam()";
	WriteLog( stk.CurrentFunctionIs(strFunc) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);

	dbg.SetSteppingMode(SRC);
	MST.WFndWnd(strSource, FW_FOCUS);
	EXPECT_TRUE( src.Find("CharProc1Param(SCHAR_MIN)") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "CharProc1Param(SCHAR_MIN)") );
	EXPECT_TRUE( dbg.StepInto(2) );
	strFunc = "CharProc1Param(char -128)";
	WriteLog( stk.CurrentFunctionIs(strFunc) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);
	VerifyLocalsWndString("char", "c", "-128");

	dbg.SetSteppingMode(SRC);
	MST.WFndWnd(strSource, FW_FOCUS);
	EXPECT_TRUE( src.Find("UCharProc1Param(UCHAR_MAX)") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "UCharProc1Param(UCHAR_MAX)") );
	EXPECT_TRUE( dbg.StepInto(2) );
	strFunc = "UCharProc1Param(unsigned char 255)";
	WriteLog( stk.CurrentFunctionIs(strFunc) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);
	VerifyLocalsWndString("unsigned char", "uc", "255");

	dbg.SetSteppingMode(SRC);
	MST.WFndWnd(strSource, FW_FOCUS);
	EXPECT_TRUE( src.Find("(IntProc1Param(INT_MIN)") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "(IntProc1Param(INT_MIN)") );
	EXPECT_TRUE( dbg.StepInto(2) );
	strFunc = "IntProc1Param(int -2147483648)";
	WriteLog( stk.CurrentFunctionIs(strFunc) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);
	VerifyLocalsWndString("int", "i", "-2147483648");
	
	return (TRUE);
}

BOOL Cstack_baseIDETest::NavigationAndModifiedLocalGlobal()
{
 	LogTestHeader( "NavigationAndModifiedLocalGlobal" );
	bps.ClearAllBreakpoints();

	bps.SetBreakpoint("foo");
	EXPECT_TRUE( dbg.Go(NULL, "int foo(int Parameter) {", "foo") );
	EXPECT_TRUE( cxx.ExpressionValueIs("Global", 77) );
	CString errorString = "CXX0017: Error: symbol \"Local\" not found";
	EXPECT_TRUE( cxx.ExpressionErrorIs("Local", errorString) );

	EXPECT_TRUE( stk.NavigateStack("TestG")>0 );
	EXPECT_TRUE( cxx.ExpressionValueIs("Global", 77) );
	EXPECT_TRUE( cxx.ExpressionValueIs("Local", 17) );
	EXPECT_TRUE( cxx.SetExpressionValue("Global", 60) );
	EXPECT_TRUE( cxx.SetExpressionValue("Local", 10) );

	EXPECT_TRUE( stk.NavigateStack("foo")>0 );
	EXPECT_TRUE( cxx.ExpressionValueIs("Global", 60) );
	EXPECT_TRUE( cxx.ExpressionErrorIs("Local", errorString) );

	EXPECT_TRUE( stk.NavigateStack("main")>0 );
	EXPECT_TRUE( cxx.ExpressionValueIs("Global", 60) );
	EXPECT_TRUE( cxx.ExpressionErrorIs("Local", errorString) );

	EXPECT_TRUE( dbg.StepOut(1, NULL, NULL, "TestG") );
	EXPECT_TRUE( cxx.ExpressionValueIs("Global", 60) );
	EXPECT_TRUE( cxx.ExpressionValueIs("Local", 10) );
	
	bps.ClearAllBreakpoints();
	EXPECT_TRUE( dbg.StepOut(1, NULL, NULL, "main") );
	EXPECT_TRUE( cxx.ExpressionValueIs("Global", 60) );
	EXPECT_TRUE( cxx.ExpressionErrorIs("Local", errorString) );
	
	dbg.StopDebugging();
	return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\stack\cspecial.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SK1CASES.CPP
//
//	Created by :			Date :
//		YefimS			01/06/94
//
//	Description :
//		Implementation of the Cstack2IDETest class
//

#include "stdafx.h"
#include "stacsub.h"
#include "cspecial.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(Cstack_specialIDETest, CDbgTestBase, "CallStack Special", -1, CstackSubSuite)

void Cstack_specialIDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

void Cstack_specialIDETest::Run()
{	 
	XSAFETY;
	if( SetProject("stack01\\stack01", PROJECT_XBE) )
	{	  
		XSAFETY;
		MainSequence();
		XSAFETY;
		Recursion();
		XSAFETY;
//		Options();
//		XSAFETY;
		AdvancedParam();
	}
}

///////////////////////////////////////////////////////////////////////////////
//	Test Cases
///////////////////////////////////////////////////////////////////////////////

BOOL Cstack_specialIDETest::MainSequence(   )
{
	EXPECT( dbg.Restart() );
	EXPECT( UIWB.VerifySubstringAtLine( "{" ) );		
	// Verify main and __crt are in stack
	CString strFunc = "main() line 57";
	LOG->RecordCompare( stk.CurrentFunctionIs(strFunc) == TRUE,
		"Top of stack on restart expected value: %s ", strFunc);
	//xbox strFunc = "mainCRTStartup";
	strFunc = "mainXapiStartup";
	stk.NavigateStack(1);
	Sleep(1500); // emmang@xbox
	LOG->RecordCompare( stk.FunctionIs(strFunc, 1) == TRUE,
		"CRT startup stack on restart expected value: %s ", strFunc);

	CheckParamList();
	VarParam();

	return (TRUE);
}

//I have no idea what I wanted to to here: all C++ cases are included in AdvancedParam()
BOOL Cstack_specialIDETest::CheckParamList(   )
{
	return (TRUE);
}

BOOL Cstack_specialIDETest::VarParam(   )
{
	bps.SetBreakpoint("average");
	dbg.Go("average");
	EXPECT_TRUE(stk.CurrentFunctionIs("average(int 1) line ") );
	bps.ClearAllBreakpoints();
	return (TRUE);
}

const int nFirstFactorialLine = 311;
//char szLastLn==nFirstFactorialLine+5;
//char szRetLn==nFirstFactorialLine+4;

BOOL Cstack_specialIDETest::Recursion(   )
{
 	LogTestHeader( "Recursion" );

	CString sLastLn;sLastLn.Format("%d",nFirstFactorialLine+5); //last line of factorial function
	CString sRetLn;sRetLn.Format("%d",nFirstFactorialLine+4);  //the return line of factorial function

	EXPECT( dbg.Restart() );
	// Open source
	CString strSource = "cstack.c";
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource);   //Review yefims
	MST.WFndWnd(strSource, FW_FOCUS);

	EXPECT_TRUE( src.Find("factorial(9)") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "factorial(9)") );
	CString strFunc = "main() line 122";
	VerifyLocalsWndString("int", "i_main", "4");
//	MST.WFndWnd(strSource, FW_FOCUS);
	WriteLog( stk.CurrentFunctionIs(strFunc) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);
/*	strFunc = "mainCRTStartup";
	WriteLog( stk.FunctionIs(strFunc, 1) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);
*/
	WriteLog( ShortRecCycle(9) ? PASSED : FAILED, "Recursion 1: CallStack verification through recursion step" );
	WriteLog( ShortRecCycle(8) ? PASSED : FAILED, "Recursion 2: CallStack verification through recursion step" );

	MST.WFndWnd(strSource, FW_FOCUS);
	for(int cnt=0;cnt<6;cnt++)
		EXPECT( dbg.StepToCursor());

	WriteLog( ShortRecCycle(1) ? PASSED : FAILED, "Recursion 9: CallStack verification through recursion step" );
	WriteLog( ShortRecCycle(0) ? PASSED : FAILED, "Recursion 10: CallStack verification through recursion step" );

	EXPECT( dbg.StepOver() );

	WriteLog( StackIsCorrect(0, sLastLn) ? PASSED : FAILED, "Recursion 10: Stack correctness after StepOver");
	EXPECT( dbg.StepOut() );
	WriteLog( StackIsCorrect(1, sRetLn) ? PASSED : FAILED, "Recursion 9: Stack correctness after StepOut");
	EXPECT( dbg.StepOut() );

	for(cnt=0;cnt<6;cnt++)
		EXPECT( dbg.StepOut() );

	WriteLog( StackIsCorrect(8, sRetLn) ? PASSED : FAILED, "Recursion 2: Stack correctness after StepOut");
	EXPECT( dbg.StepOut() );
	WriteLog( StackIsCorrect(9, sRetLn) ? PASSED : FAILED, "Recursion 1: Stack correctness after StepOut");
	EXPECT( dbg.StepOut() );
//	EXPECT( EndOfStackIsCorrect(0) ); //use StackIsCorrect with no smbols from recursive function
	WriteLog( StackIsCorrect(10, "") ? PASSED : FAILED, "Recursion 0: Stack correctness after all is done");

	EXPECT( dbg.StopDebugging() );

	return (TRUE);
}
//callstack options (hex display, types/values only displey?)
BOOL Cstack_specialIDETest::Options(   )
{
	return (TRUE);
}

BOOL Cstack_specialIDETest::AdvancedParam(   )
{
	bps.SetBreakpoint("Cxx_Tests");
	dbg.Go("Cxx_Tests");
//pointers to gunctions on the stack
	EXPECT_TRUE( StepInUntilFrameAdded( "poniterstofunc" ));
	//TODO check the second param on the stack when the EE bug fixed
	EXPECT_TRUE(stk.CurrentFunctionIs("poniterstofunc(void (void *, unsigned long)*") );
	dbg.StepOut();
	EXPECT_TRUE( StepInUntilFrameAdded( "poniterstofunc" ));
	//NULL pointer to function
	//TODO: change <no type> when EE bug is fixed
	EXPECT_TRUE(stk.CurrentFunctionIs("int (void *, <no type>)* 0x00000000") );
	dbg.StepOut();
//overloaded functions
	EXPECT_TRUE( StepInUntilFrameAdded("overloaded_function(int 1)") );
	dbg.StepOut();
//TODO set ambiguous BP on second entry to "overloaded_function"?
	EXPECT_TRUE( StepInUntilFrameAdded("overloaded_function(long 1)") );
	dbg.StepOut();
//different calling conventions
	bps.SetBreakpoint("fastcall_function");
	dbg.Go("fastcall_function");	
	char const * const stk0[] =
	{
		"fastcall_function(float 3.00000) line", //__fastcall does not put all params on stack
		"stdcall_function(int 1, long 2, float 3.00000) line",
		"cdecl_function(int 1, long 2, float 3.00000) line",
		"Cxx_Tests()",
		NULL
	};
	// Verify information on stack above callback
	int index;
	EXPECT_SUBTEST( (index = stk.Index( "Cxx_Tests()" ) ) != -1 );
	EXPECT_SUBTEST( stk.Compare( stk0, FrameList::NoFilter, 0, index ) );

	bps.ClearAllBreakpoints();
	//xbox EXPECT_TRUE(dbg.Go( NULL, NULL, NULL, ASSUME_NORMAL_TERMINATION));
	EXPECT_TRUE(dbg.StopDebugging());
	return (TRUE);
}


BOOL Cstack_specialIDETest::ShortRecCycle(int nParam)
{
	CString strLine;
	strLine.Format("%d", nFirstFactorialLine+1);

	EXPECT_TRUE( dbg.StepInto(2) );
	if( !StackIsCorrect(nParam, strLine) )
		return FALSE;

	strLine.Format("%d", nParam);
	EXPECT_TRUE( LocalsWndStringIs("int", "i", strLine ));

	EXPECT_TRUE( dbg.StepInto() );
	EXPECT_TRUE( LocalsWndStringIs("int", "i", strLine ));

	if( nParam )
		strLine.Format("%d",nFirstFactorialLine+4);
	else
		strLine.Format("%d",nFirstFactorialLine+2);

	if( !StackIsCorrect(nParam, strLine) )
		return FALSE;

	return TRUE;
}

BOOL Cstack_specialIDETest::StackIsCorrect(int nParam, LPCSTR strLine)
{
#define MAX_STK_LINE 80
 	char buffer[10];
	BOOL ret = TRUE;	
	int level;
	char  stktable[11][MAX_STK_LINE]; //11 for the "main()" frame
	char const * stkrec[12]; //12 for the baseline which must be NULL
	for( level = 0; level < 10 - nParam; level++ )
	{
		strcpy(stktable[level], "factorial(int ");
		strcat(stktable[level], _itoa(nParam + level, buffer, 10));
		strcat(stktable[level], ") line ");
		if(level==0)
			strcat(stktable[level], strLine);
		else
		{
			sprintf(buffer, "%d + ",nFirstFactorialLine+4);
			strcat(stktable[level], buffer);
		}
		stkrec[level]=stktable[level];
	}
	strcpy(stktable[level], "main() "); //main shld be the last
	stkrec[level]=stktable[level];
//	strcpy(stktable[++level], "mainCRTStartup"); //platform specific
//	stkrec[level]=stktable[level];
	stkrec[level+1] =  NULL;
	EXPECT_SUBTEST( ret=stk.Compare( stkrec, FrameList::NoFilter, 0, level ) );

	return ret;
}



BOOL Cstack_specialIDETest::EndOfStackIsCorrect(int level)
{ //obsolete
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\stack\cs_dlls.h ===
///////////////////////////////////////////////////////////////////////////////
//	cs_dlls.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CstackIDETest Class
//

#ifndef __cs_dlls_H__
#define __cs_dlls_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\dbgtestbase.h"

///////////////////////////////////////////////////////////////////////////////
//	CstackIDETest class

class Cstack_dllsIDETest :public CDbgTestBase
{
	DECLARE_TEST(Cstack_dllsIDETest, CstackSubSuite)

public:  // Operations
	virtual void PreRun(void);
	virtual void Run();

	// Test Cases
protected:
	BOOL DllGeneralNavigation();
	BOOL DllStepCheckCallStack();
};

#endif //__cs_dlls_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\stack\stacsub.h ===
///////////////////////////////////////////////////////////////////////////////
//	stacsub.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CstackSubSuite class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CstackSubSuite class

class CstackSubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CstackSubSuite)
//	CstackSubSuite() { m_strName = "TestWizard Generated script"; m_strOwner = "VCBU QA"; }


	DECLARE_TESTLIST()
public:
	void CleanUp(void);
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\retval\retvcase.h ===
///////////////////////////////////////////////////////////////////////////////
//	RetVcase.h
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CRetValIDETest Class
//

#ifndef __RetVcase_H__
#define __RetVcase_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\dbgtestbase.h"
#include "retvsub.h"

///////////////////////////////////////////////////////////////////////////////
//	CRetValIDETest class

class CRetValIDETest : public CDbgTestBase
{
		DECLARE_TEST(CRetValIDETest, CRetValSubSuite)

	// Operations
	public:
		virtual void PreRun(void);
		virtual void Run(void);

	// Test cases
	private:
		void StepOverFunctionsReturningNativeTypes(void);
		void StepOverFunctionReturningClassObject(void);
		void StepOverFunctionReturningPointerToClassObject(void);
		void StepOverFunctionThrowingExceptionToParent(void);
		void StepOutOfWinMain(void);
		void StepOverDllFunction(void);
		void StepOverConstructorAndVirtualMemberFunction(void);
		void StepOverFunctionWithOnlyLineNumberDebugInfo(void);
		void StepOverFunctionWithNoDebugInfo(void);
		void StepOverStaticallyLinkedNonDebugCrtFunction(void);
		void StepOverWin32ApiFunction(void);
		void StepOutOfFunctionWithF8(void);
		void StepOutOfFunctionWithF10(void);
		void StepOutOfFunctionWithShiftF7(void);
		void StepOverLineWithNoFunctionCall(void);
		void VerifyNoReturnValueDisplayedAfterGo(void);
		void VerifyReturnValueDisappearsWhenAssigningValue(void);
		void VerifyReturnValueDisappearsWhenNotAssigningValue(void);
		void VerifyReturnValueStaysAfterResettingNextStatement(void);
		void VerifyReturnValueStaysAfterStackNavigation(void);
		void VerifyReturnValueForFastcallCallingConvention(void);
		void StepOutOfMultipleLevelsOfRecursion(void);
		void StepOutOfCallbackFunction(void);
		void VerifyReturnValueFieldCannotBeEdited(void);
		void VerifyNoReturnValueDisplayedAfterRestart(void);
		void VerifyNoReturnValueDisplayedAfterStopAndRestart(void); 
		void ToggleReturnValueOffAndOn(void);

	// Data
	private:
		EXPR_INFO expr_info_actual[4], expr_info_expected[4];
	};

#endif //__RetVcase_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\stack\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\stack\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\threads\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\threads\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\stack\cs_stres.h ===
///////////////////////////////////////////////////////////////////////////////
//	cs_stres.H
//
//	Created by :			Date :
//		YefimS				01/06/94
//
//	Description :
//		Declaration of the Cstack_stressIDETest class
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __cs_stres_H__
#define __cs_stres_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif


#include "..\..\dbgtestbase.h"

///////////////////////////////////////////////////////////////////////////////
//	Cstack_stressIDETest class

class Cstack_stressIDETest : public CDbgTestBase
{
	DECLARE_TEST(Cstack_stressIDETest, CstackSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run();

// Test Cases
protected:
	BOOL CheckLocals(   );
	BOOL Recursion(   );

// Utilities
protected:
	void VerifyStack(int nParam, LPCSTR strLine);
	void VerifyEndOfStack(int level);
	void RecCycle(int nParam);
	BOOL ShortRecCycle(int nParam);
	BOOL EndOfStackIsCorrect(int level);
	BOOL StackIsCorrect(int nParam, LPCSTR strLine);
};

#endif //__cs_stres_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\threads\ThreadsSubsuite.h ===
///////////////////////////////////////////////////////////////////////////////
//	ThreadsSubsuite.h
//
//	Created by: MichMa		Date: 2/5/98
//
//	Description :
//		Declaration of the CThreadsSubsuite class
//

#ifndef __THREADSSUBSUITE_H__
#define __THREADSSUBSUITE_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CThreadsSubsuite class

class CThreadsSubsuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CThreadsSubsuite)
	DECLARE_TESTLIST()
};

#endif //__THREADSSUBSUITE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\stack\cs_stres.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	cs_stres.CPP
//
//	Created by :			Date :
//		YefimS			01/06/94
//
//	Description :
//		Implementation of the Cstack2IDETest class
//

#include "stdafx.h"
#include "stacsub.h"
#include "cs_stres.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

IMPLEMENT_TEST(Cstack_stressIDETest, CDbgTestBase, "CallStack Stress", -1, CstackSubSuite)

void Cstack_stressIDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}

void Cstack_stressIDETest::Run()
{	 
	XSAFETY;
	if( SetProject("stack01\\stack01", PROJECT_XBE) )
	{	  
		XSAFETY;
		CheckLocals();
		XSAFETY;
		Recursion();
		XSAFETY;
	}
}

///////////////////////////////////////////////////////////////////////////////
//	Test Cases
///////////////////////////////////////////////////////////////////////////////

BOOL Cstack_stressIDETest::CheckLocals(   )
{
 	LogTestHeader( "CheckLocals" );

	CString strSource = "cstack.c";
	
	dbg.StepInto();

	// Open source
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource);   //Review yefims

	EXPECT_TRUE( src.Find("VoidProcNoParam();") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "VoidProcNoParam();") );
//	MST.WFndWnd(strSource, FW_FOCUS);
	EXPECT_TRUE( dbg.StepInto() );
	CString strFunc = "VoidProcNoParam()";
	WriteLog( stk.CurrentFunctionIs(strFunc) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);

	EXPECT_TRUE( src.Find("CharProc1Param(SCHAR_MIN)") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "CharProc1Param(SCHAR_MIN)") );
	EXPECT_TRUE( dbg.StepInto(2) );
	strFunc = "CharProc1Param(char -128)";
	WriteLog( stk.CurrentFunctionIs(strFunc) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);
	VerifyLocalsWndString("char", "c", "-128");

	EXPECT_TRUE( src.Find("UIntProc1Param(UINT_MAX)") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "UIntProc1Param(UINT_MAX)") );
	EXPECT_TRUE( dbg.StepInto(2) );
	strFunc = "UIntProc1Param(unsigned int 4294967295)";
	WriteLog( stk.CurrentFunctionIs(strFunc) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);
	VerifyLocalsWndString("unsigned int", "ui", "4294967295");

	EXPECT_TRUE( src.Find("LongProc1Param") );
	EXPECT_TRUE( dbg.StepToCursor(0) );
	EXPECT( dbg.StepInto(2) );
	// Verify function is in stack
	strFunc = "LongProc1Param(long -2147483648)";
	WriteLog( stk.CurrentFunctionIs(strFunc) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);
	// Verify locals in Locals window							
	VerifyLocalsWndString("long", "l", "-2147483648");

	EXPECT_TRUE( src.Find("LDoubleProc1Param(ldblmin)") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "LDoubleProc1Param(ldblmin)") );
	EXPECT( dbg.StepInto(2) );
	strFunc = "LDoubleProc1Param(double 2.2250738585072e-308)";
	WriteLog( stk.CurrentFunctionIs(strFunc) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);
	VerifyLocalsWndString("double", "ld", "2.2250738585072e-308");

	EXPECT_TRUE( src.Find("PShortProc1Param") );
	EXPECT_TRUE( dbg.StepToCursor(0) );
	EXPECT( dbg.StepInto(2) );
	// Verify function is in stack
	strFunc = "PShortProc1Param(short *";
	WriteLog( stk.CurrentFunctionIs(strFunc) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);
	// Verify locals in Locals window							
	VerifyLocalsWndString("short *", "ps", "0x");

	EXPECT_TRUE( src.Find("average(1,2,3,4,5,6,7,8,9, -1)") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "average(1,2,3,4,5,6,7,8,9, -1)") );
	EXPECT( dbg.StepInto(2) );
	strFunc = "average(int 1)";
	WriteLog( stk.CurrentFunctionIs(strFunc) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);
	VerifyLocalsWndString("int", "first", "1");

	EXPECT_TRUE( src.Find("factorial(9)") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "factorial(9)") );
	EXPECT( dbg.StepInto(2) );
	strFunc = "factorial(int 9)";
	WriteLog( stk.CurrentFunctionIs(strFunc) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);
	VerifyLocalsWndString("int", "i", "9");

	EXPECT_TRUE( src.Find("MultiParam(CHAR_MIN,") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "MultiParam(CHAR_MIN,") );
	EXPECT( dbg.StepInto(2) );
	strFunc = "MultiParam(char -128, int 2147483647, short 32767, long 2147483647, double 1.7976931348623e+308, double 1.7976931348623e+308, float 3.40282e+038)";
	WriteLog( stk.CurrentFunctionIs(strFunc) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);

	VerifyLocalsWndString("char", "c", "-128");
	VerifyLocalsWndString("int", "i", "2147483647", 2);
	VerifyLocalsWndString("short", "s", "32767", 3);
	VerifyLocalsWndString("long", "l", "2147483647", 4);
	VerifyLocalsWndString("double", "d", "1.7976931348623e+308", 5);
	VerifyLocalsWndString("double", "ld", "1.7976931348623e+308", 6);
	VerifyLocalsWndString("float", "f", "3.40282e+038", 7);

	return (TRUE);
}

const int nFirstFactorialLine = 311;
//char szLastLn==nFirstFactorialLine+5;
//char szRetLn==nFirstFactorialLine+4;

BOOL Cstack_stressIDETest::Recursion(   )
{
 	LogTestHeader( "Recursion" );

	CString sLastLn;sLastLn.Format("%d",nFirstFactorialLine+5); //last line of factorial function
	CString sRetLn;sRetLn.Format("%d",nFirstFactorialLine+4);  //the return line of factorial function

	EXPECT( dbg.Restart() );
	// Open source
	CString strSource = "cstack.c";
	UIWB.OpenFile( m_strProjectDir + "\\" + strSource);   //Review yefims
	MST.WFndWnd(strSource, FW_FOCUS);

	EXPECT_TRUE( src.Find("factorial(9)") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "factorial(9)") );
	//the copy of the sequence from cspecial case
//	CString strFunc = "main() line 122";
//	VerifyLocalsWndString("int", "i_main", "4");
//	MST.WFndWnd(strSource, FW_FOCUS);
//	WriteLog( stk.CurrentFunctionIs(strFunc) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);
/*	strFunc = "mainCRTStartup";
	WriteLog( stk.FunctionIs(strFunc, 1) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);
*/
//CHRISKOZ	WriteLog( ShortRecCycle(9) ? PASSED : FAILED, "Recursion 1: CallStack verification through recursion step" );
//CHRISKOZ	WriteLog( ShortRecCycle(8) ? PASSED : FAILED, "Recursion 2: CallStack verification through recursion step" );
//CHRISKOZ	WriteLog( ShortRecCycle(7) ? PASSED : FAILED, "Recursion 3: CallStack verification through recursion step" );
//CHRISKOZ	WriteLog( ShortRecCycle(6) ? PASSED : FAILED, "Recursion 4: CallStack verification through recursion step" );
//CHRISKOZ	WriteLog( ShortRecCycle(5) ? PASSED : FAILED, "Recursion 5: CallStack verification through recursion step" );
//CHRISKOZ	WriteLog( ShortRecCycle(4) ? PASSED : FAILED, "Recursion 6: CallStack verification through recursion step" );
//CHRISKOZ	WriteLog( ShortRecCycle(3) ? PASSED : FAILED, "Recursion 7: CallStack verification through recursion step" );
//CHRISKOZ	WriteLog( ShortRecCycle(2) ? PASSED : FAILED, "Recursion 8: CallStack verification through recursion step" );

//CHRISKOZ	WriteLog( ShortRecCycle(1) ? PASSED : FAILED, "Recursion 9: CallStack verification through recursion step" );
//CHRISKOZ	WriteLog( ShortRecCycle(0) ? PASSED : FAILED, "Recursion 10: CallStack verification through recursion step" );

	RecCycle(9); LOG->RecordSuccess("Recursion 1: Stack correctness in recursive StepInto");
	RecCycle(8); LOG->RecordSuccess("Recursion 2: Stack correctness in recursive StepInto");
	RecCycle(7); LOG->RecordSuccess("Recursion 3: Stack correctness in recursive StepInto");
	RecCycle(6); LOG->RecordSuccess("Recursion 4: Stack correctness in recursive StepInto");
	RecCycle(5); LOG->RecordSuccess("Recursion 5: Stack correctness in recursive StepInto");
	RecCycle(4); LOG->RecordSuccess("Recursion 6: Stack correctness in recursive StepInto");
//CHRISKOZ enable when StepOver recurvisefunction does not work
//	RecCycle(3); 
//	RecCycle(2);
//	RecCycle(1);
//	RecCycle(0);

	EXPECT( dbg.StepOver() ); //CHRISKOZ, bug: StepOver the recursive function used not to work

//CHRISKOZ enable when StepOver recurvisefunction does not work
//	WriteLog( StackIsCorrect(0, sLastLn) ? PASSED : FAILED, "Recursion 10: Stack correctness after StepOver");
//	EXPECT( dbg.StepOut() );
//	WriteLog( StackIsCorrect(1, sRetLn) ? PASSED : FAILED, "Recursion 9: Stack correctness after StepOut");
//	EXPECT( dbg.StepOut() );
//	WriteLog( StackIsCorrect(2, sRetLn) ? PASSED : FAILED, "Recursion 8: Stack correctness after StepOut");
//	EXPECT( dbg.StepOut() );
//	WriteLog( StackIsCorrect(3, sRetLn) ? PASSED : FAILED, "Recursion 7: Stack correctness after StepOut");
//	EXPECT( dbg.StepOut() );
	WriteLog( StackIsCorrect(4, sLastLn) ? PASSED : FAILED, "Recursion 6: Stack correctness after StepOver");
	EXPECT( dbg.StepOut() );
	WriteLog( StackIsCorrect(5, sRetLn) ? PASSED : FAILED, "Recursion 5: Stack correctness after StepOut");
	EXPECT( dbg.StepOut() );
	WriteLog( StackIsCorrect(6, sRetLn) ? PASSED : FAILED, "Recursion 4: Stack correctness after StepOut");
	EXPECT( dbg.StepOut() );
	WriteLog( StackIsCorrect(7, sRetLn) ? PASSED : FAILED, "Recursion 3: Stack correctness after StepOut");
	EXPECT( dbg.StepOut() );
	WriteLog( StackIsCorrect(8, sRetLn) ? PASSED : FAILED, "Recursion 2: Stack correctness after StepOut");
	EXPECT( dbg.StepOut() );
	WriteLog( StackIsCorrect(9, sRetLn) ? PASSED : FAILED, "Recursion 1: Stack correctness after StepOut");
	EXPECT( dbg.StepOut() );
//	EXPECT( EndOfStackIsCorrect(0) ); //use StackIsCorrect with no smbols from recursive function
	WriteLog( StackIsCorrect(10, "") ? PASSED : FAILED, "Recursion 0: Stack correctness after all is done");

	EXPECT( dbg.StopDebugging() );

	return (TRUE);
}



void Cstack_stressIDETest::RecCycle(int nParam)
{
	CString strLine;
	strLine.Format("%d", nFirstFactorialLine);

	EXPECT( dbg.StepInto() );
	StackIsCorrect(nParam, strLine);

	EXPECT( dbg.StepInto() );

	strLine.Format("%d", nParam);
	VerifyLocalsWndString("int", "i", strLine);	
	strLine.Format("%d", nFirstFactorialLine+1);	
	StackIsCorrect(nParam, strLine);

	EXPECT( dbg.StepInto() );
	strLine.Format("%d", nParam);
	VerifyLocalsWndString("int", "i", strLine);

	if( nParam )
		strLine.Format("%d", nFirstFactorialLine+4);
	else
		strLine.Format("%d", nFirstFactorialLine+2);

	StackIsCorrect(nParam, strLine);
}

BOOL Cstack_stressIDETest::ShortRecCycle(int nParam)
{
	CString strLine;
	strLine.Format("%d", nFirstFactorialLine+1);

	EXPECT_TRUE( dbg.StepInto(2) );
	if( !StackIsCorrect(nParam, strLine) )
		return FALSE;

	strLine.Format("%d", nParam);
	EXPECT_TRUE( LocalsWndStringIs("int", "i",  strLine));
//	if( !StackIsCorrect(nParam, nFirstFactorialLine+1) )
//		return FALSE;
	EXPECT_TRUE( dbg.StepInto() );
	EXPECT_TRUE( LocalsWndStringIs("int", "i", strLine));

	if( nParam )
		strLine.Format("%d", nFirstFactorialLine+4);
	else
		strLine.Format("%d", nFirstFactorialLine+2);

	if( !StackIsCorrect(nParam, strLine) )
		return FALSE;

	return TRUE;
}


BOOL Cstack_stressIDETest::StackIsCorrect(int nParam, LPCSTR strLine)
{
#define MAX_STK_LINE 80
 	char buffer[10];
	BOOL ret = TRUE;	
	int level;
	char  stktable[11][MAX_STK_LINE]; //11 for the "main()" frame
	char const * stkrec[12]; //12 for the baseline which must be NULL
	for( level = 0; level < 10 - nParam; level++ )
	{
		strcpy(stktable[level], "factorial(int ");
		strcat(stktable[level], _itoa(nParam + level, buffer, 10));
		strcat(stktable[level], ") line ");
		if(level==0)
			strcat(stktable[level], strLine);
		else
		{
			sprintf(buffer, "%d + ",nFirstFactorialLine+4);
			strcat(stktable[level], buffer);
		}
		stkrec[level]=stktable[level];
LOG->RecordInfo("Function at level %d: expected value: %s ", level, stkrec[level]);
	}
	strcpy(stktable[level], "main() "); //main shld be the last
	stkrec[level]=stktable[level];
LOG->RecordInfo("Function at level %d: expected value: %s ", level, stkrec[level]);
//	strcpy(stktable[++level], "mainCRTStartup"); //platform specific
//	stkrec[level]=stktable[level];
	stkrec[level+1] =  NULL;
	EXPECT_SUBTEST( ret=stk.Compare( stkrec, FrameList::NoFilter, 0, level ) );

	return ret;
}


BOOL Cstack_stressIDETest::EndOfStackIsCorrect(int level)
{ //obsolete
	return TRUE;
}

void Cstack_stressIDETest::VerifyStack(int nParam, LPCSTR strLine)
{ //obsolete
/* 	char buffer[4];

	// Verify stack
	CString strFunc = (CString)"factorial(int " + (CString)_itoa(nParam, buffer, 10) + ") line " + strLine;
	WriteLog( stk.CurrentFunctionIs(strFunc) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);
	int level;
	for( level = 1; level < 10 - nParam; level++ )
	{
		strFunc = (CString)"factorial(int " + (CString)_itoa(nParam + level, buffer, 10) + ") line 'nFirstFactorialLine+4' + ";
		WriteLog( stk.FunctionIs(strFunc, level) ? PASSED : FAILED, "Current function expected value: %s ", strFunc);
	}		
	VerifyEndOfStack(level);
*/
}

void Cstack_stressIDETest::VerifyEndOfStack(int level)
{ //obsolete
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\tmplates\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\stack\cs_dlls.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	cs_dlls.CPP
//											 
//	Created by :			
//		VCBU QA		
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "stacsub.h"
#include "cs_dlls.h"	 

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
#define cRetailTests 1
#define cDebugTests 1

IMPLEMENT_TEST(Cstack_dllsIDETest, CDbgTestBase, "CallStack DLLs", -1, CstackSubSuite)

void Cstack_dllsIDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();

}

void Cstack_dllsIDETest::Run()
{
	XSAFETY;

//	EXPECT_EXEC( dbg.SetOwnedStack( &stk ), "Could not setup owned stack" );
//	XSAFETY;
	EXPECT_EXEC( SetProject( "dllapp\\incdll", PROJECT_DLL, fBuildOnly), "Project could not be setup" );
	EXPECT_EXEC( SetProject( "dllapp\\powdll", PROJECT_DLL, fBuildOnly), "Project could not be setup" );
	EXPECT_EXEC( SetProject( "dllapp\\dec2", PROJECT_DLL, fBuildOnly), "Project could not be setup" );
	EXPECT_EXEC( SetProject( "dllapp\\dllappx"), "Project could not be setup" );

	// when makefile is wrapped, wrapper name is dllappx1.mak and
	// exe for debug session becomes dllappx1.exe, so we must
	// change it back since we actually build dllappx.exe.
	prj.SetExeForDebugSession("dllappx.exe");

	// dllappx builds 4 files: incdll.dll, dec2.dll, powdll.dll and dllappx.exe.
	// dllappx.exe is copied to remote by SetProject, but we need to do dlls.
	COConnection *pconnec = GetSubSuite()->GetIDE()->GetConnectionInfo();
	if(pconnec->GetUserConnections() != CONNECTION_LOCAL)
	{
		prj.UpdateRemoteFile("src\\dllapp\\incdll.dll");
		prj.UpdateRemoteFile("src\\dllapp\\dec2.dll");
		prj.UpdateRemoteFile("src\\dllapp\\powdll.dll");
	}

	XSAFETY;
	DllGeneralNavigation();
	XSAFETY;
	DllStepCheckCallStack();
	XSAFETY;

	StopDbgCloseProject();
	WriteLog(PASSED,"Testing of dllapp.mak completed");
}


BOOL Cstack_dllsIDETest::DllGeneralNavigation()
{
	CString fnName;
	UIEditor editor;
	int index;

 	LogTestHeader( "DllGeneralNavigation" );

	bps.ClearAllBreakpoints();

	LogTestHeader( "Initial callstack after first stepin" );
	EXPECT_TRUE( dbg.StepInto( 1, "WinMain" ) );
	EXPECT_TRUE( Frame( stk.GetFunction( 0 ) ).GetFunctionName( fnName ) );
	EXPECT_TRUE( fnName == "WinMain" );

 	LogTestHeader( "General navigation with full debug info" );
	EXPECT_TRUE( NULL != bps.SetBreakpoint("{MainWndProc,,}CALLDLLATSTART") );
	EXPECT_TRUE( dbg.Go() );
	EXPECT_TRUE( dbg.AtSymbol("CALLDLLATSTART"));

	char const * const stk1[] =
	{
		{ "MainWndProc( HWND__ * %, unsigned int %, unsigned int %, long %) line 261" },
		NULL
	};

	// Verify information on stack above callback
	EXPECT_TRUE( (index = stk.Index( "MainWndProc" ) ) != -1 );
	EXPECT_TRUE( stk.Compare( stk1, FrameList::NoFilter, 0, index ) );

	dbg.StopDebugging();

	return (TRUE);
}

BOOL Cstack_dllsIDETest::DllStepCheckCallStack()
{
	CString fnName;
	UIEditor editor;
	int index;

 	LogTestHeader( "DllStepCheckCallStack" );
	bps.ClearAllBreakpoints();

	// Step through some dll's.
 	LogTestHeader( "Step through some dll's; stack check and some navigation" );
	EXPECT_TRUE( bps.SetBreakpoint("{MainWndProc,,}CALLDLLATSTART") );
	EXPECT_TRUE( dbg.Go("CALLDLLATSTART") );
	EXPECT_TRUE( StepInUntilFrameAdded( "Dec(unsigned short *" ) );
	EXPECT_TRUE( src.Find("Inc(wBar);   // call another") );
	EXPECT_TRUE( dbg.StepToCursor(0, NULL, "Inc(wBar);   // call another") );
	LOG->Comment("Swithing to ASM mode");
	dbg.SetSteppingMode(ASM);
	LOG->Comment("Stepping until INCDLL!");
	for(int i=0;i<30;i++)
	{  //look for the module name when stepping through thunk jumps
		dbg.StepInto();
		if(stk.CurrentFunctionIs("INCDLL! "))
			break;
	}
	LOG->RecordCompare(i<10, "Stepping into INCDLL module");
	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE( stk.CurrentFunctionIs("Inc(unsigned short *") );

	// Do a stack check and some navigation
	char const * const stk2[] =
	{
		{ "Inc( unsigned short * % ) line 36" },
		{ "Dec( unsigned short * % ) line 57" },
		{ "MainWndProc( HWND__ * %, unsigned int %, unsigned int %, long %) line 266" },
//		{ "*" },
		NULL
	};

	// Set stack dirty since StepInUntilFrameAdded used different COStack/CODebug objects
//	stk.SetDirty( TRUE );
	EXPECT_TRUE( (index = stk.Index( "MainWndProc" ) ) != -1 );
	EXPECT_TRUE( stk.Compare( stk2, FrameList::NoFilter, 0, index ) );

	dbg.SetSteppingMode(SRC);
	EXPECT_TRUE( StepInUntilFrameRemoved() );
	EXPECT_TRUE( stk.Compare( stk2+1, FrameList::NoFilter, 0, index-1 ) );

		
	//	dPow is called in an explicitly loaded dll by a function pointer
	EXPECT_TRUE( StepInUntilFrameAdded( "dPow(int 10, int 3)" ) );

	// Do a stack check and some navigation
	const char* frame1;
	frame1 = "dPow( int 10, int 3 ) line 37";
			
	char const * const stk3[] =
	{
		{ frame1 },
		{ "Dec( unsigned short * % ) line 64" },
		{ "MainWndProc( HWND__ * %, unsigned int %, unsigned int %, long %) line 266" },
//		{ "*" },
		NULL
	};

	// Set stack dirty since StepInUntilFrameAdded used different COStack/CODebug objects
	stk.SetDirty( TRUE );
	
	EXPECT_TRUE( (index = stk.Index( "MainWndProc" ) ) != -1 );
	EXPECT_TRUE( stk.Compare( stk3, FrameList::NoFilter, 0, index ) );

	EXPECT_TRUE( StepInUntilFrameRemoved() );
 
	dbg.StopDebugging();

	return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\tmplates\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\tmplates\tmplsub.h ===
///////////////////////////////////////////////////////////////////////////////
//	TMPLSUB.H
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CTemplatesSubSuite class
//

#ifndef __TMPLSUB_H__
#define __TMPLSUB_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CTemplatesSubSuite class

class CTemplatesSubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CTemplatesSubSuite)
	DECLARE_TESTLIST()
protected:
	void CleanUp(void);
};

#endif //__TMPLSUB_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\stack\stacsub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CstackSubSuite class
//

#include "stdafx.h"
#include "stacsub.h"
#include "afxdllx.h"

#include "cs_base.h"
#include "cs_dlls.h"
#include "cspecial.h"
#include "cs_stres.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;


/////////////////////////////////////////////////////////////////////////////
// CstackSubSuite

IMPLEMENT_SUBSUITE(CstackSubSuite, CIDESubSuite, "CallStack", "VCQA Debugger")

BEGIN_TESTLIST(CstackSubSuite)
	TEST(Cstack_baseIDETest, RUN)
	//xbox TEST(Cstack_dllsIDETest, RUN)
	TEST(Cstack_specialIDETest, RUN)
	//xbox TODO: fix TEST(Cstack_stressIDETest, RUN)
END_TESTLIST()


void CstackSubSuite::CleanUp(void)
	{
	::CleanUp("stack01");
	::CleanUp("testgo01");
	::CleanUp("dbg");
	::CleanUp("dllapp");
	}
///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\threads\ThreadsSubsuite.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	ThreadsSubsuite.cpp
//
//	Created by: MichMa		Date: 2/5/98
//
//	Description :
//		Implementation of the CThreadsSubsuite class
//

#include "stdafx.h"
#include "ThreadsSubsuite.h"
#include "afxdllx.h"

#include "ThreadsCases.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CThreadsSubsuite

IMPLEMENT_SUBSUITE(CThreadsSubsuite, CIDESubSuite, "Threads", "emmang@xbox.com")

BEGIN_TESTLIST(CThreadsSubsuite)
	TEST(CThreadsCases, RUN)
END_TESTLIST()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\threads\ThreadsCases.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	ThreadsCases.cpp
//											 
//	Created by:			Date:			
//		MichMa				2/5/98	
//
//	Description:								 
//		Implementation of CThreadsCases		 

#include "stdafx.h"
#include "ThreadsCases.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
											   
IMPLEMENT_TEST(CThreadsCases, CDbgTestBase, "Threads", -1, CThreadsSubsuite)


// each function that runs a test has this prototype.
typedef void (CThreadsCases::*PTR_TEST_FUNC)(void); 

// we randomly pick out of the following list of tests and run them.
// insert functions for new tests to the end of the list.
PTR_TEST_FUNC tests[] = 
{
	&CThreadsCases::VerifyThreadInfoForMultipleThreads,
	&CThreadsCases::ChangeFocusToDifferentThreadAndBack,
	// emmang@xbox - never terminate main thread
	// &CThreadsCases::RunMultithreadedAppToTermination,
	&CThreadsCases::HitLocationBPInThreadSetBeforeThreadCreated,
	&CThreadsCases::HitLocationBPInThreadSetAfterThreadCreated,
	&CThreadsCases::HitGlobalDataBPInThreadSetWhileFocusedOnAnotherThread,
	&CThreadsCases::HitGlobalDataBPInThreadSetWhileFocusedOnSameThread,
	&CThreadsCases::VerifyMemoryDumpOfLocalFromSecondaryThread,
	// emmang@xbox - extra gunk on top of stack, fix
	// &CThreadsCases::NavigateStackInSecondaryThread,
	&CThreadsCases::StopDebuggingFromSecondaryThread,
	&CThreadsCases::SuspendAndResumeThread,
	&CThreadsCases::SetFocusToThreadAndStep,
	&CThreadsCases::GoWhenThreadWithFocusIsSuspended
};


void CThreadsCases::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}


void CThreadsCases::Run(void)

{
	// thread priority for Xbox
	m_iDefaultMainThreadPri = 8;
	m_iDefaultThreadPri = 8;
	
	if (!CreateXboxProjectFromSource("threads app", "src\\threads",
				"threads.cpp"))
			return;

	// all tests expect this initial state.
	InitTestState();
	// we only want to randomly run each test once.
	RandomNumberCheckList rncl(sizeof(tests) / sizeof(PTR_TEST_FUNC));
	// indexes into the test function array.
	int iTest;
	
	/*
	// randomly run each test once.
	while((iTest = rncl.GetNext()) != -1)
		(this->*(tests[iTest]))();
	*/

	for (iTest = 0; iTest < (sizeof(tests) / sizeof(PTR_TEST_FUNC)); iTest++)
		(this->*(tests[iTest]))();
}

#define XBOXBUG_XXXX
#define XBOXBUG_2470
#define XBOXBUG_2484
#define XBOXBUG_2492

void CThreadsCases::VerifyThreadInfoForMultipleThreads(void)
{
	LogTestHeader("VerifyThreadInfoForMultipleThreads");
	// breaking in main's loop should ensure that we break on source code in both threads and on all os's.
	EXPECT_TRUE(src.Find("loop inside main()"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(dbg.CurrentLineIs("loop inside main()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("main"));
	// verify primary thread info.
	CThreadInfo ThreadInfo;
	ThreadInfo.bHasFocus = TRUE;
	ThreadInfo.strID = GetThreadIDStr("dwMainThreadID");
	ThreadInfo.intSuspend = 0;
	ThreadInfo.intPriority = m_iDefaultMainThreadPri;
	ThreadInfo.strLocation = "main";
	EXPECT_TRUE(threads.VerifyThreadInfo(ThreadInfo));
	// verify secondary thread info.
	ThreadInfo.bHasFocus = FALSE;
	ThreadInfo.strID = GetThreadIDStr("dwSecondaryThreadID");
	ThreadInfo.intSuspend = 0;
	ThreadInfo.intPriority = m_iDefaultThreadPri;
	ThreadInfo.strLocation = "SecondaryThreadFunc";
#ifdef XBOXBUG_XXXX
	ThreadInfo.strLocation = "[" + ThreadInfo.strLocation + "]";
#endif
	EXPECT_TRUE(threads.VerifyThreadInfo(ThreadInfo));
	InitTestState();
}


void CThreadsCases::ChangeFocusToDifferentThreadAndBack(void)
{
	LogTestHeader("ChangeFocusToDifferentThreadAndBack");
	// TODO(michma - 2/8/98): add watch and asm verification.
	// breaking in main's loop should ensure that we break on source code in both threads and on all os's.
	EXPECT_TRUE(src.Find("loop inside main()"));
	EXPECT_TRUE(dbg.StepToCursor());
	CString strThreadID = GetThreadIDStr("dwSecondaryThreadID");
	EXPECT_TRUE(threads.SetThreadFocus(strThreadID));

	// with Xbox, we have to move down the stack
	EXPECT_TRUE(stk.NavigateStack(3));

	EXPECT_TRUE(dbg.CurrentLineIs("loop inside SecondaryThreadFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("SecondaryThreadFunc"));
	EXPECT_TRUE(locals.VerifyLocalInfo("pdata", "0x00000000", "void *", NOT_EXPANDABLE));
	EXPECT_TRUE(locals.VerifyLocalInfo("intLocalSecondaryThreadFunc", "1", "int", NOT_EXPANDABLE));
	EXPECT_TRUE(locals.LocalsCountIs(2));
	strThreadID = GetThreadIDStr("dwMainThreadID");
	EXPECT_TRUE(threads.SetThreadFocus(strThreadID));
	EXPECT_TRUE(dbg.CurrentLineIs("loop inside main()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("main"));
	/*
	EXPECT_TRUE(locals.VerifyLocalInfo("hInst", "ADDRESS", "HINSTANCE__ *", COLLAPSED));
	EXPECT_TRUE(locals.VerifyLocalInfo("hInstPrev", "0x00000000", "HINSTANCE__ *", COLLAPSED));
	EXPECT_TRUE(locals.VerifyLocalInfo("lszCmdLine", "ADDRESS \"", "char *", COLLAPSED));
	EXPECT_TRUE(locals.VerifyLocalInfo("nCmdShow", "0", "int", NOT_EXPANDABLE));
	*/
	EXPECT_TRUE(locals.VerifyLocalInfo("intLocalMain", "0", "int", NOT_EXPANDABLE));
	EXPECT_TRUE(locals.LocalsCountIs(1));
	InitTestState();
}


void CThreadsCases::RunMultithreadedAppToTermination(void)
{
	LogTestHeader("RunMultithreadedAppToTermination");
	// step passed the code that will create the secondary thread.
	EXPECT_TRUE(src.Find("line after call to CreateThread()"));
	EXPECT_TRUE(dbg.StepToCursor());
	// setting bInfiniteLoop to 0 will let the app terminate.
	EXPECT_TRUE(cxx.SetExpressionValue("bInfiniteLoop", 0));
	CString strSecondaryThreadID = GetThreadIDStr("dwSecondaryThreadID");
	CString strMainThreadID = GetThreadIDStr("dwMainThreadID");
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, WAIT_FOR_TERMINATION));
	EXPECT_TRUE(threads.VerifyThreadExitCode(strSecondaryThreadID, 1));
	EXPECT_TRUE(threads.VerifyThreadExitCode(strMainThreadID, 0));
	InitTestState();
}


void CThreadsCases::HitLocationBPInThreadSetBeforeThreadCreated(void)
{
	LogTestHeader("HitLocationBPInThreadSetBeforeThreadCreated");
	EXPECT_TRUE(src.Find("loop inside SecondaryThreadFunc()"));
	EXPECT_VALIDBP(bps.SetBreakpoint());
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("loop inside SecondaryThreadFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("SecondaryThreadFunc"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	InitTestState();
}


void CThreadsCases::HitLocationBPInThreadSetAfterThreadCreated(void)
{
	LogTestHeader("HitLocationBPInThreadSetAfterThreadCreated");
	EXPECT_TRUE(src.Find("CreateThreadFunc();"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(dbg.StepOver());
	// verify that the thread has been created before setting the breakpoint.
	CThreadInfo ThreadInfo;
	ThreadInfo.bHasFocus = FALSE;
	ThreadInfo.strID = GetThreadIDStr("dwSecondaryThreadID");
	ThreadInfo.intSuspend = 0;
	ThreadInfo.intPriority = m_iDefaultThreadPri;
	ThreadInfo.strLocation = "SecondaryThreadFunc";
#ifdef XBOXBUG_XXXX
	ThreadInfo.strLocation = "[" + ThreadInfo.strLocation + "]";
#endif
	EXPECT_TRUE(threads.VerifyThreadInfo(ThreadInfo));
	// now set the bp in the thread's func and verify that it is hit.
	EXPECT_TRUE(src.Find("loop inside SecondaryThreadFunc()"));
	EXPECT_VALIDBP(bps.SetBreakpoint());
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("loop inside SecondaryThreadFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("SecondaryThreadFunc"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	InitTestState();
}


void CThreadsCases::HitGlobalDataBPInThreadSetWhileFocusedOnAnotherThread(void)
{
	LogTestHeader("HitGlobalDataBPInThreadSetWhileFocusedOnAnotherThread");
	// remember that initially focus is on main thread (main).
	EXPECT_VALIDBP(bps.SetBreakOnExpr("intGlobal", COBP_TYPE_IF_EXP_CHANGED));
	EXPECT_TRUE(dbg.Go());
	// xbox seems to require this extra line
	dbg.SetSteppingMode(SRC);
	EXPECT_TRUE(dbg.CurrentLineIs("line after intGlobal changed."));
	EXPECT_TRUE(stk.CurrentFunctionIs("SecondaryThreadFunc"));
	EXPECT_TRUE(cxx.ExpressionValueIs("intGlobal", 1));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	InitTestState();
}


void CThreadsCases::HitGlobalDataBPInThreadSetWhileFocusedOnSameThread(void)
{
	LogTestHeader("HitGlobalDataBPInThreadSetWhileFocusedOnSameThread");
	EXPECT_TRUE(src.Find("first line of SecondaryThreadFunc()"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of SecondaryThreadFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("SecondaryThreadFunc"));
	EXPECT_VALIDBP(bps.SetBreakOnExpr("intGlobal", COBP_TYPE_IF_EXP_CHANGED));
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("line after intGlobal changed."));
	EXPECT_TRUE(stk.CurrentFunctionIs("SecondaryThreadFunc"));
	EXPECT_TRUE(cxx.ExpressionValueIs("intGlobal", 1));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	InitTestState();
}


void CThreadsCases::VerifyMemoryDumpOfLocalFromSecondaryThread(void)
{
	LogTestHeader("VerifyMemoryDumpOfLocalFromSecondaryThread");
	EXPECT_TRUE(src.Find("loop inside SecondaryThreadFunc()"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(dbg.CurrentLineIs("loop inside SecondaryThreadFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("SecondaryThreadFunc"));
	EXPECT_TRUE(mem.MemoryDataIs("intLocalSecondaryThreadFunc", 1));
	InitTestState();
}


void CThreadsCases::NavigateStackInSecondaryThread(void)
{
	LogTestHeader("NavigateStackInSecondaryThread");
	EXPECT_TRUE(src.Find("first line of FuncCalledBySecondaryThreadFunc()"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(stk.NavigateStack(1));
	EXPECT_TRUE(dbg.CurrentLineIs("line after call to FuncCalledBySecondaryThreadFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("SecondaryThreadFunc"));
	EXPECT_TRUE(locals.VerifyLocalInfo("pdata", "0x00000000", "void *", NOT_EXPANDABLE));
	EXPECT_TRUE(locals.VerifyLocalInfo("intLocalSecondaryThreadFunc", "1", "int", NOT_EXPANDABLE));
	EXPECT_TRUE(locals.LocalsCountIs(2));
	EXPECT_TRUE(stk.NavigateStack(0));
	EXPECT_TRUE(dbg.CurrentLineIs("first line of FuncCalledBySecondaryThreadFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("FuncCalledBySecondaryThreadFunc"));
	EXPECT_TRUE(locals.LocalsCountIs(0));
	InitTestState();
}


void CThreadsCases::StopDebuggingFromSecondaryThread(void)
{
	LogTestHeader("StopDebuggingFromSecondaryThread");
	EXPECT_TRUE(src.Find("first line of SecondaryThreadFunc()"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(dbg.CurrentLineIs("first line of SecondaryThreadFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("SecondaryThreadFunc"));
	// view registers and disassembly while in secondary thread (a different case in the testplan).
	EXPECT_TRUE(regs.Enable());
	EXPECT_TRUE(dam.Enable());
	EXPECT_TRUE(dbg.SetSteppingMode(SRC));
	EXPECT_TRUE(dbg.StopDebugging());
	InitTestState();
}


void CThreadsCases::SuspendAndResumeThread(void)
{
	LogTestHeader("SuspendAndResumeThread");
#ifdef XBOXBUG_2492
	EXPECT_TRUE("Skipping SuspendAndResumeThread() due to bug #2492");
#else
	// step over the function that creates the thread.
	EXPECT_TRUE(src.Find("CreateThreadFunc();"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(dbg.StepOver());
	// set the bp in the thread's func.
	EXPECT_TRUE(src.Find("loop inside SecondaryThreadFunc()"));
	EXPECT_VALIDBP(bps.SetBreakpoint());
	// suspend the thread and verify its new status.
	CString strThreadID = GetThreadIDStr("dwSecondaryThreadID");
	EXPECT_TRUE(threads.SuspendThread(strThreadID)); 
	CThreadInfo ThreadInfo;
	ThreadInfo.bHasFocus = FALSE;
	ThreadInfo.strID = strThreadID;
	ThreadInfo.intSuspend = 1;
	ThreadInfo.intPriority = m_iDefaultThreadPri;
	ThreadInfo.strLocation = "SecondaryThreadFunc";
	EXPECT_TRUE(threads.VerifyThreadInfo(ThreadInfo));
	// go and verify that the bp isn't hit (if app is still running after 5 seconds).
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, NOWAIT));
	Sleep(5000);
	EXPECT_TRUE(dbg.GetDebugState() == Debug_Run);
	// resume the thread and verify its new status.
	EXPECT_TRUE(dbg.Break());
	EXPECT_TRUE(threads.ResumeThread(strThreadID));
	ThreadInfo.intSuspend = 0;
	EXPECT_TRUE(threads.VerifyThreadInfo(ThreadInfo));
	// go and verify that the bp is hit.
	EXPECT_TRUE(dbg.Go());
	EXPECT_TRUE(dbg.CurrentLineIs("loop inside SecondaryThreadFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("SecondaryThreadFunc"));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
	InitTestState();
#endif
}


void CThreadsCases::SetFocusToThreadAndStep(void)

{
	LogTestHeader("SetFocusToThreadAndStep");
	// break in the secondary thread.
	EXPECT_TRUE(src.Find("loop inside SecondaryThreadFunc()"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(dbg.CurrentLineIs("loop inside SecondaryThreadFunc()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("SecondaryThreadFunc"));

#ifdef XBOXBUG_2484
	EXPECT_TRUE("Skipping main check due to bug #2484");
#else
	// set focus to the main thread.
	CString strThreadID = GetThreadIDStr("dwMainThreadID");
	EXPECT_TRUE(threads.SetThreadFocus(strThreadID));
	EXPECT_TRUE(stk.RunToFrame("main"));
	EXPECT_TRUE(dbg.SetSteppingMode(SRC));
	EXPECT_TRUE(dbg.CurrentLineIs("loop inside main()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("main"));
#endif

	InitTestState();
}


void CThreadsCases::GoWhenThreadWithFocusIsSuspended(void)
{
	LogTestHeader("GoWhenThreadWithFocusIsSuspended");
#ifdef XBOXBUG_2470
	EXPECT_TRUE("Can't run due to bug #2470");
#else
	EXPECT_TRUE(src.Find("loop inside SecondaryThreadFunc()"));
	EXPECT_TRUE(dbg.StepToCursor());
	CString strThreadID = GetThreadIDStr("dwSecondaryThreadID");
	EXPECT_TRUE(threads.SuspendThread(strThreadID));
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, WAIT_FOR_RUN));
	// CreateThreadFunc sleeps for 3 seconds before returning. this is to ensure that the thread gets created before 
	// that function returns. so if we want to be sure we break into main below, we need to sleep for 3 seconds
	// to ensure that CreateThreadFunc has returned.
	Sleep(3000);
	EXPECT_TRUE(dbg.Break());
	EXPECT_TRUE(dbg.CurrentLineIs("loop inside main()"));
	EXPECT_TRUE(stk.CurrentFunctionIs("main"));
	InitTestState();
#endif
}


void CThreadsCases::InitTestState(void)
{
	EXPECT_TRUE(dbg.Restart());
	// attach the COSource object to the source file that the debugger opened.
	src.AttachActive();
} 


LPCSTR CThreadsCases::GetThreadIDStr(LPCSTR szThreadIDVar)

{
	LOG->RecordInfo("GetThreadIDStr - szThreadIDVar = '%s'", szThreadIDVar);
	static char szText[12] = "";
	DWORD dwThreadID;
	
	if(!cxx.GetExpressionValue(szThreadIDVar, &dwThreadID))
	{
		LOG->RecordInfo("CThreadsCases::GetThreadIDStr - GetExpressionValue failed.");
		return (LPCSTR)szText;
	}

	sprintf(szText, "%.8x", dwThreadID);
	return (LPCSTR)szText;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\threads\ThreadsCases.h ===
///////////////////////////////////////////////////////////////////////////////
//	ThreadsCases.h
//
//	Created by:			Date:
//		MichMa				2/5/98
//
//	Description :
//		Declaration of the CThreadsCases Class
//

#ifndef __THREADSCASES_H__
#define __THREADSCASES_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\dbgtestbase.h"
#include "ThreadsSubsuite.h"


///////////////////////////////////////////////////////////////////////////////
//	CThreadsCases class

class CThreadsCases : public CDbgTestBase

{
	DECLARE_TEST(CThreadsCases, CThreadsSubsuite)

private:
	// Data
	int m_iDefaultMainThreadPri;
	int m_iDefaultThreadPri;

public:

	// Operations
	virtual void PreRun(void);
	virtual void Run(void);

	// Utils
	void InitTestState(void);
	LPCSTR GetThreadIDStr(LPCSTR szThreadIDVar);

	// Test Cases
	void VerifyThreadInfoForMultipleThreads(void);
	void ChangeFocusToDifferentThreadAndBack(void);
	void RunMultithreadedAppToTermination(void);
	void HitLocationBPInThreadSetBeforeThreadCreated(void);
	void HitLocationBPInThreadSetAfterThreadCreated(void);
	void HitGlobalDataBPInThreadSetWhileFocusedOnAnotherThread(void);
	void HitGlobalDataBPInThreadSetWhileFocusedOnSameThread(void);
	void VerifyMemoryDumpOfLocalFromSecondaryThread(void);
	void NavigateStackInSecondaryThread(void);
	void StopDebuggingFromSecondaryThread(void);
	void SuspendAndResumeThread(void);
	void SetFocusToThreadAndStep(void);
	void GoWhenThreadWithFocusIsSuspended(void);
};

#endif //__THREADSCASES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\varswnd\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\varswnd\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\tmplates\tmplcase.h ===
///////////////////////////////////////////////////////////////////////////////
//	TMPLCASE.H
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CTemplatesIDETest Class
//

#ifndef __TMPLCASE_H__
#define __TMPLCASE_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\dbgtestbase.h"
#include "tmplsub.h"

///////////////////////////////////////////////////////////////////////////////
//	CTemplatesIDETest class

class CTemplatesIDETest : public CDbgTestBase
	
	{
	DECLARE_TEST(CTemplatesIDETest, CTemplatesSubSuite)

	// Operations
	public:
		virtual void PreRun(void);
		virtual void Run(void);

	// Tests
	public:
		void StepIntoAndOutOfTemplateFunction(void);
		void StepOverTemplateFunction(void);
		void StepToCursorInTemplateFunction(void);
		void SetBreakpointOnLineInTemplateFunctionWhileDebugging(void);
		void SetBreakpointOnLineInTemplateFunctionWhileNotDebugging(void);
		void VerifyTemplateParameterOnStack(void);
		void GoToDisassemblyFromWithinTemplateFunction(void);
		void StepIntoSpecificTemplateFunction(void);

		void SetNextStatementInTemplateFunction(void);
		void StepToCursorInTemplateFunctionInStack(void);
		void EvaluateSTLObjectWithLongName(void);
		void StepToCursorInTemplateFunctionToStartDebugging(void);
		void HitBreakpointOnAmbiguousTemplateFunction(void);
		void HitBreakpointOnNonAmbiguousTemplateFunction(void);
		void DisableBreakpointInTemplateFunctionAndVerifyNotHit(void);
		void ToggleOffBreakpointInTemplateFunctionAndVerifyNotHit(void);
	};

#endif //__TMPLCASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\tmplates\tmplsub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	TMPLSUB.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CTemplatesSubSuite class
//

#include "stdafx.h"
#include "tmplsub.h"
#include "afxdllx.h"

#include "tmplcase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CTemplatesSubSuite

IMPLEMENT_SUBSUITE(CTemplatesSubSuite, CIDESubSuite, "Templates", "VCQA Debugger")

BEGIN_TESTLIST(CTemplatesSubSuite)
	TEST(CTemplatesIDETest, RUN)
END_TESTLIST()

void CTemplatesSubSuite::CleanUp(void)
	{
	::CleanUp("ee");
	}

///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\varswnd\autocase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	AUTOCASE.CPP
//											 
//	Created by :			
//		VCBU QA		
//
//	Description :								 	   
//		TestWizard Generated script.	 

#include "stdafx.h"
#include "autocase.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
										   
IMPLEMENT_TEST(CAutoPaneIDETest, CDbgTestBase, "Auto Pane", -1, CVarsWndSubSuite)
												 
void CAutoPaneIDETest::PreRun(void)
	{
	// call the base class
	CTest::PreRun();
	}


void CAutoPaneIDETest::Run(void)
	
	{
	/******************
	 * INITIALIZATION *
	 ******************/
	if(!InitProject("autopane\\autopane", PROJECT_XBE))
		{
		m_pLog->RecordInfo("ERROR: could not init autopane project");
		return;
		}

	// this is the initial state each test expects.
	//	  - step passed prolog of WinMain().
	//	  - select Auto pane in variables wnd.
	//    - restore focus to source window.
	if(!dbg.StepOver(2))
		{
		m_pLog->RecordInfo("ERROR: could not step passed WinMain()'s prolog");
		return;
		}

	uivar.Activate();

	if(!uivar.SetPane(PANE_AUTO) == ERROR_SUCCESS)
		{
		m_pLog->RecordInfo("ERROR: could not activate Auto pane");
		return;
		}

	RestoreFocusToSrcWnd();

	/*********
	 * TESTS *
	 *********/
	VerifyUpdateAfterGo();
	VerifyUpdateAfterStepInto();
	VerifyUpdateAfterStepOut();
	VerifyUpdateAfterStepOver();
//	VerifyUpdateAfterRestart();	   //bug orion #15002
	VerifyUpdateAfterBreak();
	VerifyUpdateAfterRunToCursor();
	VerifyUpdateAfterSetNextStatement();
	ChangeValueViaExecution();
//	ChangeValueViaMemWnd();
	ChangeValueViaWatchWnd();
	ChangeValueViaQuickWatchDlg();
	ChangeValueViaAutoPane();
	//VerifyFuncArgsAppearWhenPrologReached();
	//NavigateStackToParentFuncAndBack();
	//ChangeToThisPaneAndBack();
	//ChangeToLocalsPaneAndBack();
	//VerifyOnlyCurrentAndPrevStatementsAreScanned();
	//VerifyMultilineStatementsGetScannedBackTenLines();
	ScanArraySubscript();
	ScanCastsAndOpsInsideArraySubscript();
	ScanSelfSubscriptedArray();
	ScanIndirectAccessToClassVariableAndFunc();
	ScanDirectAccessToClassVariableAndFunc();
	ScanScopeOp();
	ScanAddressOfOp();
	//ScanPointerToMember();
	//VerifyRegistersNotAddedInMixedMode();
	//VerifyNamesCantBeManuallyDeletedAddedOrEdited();
	//VerifyConstantExpressionsNotAdded();
	//VerifyFuncCallsNotAdded();
	//VerifyUnsupportedOpsNotAdded();
	StepIntoContextOfNoExpressions();
	VerifyExpressionsInCommentsNotAdded();
	VerifyDupExpressionsNotAdded();
	//VerifyExpressionsWithErrorValsNotAdded();

	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_SUCCESS(prj.Attach());
	EXPECT_SUCCESS(prj.Close());
	} 


/*******************************************
 * verify variables list updated after go. *
 *******************************************/
void CAutoPaneIDETest::VerifyUpdateAfterGo(void)
	{
	LogTestHeader("VerifyUpdateAfterGo");
	EXPECT_TRUE(dbg.Restart());
//	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE(src.Find("*pi = 1;"));
	EXPECT_TRUE(bps.SetBreakpoint());
	EXPECT_TRUE(dbg.Go());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "i", "0");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "int", "*pi", "0");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));
	bps.ClearAllBreakpoints();
	RestoreFocusToSrcWnd();
	}


/**************************************************
 * verify variables list updated after step into. *
 **************************************************/
void CAutoPaneIDETest::VerifyUpdateAfterStepInto(void)
	{
	LogTestHeader("VerifyUpdateAfterStepInto");
	EXPECT_TRUE(src.Find("i = 0;"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepInto());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "i", "0");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "int", "*pi", "0");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));
	RestoreFocusToSrcWnd();
	}


/*************************************************
 * verify variables list updated after step out. *
 *************************************************/
void CAutoPaneIDETest::VerifyUpdateAfterStepOut(void)
	{
	LogTestHeader("VerifyUpdateAfterStepOut");
	EXPECT_TRUE(src.Find("b.func(0);"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepInto());
	EXPECT_TRUE(dbg.StepOut());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], COLLAPSED, "base", "b", "{...}");
	//FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "void", "base::func returned", "<void>");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}


/**************************************************
 * verify variables list updated after step over. *
 **************************************************/
void CAutoPaneIDETest::VerifyUpdateAfterStepOver(void)
	{
	LogTestHeader("VerifyUpdateAfterStepOver");
	EXPECT_TRUE(src.Find("i = 0;"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "i", "0");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "int", "*pi", "0");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));
	RestoreFocusToSrcWnd();
	}


/************************************************
 * verify variables list updated after restart. *
 ************************************************/
void CAutoPaneIDETest::VerifyUpdateAfterRestart(void)
	{
	LogTestHeader("VerifyUpdateAfterRestart");
	EXPECT_TRUE(dbg.Restart());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], COLLAPSED, "void *", "hinst", "ADDRESS");
	FillExprInfo(expr_info_expected[1], COLLAPSED, "void *", "hinstPrev", "ADDRESS");
	FillExprInfo(expr_info_expected[2], COLLAPSED, "char *", "lszCmdLine", "ADDRESS");
	FillExprInfo(expr_info_expected[3], NOT_EXPANDABLE, "int", "nCmdShow", "1");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 4));
	// restore execution to initial state (anywhere after WinMain's prolog).
	EXPECT_TRUE(dbg.StepOver());
	RestoreFocusToSrcWnd();
	}


/**********************************************
 * verify variables list updated after break. *
 **********************************************/
void CAutoPaneIDETest::VerifyUpdateAfterBreak(void)
	{
	LogTestHeader("VerifyUpdateAfterBreak");
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(dbg.Go(NULL, 0, NULL, WAIT_FOR_RUN));
	// wait until infinite loop (while(1);) is executed.
	Sleep(10000);
	EXPECT_TRUE(dbg.Break());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "i", "1");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}


/******************************************************
 * verify variables list updated after run to cursor. *
 ******************************************************/
void CAutoPaneIDETest::VerifyUpdateAfterRunToCursor(void)
	{
	LogTestHeader("VerifyUpdateAfterRunToCursor");
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("*pi = 1;"));
	EXPECT_TRUE(dbg.StepToCursor());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "i", "0");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "int", "*pi", "0");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));
	RestoreFocusToSrcWnd();
	}


/************************************************************
 * verify variables list updated after setd next statement. *
 ************************************************************/
void CAutoPaneIDETest::VerifyUpdateAfterSetNextStatement(void)
	{
	LogTestHeader("VerifyUpdateAfterSetNextStatement");
	EXPECT_TRUE(src.Find("i = 0;"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(src.Find("*pi = 1;"));
	EXPECT_TRUE(dbg.SetNextStatement());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "i", "0");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "int", "*pi", "0");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));
	RestoreFocusToSrcWnd();
	}


/****************************************************************
 * verify auto pane updated when variable changes via execution	*
 ****************************************************************/
void CAutoPaneIDETest::ChangeValueViaExecution(void)
	{
	LogTestHeader("ChangeValueViaExecution");
	EXPECT_TRUE(src.Find("int i2 = 0;"));
	EXPECT_TRUE(dbg.SetNextStatement());
	// step over "int i2 = 0;" and "i2 = 1;".
	EXPECT_TRUE(dbg.StepOver(2));
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "i2", "1");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}

/*********************************************************************
 * verify auto pane updated when variable changes via memory window. *
 *********************************************************************/
void CAutoPaneIDETest::ChangeValueViaMemWnd(void)
	{
	LogTestHeader("ChangeValueViaMemWnd");
	EXPECT_TRUE(src.Find("int i2 = 0;"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(mem.SetMemoryData("i2", 1));
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "i2", "1");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}


/********************************************************************
 * verify auto pane updated when variable changes via watch window.	*
 ********************************************************************/
void CAutoPaneIDETest::ChangeValueViaWatchWnd(void)
	{
	LogTestHeader("ChangeValueViaWatchWnd");
	EXPECT_TRUE(src.Find("int i2 = 0;"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uiwatch.Activate();
	EXPECT_SUCCESS(uiwatch.SetName("i2", 1));
	EXPECT_SUCCESS(uiwatch.SetValue("1", 1));
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "i2", "1");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	uiwatch.Activate();
	uiwatch.Delete(1);
	RestoreFocusToSrcWnd();
	}


/************************************************************************
 * verify auto pane updated when variable changes via quickwatch dlg.	*
 ************************************************************************/
void CAutoPaneIDETest::ChangeValueViaQuickWatchDlg(void)
	{
	LogTestHeader("ChangeValueViaQuickWatchDlg");
	EXPECT_TRUE(src.Find("int i2 = 0;"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	EXPECT_TRUE(uiqw.Activate());
	EXPECT_TRUE(uiqw.SetExpression("i2"));
	EXPECT_TRUE(uiqw.Recalc());
	EXPECT_TRUE(uiqw.SetNewValue("1"));
	EXPECT_TRUE(uiqw.Close() == NULL);
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "i2", "1");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}


/******************************************************************************************
 * verify auto pane updated when variable changes via auto pane (ie. two different rows). *
 ******************************************************************************************/
void CAutoPaneIDETest::ChangeValueViaAutoPane(void)
	{
	LogTestHeader("ChangeValueViaAutoPane");
	EXPECT_TRUE(src.Find("i = 0;"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.SetValue("1", 1));
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "i", "1");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "int", "*pi", "1");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));
	RestoreFocusToSrcWnd();
	}


/**************************************************************
 * verify that function arguments appear when prolog reached. *
 **************************************************************/
void CAutoPaneIDETest::VerifyFuncArgsAppearWhenPrologReached(void)
	{
	}


/****************************************************
 * navigate the stack to another function and back.	*
 ****************************************************/
void CAutoPaneIDETest::NavigateStackToParentFuncAndBack(void)
	{
	}


/********************************************
 * change panes from auto to this and back.	*
 ********************************************/
void CAutoPaneIDETest::ChangeToThisPaneAndBack(void)
	{
	}


/**********************************************
 * change panes from auto to locals and back. *
 **********************************************/
void CAutoPaneIDETest::ChangeToLocalsPaneAndBack(void)
	{
	}


/*****************************************************************************************
 * verify that only expressions from current statement and previous statement are added. *
 *****************************************************************************************/
void CAutoPaneIDETest::VerifyOnlyCurrentAndPrevStatementsAreScanned(void)
	{
	}


/****************************************************************
 * verify that multi-line statements get scanned back 10 lines.	*
 ****************************************************************/
void CAutoPaneIDETest::VerifyMultilineStatementsGetScannedBackTenLines(void)
	{
	}


/******************************************************************************************
 * step into context of "array[i]".  only "array[i]" should show up, not "array" nor "i". *
 ******************************************************************************************/
void CAutoPaneIDETest::ScanArraySubscript(void)
	{
	LogTestHeader("ScanArraySubscript");
	EXPECT_TRUE(src.Find("array[0] = 'x';"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "char", "array[0]", "120 'x'");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}


/***********************************************************************************
 * step into context of "array[i + (int)*pchar]", entire expression should show    *
 * up even though casts and arithmetic operators are unsupported outside brackets. *	
 ***********************************************************************************/
void CAutoPaneIDETest::ScanCastsAndOpsInsideArraySubscript(void)
	{
	LogTestHeader("ScanCastsAndOpsInsideArraySubscript");
	EXPECT_TRUE(src.Find("array[(5 + 15) / 10 * 2 - (4 + (int)'\x00')] = '1';"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "char", "array[(5+15)/10*2-(4+(int)'\\x00')]", "49 '1'");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}


/*******************************************
 * step into context of "array[array[i]]". *
 *******************************************/
void CAutoPaneIDETest::ScanSelfSubscriptedArray(void)
	{
	LogTestHeader("ScanSelfSubscriptedArray");
	EXPECT_TRUE(src.Find("array[array[4]] = 'a';"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "char", "array[4]", "UNKNOWN");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "char", "array[array[4]]", "97 'a'");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));
	RestoreFocusToSrcWnd();
	}


/*******************************************************************************
 * step into context of indirect access to class member variable and function. *
 *******************************************************************************/
void CAutoPaneIDETest::ScanIndirectAccessToClassVariableAndFunc(void)
	{
	LogTestHeader("ScanIndirectAccessToClassVariableAndFunc");
	EXPECT_TRUE(src.Find("pb->m_public = 0;"));
	EXPECT_TRUE(dbg.StepToCursor());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], COLLAPSED, "base *", "pb", "ADDRESS");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "int", "pb->m_public", "0");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));
	RestoreFocusToSrcWnd();
	}


/*****************************************************************************
 * step into context of direct access to class member variable and function. *
 *****************************************************************************/
void CAutoPaneIDETest::ScanDirectAccessToClassVariableAndFunc(void)
	{
	LogTestHeader("ScanDirectAccessToClassVariableAndFunc");
	EXPECT_TRUE(src.Find("b.m_public = 1;"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], COLLAPSED, "base", "b", "{...}");
	FillExprInfo(expr_info_expected[1], NOT_EXPANDABLE, "int", "b.m_public", "1");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));
	RestoreFocusToSrcWnd();
	}


/*************************************
 * step into context of :: operator. *
 *************************************/
void CAutoPaneIDETest::ScanScopeOp(void)
	{
	LogTestHeader("ScanScopeOp");
	EXPECT_TRUE(src.Find("::global = 1;"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "::global", "1");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}


/*************************************************
 * step into context of address-of (&) operator. *
 *************************************************/
void CAutoPaneIDETest::ScanAddressOfOp(void)
	{
	LogTestHeader("ScanAddressOfOp");
	EXPECT_TRUE(src.Find("int *pint = &i;"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], COLLAPSED, "int *", "&i", "ADDRESS");
	FillExprInfo(expr_info_expected[1], COLLAPSED, "int *", "pint", "ADDRESS");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 2));
	RestoreFocusToSrcWnd();
	}


/*******************************************
 * step into context of pointer to member. *
 *******************************************/
void CAutoPaneIDETest::ScanPointerToMember(void)
	{
	}


/*************************************************
 * step in mixed mode - registers not supported. *
 *************************************************/
void CAutoPaneIDETest::VerifyRegistersNotAddedInMixedMode(void)
	{
	}


/********************************************************************
 * verify that expression names cant be deleted, added, or edited.	*
 ********************************************************************/
void CAutoPaneIDETest::VerifyNamesCantBeManuallyDeletedAddedOrEdited(void)
	{
	}


/**************************************************
 * verify that no constant expressions are added. *
 **************************************************/
void CAutoPaneIDETest::VerifyConstantExpressionsNotAdded(void)
	{
	}


/********************************************
 * verify that function calls arent added.	*
 ********************************************/
void CAutoPaneIDETest::VerifyFuncCallsNotAdded(void)
	{
	}


/****************************************************************************
 * verify that the unsupported operators are not included 				    *
 * (arithmetic, casts, logical, bitwise, increment, decrement, relational).	*
 ****************************************************************************/
void CAutoPaneIDETest::VerifyUnsupportedOpsNotAdded(void)
	{
	}


/****************************************
 * step into context of no expressions.	*
 ****************************************/
void CAutoPaneIDETest::StepIntoContextOfNoExpressions(void)
	{
	LogTestHeader("StepIntoContextOfNoExpressions");
	EXPECT_TRUE(src.Find("while(0); // no expressions"));
	EXPECT_TRUE(dbg.SetNextStatement());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "", "", "");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}


/*****************************************************
 * verify that no expressions in comments are added. *
 *****************************************************/
void CAutoPaneIDETest::VerifyExpressionsInCommentsNotAdded(void)
	{
	LogTestHeader("VerifyExpressionsInCommentsNotAdded");
	EXPECT_TRUE(src.Find("int before_comments = 0;"));
	EXPECT_TRUE(dbg.SetNextStatement());
	// next few lines are commented symbols, then more code.
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "before_comments", "0");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}


/****************************************************
 * verify that duplicate expressions are not added. *
 ****************************************************/
void CAutoPaneIDETest::VerifyDupExpressionsNotAdded(void)
	{
	LogTestHeader("VerifyDupExpressionsNotAdded");
	EXPECT_TRUE(src.Find("int before_comments = 0;"));
	EXPECT_TRUE(dbg.SetNextStatement());
	// next few lines are commented symbols, then more code.
	EXPECT_TRUE(dbg.StepOver());
	uivar.Activate();
	EXPECT_SUCCESS(uivar.GetAllFields(expr_info_actual, 1, ROW_ALL));
	FillExprInfo(expr_info_expected[0], NOT_EXPANDABLE, "int", "before_comments", "0");
	EXPECT_TRUE(ExprInfoIs(expr_info_actual, expr_info_expected, 1));
	RestoreFocusToSrcWnd();
	}


/***********************************************************
 * verify that no expressions with error values are added. *
 ***********************************************************/
void CAutoPaneIDETest::VerifyExpressionsWithErrorValsNotAdded(void)
	{
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\varswnd\thiscase.h ===
///////////////////////////////////////////////////////////////////////////////
//	THISCASE.H
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CThisPaneIDETest Class
//

#ifndef __THISCASE_H__
#define __THISCASE_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

//#include "..\dbgset.h"
#include "..\..\DbgTestBase.h"
#include "varssub.h"

///////////////////////////////////////////////////////////////////////////////
//	CThisPaneIDETest class

class CThisPaneIDETest : public CDbgTestBase
{
	DECLARE_TEST(CThisPaneIDETest, CVarsWndSubSuite)

	// Operations
	public:
		virtual void PreRun(void);
		virtual void Run(void);

	// Test cases
	private:

	// Data
	private:
		EXPR_INFO expr_info_actual[8], expr_info_expected[8];
	};

#endif //__THISCASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\varswnd\autocase.h ===
///////////////////////////////////////////////////////////////////////////////
//	AUTOCASE.H
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CAutoPaneIDETest Class
//

#ifndef __AUTOCASE_H__
#define __AUTOCASE_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

//#include "..\dbgset.h"
#include "..\..\DbgTestBase.h"
#include "varssub.h"

///////////////////////////////////////////////////////////////////////////////
//	CNameSpceIDETest class

class CAutoPaneIDETest : public CDbgTestBase
{
	DECLARE_TEST(CAutoPaneIDETest, CVarsWndSubSuite)

	// Operations
	public:
		virtual void PreRun(void);
		virtual void Run(void);

	// Test cases
	private:
		void VerifyUpdateAfterGo(void);
		void VerifyUpdateAfterStepInto(void);
		void VerifyUpdateAfterStepOut(void);
		void VerifyUpdateAfterStepOver(void);
		void VerifyUpdateAfterRestart(void);
		void VerifyUpdateAfterBreak(void);
		void VerifyUpdateAfterRunToCursor(void);
		void VerifyUpdateAfterSetNextStatement(void);
		void ChangeValueViaExecution(void);
		void ChangeValueViaMemWnd(void);
		void ChangeValueViaWatchWnd(void);
		void ChangeValueViaQuickWatchDlg(void);
		void ChangeValueViaAutoPane(void);
		void VerifyFuncArgsAppearWhenPrologReached(void);
		void NavigateStackToParentFuncAndBack(void);
		void ChangeToThisPaneAndBack(void);
		void ChangeToLocalsPaneAndBack(void);
		void VerifyOnlyCurrentAndPrevStatementsAreScanned(void);
		void VerifyMultilineStatementsGetScannedBackTenLines(void);
		void ScanArraySubscript(void);
		void ScanCastsAndOpsInsideArraySubscript(void);
		void ScanSelfSubscriptedArray(void);
		void ScanIndirectAccessToClassVariableAndFunc(void);
		void ScanDirectAccessToClassVariableAndFunc(void);
		void ScanScopeOp(void);
		void ScanAddressOfOp(void);
		void ScanPointerToMember(void);
		void VerifyRegistersNotAddedInMixedMode(void);
		void VerifyNamesCantBeManuallyDeletedAddedOrEdited(void);
		void VerifyConstantExpressionsNotAdded(void);
		void VerifyFuncCallsNotAdded(void);
		void VerifyUnsupportedOpsNotAdded(void);
		void StepIntoContextOfNoExpressions(void);
		void VerifyExpressionsInCommentsNotAdded(void);
		void VerifyDupExpressionsNotAdded(void);
		void VerifyExpressionsWithErrorValsNotAdded(void);

	// Data
	private:
		EXPR_INFO expr_info_actual[8], expr_info_expected[8];
	};

#endif //__AUTOCASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\varswnd\loccase.h ===
///////////////////////////////////////////////////////////////////////////////
//	LOCCASE.H
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CLocalsCases Class
//

#ifndef __LOCCASE_H__
#define __LOCCASE_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\DbgTestBase.h"
#include "varssub.h"

///////////////////////////////////////////////////////////////////////////////
//	CLocalsCases class

class CLocalsCases : public CDbgTestBase
{
	DECLARE_TEST(CLocalsCases, CVarsWndSubSuite)

	// Operations
	public:
		virtual void PreRun(void);
		virtual void Run(void);

	// Test cases
	public:
		void VerifyLocPaneWhenVariablesChangeViaExec(void);
		void VerifyLocPaneWhenVariablesChangeViaMemoryWindow(void);
		void VerifyLocPaneWhenVariablesChangeViaWatchWindow(void);
		void VerifyLocPaneWhenVariablesChangeViaLocalsWindow(void);
		void VerifyLocPaneWhenVariablesChangeViaQuickWatchWindow(void);
		void VerifyThatFunctionArgumentsAppearWhenPrologReached(void);
		void VerifyThatLocalsAppearAfterExecutingProlog(void);
		void NavigateStackToParentFunctionAndBack(void);
		void CheckLocalsWhenSwitchToThisAutoAndBack(void);
		void VerifyThatLocalsUpdatesViaRegisterWindow(void);
		void StepThroughFunctionWithNoArguments(void);
		void StepThroughPrologWithThisPaneActive(void);

	// Data
	private:
		EXPR_INFO expr_info_actual[8], expr_info_expected[8];
		int m_TestNumber;
		int m_TotalNumberOfTests;
		CString m_strLogInfo;
	};

#endif //__LOCCASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\varswnd\loccase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	LOCCASE.CPP
//											 
//	Created by :			
//		VCBU QA		
//
//	Description :								 
//		TestWizard Generated script.	 

#include "stdafx.h"
#include "loccase.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
										   
IMPLEMENT_TEST(/*999,*/ CLocalsCases, CDbgTestBase, "Locals", -1, CVarsWndSubSuite)


// each function that runs a test has this prototype.
typedef void (CLocalsCases::*PTR_TEST_FUNC)(void); 

// Information about a test to be put in the test header
#define LOGTESTHEADER(strTestName) 	m_strLogInfo.Format("# - %d.  %s. Total # - %d, Passed - %d %%", ++m_TestNumber, strTestName, m_TotalNumberOfTests, (m_TestNumber*100)/m_TotalNumberOfTests);  \
									LogTestHeader(m_strLogInfo);


// we randomly pick out of the following list of tests and run them.
// insert functions for new tests to the end of the list.

PTR_TEST_FUNC tests[] = {
	&CLocalsCases::NavigateStackToParentFunctionAndBack,
	&CLocalsCases::VerifyThatLocalsUpdatesViaRegisterWindow,				
	&CLocalsCases::VerifyLocPaneWhenVariablesChangeViaExec,
//TODO dklem (07/29/980 make this test available when bug #5190 is fixed
	&CLocalsCases::VerifyLocPaneWhenVariablesChangeViaMemoryWindow,
	&CLocalsCases::VerifyLocPaneWhenVariablesChangeViaWatchWindow,
	&CLocalsCases::VerifyLocPaneWhenVariablesChangeViaLocalsWindow,
	&CLocalsCases::VerifyLocPaneWhenVariablesChangeViaQuickWatchWindow,
	&CLocalsCases::VerifyThatFunctionArgumentsAppearWhenPrologReached,	
	&CLocalsCases::VerifyThatLocalsAppearAfterExecutingProlog,			
	&CLocalsCases::CheckLocalsWhenSwitchToThisAutoAndBack,
	&CLocalsCases::StepThroughFunctionWithNoArguments,					
	&CLocalsCases::StepThroughPrologWithThisPaneActive,					

};

void CLocalsCases::PreRun(void)
	{
	// call the base class
	CTest::PreRun();
	}


void CLocalsCases::Run(void)
	
	{
	/******************
	 * INITIALIZATION *
	 ******************/

	if (!CreateXboxProjectFromSource("Locals Application", "src\\locpane",
			"Locals Application.cpp"))
		return;

	// all tests expect the ide to be in this initial state.
	EXPECT_TRUE(dbg.StepOver());

	m_TestNumber = 0;
	m_TotalNumberOfTests = sizeof(tests) / sizeof(PTR_TEST_FUNC);
	
	// we only want to randomly run each test once.
	RandomNumberCheckList rncl(sizeof(tests) / sizeof(PTR_TEST_FUNC));
	// indexes into the test function array.
	int iTest;
	
	if(CMDLINE->GetBooleanValue("random", TRUE))
	{
		// randomly run each test once.
		while((iTest = rncl.GetNext()) != -1)
			(this->*(tests[iTest]))();
	}
	else
	{
		// run each test in sequence.
		for(iTest = 0; iTest < sizeof(tests) / sizeof(PTR_TEST_FUNC); iTest++)
			(this->*(tests[iTest]))();
	}

	dbg.StopDebugging(ASSUME_NORMAL_TERMINATION) ;
} 

	/*********
	 * TESTS *
	 *********/

void CLocalsCases::VerifyLocPaneWhenVariablesChangeViaExec(void)
{
	LOGTESTHEADER("VerifyLocPaneWhenVariablesChangeViaExec");
	
	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());
	LogTestHeader("Check that initial values are correct");
	EXPECT_TRUE(locals.VerifyLocalInfo("nJustInt", "1965", "int", NOT_EXPANDABLE));
	EXPECT_TRUE(locals.VerifyLocalInfo("chJustChar", "97 'a'", "char", NOT_EXPANDABLE));

	// Now do 2 steps over and begin test 
	EXPECT_TRUE(dbg.StepOver(2));
	// Check that initial values change via execution
	EXPECT_TRUE(locals.VerifyLocalInfo("nJustInt", "1966", "int", NOT_EXPANDABLE));
	EXPECT_TRUE(locals.VerifyLocalInfo("chJustChar", "98 'b'", "char", NOT_EXPANDABLE));
}


void CLocalsCases::VerifyLocPaneWhenVariablesChangeViaMemoryWindow(void)
{
	LOGTESTHEADER("VerifyLocPaneWhenVariablesChangeViaMemoryWindow");
	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	// Open Memory window
	EXPECT_TRUE(mem.Enable());
	EXPECT_TRUE(mem.SetMemoryData("chJustChar", 'e', MEM_FORMAT_ASCII));
	EXPECT_TRUE(locals.VerifyLocalInfo("chJustChar", "101 'e'", "char", NOT_EXPANDABLE));
	EXPECT_TRUE(mem.Disable());
}

void CLocalsCases::VerifyLocPaneWhenVariablesChangeViaWatchWindow(void)
{
	LOGTESTHEADER("VerifyLocPaneWhenVariablesChangeViaWatchWindow");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	//Change Watch Window
	EXPECT_TRUE(watch.AddWatch("nJustInt"));
	EXPECT_TRUE(watch.SetWatchValue("nJustInt", "1993"));
	EXPECT_TRUE(locals.VerifyLocalInfo("nJustInt", "1993", "int", NOT_EXPANDABLE));
}

void CLocalsCases::VerifyLocPaneWhenVariablesChangeViaLocalsWindow(void)
{
	LOGTESTHEADER("VerifyLocPaneWhenVariablesChangeViaLocalsWindow");
	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	//Change Locals Window
	EXPECT_TRUE(locals.SetLocalValue("nJustInt", "1974"));
	EXPECT_TRUE(locals.VerifyLocalInfo("nJustIntRef", "1974", "int &", NOT_EXPANDABLE));
}

void CLocalsCases::VerifyLocPaneWhenVariablesChangeViaQuickWatchWindow(void)
{

	LOGTESTHEADER("VerifyLocPaneWhenVariablesChangeViaQuickWatchWindow");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* First line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	//Change Quick Watch Window
	EXPECT_TRUE(uiqw.Activate());
	EXPECT_TRUE(uiqw.SetExpression("dJustDouble"));
	EXPECT_TRUE(uiqw.Recalc());
	EXPECT_TRUE(uiqw.SetNewValue("3.141592"));
	EXPECT_TRUE(uiqw.Recalc());
	EXPECT_TRUE(NULL ==uiqw.Close());
	EXPECT_TRUE(locals.VerifyLocalInfo("dJustDouble", "3.1415920000000", "double", NOT_EXPANDABLE));
	

}

void CLocalsCases::VerifyThatFunctionArgumentsAppearWhenPrologReached(void)
{
	LOGTESTHEADER("VerifyThatFunctionArgumentsAppearWhenPrologReached");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* Second line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	//Step into function
	EXPECT_TRUE(dbg.StepInto(1));
	EXPECT_TRUE(locals.LocalsCountIs(1));
	EXPECT_TRUE(locals.VerifyLocalInfo("chArg", "98 'b'", "char", NOT_EXPANDABLE));
}

void CLocalsCases::VerifyThatLocalsAppearAfterExecutingProlog(void)
{

	LOGTESTHEADER("VerifyThatLocalsAppearAfterExecutingProlog");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* Second line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	//Step into function and execute prolog
	EXPECT_TRUE(dbg.StepInto(2));
	EXPECT_TRUE(locals.LocalsCountIs(3));
	EXPECT_TRUE(locals.VerifyLocalInfo("chArg", "98 'b'", "char", NOT_EXPANDABLE));
	EXPECT_TRUE(locals.VerifyLocalInfo("nJustLocalInt", "UNKNOWN", "int", NOT_EXPANDABLE));
	EXPECT_TRUE(locals.VerifyLocalInfo("dJustLocalDouble", "UNKNOWN", "double", NOT_EXPANDABLE));
}


void CLocalsCases::NavigateStackToParentFunctionAndBack(void)
{

	LOGTESTHEADER("NavigateStackToParentFunctionAndBack");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* Second line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	//Step into function and execute prolog
	EXPECT_TRUE(dbg.StepInto(2));
	EXPECT_TRUE(stk.NavigateStack("WinMain"));
	EXPECT_TRUE(locals.LocalsCountIs(8));
	EXPECT_TRUE(locals.VerifyLocalInfo("hInstance", "UNKNOWN", "HINSTANCE__ *", COLLAPSED));
	EXPECT_TRUE(locals.VerifyLocalInfo("hPrevInstance", "UNKNOWN", "HINSTANCE__ *", COLLAPSED));
	EXPECT_TRUE(locals.VerifyLocalInfo("lpCmdLine", "UNKNOWN", "char *", COLLAPSED));
	EXPECT_TRUE(locals.VerifyLocalInfo("nCmdShow", "1", "int", NOT_EXPANDABLE));
	EXPECT_TRUE(locals.VerifyLocalInfo("dJustDouble", "2.9200000000000", "double", NOT_EXPANDABLE));
	EXPECT_TRUE(locals.VerifyLocalInfo("chJustChar", "98 'b'", "char", NOT_EXPANDABLE));
	EXPECT_TRUE(locals.VerifyLocalInfo("nJustIntRef", "1966", "int &", NOT_EXPANDABLE));
	EXPECT_TRUE(locals.VerifyLocalInfo("nJustInt", "1966", "int", NOT_EXPANDABLE));

	EXPECT_TRUE(stk.NavigateStack("FuncWithArg"));
	EXPECT_TRUE(locals.LocalsCountIs(3));
	EXPECT_TRUE(locals.VerifyLocalInfo("chArg", "98 'b'", "char", NOT_EXPANDABLE));
	EXPECT_TRUE(locals.VerifyLocalInfo("nJustLocalInt", "UNKNOWN", "int", NOT_EXPANDABLE));
	EXPECT_TRUE(locals.VerifyLocalInfo("dJustLocalDouble", "UNKNOWN", "double", NOT_EXPANDABLE));

}

void CLocalsCases::CheckLocalsWhenSwitchToThisAutoAndBack(void)
{
	
	LOGTESTHEADER("CheckLocalsWhenSwitchToThisAutoAndBack");	

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* Second line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	//Step into function and execute prolog
	EXPECT_TRUE(dbg.StepInto(2));
	uivar.Activate();
	EXPECT_TRUE(ERROR_SUCCESS == uivar.SetPane(PANE_THIS)); 
	Sleep(500);
	EXPECT_TRUE(ERROR_SUCCESS == uivar.SetPane(PANE_LOCALS));
	EXPECT_TRUE(locals.LocalsCountIs(3));
	EXPECT_TRUE(locals.VerifyLocalInfo("chArg", "98 'b'", "char", NOT_EXPANDABLE));
	EXPECT_TRUE(locals.VerifyLocalInfo("nJustLocalInt", "UNKNOWN", "int", NOT_EXPANDABLE));
	EXPECT_TRUE(locals.VerifyLocalInfo("dJustLocalDouble", "UNKNOWN", "double", NOT_EXPANDABLE));

//TODO dklem (07/29/980 make this test available when Atuto pan is available
	uivar.Activate();
	EXPECT_TRUE(ERROR_SUCCESS == uivar.SetPane(PANE_AUTO));
	Sleep(500);
	EXPECT_TRUE(ERROR_SUCCESS == uivar.SetPane(PANE_LOCALS));
	EXPECT_TRUE(locals.LocalsCountIs(3));
	EXPECT_TRUE(!locals.LocalDoesNotExist("chArg"));
	EXPECT_TRUE(!locals.LocalDoesNotExist("nJustLocalInt"));
	EXPECT_TRUE(!locals.LocalDoesNotExist("dJustLocalDouble"));


}

void CLocalsCases::VerifyThatLocalsUpdatesViaRegisterWindow(void)
{

	LOGTESTHEADER("VerifyThatLocalsUpdatesViaRegisterWindow");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* Last FuncWithArg line */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	//Step into function and return
	EXPECT_TRUE(dbg.StepInto(1));
	EXPECT_TRUE(regs.Enable());
	EXPECT_TRUE(regs.SetRegister(EAX, "00000079"));
	EXPECT_TRUE(dbg.StepInto(1));
	EXPECT_TRUE(locals.VerifyLocalInfo("chJustChar", "121 'y'", "char", NOT_EXPANDABLE));
}


void CLocalsCases::StepThroughFunctionWithNoArguments(void)
{
	LOGTESTHEADER("StepThroughFunctionWithNoArguments");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* Third line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	EXPECT_TRUE(dbg.StepInto(1));
	EXPECT_TRUE(locals.LocalsCountIs(0));
	EXPECT_TRUE(dbg.StepInto(1));
	EXPECT_TRUE(locals.LocalsCountIs(0));

}

void CLocalsCases::StepThroughPrologWithThisPaneActive(void)
{
	LOGTESTHEADER("StepThroughPrologWithThisPaneActive");

	// Restart and Go to the line at which we want to begin our tests
	EXPECT_TRUE(dbg.Restart());
	EXPECT_TRUE(src.Find("/* Second line for tests */", FALSE, FALSE, FALSE, 0 /*FD_DOWN*/)); 
	EXPECT_TRUE(dbg.StepToCursor());

	uivar.Activate();
	EXPECT_TRUE(ERROR_SUCCESS == uivar.SetPane(PANE_THIS)); 
	EXPECT_TRUE(dbg.StepInto(2));
	EXPECT_TRUE(locals.LocalsCountIs(3));
	EXPECT_TRUE(locals.VerifyLocalInfo("chArg", "98 'b'", "char", NOT_EXPANDABLE));
	EXPECT_TRUE(locals.VerifyLocalInfo("nJustLocalInt", "UNKNOWN", "int", NOT_EXPANDABLE));
	EXPECT_TRUE(locals.VerifyLocalInfo("dJustLocalDouble", "UNKNOWN", "double", NOT_EXPANDABLE));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\varswnd\thiscase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	THISCASE.CPP
//											 
//	Created by :			
//		VCBU QA		
//
//	Description :								 
//		TestWizard Generated script.	 

#include "stdafx.h"
#include "thiscase.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
										   
IMPLEMENT_TEST(CThisPaneIDETest, CDbgTestBase, "This Pane", -1, CVarsWndSubSuite)

												 
void CThisPaneIDETest::PreRun(void)
	{
	// call the base class
	CTest::PreRun();
	}


void CThisPaneIDETest::Run(void)
	
	{
	/******************
	 * INITIALIZATION *
	 ******************/
	if(!InitProject("thispane\\thispane", PROJECT_XBE))
		{
		m_pLog->RecordInfo("ERROR: could not init thispane project");
		return;
		}

	// step passed prolog of WinMain().
	// this is the initial state each test expects.
	if(!dbg.StepOver(2))
		{
		m_pLog->RecordInfo("ERROR: could not step passed WinMain()'s prolog");
		return;
		}

	/*********
	 * TESTS *
	 *********/
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\tmplates\tmplcase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	TMPLCASE.CPP
//											 
//	Created by :			
//		VCBU QA		
//
//	Description :								 
//		Implementation of the CTemplatesIDETest Class

#include "stdafx.h"
#include "tmplcase.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
IMPLEMENT_TEST(CTemplatesIDETest, CDbgTestBase, "Templates", -1, CTemplatesSubSuite)
									   
												 
void CTemplatesIDETest::PreRun(void)
{
	// call the base class
	CTest::PreRun();
}


void CTemplatesIDETest::Run(void)
	
{
	/******************
	 * INITIALIZATION *
	 ******************/

	if(!InitProject("tmplates\\tmplates", PROJECT_XBE))
	{
		m_pLog->RecordInfo("ERROR: could not init tmplates project");
		return;
	}

	EXPECT_TRUE(dbg.StepInto(2));

	/*********
	 * TESTS *
	 *********/
	StepIntoAndOutOfTemplateFunction();
	StepOverTemplateFunction();
	StepToCursorInTemplateFunction();
	SetBreakpointOnLineInTemplateFunctionWhileDebugging();
	SetBreakpointOnLineInTemplateFunctionWhileNotDebugging();
	VerifyTemplateParameterOnStack();
	GoToDisassemblyFromWithinTemplateFunction();
	StepIntoSpecificTemplateFunction();
	SetNextStatementInTemplateFunction();
	StepToCursorInTemplateFunctionInStack();
	StepToCursorInTemplateFunctionToStartDebugging();	
	HitBreakpointOnNonAmbiguousTemplateFunction();
	HitBreakpointOnAmbiguousTemplateFunction();
	DisableBreakpointInTemplateFunctionAndVerifyNotHit();
	ToggleOffBreakpointInTemplateFunctionAndVerifyNotHit();
	EvaluateSTLObjectWithLongName();
//end of tests
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, ASSUME_NORMAL_TERMINATION));
}


void CTemplatesIDETest::StepIntoAndOutOfTemplateFunction(void)
{
	
	LogTestHeader("StepIntoAndOutOfTemplateFunction");
	EXPECT_TRUE(src.Find("intObject.func(1);"));
	EXPECT_TRUE(dbg.SetNextStatement());

	// step into and verify source, stack.
	EXPECT_TRUE(dbg.StepInto(1, NULL, 
		"// first line of template function 'func'", 
		"SomeReallyLongSymbolName<int>::func(int 1)"));
	
	// step out of and verify source, stack.
	EXPECT_TRUE(dbg.StepOut(1, NULL, "while(0); //1", "WinMain("));
}


void CTemplatesIDETest::StepOverTemplateFunction(void)
{
	LogTestHeader("StepOverTemplateFunction");
	EXPECT_TRUE(src.Find("intObject.func(2);"));
	EXPECT_TRUE(dbg.SetNextStatement());
	// step over and verify source, stack
	EXPECT_TRUE(dbg.StepOver(1, NULL, "while(0); //2", "WinMain("));
}


void CTemplatesIDETest::StepToCursorInTemplateFunction(void)
{
	LogTestHeader("StepToCursorInTemplateFunction");
	EXPECT_TRUE(src.Find("charObject.func('b');"));
	EXPECT_TRUE(dbg.SetNextStatement());
	// step to cursor and resolve source line ambiguity
	EXPECT_TRUE(src.Find("// first line of template function 'func'"));
	EXPECT_TRUE(dbg.StepToCursor(0, NULL, NULL, NULL, NOWAIT));
	// choose the second (<char>) entry to resolve the ambiguity 
	EXPECT_TRUE(dbg.ResolveSourceLineAmbiguity(2));
	EXPECT_TRUE(dbg.Wait(WAIT_FOR_BREAK));
	// verity the line and function
	EXPECT_TRUE(dbg.CurrentLineIs("// first line of template function 'func'"));
	EXPECT_TRUE(stk.CurrentFunctionIs("SomeReallyLongSymbolName<char>::func(char 98)"));
	// step out to WinMain to set up next test.
	EXPECT_TRUE(dbg.StepOut(1, NULL, "while(0); //b", "WinMain("));
}


void CTemplatesIDETest::SetBreakpointOnLineInTemplateFunctionWhileDebugging(void)

{
	LogTestHeader("SetBreakpointOnLineInTemplateFunctionWhileDebugging");
	// set a bp within a template function
	EXPECT_TRUE(src.Find("// first line of template function 'func'"));
	EXPECT_VALIDBP(bps.SetBreakpoint());
	// set ip to function a place before all instances of the template.
	EXPECT_TRUE(src.Find("intObject.func(1);"));
	EXPECT_TRUE(dbg.SetNextStatement());

	// verify that the bp is hit for each instance of the template
	EXPECT_TRUE(dbg.Go(NULL, 
		"// first line of template function 'func'", 
		"SomeReallyLongSymbolName<int>::func(int 1)"));
	EXPECT_TRUE(dbg.Go(NULL, 
		"// first line of template function 'func'", 
		"SomeReallyLongSymbolName<int>::func(int 2)"));
	EXPECT_TRUE(dbg.Go(NULL, 
		"// first line of template function 'func'", 
		"SomeReallyLongSymbolName<char>::func(char 98)"));
	EXPECT_TRUE(dbg.Go(NULL, 
		"// first line of template function 'func'", 
		"SomeReallyLongSymbolName<char>::func(char 99)"));
	
	// step out to WinMain and clear breakpoint to set up next test.
	EXPECT_TRUE(dbg.StepOut(1, NULL, "while(0); //c", "WinMain("));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
}


void CTemplatesIDETest::SetBreakpointOnLineInTemplateFunctionWhileNotDebugging(void)

{
	LogTestHeader("SetBreakpointOnLineInTemplateFunctionWhileNotDebugging");
	EXPECT_TRUE(dbg.StopDebugging());
	EXPECT_TRUE(src.Find("// first line of template function 'func'"));
	// set a bp within a template function
	EXPECT_VALIDBP(bps.SetBreakpoint());
	
	// verify that the bp is hit for each instance of the template
	EXPECT_TRUE(dbg.Go(NULL, 
		"// first line of template function 'func'", 
		"SomeReallyLongSymbolName<int>::func(int 1)"));
	EXPECT_TRUE(dbg.Go(NULL, 
		"// first line of template function 'func'", 
		"SomeReallyLongSymbolName<int>::func(int 2)"));
	EXPECT_TRUE(dbg.Go(NULL, 
		"// first line of template function 'func'", 
		"SomeReallyLongSymbolName<char>::func(char 98)"));
	EXPECT_TRUE(dbg.Go(NULL, 
		"// first line of template function 'func'", 
		"SomeReallyLongSymbolName<char>::func(char 99)"));
	
	// step out to WinMain and clear breakpoint to set up next test.
	EXPECT_TRUE(dbg.StepOut(1, NULL, "while(0); //c", "WinMain("));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
}


void CTemplatesIDETest::VerifyTemplateParameterOnStack(void)

{
	LogTestHeader("VerifyTemplateParameterOnStack");
	EXPECT_TRUE(src.Find("FuncWithTemplateClassParam(intObject);"));
	EXPECT_TRUE(dbg.SetNextStatement());
	
	// step into and verify stack.
	EXPECT_TRUE(dbg.StepInto(1, NULL, 
		"// first line of FuncWithTemplateClassParam",
		"FuncWithTemplateClassParam(SomeReallyLongSymbolName<int> {...})"));
	
	// step out to WinMain to set up next test.
	CString strline;
	Frame frm( stk.GetFunction(1) );
	LOG->Comment("Frame no 1: %s",frm);
	frm.GetLineNumber(strline);
	strline = "@" + strline;
	LOG->Comment("Line to go from frame no 1: %s",strline);
	EXPECT_TRUE(dbg.StepOut(1, NULL, NULL, "WinMain("));
	//EXPECT_TRUE(dbg.AtLine("while(0); //intObject") );
	EXPECT_TRUE(dbg.VerifyCurrentLine(strline) );
}


void CTemplatesIDETest::GoToDisassemblyFromWithinTemplateFunction(void)

{
	LogTestHeader("GoToDisassemblyFromWithinTemplateFunction");
	EXPECT_TRUE(src.Find("intObject.func(1);"));
	src.AttachActiveEditor();
	EXPECT_TRUE(dbg.SetNextStatement());

	// step into template function and go to disassembly (will need to resolve ambiguity).
	EXPECT_TRUE(dbg.StepInto(1, NULL,
		"// first line of template function 'func'",
		"SomeReallyLongSymbolName<int>::func(int 1)"));
//	EXPECT_TRUE(dbg.SetSteppingMode(ASM)); //Goto DAM from menu works in IP context - not ambiguous
	src.TypeTextAtCursor("{HOME}+{F10}",FALSE);
	Sleep(2000);
	MST.WMenu("Go To Disassembly"); //only Goto DAM from source context is ambiguous
	// choose the first (<int>) entry to resolve the ambiguity. 
	EXPECT_TRUE(dbg.ResolveSourceLineAmbiguity(1));
	EXPECT_TRUE(dbg.Wait(WAIT_FOR_BREAK));
	// restore source mode
	EXPECT_TRUE(dbg.SetSteppingMode(SRC));
	// step out to WinMain to set up next test.
	EXPECT_TRUE(dbg.StepOut(1, NULL, "while(0); //1", "WinMain("));
}



void CTemplatesIDETest::StepIntoSpecificTemplateFunction(void)
{
	int nline;
	LogTestHeader("StepIntoSpecific Member of TemplateClass");
	
	EXPECT_TRUE(src.Find("charObject.func('c');"));
	src.AttachActiveEditor();
	EXPECT_TRUE(dbg.SetNextStatement());
	src.TypeTextAtCursor("{Home}",FALSE);
	nline = UIWB.GetEditorCurPos(GECP_LINE); /*GetLineNumber()*/
	EXPECT_TRUE(src.Find("func")); //only function name shld be highlighted
	EXPECT_TRUE(nline == UIWB.GetEditorCurPos(GECP_LINE) ); //line # didn't change
	src.TypeTextAtCursor("+{F10}", FALSE);Sleep(2000);
	MST.WMenu("Ste&p into SomeReallyLongSymbolName<char>::func");
	//no ambiguity here
	EXPECT_TRUE(dbg.Wait(WAIT_FOR_BREAK));
	EXPECT_TRUE(dbg.CurrentLineIs("{ // first line of template function 'func'") );
	// step out to WinMain to set up next test.
	EXPECT_TRUE( (nline=stk.NavigateStack(1)) > 0); //check where we are going to step out
	CString strnumber;strnumber.Format("@%d",nline);
	EXPECT_TRUE(dbg.StepOut(1, NULL, strnumber));


	LogTestHeader("StepIntoSpecific Specialization of TemplateFunction");
	
	EXPECT_TRUE(src.Find("globaltemplatefunc(global_float"));
	EXPECT_TRUE(dbg.SetNextStatement());
	src.TypeTextAtCursor("{Home}",FALSE);
	nline = UIWB.GetEditorCurPos(GECP_LINE); /*GetLineNumber()*/
	EXPECT_TRUE(src.Find("globaltemplatefunc")); //only function name shld be highlighted
	EXPECT_TRUE(nline == UIWB.GetEditorCurPos(GECP_LINE) ); //line # didn't change
	src.TypeTextAtCursor("+{F10}", FALSE);Sleep(2000);
	MST.WMenu("Ste&p into globaltemplatefunc");
	//no ambiguity here
	EXPECT_TRUE(dbg.Wait(WAIT_FOR_BREAK));
	EXPECT_TRUE(dbg.CurrentLineIs("{ // first line of float specialization of globaltemplatefunc") );
	// step out to WinMain to set up next test.
	EXPECT_TRUE(dbg.StepOut(1, NULL, "globaltemplatefunc(global_float"));
}

void CTemplatesIDETest::SetNextStatementInTemplateFunction(void)

{
	LogTestHeader("SetNextStatementInTemplateFunction");
	EXPECT_TRUE(src.Find("intObject.func(1);"));
	EXPECT_TRUE(dbg.SetNextStatement());
	
	// step into and verify source, stack.
	EXPECT_TRUE(dbg.StepInto(2, NULL,
		"m_Type = var;", 
		"SomeReallyLongSymbolName<int>::func(int 1)"));

	// set next statement and verify source and stack
	EXPECT_TRUE(src.Find("in template function 'func'"));
	EXPECT_TRUE(dbg.SetNextStatement());
	EXPECT_TRUE(dbg.ResolveSourceLineAmbiguity(1));
	EXPECT_TRUE(dbg.Wait(WAIT_FOR_BREAK));
	EXPECT_TRUE(dbg.CurrentLineIs("// in template function 'func'"));
	EXPECT_TRUE(stk.CurrentFunctionIs("SomeReallyLongSymbolName<int>::func(int 1)"));
	// step out to WinMain to set up next test.
	EXPECT_TRUE(dbg.StepOut(1, NULL, "while(0); //1", "WinMain("));
}


void CTemplatesIDETest::StepToCursorInTemplateFunctionInStack(void)
{
	LogTestHeader("StepToCursorInTemplateFunctionInStack");
	EXPECT_TRUE(src.Find("intObject.func(2);"));
	EXPECT_TRUE(dbg.SetNextStatement());

	// run to a function that was called by a template function
	EXPECT_TRUE(src.Find("void globalfunc(void){}"));
	EXPECT_TRUE(dbg.StepToCursor());
	// navigate to the template function
	EXPECT_TRUE(stk.NavigateStack("SomeReallyLongSymbolName<int>::func(int 2)")>0);
	EXPECT_TRUE(stk.NavigateStack(0)>0); //return to EIP
	// run to the template function in the stack, verify source and stack.
	// no ambiguity here
	EXPECT_TRUE(stk.RunToFrame("SomeReallyLongSymbolName<int>::func(int 2)", 0));
	EXPECT_TRUE(dbg.CurrentLineIs("// in template function 'func'"));
	EXPECT_TRUE(stk.CurrentFunctionIs("SomeReallyLongSymbolName<int>::func(int 2)"));
	// step out to WinMain to set up next test.
	EXPECT_TRUE(dbg.StepOut(1, NULL, "while(0); //2", "WinMain("));
}


void CTemplatesIDETest::StepToCursorInTemplateFunctionToStartDebugging(void)
{
	LogTestHeader("StepToCursorInTemplateFunctionToStartDebugging");
	EXPECT_TRUE(dbg.StopDebugging());
	// step to cursor into the template function to start debugging..
	EXPECT_TRUE(src.Find("// first line of template function 'func'"));
	EXPECT_TRUE(dbg.StepToCursor(0, NULL, NULL, NULL, NOWAIT));
	// choose the second (<char>) entry to resolve the ambiguity 
	EXPECT_TRUE(dbg.ResolveSourceLineAmbiguity(2));
	EXPECT_TRUE(dbg.Wait(WAIT_FOR_BREAK));
	// verity the line and function
	EXPECT_TRUE(dbg.CurrentLineIs("// first line of template function 'func'"));
	EXPECT_TRUE(stk.CurrentFunctionIs("SomeReallyLongSymbolName<char>::func(char 98)"));
	// step out to WinMain to set up next test.
	EXPECT_TRUE(dbg.StepOut(1, NULL, "while(0); //b", "WinMain("));
}


void CTemplatesIDETest::HitBreakpointOnNonAmbiguousTemplateFunction(void)

{
	LogTestHeader("HitBreakpointOnNonAmbiguousTemplateFunction");
	// set a bp on a template function
	EXPECT_VALIDBP(bps.SetBreakpoint("globaltemplatefunc(int)"));
	EXPECT_TRUE(dbg.Go(NULL, 
		"// first line of globaltemplatefunc", 
		"globaltemplatefunc(int 1)"));
	
	// step out to WinMain to set up next test.
	CString strline;
	Frame frm( stk.GetFunction(1) );
	LOG->Comment("Frame no 1: %s",frm);
	frm.GetLineNumber(strline);
	strline = "@" + strline;
	LOG->Comment("Line to go from frame no 1: %s",strline);
	EXPECT_TRUE(dbg.StepOut(1, NULL, NULL, "WinMain("));
	//EXPECT_TRUE(dbg.AtLine("while(0); //::1") );
	EXPECT_TRUE(dbg.VerifyCurrentLine(strline) );

	EXPECT_TRUE(bps.ClearAllBreakpoints());
}


void CTemplatesIDETest::HitBreakpointOnAmbiguousTemplateFunction(void)

{
	LogTestHeader("HitBreakpointOnAmbiguousTemplateFunction");
	// set a bp on a template function (char)
	EXPECT_VALIDBP(bps.SetAmbiguousBreakpoint("globaltemplatefunc", 4)); //TODO: choose it from string (char) rather than position in the list
	EXPECT_TRUE(dbg.Go(NULL, 
		"// first line of globaltemplatefunc", 
		"globaltemplatefunc(char 97)"));
	
	// step out to WinMain to set up next test.
	CString strline;
	Frame frm( stk.GetFunction(1) );
	LOG->Comment("Frame no 1: %s",frm);
	frm.GetLineNumber(strline);
	strline = "@" + strline;
	LOG->Comment("Line to go from frame no 1: %s",strline);
	EXPECT_TRUE(dbg.StepOut(1, NULL, NULL, "WinMain("));
	//EXPECT_TRUE(dbg.AtLine("while(0); //::a") );
	EXPECT_TRUE(dbg.VerifyCurrentLine(strline) );

	EXPECT_TRUE(bps.ClearAllBreakpoints());
}


void CTemplatesIDETest::DisableBreakpointInTemplateFunctionAndVerifyNotHit(void)

{
	LogTestHeader("DisableBreakpointInTemplateFunctionAndVerifyNotHit");
	// set a bp within a template function
	EXPECT_TRUE(src.Find("// first line of template function 'func'"));
	bp *pbp = bps.SetBreakpoint();
	// two bp's were set, disable one of them (<int>)
	// TODO(michma): two bps were set but we only get one bp object.
	// the first one gets disabled because of the way cafe indexes bp
	// objects. we need a disable breakpoint function that takes indexes.
	EXPECT_TRUE(bps.DisableBreakpoint(pbp));
	// set ip to function a place before the breakpoints.
	EXPECT_TRUE(src.Find("intObject.func(1);"));
	EXPECT_TRUE(dbg.SetNextStatement());

	// verify that the bp is hit for each instance of the template not disabled (<char>)
	// the other earlier ones (<int>) should get passed up.
	EXPECT_TRUE(dbg.Go(NULL, 
		"// first line of template function 'func'", 
		"SomeReallyLongSymbolName<char>::func(char 98)"));
	EXPECT_TRUE(dbg.Go(NULL, 
		"// first line of template function 'func'", 
		"SomeReallyLongSymbolName<char>::func(char 99)"));
	
	// step out to WinMain and clear breakpoint to set up next test.
	EXPECT_TRUE(dbg.StepOut(1, NULL, "while(0); //c", "WinMain("));
	EXPECT_TRUE(bps.ClearAllBreakpoints());
}


void CTemplatesIDETest::ToggleOffBreakpointInTemplateFunctionAndVerifyNotHit(void)

{
	LogTestHeader("ToggleOffBreakpointInTemplateFunctionAndVerifyNotHit");
	// toggle on a bp within a template function
	EXPECT_TRUE(src.Find("// first line of template function 'func'"));
	EXPECT_VALIDBP(bps.SetBreakpoint());
	// toggle it off.
	// TODO(michma): SetBreakpoint isn't smart enough to know when we're
	// toggling a bp off. we shouldn't be getting back a valid bp.
	EXPECT_VALIDBP(bps.SetBreakpoint());
	// go and make sure we don't hit the breakpoints we just toggled off.
	EXPECT_TRUE(dbg.Go(NULL, NULL, NULL, WAIT_FOR_TERMINATION));
	// step past prolog of WinMain to set up next test.
	EXPECT_TRUE(dbg.StepInto(2));
}


void CTemplatesIDETest::EvaluateSTLObjectWithLongName(void)
{
	LogTestHeader("EvaluateSTLObjectWithLongName");
	EXPECT_TRUE(cxx.ExpressionValueIs("STLObjectWithLongName._Tr", "{...}"));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\varswnd\varssub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	VARSSUB.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CVarsWndSubSuite class
//

#include "stdafx.h"
#include "varssub.h"
#include "afxdllx.h"

#include "autocase.h"
#include "loccase.h"
#include "thiscase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CVarsWndSubSuite

IMPLEMENT_SUBSUITE(CVarsWndSubSuite, CIDESubSuite, "Variables Window", "VCQA Debugger")

BEGIN_TESTLIST(CVarsWndSubSuite)
	TEST(CAutoPaneIDETest, RUN)
	TEST(CLocalsCases, RUN)
	TEST(CThisPaneIDETest, DONTRUN)	//	TODO : dverma : thispane currently is not implemented
END_TESTLIST()

void CVarsWndSubSuite::CleanUp(void)
	{
	::CleanUp("autopane");
	}

///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\core\varswnd\varssub.h ===
///////////////////////////////////////////////////////////////////////////////
//	VARSSUB.H
//
//	Created by :			
//		VCBU QA
//
//	Description :
//		Declaration of the CVarsWndSubSuite class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CVarsWndSubSuite class

class CVarsWndSubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CVarsWndSubSuite)
	DECLARE_TESTLIST()
protected:
	void CleanUp(void);
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\stress\Base\Dbg_Stress_Sub.h ===
///////////////////////////////////////////////////////////////////////////////
//	Dbg_Stress_Sub.h
//
//	Created by :			
//		Xbox XDK Test
//
//	Description :
//		Declaration of the CDbgStressSubSuite class
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CDbgStressSubSuite class

class CDbgStressSubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CDbgStressSubSuite)
//exeSubSuite() { m_strName = "TestWizard Generated script"; m_strOwner = "Xbox XDK Test"; }


	DECLARE_TESTLIST()
protected:
	void CleanUp(void);
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\stress\Base\Dbg_Stress_Sub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	Dbg_Stress_Sub.CPP
//
//	Created by :			
//		Xbox XDK Test		
//
//	Description :
//		implementation of the CDbgStressSubSuite class
//

#include "stdafx.h"
#include "Dbg_Stress_Sub.h"
#include "afxdllx.h"

#include "Dbg_stress_base.h"


#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CDbgStressSubSuite

IMPLEMENT_SUBSUITE(CDbgStressSubSuite, CIDESubSuite, "Debugger Stress", "Xbox Debugger")

BEGIN_TESTLIST(CDbgStressSubSuite)
	TEST(CDbgStressStopAndGoTest, RUN)
	TEST(CDbgStressRestartAndGoTest, RUN)
	TEST(CDbgStressBreakAndGoTest, RUN)
	TEST(CDbgStressConditionalBPNonCountingTest, RUN)
	TEST(CDbgStressConditionalBPCountingTest, RUN)
	TEST(CDbgStressDataBPTest, RUN)
END_TESTLIST()

void CDbgStressSubSuite::CleanUp(void)
	{
	::CleanUp("stress01");
	}

///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\stress\Base\Dbg_stress_base.h ===
///////////////////////////////////////////////////////////////////////////////
//	Dbg_Stress_base.h
//
//	Created by :			
//		Xbox XDK Test
//
//	Description :
//		Declaration of the CDbgStressBaseTest Class
//

#ifndef __exe_base_H__
#define __exe_base_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\dbgtestbase.h"
#include "Dbg_Stress_Sub.h"

///////////////////////////////////////////////////////////////////////////////
//	CexeIDETest class

class CDbgStressStopAndGoTest : public CDbgTestBase
{
	DECLARE_TEST(CDbgStressStopAndGoTest, CDbgStressSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run();

// Test Cases
protected:

	BOOL StopAndGo();
};


class CDbgStressRestartAndGoTest : public CDbgTestBase
{
	DECLARE_TEST(CDbgStressRestartAndGoTest, CDbgStressSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run();

// Test Cases
protected:

	BOOL RestartAndGo();
};


class CDbgStressBreakAndGoTest : public CDbgTestBase
{
	DECLARE_TEST(CDbgStressBreakAndGoTest, CDbgStressSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run();

// Test Cases
protected:
	BOOL BreakAndGo();
};


class CDbgStressConditionalBPNonCountingTest : public CDbgTestBase
{
	DECLARE_TEST(CDbgStressConditionalBPNonCountingTest, CDbgStressSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run();

// Test Cases
protected:
	BOOL CondBPNonCounting();
};


class CDbgStressConditionalBPCountingTest : public CDbgTestBase
{
	DECLARE_TEST(CDbgStressConditionalBPCountingTest, CDbgStressSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run();

// Test Cases
protected:
	BOOL CondBPCounting();
};

class CDbgStressDataBPTest : public CDbgTestBase
{
	DECLARE_TEST(CDbgStressDataBPTest, CDbgStressSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run();

// Test Cases
protected:
	BOOL DataBP();
};

#endif //__exe_base_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\stress\Base\Dbg_stress_base.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	Dbg_stress_base.CPP
//											 
//	Created by :			
//		Xbox XDK Test		

#include "stdafx.h"
#include "Dbg_stress_base.h"
#include "PerfCounter.h"	

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

											   
IMPLEMENT_TEST(CDbgStressStopAndGoTest, CDbgTestBase, "Debugger Stress Stop & Go", -1, CDbgStressSubSuite)
IMPLEMENT_TEST(CDbgStressRestartAndGoTest, CDbgTestBase, "Debugger Stress Restart & Go", -1, CDbgStressSubSuite)
IMPLEMENT_TEST(CDbgStressBreakAndGoTest, CDbgTestBase, "Debugger Stress Break & Go", -1, CDbgStressSubSuite)
IMPLEMENT_TEST(CDbgStressConditionalBPNonCountingTest, CDbgTestBase, "Debugger Stress Conditional Breakpoint (non-counting type)", -1, CDbgStressSubSuite)
IMPLEMENT_TEST(CDbgStressConditionalBPCountingTest, CDbgTestBase, "Debugger Stress Conditional Breakpoint (counting type)", -1, CDbgStressSubSuite)
IMPLEMENT_TEST(CDbgStressDataBPTest, CDbgTestBase, "Debugger Stress Data Breakpoint", -1, CDbgStressSubSuite)

#define TIMESTORUN 250
#define TIMESTORUNSTR "250"

void CDbgStressStopAndGoTest::PreRun(void)
{
	// call the base class
	CTest::PreRun();

}

void CDbgStressStopAndGoTest::Run()
{	 
	XSAFETY;
	
	if( SetProject("stress01\\stress01", PROJECT_XBE))
	{	  
		bps.ClearAllBreakpoints();
		XSAFETY;
		StopAndGo();
		XSAFETY;
	}
	else
		m_pLog->RecordFailure("SetProject failed for \"stress01\"." );
}

void CDbgStressRestartAndGoTest::PreRun(void)
{
	// call the base class
	CTest::PreRun();

}

void CDbgStressRestartAndGoTest::Run()
{	 
	XSAFETY;
	
	if( SetProject("stress01\\stress01", PROJECT_XBE))
	{	  
		bps.ClearAllBreakpoints();
		XSAFETY;
		RestartAndGo();
		XSAFETY;
	}
	else
		m_pLog->RecordFailure("SetProject failed for \"stress01\"." );
}



void CDbgStressBreakAndGoTest::PreRun(void)
{
	// call the base class
	CTest::PreRun();

}

void CDbgStressBreakAndGoTest::Run()
{	 
	XSAFETY;
	
	if( SetProject("stress01\\stress01", PROJECT_XBE))
	{	  
		bps.ClearAllBreakpoints();
		XSAFETY;
		BreakAndGo();
		XSAFETY;
	}
	else
		m_pLog->RecordFailure("SetProject failed for \"stress01\"." );
}


void CDbgStressConditionalBPNonCountingTest::PreRun(void)
{
	// call the base class
	CTest::PreRun();

}

void CDbgStressConditionalBPNonCountingTest::Run()
{	 
	XSAFETY;
	
	if( SetProject("stress01\\stress01", PROJECT_XBE))
	{	  
		bps.ClearAllBreakpoints();
		XSAFETY;
		CondBPNonCounting();
		XSAFETY;
	}
	else
		m_pLog->RecordFailure("SetProject failed for \"stress01\"." );
}


void CDbgStressConditionalBPCountingTest::PreRun(void)
{
	// call the base class
	CTest::PreRun();

}

void CDbgStressConditionalBPCountingTest::Run()
{	 
	XSAFETY;
	
	if( SetProject("stress01\\stress01", PROJECT_XBE))
	{	  
		bps.ClearAllBreakpoints();
		XSAFETY;
		CondBPCounting();
		XSAFETY;
	}
	else
		m_pLog->RecordFailure("SetProject failed for \"stress01\"." );
}


void CDbgStressDataBPTest::PreRun(void)
{
	// call the base class
	CTest::PreRun();

}

void CDbgStressDataBPTest::Run()
{	 
	XSAFETY;
	
	if( SetProject("stress01\\stress01", PROJECT_XBE))
	{	  
		bps.ClearAllBreakpoints();
		XSAFETY;
		DataBP();
		XSAFETY;
	}
	else
		m_pLog->RecordFailure("SetProject failed for \"stress01\"." );
}


/*
1.  Rapid fire Go, Stop, Go, Stop x 10,000 (with memory leak checks)
2.  Rapid fire Go, Restart, Restart x 10,000 (with memory leak checks)
3.  Rapid fire Go, break, Go, break x 10,000 (with memory leak checks)
4.  Tight 500,000 loop with a conditional data breakpoint (counting type)
5.  Tight 500,000 loop with a conditional data breakpoint (evaluate data type)
*/
///////////////////////////////////////////////////////////////////////////////
//	Test Cases
///////////////////////////////////////////////////////////////////////////////

BOOL CDbgStressStopAndGoTest::StopAndGo( )
{
	long		workingset = 0;
	PerfCounter	PC;
	char		buf[1024];

 	LogTestHeader( "StopAndGoStress" );
	m_pLog->RecordInfo( "Start and Stop Debugger " TIMESTORUNSTR " Times" );
	bps.ClearAllBreakpoints();

	//
	// Get Memory usage on xbox
	//
	Sleep(10000);
	PC.LogData();
	workingset = PC.GetCur();
	wsprintf(buf, "MSDEV Working Set: %uk", workingset / 1024);
	m_pLog->RecordInfo(buf);

	for (unsigned count = 0; count < TIMESTORUN; count++)
	{
		wsprintf(buf, "Run: %d", count+1);
		m_pLog->RecordInfo(buf);
		EXPECT_TRUE( dbg.Go(NULL, NULL, NULL, WAIT_FOR_RUN) );
//		Sleep(20000);
		EXPECT_TRUE( dbg.StopDebugging() );
		Sleep(500);
		PC.LogData();
	}
	//
	// Let MSDEV Settle down before capturing the last sample
	//
	Sleep(10000);
	PC.LogData();
	//
	// Get Xbox and Dev memory usage
	//
	wsprintf(buf, "MSDEV Working Set: %uk (diff = %ldk)", PC.GetCur() / 1024, (PC.GetCur() - workingset) / 1024);
	m_pLog->RecordInfo(buf);
	wsprintf(buf, "MSDEV Working Set: Min = %uk / Max = %uk / Avg = %uk", 
		PC.GetMin() / 1024,
		PC.GetMax() / 1024,
		PC.GetAvg() / 1024
		);
	m_pLog->RecordInfo(buf);

	return (TRUE);
}

BOOL CDbgStressBreakAndGoTest::BreakAndGo( )
{
	long		workingset = 0;
	PerfCounter	PC;
	char		buf[1024];

 	LogTestHeader( "BreakAndGoStress" );
	m_pLog->RecordInfo( "Go and Break Debugger " TIMESTORUNSTR " Times" );
	bps.ClearAllBreakpoints();


	//
	// Get Memory usage on xbox
	//
	Sleep(10000);
	PC.LogData();
	workingset = PC.GetCur();
	wsprintf(buf, "MSDEV Working Set: %uk", workingset / 1024);
	m_pLog->RecordInfo(buf);
	dbg.Restart();
	dbg.SetSteppingMode(SRC);
	for (unsigned count = 0; count < TIMESTORUN; count++)
	{
		wsprintf(buf, "Run: %d", count+1);
		m_pLog->RecordInfo(buf);
		
		EXPECT_TRUE( dbg.Go(NULL, NULL, NULL, WAIT_FOR_RUN) );
		Sleep(5000);
		EXPECT_TRUE( dbg.Break() );
		if (dbg.GetDebugState() == 2)
		{
			MST.DoKeys( "{esc}" );
		}

		Sleep(2000);
		PC.LogData();
	}
	EXPECT_TRUE( dbg.StopDebugging() );
	//
	// Let MSDEV Settle down before capturing the last sample
	//
	Sleep(10000);
	PC.LogData();
	//
	// Get Xbox and Dev memory usage
	//
	wsprintf(buf, "MSDEV Working Set: %uk (diff = %ldk)", PC.GetCur() / 1024, (PC.GetCur() - workingset) / 1024);
	m_pLog->RecordInfo(buf);
	wsprintf(buf, "MSDEV Working Set: Min = %uk / Max = %uk / Avg = %uk", 
		PC.GetMin() / 1024,
		PC.GetMax() / 1024,
		PC.GetAvg() / 1024
		);
	m_pLog->RecordInfo(buf);

	return (TRUE);
}


BOOL CDbgStressRestartAndGoTest::RestartAndGo( )
{
	long		workingset = 0;
	PerfCounter	PC;
	char		buf[1024];

 	LogTestHeader( "RestartAndGoStress" );
	m_pLog->RecordInfo( "Start and Restart Debugger " TIMESTORUNSTR " Times" );
	bps.ClearAllBreakpoints();


	//
	// Get Memory usage on xbox
	//
	Sleep(10000);
	PC.LogData();
	workingset = PC.GetCur();
	wsprintf(buf, "MSDEV Working Set: %uk", workingset / 1024);
	m_pLog->RecordInfo(buf);

	EXPECT_TRUE( dbg.Restart() );
	EXPECT_TRUE( dbg.ShowNextStatement() ); // insure we're in source
	EXPECT_TRUE( src.Find("Sleep(10);") );
	EXPECT_TRUE( bps.SetBreakpoint() );

	for (unsigned count = 0; count < TIMESTORUN; count++)
	{
		wsprintf(buf, "Run: %d", count+1);
		m_pLog->RecordInfo(buf);
		
		EXPECT_TRUE( dbg.Go(NULL, NULL, NULL, WAIT_FOR_BREAK) );
		EXPECT_TRUE( dbg.Restart() );
		Sleep(500);
		PC.LogData();
	}
	EXPECT_TRUE( dbg.StopDebugging() );
	//
	// Let MSDEV Settle down before capturing the last sample
	//
	Sleep(10000);
	PC.LogData();
	//
	// Get Xbox and Dev memory usage
	//
	wsprintf(buf, "MSDEV Working Set: %uk (diff = %ldk)", PC.GetCur() / 1024, (PC.GetCur() - workingset) / 1024);
	m_pLog->RecordInfo(buf);
	wsprintf(buf, "MSDEV Working Set: Min = %uk / Max = %uk / Avg = %uk", 
		PC.GetMin() / 1024,
		PC.GetMax() / 1024,
		PC.GetAvg() / 1024
		);
	m_pLog->RecordInfo(buf);

	return (TRUE);
}


BOOL CDbgStressConditionalBPNonCountingTest::CondBPNonCounting( )
{
	long		workingset = 0;
	PerfCounter	PC;
	char		buf[1024];

 	LogTestHeader( "Conditional BP" );
	m_pLog->RecordInfo( "Conditional BP at location " TIMESTORUNSTR " Times" );
	bps.ClearAllBreakpoints();

	//
	// Get Memory usage on xbox
	//
	Sleep(10000);
	PC.LogData();
	workingset = PC.GetCur();
	wsprintf(buf, "MSDEV Working Set: %uk", workingset / 1024);
	m_pLog->RecordInfo(buf);

	//
	// insert a conditional breakpoint
	//
	EXPECT_TRUE( dbg.Restart() );
	EXPECT_TRUE( dbg.ShowNextStatement() ); // insure we're in source
	EXPECT_VALIDBP(bps.SetBreakOnExpr("(global_count % 2) == 1", COBP_TYPE_IF_EXP_TRUE));

	// make sure TIMESTORUN is greater than or equal the times that
	// global_count is changed in the target source (LoopLevel1)
	for (unsigned count = 0; count < TIMESTORUN; count++)
	{
		wsprintf(buf, "Run: %d", count+1);
		m_pLog->RecordInfo(buf);
		
		EXPECT_TRUE( dbg.Go(NULL, NULL, NULL, WAIT_FOR_BREAK) );
		Sleep(500);
		PC.LogData();
	}
	EXPECT_TRUE( dbg.StopDebugging() );

	//
	// Let MSDEV Settle down before capturing the last sample
	//
	Sleep(10000);
	PC.LogData();
	//
	// Get Xbox and Dev memory usage
	//
	wsprintf(buf, "MSDEV Working Set: %uk (diff = %ldk)", PC.GetCur() / 1024, (PC.GetCur() - workingset) / 1024);
	m_pLog->RecordInfo(buf);
	wsprintf(buf, "MSDEV Working Set: Min = %uk / Max = %uk / Avg = %uk", 
		PC.GetMin() / 1024,
		PC.GetMax() / 1024,
		PC.GetAvg() / 1024
		);
	m_pLog->RecordInfo(buf);


	return (TRUE);
}


BOOL CDbgStressConditionalBPCountingTest::CondBPCounting( )
{
	long		workingset = 0;
	PerfCounter	PC;
	char		buf[1024];

 	LogTestHeader( "Conditional BP with counting" );
	m_pLog->RecordInfo( "Conditional BP with counting " TIMESTORUNSTR " Times" );
	bps.ClearAllBreakpoints();

	//
	// Get Memory usage on xbox
	//

	Sleep(10000);
	PC.LogData();
	workingset = PC.GetCur();
	wsprintf(buf, "MSDEV Working Set: %uk", workingset / 1024);
	m_pLog->RecordInfo(buf);

	//
	// insert a conditional breakpoint with a count
	//
	EXPECT_TRUE( dbg.Restart() );
	EXPECT_TRUE( dbg.ShowNextStatement() ); // insure we're in source
	EXPECT_VALIDBP(bps.SetBreakOnExpr("(global_count % 2) == 1", COBP_TYPE_IF_EXP_TRUE, 1, TIMESTORUN));

	// make sure TIMESTORUN is greater than or equal the times that
	// global_count is changed in the target source (LoopLevel1)
	for (unsigned count = 0; count < TIMESTORUN; count++)
	{
		wsprintf(buf, "Run: %d", count+1);
		m_pLog->RecordInfo(buf);
		
		EXPECT_TRUE( dbg.Go(NULL, NULL, NULL, WAIT_FOR_BREAK) );
		Sleep(500);
		PC.LogData();
	}
	EXPECT_TRUE( dbg.StopDebugging() );

	//
	// Let MSDEV Settle down before capturing the last sample
	//
	Sleep(10000);
	PC.LogData();
	//
	// Get Xbox and Dev memory usage
	//
	wsprintf(buf, "MSDEV Working Set: %uk (diff = %ldk)", PC.GetCur() / 1024, (PC.GetCur() - workingset) / 1024);
	m_pLog->RecordInfo(buf);
	wsprintf(buf, "MSDEV Working Set: Min = %uk / Max = %uk / Avg = %uk", 
		PC.GetMin() / 1024,
		PC.GetMax() / 1024,
		PC.GetAvg() / 1024
		);
	m_pLog->RecordInfo(buf);


	return (TRUE);
}


BOOL CDbgStressDataBPTest::DataBP( )
{
	long		workingset = 0;
	PerfCounter	PC;
	char		buf[1024];

 	LogTestHeader( "Conditional BP with counting" );
	m_pLog->RecordInfo( "Conditional BP with counting " TIMESTORUNSTR " Times" );
	bps.ClearAllBreakpoints();

	//
	// Get Memory usage on xbox
	//

	Sleep(10000);
	PC.LogData();
	workingset = PC.GetCur();
	wsprintf(buf, "MSDEV Working Set: %uk", workingset / 1024);
	m_pLog->RecordInfo(buf);

	//
	// insert a conditional breakpoint with a count
	//
	EXPECT_TRUE( dbg.Restart() );
	EXPECT_TRUE( dbg.ShowNextStatement() ); // insure we're in source
	EXPECT_VALIDBP(bps.SetBreakOnExpr("global_count", COBP_TYPE_IF_EXP_CHANGED, 1, TIMESTORUN));

	// make sure TIMESTORUN is greater than or equal the times that
	// global_count is changed in the target source (LoopLevel1)
	for (unsigned count = 0; count < TIMESTORUN; count++)
	{
		wsprintf(buf, "Run: %d", count+1);
		m_pLog->RecordInfo(buf);
		
		EXPECT_TRUE( dbg.Go(NULL, NULL, NULL, WAIT_FOR_BREAK) );
		Sleep(500);
		PC.LogData();
	}
	EXPECT_TRUE( dbg.StopDebugging() );

	//
	// Let MSDEV Settle down before capturing the last sample
	//
	Sleep(10000);
	PC.LogData();
	//
	// Get Xbox and Dev memory usage
	//
	wsprintf(buf, "MSDEV Working Set: %uk (diff = %ldk)", PC.GetCur() / 1024, (PC.GetCur() - workingset) / 1024);
	m_pLog->RecordInfo(buf);
	wsprintf(buf, "MSDEV Working Set: Min = %uk / Max = %uk / Avg = %uk", 
		PC.GetMin() / 1024,
		PC.GetMax() / 1024,
		PC.GetAvg() / 1024
		);
	m_pLog->RecordInfo(buf);


	return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\stress\Base\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		Xbox XDK Test		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\stress\Base\PerfCounter.h ===
//
// Performance Counter classes to snapshot memory
//
// Winthrop Chan (winthc)
// March 22, 2001
//
#include <pdh.h>

class PerfCounter
{
private:
	HQUERY			m_hQuery;
	HCOUNTER		m_hCounter;
	bool			m_firsttime;

	unsigned long	m_ticks;
	long			m_minCounter;
	long			m_maxCounter;
	long			m_curCounter;
	ULONGLONG		m_totalCounter;
	ULONGLONG		m_avgCounter;

public:
	PerfCounter(char *strCounter = "\\process(msdev)\\Working Set")
	{
		PDH_STATUS	pdhStatus;

		m_ticks        = 0;
		m_firsttime    = true;
		m_minCounter   = 0;
		m_curCounter   = 0;
		m_maxCounter   = 0;
		m_totalCounter = 0;
		m_avgCounter   = 0;

		pdhStatus = PdhOpenQuery (0, 0, &m_hQuery);

		pdhStatus = PdhAddCounter (m_hQuery, strCounter, 0, &m_hCounter);
	}

	~PerfCounter()
	{
		PdhCloseQuery (m_hQuery);
	}

	void LogData()
	{
		PDH_STATUS				pdhStatus;
		DWORD					ctype;
		PDH_FMT_COUNTERVALUE	fmtValue;

		pdhStatus = PdhCollectQueryData (m_hQuery);
		pdhStatus = PdhGetFormattedCounterValue(
			m_hCounter, PDH_FMT_LONG, // PDH_FMT_DOUBLE, 
			&ctype, 
			&fmtValue); 

		m_ticks++;
		if (m_firsttime)
		{
			m_minCounter    = fmtValue.longValue;
			m_maxCounter    = fmtValue.longValue;
			m_firsttime     = false;
		}
		else
		{
			m_minCounter    = min(m_minCounter, fmtValue.longValue);
			m_maxCounter    = max(m_maxCounter, fmtValue.longValue);
		}


		m_curCounter    = fmtValue.longValue;
		m_totalCounter += fmtValue.longValue;
		m_avgCounter    = m_totalCounter / m_ticks;
	}

	long GetMin()
	{
		return m_minCounter;
	}

	long GetMax()
	{
		return m_maxCounter;
	}

	long GetCur()
	{
		return m_curCounter;
	}

	ULONGLONG GetAvg()
	{
		return m_avgCounter;
	}

	unsigned long GetTicks()
	{
		return m_ticks;
	}

//	pdhStatus = PdhAddCounter (hQuery, _T("\\process(msdev)\\private bytes"), 0, &hCounter[0]);
//	pdhStatus = PdhAddCounter (hQuery, _T("\\process(msdev)\\Working Set"), 0, &hCounter[1]);
//	pdhStatus = PdhAddCounter (hQuery, _T("\\process(msdev)\\page file bytes"), 0, &hCounter);
//	pdhStatus = PdhAddCounter (hQuery, _T("\\process(msdev)\\pool Paged bytes"), 0, &hCounter);
//	pdhStatus = PdhAddCounter (hQuery, _T("\\process(msdev)\\pool Nonpaged bytes"), 0, &hCounter);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\debugger\stress\Base\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		Xbox XDK Test		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\ide\core\appwiz\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\ide\core\appwiz\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\ide\core\appwiz\appwizcase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	AppWizCase.CPP
//											 
//	Created by :			
//		dklem
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "Appwizcase.h"
//#include "coprject.h"	
//#include "process.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
											   
IMPLEMENT_TEST(/*999,*/ CAppWizTest, CIdeTestBase, "General", -1, CAppWizSubSuite)

// each function that runs a test has this prototype.
typedef void (CAppWizTest::*PTR_TEST_FUNC)(void); 

// Information about a test to be put in the test header
#define LOGTESTHEADER(strTestName) 	m_strLogInfo.Format("# - %d.  %s. Total # - %d, Passed - %d %%", ++m_TestNumber, strTestName, m_TotalNumberOfTests, (m_TestNumber*100)/m_TotalNumberOfTests);  \
									LogTestHeader(m_strLogInfo);

void CAppWizTest::PreRun(void)
{
	// call the base class
	CTest::PreRun();

}

void CAppWizTest::Run()
{
	CreateDirectory(TMP_PROJ_DIR, NULL);

	CreateWin32App();
	CreateWin32ConsoleApp();
	CreateWin32Dll();
	CreateWin32StaticLib();
	CreateXboxGame();
	CreateXboxStaticLib();
	CreateAndBuildXboxStaticLib();
	UseStaticLibDebug();
	UseStaticLibRelease();
}	

void RemovePreExistingProject(CProjWizOptions *pOptions)
{
	CString strDir = pOptions->m_strLocation + "\\" + pOptions->m_strName;

	KillFiles(strDir + "\\Debug\\", "*.*");
	KillFiles(strDir + "\\Release\\", "*.*");
	RemoveDirectory(strDir + "\\Debug");
	RemoveDirectory(strDir + "\\Release");
	KillFiles(strDir + "\\", "*.*");
	RemoveDirectory(strDir);
}

void CAppWizTest::SafeCloseProject()
{
	if (prj.IsOpen())
		prj.Close();
	else
	{
		LOG->RecordFailure("Possible failure to create project %s", prj.GetName());
		MST.DoKeys("+{B}+{B}+{B}{ESC}");
	}
}

///////////////////////////////////////////////////////////////////////////////
//	Test Cases
///////////////////////////////////////////////////////////////////////////////

void CAppWizTest::CreateWin32App(void)
{
	LOGTESTHEADER("CreateWin32App");
	// set the options for the exe project we are building for this test.
	CWin32AppWizOptions *pOptions = new(CWin32AppWizOptions);
	pOptions->m_strLocation = TMP_PROJ_DIR;
	pOptions->m_strName = "CreateWin32App Empty";
	pOptions->m_AppType = (CWin32AppWizOptions::APP_TYPE) 1;
	
	// create the exe project.
	RemovePreExistingProject(pOptions);
	EXPECT_SUCCESS(prj.New(pOptions));
	prj.Close();

	pOptions->m_strLocation = TMP_PROJ_DIR;
	pOptions->m_strName = "CreateWin32App Simple App";
	pOptions->m_AppType = (CWin32AppWizOptions::APP_TYPE) 2;
	
	// create the exe project.
	RemovePreExistingProject(pOptions);
	EXPECT_SUCCESS(prj.New(pOptions));
	EXPECT_SUCCESS(prj.Build());
	prj.Close();

	pOptions->m_strLocation = TMP_PROJ_DIR;
	pOptions->m_strName = "CreateWin32App Hello World";
	pOptions->m_AppType = (CWin32AppWizOptions::APP_TYPE) 3;
	
	// create the exe project.
	RemovePreExistingProject(pOptions);
	EXPECT_SUCCESS(prj.New(pOptions));
	EXPECT_SUCCESS(prj.Build());
	prj.Close();
}

void CAppWizTest::CreateWin32ConsoleApp(void)
{

	LOGTESTHEADER("CreateWin32ConsoleApp");
}

void CAppWizTest::CreateWin32Dll(void)
{
	LOGTESTHEADER("CreateWin32Dll");

	// set the options for the dll project we are building for this test.
	CWin32DllWizOptions *pOptions = new(CWin32DllWizOptions);
	pOptions->m_strLocation = TMP_PROJ_DIR;
	pOptions->m_strName = "CreateWin32Dll Empty";
	pOptions->m_DllType = (CWin32DllWizOptions::DLL_TYPE) 1;
	
	// create the dll project.
	RemovePreExistingProject(pOptions);
	EXPECT_SUCCESS(prj.New(pOptions));
	SafeCloseProject();

	pOptions->m_strLocation = TMP_PROJ_DIR;
	pOptions->m_strName = "CreateWin32Dll Simple Dll";
	pOptions->m_DllType = (CWin32DllWizOptions::DLL_TYPE) 2;
	
	// create the dll project.
	RemovePreExistingProject(pOptions);
	EXPECT_SUCCESS(prj.New(pOptions));
	EXPECT_SUCCESS(prj.Build());
	SafeCloseProject();

	pOptions->m_strLocation = TMP_PROJ_DIR;
	pOptions->m_strName = "CreateWin32Dll Dll Exports";
	pOptions->m_DllType = (CWin32DllWizOptions::DLL_TYPE) 3;
	
	// create the dll project.
	RemovePreExistingProject(pOptions);
	EXPECT_SUCCESS(prj.New(pOptions));
	EXPECT_SUCCESS(prj.Build());
	SafeCloseProject();
}

void CAppWizTest::CreateWin32StaticLib(void)
{

	LOGTESTHEADER("CreateWin32StaticLib");
}

void CAppWizTest::CreateXboxGame(void)
{
	LOGTESTHEADER("CreateXboxGame");
	// set the options for the exe project we are building for this test.
	CXboxGameOptions *pOptions = new(CXboxGameOptions);
	pOptions->m_strLocation = TMP_PROJ_DIR;
	pOptions->m_strName = "CreateXboxGame";
	
	// create the exe project.
	RemovePreExistingProject(pOptions);
	EXPECT_SUCCESS(prj.New(pOptions));
	SafeCloseProject();
}

void CAppWizTest::CreateXboxStaticLib(void)
{
	LOGTESTHEADER("CreateXboxStaticLib");
	// set the options for the exe project we are building for this test.
	CXboxStaticLibOptions *pOptions = new(CXboxStaticLibOptions);
	pOptions->m_strLocation = TMP_PROJ_DIR;
	pOptions->m_strName = "CreateXboxStaticLib";
	
	// create the exe project.
	RemovePreExistingProject(pOptions);
	EXPECT_SUCCESS(prj.New(pOptions));
	SafeCloseProject();
}

void CAppWizTest::CreateAndBuildXboxStaticLib(void)
{
	LOGTESTHEADER("CreateAndBuildXboxStaticLib");
	// set the options for the exe project we are building for this test.
	CXboxStaticLibOptions *pOptions = new(CXboxStaticLibOptions);
	pOptions->m_strLocation = TMP_PROJ_DIR;
	pOptions->m_strName = "CreateAndBuildXboxStaticLib";

	// create the exe project.
	RemovePreExistingProject(pOptions);
	EXPECT_SUCCESS(prj.New(pOptions));

	// where is the common stuff?
	CString cstrXDK;
	GetEnvironmentVariable("XDK", cstrXDK.GetBufferSetLength(1024), 1024);
	cstrXDK.ReleaseBuffer();

	EXPECT_SUCCESS(prj.AddFiles(cstrXDK + "\\Samples\\Xbox\\Common\\Src\\xbapp.cpp"));
	EXPECT_SUCCESS(prj.AddFiles(cstrXDK + "\\Samples\\Xbox\\Common\\Src\\xbfont.cpp"));
	EXPECT_SUCCESS(prj.AddFiles(cstrXDK + "\\Samples\\Xbox\\Common\\Src\\xbhelp.cpp"));
	EXPECT_SUCCESS(prj.AddFiles(cstrXDK + "\\Samples\\Xbox\\Common\\Src\\xbutil.cpp"));
	EXPECT_SUCCESS(prj.AddFiles(cstrXDK + "\\Samples\\Xbox\\Common\\Src\\xbinput.cpp"));
	EXPECT_SUCCESS(prj.AddFiles(cstrXDK + "\\Samples\\Xbox\\Common\\Src\\xbmesh.cpp"));
	EXPECT_SUCCESS(prj.AddFiles(cstrXDK + "\\Samples\\Xbox\\Common\\Src\\xbresource.cpp"));

	prj.SetProjProperty(CT_COMPILER, CL_IDC_ADD_INCLUDE, cstrXDK + "\\Samples\\Xbox\\Common\\Include");
	EXPECT_SUCCESS(prj.Build());
	EXPECT_SUCCESS(prj.VerifyBuild());

	// try the release configuration
	EXPECT_SUCCESS(prj.SetTarget(pOptions->m_strName + " - Xbox Release"));

	prj.SetProjProperty(CT_COMPILER, CL_IDC_ADD_INCLUDE, cstrXDK + "\\Samples\\Xbox\\Common\\Include");
	EXPECT_SUCCESS(prj.Build());
	EXPECT_SUCCESS(prj.VerifyBuild());

	SafeCloseProject();
}

#define STATIC_LIB			"CreateAndBuildXboxStaticLib"
#define STATIC_LIB_DBG_DIR	TMP_PROJ_DIR "\\" STATIC_LIB "\\Debug"
#define STATIC_LIB_DBG		STATIC_LIB_DBG_DIR "\\" STATIC_LIB ".lib"

void CAppWizTest::UseStaticLibDebug(void)
{
	// make sure we have a lib to link to
	FILE *f = fopen(STATIC_LIB_DBG, "r");
	if (!f)
	{
		CreateAndBuildXboxStaticLib();
		f = fopen(STATIC_LIB_DBG, "r");
		if (!f)
			return;
	}
	fclose(f);

	LOGTESTHEADER("UseStaticLibDebug");
	// set the options for the exe project we are building for this test.
	CXboxGameOptions *pOptions = new(CXboxGameOptions);
	pOptions->m_strLocation = TMP_PROJ_DIR;
	pOptions->m_strName = "UseStaticLibDebug";

	// create the exe project.
	RemovePreExistingProject(pOptions);
	EXPECT_SUCCESS(prj.New(pOptions));

	// where is the common stuff?
	CString cstrXDK;
	GetEnvironmentVariable("XDK", cstrXDK.GetBufferSetLength(1024), 1024);
	cstrXDK.ReleaseBuffer();

	EXPECT_SUCCESS(prj.AddFiles(cstrXDK + "\\Samples\\Xbox\\Graphics\\Cartoon\\cartoon.cpp"));

	// add include path
	prj.SetProjProperty(CT_COMPILER, CL_IDC_ADD_INCLUDE, cstrXDK + "\\Samples\\Xbox\\Common\\Include");

	// add library
	CString strDefaultLibs = prj.GetProjProperty(CT_LINKER, LNK_IDC_MODULES);
	prj.SetProjProperty(CT_LINKER, LNK_IDC_MODULES, strDefaultLibs + STATIC_LIB + ".lib");	
	prj.SetProjProperty(CT_LINKER, LNK_IDC_ADDL_LIB_PATH, STATIC_LIB_DBG_DIR);

	// turn off autocopy
	EXPECT_SUCCESS(prj.SetProjProperty(CT_IMAGEBLD, IMAGEBLD_IDC_AUTOCOPY_OFF, 1));
	EXPECT_SUCCESS(prj.Build());
	EXPECT_SUCCESS(prj.VerifyBuild());
	SafeCloseProject();
}

#define STATIC_LIB_REL_DIR	TMP_PROJ_DIR "\\" STATIC_LIB "\\Release"
#define STATIC_LIB_REL		STATIC_LIB_REL_DIR "\\" STATIC_LIB ".lib"

void CAppWizTest::UseStaticLibRelease(void)
{
	// make sure we have a lib to link to
	FILE *f = fopen(STATIC_LIB_REL, "r");
	if (!f)
	{
		CreateAndBuildXboxStaticLib();
		f = fopen(STATIC_LIB_REL, "r");
		if (!f)
			return;
	}
	fclose(f);

	LOGTESTHEADER("UseStaticLibRelease");
	// set the options for the exe project we are building for this test.
	CXboxGameOptions *pOptions = new(CXboxGameOptions);
	pOptions->m_strLocation = TMP_PROJ_DIR;
	pOptions->m_strName = "UseStaticLibRelease";

	// create the exe project.
	RemovePreExistingProject(pOptions);
	EXPECT_SUCCESS(prj.New(pOptions));

	// set target to release
	prj.SetTarget(pOptions->m_strName + " - Xbox Release");

	// where is the common stuff?
	CString cstrXDK;
	GetEnvironmentVariable("XDK", cstrXDK.GetBufferSetLength(1024), 1024);
	cstrXDK.ReleaseBuffer();

	EXPECT_SUCCESS(prj.AddFiles(cstrXDK + "\\Samples\\Xbox\\Graphics\\Cartoon\\cartoon.cpp"));

	// add include path
	prj.SetProjProperty(CT_COMPILER, CL_IDC_ADD_INCLUDE, cstrXDK + "\\Samples\\Xbox\\Common\\Include");

	// add library
	CString strDefaultLibs = prj.GetProjProperty(CT_LINKER, LNK_IDC_MODULES);
	prj.SetProjProperty(CT_LINKER, LNK_IDC_MODULES, strDefaultLibs + STATIC_LIB + ".lib");	
	prj.SetProjProperty(CT_LINKER, LNK_IDC_ADDL_LIB_PATH, STATIC_LIB_REL_DIR);

	// turn off autocopy
	EXPECT_SUCCESS(prj.SetProjProperty(CT_IMAGEBLD, IMAGEBLD_IDC_AUTOCOPY_OFF, 1));
	EXPECT_SUCCESS(prj.Build());
	EXPECT_SUCCESS(prj.VerifyBuild());
	SafeCloseProject();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\ide\core\appwiz\appwizcase.h ===
///////////////////////////////////////////////////////////////////////////////
//	AppWizcase.h
//

#ifndef __APPWIZCASE_H__
#define __APPWIZCASE_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\IdeTestBase.h"
#include "AppWizsub.h"

///////////////////////////////////////////////////////////////////////////////
//	CDisAsmIDETest class

class CAppWizTest : public CIdeTestBase
{
	DECLARE_TEST(CAppWizTest, CAppWizSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);

// Test Cases
	void CreateWin32App(void);
	void CreateWin32ConsoleApp(void);
	void CreateWin32Dll(void);
	void CreateWin32StaticLib(void);
	void CreateXboxGame(void);
	void CreateXboxStaticLib(void);
	void CreateAndBuildXboxStaticLib(void);
	void UseStaticLibDebug(void);
	void UseStaticLibRelease(void);

	void SafeCloseProject();

private:
	int m_TestNumber;
	int m_TotalNumberOfTests;
	CString m_strLogInfo;
};

#endif //__APPWIZCASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\ide\idetestbase.cpp ===
///////////////////////////////////////////////////////////////////////////////
// IdeTestBase.cpp
//
//	Created by:	MichMa
//	Date:		3/30/98
//
//	Description: Definition of base class for all debugger tests.


#include "stdafx.h"
#include "IdeTestBase.h"
#include "guitarg.h"
#include "xboxdbg.h"

// emmang@xbox utility functions
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// GetHkeyFromStr
//
// utility function to map the prefix of a string (either "hklm"
// or "hkcu") to an actual HKEY value
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HKEY GetHkeyFromStr(CString cstr)
{
   cstr.MakeLower();
   if (cstr.Left(4) == "hklm")
	   return HKEY_LOCAL_MACHINE;
   else if (cstr.Left(4) == "hkcr")
	   return HKEY_CLASSES_ROOT;
   else
	   return HKEY_CURRENT_USER;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// GetStrFromRegistry
//
// utility function; gets a string value from the registry; if the key
// is not present, return the supplied default instead
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CString GetStrFromRegistry(CString cstrSubKey, CString cstrDefault)
{
	UCHAR szBuf[2048];
	LONG retval;
	ULONG lBufSize = 4096;
	CString cstrTemp = cstrSubKey.Mid(5);

	HKEY hKey;
	cstrTemp = cstrSubKey.Left(cstrSubKey.ReverseFind('\\'));
	cstrTemp = cstrTemp.Mid(5);
	retval = RegOpenKey(GetHkeyFromStr(cstrSubKey), cstrTemp, &hKey);
	if (retval != ERROR_SUCCESS)
		return cstrDefault;

	cstrTemp = cstrSubKey.Mid(cstrSubKey.ReverseFind('\\')+1);
	retval = RegQueryValueEx(hKey, cstrTemp, NULL, NULL, szBuf, &lBufSize);
	if ((retval != ERROR_SUCCESS) || !lBufSize)
	{
		RegCloseKey(hKey);
		return cstrDefault;
	}
	return szBuf;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// GetProgramFilesDir
//
// utility function, returns the Program Files directory
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CString GetProgramFilesDir()
{
	return GetStrFromRegistry(
		"HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\ProgramFilesDir",
		"C:\\Program Files");
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// GetVisualCDir
//
// utility function, returns VC directory
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CString GetVisualCDir()
{
	return GetStrFromRegistry(
		"HKLM\\Software\\Microsoft\\VisualStudio\\6.0\\Products\\Microsoft Visual C++\\ProductDir",
		GetProgramFilesDir() + "\\Microsoft Visual Studio\\VC98");
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// GetVisualStudioCommonDir
//
// utility function, returns Visual Studio's common directory
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CString GetVisualStudioCommonDir()
{
	return GetStrFromRegistry(
		"HKLM\\Software\\Microsoft\\VisualStudio\\6.0\\Setup\\VsCommonDir",
		GetProgramFilesDir() + "\\Microsoft Visual Studio\\Common");
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// GetXboxSdkDir
//
// utility function, returns the Xbox SDK's base directory
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CString GetXboxSdkDir()
{
	TCHAR szSDKDir[1024];
	szSDKDir[0] = 0;
	GetEnvironmentVariable("XDK", szSDKDir, 1024);
	return CString(szSDKDir);
}


IMPLEMENT_DYNAMIC( CSubTestException, CException );

IMPLEMENT_DYNAMIC(CIdeTestBase, CTest)

#define GetSubSuite() ((CIDESubSuite*)m_pSubSuite)

CIdeTestBase::CIdeTestBase(/*int metricID,*/ CIDESubSuite* pSubSuite, LPCSTR szName, int nExpectedCompares, LPCSTR szListFilename /*= NULL*/)
: CTest(/*metricID,*/ pSubSuite, szName, nExpectedCompares, szListFilename)
{
}

BOOL CIdeTestBase::SetXboxProject(LPCSTR projName, PROJECT_FLAGS flags /* fDefault */, LPCSTR cfgName /*NULL*/)
{
	const char* const THIS_FUNCTION = "SetXboxProject()";
	CString projPathAndName = projName;
	int iName = projPathAndName.ReverseFind('\\');
	if (iName < 0)
	{
		m_strProjectDir = FullPath("src");
		m_strProjectName = projName;
	}
	else
	{
		m_strProjectDir = (CString)FullPath("src") + "\\" + projPathAndName.Left(iName);
		m_strProjectName = projPathAndName.Mid(iName + 1);
	}

	// TODO: copy stuff to new directory and do work there
	// CreateDirectory(TMP_PROJ_DIR);

	KillFiles(m_strProjectDir, "*.opt");
	KillFiles(m_strProjectDir, "*.xbe");
	KillFiles(m_strProjectDir, "*.exe");
	KillFiles(m_strProjectDir, "*.obj");
	KillFiles(m_strProjectDir, "*.ilk");
	KillFiles(m_strProjectDir, "*.ncb");
	KillFiles(m_strProjectDir, "*.plg");

	CIDESubSuite* pSubSuite=GetSubSuite();
	ASSERT(pSubSuite->IsKindOf(RUNTIME_CLASS(CIDESubSuite))); //our tests are IDE tests only
	// build the path, lib, and include environment strings.

	CString cstrPathEnv, cstrLibEnv, cstrIncludeEnv;
	pSubSuite->GetIDE()->GetEnvironmentVar(settingPathEnv, cstrPathEnv);
	cstrPathEnv = settingPathEnv + CString("=") +
		GetXboxSdkDir() + "\\Xbox\\Bin;" +
		GetVisualStudioCommonDir() + "\\MsDev98\\Bin;" +
		GetVisualCDir() + "\\Bin;" +
		GetVisualStudioCommonDir() + "\\Tools;" +
		GetVisualStudioCommonDir() + "\\Tools\\WINNT;" +
		cstrPathEnv;
	cstrLibEnv = "LIB=" + GetXboxSdkDir() + "\\Xbox\\Lib";
	cstrIncludeEnv = "INCLUDE=" + GetXboxSdkDir() + "\\Xbox\\Include";

	// get windows and system dir and append to path environment string.
	CString cstrWindowsDir, cstrSystemDir;
	// each dir is prepended with a semi-colon as a separator. 
	char chDirBuf[MAX_PATH] = ";";
 	GetWindowsDirectory(&chDirBuf[1], MAX_PATH);	// &chDirBuf[0] = ';'
	cstrWindowsDir = chDirBuf;
	GetSystemDirectory(&chDirBuf[1], MAX_PATH);		// &chDirBuf[0] = ';'
	cstrSystemDir = chDirBuf;
	cstrPathEnv += cstrWindowsDir + cstrSystemDir;

	// nmake's environment block.
	char chNmakeEnv[1024];
	// pointer to navigate through block.
	char *pchNmakeEnv = chNmakeEnv;

	// put the path, lib, and include environment strings into the block.
	// each string is terminated by null.
	strcpy(pchNmakeEnv, cstrPathEnv);
	pchNmakeEnv += strlen(pchNmakeEnv) + 1;
	strcpy(pchNmakeEnv, cstrLibEnv);
	pchNmakeEnv += strlen(pchNmakeEnv) + 1;
	strcpy(pchNmakeEnv, cstrIncludeEnv);
	// block is terminated by additional null.
	pchNmakeEnv[strlen(pchNmakeEnv) + 1] = 0;
 
	// to find nmake.exe in the toolset path environment, 
	// we'll use cstrPathFrag to search	for and extract directories
	// from cstrPathEnv	(minus first 5 characters which are "PATH=").
	CString cstrPathFrag = cstrPathEnv.Mid(5);
	// stores dir extracted from cstrPathFrag.
	CString cstrDir;
	// stores index of next semi-colon (dir separator) in cstrPathEnv.
	int indexSemi;
	// handle to nmake.exe returned by FindFirstFile().
	HANDLE hNmake;
	// FindFirstFile param.
	WIN32_FIND_DATA fdFindData;

	while(1)
		
		{
		// find the next semi-colon which terminates the next dir to search.
		indexSemi = cstrPathFrag.Find(';');

		// if a semi-colon was found, extract the dir it terminates. otherwise
		// we are at the final dir in the path environment. 
		if(indexSemi != -1)
			cstrDir = cstrPathFrag.Left(indexSemi);
		else
			cstrDir = cstrPathFrag;
			
		// only want to search dirs at least 3 chars long. for example:
		// path  = C:\;
		// index = 0123
		if(cstrDir.GetLength() >= 3)
			hNmake = FindFirstFile(cstrDir + "\\nmake.exe", &fdFindData);
  		
		// stop searching if nmake was found in cstrPathFrag.
		if(hNmake != INVALID_HANDLE_VALUE)
			break;

		// if no semi-colon was found or it was the last char in the path, 
		// then we just searched the final dir in the environment string, 
		// but still haven't found nmake. 
	 	if((indexSemi == -1) || (cstrPathFrag.GetLength() == (indexSemi + 1)))
			{
			m_pLog->RecordInfo("ERROR in %s: could not find nmake.exe in path environment "
							   "specified by CAFE.", THIS_FUNCTION);
			return FALSE;
			}
		else
			// advance to the start of the next dir after the semi-colon.
			cstrPathFrag = cstrPathFrag.Mid(indexSemi + 1);
		}


	// determine the configuration switch that we need to pass to nmake.
	// also set platform member value for easy access by tests.
	if(cfgName==NULL)
		{
            cfgName = "xbox";
            m_platform = PLATFORM_XBOX;
		}

	// project name and configuration switch we will pass to nmake.
	// we enclose the project name in quotes to support names with spaces.
	CString cstrProjAndConfig = (CString)"\"" + m_strProjectName + ".mak\" CFG=" + cfgName;
	if( UIWB.GetPcodeSwitch() )
		cstrProjAndConfig += " PCODE=yes";
	// CreateProcess() params.
   	STARTUPINFO siStartInfo;
	PROCESS_INFORMATION piProcInfo;
	// this is the minium initialization of STARTUPINFO required for CreateProcess() to work.
	memset(&siStartInfo, 0, sizeof(STARTUPINFO));
	siStartInfo.cb = sizeof(STARTUPINFO);
	siStartInfo.wShowWindow = SW_SHOWDEFAULT;
	// fully qualified nmake.exe cmd line (cstrDir is directory we found nmake in earlier).
	char chNmakeCmdLine[MAX_PATH];
	strcpy(chNmakeCmdLine, cstrDir + "\\nmake.exe /a /f " + cstrProjAndConfig);

	// before spawning nmake make sure Debugger is not running, so vc50.pdb is released
	if(dbg.GetDebugState() != NotDebugging)
		dbg.StopDebugging();

	// Allocate console to be able to see how the project is built.  If we don't allocate it the window close
	// immediately after build process has finished. *dklem
	WaitStepInstructions("Allocating nmake console");
	AllocConsole();
	SetConsoleTitle(chNmakeCmdLine);

	// spawn nmake in the project dir.
	BOOL bRet = CreateProcess(NULL, chNmakeCmdLine, NULL, NULL, TRUE, NORMAL_PRIORITY_CLASS, chNmakeEnv,
							  m_strProjectDir, &siStartInfo, &piProcInfo);
	
	// verify that nmake was successfully spawned.						  
	if(!bRet)
		{
		m_pLog->RecordInfo("ERROR in %s: nmake.exe found but could not be spawned.", THIS_FUNCTION);
		return FALSE;
		}

	// nmake's exit code returned by GetExitCodeProcess().
	DWORD dwNmakeExitCode;

	// wait up to 60 minutes for nmake to terminate.
	for(int i = 0; i < 3600; i++)
		
		{
		Sleep(1000);
		// get nmake's exit code (if it has finished).
		GetExitCodeProcess(piProcInfo.hProcess, &dwNmakeExitCode);
		
		// keep sleeping if nmake is still running.
		if(dwNmakeExitCode != STILL_ACTIVE)
			break;
		}

	// Say good bye to the console
	WaitStepInstructions("Destroying nmake console");
	FreeConsole();

	// verify that nmake finished within the allotted time.
	if(i == 3600)
		{
		m_pLog->RecordInfo("ERROR in %s: after 60 minutes nmake is still running.", THIS_FUNCTION);
		return FALSE;
		}

	// verify that nmake was successful in building the executable.
	if(dwNmakeExitCode != 0)
		{
		m_pLog->RecordInfo("ERROR in %s: nmake.exe returned error code %d.", THIS_FUNCTION, dwNmakeExitCode);
		return FALSE;
		}

	// wait until nmake's window has gone away.
	if(!MST.WFndWndWait(chNmakeCmdLine, FW_NOEXIST, 5))
		{
		m_pLog->RecordInfo("ERROR in %s: after 5 seconds nmake's window still exists.", THIS_FUNCTION);
		return FALSE;
		}

	// stop here if we only want to build.
	if(flags & fBuildOnly)
		return TRUE;

	// project executable
	CString cstrProjectExe = m_strProjectName.Right(m_strProjectName.GetLength() -
							 m_strProjectName.ReverseFind('\\') - 1) + ".xbe";


	// we need to make sure the debugger isn't running on a previous project
	// or COWorkSpace::CloseAllWindows will fail.
	if(dbg.GetDebugState() != NotDebugging)
		dbg.StopDebugging();

	// we need to close all windows before opening the exe or COProject::Open will fail.
 	COWorkSpace ws;
	ws.CloseAllWindows();

	// open the executable.	
	if(prj.Open(m_strProjectDir + "\\" + cstrProjectExe) != ERROR_SUCCESS)
	{
		m_pLog->RecordInfo("ERROR in %s: could not open \"%s\".", THIS_FUNCTION, 
				m_strProjectDir + "\\" + cstrProjectExe);
		return FALSE;
	}

	// set up connection
	if (!XboxSetTarget(REMOTE_XBOX_IP))
	{
		m_pLog->RecordInfo("ERROR in %s: could not set target machine to \"%s\".", THIS_FUNCTION, 
				REMOTE_XBOX_IP);
		return FALSE;
	}
	if (!(XboxCopyToTarget(m_strProjectDir + "\\" + cstrProjectExe)))
	{
		m_pLog->RecordInfo("ERROR in %s: could not copy xbe to target machine \"%s\".", THIS_FUNCTION, 
				REMOTE_XBOX_IP);
		return FALSE;
	}
	if (prj.SetRemotePath(REMOTE_XBOX_FILE) != ERROR_SUCCESS)
	{
		m_pLog->RecordInfo("ERROR in %s: could not set remote path to \"%s\".", THIS_FUNCTION, 
				REMOTE_XBOX_FILE);
		return FALSE;
	}
	prj.SetLocateOtherDLLs(TOGGLE_OFF);
		
	return TRUE;
}


BOOL CIdeTestBase::CreateXboxProjectFromSource(LPCSTR strProjBase, LPCSTR strSrcDir, LPCSTR strSrcFile, LPCSTR strSrcFile2)
{
	// the base name of the localized directories and files we will use.
	if(GetSystem() & SYSTEM_DBCS)
		m_strProjectName = "eXg" + CString(strProjBase) + " xbe";
	else
		m_strProjectName = CString(strProjBase) + " xbe";

	// the location of the unlocalized sources, under which the projects we will use will be located.
	m_strSrcDir = GetCWD() + strSrcDir;
	// the location of the xbe project, and the localized source(s), that we will use for this test.
	m_strProjectDir = CString(TMP_PROJ_DIR) + "\\" + m_strProjectName;

	CreateDirectory(TMP_PROJ_DIR, NULL);

	// clean-up the exe project from the last run.
	KillFiles(m_strProjectDir + "\\Debug\\", "*.*");
	KillFiles(m_strProjectDir + "\\Release\\", "*.*");
	RemoveDirectory(m_strProjectDir + "\\Debug");
	RemoveDirectory(m_strProjectDir + "\\Release");
	KillFiles(m_strProjectDir + "\\", "*.*");
	RemoveDirectory(m_strProjectDir);

	// set the options for the exe project we are building for this test.
	CXboxGameOptions *pXboxGameOpt = new(CXboxGameOptions);
	pXboxGameOpt->m_strLocation = TMP_PROJ_DIR;
	pXboxGameOpt->m_strName = m_strProjectName;
	
	// create the exe project.
	EXPECT_SUCCESS(prj.New(pXboxGameOpt));
	// create a new localized exe source file in the project dir from the unlocalized exe source file.
	CopyFile(m_strSrcDir + "\\" + strSrcFile, m_strProjectDir + "\\" + m_strProjectName + ".cpp", FALSE);
	// make it writable so it can be cleaned up later.
	SetFileAttributes(m_strProjectDir + "\\" + m_strProjectName + ".cpp", FILE_ATTRIBUTE_NORMAL);
	// add the source to the project.

	if (strSrcFile2)
	{
		CopyFile(m_strSrcDir + "\\" + strSrcFile2, m_strProjectDir + "\\" + strSrcFile2, FALSE);
		SetFileAttributes(m_strProjectDir + "\\" + strSrcFile2, FILE_ATTRIBUTE_NORMAL);
	}

	EXPECT_SUCCESS(prj.AddFiles(m_strProjectName + ".cpp"));
	if (ReturnCode)
	{
		LOG->Comment("prj.AddFiles(\"%s\") failed", m_strProjectName + ".cpp");
		return FALSE;
	}
	
	if (strSrcFile2)
	{
		EXPECT_SUCCESS(prj.AddFiles(strSrcFile2));
		if (ReturnCode)
		{
			LOG->Comment("prj.AddFiles(\"%s\") failed", strSrcFile2);
			return FALSE;
		}
	}

	// set the remote path first, so autocopy won't pop up a query
	EXPECT_SUCCESS(prj.SetRemotePath(REMOTE_XBOX_FILE));
	{
		if (ReturnCode)
			return FALSE;
	}

	// build the project.
	EXPECT_SUCCESS(prj.Build());
	
	if (!XboxSetTarget(REMOTE_XBOX_IP))
		return FALSE;

	// no longer needed due to autocopy
	// if (!XboxCopyToTarget())
	//	return FALSE;

	prj.SetLocateOtherDLLs(TOGGLE_OFF);

	return TRUE;
}


#if 0
void CIdeTestBase::RunCases()
{
	// all tests expect the ide to be in this initial state.
	InitTestState();

	// we only want to randomly run each test once.
	RandomNumberCheckList rncl(sizeof(tests) / sizeof(PTR_TEST_FUNC));
	// indexes into the test function array.
	int iTest;
	
	if (CMDLINE->GetValue("random"))
	{
	// randomly run each test once.
	while((iTest = rncl.GetNext()) != -1)
		(this->*(tests[iTest]))();
	}
	else
	{
		for (iTest = 0; iTest < (sizeof(tests) / sizeof(PTR_TEST_FUNC)); iTest++)
			(this->*(tests[iTest]))();
	}
}
#endif


BOOL CIdeTestBase::SetProject(LPCSTR projName, PROJECT_TYPE projType /* PROJECT_EXE */, PROJECT_FLAGS flags /* fDefault */, LPCSTR cfgName /*NULL*/)
{
	if (projType = PROJECT_XBE)
		return SetXboxProject(projName, flags, cfgName);

	const char* const THIS_FUNCTION = "SetProject()";
	CString projPathAndName = projName;
	int iName = projPathAndName.ReverseFind('\\');
	if( iName < 0 )
	{
		m_strProjectDir = FullPath("src");
		m_strProjectName = projName;
	}
	else
	{
		m_strProjectDir = (CString)FullPath("src") + "\\" + projPathAndName.Left(iName);
		m_strProjectName = projPathAndName.Mid(iName + 1);
	}

	KillFiles(m_strProjectDir, "*.opt");
	KillFiles(m_strProjectDir, "*.exe");
	KillFiles(m_strProjectDir, "*.obj");
	KillFiles(m_strProjectDir, "*.ilk");
	KillFiles(m_strProjectDir, "*.ncb");
	KillFiles(m_strProjectDir, "*.plg");

	CIDESubSuite* pSubSuite=GetSubSuite();
	ASSERT(pSubSuite->IsKindOf(RUNTIME_CLASS(CIDESubSuite))); //our tests are IDE tests only
	// build the path, lib, and include environment strings.

	CString cstrPathEnv, cstrLibEnv, cstrIncludeEnv;
	pSubSuite->GetIDE()->GetEnvironmentVar(settingPathEnv, cstrPathEnv);
	cstrPathEnv = settingPathEnv + CString("=") + cstrPathEnv;
	pSubSuite->GetIDE()->GetEnvironmentVar(settingLibEnv, cstrLibEnv);
	cstrLibEnv = settingLibEnv + CString("=") + cstrLibEnv;
	pSubSuite->GetIDE()->GetEnvironmentVar(settingIncludeEnv, cstrIncludeEnv);
	cstrIncludeEnv = settingIncludeEnv + CString("=") + cstrIncludeEnv;

	// get windows and system dir and append to path environment string.
	CString cstrWindowsDir, cstrSystemDir;
	// each dir is prepended with a semi-colon as a separator. 
	char chDirBuf[MAX_PATH] = ";";
 	GetWindowsDirectory(&chDirBuf[1], MAX_PATH);	// &chDirBuf[0] = ';'
	cstrWindowsDir = chDirBuf;
	GetSystemDirectory(&chDirBuf[1], MAX_PATH);		// &chDirBuf[0] = ';'
	cstrSystemDir = chDirBuf;
	cstrPathEnv += cstrWindowsDir + cstrSystemDir;

	// nmake's environment block.
	char chNmakeEnv[1024];
	// pointer to navigate through block.
	char *pchNmakeEnv = chNmakeEnv;

	// put the path, lib, and include environment strings into the block.
	// each string is terminated by null.
	strcpy(pchNmakeEnv, cstrPathEnv);
	pchNmakeEnv += strlen(pchNmakeEnv) + 1;
	strcpy(pchNmakeEnv, cstrLibEnv);
	pchNmakeEnv += strlen(pchNmakeEnv) + 1;
	strcpy(pchNmakeEnv, cstrIncludeEnv);
	// block is terminated by additional null.
	pchNmakeEnv[strlen(pchNmakeEnv) + 1] = 0;
 
	// to find nmake.exe in the toolset path environment, 
	// we'll use cstrPathFrag to search	for and extract directories
	// from cstrPathEnv	(minus first 5 characters which are "PATH=").
	CString cstrPathFrag = cstrPathEnv.Mid(5);
	// stores dir extracted from cstrPathFrag.
	CString cstrDir;
	// stores index of next semi-colon (dir separator) in cstrPathEnv.
	int indexSemi;
	// handle to nmake.exe returned by FindFirstFile().
	HANDLE hNmake;
	// FindFirstFile param.
	WIN32_FIND_DATA fdFindData;

	while(1)
		
		{
		// find the next semi-colon which terminates the next dir to search.
		indexSemi = cstrPathFrag.Find(';');

		// if a semi-colon was found, extract the dir it terminates. otherwise
		// we are at the final dir in the path environment. 
		if(indexSemi != -1)
			cstrDir = cstrPathFrag.Left(indexSemi);
		else
			cstrDir = cstrPathFrag;
			
		// only want to search dirs at least 3 chars long. for example:
		// path  = C:\;
		// index = 0123
		if(cstrDir.GetLength() >= 3)
			hNmake = FindFirstFile(cstrDir + "\\nmake.exe", &fdFindData);
  		
		// stop searching if nmake was found in cstrPathFrag.
		if(hNmake != INVALID_HANDLE_VALUE)
			break;

		// if no semi-colon was found or it was the last char in the path, 
		// then we just searched the final dir in the environment string, 
		// but still haven't found nmake. 
	 	if((indexSemi == -1) || (cstrPathFrag.GetLength() == (indexSemi + 1)))
			{
			m_pLog->RecordInfo("ERROR in %s: could not find nmake.exe in path environment "
							   "specified by CAFE.", THIS_FUNCTION);
			return FALSE;
			}
		else
			// advance to the start of the next dir after the semi-colon.
			cstrPathFrag = cstrPathFrag.Mid(indexSemi + 1);
		}


	// determine the configuration switch that we need to pass to nmake.
	// also set platform member value for easy access by tests.
	if(cfgName==NULL)
	switch(GetUserTargetPlatforms())
		{
        case PLATFORM_WIN32_ALPHA:
            cfgName = "alpha";
            m_platform = PLATFORM_WIN32_ALPHA;
            break;
		case PLATFORM_WIN32_X86:
			cfgName = "x86";
			m_platform = PLATFORM_WIN32_X86;
			break;
		}

	// project name and configuration switch we will pass to nmake.
	// we enclose the project name in quotes to support names with spaces.
	CString cstrProjAndConfig = (CString)"\"" + m_strProjectName + ".mak\" CFG=" + cfgName;
	if( UIWB.GetPcodeSwitch() )
		cstrProjAndConfig += " PCODE=yes";
	// CreateProcess() params.
   	STARTUPINFO siStartInfo;
	PROCESS_INFORMATION piProcInfo;
	// this is the minium initialization of STARTUPINFO required for CreateProcess() to work.
	memset(&siStartInfo, 0, sizeof(STARTUPINFO));
	siStartInfo.cb = sizeof(STARTUPINFO);
	siStartInfo.wShowWindow = SW_SHOWDEFAULT;
	// fully qualified nmake.exe cmd line (cstrDir is directory we found nmake in earlier).
	char chNmakeCmdLine[MAX_PATH];
	strcpy(chNmakeCmdLine, cstrDir + "\\nmake.exe /a /f " + cstrProjAndConfig);

	// before spawning nmake make sure Debugger is not running, so vc50.pdb is released
	if(dbg.GetDebugState() != NotDebugging)
		dbg.StopDebugging();

	// Allocate console to be able to see how the project is built.  If we don't allocate it the window close
	// immediately after build process has finished. *dklem
	WaitStepInstructions("Allocating nmake console");
	AllocConsole();
	SetConsoleTitle(chNmakeCmdLine);

	// spawn nmake in the project dir.
	BOOL bRet = CreateProcess(NULL, chNmakeCmdLine, NULL, NULL, TRUE, NORMAL_PRIORITY_CLASS, chNmakeEnv,
							  m_strProjectDir, &siStartInfo, &piProcInfo);
	
	// verify that nmake was successfully spawned.						  
	if(!bRet)
		{
		m_pLog->RecordInfo("ERROR in %s: nmake.exe found but could not be spawned.", THIS_FUNCTION);
		return FALSE;
		}

	// nmake's exit code returned by GetExitCodeProcess().
	DWORD dwNmakeExitCode;

	// wait up to 60 minutes for nmake to terminate.
	for(int i = 0; i < 3600; i++)
		
		{
		Sleep(1000);
		// get nmake's exit code (if it has finished).
		GetExitCodeProcess(piProcInfo.hProcess, &dwNmakeExitCode);
		
		// keep sleeping if nmake is still running.
		if(dwNmakeExitCode != STILL_ACTIVE)
			break;
		}

	// Say good bye to the console
	WaitStepInstructions("Destroying nmake console");
	FreeConsole();

	// verify that nmake finished within the allotted time.
	if(i == 3600)
		{
		m_pLog->RecordInfo("ERROR in %s: after 60 minutes nmake is still running.", THIS_FUNCTION);
		return FALSE;
		}

	// verify that nmake was successful in building the executable.
	if(dwNmakeExitCode != 0)
		{
		m_pLog->RecordInfo("ERROR in %s: nmake.exe returned error code %d.", THIS_FUNCTION, dwNmakeExitCode);
		return FALSE;
		}

	// wait until nmake's window has gone away.
	if(!MST.WFndWndWait(chNmakeCmdLine, FW_NOEXIST, 5))
		{
		m_pLog->RecordInfo("ERROR in %s: after 5 seconds nmake's window still exists.", THIS_FUNCTION);
		return FALSE;
		}

	// stop here if we only want to build.
	if(flags & fBuildOnly)
		return TRUE;

	// project exe has same base as makefile (i.e. xxx.mak/xxx.exe/xxx.dll)
	// we want to strip out any prepended path and just use the file name
	// because we use this name to set the remote path, and the host
	// path will usually not match the remote path.
	CString cstrProjectExe = m_strProjectName.Right(m_strProjectName.GetLength() -
							 m_strProjectName.ReverseFind('\\') - 1) + 
							 ((projType == PROJECT_EXE) ? ".exe" : ".dll");


	// we need to make sure the debugger isn't running on a previous project
	// or COWorkSpace::CloseAllWindows will fail.
	if(dbg.GetDebugState() != NotDebugging)
		dbg.StopDebugging();

	// we need to close all windows before opening the exe or COProject::Open will fail.
 	COWorkSpace ws;
	ws.CloseAllWindows();

	// open the executable.	
	if(prj.Open(m_strProjectDir + "\\" + cstrProjectExe) != ERROR_SUCCESS)
		{
		m_pLog->RecordInfo("ERROR in %s: could not open \"%s\".", THIS_FUNCTION, 
							m_strProjectDir + "\\" + cstrProjectExe);
		return FALSE;
		}

	// allows us to access ide's connection settings via pconnec.
	COConnection *pconnec = pSubSuite->GetIDE()->GetConnectionInfo();
	
/*	// TODO(michma - 8/12/98): connection stuff has been moved to project settings.
re-enable when support layer has been updated.

	// set the connection as specified by the user.
	if(pconnec->SetAll() != ERROR_SUCCESS)
		{
		m_pLog->RecordInfo("ERROR in %s: could not set connection settings.", THIS_FUNCTION);
		return FALSE;
		}
*/	
	// if indicated, set the remote path and copy the executable to the remote machine.
	if(pconnec->GetUserConnections() != CONNECTION_LOCAL)
		
		{
		if(prj.SetRemotePath(cstrProjectExe) != ERROR_SUCCESS)
			{
			m_pLog->RecordInfo("ERROR in %s: could not set remote path using \"%s\".", 
							   THIS_FUNCTION, cstrProjectExe);
			return FALSE;
			}
		
		if(prj.UpdateRemoteFile(m_strProjectDir + "\\" + cstrProjectExe) != ERROR_SUCCESS)
			{
			m_pLog->RecordInfo("ERROR in %s: could not update remote file using \"%s\".", 
							   THIS_FUNCTION, m_strProjectDir + "\\" + cstrProjectExe);
			return FALSE;
			}
		}
	
	return TRUE;
	}


/*
** start debugging and do some initialization.  
*/

BOOL CIdeTestBase::StartDebugging(void)
{
	BOOL bSuccess; 
	COSource src;	

	bps.ClearAllBreakpoints();		// Clear All Breakpoints Just in case.
	dbg.StepOver(1);				// Start debugging session with initial trace.
	src.AttachActiveEditor();		// WinslowF
	bSuccess = dbg.AtSymbol("WinMain");

	// attach to the editor window the debugger opened
	bSuccess &= src.AttachActiveEditor();

	mem.SetMemoryFormat(MEM_FORMAT_BYTE); 
	dbg.SetSteppingMode(SRC); 		
	return bSuccess;
}


BOOL CIdeTestBase::StopDbgCloseProject(void)
{
	if (dbg.GetDebugState() != NotDebugging)
		dbg.StopDebugging();
	UIWB.CloseAllWindows();
	prj.Close();						

	return TRUE;
}


BOOL CIdeTestBase::VerifyProjectRan(int exitcode /* = 0 */)
{

	// REVIEW: use CODebug::VerifyTermination when it is available.
	// OpenOutputWindow
	UIOutput uow = UIDebug::ShowDockWindow(IDW_OUTPUT_WIN, TRUE);
//	EXPECT( uow.IsActive() );
	// Select the last line, write it to clipboard and look for "exit code 0"
	MST.DoKeys( "^{end}" );
	MST.DoKeys( "{up}" );

	char buffer[10];
	CString	szexcode = "exited with code ";			
	szexcode += itoa(exitcode, buffer, 10 ); // WinslowF - for OEM compatibility now we can specify the exit code to be verified

	if ( UIWB.VerifySubstringAtLine( szexcode ))
	{
		return (TRUE);
	}
	else
	{
		return (FALSE);
	}		
	
	return TRUE;
}


BOOL CIdeTestBase::StepInUntilFrameAdded( CString addframe )
{
	BOOL bResult = TRUE;
	COStack stk;
	CODebug dbg;
	FrameList framelist0;

	// Establish base line
	if(framelist0.CreateFromText( stk.GetAllFunctions() ) == FALSE)
	{
		m_pLog->RecordInfo( "StepInUntilFrameAdded - error retrieving stack frames");
		return FALSE;
	}
	Frame topframe( framelist0[0] );

	while( bResult ) {
		dbg.StepInto();
		FrameList current;
		if(current.CreateFromText( stk.GetAllFunctions() ) == FALSE)
		{
			m_pLog->RecordInfo( "StepInUntilFrameAdded - error retrieving stack frames");
			return FALSE;
		}

		if( current.GetSize() == framelist0.GetSize() ) {
			// Only check function name or image name for top frame.
			CString str0;
			if( topframe.GetFunctionName( str0 ) ) {
				bResult = Frame( current[0] ).Test( str0 );
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameAdded - Mismatch top frame '%s' not in '%s'",
						(LPCTSTR)str0, (LPCTSTR)current[0] );
				}
			}
			else if( topframe.GetImageName( str0 ) ){
				bResult = Frame( current[0] ).Test( str0 );
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameAdded - Mismatch top frame '%s' not in '%s'",
						(LPCTSTR)str0, (LPCTSTR)current[0] );
				}
			}
			else {
				// Bad format
				m_pLog->RecordInfo( "StepInUntilFrameAdded - Bad format for frame '%s'",
					(LPCTSTR)topframe );
				bResult = FALSE;
			}

			// The remaining frames should be identical
			for( int iFrame = 1; bResult && iFrame < framelist0.GetSize(); iFrame++ ) {
				bResult = framelist0[iFrame] == current[iFrame];
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameAdded - Mismatch in frame %d, '%s' != '%s'",
						(LPCTSTR)current[0], (LPCTSTR)framelist0[0] );
				}
			}
		}
		else if( current.GetSize() == framelist0.GetSize() + 1 ) {
			// Test new top frame
			bResult = Frame( current[0] ).Test( addframe );

			// Only check function name or image name for 2nd frame since the line number
			// may change.
			CString str0;
			if( topframe.GetFunctionName( str0 ) ) {
				bResult = Frame( current[1] ).Test( str0 );
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameAdded - Mismatch 2nd frame '%s' not in '%s'",
						(LPCTSTR)str0, (LPCTSTR)current[1] );
				}
			}
			else if( topframe.GetImageName( str0 ) ) {
				bResult = Frame( current[1] ).Test( str0 );
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameAdded - Mismatch 2nd frame '%s' not in '%s'",
						(LPCTSTR)str0, (LPCTSTR)current[1] );
				}
			}
			else {
				// Bad format
				m_pLog->RecordInfo( "StepInUntilFrameAdded - Bad format for frame '%s'",
					(LPCTSTR)topframe );
				bResult = FALSE;
			}

			// The remaining frames should be identical
			for( int iFrame = 1; bResult && iFrame < framelist0.GetSize(); iFrame++ ) {
				bResult = framelist0[iFrame] == current[iFrame+1];
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameAdded - Mismatch in frame %d, '%s' != '%s'",
						(LPCTSTR)current[iFrame+1], (LPCTSTR)framelist0[iFrame] );
				}
			}
			break;	// Get out of loop

		}
		else {
			// Unexpected number of frames
			m_pLog->RecordInfo( "StepInUntilFrameAdded - Expected %d frames, got %d frames",
				framelist0.GetSize() + 1, current.GetSize() );
			bResult = FALSE;
		}
	}

	return bResult;
}

BOOL CIdeTestBase::StepInUntilFrameRemoved() {
	BOOL bResult = TRUE;
	COStack stk;
	CODebug dbg;
	FrameList framelist0;

	// Establish base line
	if(framelist0.CreateFromText( stk.GetAllFunctions() ) == FALSE)
	{
		m_pLog->RecordInfo( "StepInUntilFrameRemoved - error retrieving stack frames");
		return FALSE;
	}
	Frame topframe( framelist0[0] );

	while( bResult ) {
		dbg.StepInto();
		FrameList current;
		if(current.CreateFromText( stk.GetAllFunctions() ) == FALSE)
		{
			m_pLog->RecordInfo( "StepInUntilFrameRemoved - error retrieving stack frames");
			return FALSE;
		}

		//
		// REVIEW: This can be shared with StepInUntilAdded
		//
		if( current.GetSize() == framelist0.GetSize() ) {
			// Only check function name or image name for top frame.
			CString str0;
			if( topframe.GetFunctionName( str0 ) ) {
				CString str1;
				if( topframe.GetParameters( str1 ) ) {
					str0 += "(" + str1 + ")";
				}
				bResult = Frame( current[0] ).Test( str0 );
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameRemoved - Mismatch top frame '%s' not in '%s'",
						(LPCTSTR)str0, (LPCTSTR)current[0] );
				}
			}
			else if( topframe.GetImageName( str0 ) ) {
				bResult = Frame( current[0] ).Test( str0 );
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameRemoved - Mismatch top frame '%s' not in '%s'",
						(LPCTSTR)str0, (LPCTSTR)current[0] );
				}
			}
			else {
				// Bad format
				m_pLog->RecordInfo( "StepInUntilFrameRemoved - Bad format for frame '%s'",
					(LPCTSTR)topframe );
				bResult = FALSE;
			}

			// The remaining frames should be identical
			for( int iFrame = 1; bResult && iFrame < framelist0.GetSize(); iFrame++ ) {
				bResult = framelist0[iFrame] == current[iFrame];
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameRemoved - Mismatch in frame %d, '%s' != '%s'",
						iFrame, (LPCTSTR)current[0], (LPCTSTR)framelist0[0] );
				}
			}
		}
		else if( current.GetSize() == framelist0.GetSize() - 1 ) {
			// The remaining frames should be identical
			for( int iFrame = 0; bResult && iFrame < current.GetSize(); iFrame++ ) {
				bResult = framelist0[iFrame+1] == current[iFrame];
				if( !bResult ) {
					m_pLog->RecordInfo( "StepInUntilFrameRemoved - Mismatch in frame %d, '%s' != '%s'",
						iFrame, (LPCTSTR)current[iFrame], (LPCTSTR)framelist0[iFrame+1] );
				}
			}
			break;	// Get out of loop
		}
		else {
			// Unexpected number of frames
			m_pLog->RecordInfo( "StepInUntilFrameRemoved - Expected %d frames, got %d frames",
				framelist0.GetSize() + 1, current.GetSize() );
			bResult = FALSE;
		}
	}

	return bResult;
}


int ReturnCode =0;
bp  * ReturnBP =0;

void CIdeTestBase::LogResult(int line, int result,LPCSTR szoperation, int code /* 0 */, LPCSTR szComment /* "" */)

	{
	CString szOpCom = (CString)szoperation + "  " + szComment;
	if(result == PASSED)
		m_pLog->RecordSuccess("%s", szOpCom);
	else
		{
		CString szextra;
		char chbuf[24];
		szextra = szextra + "Error Code = " + itoa(code, chbuf, 10);
		m_pLog->RecordFailure("LINE %d %s", line, szextra + szOpCom);
		}
	}


//
//	Returns the current directory of the first time this function was called.
//
LPCSTR CIdeTestBase::HomeDir()
{
	static CString szCurDir;

	if( szCurDir.IsEmpty() )
	{
		char* psz = szCurDir.GetBufferSetLength(_MAX_DIR);

		GetCurrentDirectory(_MAX_DIR - 1, psz);
		szCurDir.ReleaseBuffer(-1);
		if( szCurDir.Right(1) != '\\' )
			szCurDir += "\\";
	}
 	return szCurDir;
}

//
//	Returns the fully qualified path with szAddPath appended to the breadth dir.	
//
LPCSTR CIdeTestBase::FullPath( LPCSTR szAddPath )
{
	static CString szFilespec;

	szFilespec = HomeDir();
	szFilespec += szAddPath;

	return szFilespec;
}


void CIdeTestBase::FillExprInfo(EXPR_INFO &expr_info, 
								 int state, LPCSTR type, LPCSTR name, LPCSTR value)

	{
	expr_info.state = state;
	expr_info.type = type;
	expr_info.name = name;
	expr_info.value = value;
	}


BOOL CIdeTestBase::ExprInfoIs(EXPR_INFO * expr_info_actual, EXPR_INFO * expr_info_expected, 
							   int total_rows /* 1 */)
	
	{
	for(int i = 0; i < total_rows; i++)

		{
		if(expr_info_actual[i].state != expr_info_expected[i].state)
			
			{
			m_pLog->RecordFailure("ERROR in ExprInfoIs(): state is %d instead of %d", 
								  expr_info_actual[i].state, expr_info_expected[i].state);

			return FALSE;
			}

		if(expr_info_actual[i].type != expr_info_expected[i].type)
			
			{
			m_pLog->RecordFailure("ERROR in ExprInfoIs(): type is %s instead of %s", 
								  expr_info_actual[i].type, expr_info_expected[i].type);

			return FALSE;
			}

		if(expr_info_actual[i].name != expr_info_expected[i].name)
			
			{
			m_pLog->RecordFailure("ERROR in ExprInfoIs(): name is %s instead of %s", 
								  expr_info_actual[i].name, expr_info_expected[i].name);

			return FALSE;
			}

		if(expr_info_expected[i].value.Mid(0, 7) != "UNKNOWN") 

			{
			BOOL value_tests_passed;

			if(expr_info_expected[i].value.Mid(0, 7) == "ADDRESS")
				
				{
				value_tests_passed = ValueIsAddress(expr_info_actual[i].value);

				// is extra data besides address expected? (ex. peek at string)
				if(expr_info_expected[i].value != "ADDRESS")
				
					{
					// user must supply extra data to avoid CString assert.
					EXPECT(expr_info_expected[i].value.GetLength() > 8);

					// make sure actual string is long enough so we avoid CString assert.
					if(expr_info_actual[i].value.GetLength() > 10)
					{
						// verify extra data is correct.
						if(expr_info_actual[i].value.Mid(10) ==  (" " + expr_info_expected[i].value.Mid(8)))
							value_tests_passed=TRUE;	
					}
					else
						// actual string wasn't long enough to contain extra data.
						value_tests_passed = FALSE;
					}
				}	 
	
			else	
				value_tests_passed = expr_info_actual[i].value == expr_info_expected[i].value;

			if(!value_tests_passed)
				
				{
				m_pLog->RecordFailure("ERROR in ExprInfoIs(): value is %s instead of %s", 
									  expr_info_actual[i].value, expr_info_expected[i].value);

				return FALSE;
				}
			}
		}

	return TRUE;
	}


BOOL CIdeTestBase::ValueIsAddress(CString str)
	{
	return (str.Mid(0, 2) == "0x") && 
		   (str.Mid(2).SpanIncluding("0123456789abcdef").GetLength() == 8);
	}


void CIdeTestBase::VerifyLocalsWndString(LPCSTR strType, LPCSTR strName,  LPCSTR strValue, int lineNumber)
{
	uivar.Activate();
	EXPECT_TRUE(uivar.SetPane(PANE_LOCALS) == ERROR_SUCCESS);

	EXPR_INFO expr_info;
	uivar.GetAllFields(&expr_info, lineNumber, 1);
	CString csType = expr_info.type;
	CString csName = expr_info.name;
	CString csValue = expr_info.value;


	WriteLog( (csType == strType && csName == strName && 
		csValue.Find(strValue) >= 0) ? PASSED : FAILED,
		"Current Locals line: \"%s %s %s \" Expectation: \"%s %s %s \"", 
		(LPCSTR)csType, (LPCSTR)csName, (LPCSTR)csValue, 
		(LPCSTR)strType, (LPCSTR)strName, (LPCSTR)strValue );
}

BOOL CIdeTestBase::LocalsWndStringIs(LPCSTR strType, LPCSTR strName,  LPCSTR strValue, int lineNumber)
{
	uivar.Activate();
	EXPECT_TRUE(uivar.SetPane(PANE_LOCALS) == ERROR_SUCCESS);
	BOOL ret = FALSE;

	EXPR_INFO expr_info;
	if(uivar.GetAllFields(&expr_info, lineNumber, 1)!=ERROR_SUCCESS)
		return FALSE;
	if(strcmp(strType, expr_info.type)==0 &&
	   strcmp(strName, expr_info.name)==0 &&
	   strstr(strValue,expr_info.value)!=NULL)
		ret = TRUE;

	return ret;
}


BOOL CIdeTestBase::PrepareProject(LPCSTR projName)
{
	const char* const THIS_FUNCTION = "PrepareProject()";
	CString projPathAndName = projName;
	int iName = projPathAndName.ReverseFind('\\');
	if( iName < 0 )
	{
		m_strProjectDir = FullPath("apps");
		m_strProjectName = projName;
	}
	else
	{
		m_strProjectDir = (CString)FullPath("apps") + "\\" + projPathAndName.Left(iName);
		m_strProjectName = projPathAndName.Mid(iName + 1);
	}


	// project exe has same base as makefile (i.e. xxx.mak/xxx.exe/xxx.dll)
	// we want to strip out any prepended path and just use the file name
	// because we use this name to set the remote path, and the host
	// path will usually not match the remote path.
/*	CString cstrProjectExe = m_strProjectName.Right(m_strProjectName.GetLength() -
							 m_strProjectName.ReverseFind('\\') - 1) + 
							 ((projType == PROJECT_EXE) ? ".exe" : ".dll");
*/
	CString cstrProjectExe = m_strProjectName;

	// we need to make sure the debugger isn't running on a previous project
	// or COWorkSpace::CloseAllWindows will fail.
	if(dbg.GetDebugState() != NotDebugging)
		dbg.StopDebugging();

	// we need to close all windows before opening the exe or COProject::Open will fail.
 	COWorkSpace ws;
	ws.CloseAllWindows();

	// open the executable.	
	if(prj.Open(m_strProjectDir + "\\" + cstrProjectExe) != ERROR_SUCCESS)
		{
		m_pLog->RecordInfo("ERROR in %s: could not open \"%s\".", THIS_FUNCTION, 
							m_strProjectDir + "\\" + cstrProjectExe);
		return FALSE;
		}

	CIDESubSuite* pSubSuite=GetSubSuite();
	ASSERT(pSubSuite->IsKindOf(RUNTIME_CLASS(CIDESubSuite))); //our tests are IDE tests only

	// allows us to access ide's connection settings via pconnec.
	COConnection *pconnec = pSubSuite->GetIDE()->GetConnectionInfo();
//	COConnection *pconnec = GetSubSuite()->GetIDE()->GetConnectionInfo();

	// set the connection as specified by the user.
	if(pconnec->SetAll() != ERROR_SUCCESS)
		{
		m_pLog->RecordInfo("ERROR in %s: could not set connection settings.", THIS_FUNCTION);
		return FALSE;
		}
	
	// if indicated, set the remote path and copy the executable to the remote machine.
	if(pconnec->GetUserConnections() != CONNECTION_LOCAL)
		
		{
		if(prj.SetRemotePath(cstrProjectExe) != ERROR_SUCCESS)
			{
			m_pLog->RecordInfo("ERROR in %s: could not set remote path using \"%s\".", 
							   THIS_FUNCTION, cstrProjectExe);
			return FALSE;
			}
		
		if(prj.UpdateRemoteFile(m_strProjectDir + "\\" + cstrProjectExe) != ERROR_SUCCESS)
			{
			m_pLog->RecordInfo("ERROR in %s: could not update remote file using \"%s\".", 
							   THIS_FUNCTION, m_strProjectDir + "\\" + cstrProjectExe);
			return FALSE;
			}
		}
	
	return TRUE;
}


void CIdeTestBase::LogTestHeader(LPCSTR test_desc_str, TestType testtype /* TT_TEST */)
{
	if( testtype == TT_TEST )
		m_pLog->RecordInfo("");
	m_pLog->RecordInfo("");
	CString strTestType;
    switch (testtype)
    {
		case TT_TEST:
			strTestType = "TEST";
			break;

		case TT_SUBTEST:
			strTestType = "SubTest";
			break;

		case TT_TESTCASE:
			strTestType = "TestCase";
			break;
	}

	m_pLog->RecordInfo("%s: %s", strTestType, test_desc_str);
}

void CIdeTestBase::LogTestStartEnd(LPCSTR test_desc_str, StartEndTest startend /* START_TEST */)
{
	CString strTest = "END";

	if( startend == START_TEST)
	{
		strTest = "START";
		m_pLog->RecordInfo("");
	}
 
	strTest += "***TEST";

	m_pLog->RecordInfo("%s: %s", strTest, test_desc_str);
}

void CIdeTestBase::LogTestBegin(LPCSTR test_desc_str)
{
	m_pLog->RecordInfo("");
	m_pLog->RecordInfo("BEGIN***TEST: %s", test_desc_str);
}

void CIdeTestBase::LogTestEnd(LPCSTR test_desc_str)
{
	m_pLog->RecordInfo("END***TEST: %s", test_desc_str);
}

void CIdeTestBase::LogTestEnd(LPCSTR test_desc_str, CTimeSpan elapsed_time, bool timing /* FALSE */)
{
//	GetLog()->RecordInfo("***TEST elapsed time %s", elapsed_time.Format("%H:%M:%S"));
	if( timing )
	{
		m_pLog->RecordInfo("END***TEST: %s  elapsed time %s", test_desc_str, elapsed_time.Format("%H:%M:%S"));
	}
	else
	{
		m_pLog->RecordInfo("END***TEST: %s", test_desc_str);
	}
}

void CIdeTestBase::LogSubTestHeader(LPCSTR test_desc_str)
{
	m_pLog->RecordInfo("");
	m_pLog->RecordInfo("SubTest: %s", test_desc_str);
}


BOOL CIdeTestBase::CopyProjectSources( LPCSTR szSRCFileLoc, LPCSTR szProjLoc )
{
	CString szPattern		= (CString)szSRCFileLoc + "*.*";

	// Copy sources to the project directory
	WIN32_FIND_DATA ffdImgFile;
    HANDLE hFile = FindFirstFile(szPattern, &ffdImgFile);
    if( hFile != INVALID_HANDLE_VALUE )
    {
        do
        {
			CopyFile( (CString)szSRCFileLoc + ffdImgFile.cFileName, (CString)szProjLoc + ffdImgFile.cFileName, FALSE );
			SetFileAttributes((CString)szProjLoc + ffdImgFile.cFileName, FILE_ATTRIBUTE_NORMAL );
		}
        while( FindNextFile(hFile, &ffdImgFile) );
        EXPECT( GetLastError() == ERROR_NO_MORE_FILES );
		return TRUE;
    }
	else
	{
		m_pLog->RecordFailure("Could not copy sources from %s to %s", szSRCFileLoc, szProjLoc);
		return FALSE;
	}
}

void CIdeTestBase::RemoveTestFiles( CString szProjLoc )
{
	KillAllFiles( szProjLoc, TRUE );
}
	
BOOL CIdeTestBase::IsMsgBox(CString strMsg, CString strBtn)
{	
	if( WaitMsgBoxText( strMsg, 10 ) )
	{
		MST.WButtonClick( strBtn );
		return TRUE;
	}
	else
		return FALSE;
}

CString CIdeTestBase::GetBldLog()
{
	CString BuildRecord;
	CString str;
	
	// Get build data
	UIWB.DoCommand(IDM_WINDOW_ERRORS,DC_ACCEL);  // goto output window
	MST.DoKeys("^{END}");			// goto end
	MST.DoKeys("+^{HOME}");			// select whole build record
	MST.DoKeys("^c");				// copy it
	GetClipText(BuildRecord);       // get text from clipboard
	MST.DoKeys("{ESC}");            // return focus from output window
	BuildRecord.MakeLower();
	return (BuildRecord);
	
};


BOOL CIdeTestBase::VerifyBuildOccured( BOOL iBuild )
{
	// iBuild == TRUE  -  project should be rebuilt
	// iBuild == FALSE  -  project should not be rebuilt

	// Get the output window contents
	CString szBldLog = GetBldLog();
	if (szBldLog == "")
	{
		m_pLog->RecordFailure("Incorrect build: Output window is empty");
		return FALSE;
	}

	int iFoundCompiling = szBldLog.Find ("compiling");	// International ?
	int iFoundLinking = szBldLog.Find ("linking");		// International ?

	if( iBuild )
	{
		if( (iFoundCompiling < 0) && (iFoundLinking < 0) )
		{
			m_pLog->RecordFailure("Incorrect build: can't find 'Compiling' or 'Linking");
			return FALSE;
		}
	}
	else
	{
		if ( (iFoundCompiling > 0) || (iFoundLinking > 0) )
		{
			m_pLog->RecordFailure("Nothing change, the project shouldn't be rebuilt.");
			return FALSE;
		}
	}

	return TRUE;
}

int CIdeTestBase::VerifyBuildString( LPCSTR verifyString, BOOL fExist /* TRUE */ )
{
	int iFoundString;

	// Get the output window contents
	CString szBldLog = GetBldLog();
	CString testString = verifyString;

	// For some reason the output window text is always lower case when extracted.

	testString.MakeLower();
	iFoundString = szBldLog.Find(testString);

	if ( (iFoundString < 0) && fExist )
	{
		m_pLog->RecordFailure("Can't find %s", verifyString);
	}
	
	if ( (iFoundString >= 0) && !fExist )
	{
		m_pLog->RecordFailure("Found %s : it should not be there", verifyString);
	}

	return iFoundString;
}

int CIdeTestBase::VerifyDebugOutputString( LPCSTR verifyString, BOOL fExist /* TRUE */ )
{
	int iFoundString;
	CString csLog;
	CString testString = verifyString;

	// Get the output window contents
	// TODO(michma): mismatch with CODebug here. need to merge?
	dbg.SetDebugOutputPane(IDSS_PANE_DEBUG_OUTPUT);
	MST.DoKeys("^{END}");			// goto end
	MST.DoKeys("+^{HOME}");			// select whole build record
	MST.DoKeys("^c");				// copy it
	GetClipText(csLog);       // get text from clipboard
	MST.DoKeys("{ESC}");            // return focus from output window
	csLog.MakeLower();

	// For some reason the output window text is always lower case when extracted.
	testString.MakeLower();
	iFoundString = csLog.Find(testString);

	if ( (iFoundString < 0) && fExist )
	{
		m_pLog->RecordFailure("Can't find %s", verifyString);
	}
	
	if ( (iFoundString >= 0) && !fExist )
	{
		m_pLog->RecordFailure("Found %s : it should not be there", verifyString);
	}

	return iFoundString;
}

CStartEndTest::CStartEndTest(LPCSTR testName, CIdeTestBase *test, bool timing /*=FALSE*/)
{
	m_testName = testName;
	m_Test = test;
	if( timing )
	{
		m_startTime = CTime::GetCurrentTime();
		m_timing = TRUE;
		m_Test->LogTestBegin( m_testName );
	}
}

CStartEndTest::~CStartEndTest()
{
	if( m_timing )
	{
		m_endTime = CTime::GetCurrentTime();
		CTimeSpan elapsed_time(m_endTime - m_startTime);
		m_Test->LogTestEnd( m_testName, elapsed_time, m_timing );
	}
	else
		m_Test->LogTestEnd( m_testName );
}


/*
unused in Xbox
char szecEditTypes[6][256] =
{
	"EC_NO_STACK_FRAME",
	"EC_CURRENT_FRAME_AFTER_IP",
	"EC_CURRENT_FRAME_BEFORE_IP",
	"EC_CURRENT_FRAME_AT_IP", 
	"EC_PARENT_FRAME_AFTER_IP", 
	"EC_PARENT_FRAME_BEFORE_IP"
};

BOOL CIdeTestBase::IsProjectReady(ProjType projType)
{
	switch (projType)
	{
	case PT_EXE:
		m_strProjectName = "ecconsol";
		break;
	case PT_EXT:
		m_strProjectName = "ecwinapp";
		break;
	case PT_INT:
		m_strProjectName = "ecmfcapp";
		break;
	}
	
	m_strSrcDir = "ecapp";	//ToDo: We should get the name from file with all languages strings
	m_strProjectLoc  = m_strCWD + "apps\\" + m_strProjectName + "\\";
	CString szSRCFileLoc	= m_strCWD + "src\\" + m_strSrcDir + "\\";
	CString szProjPathName	= (CString)("..\\apps\\") + m_strProjectName + "\\" + m_strProjectName;

	if (projType == PT_INT)	  // MFC app
		RemoveTestFiles( m_strProjectLoc + "res\\");
	RemoveTestFiles( m_strProjectLoc );
	CreateDirectory(m_strProjectLoc, 0);          
	EXPECT_TRUE( CopyProjectSources( szSRCFileLoc, m_strProjectLoc ) );
	if (projType == PT_INT)	   // MFC app
	{
		CreateDirectory(m_strProjectLoc + "res\\", 0);          
		EXPECT_TRUE( CopyProjectSources( szSRCFileLoc + "res\\", m_strProjectLoc + "res\\" ) );
	}
	if (projType == PT_EXE)	   // EXE consol app
	{
		if( SetProject(szProjPathName) )
			return TRUE;
	}
	else
	{
		int iWaitForBuild = 3;	// Minutes to wait for the build to complete
		if( PrepareProject(szProjPathName) && VERIFY_TEST_SUCCESS( prj.Build(iWaitForBuild)))
		{
			prj.SetExeForDebugSession(m_strProjectName + ".exe");
			return TRUE;
		}
	}
	return FALSE;
}


LPCSTR CIdeTestBase::GetThreadIDStr(LPCSTR szThreadIDVar)

{
	static char szText[12] = "";
	DWORD dwThreadID;
	
	if(!cxx.GetExpressionValue(szThreadIDVar, &dwThreadID))
	{
		LOG->RecordInfo("CIdeTestBase::GetThreadIDStr - GetExpressionValue failed.");
		return (LPCSTR)szText;
	}

	sprintf(szText, "%.8x", dwThreadID);
	return (LPCSTR)szText;
}
*/


void CleanUp(LPCSTR szDirName)

{
	CString strPath;
	//strPath = (CString)"src\\" + szDirName + "\\";
	if (szDirName[0] != '\\')
		strPath = CString(TMP_PROJ_DIR) + "\\" + szDirName + "\\";
	else
		strPath = szDirName;

	KillFiles(strPath + "*.dsp");
	KillFiles(strPath + "*.dsw");
	KillFiles(strPath + "*.opt");
	KillFiles(strPath + "*.plg");
	KillFiles(strPath + "*.ncb");
	KillFiles(strPath + "*.mak");
	KillFiles(strPath + "*.lnk");
	KillFiles(strPath + "*.mdp");
	KillFiles(strPath + "*.pdb");
	KillFiles(strPath + "*.obj");
	KillFiles(strPath + "*.ilk");
	KillFiles(strPath + "*.dll");
	KillFiles(strPath + "*.exe");
	KillFiles(strPath + "*.xbe");
}


void KillFiles(LPCSTR szPathName, LPCSTR szFileName /* NULL */)

{
	WIN32_FIND_DATA ffdImgFile;
	HANDLE hFile;
	CString str, strPattern, strPath = szPathName;

	if(szFileName != NULL)
		
	{
		if((strPath.Right(1) != "\\") && (szFileName[0] != '\\'))
			strPath += "\\";

		strPattern = strPath + szFileName; 
	}

	else
		strPattern = strPath;

	hFile = FindFirstFile(strPattern, &ffdImgFile);
	
	if(hFile != INVALID_HANDLE_VALUE)
	{
		do
		{
			str = strPath + ffdImgFile.cFileName;
			DeleteFile(str);
		} while(FindNextFile(hFile, &ffdImgFile));
	}

	FindClose(hFile);
}


CString CIdeTestBase::FindInPath(LPCSTR szAppName)
{
	CIDESubSuite* pSubSuite=GetSubSuite();

	CString cstrPathEnv;
	pSubSuite->GetIDE()->GetEnvironmentVar(settingPathEnv, cstrPathEnv);
	cstrPathEnv = settingPathEnv + CString("=") + cstrPathEnv;

	// get windows and system dir and append to path environment string.
	CString cstrWindowsDir, cstrSystemDir;
	// each dir is prepended with a semi-colon as a separator. 
	char chDirBuf[MAX_PATH] = ";";
 	GetWindowsDirectory(&chDirBuf[1], MAX_PATH);	// &chDirBuf[0] = ';'
	cstrWindowsDir = chDirBuf;
	GetSystemDirectory(&chDirBuf[1], MAX_PATH);		// &chDirBuf[0] = ';'
	cstrSystemDir = chDirBuf;
	cstrPathEnv += cstrWindowsDir + cstrSystemDir;

	// environment block.
	char chEnvBlock[1024];
	// pointer to navigate through block.
	char *pch = chEnvBlock;

	// put the path into the block.
	// each string is terminated by null.
	strcpy(chEnvBlock, cstrPathEnv);
 
	// to find our app in the toolset path environment, 
	// we'll use cstrPathFrag to search	for and extract directories
	// from cstrPathEnv	(minus first 5 characters which are "PATH=").
	CString cstrPathFrag = cstrPathEnv.Mid(5);
	// stores dir extracted from cstrPathFrag.
	CString cstrDir;
	// stores index of next semi-colon (dir separator) in cstrPathEnv.
	int indexSemi;
	// handle to nmake.exe returned by FindFirstFile().
	HANDLE hNmake;
	// FindFirstFile param.
	WIN32_FIND_DATA fdFindData;

	while(1)
		
		{
		// find the next semi-colon which terminates the next dir to search.
		indexSemi = cstrPathFrag.Find(';');

		// if a semi-colon was found, extract the dir it terminates. otherwise
		// we are at the final dir in the path environment. 
		if(indexSemi != -1)
			cstrDir = cstrPathFrag.Left(indexSemi);
		else
			cstrDir = cstrPathFrag;
			
		// only want to search dirs at least 3 chars long. for example:
		// path  = C:\;
		// index = 0123
		if(cstrDir.GetLength() >= 3)
			hNmake = FindFirstFile(cstrDir + "\\" + szAppName, &fdFindData);
  		
		// stop searching if nmake was found in cstrPathFrag.
		if(hNmake != INVALID_HANDLE_VALUE)
			break;

		// if no semi-colon was found or it was the last char in the path, 
		// then we just searched the final dir in the environment string, 
		// but still haven't found nmake. 
	 	if((indexSemi == -1) || (cstrPathFrag.GetLength() == (indexSemi + 1)))
			{
			m_pLog->RecordInfo("ERROR in %s: could not find %s in path environment "
							   "specified by CAFE.", "CIdeTestBase::FindInPath", szAppName);
			return "";
			}
		else
			// advance to the start of the next dir after the semi-colon.
			cstrPathFrag = cstrPathFrag.Mid(indexSemi + 1);
		}

	return cstrDir;
}

BOOL CIdeTestBase::XboxDebuggerConnect()
{
	BOOL bRetVal = dbg.Go(0, 0, 0, WAIT_FOR_RUN);
	if (!bRetVal)
	{
		m_pLog->RecordInfo("ERROR in %s: unable to start debugger, forcing stop",
						   "CIdeTestBase::XboxDebuggerConnect()");
		dbg.StopDebugging(NOWAIT);
		return FALSE;
	}

	return bRetVal;
}

typedef HRESULT (CALLBACK* LPDMAPI_LPCSTR) (LPCSTR);
typedef HRESULT (CALLBACK* LPDMAPI_LPCSTR_LPCSTR) (LPCSTR, LPCSTR);

BOOL CIdeTestBase::XboxSetTarget(LPCSTR szXbox)
{
	WaitStepInstructions("Calling DmSetXboxName");
	HINSTANCE hXboxDbgDll = LoadLibrary("XboxDbg");
	if (hXboxDbgDll == NULL)
	{
		LOG->RecordInfo("LoadLibrary() failed");
		return FALSE;
	}

	LPDMAPI_LPCSTR pDmSetXboxName = (LPDMAPI_LPCSTR) GetProcAddress(hXboxDbgDll, "DmSetXboxName");
	if (!pDmSetXboxName)
	{
		LOG->RecordInfo("GetProcAddress(\"DmSetXboxName\") failed");
		FreeLibrary(hXboxDbgDll);
		return FALSE;
	}

	HRESULT hr = pDmSetXboxName(REMOTE_XBOX_IP);

	if (FAILED(hr))
	{
		LOG->RecordInfo("XboxSetTarget() failed");
		FreeLibrary(hXboxDbgDll);
		return FALSE;
	}

	FreeLibrary(hXboxDbgDll);
	return TRUE;
}


// copy xbe binary to target
BOOL CIdeTestBase::XboxCopyToTarget(LPCSTR szFileName /* = NULL */)
{
	//const char* const THIS_FUNCTION = "CopyToXboxTarget()";

	// TODO: fix COProject::GetOutputXbeFile

	CString xbeFile = ((szFileName && *szFileName) ? szFileName : 
		(CString(prj.GetDir()) + "\\Debug\\" + CString(prj.GetName()) + ".xbe"));

	CString xbeDir, xbeName;
	int ipos = xbeFile.ReverseFind('\\');
	if (ipos > -1)
	{
		xbeDir = xbeFile.Left(ipos);
		xbeName = xbeFile.Mid(ipos+1);
	}
	else
	{
		xbeName = xbeFile;
	}

	HINSTANCE hXboxDbgDll = LoadLibrary("XboxDbg");
	if (hXboxDbgDll == NULL)
	{
		LOG->RecordInfo("LoadLibrary() failed");
		return FALSE;
	}

	HRESULT hr;

	LPDMAPI_LPCSTR pDmMkdir = (LPDMAPI_LPCSTR) GetProcAddress(hXboxDbgDll, "DmMkdir");
	if (!pDmMkdir)
	{
		LOG->RecordInfo("GetProcAddress(\"DmMkdir\") failed");
		FreeLibrary(hXboxDbgDll);
		return FALSE;
	}

	hr = pDmMkdir(REMOTE_XBOX_DIR);
    /*
	if (FAILED(hr))
	{
		LOG->RecordInfo("XboxCopyToTarget() failed, DmMkdir(\"%s\") returned %08X",
			REMOTE_XBOX_DIR, hr);
		return FALSE;
	}
	*/

	LPDMAPI_LPCSTR_LPCSTR pDmSendFile = (LPDMAPI_LPCSTR_LPCSTR) GetProcAddress(hXboxDbgDll, "DmSendFileA");
	if (!pDmSendFile)
	{
		LOG->RecordInfo("GetProcAddress(\"DmSendFileA\") failed");
		FreeLibrary(hXboxDbgDll);
		return FALSE;
	}

	hr = pDmSendFile(xbeFile, REMOTE_XBOX_FILE);
	if (FAILED(hr))
	{
		LOG->RecordInfo("XboxCopyToTarget() failed, DmSendFile(\"%s\", \"%s\") returned %08X",
			xbeFile, REMOTE_XBOX_FILE, hr);
		return FALSE;
	}

	return TRUE;
}


CString GetRemoteXboxIP()
{
	return CString(CMDLINE->GetTextValue("xbox",
		GetStrFromRegistry("HKCU\\Software\\Microsoft\\XboxSDK\\XboxName",
			"157.56.10.118")));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\ide\idetestbase.h ===
///////////////////////////////////////////////////////////////////////////////
// IdeTestBase.h
//
//  Based on:		DbgTestBase.cpp MichMa 3/30/98
//

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#ifndef __IDETESTBASE_H__
#define __IDETESTBASE_H__

extern int ReturnCode;
extern bp  * ReturnBP;

#define VERIFY_TEST_SUCCESS(TestCase)\
	TestCase == ERROR_SUCCESS

#define EXPECT_TRUE(f)    ((f)?LogResult(__LINE__, PASSED,#f):LogResult(__LINE__, FAILED,#f));
#define EXPECT_FALSE(f)    ((f)?LogResult(__LINE__, FAILED,#f):LogResult(__LINE__, PASSED,#f));
#define EXPECT_SUCCESS(f) (((ReturnCode=(f))==0)?LogResult(__LINE__, PASSED,#f):LogResult(__LINE__, FAILED,#f,ReturnCode));
#define EXPECT_VALIDBP(f) (((ReturnBP=(f))!=NULL)?LogResult(__LINE__, PASSED,#f):LogResult(__LINE__, FAILED,#f));
#define EXPECT_TRUE_COMMENT(f,comment) ((f)?LogResult(__LINE__, PASSED,#f,0,#comment):LogResult(__LINE__, FAILED,#f,0,#comment));

#define ABORT_SUBTEST() THROW( new CSubTestException )

#define EXPECT_SUBTEST_OLD(f)  if(f) { LogResult(__LINE__, PASSED,#f);} \
				else { LogResult(__LINE__, FAILED,#f); ABORT_SUBTEST(); }

#define EXPECT_SUBTEST(f)   if(f) { LogResult(__LINE__, PASSED,#f);} \
							else {LogResult(__LINE__, FAILED,#f); }

#define INFO(txt) WaitStepInstructions(#txt); Sleep (5000);

class CSubTestException : public CException {
	DECLARE_DYNAMIC( CSubTestException );
};

#define InitProject SetProject
#define RestoreFocusToSrcWnd() MST.DoKeys("{ESC}")

enum ProjType
{
	PT_EXE,
	PT_EXT,
	PT_INT
};

enum TestType
{
	TT_TEST,
	TT_SUBTEST,
	TT_TESTCASE
};

enum StartEndTest
{
	START_TEST,
	END_TEST
};

///////////////////////////////////////////////////////////////////////////////
//	class CIdeTestBase used as base for debugging tests

class CIdeTestBase : public CTest

{
	DECLARE_DYNAMIC(CIdeTestBase)
	friend class CStartEndTest;

public:	
	// since this class is a base class for tests, it must have a ctor
	// that takes all test parameters for proper base class initialization
	CIdeTestBase(/*int metricID,*/ CIDESubSuite* pSubSuite, LPCSTR szName, int nExpectedCompares, LPCSTR szListFilename = NULL);

protected: // data
	CString	m_strProjectDir;
	CString	m_strSrcDir;
	CString	m_strProjectName;
	CString	m_strProjectLoc;
	CString	m_szErrorText;
	int m_platform;
	ProjType m_projType;

	COSource src;
	COProject prj;
	CODebug dbg;
	COExpEval cxx;
	COBreakpoints bps;
	COStack stk;
	UIStack uistack;
	UIMemory uimem;
	COMemory mem;
	UIVariables uivar;
	COBrowse browse;
	COFile file;
	UIWatch uiwatch;
	UIQuickWatch uiqw;
	UIDAM uidam;
	UIRegisters uiregs;
	CODAM dam;
	COThreads threads;
	COLocals locals;
	CORegisters regs;
	COExpEval ee;
	COWatch watch;
	COClipboard clipboard;
	COApplication app;
	COAuto coauto;
	COConnection *pConnection;

	typedef enum {PROJECT_EXE, PROJECT_DLL, PROJECT_XBE} PROJECT_TYPE;
	typedef enum {fDefault, fBuildOnly} PROJECT_FLAGS;

	BOOL SetProject(LPCSTR projName, PROJECT_TYPE projType = PROJECT_EXE,
					PROJECT_FLAGS = fDefault, LPCSTR cfgName=NULL);
	BOOL SetXboxProject(LPCSTR projName, PROJECT_FLAGS = fDefault, LPCSTR cfgName=NULL);
	BOOL CreateXboxProjectFromSource(LPCSTR strProjBase, LPCSTR strSrcDir,
		LPCSTR strSrcFile, LPCSTR strSrcFile2 = 0);
#if 0
	virtual void InitTestState() { dbg.StopDebugging(); dbg.StepOver(); }
	void RunCases();
#endif

	BOOL PrepareProject(LPCSTR projName);
	BOOL IsProjectReady(ProjType projType);
	BOOL StartDebugging(void);
	BOOL StopDbgCloseProject(void);
	BOOL VerifyProjectRan(int exitcode = 0);
	BOOL StepInUntilFrameAdded(CString addframe);
	BOOL StepInUntilFrameRemoved(void);

	// shorthand method of filling EXPR_INFO object.
	void FillExprInfo(EXPR_INFO &expr_info, int state, LPCSTR type, LPCSTR name, LPCSTR value);

	// compares two EXPR_INFO objects
	BOOL ExprInfoIs(EXPR_INFO * expr_info_actual, EXPR_INFO * expr_info_expected, 
					int total_rows = 1);

	// tells whether string represents an address as displayed in an ee window.
	// for example: 0x1234abcd "xyz"
	// support function for ExprInfoIs()
	BOOL ValueIsAddress(CString str);
	LPCSTR GetThreadIDStr(LPCSTR szThreadIDVar);

	void LogResult(int line, int result,LPCSTR szoperation, int code=0, LPCSTR szComment="");
	LPCSTR HomeDir(void);
	LPCSTR FullPath(LPCSTR szAddPath);

	void LogTestHeader(LPCSTR test_desc_str, TestType testtype = TT_TEST);
	void LogTestStartEnd(LPCSTR test_desc_str, StartEndTest startend = START_TEST);
	void LogSubTestHeader(LPCSTR test_desc_str);
	void LogTestBegin(LPCSTR test_desc_str);
	void LogTestEnd(LPCSTR test_desc_str);
	void LogTestEnd(LPCSTR test_desc_str, CTimeSpan elapsed_time, bool timing);

	void VerifyLocalsWndString(LPCSTR strType, LPCSTR strName,  LPCSTR strValue, int lineNumber = 1);
	BOOL LocalsWndStringIs(LPCSTR strType, LPCSTR strName,  LPCSTR strValue, int lineNumber = 1);

	CString GetBldLog();
	BOOL VerifyBuildOccured( BOOL iBuild );
	int VerifyBuildString( LPCSTR verifyString, BOOL fExist = TRUE );
	int VerifyDebugOutputString( LPCSTR verifyString, BOOL fExist = TRUE  );

	//unused in xbox - void VerifyECSuccess();
	//unused in xbox - void VerifyECCompileError();
	//unused in xbox - void VerifyECUnsupportedEdit();
	

	BOOL CopyProjectSources( LPCSTR szSRCFileLoc, LPCSTR szProjLoc );
	void RemoveTestFiles( CString szProjLoc );

	//unused in xbox - BOOL ModifyCodeLine(LPCSTR szFind, LPCSTR szReplace);
	//unused in xbox - BOOL ModifyCode(LPCSTR szFind, LPCSTR szReplace, int nLines = 1);
	BOOL IsMsgBox(CString strMsg, CString strBtn);

	// emmang ADDITION Xbox-specific methods
	CString FindInPath(LPCSTR szAppName);
	BOOL XboxSetTarget(LPCSTR szXbox);
	BOOL XboxDebuggerConnect();
	BOOL XboxCopyToTarget(LPCSTR strXbePath = NULL);
	CString XboxGetTarget();
};


class CStartEndTest
{

public:	
	// since this class is a base class for tests, it must have a ctor
	// that takes all test parameters for proper base class initialization
	CStartEndTest(LPCSTR testName, CIdeTestBase *test, bool timing = FALSE);
	~CStartEndTest();

protected: // data
	CString	m_testName;
	bool m_timing;
	CTime m_startTime;
	CTime m_endTime;
	CIdeTestBase *m_Test;
};


void CleanUp(LPCSTR szDirName);
void KillFiles(LPCSTR szPathName, LPCSTR szFileName = NULL);
CString GetRemoteXboxIP();

extern char szecEditTypes[6][256];

// Xbox additions

#define REMOTE_XBOX_IP     GetRemoteXboxIP()
#define REMOTE_XBOX_DIR    "e:\\cafe6"
#define REMOTE_XBOX_FILE   REMOTE_XBOX_DIR "\\dbgtest.xbe"

#define TMP_PROJ_DIR       "c:\\cafe6tmp"

CString GetStrFromRegistry(CString cstrSubKey, CString cstrDefault);

#endif	// __IDETESTBASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\ide\core\appwiz\appwizsub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CDisAsmSubSuite class
//

#include "stdafx.h"
#include "AppWizsub.h"
#include "afxdllx.h"
#include "..\..\IdeTestBase.h"

#include "AppWizcase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CDisAsmSubSuite

IMPLEMENT_SUBSUITE(CAppWizSubSuite, CIDESubSuite, "IDE AppWizard", "emmang@xbox.com")

BEGIN_TESTLIST(CAppWizSubSuite)
	TEST(CAppWizTest, RUN)
END_TESTLIST()

void CAppWizSubSuite::CleanUp(void)
	{
	::CleanUp("testgo01");
	}

///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization

void CAppWizSubSuite::SetUp(BOOL bCleanUp)

{
	CIDESubSuite::SetUp(bCleanUp);
	// TODO(michma - 9/2/98): re-enable when memory leak bugs are fixed.
	ExpectedMemLeaks(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\ide\core\appwiz\appwizsub.h ===
///////////////////////////////////////////////////////////////////////////////
//	AppWizsub.h
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CDisAsmSubSuite class

class CAppWizSubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CAppWizSubSuite)
//	CDisAsmSubSuite() { m_strName = "TestWizard Generated script"; m_strOwner = "VCBU QA"; }


	DECLARE_TESTLIST()
protected:
	void CleanUp(void);
	void SetUp(BOOL bCleanUp);
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\ide\core\bldxquake\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			:
//		VCBU QA		
//
//	Description :
//		source file that includes just the standard include
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\ide\core\bldxquake\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		VCBU QA		
//
//	Description :
//		Precompiled header for the test
//
//		Includes core CAFE headers, as contained in the utility headers
//		for the Workbench and all of the workbench's areas.
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#include "test.h"
#include "subsuite.h"
#include "support.h"


#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\ide\core\bldxquake\bldxquakecase.h ===
///////////////////////////////////////////////////////////////////////////////
//	BldXQuakecase.h
//

#ifndef __APPWIZCASE_H__
#define __APPWIZCASE_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "..\..\IdeTestBase.h"
#include "BldXQuakesub.h"

///////////////////////////////////////////////////////////////////////////////
//	CDisAsmIDETest class

class CBldXQuakeTest : public CIdeTestBase
{
	DECLARE_TEST(CBldXQuakeTest, CBldXQuakeSubSuite)

// Operations
public:
	virtual void PreRun(void);
	virtual void Run(void);

// Test Cases
	void BuildXQuake(void);

	void SafeCloseProject();

private:
	int m_TestNumber;
	int m_TotalNumberOfTests;
	CString m_strLogInfo;
};

#endif //__APPWIZCASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\ide\core\bldxquake\bldxquakesub.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	SNIFF.CPP
//
//	Created by :			
//		VCBU QA		
//
//	Description :
//		implementation of the CDisAsmSubSuite class
//

#include "stdafx.h"
#include "BldXQuakesub.h"
#include "afxdllx.h"
#include "..\..\IdeTestBase.h"

#include "BldXQuakecase.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CDisAsmSubSuite

IMPLEMENT_SUBSUITE(CBldXQuakeSubSuite, CIDESubSuite, "BldXQuake", "emmang@xbox.com")

BEGIN_TESTLIST(CBldXQuakeSubSuite)
	TEST(CBldXQuakeTest, RUN)
END_TESTLIST()

void CBldXQuakeSubSuite::CleanUp(void)
	{
	::CleanUp("testgo01");
	}

///////////////////////////////////////////////////////////////////////////////
//	SubSuite initialization

void CBldXQuakeSubSuite::SetUp(BOOL bCleanUp)

{
	CIDESubSuite::SetUp(bCleanUp);
	// TODO(michma - 9/2/98): re-enable when memory leak bugs are fixed.
	ExpectedMemLeaks(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\ide\core\bldxquake\bldxquakecase.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	BldXQuakeCase.CPP
//											 
//	Created by :			
//		dklem
//
//	Description :								 
//		TestWizard Generated script		 

#include "stdafx.h"
#include "BldXQuakeCase.h"
//#include "coprject.h"	
//#include "process.h"
#include "xboxdbg.h"

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
				 	 
											   
IMPLEMENT_TEST(/*999,*/ CBldXQuakeTest, CIdeTestBase, "General", -1, CBldXQuakeSubSuite)

// each function that runs a test has this prototype.
typedef void (CBldXQuakeTest::*PTR_TEST_FUNC)(void); 

// Information about a test to be put in the test header
#define LOGTESTHEADER(strTestName) 	m_strLogInfo.Format("# - %d.  %s. Total # - %d, Passed - %d %%", ++m_TestNumber, strTestName, m_TotalNumberOfTests, (m_TestNumber*100)/m_TotalNumberOfTests);  \
									LogTestHeader(m_strLogInfo);

void CBldXQuakeTest::PreRun(void)
{
	// call the base class
	CTest::PreRun();

}

void CBldXQuakeTest::Run()
{
	CreateDirectory(TMP_PROJ_DIR, NULL);
	BuildXQuake();
}	

void RemovePreExistingProject(CProjWizOptions *pOptions)
{
	CString strDir = pOptions->m_strLocation + "\\" + pOptions->m_strName;

	KillFiles(strDir + "\\Debug\\", "*.*");
	KillFiles(strDir + "\\Release\\", "*.*");
	RemoveDirectory(strDir + "\\Debug");
	RemoveDirectory(strDir + "\\Release");
	KillFiles(strDir + "\\", "*.*");
	RemoveDirectory(strDir);
}

void CBldXQuakeTest::SafeCloseProject()
{
	if (prj.IsOpen())
		prj.Close();
	else
	{
		LOG->RecordFailure("Possible failure to create project %s", prj.GetName());
		MST.DoKeys("+{B}+{B}+{B}{ESC}");
	}
}

///////////////////////////////////////////////////////////////////////////////
//	Test Cases
///////////////////////////////////////////////////////////////////////////////

#define QUAKE_PROJ_NAME		"XQuake"
#define QUAKE_ROOT			REMOTE_XBOX_DIR "\\" QUAKE_PROJ_NAME
#define QUAKE_MEDIA			QUAKE_ROOT "\\media"
#define QUAKE_DBG_XBE		QUAKE_ROOT "\\" QUAKE_PROJ_NAME "D.xbe"
#define QUAKE_RLS_XBE		QUAKE_ROOT "\\" QUAKE_PROJ_NAME "R.xbe"

void CBldXQuakeTest::BuildXQuake(void)
{
	LOGTESTHEADER("BuildXQuake");

	// set the options for the exe project we are building for this test.
	CXboxGameOptions *pOptions = new(CXboxGameOptions);
	pOptions->m_strLocation = TMP_PROJ_DIR;
	pOptions->m_strName = QUAKE_PROJ_NAME;

	// create the exe project.
	RemovePreExistingProject(pOptions);
	EXPECT_SUCCESS(prj.New(pOptions));

	// where are the files?
	CString cstrNTDrive;
	GetEnvironmentVariable("_NTDRIVE", cstrNTDrive.GetBufferSetLength(1024), 1024);
	cstrNTDrive.ReleaseBuffer();

	CString cstrNTRoot;
	GetEnvironmentVariable("_NTROOT", cstrNTRoot.GetBufferSetLength(1024), 1024);
	cstrNTRoot.ReleaseBuffer();

	CString cstrSources;
	cstrSources = cstrNTDrive + cstrNTRoot + "\\private\\test\\games\\xquake";

	CFileFind finder;
	BOOL bWorking = finder.FindFile(cstrSources + "\\*.cpp");
	while (bWorking)
	{
		bWorking = finder.FindNextFile();
		EXPECT_SUCCESS(prj.AddFiles(finder.GetFilePath()));
	}

	bWorking = finder.FindFile(cstrSources + "\\*.c");
	while (bWorking)
	{
		bWorking = finder.FindNextFile();
		if (finder.GetFileName() != CString("net_ipx.c"))
		EXPECT_SUCCESS(prj.AddFiles(finder.GetFilePath()));
	}

	bWorking = finder.FindFile(cstrSources + "\\*.h");
	while (bWorking)
	{
		bWorking = finder.FindNextFile();
		EXPECT_SUCCESS(prj.AddFiles(finder.GetFilePath()));
	}

	////////////////////////////////////////////////////////////
	// build debug
	//
	EXPECT_SUCCESS(prj.SetTarget(QUAKE_PROJ_NAME " - Xbox Debug"));

	// set defines
	CString strDefines = prj.GetProjProperty(CT_COMPILER, CL_IDC_PREPROC_DEF);
	prj.SetProjProperty(CT_COMPILER, CL_IDC_PREPROC_DEF,
		strDefines + ",XBOX,NO_ASSEMBLY,NO_MGRAPH,GLQUAKE,D3DQUAKE");	

	// add include path
	prj.SetProjProperty(CT_COMPILER, CL_IDC_ADD_INCLUDE, cstrSources);

	// add library
	CString strDefaultLibs = prj.GetProjProperty(CT_LINKER, LNK_IDC_MODULES);
	prj.SetProjProperty(CT_LINKER, LNK_IDC_MODULES,
		strDefaultLibs + "xbdm.lib");	

	// turn off autocopy
	EXPECT_SUCCESS(prj.SetProjProperty(CT_IMAGEBLD, IMAGEBLD_IDC_AUTOCOPY_OFF, 1));
	EXPECT_SUCCESS(prj.Build());
	EXPECT_SUCCESS(prj.VerifyBuild());

	DmMkdir(REMOTE_XBOX_DIR);
	DmMkdir(QUAKE_ROOT);
	DmMkdir(QUAKE_MEDIA);

	CString strXBE = CString(prj.GetDir()) + "Debug\\" QUAKE_PROJ_NAME ".xbe";
	HRESULT hr = DmSendFile(strXBE, QUAKE_DBG_XBE);
	if (hr != XBDM_NOERR)
	{
		LOG->RecordFailure("BuildXQuake() failed, DmSendFile(\"%s\", \"%s\") returned %08X",
			strXBE, QUAKE_DBG_XBE, hr);
		return;
	}


	////////////////////////////////////////////////////////////
	// build release
	//
	EXPECT_SUCCESS(prj.SetTarget("XQuake - Xbox Release"));

	// set defines
	strDefines = prj.GetProjProperty(CT_COMPILER, CL_IDC_PREPROC_DEF);
	prj.SetProjProperty(CT_COMPILER, CL_IDC_PREPROC_DEF,
		strDefines + ",XBOX,NO_ASSEMBLY,NO_MGRAPH,GLQUAKE,D3DQUAKE");	

	// add include path
	prj.SetProjProperty(CT_COMPILER, CL_IDC_ADD_INCLUDE, cstrSources);

	// add library
	strDefaultLibs = prj.GetProjProperty(CT_LINKER, LNK_IDC_MODULES);
	prj.SetProjProperty(CT_LINKER, LNK_IDC_MODULES,
		strDefaultLibs + "xbdm.lib");	

	// turn off autocopy
	EXPECT_SUCCESS(prj.SetProjProperty(CT_IMAGEBLD, IMAGEBLD_IDC_AUTOCOPY_OFF, 1));
	EXPECT_SUCCESS(prj.Build());
	EXPECT_SUCCESS(prj.VerifyBuild());

	strXBE = CString(prj.GetDir()) + "Release\\" QUAKE_PROJ_NAME ".xbe";
	hr = DmSendFile(strXBE, QUAKE_RLS_XBE);
	if (hr != XBDM_NOERR)
	{
		LOG->RecordFailure("BuildXQuake() failed, DmSendFile(\"%s\", \"%s\") returned %08X",
			strXBE, QUAKE_RLS_XBE, hr);
		return;
	}

	CString strXBCP, strXDK;
	GetEnvironmentVariable("XDK", strXDK.GetBufferSetLength(1024), 1024);
	strXDK.ReleaseBuffer();

	strXBCP = "xbcp.exe /r /s /h /y /t /f " + cstrSources + "\\media\\*.* x" QUAKE_MEDIA;
	// CreateProcess() params.
   	STARTUPINFO siStartInfo;
	PROCESS_INFORMATION piProcInfo;
	// this is the minium initialization of STARTUPINFO required for CreateProcess() to work.
	memset(&siStartInfo, 0, sizeof(STARTUPINFO));
	siStartInfo.cb = sizeof(STARTUPINFO);
	siStartInfo.wShowWindow = SW_SHOWDEFAULT;

	// copy any media files needed
	// spawn nmake in the project dir.
	BOOL bRet = CreateProcess(NULL,
		(char *) ((LPCTSTR) strXBCP),
		NULL,
		NULL,
		TRUE,
		NORMAL_PRIORITY_CLASS,
		NULL,
		strXDK,
		&siStartInfo,
		&piProcInfo);
	
	// verify that nmake was successfully spawned.						  
	if(!bRet)
	{
		LPVOID lpMsgBuf;
		FormatMessage( 
			FORMAT_MESSAGE_ALLOCATE_BUFFER | 
			FORMAT_MESSAGE_FROM_SYSTEM | 
			FORMAT_MESSAGE_IGNORE_INSERTS,
			NULL,
			GetLastError(),
			MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
			(LPTSTR) &lpMsgBuf,
			0,
			NULL 
		);

		m_pLog->RecordFailure("XBCP spawn error (%s).\nxbcp = [%s]", lpMsgBuf, strXBCP);
		// Free the buffer.
		LocalFree( lpMsgBuf );
		return;
	}

	SafeCloseProject();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\xtests\ide\core\bldxquake\bldxquakesub.h ===
///////////////////////////////////////////////////////////////////////////////
//	BldXQuakesub.h
//

#ifndef __SNIFF_H__
#define __SNIFF_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// CDisAsmSubSuite class

class CBldXQuakeSubSuite : public CIDESubSuite
{
public:
	DECLARE_SUBSUITE(CBldXQuakeSubSuite)
//	CDisAsmSubSuite() { m_strName = "TestWizard Generated script"; m_strOwner = "VCBU QA"; }


	DECLARE_TESTLIST()
protected:
	void CleanUp(void);
	void SetUp(BOOL bCleanUp);
};

#endif //__SNIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\common\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <tchar.h>

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const TCHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}


//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const TCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const TCHAR *sz = str; *sz; sz = _tcsinc(sz))
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const TCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const TCHAR *sz = str; *sz; sz = _tcsinc(sz))
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const TCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const TCHAR *sz = str; *sz; sz = _tcsinc(sz))
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const TCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
#ifdef _XBOX
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const TCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };

    D3DLOCKED_RECT lockRect;
    if(pSurface->LockRect(&lockRect, NULL, 0L) != S_OK)
    {
        OutputDebugString("BitFont::DrawText() pSurface->LockRect() failed\n");
        return;
    }

    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);


    UINT BitsPerPixel =
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );

    // Relase the lock on the surface
    pSurface->UnlockRect();
#endif
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
#ifdef _XBOX
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
    case D3DFMT_LIN_A8R8G8B8:
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
    case D3DFMT_LIN_X8R8G8B8:
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
    case D3DFMT_LIN_R5G6B5:
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
    case D3DFMT_LIN_X1R5G5B5:
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
    case D3DFMT_LIN_A4R4G4B4:
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
    case D3DFMT_LIN_A1R5G5B5:
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        OutputDebugString("BitFont::DrawText() dwColorFromD3DXColor() invalid surface format\n");
        break;
    }
    return dwColor;
#else
    return 0;
#endif
};

//----------------------------------------------------------------------------
// Map our 'new' directly to LocalAlloc
void* __cdecl operator new(size_t size)
{
    return LocalAlloc(0, size);
}

//----------------------------------------------------------------------------
// Map our 'delete' directly to LocalFree   
VOID __cdecl operator delete(VOID* alloc)
{
    LocalFree(alloc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\common\bounce.h ===
// bounce.h
// definition of CBounce class
//
// CBounce draws a bouncing ball onscreen.  Useful for easily
// determining if an Xbox application is still running 
//
// based on the xpong sample

#ifndef __BOUNCE_H__
#define __BOUNCE_H__

class CBounce
{
    public:
        CBounce();
        void DrawStuff();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\common\bounce.cpp ===
// cbounce.cpp

#include "draw.h"
#include "bounce.h"

#define BallSpeed (.12f)
#define SCRWIDTH 640
#define SCRHEIGHT 480

typedef struct BALL
{
	float x;
	float y;
	float height;
	float width;
	DWORD color;
	float dx;
	float dy;
} BALL;

static BALL b = {SCRWIDTH / 2, SCRHEIGHT / 8, 5, 5, 0xffffff00, -BallSpeed, BallSpeed};

float fabs(float a) { return a < 0 ? -a : a; }
float sign(float a) { return (a == 0) ? (float)0 : (a < 0) ? (float)-1 : (float)1; }

CDraw *g_pDraw;

CBounce::CBounce()
{
    g_pDraw = new CDraw(SCRWIDTH, SCRHEIGHT);
    b.x = SCRWIDTH * .75; b.y = SCRHEIGHT * .9; b.dx = -BallSpeed; b.dy = BallSpeed;

    // clear the screen
	g_pDraw->FillRect(0, 0, SCRWIDTH, SCRHEIGHT, 0xFF000000);
    g_pDraw->Present();
}

void CBounce::DrawStuff()
{
	//g_pDraw->DrawText(__FILE__ " (compiled " __DATE__ " " __TIME__ ")", 0, 0, 0xFFFFFF);

    // erase the ball
    g_pDraw->FillRect((int) b.x, (int) b.y, (int) b.width, (int) b.height, 0xFF000000);

	if (b.y <= 0)
	{
		b.dy = fabs(b.dy);	// make ball bounce off the top of the screen
	}
	else if (b.y >= SCRHEIGHT - b.height)
	{
		b.dy = -fabs(b.dy);	// bounce off the bottom
	}

	if (b.x < 0)			// if ball is off the left edge
	{
		b.dx = fabs(b.dx);	//change x direction
	}
	else if (b.x >= SCRWIDTH - b.width - 1)	// if the ball is off the right edge
	{
		b.dx = -fabs(b.dx);		//change x direction
	}

	// move the ball
	b.x += b.dx;	
	b.y += b.dy;

    // draw the ball
    g_pDraw->FillRect((int) b.x, (int) b.y, (int) b.width, (int) b.height, b.color);

    g_pDraw->Present();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\common\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_

#ifdef _XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

// pack the structure as we're reading it from the disk
#pragma pack(1)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const TCHAR* filename);

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const TCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText
    (
        IDirect3DSurface8 *pSurface,
        const TCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};

#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\common\draw.cpp ===
/*--
Copyright (c) 2000 Microsoft Corporation - Xbox SDK

Module Name:

    Main.cpp

Abstract:

    Simple sample for drawing text on the screen.

Revision History:

    Derived from a DX8 sample.
--*/

#include "draw.h"

//------------------------------------------------------------------------------
// CDraw
//
// Handy little D3D encapsulation for simple 2D drawing.


//------------------------------------------------------------------------------
// CDraw::m_pDevice
//
// Instantiate static class member, initialized to NULL.

IDirect3DDevice8* CDraw::m_pDevice;

//------------------------------------------------------------------------------
// CDraw constructor

CDraw::CDraw(INT width, INT height)
{
    m_pBackBuffer = NULL;

    // If we're invoked multiple times, we inherit the old mode (largely
    // because we don't support multiple mode sets on Xbox yet):

    if (m_pDevice == NULL)
    {
        // Create D3D 8.
    
        IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);
        if (pD3D == NULL)
            return;
    
        // Set the screen mode.
    
        D3DPRESENT_PARAMETERS d3dpp;
        ZeroMemory(&d3dpp, sizeof(d3dpp));
    
        d3dpp.BackBufferWidth           = width;
        d3dpp.BackBufferHeight          = height;
        d3dpp.BackBufferFormat          = D3DFMT_X8R8G8B8;
        d3dpp.BackBufferCount           = 1;
        d3dpp.Windowed                  = false;    // Must be false for Xbox
        d3dpp.EnableAutoDepthStencil    = true;
        d3dpp.AutoDepthStencilFormat    = D3DFMT_D24S8;
        d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;
        d3dpp.FullScreen_RefreshRateInHz= 60;
        d3dpp.hDeviceWindow             = NULL;
    
        // Create the device.
	HRESULT hr = pD3D->CreateDevice
		(
		    D3DADAPTER_DEFAULT,
		    D3DDEVTYPE_HAL,
		    NULL,
		    D3DCREATE_HARDWARE_VERTEXPROCESSING,
		    &d3dpp,
		    &m_pDevice
		);
	if (hr != S_OK)
        {
            pD3D->Release();

            return;
        }
    
        // Now we no longer need the D3D interface so let's free it.
    
        pD3D->Release();
    }

    m_pDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &m_pBackBuffer);
}

//------------------------------------------------------------------------------
// CDraw::~CDraw

CDraw::~CDraw()
{
    if (m_pBackBuffer)
        m_pBackBuffer->Release();
}

//------------------------------------------------------------------------------
// CDraw::FillRect

VOID CDraw::FillRect(
    INT x,
    INT y,
    INT width,
    INT height,
    D3DCOLOR color)
{
    D3DRECT rect;

    if (m_pDevice != NULL)
    {
        rect.x1 = x;
        rect.y1 = y;
        rect.x2 = x + width;
        rect.y2 = y + height;

        m_pDevice->Clear(1, &rect, D3DCLEAR_TARGET, color, 0, 0);
    }
}

//------------------------------------------------------------------------------
// CDraw::DrawText

VOID CDraw::DrawText(
    const TCHAR* string,
    INT x,
    INT y,
    D3DCOLOR foregroundColor,   // 0xff0000 is red
    D3DCOLOR backgroundColor,
    DWORD flags)
{
    if (m_pBackBuffer != NULL)
    {
        m_font.DrawText(m_pBackBuffer, string, x, y, flags, foregroundColor,
                        backgroundColor);
    }
}

//------------------------------------------------------------------------------
// CDraw::Present
//
// Make the current back-buffer visible

VOID CDraw::Present()
{
    if (m_pDevice != NULL)
    {
        m_pDevice->Present(NULL, NULL, NULL, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\dbgfunc\icf.cpp ===
// identical comdat folding

#include "dbgtest.h"

int NonUniqueComdatFunction1(int i1, char c1)
{
    return i1;
}

unsigned int NonUniqueComdatFunction2(unsigned int i2, unsigned char c2)
{
    return i2;
}

void Test_ICF()
{
    NonUniqueComdatFunction1(0, 'A');
    NonUniqueComdatFunction2(0, 'A');
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\dbgfunc\bp.cpp ===
#include "dbgtest.h"

void Test_Breakpoints()
{
    int i = 0;
    int j = 1;

    // set a breakpoint inside this broken-up line
    // thanks to danrose for finding this bug

    i
    =
    i
    +
    1
    ;

    
    while (j)
        ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\dbgfunc\registers.cpp ===
// adapted from \\vsqaauto\vc6snaps\Debugger\Core\src\registers

#include "dbgtest.h"

int Foo(int nArg)
{
	return nArg*2;
}							/* Return from Foo */


//turn off divide by zero compiler warning
#pragma warning(disable: 4723)

void Test_Registers()
{
    /* "err" is one of the magic register names recognized by the */
    /* debugger.  Here we force a conflict by having a local var  */
    /* of the same name */

    int err = 0;
	int fSetFpuCtrlWord = 0;	/* set this to 1 to do exception checks */
	int FpuCtrlWord;
	int res = Foo(7);		/* First line for tests */

	double y = 1e-19;
	_asm fld y;
	
	if (fSetFpuCtrlWord)
	{
		FpuCtrlWord = 0x277;
		__asm { FLDCW FpuCtrlWord }
	}

	float f1;

	/* check Overflow exception */
	f1 = (float) 1.234567e38;
	f1 *= f1;
	f1 *= f1;	/* Exception should be here for CTRL 277 */
	f1 *= f1;

	if (fSetFpuCtrlWord)
	{
		FpuCtrlWord = 0x27B;
		__asm { FLDCW FpuCtrlWord }
	}

	/* check divide by zero exception */
	f1 = 10.;
	f1 /= 0;	/* Exception should be here for CTRL 27B */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\dbgfunc\disasm.cpp ===
// disasm.cpp
// copied/derived from vc6 debugger test source
// \\vsqaauto\vc6snaps\debugger\core\src\disasm pp\disasm pp.cpp

#include "dbgtest.h"

const float FLOAT_ZERO = 0;
__int64 GlobalInt64 = 0;

__int64 FloatVal[] =	//	32 bit register values for each integer
{
	3225419779,		//	-3
	3221225474,		//	-2	
	3212836866,		//	-1
	0,				//	0
	1065353218,		//	1
	1073741826,		//	2
	1077936131,		//	3
	1082130434,		//	4
	1084227586,		//	5
	1086324738,		//	6
	1088421890,		//	7	
	1090519041,		//	8
	1091567617,		//	9
	1092616193		//	10
};

__m128 Var128;

const int FLOATVAL_BASE = -3;

// local functions

void ClearXMMReg(int regid);
void set_GlobalInt64(int Hi, int Low);
void set_XMMRegister(int regid, char upper, int Hi, int Low);
void set_XMMRegister(int regid, int X3, int X2, int X1, int X0);


void set_Register(int regid, __int64 regval);


void set_Register(int regid, __int64 regval)
{
	switch (regid)
	{
		case 0:		__asm { MOVQ MM0, regval }
					break;


		case 1:		__asm { MOVQ MM1, regval }
					break;


		case 2:		__asm { MOVQ MM2, regval }
					break;

		case 3:		__asm { MOVQ MM3, regval }
					break;


		case 4:		__asm { MOVQ MM4, regval }
					break;

		case 5:		__asm { MOVQ MM5, regval }
					break;

		case 6:		__asm { MOVQ MM6, regval }
					break;

		case 7:		__asm { MOVQ MM7, regval }
					break;

	}
}


void Test_Disasm_MMX()
{
	//	MMX tests
	
	__int64 count = 0;
	__int32 iVar32 = 0;

	//	test all registers for visibility
	__asm {	MOVQ MM0,MM1 }
	__asm {	MOVQ MM1,MM2 }
	__asm {	MOVQ MM2,MM3 }
	__asm {	MOVQ MM3,MM4 }
	__asm {	MOVQ MM4,MM5 }
	__asm {	MOVQ MM5,MM6 }
	__asm {	MOVQ MM6,MM7 }
	__asm {	MOVQ MM7,MM0 }

	//	shift left
	__asm {	PSLLW MM0,count }
	__asm {	PSLLW MM0,MM1 }

	//	mov 32 bit
	__asm {	MOVD MM0,iVar32 }
	__asm {	MOVD iVar32,MM0 }
	__asm {	MOVQ MM0,count }	
	__asm {	MOVQ count,MM0 }	

	__asm {	MOVD MM0,eax }
	__asm {	MOVD eax,MM0 }
	__asm {	MOVQ MM0,MM1 }	
	
	//	Pack with Signed Saturation
	__asm {	PACKSSWB MM0,count }
	__asm {	PACKSSDW MM0,count }

	__asm {	PACKSSWB MM0,MM1 }
	__asm {	PACKSSDW MM0,MM1 }

	//	Pack with Unsigned Saturation	
	__asm {	PACKUSWB MM0,count }
	__asm {	PACKUSWB MM0,MM1 }

	//	Packed Add
	__asm {	PADDB MM0,count }
	__asm {	PADDW MM0,count }	
	__asm {	PADDD MM0,count }

	__asm {	PADDB MM0,MM1 }
	__asm {	PADDW MM0,MM1 }	
	__asm {	PADDD MM0,MM1 }

	//	Packed Add with Saturation
	__asm {	PADDSB MM0,count }
	__asm {	PADDSW MM0,count }

	__asm {	PADDSB MM0,MM1 }
	__asm {	PADDSW MM0,MM1 }

	//	Packed Add Unsigned with Saturation 
	__asm {	PADDUSB MM0,count }
	__asm {	PADDUSW MM0,count }

	__asm {	PADDUSB MM0,MM1 }
	__asm {	PADDUSW MM0,MM1 }

	//	Bitwise Logical And 
	__asm {	PAND MM0,count }
	__asm {	PAND MM0,MM1 }

	//	Bitwise Logical And Not 
	__asm {	PANDN MM0,count }
	__asm {	PANDN MM0,MM1 }

	//	Bitwise Logical Or
	__asm {	POR MM0,count }
	__asm {	POR MM0,MM1 }

	//	Compare for Equal 
	__asm {	PCMPEQB MM0,count }
	__asm {	PCMPEQW MM0,count }
	__asm {	PCMPEQD MM0,count }

	__asm {	PCMPEQB MM0,MM1 }
	__asm {	PCMPEQW MM0,MM1 }
	__asm {	PCMPEQD MM0,MM1 }

	//	Compare for Greater Than
	__asm {	PCMPGTB MM0,count }
	__asm {	PCMPGTW MM0,count }
	__asm {	PCMPGTD MM0,count }

	__asm {	PCMPGTB MM0,MM1 }
	__asm {	PCMPGTW MM0,MM1 }
	__asm {	PCMPGTD MM0,MM1 }

	//	Packed Multiply and Add 
	__asm {	PMADDWD MM0,count }
	__asm {	PMADDWD MM0,MM1 }

	//	Packed Multiply High
	__asm {	PMULHW MM0,count }
	__asm {	PMULHW MM0,MM1 }

	//	Packed Multiply Low
	__asm {	PMULLW MM0,count }
	__asm {	PMULLW MM0,MM1 }

	//	Packed Shift Left Logical
	__asm {	PSLLW MM0,count }
	__asm {	PSLLD MM0,count }
	__asm {	PSLLQ MM0,count }

	__asm {	PSLLW MM0,MM1 }
	__asm {	PSLLD MM0,MM1 }
	__asm {	PSLLQ MM0,MM1 }

	__asm {	PSLLW MM0,7 }
	__asm {	PSLLD MM0,7 }
	__asm {	PSLLQ MM0,7 }

	//	Packed Shift Right Arithmetic
	__asm {	PSRAW MM0,count }
	__asm {	PSRAD MM0,count }
	
	__asm {	PSRAW MM0,MM1 }
	__asm {	PSRAD MM0,MM1 }

	__asm {	PSRAW MM0,5 }
	__asm {	PSRAD MM0,5 }

	//	Packed Shift Right Logical
	__asm {	PSRLW MM0,count }
	__asm {	PSRLD MM0,count }
	__asm {	PSRLQ MM0,count }

	__asm {	PSRLW MM0,MM1 }
	__asm {	PSRLD MM0,MM1 }
	__asm {	PSRLQ MM0,MM1 }

	__asm {	PSRLW MM0,6 }
	__asm {	PSRLD MM0,6 }
	__asm {	PSRLQ MM0,6 }

	//	Packed Subtract
	__asm {	PSUBB MM0,count }
	__asm {	PSUBW MM0,count }
	__asm {	PSUBD MM0,count }

	__asm {	PSUBB MM0,MM1 }
	__asm {	PSUBW MM0,MM1 }
	__asm {	PSUBD MM0,MM1 }

	//	Packed Subtract with Saturation
	__asm {	PSUBSB MM0,count }
	__asm {	PSUBSW MM0,count }

	__asm {	PSUBSB MM0,MM1 }
	__asm {	PSUBSW MM0,MM1 }

	//	Packed Subtract Unsigned with Saturation
	__asm {	PSUBUSB MM0,count }
	__asm {	PSUBSW MM0,count }
	
	__asm {	PSUBUSB MM0,MM1 }
	__asm {	PSUBSW MM0,MM1 }
	
	//	Unpack High Packed Data
	__asm {	PUNPCKHBW MM0,count }	
	__asm {	PUNPCKHWD MM0,count }
	__asm {	PUNPCKHDQ MM0,count }
	
	__asm {	PUNPCKHBW MM0,MM1 }	
	__asm {	PUNPCKHWD MM0,MM1 }
	__asm {	PUNPCKHDQ MM0,MM1 }
	
	//	Unpack Low Packed Data
	__asm {	PUNPCKLBW MM0,iVar32 }
	__asm {	PUNPCKLWD MM0,iVar32 }
	__asm {	PUNPCKLDQ MM0,iVar32 }
	
	__asm {	PUNPCKLBW MM0,MM1 }
	__asm {	PUNPCKLWD MM0,MM1 }
	__asm {	PUNPCKLDQ MM0,MM1 }
	
	//	Bitwise Logical Exclusive OR
	__asm {	PXOR MM0,count }
	__asm {	PXOR MM0,MM1 }

}


void Test_Disasm_3dNow()
{
	//	3d Now Tests

	__int64 count = 0;
	unsigned char int8 = 0;

	//	average of unsigned int bytes
	__asm {	PAVGUSB MM0,count }
	__asm {	PAVGUSB MM0,MM5 }

	//	float to 32 bit signed int
	__asm {	PF2ID MM0,count }
	__asm {	PF2ID MM0,MM5 }

	//	accumulator
	__asm {	PFACC MM0,count }
	__asm {	PFACC MM0,MM5 }

	//	add
	__asm {	PFADD MM0,count }
	__asm {	PFADD MM0,MM5 }

	//	compare for equal
	__asm {	PFCMPEQ MM0,count }
	__asm {	PFCMPEQ MM0,MM5 }

	//	compare for greater than or equal to
	__asm {	PFCMPGE MM0,count }
	__asm {	PFCMPGE MM0,MM5 }

	//	compare for greater than
	__asm {	PFCMPGT MM0,count }
	__asm {	PFCMPGT MM0,MM5 }
	
	//	maximum
	__asm {	PFMAX MM0,count }
	__asm {	PFMAX MM0,MM5 }

	//	minimum
	__asm {	PFMIN MM0,count }
	__asm {	PFMIN MM0,MM5 }

	//	multiply
	__asm {	PFMUL MM0,count }
	__asm {	PFMUL MM0,MM5 }
	
	//	reciprocal
	__asm {	PFRCP MM0,count }
	__asm {	PFRCP MM0,MM5 }

	//	reciprocal, reciprocal intermediate step 1, reciprocal intermediate step 2
	__asm {	PFRCPIT1 MM1,MM0 }
	__asm {	PFRCPIT2 MM0,MM1 }

	__asm {	PFRCPIT1 MM5,count }
	__asm {	PFRCPIT2 MM5,count }

	//	reciprocal sqrt
	__asm {	PFRSQRT MM0,count }
	__asm {	PFRSQRT MM0,MM5 }

	//	reciprocal sqrt, reciprocal sqrt intermediate step 1	
	__asm {	PFRSQIT1 MM1,MM0 }
	__asm {	PFRSQIT1 MM1,count }

	//	subtract
	__asm {	PFSUB MM0,count }
	__asm {	PFSUB MM0,MM5 }

	//	reverse subtraction
	__asm {	PFSUBR MM0,count }
	__asm {	PFSUBR MM0,MM5 }

	//	32 bit signed int to float
	__asm {	PI2FD MM0,count }
	__asm {	PI2FD MM0,MM5 }

	//	multiply high
	__asm {	PMULHRW MM0,count }
	__asm {	PMULHRW MM0,MM5 }

	int8 = 1;

	//	load a processor cache into data cache
	__asm {	PREFETCH int8 }

	//	same, sets MES state to modified
	__asm {	PREFETCHW int8 }

}


void Test_Disasm_3dNowEnhanced()
{
	//	enhanced 3dnow tests

	__int64 count = 0;
	unsigned char count8 = 0;
	__int16 iVar16 = 0;

	//	packed float to int word with sign extend
	__asm {	PF2IW MM0,count }
	__asm {	PF2IW MM0,MM1 }

	//	packed float negative accumulate
	__asm {	PFNACC MM0,count }
	__asm {	PFNACC MM0,MM1 }

	//	packed float mixed +ve -ve accumulate
	__asm {	PFPNACC MM0,count }
 	__asm {	PFPNACC MM0,MM1 }
    
	//	packed int word to float
	//	somewhat erroneous values
	__asm {	PI2FW MM0,count }
	__asm {	PI2FW MM0,MM1 }

	//	packed swap double word
	__asm {	PSWAPD MM0,count }
	__asm {	PSWAPD MM0,MM1 }
	
	//	streaming store using byte mask
	//	DID NOT UNDERSTAND
	__asm {	MASKMOVQ MM0,MM1 }
	
	//	streaming store
	__asm {	MOVNTQ count,MM0 }
			
	//	packed avg of unsigned byte	
	__asm {	PAVGB MM0,count }
	__asm {	PAVGB MM0,MM1 }
	
	//	packed avg of unsigned word	
	__asm {	PAVGW MM0,count }
	__asm {	PAVGW MM0,MM1 }

	//	extract word into int register
	__asm {	PEXTRW EAX,MM0, 1 }

	//	insert word from int register
	__asm {	PINSRW MM0, EAX, 1 }
	__asm {	PINSRW MM0, iVar16, 1 }

	//	packed max signed word
	__asm {	PMAXSW MM0,count }	//	1431633926
	__asm {	PMAXSW MM0,MM1 }	//	1431633926
	
	//	packed max unsigned byte
	__asm {	PMAXUB MM0,count }	//	1834219928319
	__asm {	PMAXUB MM0,MM1 }	//	1834219928319
	
	//	packed min signed word
	__asm {	PMINSW MM0,count }	//	1431633921
	__asm {	PMINSW MM0,MM1 }	//	1431633921
	
	//	packed min unsigned byte	
	__asm {	PMINUB MM0,count }	//	730396487935
	__asm {	PMINUB MM0,MM1 }	//	730396487935
	
	//	move mask to integer register
	__asm {	PMOVMSKB EAX, MM0 }	//	EAX = 217
	
	//	packed multiply high unsigned word
	__asm {	PMULHUW MM0,count }	//	281474976841729
	__asm {	PMULHUW MM0,MM1 }	//	281474976841729

	//	prefetch non-temporal access
	__asm {	PREFETCHNTA count8 }
	
	//	prefetch to all cache levels
	__asm {	PREFETCHT0 count8 }
	
	//	prefetch to all cache levels except 0
	__asm {	PREFETCHT1 count8 }
	
	//	prefetch to all cache levels except 0 & 1
	__asm {	PREFETCHT2 count8 }

	//	packed sum of absolute byte differences
	__asm {	PSADBW MM0,count }	//	35
	__asm {	PSADBW MM0,MM1 }	//	35
	
	//	packed shuffle word
	__asm {	PSHUFW MM0,count,228 }	//	578437695752307201
	__asm {	PSHUFW MM0,MM1,225 }	//	578437695752307201
	
	// store fence
	__asm {	SFENCE }

}


void Test_Disasm_Katmai()
{
	//	Katmai (PIII) tests
	
	float fVal = 0.0;
	__m128 mVar128 = {0,0,0,0};
	__int32 i32Val = 0;

	//	test all registers for visibility
	__asm { movss   xmm0, xmm1 }	//	0.0.0.9
	__asm { movss   xmm1, xmm2 }	//	0.0.0.9
	__asm { movss   xmm2, xmm3 }	//	0.0.0.9
	__asm { movss   xmm3, xmm4 }	//	0.0.0.9
	__asm { movss   xmm4, xmm5 }	//	0.0.0.9
	__asm { movss   xmm5, xmm6 }	//	0.0.0.9
	__asm { movss   xmm6, xmm7 }	//	0.0.0.9
	__asm { movss   xmm7, xmm0 }	//	0.0.0.9

	__asm { addps   xmm0, xmm1 }	//	XMM0 - 3,5,7,9
	__asm { addps   xmm0, mVar128 }	//	XMM0 - 3,5,7,9

	__asm { addss   xmm0, xmm1 }	//	1,2,3,9
	__asm { addss   xmm0, i32Val }	//	1,2,3,9

	__asm { andnps   xmm0, xmm1 }
	__asm { andnps   xmm0, mVar128 }

	__asm { andps   xmm0, xmm1 }	//	0
	__asm { andps   xmm0, mVar128 }	//	0

	__asm { cmpps   xmm0, xmm1, 0 }		//	eq
	__asm { cmpps   xmm0, xmm1, 1 }		//	lt
	__asm { cmpps   xmm0, xmm1, 2 }		//	le
	__asm { cmpps   xmm0, xmm1, 3 }		//	unord
	__asm { cmpps   xmm0, xmm1, 4 }		//	neq
	__asm { cmpps   xmm0, xmm1, 5 }		//	nlt
	__asm { cmpps   xmm0, xmm1, 6 }		//	nle
	__asm { cmpps   xmm0, xmm1, 7 }		//	ord
	
	__asm { cmpps   xmm0, mVar128, 0 }
	__asm { cmpps   xmm0, mVar128, 1 }
	__asm { cmpps   xmm0, mVar128, 2 }
	__asm { cmpps   xmm0, mVar128, 3 }
	__asm { cmpps   xmm0, mVar128, 4 }
	__asm { cmpps   xmm0, mVar128, 5 }
	__asm { cmpps   xmm0, mVar128, 6 }
	__asm { cmpps   xmm0, mVar128, 7 }

	__asm { cmpss   xmm0, xmm1, 0 }		//	eq
	__asm { cmpss   xmm0, xmm1, 1 }		//	lt
	__asm { cmpss   xmm0, xmm1, 2 }		//	le
	__asm { cmpss   xmm0, xmm1, 3 }		//	unord
	__asm { cmpss   xmm0, xmm1, 4 }		//	neq
	__asm { cmpss   xmm0, xmm1, 5 }		//	nlt
	__asm { cmpss   xmm0, xmm1, 6 }		//	nle
	__asm { cmpss   xmm0, xmm1, 7 }		//	ord
	
	__asm { cmpss   xmm0, i32Val, 0 }
	__asm { cmpss   xmm0, i32Val, 1 }
	__asm { cmpss   xmm0, i32Val, 2 }
	__asm { cmpss   xmm0, i32Val, 3 }
	__asm { cmpss   xmm0, i32Val, 4 }
	__asm { cmpss   xmm0, i32Val, 5 }
	__asm { cmpss   xmm0, i32Val, 6 }
	__asm { cmpss   xmm0, i32Val, 7 }

	__asm { cmpeqps   xmm0, xmm1 }	//	eq-eq-eq-eq
	__asm { cmpeqss   xmm0, xmm1 }	//	1,2,3,eq
	__asm { cmpltps   xmm0, xmm1 }	//	no-yes-no-no
	__asm { cmpltss   xmm0, xmm1 }	//	1,2,3,yes
	__asm { cmpleps   xmm0, xmm1 }	//	yes,yes,no,no
	__asm { cmpless   xmm0, xmm1 }	//	1,2,3,yes
	__asm { cmpneqps  xmm0, xmm1 }	//	no,y,y,n
	__asm { cmpneqss   xmm0, xmm1 }	//	1,2,3,n
	__asm { cmpnltps   xmm0, xmm1 }	//	n,y,n,y
	__asm { cmpnltss   xmm0, xmm1 }	//	1,2,3,y
	__asm { cmpnleps   xmm0, xmm1 }	//	n,n,n,y
	__asm { cmpnless   xmm0, xmm1 }	//	1,2,3,n

	__asm { comiss   xmm0, xmm1 }	//	1
	__asm { comiss   xmm0, i32Val }	//	1

	__asm { cvtpi2ps   xmm0, GlobalInt64 }	//	1,2,3,4
	__asm { cvtpi2ps   xmm0, mm0 }	//	1,2,3,4

	__asm { cvtps2pi   mm0, xmm0 }	//	MM0 has 2,5
	__asm { cvtps2pi   mm0, GlobalInt64 }	//	MM0 has 2,5

	__asm { cvtsi2ss   xmm0, eax }	//	1,2,3,17
	__asm { cvtsi2ss   xmm0, i32Val }	//	1,2,3,17

	__asm { cvtss2si   eax, xmm0 }	//	eax has 4
	__asm { cvtss2si   eax, i32Val }	//	eax has 4

	__asm { cvttps2pi   mm0, xmm0 }	//	MM0 has 7,5
	__asm { cvttps2pi   mm0, GlobalInt64 }	//	MM0 has 7,5

	__asm { cvttss2si   eax, xmm0 }	//	eax has 7
	__asm { cvttss2si   eax, i32Val }	//	eax has 7

	__asm { divps   xmm0, xmm1 }	//	0.5,1,3,4
	__asm { divps   xmm0, mVar128 }	//	0.5,1,3,4

	__asm { divss   xmm0, xmm1 }	//	1,2,3,5
	__asm { divss   xmm0, i32Val }	//	1,2,3,5

	__asm { maxps   xmm0, xmm1 }	//	5,2,9,5
	__asm { maxps   xmm0, mVar128 }	//	5,2,9,5

	__asm { maxss   xmm0, xmm1 }	//	5,2,7,6
	__asm { maxss   xmm0, i32Val }	//	5,2,7,6

	__asm { minps   xmm0, xmm1 }	//	4,2,7,3
	__asm { minps   xmm0, mVar128 }	//	4,2,7,3

	__asm { minss   xmm0, xmm1 }	//	1.2.3.4
	__asm { minss   xmm0, i32Val }	//	1.2.3.4

	__asm { movaps   xmm0, xmm1 }	//	5.5.5.5
	__asm { movaps   xmm0, mVar128 }	//	5.5.5.5
	__asm { movaps   mVar128, xmm1 }	//	5.5.5.5

	__asm { movhlps	 xmm0, xmm1 }	//	1,2,5,6

	__asm { movhps   xmm0, GlobalInt64 }	//	6.7.3.4
	__asm { movhps   GlobalInt64, xmm0 }	//	6.7.3.4

	__asm { movlps   xmm0, GlobalInt64 }	//	1.2.6.7
	__asm { movlps   GlobalInt64, xmm0 }	//	1.2.6.7

	__asm { movlhps   xmm0, xmm1 }	//	5.6.3.4

	__asm { movmskps   eax, xmm0 }	//	5

	__asm { movntps   mVar128, xmm0 }

	__asm { movss   xmm0, i32Val }	//	0.0.0.9
	__asm { movss   i32Val, xmm0 }	//	0.0.0.9
	__asm { movss   xmm0, xmm1 }	//	0.0.0.9

	__asm { movups   xmm0, xmm1 }	//	5,6,7,8
	__asm { movups   xmm0, mVar128 }	//	5,6,7,8
	__asm { movups   mVar128, xmm1 }	//	5,6,7,8

	__asm { mulps   xmm0, xmm1 }	//	2,6,0,10
	__asm { mulps   xmm0, mVar128 }	//	2,6,0,10

	__asm { mulss   xmm0, xmm1 }	//	1,2,3,8
	__asm { mulss   xmm0, i32Val }	//	1,2,3,8

	__asm { orps   xmm0, xmm1 }	//	1,x,y,z
	__asm { orps   xmm0, mVar128 }	//	1,x,y,z

	__asm { rcpps   xmm0, xmm1 }	//	1/2, 1/3, 1/4, 1/5
	__asm { rcpps   xmm0, mVar128 }	//	1/2, 1/3, 1/4, 1/5

	__asm { rcpss   xmm0, xmm1 }	//	1,2,3,1/2
	__asm { rcpss   xmm0, i32Val }	//	1,2,3,1/2

	__asm { rsqrtps   xmm0, xmm1 }	//	reciprocal 1,1.73,2,3
	__asm { rsqrtps   xmm0, mVar128 }	//	reciprocal 1,1.73,2,3

	__asm { rsqrtss   xmm0, xmm1 }	//	1,2,3, 1/3
	__asm { rsqrtss   xmm0, i32Val }	//	1,2,3, 1/3

	__asm { sfence }

	__asm { shufps   xmm0, xmm1, 114 }
	__asm { shufps   xmm0, mVar128, 115 }

	__asm { sqrtps   xmm0, xmm1 }	//	1,1.73,2,3
	__asm { sqrtps   xmm0, mVar128 }	//	1,1.73,2,3

	__asm { sqrtss   xmm0, xmm1 }	//	1,2,3,3
	__asm { sqrtss   xmm0, i32Val }	//	1,2,3,3

	__asm { stmxcsr  i32Val }
	__asm { ldmxcsr  i32Val }	//	1,2,3,5

	__asm { subps   xmm0, xmm1 }	//	-1,5,1,3
	__asm { subps   xmm0, mVar128 }	//	-1,5,1,3

	__asm { subss   xmm0, xmm1 }	//	1,8,5,-2
	__asm { subss   xmm0, i32Val }	//	1,8,5,-2

	__asm { ucomiss   xmm0, xmm1 }	//	0
	__asm { ucomiss   xmm0, i32Val }	//	0

	__asm { unpckhps   xmm0, xmm1 }	//	interleaved high - 5,1,6,2
	__asm { unpckhps   xmm0, mVar128 }	//	interleaved high - 5,1,6,2

	__asm { unpcklps   xmm0, xmm1 }	//	interleaved low - 7,3,8,4
	__asm { unpcklps   xmm0, mVar128 }	//	interleaved low - 7,3,8,4

	__asm { xorps   xmm0, xmm1 }	//	xor - 0,0,x,y
	__asm { xorps   xmm0, mVar128 }	//	xor - 0,0,x,y

}

void ClearXMMReg(int regid)
{

	switch(regid)
	{

	case 0:
		__asm { MOVSS XMM0, FLOAT_ZERO }
		break;

	case 1:
		__asm { MOVSS XMM1, FLOAT_ZERO }
		break;

	case 2:
		__asm { MOVSS XMM2, FLOAT_ZERO }
		break;

	case 3:
		__asm { MOVSS XMM3, FLOAT_ZERO }
		break;

	case 4:
		__asm { MOVSS XMM4, FLOAT_ZERO }
		break;

	case 5:
		__asm { MOVSS XMM5, FLOAT_ZERO }
		break;

	case 6:
		__asm { MOVSS XMM6, FLOAT_ZERO }
		break;

	case 7:
		__asm { MOVSS XMM7, FLOAT_ZERO }
		break;

	}

}

void set_GlobalInt64(int Hi, int Low)
{
	__int64 HiVal = FloatVal[Hi - FLOATVAL_BASE];
	__int64 LowVal = FloatVal[Low - FLOATVAL_BASE];

	GlobalInt64 = HiVal;
	GlobalInt64  = GlobalInt64 << 32;
	GlobalInt64 |= LowVal;
}

void set_XMMRegister(int regid, char upper, int Hi, int Low)
{

	switch (regid)
	{
		case 0:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM0, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM0, GlobalInt64 }
					}
					break;

		case 1:					
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM1, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM1, GlobalInt64 }
					}
					break;


		case 2:					
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM2, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM2, GlobalInt64 }
					}
					break;

		case 3:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM3, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM3, GlobalInt64 }
					}
					break;


		case 4:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM4, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM4, GlobalInt64 }
					}
					break;

		case 5:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM5, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM5, GlobalInt64 }
					}
					break;

		case 6:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM6, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM6, GlobalInt64 }
					}
					break;

		case 7:		
					set_GlobalInt64(Hi, Low);
					if (upper)
					{
						__asm { MOVHPS XMM7, GlobalInt64 }
					}
					else
					{
						__asm { MOVLPS XMM7, GlobalInt64 }
					}
					break;
	}
}


void set_XMMRegister(int regid, int X3, int X2, int X1, int X0)
{
	set_XMMRegister(regid, 1, X3, X2);	//	upper 64 bits
	set_XMMRegister(regid, 0, X1, X0);	//	lower 64 bits
}

// Willamette (SSE2) instructions

void Test_Disasm_WNI()
{
	__m128 mVar128 = {0,0,0,0};
	// __m64 mVar64 = {0,0};
    __m64 mVar64;

	__int8 mVar8;
	__int16 mVar16;
	__int32 mVar32;
	char arr[32];

	__asm
	{
		EMMS		
		
		ADDPD XMM0,XMM1
		ADDPD XMM2,XMM3
		ADDPD XMM4,XMM5
		ADDPD XMM6,XMM7
		ADDPD XMM1,XMM0
		ADDPD XMM3,XMM2
		ADDPD XMM5,XMM4
		ADDPD XMM7,XMM6
			
		ADDPD XMM0,XMM1
		ADDPD XMM0,mVar128
		
		ADDSD XMM0,XMM1
		ADDSD XMM0,mVar64

		ANDNPD XMM0,XMM1
		ANDNPD XMM0,mVar128
		
		ANDPD XMM0,XMM1
		ANDPD XMM0,mVar128
		
		CMPPD XMM0,XMM1, 0
		CMPPD XMM0,mVar128, 0
		CMPPD XMM0,XMM1, 1
		CMPPD XMM0,mVar128, 1
		CMPPD XMM0,XMM1, 2
		CMPPD XMM0,mVar128, 2
		CMPPD XMM0,XMM1, 3
		CMPPD XMM0,mVar128, 3
		CMPPD XMM0,XMM1, 4
		CMPPD XMM0,mVar128, 4
		CMPPD XMM0,XMM1, 5
		CMPPD XMM0,mVar128, 5
		CMPPD XMM0,XMM1, 6
		CMPPD XMM0,mVar128, 6
		CMPPD XMM0,XMM1, 7
		CMPPD XMM0,mVar128, 7
		
		CMPSD XMM0,XMM1, 0		
		CMPSD XMM0,mVar64, 0
		CMPSD XMM0,XMM1, 1		
		CMPSD XMM0,mVar64, 1
		CMPSD XMM0,XMM1, 2		
		CMPSD XMM0,mVar64, 2
		CMPSD XMM0,XMM1, 3		
		CMPSD XMM0,mVar64, 3
		CMPSD XMM0,XMM1, 4		
		CMPSD XMM0,mVar64, 4
		CMPSD XMM0,XMM1, 5		
		CMPSD XMM0,mVar64, 5
		CMPSD XMM0,XMM1, 6		
		CMPSD XMM0,mVar64, 6
		CMPSD XMM0,XMM1, 7		
		CMPSD XMM0,mVar64, 7
		
		COMISD XMM0,XMM1
		COMISD XMM0,mVar64
		
		CVTDQ2PD XMM0,XMM1
		CVTDQ2PD XMM0,mVar64

		CVTPD2PI MM0,XMM1	
		CVTPD2PI MM0,mVar128	
		
		CVTPD2DQ XMM0,XMM1	
		CVTPD2DQ XMM0,mVar128	

		
		CVTPD2PS XMM0,XMM1
		CVTPD2PS XMM0,mVar128
		
		CVTPI2PD XMM0,MM0
		CVTPI2PD XMM0,mVar64
		
		CVTPS2PD XMM0,XMM1
		CVTPS2PD XMM0,mVar64
		
		CVTSD2SI eax,XMM1
		CVTSD2SI eax,mVar64
		
		CVTSD2SS XMM0,XMM1
		CVTSD2SS XMM0,mVar64
		
		CVTSI2SD XMM0,eax
		CVTSI2SD XMM0,mVar32
		
		CVTSS2SD XMM0,XMM1
		CVTSS2SD XMM0,mVar32
		
		CVTTPD2PI MM0,XMM1
		CVTTPD2PI MM0,mVar128
		
		CVTTPD2DQ XMM0,XMM1
		CVTTPD2DQ XMM0,mVar128
		
		CVTTSD2SI eax,XMM1
		CVTTSD2SI eax,mVar64
		
		DIVPD XMM0,XMM1
		DIVPD XMM0,mVar128
		
		DIVSD XMM0,XMM1
		DIVSD XMM0,mVar64
		
		MAXPD XMM0,XMM1
		MAXPD XMM0,mVar128
		
		MAXSD XMM0,XMM1
		MAXSD XMM0,mVar64
		
		MINPD XMM0,XMM1
		MINPD XMM0,mVar128
		
		MINSD XMM0,XMM1
		MINSD XMM0,mVar64
		
		MOVAPD XMM0,XMM1
		MOVAPD XMM0,mVar128
		MOVAPD mVar128,XMM1
		
		MOVHPD XMM0,mVar64
		MOVHPD mVar64,XMM0
		
		MOVLPD XMM0,mVar64
		MOVLPD mVar64,XMM0
		
		MOVMSKPD eax,XMM1
		
		MOVSD XMM0,XMM1
		MOVSD XMM0,mVar64
		MOVSD mVar64,XMM1
		
		MOVUPD XMM0,XMM1
		MOVUPD XMM0,mVar128
		MOVUPD mVar128,XMM1
		
		MULPD XMM0,XMM1
		MULPD XMM0,mVar128
		
		MULSD XMM0,XMM1
		MULSD XMM0,mVar64
		
		ORPD XMM0,XMM1
		ORPD XMM0,mVar128
		
		SHUFPD XMM0,XMM1,8
		SHUFPD XMM0,mVar128,8
		
		SQRTPD XMM0,XMM1
		SQRTPD XMM0,mVar128
		
		SQRTSD XMM0,XMM1
		SQRTSD XMM0,mVar64
		
		SUBPD XMM0,XMM1
		SUBPD XMM0,mVar128
		
		SUBSD XMM0,XMM1
		SUBSD XMM0,mVar64
		
		UCOMISD XMM0,XMM1
		UCOMISD XMM0,mVar64
		
		UNPCKHPD XMM0,XMM1
		UNPCKHPD XMM0,mVar128
		
		UNPCKLPD XMM0,XMM1
		UNPCKLPD XMM0,mVar128
		
		XORPD XMM0,XMM1
		XORPD XMM0,mVar128

		
		CVTDQ2PS XMM0,XMM1
		CVTDQ2PS XMM0,mVar128

		CVTPS2DQ XMM0,XMM1
		CVTPS2DQ XMM0,mVar128

		CVTTPS2DQ XMM0,XMM1
		CVTTPS2DQ XMM0,mVar128

		//	not in manual
		CVTPI2PS XMM0,MM1
		CVTPI2PS XMM0,MM1

		//	not in manual
		CVTPS2PI MM0,XMM1
		CVTPS2PI MM0,XMM1
		
		//	not in manual
		CVTTPS2PI MM0,XMM1
		CVTTPS2PI MM0,XMM1
		
		MOVD XMM0,eax
		MOVD XMM0,mVar32
		MOVD eax,XMM1
		MOVD mVar32,XMM1
		
		MOVDQA XMM0,XMM1
		MOVDQA XMM0,mVar128
		MOVDQA mVar128,XMM1
		
		MOVDQU XMM0,XMM1
		MOVDQU XMM0,mVar128
		MOVDQU mVar128,XMM1
		
		MOVDQ2Q MM0,XMM1

		MOVQ2DQ XMM0,MM1
		
		MOVQ XMM0,XMM1
		MOVQ XMM0,mVar64
		MOVQ mVar64,XMM1

		PACKSSWB XMM0,XMM1
		PACKSSWB XMM0,mVar128
		
		PACKSSDW XMM0,XMM1
		PACKSSDW XMM0,mVar128
		
		PACKUSWB XMM0,XMM1
		PACKUSWB XMM0,mVar128
		
		PADDB XMM0,XMM1
		PADDB XMM0,mVar128
		
		PADDW XMM0,XMM1
		PADDW XMM0,mVar128
		
		PADDD XMM0,XMM1
		PADDD XMM0,mVar128
		
		PADDQ MM0,MM1
		PADDQ MM0,mVar64
		PADDQ XMM0,XMM1
		PADDQ XMM0,mVar128

		PADDSB XMM0,XMM1
		PADDSB XMM0,mVar128
		
		PADDSW XMM0,XMM1
		PADDSW XMM0,mVar128
		
		PADDUSB XMM0,XMM1
		PADDUSB XMM0,mVar128
		
		PADDUSW XMM0,XMM1
		PADDUSW XMM0,mVar128
		
		PAND XMM0,XMM1
		PAND XMM0,mVar128
		
		PANDN XMM0,XMM1
		PANDN XMM0,mVar128
		
		PAVGB XMM0,XMM1
		PAVGB XMM0,mVar128
		
		PAVGW XMM0,XMM1
		PAVGW XMM0,mVar128
		
		PCMPEQB XMM0,XMM1
		PCMPEQB XMM0,mVar128
		
		PCMPEQW XMM0,XMM1
		PCMPEQW XMM0,mVar128
		
		PCMPEQD XMM0,XMM1
		PCMPEQD XMM0,mVar128
		
		PCMPGTB XMM0,XMM1
		PCMPGTB XMM0,mVar128
		
		PCMPGTW XMM0,XMM1
		PCMPGTW XMM0,mVar128
		
		PCMPGTD XMM0,XMM1
		PCMPGTD XMM0,mVar128

		PEXTRW eax,XMM1,6

		PINSRW XMM0,mVar16,6
		PINSRW XMM0,eax,6
		
		PMADDWD XMM0,XMM1
		PMADDWD XMM0,mVar128

		PMAXSW XMM0,XMM1
		PMAXSW XMM0,mVar128

		PMAXUB XMM0,XMM1
		PMAXUB XMM0,mVar128
		
		PMINSW XMM0,XMM1
		PMINSW XMM0,mVar128
		
		PMINUB XMM0,XMM1
		PMINUB XMM0,mVar128
		
		PMOVMSKB eax,XMM1
		
		PMULHW XMM0,XMM1
		PMULHW XMM0,mVar128
		
		PMULHUW XMM0,XMM1
		PMULHUW XMM0,mVar128
		
		PMULLW XMM0,XMM1
		PMULLW XMM0,mVar128
		
		PMULUDQ MM0,MM1
		PMULUDQ MM0,mVar64
		PMULUDQ XMM0,XMM1
		PMULUDQ XMM0,mVar128
		
		POR XMM0,XMM1
		POR XMM0,mVar128
		
		PSADBW XMM0,XMM1
		PSADBW XMM0,mVar128
		
		PSHUFD XMM0,XMM1,8
		PSHUFD XMM0,mVar128,8
		
		PSHUFHW XMM0,XMM1,8
		PSHUFHW XMM0,mVar128,8
		
		PSHUFLW XMM0,XMM1,8
		PSHUFLW XMM0,mVar128,8
		
		PSLLDQ XMM0,8
		
		PSLLW XMM0,XMM1
		PSLLW XMM0,mVar128
		PSLLW XMM0,8
		
		PSLLD XMM0,XMM1
		PSLLD XMM0,mVar128
		PSLLD XMM0,8
		
		PSLLQ XMM0,XMM1
		PSLLQ XMM0,mVar128
		PSLLQ XMM0,8
		
		PSRAW XMM0,XMM1
		PSRAW XMM0,mVar128
		PSRAW XMM0,8
		
		PSRAD XMM0,XMM1
		PSRAD XMM0,mVar128
		PSRAD XMM0,8
		
		PSRLDQ XMM0,8
		
		PSRLW XMM0,XMM1
		PSRLW XMM0,mVar128
		PSRLW XMM0,8
		
		PSRLD XMM0,XMM1
		PSRLD XMM0,mVar128
		PSRLD XMM0,8
		
		PSRLQ XMM0,XMM1
		PSRLQ XMM0,mVar128
		PSRLQ XMM0,8
		
		PSUBB XMM0,XMM1
		PSUBB XMM0,mVar128
		
		PSUBW XMM0,XMM1
		PSUBW XMM0,mVar128
		
		PSUBD XMM0,XMM1
		PSUBD XMM0,mVar128

		PSUBQ MM0,MM1
		PSUBQ MM0,mVar64
		PSUBQ XMM0,XMM1
		PSUBQ XMM0,mVar128
		
		PSUBSB XMM0,XMM1
		PSUBSB XMM0,mVar128
		
		PSUBSW XMM0,XMM1
		PSUBSW XMM0,mVar128
		
		PSUBUSB XMM0,XMM1
		PSUBUSB XMM0,mVar128
		
		PSUBUSW XMM0,XMM1
		PSUBUSW XMM0,mVar128
		
		PUNPCKHBW XMM0,XMM1
		PUNPCKHBW XMM0,mVar128
		
		PUNPCKHWD XMM0,XMM1
		PUNPCKHWD XMM0,mVar128
		
		PUNPCKHDQ XMM0,XMM1
		PUNPCKHDQ XMM0,mVar128
		
		PUNPCKHQDQ XMM0,XMM1
		PUNPCKHQDQ XMM0,mVar128
		
		PUNPCKLBW XMM0,XMM1
		PUNPCKLBW XMM0,mVar128
		
		PUNPCKLWD XMM0,XMM1
		PUNPCKLWD XMM0,mVar128
		
		PUNPCKLDQ XMM0,XMM1
		PUNPCKLDQ XMM0,mVar128
		
		PUNPCKLQDQ XMM0,XMM1
		PUNPCKLQDQ XMM0,mVar128
		
		PXOR XMM0,XMM1
		PXOR XMM0,mVar128
		
		CLFLUSH mVar8
		push eax
		lea eax, dword ptr arr
		CLFLUSH  [eax]
		pop eax
		
		LFENCE

		MASKMOVDQU XMM0,XMM1
		
		MFENCE

		MOVNTPD mVar128,XMM1
		MOVNTDQ mVar128,XMM1

		MOVNTI mVar32, eax

		PAUSE
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\dbgfunc\main.cpp ===
#ifdef _XBOX
#include <xtl.h>
#else
#include <windows.h>
#endif

#include "dbgtest.h"
#include "bounce.h"

#ifdef _XBOX
void __cdecl main()
#else
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
#endif
{
    CBounce bounce;
	int choice = 0;

	while(1)
	{
        #ifdef _XBOX
        bounce.DrawStuff();
		#endif

		if (!choice)
			continue;

        Test_Disasm_MMX();
        Test_Disasm_Katmai();

        // debug multiple threads
        Test_Threads();

        // test FPU exception handling
		Test_Registers();

        // test register view of MMX and SSE registers
        Test_MMX_Registers();
        Test_SSE_Registers();

        // test call stack 
        Test_Stack();

        // test tracing through /opt:icf-combined functions
        Test_ICF();

        // some interesting breakpoint testcases
        Test_Breakpoints();
	}
	
#ifndef _XBOX
    return 0;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\dbgfunc\dbgtest.h ===
#ifndef __DBGBASIC_H__
#define __DBGBASIC_H__

#ifndef _XBOX
#include <windows.h>
#else
#include <xtl.h>
#endif

void Test_Disasm_MMX();
void Test_Disasm_Katmai();

void Test_Threads();

void Test_Registers();
void Test_MMX_Registers();
void Test_SSE_Registers();

extern "C" { void Test_Stack(); }

void Test_ICF();
void Test_Breakpoints();

#ifdef TEST_DLL_SUPPORT
int WINAPI TestDllFunc(int, char);
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\common\draw.h ===
#ifndef __DRAW_H__
#define __DRAW_H__

#ifdef _XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

#include "bitfont.h"

#define BACKDROP_BLUE 0x000080
#define PITCH_BLACK 0x0
#define LABEL_WHITE 0xffffff
#define DISCONNECTED_BLUE 0x000040
#define CONNECTED_YELLOW 0xffff00

class CDraw
{
private:

    static IDirect3DDevice8* m_pDevice;

    IDirect3DSurface8* m_pBackBuffer;

    BitFont m_font;

public:

    CDraw(INT width = 640, INT height = 480);

    ~CDraw();

    VOID FillRect(
        INT x,
        INT y,
        INT width,
        INT height,
        D3DCOLOR color);

    VOID DrawText(
        const TCHAR* string,
        INT x,
        INT y,
        D3DCOLOR foregroundColor,           // 0xff0000 is red
        D3DCOLOR backgroundColor = 0,
        DWORD flags = DRAWTEXT_TRANSPARENTBKGND);

    VOID Present();

    BOOL IsValid() { return m_pDevice != NULL; }
};


#endif __DRAW_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\dbgfunc\registerspp.cpp ===
// \\vsqaauto\vc6snaps\Debugger\Core\src\Registers PP\Registers PP.cpp

#include "dbgtest.h"

void Test_MMX_Registers()
{
	// The following instructions will modify the contents of the MMX
    // registers; step through the instructions and make sure that the
    // register window reflects those changes as they are made.
	
	__int64 regVal = 0;

	regVal = 100;
	__asm { MOVQ MM0, regVal }

	regVal = 200;
	__asm { MOVQ MM1, regVal }

	regVal = 300;
	__asm { MOVQ MM2, regVal }

	regVal = 400;
	__asm { MOVQ MM3, regVal }

	regVal = 500;
	__asm { MOVQ MM4, regVal }

	regVal = 600;
	__asm { MOVQ MM5, regVal }

	regVal = 700;
	__asm { MOVQ MM6, regVal }

	regVal = 800;
	__asm { MOVQ MM7, regVal }

	regVal = 0;
	regVal = 1;
}

void Test_SSE_Registers()
{
	// The following instructions will modify the contents of the PIII
    // SIMD floating point registers; step through the instructions 
    // and make sure that the register window reflects those changes 
    // as they are made.
	
    // Each register is represented in the register window in its
    // entirety as well as its four subparts.  for example, the value
    // of XMM0 is shown, as well as XMM00, XMM01, XMM02, XMM03.  A
    // change to XMM0 should change one or more of its subparts.

	float fVal = 0;

	fVal = 1.0;
	__asm { MOVSS XMM0, fVal }

	fVal = 2.0;
	__asm { MOVSS XMM1, fVal }

	fVal = 3.0;
	__asm { MOVSS XMM2, fVal }

	fVal = 4.0;
	__asm { MOVSS XMM3, fVal }

	fVal = 5.0;
	__asm { MOVSS XMM4, fVal }

	fVal = 6.0;
	__asm { MOVSS XMM5, fVal }

	fVal = 7.0;
	__asm { MOVSS XMM6, fVal }

	fVal = 8.0;
	__asm { MOVSS XMM7, fVal }


	fVal = 1.0;
	fVal = 2.0;
	fVal = 3.0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\dbgfunc\stack.h ===
/*
\\vsqaauto\VC6Snaps\Debugger\Core\src\stack01\cstack.h
*/

#ifdef _XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <limits.h> /* Win32 limit constants */
#include <float.h> /* Win32 floating point limit constants */
#endif

//***************************************************************************
// prototypes

void                    VoidProcNoParam(void);
char                    CharProcNoParam(void);
unsigned char           UCharProcNoParam(void);
int                     IntProcNoParam(void);
unsigned int            UIntProcNoParam(void);
short                   ShortProcNoParam(void);
unsigned short          UShortProcNoParam(void);
long                    LongProcNoParam(void);
unsigned long           ULongProcNoParam(void);
float                   FloatProcNoParam(void);
double                  DoubleProcNoParam(void);
long double             LDoubleProcNoParam(void);

void                    VoidProc1Param(int i);
char                    CharProc1Param(char c);
unsigned char           UCharProc1Param(unsigned char uc);
int                     IntProc1Param(int i);
unsigned int            UIntProc1Param(unsigned int ui);
short                   ShortProc1Param(short s);
unsigned short          UShortProc1Param(unsigned short us);
long                    LongProc1Param(long l);
unsigned long           ULongProc1Param(unsigned long ul);
float                   FloatProc1Param(float f);
double                  DoubleProc1Param(double d);
long double             LDoubleProc1Param(long double ld);

short *            		PShortProc1Param(short * ps);
int * 					LPIntProc1Param(int * lpi);

int                     average(int first, ...);
unsigned long           factorial(int i);

long		            MultiParam(char c, int i, short s, long l, double d, long double ld, float f);

void 					check(int i, TCHAR *pc);

#ifdef __cplusplus
extern "C" { int Cxx_Tests(); }
#else
int Cxx_Tests();
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\dbgfunc\stack_cpp.cpp ===
//
// \\vsqaauto\VC6Snaps\Debugger\Core\src\stack01\cppstack.cpp

#include "stack.h"

typedef void (*PFNINT)(void*, unsigned long);
typedef int (*PFNVAR)(void*, ...);

void afuncint(void*, DWORD)
{
}

static int afuncvar(void*, ...)
{
	return 0;
}

class AClass
{
public:
	PFNINT pfnint;
	PFNVAR pfnvar;
	static int m_static;
	virtual void __fastcall virt_method() {};
} the_Aclass;

int AClass::m_static = -1;
static AClass static_Aclass;

typedef AClass* PAClass;
typedef class ADerived: public AClass{
	void __fastcall virt_method() {
		int in_derived = 0;
	};
} CLASS_DERIVED;



CLASS_DERIVED the_derived;


static int Result=0;

static PFNVAR globalsecond1;
PFNVAR globalsecond2;

PAClass pclass = &the_Aclass;

//****************************************************************************
// Purpose:     function taking class & pointer to class
int paramclass(AClass the_class, AClass *the_pointer)
{
	return 0;
}

//****************************************************************************
// Purpose:     function taking typedef class & pointer to class
int paramtypedefclass(CLASS_DERIVED the_class, PAClass the_pointer)
{
	return 0;
}

//****************************************************************************
// Purpose:     function taking pointers to a functions as params
PFNINT pointerstofunc(PFNINT first, PFNVAR second)
{
	static PFNINT localfirst=first;
	PFNVAR localsecond=second;
	int i=0;
	return first;
}

char *szdummy;

//****************************************************************************
// Purpose:     overloaded function taking int
int overloaded_function(int first)
{
	static int i=1;
	static int j=first;
    szdummy = "overloaded function taking int";
	return first;
}

//****************************************************************************
// Purpose:     overloaded function taking long
int overloaded_function(long first)
{
    szdummy = "overloaded function taking long";
	return first;
}



//****************************************************************************
// Purpose:     fpo function
double __fastcall fastcall_function(int first,long second, float third)
{

	return first + second + third;
}


//****************************************************************************
// Purpose:     stdcall function
double __stdcall stdcall_function(int first,long second, float third)
{

	return fastcall_function(first, second, third);
}


//****************************************************************************
// Purpose:     cdecl function
double __cdecl cdecl_function(int first,long second, float third)
{
	return stdcall_function(first, second, third);
}
static int foo()
{
	return 10;
}

// disable conversion
#pragma warning ( disable : 4244 )

int Cxx_Tests()
{
	pointerstofunc(afuncint, afuncvar);
	pointerstofunc(afuncint, NULL);

	Result += overloaded_function(1);
	Result += overloaded_function(1L);
	static double doubleresult=cdecl_function(1, 2, 3.0);
	Result += (int) doubleresult;
	Result += 3;

    // try and set a breakpoint inside a virtual method
    // see if we stop inside of it

    CLASS_DERIVED *pDerived = new CLASS_DERIVED;
    PAClass pClass = pDerived;
    pClass->virt_method();

    // clean up

    delete pDerived;

	return Result==0;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\dbgfunc\stack_c.c ===
/*
\\vsqaauto\VC6Snaps\Debugger\Core\src\stack01\cstack.c
*/
#include "stack.h"

//****************************************************************************
// globals

char            test[]      = "CallStack";

char            scharmax    = SCHAR_MAX;
char            scharmin    = SCHAR_MIN;
unsigned char   ucharmax    = UCHAR_MAX;
unsigned char   ucharmin    = 0;
int             intmax      = INT_MAX;
int             intmin      = INT_MIN;
unsigned int    uintmax     = UINT_MAX;
unsigned int    uintmin     = 0;
short           shrtmax     = SHRT_MAX;
short           shrtmin     = SHRT_MIN;
unsigned short  ushrtmax    = USHRT_MAX;
unsigned short  ushrtmin    = 0;
long            longmax     = LONG_MAX;
long            longmin     = LONG_MIN;
unsigned long   ulongmax    = ULONG_MAX;
unsigned long   ulongmin    = 0;
double          dblmax      = DBL_MAX;
double          dblmin      = DBL_MIN;
long double     ldblmax     = LDBL_MAX;
long double     ldblmin     = LDBL_MIN;
float           fltmax      = FLT_MAX;
float           fltmin      = FLT_MIN;

char            *pscharmax  = &scharmax;
char            *pscharmin  = &scharmin;
unsigned char   *pucharmax  = &ucharmax;
unsigned char   *pucharmin  = &ucharmin;
int             *pintmax    = &intmax;
int             *pintmin    = &intmin;
unsigned int    *puintmax   = &uintmax;
unsigned int    *puintmin   = &uintmin;
short           *pshrtmax   = &shrtmax;
short           *pshrtmin   = &shrtmin;
unsigned short  *pushrtmax  = &ushrtmax;
unsigned short  *pushrtmin  = &ushrtmin;
long            *plongmax   = &longmax;
long            *plongmin   = &longmin;
unsigned long   *pulongmax  = &ulongmax;
unsigned long   *pulongmin  = &ulongmin;
double          *pdblmax    = &dblmax;
double          *pdblmin    = &dblmin;
long double     *pldblmax   = &ldblmax;
long double     *pldblmin   = &ldblmin;
float           *pfltmax    = &fltmax;
float           *pfltmin    = &fltmin;

//****************************************************************************
// Purpose:     main program
void Test_Stack()
{
    // no parameters
    VoidProcNoParam();
    check(!(CharProcNoParam() == SCHAR_MIN),	TEXT("CharProcNoParam()"));
    check(!(UCharProcNoParam() == UCHAR_MAX),	TEXT("UCharProcNoParam()"));
    check(!(IntProcNoParam() == INT_MIN),		TEXT("IntProcNoParam()"));
    check(!(UIntProcNoParam() == UINT_MAX),		TEXT("UIntProcNoParam()"));
    check(!(ShortProcNoParam() == SHRT_MIN),	TEXT("ShortProcNoParam()"));
    check(!(UShortProcNoParam() == USHRT_MAX),	TEXT("UShortProcNoParam()"));
    check(!(LongProcNoParam() == LONG_MIN),		TEXT("LongProcNoParam()"));
    check(!(ULongProcNoParam() == ULONG_MAX),	TEXT("ULongProcNoParam()"));
    check(!(DoubleProcNoParam() == DBL_MIN),	TEXT("DoubleProcNoParam()"));
    check(!(LDoubleProcNoParam() == LDBL_MAX),	TEXT("LDoubleProcNoParam()"));
    check(!(FloatProcNoParam() == FLT_MIN),		TEXT("FloatProcNoParam()"));

    // at least one parameter
    VoidProc1Param(INT_MAX);
    check(!(CharProc1Param(SCHAR_MIN) == SCHAR_MIN),	TEXT("CharProc1Param"));
    check(!(UCharProc1Param(UCHAR_MAX) == UCHAR_MAX),	TEXT("UCharProc1Param"));
    check(!(IntProc1Param(INT_MIN) == INT_MIN),			TEXT("IntProc1Param"));
    check(!(UIntProc1Param(UINT_MAX) == UINT_MAX),		TEXT("UIntProc1Param"));
    check(!(ShortProc1Param(SHRT_MIN) == SHRT_MIN),		TEXT("ShortProc1Param"));
    check(!(UShortProc1Param(USHRT_MAX) == USHRT_MAX),	TEXT("UShortProc1Param"));
    check(!(LongProc1Param(LONG_MIN) == LONG_MIN),		TEXT("LongProc1Param"));
    check(!(ULongProc1Param(ULONG_MAX) == ULONG_MAX),	TEXT("ULongProc1Param"));
    check(!(DoubleProc1Param(DBL_MAX) == DBL_MAX),		TEXT("DoubleProc1Param"));
    check(!(LDoubleProc1Param(LDBL_MIN) == LDBL_MIN),	TEXT("LDoubleProc1Param"));
    check(!(FloatProc1Param(FLT_MAX) == FLT_MAX),		TEXT("FloatProc1Param"));

    // parameter passed on using global variables
    VoidProc1Param(intmax);
    check(!(CharProc1Param(scharmin) == SCHAR_MIN),		TEXT("CharProc1Param"));
    check(!(UCharProc1Param(ucharmax) == UCHAR_MAX),	TEXT("UCharProc1Param"));
    check(!(IntProc1Param(intmin) == INT_MIN),			TEXT("IntProc1Param"));
    check(!(UIntProc1Param(uintmax) == UINT_MAX),		TEXT("UIntProc1Param"));
    check(!(ShortProc1Param(shrtmin) == SHRT_MIN),		TEXT("ShortProc1Param"));
    check(!(UShortProc1Param(ushrtmax) == USHRT_MAX),	TEXT("UShortProc1Param"));
    check(!(LongProc1Param(longmin) == LONG_MIN),		TEXT("LongProc1Param"));
    check(!(ULongProc1Param(ulongmax) == ULONG_MAX),	TEXT("ULongProc1Param"));
    check(!(DoubleProc1Param(dblmax) == DBL_MAX),		TEXT("DoubleProc1Param"));
    check(!(LDoubleProc1Param(ldblmin) == LDBL_MIN),	TEXT("LDoubleProc1Param"));
    check(!(FloatProc1Param(fltmax) == FLT_MAX),		TEXT("FloatProc1Param"));

    // parameter passed on using pointers
    VoidProc1Param(*pintmax);
    check(!(CharProc1Param(*pscharmin) == SCHAR_MIN),	TEXT("CharProc1Param*"));
    check(!(UCharProc1Param(*pucharmax) == UCHAR_MAX),	TEXT("UCharProc1Param*"));
    check(!(IntProc1Param(*pintmin) == INT_MIN),		TEXT("IntProc1Param*"));
    check(!(UIntProc1Param(*puintmax) == UINT_MAX),		TEXT("UIntProc1Param*"));
    check(!(ShortProc1Param(*pshrtmin) == SHRT_MIN),	TEXT("ShortProc1Param*"));
    check(!(UShortProc1Param(*pushrtmax) == USHRT_MAX),	TEXT("UShortProc1Param*"));
    check(!(LongProc1Param(*plongmin) == LONG_MIN),		TEXT("LongProc1Param*"));
    check(!(ULongProc1Param(*pulongmax) == ULONG_MAX),	TEXT("ULongProc1Param*"));
    check(!(DoubleProc1Param(*pdblmax) == DBL_MAX),		TEXT("DoubleProc1Param*"));
    check(!(LDoubleProc1Param(*pldblmin) == LDBL_MIN),	TEXT("LDoubleProc1Param*"));
    check(!(FloatProc1Param(*pfltmax) == FLT_MAX),		TEXT("FloatProc1Param*"));

    // parameter passed on using near/far/ellipses
    check(!(PShortProc1Param(&shrtmin) == pshrtmin),			TEXT("PShortProc1Param*"));
    check(!(LPIntProc1Param((int *)&intmin) == (int *)pintmin),	TEXT("LPIntProc1Param*"));

    // variable parameters and recursive
    check(!(average(1,2,3,4,5,6,7,8,9, -1) == 5),	TEXT("average"));
    check(!(factorial(9) == (long)362880),			TEXT("factorial"));

    check(!(MultiParam(CHAR_MIN, INT_MAX, SHRT_MAX, LONG_MAX, DBL_MAX, LDBL_MAX, FLT_MAX) == LONG_MAX), TEXT("MultiParam"));

    // C++ object parameters and template parameters
    check(!(Cxx_Tests() == 0), TEXT("C++ objects"));
}

//****************************************************************************
// Purpose:     function returning void and has no parameter
void VoidProcNoParam(void)
{
	return;
}

// Purpose:     function returning char and has no parameter
char CharProcNoParam(void)
{
	return SCHAR_MIN;
}

// Purpose:     function returning unsigned char and has no parameter
unsigned char UCharProcNoParam(void)
{
	return UCHAR_MAX;
}

// Purpose:     function returning int and has no parameter
int IntProcNoParam(void)
{
	return INT_MIN;
}

// Purpose:     function returning unsigned int and has no parameter
unsigned int UIntProcNoParam(void)
{
	return UINT_MAX;
}

// Purpose:     function returning short and has no parameter
short ShortProcNoParam(void)
{
	return SHRT_MIN;
}

// Purpose:     function returning unsigned short and has no parameter
unsigned short UShortProcNoParam(void)
{
	return USHRT_MAX;
}

// Purpose:     function returning long and has no parameter
long LongProcNoParam(void)
{
	return LONG_MIN;
}

// Purpose:     function returning unsigned long and has no parameter
unsigned long ULongProcNoParam(void)
{
	return ULONG_MAX;
}

// Purpose:     function returning float and has no parameter
float FloatProcNoParam(void)
{
	return FLT_MIN;
}

// Purpose:     function returning Double and has no parameter
double DoubleProcNoParam(void)
{
	return DBL_MIN;
}

// Purpose:     function returning long double and has no parameter
long double LDoubleProcNoParam(void)
{
	return LDBL_MAX;
}

// this variable is modified by dummy code in the following
// functions, this prevents the generated code from becoming
// identical and getting merged (see MSDN documentation on 
// linker /OPT:ICF switch)

static int g_iDummy = 0;

//****************************************************************************
// Purpose:     function returning void and has 1 parameter
void VoidProc1Param(int i)
{
    g_iDummy = 1;
	return;
}

// Purpose:     function returning char and has 1 parameter
char CharProc1Param(char c)
{
    g_iDummy = 2;
	return c;
}
// Purpose:     function returning unsigned char and has 1 parameter
unsigned char UCharProc1Param(unsigned char uc)
{
    g_iDummy = 3;
	return uc;
}

// Purpose:     function returning int and has 1 parameter
int IntProc1Param(int i)
{
    g_iDummy = 4;
	return i;
}

// Purpose:     function returning unsigned int and has 1 parameter
unsigned int UIntProc1Param(unsigned int ui)
{
    g_iDummy = 5;
	return ui;
}

// Purpose:     function returning short and has 1 parameter
short ShortProc1Param(short s)
{
    g_iDummy = 6;
	return s;
}

// Purpose:     function returning unsigned short and has 1 parameter
unsigned short UShortProc1Param(unsigned short us)
{
    g_iDummy = 7;
	return us;
}

// Purpose:     function returning long and has 1 parameter
long LongProc1Param(long l)
{
    g_iDummy = 8;
	return l;
}

// Purpose:     function returning unsigned long and has 1 parameter
unsigned long ULongProc1Param(unsigned long ul)
{
    g_iDummy = 9;
	return ul;
}

// Purpose:     function returning float and has 1 parameter
float FloatProc1Param(float f)
{
    g_iDummy = 10;
	return f;
}

// Purpose:     function returning Double and has 1 parameter
double DoubleProc1Param(double d)
{
    g_iDummy = 11;
	return d;
}

// Purpose:     function returning long double and has 1 parameter
long double LDoubleProc1Param(long double ld)
{
    g_iDummy = 12;
	return ld;
}

//****************************************************************************
// Purpose:     function returning address and has 1 parameter
//              as pointer
short * PShortProc1Param(short * ps)
{
    g_iDummy = 13;
	return ps;
}

int * LPIntProc1Param(int * lpi)
{
    g_iDummy = 14;
	return lpi;
}

//****************************************************************************
// Purpose:     function returning address and has ... parameter
int average(int first, ...)
{
	int count = 0, sum = 0, i = first;
    va_list marker;

    va_start(marker, first);
    while (i != -1)
    {
        sum += i;
        count++;
        i = va_arg(marker, int);
    }
    va_end(marker);
    return (sum ? (sum/count):(0));
}

//****************************************************************************
// Purpose:     recursive function
unsigned long factorial(int i)
{
	if (i == 0)
        return 1;
    else
        return (i * factorial(i-1));
}

//****************************************************************************
// Purpose:     function returning long and has many parameters
long MultiParam(char c, int i, short s, long l, double d, long double ld, float f)
{
	long double ldbl = (long double)c + (long double)i + (long double)s + (long double)l + (long double)d + (long double)ld + (long double)f;
	return l;
}

void check(int i, TCHAR *pc)
{
	if( !i ) return;
	OutputDebugString(TEXT("FAILED: "));
	OutputDebugString(pc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\dmapi\DmTestHarness\Logging.h ===
//
// Automation Logging header
//

#ifndef _LOGGING_H_
#define _LOGGING_H_

#ifdef _XBOX
#include <xtl.h>
#else
#include <windows.h>
#endif

//
// Log levels
//
#define LOG_TITLE    0
#define LOG_RESULTS  1
#define LOG_NOTES    2

//
// Methods
//

void LogWrite(int level, char * str);
bool LogTestResult(char * Title, bool Pass, char * Err);
HRESULT LogVerifyHResult(HRESULT hrActual, char * Title, HRESULT hrExpected);
HRESULT LogVerifyHResultAlt(HRESULT hrActual, char * Title, HRESULT hrExpected, HRESULT hrAlternate);
void LogAPIError(HRESULT hr);
void LogTestResultAPI(char * Title, HRESULT hr);

#define LogNote(x) LogWrite(LOG_NOTES,x)

// Handy macros

#define VERIFY_TRUE(expr)							( LogTestResult(#expr, expr, NULL) )
#define VERIFY_HRESULT(expr, expectedhr)			( hr = expr, LogVerifyHResult(hr, #expr, expectedhr), hr == expectedhr )
#define VERIFY_HRESULT_ALT(expr, expectedhr, althr)	( hr = expr, LogVerifyHResultAlt(hr, #expr, expectedhr, althr), (hr == expectedhr) || (hr == althr) )


#endif // ifndef _LOGGING_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\dbgfunc\threads.cpp ===
// threads.cpp
//
// based on VC6 QA debugger test code
// \\vsqaauto\vc6snaps\debugger\core\src\threads

#include "dbgtest.h"

static HANDLE hSecondaryThread = NULL;
static DWORD dwMainThreadID, dwSecondaryThreadID;
static int intGlobal = 0;
static BOOL bInfiniteLoop = TRUE;

void FuncCalledBySecondaryThreadFunc(void)
{
    // first line of FuncCalledBySecondaryThreadFunc().
    intGlobal++;
}


unsigned long __stdcall SecondaryThreadFunc(void * pdata)
{
    // first line of SecondaryThreadFunc().

	int intLocalSecondaryThreadFunc = 1;
	intGlobal = 1;
	// line after intGlobal changed.
	while(0);
	
	FuncCalledBySecondaryThreadFunc();
	// line after call to FuncCalledBySecondaryThreadFunc().
	while(0);							

    bInfiniteLoop = TRUE;

	// loop inside SecondaryThreadFunc().
	while(bInfiniteLoop);

    hSecondaryThread = NULL;
	return 1;
}


// If a second thread already exists, CreateThreadFunc() will
// not create a new one.  To kill the secondary thread, set
// bInfiniteLoop to FALSE
void CreateThreadFunc(void)
{
    if (hSecondaryThread != NULL)
        return;

	hSecondaryThread = CreateThread(NULL, 0, SecondaryThreadFunc, 0, 0, &dwSecondaryThreadID);
	// sleeping will ensure that the thread is created before this function returns.
	Sleep(3000);
}


void Test_Threads()
{
	dwMainThreadID = GetCurrentThreadId();
	int intLocalWinMain = 0;
	CreateThreadFunc();
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\dmapi\DmTestHarness\Logging.cpp ===
//
// Automation Logging Functions
//

#include "logging.h"
#ifdef _XBOX
#include <xbdm.h>
#else
#include <xboxdbg.h>
#endif

/*

  Log format

  level,info

  000,Title
  000,Build # / Retail/Debug
  000,Run time date
  000,Start time

  002,Status messages 
  001,"Function","Test Case Title","PASS/FAIL","Error Message"

  000,End Time
  000,Total run time




  To do:

  Cache Test title for Begin/End
  Allow nested Begin/End Logging
  Re-write logging code as a C++ class
*/


//
// LogWrite
//
// Helper function to write Log data in the correct CSV format
//
void LogWrite(int level, char * str)
{
	char buf[2048];

	wsprintf(buf, "%03d,%s\n", level, str);
	OutputDebugString(buf);
}

//
// LogTestResult
//
// Used to log the result after each test pass
//
bool LogTestResult(char * Title, bool Pass, char * Err)
{
	char buf[1024];

#ifndef VERBOSE
	if (Pass)
		return Pass;
#endif
	wsprintf(buf, "\"%s\",\"%s\",\"%s\"", 
		Title ? Title : "", 
		Pass ? "PASS" : "FAIL", 
		Err ? Err : ""
		);
	LogWrite(LOG_RESULTS, buf);
	return Pass;
}

HRESULT LogVerifyHResult(HRESULT hrActual, char * Title, HRESULT hrExpected)
{
	char buf[1024];
	char hrExpectedTrans[256];
	char hrActualTrans[256];

	if (hrExpected != XBDM_NOERR)
		DmTranslateError(hrExpected, hrExpectedTrans, sizeof hrExpectedTrans);
	else
		strcpy(hrExpectedTrans, "XBDM_NOERR");

	if (hrActual != XBDM_NOERR)
		DmTranslateError(hrActual, hrActualTrans, sizeof hrActualTrans);
	else
		strcpy(hrActualTrans, "XBDM_NOERR");

#ifndef VERBOSE
	if (hrExpected == hrActual)
		return hrActual;
#endif
	wsprintf(buf, "\"%s\",\"%s\", \"Expected %08X (%s), Received %08X (%s)\"", 
		Title ? Title:"", 
		hrExpected == hrActual ? "PASS" : "FAIL", 
		hrExpected,
		hrExpectedTrans,
		hrActual,
		hrActualTrans
		);
	LogWrite(LOG_RESULTS, buf);
	return hrActual;
}

HRESULT LogVerifyHResultAlt(HRESULT hrActual, char * Title, HRESULT hrExpected, HRESULT hrAlternate)
{
	char buf[1024];
	char hrExpectedTrans[256];
	char hrActualTrans[256];
	char hrAlternateTrans[256];

	if (hrExpected != XBDM_NOERR)
		DmTranslateError(hrExpected, hrExpectedTrans, sizeof hrExpectedTrans);
	else
		strcpy(hrExpectedTrans, "XBDM_NOERR");

	if (hrActual != XBDM_NOERR)
		DmTranslateError(hrActual, hrActualTrans, sizeof hrActualTrans);
	else
		strcpy(hrActualTrans, "XBDM_NOERR");

	if (hrAlternate != XBDM_NOERR)
		DmTranslateError(hrAlternate, hrAlternateTrans, sizeof hrAlternateTrans);
	else
		strcpy(hrAlternateTrans, "XBDM_NOERR");

#ifndef VERBOSE
	if ((hrExpected == hrActual) || (hrAlternate == hrActual))
		return hrActual;
#endif
	wsprintf(buf, "\"%s\",\"%s\", \"Expected %08X (%s) or %08X (%s), Received %08X (%s)\"", 
		Title ? Title:"", 
		(hrExpected == hrActual) || (hrAlternate == hrActual) ? "PASS" : "FAIL", 
		hrExpected,
		hrExpectedTrans,
		hrAlternate,
		hrAlternateTrans,
		hrActual,
		hrActualTrans
		);
	LogWrite(LOG_RESULTS, buf);
	return hrActual;
}

//
// LogAPIError
//
// Helper function to log ongoing API error codes
//
void LogAPIError(HRESULT hr)
{
	char errortext[256];
	char buf[1024];

	DmTranslateError(hr, errortext, 256);
	wsprintf(buf, "\"APIERROR\",\"0x%08x\",\"%s\"", hr, errortext);
	LogWrite(LOG_NOTES, buf);
}

void LogTestResultAPI(char * Title, HRESULT hr)
{
	char errortext[256] = {""};

	DmTranslateError(hr, errortext, 256);
	LogTestResult(Title, (hr == XBDM_NOERR), errortext);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\dmapi\DmTestHarness\FileSystem.cpp ===
//
// Debug API - FileSystem Functions
//

#include "tests.h"
#include "logging.h"

#ifdef _XBOX

void testFileSystem() {} // these APIs are xboxdbg (Win32) only

#else

static void testDmSendFileA();
static void testDmSendFileW();
static void testDmReceiveFileA();
static void testDmReceiveFileW();
static void testDmGetFileAttributes();
static void testDmSetFileAttributes();
static void testDmMkdir();
static void testDmRenameFile();
static void testDmDeleteFile();
static void testDmWalkDir();
static void testDmCloseDir();

void testFileSystem()
{
	testDmSendFileA();
	testDmSendFileW();
	testDmReceiveFileA();
	testDmReceiveFileW();
	testDmGetFileAttributes();
	testDmSetFileAttributes();
	testDmMkdir();
	testDmRenameFile();
	testDmDeleteFile();
	testDmWalkDir();
	testDmCloseDir();
}

void testDmWalkDir()
{
	HRESULT				hr;
	PDM_WALK_DIR		pWalkDir = NULL;
	DM_FILE_ATTRIBUTES	buffer;

	// Pass NULL for WalkDir

	pWalkDir = NULL;
	memset(&buffer, 0, sizeof buffer);
	VERIFY_HRESULT(DmWalkDir(NULL, "e:\\", &buffer), E_INVALIDARG);
	if (hr != E_INVALIDARG)
		DmCloseDir(pWalkDir);

	// Pass NULL for szDir

	pWalkDir = NULL;
	memset(&buffer, 0, sizeof buffer);
	VERIFY_HRESULT(DmWalkDir(&pWalkDir, NULL, &buffer), E_INVALIDARG);
	if (hr != E_INVALIDARG)
		DmCloseDir(pWalkDir);

	// Pass NULL for DM_FILE_ATTRIBUTES ptr

	pWalkDir = NULL;
	VERIFY_HRESULT(DmWalkDir(&pWalkDir, "e:\\", NULL), E_INVALIDARG);
	if (hr != E_INVALIDARG)
		DmCloseDir(pWalkDir);

	// Pass valid WalkDir

	pWalkDir = NULL;
	memset(&buffer, 0, sizeof buffer);
	VERIFY_HRESULT_ALT(DmWalkDir(&pWalkDir, "e:\\samples", &buffer), XBDM_NOERR, XBDM_ENDOFLIST);
	if (hr == XBDM_NOERR || hr == XBDM_ENDOFLIST)
		hr = DmCloseDir(pWalkDir);

	// Pass invalid directory for szDir

	pWalkDir = NULL;
	memset(&buffer, 0, sizeof buffer);
	VERIFY_HRESULT(DmWalkDir(&pWalkDir, "e:\\bogusdirectory", &buffer), XBDM_CANNOTACCESS);
	if (hr == XBDM_NOERR || hr == XBDM_ENDOFLIST)
		DmCloseDir(pWalkDir);
	
	// Pass root directory for szDir

	pWalkDir = NULL;
	memset(&buffer,0,sizeof buffer);
	VERIFY_HRESULT(DmWalkDir(&pWalkDir, "e:\\", &buffer), XBDM_NOERR);
	if (hr == XBDM_NOERR || hr == XBDM_ENDOFLIST)
		hr = DmCloseDir(pWalkDir);
	
	// Pass long directory name for szDir

	pWalkDir = NULL;
	memset(&buffer,0,sizeof buffer);
	VERIFY_HRESULT_ALT(DmMkdir("e:\\123456789012345678901234567890123456789012"), , XBDM_NOERR, XBDM_ALREADYEXISTS);
	VERIFY_HRESULT_ALT(DmWalkDir(&pWalkDir, "e:\\123456789012345678901234567890123456789012", &buffer), XBDM_NOERR, XBDM_ENDOFLIST);
	if (hr == XBDM_NOERR || hr == XBDM_ENDOFLIST)
		DmCloseDir(pWalkDir);
}

void testDmCloseDir()
{
	HRESULT				hr;
	PDM_WALK_DIR		pWalkDir = NULL;
	DM_FILE_ATTRIBUTES	buffer;

	// using Null

	hr = DmCloseDir(NULL);
	VERIFY_HRESULT(DmCloseDir(NULL), E_INVALIDARG);

	// using valid object

	hr = DmWalkDir(&pWalkDir, "e:\\", &buffer);
	if (hr != XBDM_NOERR)
		LogTestResult("DmCloseDir(valid PDM_WALK_DIR)", false, "Unable to obtain valid DM_WALK_DIR object");
	else 
		VERIFY_HRESULT(DmCloseDir(pWalkDir), XBDM_NOERR);
}

void testDmMkdir()
{
	HRESULT			hr;
	char			buffer[1024];

	// Pass NULL

	VERIFY_HRESULT(DmMkdir(NULL), E_INVALIDARG);

	// Pass empty string

	VERIFY_HRESULT(DmMkdir(""), XBDM_CANNOTCREATE);

	// Pass existing directory

	VERIFY_HRESULT(DmMkdir("e:\\dxt"), XBDM_ALREADYEXISTS);

	// Pass existing file

	GetEnvironmentVariable("SystemRoot", buffer, sizeof(buffer));
	strcat(buffer, "\\taskman.exe");

	hr = DmSendFile(buffer, "e:\\PreExistingFile");
	VERIFY_HRESULT(DmMkdir("e:\\PreExistingFile"), XBDM_ALREADYEXISTS);

	// Pass relative path

#if 0 // Bug 3443, resolved by design in your absence
	VERIFY_HRESULT(DmMkdir("e:\\dxt\\..\\bogus"), hr);
#endif

	// Pass invalid path

	VERIFY_HRESULT(DmMkdir("o:\\"), XBDM_NOSUCHFILE);

	// Pass long directory name

	VERIFY_HRESULT_ALT(DmMkdir("e:\\123456789012345678901234567890123456789012"), XBDM_NOERR, XBDM_ALREADYEXISTS);

	// Pass long path

	VERIFY_HRESULT_ALT(DmMkdir("e:\\dxt\\123456789012345678901234567890123456789012"), XBDM_NOERR, XBDM_ALREADYEXISTS);
	
	// Pass directory name with leading spaces

	VERIFY_HRESULT(DmMkdir("  e:\\leading spaces in dir name"), XBDM_CANNOTCREATE);

	// Pass directory name with trailing spaces

	VERIFY_HRESULT(DmMkdir("e:\\trailing spaces in dir name   "), XBDM_NOERR);
}


void testDmDeleteFile()
{
	HRESULT				hr;
	DM_FILE_ATTRIBUTES	FileAttributes;
	char				szFileToSend[1024];

	GetEnvironmentVariable("SystemRoot", szFileToSend, sizeof(szFileToSend));
	strcat(szFileToSend, "\\taskman.exe");

	// Pass NULL with IsDirectory = false

	VERIFY_HRESULT(DmDeleteFile(NULL, false), E_INVALIDARG);

	// Pass NULL with IsDirectory = true

	VERIFY_HRESULT(DmDeleteFile(NULL, true), E_INVALIDARG);

	// Use existing file with IsDirectory==false

	hr = DmSendFile(szFileToSend, "e:\\PreExistingFile");
	VERIFY_HRESULT(DmDeleteFile("e:\\PreExistingFile", false), XBDM_NOERR);

	// Use existing file with IsDirectory==true

	hr = DmSendFile(szFileToSend, "e:\\PreExistingFile");
	VERIFY_HRESULT(DmDeleteFile("e:\\PreExistingFile", true), XBDM_CANNOTACCESS);

	// Use invalid name with IsDirectory==false

	VERIFY_HRESULT(DmDeleteFile("e:\\DmDeleteFile_bogus_name", false), XBDM_NOSUCHFILE);
	
	// Use invalid name with IsDirectory==true

	VERIFY_HRESULT(DmDeleteFile("e:\\DmDeleteFile_bogus_name", true), XBDM_NOSUCHFILE);
	
	// Use valid directory empty with IsDirectory==false

	hr = DmMkdir("e:\\DmDeleteFileEmptyDir1");
	VERIFY_HRESULT(DmDeleteFile("e:\\DmDeleteFileEmptyDir1", false), XBDM_CANNOTACCESS);

	// Use valid directory empty with IsDirectory==true

	hr = DmMkdir("e:\\DmDeleteFileEmptyDir2");
	VERIFY_HRESULT(DmDeleteFile("e:\\DmDeleteFileEmptyDir2", true), XBDM_NOERR);

	// Use valid directory non-empty with IsDirectory==false

	hr = DmMkdir("e:\\DmDeleteFileNonEmptyDir1");
	hr = DmSendFile(szFileToSend, "e:\\DmDeleteFileNonEmptyDir1\taskman");
	VERIFY_HRESULT(DmDeleteFile("e:\\DmDeleteFileNonEmptyDir1", false), XBDM_CANNOTACCESS);

	// Use valid directory non-empty with IsDirectory==true

	hr = DmMkdir("e:\\DmDeleteFileNonEmptyDir2");
	hr = DmSendFile(szFileToSend, "e:\\DmDeleteFileNonEmptyDir2\\taskman");
	VERIFY_HRESULT(DmDeleteFile("e:\\DmDeleteFileNonEmptyDir2", true), XBDM_DIRNOTEMPTY);
	
	// Use read-only directory

	hr = DmMkdir("e:\\DmDeleteFileReadOnlyDir");
	hr = DmGetFileAttributes("e:\\DmDeleteFileReadOnlyDir", &FileAttributes);
	FileAttributes.Attributes |= FILE_ATTRIBUTE_READONLY;
	hr = DmSetFileAttributes("e:\\DmDeleteFileReadOnlyDir", &FileAttributes);
	VERIFY_HRESULT(DmDeleteFile("e:\\DmDeleteFileReadOnlyDir", true), XBDM_CANNOTACCESS);

	// Use hidden directory

	hr = DmMkdir("e:\\DmDeleteFileHiddenDir");
	hr = DmGetFileAttributes("e:\\DmDeleteFileHiddenDir", &FileAttributes);
	FileAttributes.Attributes |= FILE_ATTRIBUTE_HIDDEN;
	hr = DmSetFileAttributes("e:\\DmDeleteFileHiddenDir", &FileAttributes);
	VERIFY_HRESULT(DmDeleteFile("e:\\DmDeleteFileHiddenDir", true), XBDM_NOERR);

	// Use read-only file

	hr = DmSendFile(szFileToSend, "e:\\DmDeleteFileReadOnlyFile");
	hr = DmGetFileAttributes("e:\\DmDeleteFileReadOnlyFile", &FileAttributes);
	FileAttributes.Attributes |= FILE_ATTRIBUTE_READONLY;
	hr = DmSetFileAttributes("e:\\DmDeleteFileReadOnlyFile", &FileAttributes);
	VERIFY_HRESULT(DmDeleteFile("e:\\DmDeleteFileReadOnlyFile", false), XBDM_CANNOTACCESS);

	// Use hidden file

	hr = DmSendFile(szFileToSend, "e:\\DmDeleteFileHiddenFile");
	hr = DmGetFileAttributes("e:\\DmDeleteFileHiddenFile", &FileAttributes);
	FileAttributes.Attributes |= FILE_ATTRIBUTE_HIDDEN;
	hr = DmSetFileAttributes("e:\\DmDeleteFileHiddenFile", &FileAttributes);
	VERIFY_HRESULT(DmDeleteFile("e:\\DmDeleteFileHiddenFile", false), XBDM_NOERR);
	
	// Use filename with leading spaces

	hr = DmSendFile(szFileToSend, "e:\\   DmDeleteFileFilenameLeadingSpaces");
	VERIFY_HRESULT(DmDeleteFile("e:\\   DmDeleteFileFilenameLeadingSpaces", false), XBDM_NOERR);

	// Use filename with trailing spaces

	hr = DmSendFile(szFileToSend, "e:\\DmDeleteFileFilenameTrailingSpaces   ");
	VERIFY_HRESULT(DmDeleteFile("e:\\DmDeleteFileFilenameTrailingSpaces   ", false), XBDM_NOERR);

	// Use directory with leading spaces

	hr = DmMkdir("e:\\   DmDeleteFileDirLeadingSpaces");
	VERIFY_HRESULT(DmDeleteFile("e:\\   DmDeleteFileDirLeadingSpaces", true), XBDM_NOERR);

	// Use directory with trailing spaces

	hr = DmMkdir("e:\\DmDeleteFileDirTrailingSpaces   ");
	VERIFY_HRESULT(DmDeleteFile("e:\\DmDeleteFileDirTrailingSpaces   ", true), XBDM_NOERR);

	// Use long filename

	hr = DmSendFile(szFileToSend, "e:\\DmDeleteFileLongFileName123456789012345678");
	VERIFY_HRESULT(DmDeleteFile("e:\\DmDeleteFileLongFileName123456789012345678", false), XBDM_NOERR);

	// Use long directory name

	hr = DmMkdir("e:\\DmDeleteFileLongDirName1234567890123456789");
	VERIFY_HRESULT(DmDeleteFile("e:\\DmDeleteFileLongDirName1234567890123456789", true), XBDM_NOERR);
}

void testDmRenameFile()
{
	HRESULT hr;
	char	szFileToSend[1024];

	GetEnvironmentVariable("SystemRoot", szFileToSend, sizeof(szFileToSend));
	strcat(szFileToSend, "\\taskman.exe");

	// Pass NULL for OldName

	VERIFY_HRESULT(DmRenameFile(NULL, "e:\\DmRenameFileTemp1b"), E_INVALIDARG);

	// Pass NULL for NewName

	hr = DmSendFile(szFileToSend, "e:\\DmRenameFileTemp2a");
	VERIFY_HRESULT(DmRenameFile("e:\\DmRenameFileTemp2a", NULL), E_INVALIDARG);

	// Pass empty string for OldName

	VERIFY_HRESULT(DmRenameFile("", "e:\\DmRenameFileTemp3b"), XBDM_CANNOTACCESS);

	// Pass empty string for NewName

	hr = DmSendFile(szFileToSend, "e:\\DmRenameFileTemp4a");
	VERIFY_HRESULT(DmRenameFile("e:\\DmRenameFileTemp4a", ""), XBDM_BADFILENAME);

	// Pass valid file for OldName
	// Pass directory for OldName
	// Pass invalid file for OldName
	// Pass read-only file for OldName
	// Pass valid file with leading/trailing spaces for OldName
	// Pass valid name for NewName
	// Pass valid name with leading/trailing spaces for NewName
	// Pass directory for NewName
	// Pass existing file for NewName
	// Pass existing read-only file for NewName
}

void testDmGetFileAttributes()
{
	HRESULT hr;
	DM_FILE_ATTRIBUTES FileAttr;
	char	szFileToSend[1024];

	GetEnvironmentVariable("SystemRoot", szFileToSend, sizeof(szFileToSend));
	strcat(szFileToSend, "\\taskman.exe");

	// Pass Null for filename

	VERIFY_HRESULT(DmGetFileAttributes(NULL, &FileAttr), E_INVALIDARG);
	
	// Pass Null for FileAttributes

	VERIFY_HRESULT(DmGetFileAttributes("e:\\dxt", NULL), E_INVALIDARG);

	// Pass empty string for filename

	VERIFY_HRESULT(DmGetFileAttributes("", &FileAttr), XBDM_NOSUCHFILE);
	
	// Pass valid filename

	hr = DmSendFile(szFileToSend, "e:\\DmGetFileAttributesValidFile");
	VERIFY_HRESULT(DmGetFileAttributes("e:\\DmGetFileAttributesValidFile", &FileAttr), XBDM_NOERR);

	// Pass directory name

	VERIFY_HRESULT(DmGetFileAttributes("e:\\dxt", &FileAttr), XBDM_NOERR);

	// Pass valid filename with leading/trailing spaces
	// Pass invalid filename
	// Pass long filename
	// Pass long directory name
	// Pass MAX_PATH filename
}

void testDmSetFileAttributes()
{
	HRESULT hr;
	DM_FILE_ATTRIBUTES FileAttr;
	char	szFileToSend[1024];

	GetEnvironmentVariable("SystemRoot", szFileToSend, sizeof(szFileToSend));
	strcat(szFileToSend, "\\taskman.exe");

	// Pass Null for filename

	VERIFY_HRESULT(DmSetFileAttributes(NULL, &FileAttr), E_INVALIDARG);

	// Pass Null for FileAttributes

	VERIFY_HRESULT(DmSetFileAttributes("e:\\dxt", NULL), E_INVALIDARG);

	// Pass empty string for filename

	VERIFY_HRESULT(DmSetFileAttributes("", &FileAttr), XBDM_CANNOTACCESS);
	
	// Pass valid filename

	hr = DmSendFile(szFileToSend, "e:\\DmSetFileAttributesValidFile1");
	hr = DmGetFileAttributes("e:\\DmSetFileAttributesValidFile1", &FileAttr);
	FileAttr.Attributes |= FILE_ATTRIBUTE_READONLY;
	VERIFY_HRESULT(DmSetFileAttributes("e:\\DmSetFileAttributesValidFile1", &FileAttr), XBDM_NOERR);

	// Pass directory name

	hr = DmGetFileAttributes("e:\\dxt", &FileAttr);
	FileAttr.Attributes |= FILE_ATTRIBUTE_READONLY;
	VERIFY_HRESULT(DmSetFileAttributes("e:\\dxt", &FileAttr), XBDM_NOERR);

	// Pass valid filename with leading/trailing spaces
	// Pass invalid filename
	// Pass long filename
	// Pass long directory name
	// Pass MAX_PATH filename

	// insure that DmSetFileAttributes does NOT modify its arguments
	// bug 3420

	DM_FILE_ATTRIBUTES FileAttr2;
	hr = DmSendFile(szFileToSend, "e:\\DmGetFileAttributesValidFile2");
	hr = DmGetFileAttributes("e:\\DmGetFileAttributesValidFile2", &FileAttr);
	FileAttr.Attributes |= FILE_ATTRIBUTE_READONLY;
	FileAttr2 = FileAttr;
	hr = DmSetFileAttributes("e:\\DmGetFileAttributesValidFile2", &FileAttr);
	if (memcmp(&FileAttr, &FileAttr2, sizeof(FileAttr)) != 0)
		LogTestResult("DmSetFileAttributes() - argument not modified", false, "argument modified");
	else
		LogTestResult("DmSetFileAttributes() - argument not modified", true, "");
}

void testDmSendFile(BOOL fUseWideChar)
{
	HRESULT hr;
	char	szFileToSend[MAX_PATH];
	WCHAR	wszFileToSend[MAX_PATH];

	if (fUseWideChar)
	{
		GetEnvironmentVariableW(L"SystemRoot", wszFileToSend, sizeof(wszFileToSend));
		wcscat(wszFileToSend, L"\\taskman.exe");
	}
	else
	{
		GetEnvironmentVariableA("SystemRoot", szFileToSend, sizeof(szFileToSend));
		strcat(szFileToSend, "\\taskman.exe");
	}

	// Pass NULL for LocalName

	if (fUseWideChar)
		; //VERIFY_HRESULT(DmSendFileW(NULL, "e:\\DmSendFileTemp1b"), E_INVALIDARG);
	else
		VERIFY_HRESULT(DmSendFileA(NULL, "e:\\DmSendFileTemp1b"), E_INVALIDARG);

	// Pass NULL for RemoteName

	if (fUseWideChar)
		; //VERIFY_HRESULT(DmSendFileW(wszFileToSend, NULL), E_INVALIDARG);
	else
		VERIFY_HRESULT(DmSendFileA(szFileToSend, NULL), E_INVALIDARG);

	// Pass empty string for LocalName

	if (fUseWideChar)
		; //VERIFY_HRESULT(DmSendFileW(L"", "e:\\DmSendFileTemp3b"), XBDM_BADFILENAME);
	else
		VERIFY_HRESULT(DmSendFileA("", "e:\\DmSendFileTemp3b"), XBDM_BADFILENAME);

	// Pass empty string for NewName

	if (fUseWideChar)
		; //VERIFY_HRESULT(DmSendFileW(wszFileToSend, ""), XBDM_BADFILENAME);
	else
		VERIFY_HRESULT(DmSendFileA(szFileToSend, ""), XBDM_BADFILENAME);

	// Pass read-only file for LocalName
	// Pass invalid file for LocalName
	// Pass directory for LocalName
	// Pass valid file with leading/trailing spaces for LocalName
	// Pass read-only file for RemoteName
	// Pass invalid file for RemoteName
	// Pass directory for RemoteName
	// Pass valid file with leading/trailing spaces for RemoteName
}

void testDmSendFileA() { testDmSendFile(false); }
void testDmSendFileW() { testDmSendFile(true); }

void testDmReceiveFile(BOOL fUseWideChar)
{
	HRESULT hr;
	char	szFileToReceive[MAX_PATH];
	WCHAR	wszFileToReceive[MAX_PATH];

	// Pass NULL for LocalName

	if (fUseWideChar)
		; //VERIFY_HRESULT(DmReceiveFileW(NULL, "e:\\samples\\cartoon\\cartoon.xbe"), E_INVALIDARG);
	else
		VERIFY_HRESULT(DmReceiveFileA(NULL, "e:\\samples\\cartoon\\cartoon.xbe"), E_INVALIDARG);

	// Pass NULL for RemoteName

	if (fUseWideChar)
	{
		GetEnvironmentVariableW(L"Temp", wszFileToReceive, sizeof(wszFileToReceive));
		wcscat(wszFileToReceive, L"\\DmReceiveFileTemp2a");
	}
	else
	{
		GetEnvironmentVariable("Temp", szFileToReceive, sizeof(szFileToReceive));
		strcat(szFileToReceive, "\\DmReceiveFileTemp2a");
	}

	if (fUseWideChar)
		; //VERIFY_HRESULT(DmReceiveFileW(L"c:\\winnt\\temp\\DmReceiveFileTemp2a", NULL), E_INVALIDARG);
	else
		VERIFY_HRESULT(DmReceiveFileA("c:\\winnt\\temp\\DmReceiveFileTemp2a", NULL), E_INVALIDARG);

	// Pass empty string for LocalName

	if (fUseWideChar)
		; //VERIFY_HRESULT(DmReceiveFileW(L"", "e:\\samples\\cartoon\\cartoon.xbe"), XBDM_BADFILENAME);
	else
		VERIFY_HRESULT(DmReceiveFileA("", "e:\\samples\\cartoon\\cartoon.xbe"), XBDM_BADFILENAME);

	// Pass empty string for RemoteName

	if (fUseWideChar)
	{
		GetEnvironmentVariableW(L"Temp", wszFileToReceive, sizeof(wszFileToReceive));
		wcscat(wszFileToReceive, L"\\DmReceiveFileTemp4a");
	}

	if (fUseWideChar)
		; //VERIFY_HRESULT(DmReceiveFileW(wszFileToReceive, ""), XBDM_BADFILENAME);
	else
		VERIFY_HRESULT(DmReceiveFileA(szFileToReceive, ""), XBDM_BADFILENAME);

	// Pass read-only file for LocalName
	// Pass invalid file for LocalName
	// Pass directory for LocalName
	// Pass valid file with leading/trailing spaces for LocalName
	// Pass read-only file for RemoteName
	// Pass invalid file for RemoteName
	// Pass directory for RemoteName
	// Pass valid file with leading/trailing spaces for RemoteName
}

void testDmReceiveFileA() { testDmReceiveFile(false); }
void testDmReceiveFileW() { testDmReceiveFile(true); }

#endif // #ifdef _XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\dmapi\DmTestHarness\config.cpp ===
//
// Debugger API - Config functions
//

#include "tests.h"
#include "logging.h"
#include <stdio.h>

static void testDmSetConfigValue();
static void testDmGetXboxName();
static void testDmSetXboxName();
static void testDmSetXboxNameNoRegister();

void testConfig()
{
	testDmSetConfigValue();
	testDmGetXboxName();
	testDmSetXboxName();
	testDmSetXboxNameNoRegister();
}

void testDmSetConfigValue()
{
#ifndef _XBOX
	HRESULT hr;
	// this is an undocumented function
	// VERIFY_HRESULT(DmSetConfigValue(0, 0, 0, 0), XBDM_NOERR);
#endif
}

void testDmGetXboxName()
{
	HRESULT			hr;
	unsigned char	szStoredName[256];
	char			buffer[260];
	DWORD			dwStoredSize;
	DWORD			Type, dwSize;
	HKEY			key;

#ifndef _XBOX
	// get name via registry

	dwStoredSize = sizeof szStoredName;
	RegOpenKeyEx(HKEY_CURRENT_USER, "Software\\Microsoft\\XboxSDK", 0, KEY_QUERY_VALUE, &key);
	RegQueryValueEx(key, "XboxName", NULL, &Type, szStoredName, &dwStoredSize);
	RegCloseKey(key);
	dwStoredSize = strlen(reinterpret_cast<const char *>(szStoredName));
#endif

	// Verify name matches registry value

	memset(buffer, 0, sizeof buffer);
	dwSize = sizeof buffer;
	VERIFY_HRESULT(DmGetXboxName(buffer, &dwSize), XBDM_NOERR);
#ifndef _XBOX
	VERIFY_TRUE(strcmp(buffer, (char *) szStoredName) == 0);
#else
	strcpy(szStoredName, buffer);
	dwStoredSize = dwSize;
#endif

	// Pass NULL for buf

	memset(buffer, 0, sizeof buffer);
	dwSize = sizeof buffer;
	VERIFY_HRESULT(DmGetXboxName(NULL, &dwSize), E_INVALIDARG);

	// Pass NULL for max

	memset(buffer, 0, sizeof buffer);
	dwSize = sizeof buffer;
 	VERIFY_HRESULT(DmGetXboxName(buffer, NULL), E_INVALIDARG);

	// Pass # < actual name for max

	if (dwStoredSize > 0)
	{
		memset(buffer, 0, sizeof buffer);
		dwSize = dwStoredSize - 1;
 		VERIFY_HRESULT(DmGetXboxName(buffer, &dwSize /* too small */), XBDM_BUFFER_TOO_SMALL);
	}

	// Pass # > actual name for max

	if (dwStoredSize > 0)
	{
		memset(buffer, 0, sizeof buffer);
		dwSize = dwStoredSize + 1;
 		VERIFY_HRESULT(DmGetXboxName(buffer, &dwSize /* too big */), XBDM_NOERR);
	}
}

void testDmSetXboxName()
{
	HRESULT		hr;
	char		szStoredName[256];
	char		szBuffer[260];
	DWORD		dwStoredSize;
	DWORD		i, dwIP;

	dwStoredSize = sizeof szStoredName;
	DmGetXboxName(szStoredName, &dwStoredSize);

	// Pass NULL for name

	VERIFY_HRESULT(DmSetXboxName(NULL), XBDM_NOERR);

	// Pass empty string for name

	VERIFY_HRESULT(DmSetXboxName(""), E_INVALIDARG);

	// Pass 1 char string for name

	VERIFY_HRESULT(DmSetXboxName("A"), XBDM_NOERR);

	// Pass numeric string for name (should resolve to IP)

	DmResolveXboxName(&dwIP);
	sprintf(szBuffer, "%d.%d.%d.%d", (dwIP>>24)&0xFF, (dwIP>>16)&0xFF, (dwIP>>8)&0xFF, dwIP&0xFF);
	VERIFY_HRESULT(DmSetXboxName(szBuffer /*IP*/), XBDM_NOERR);

	// Pass < 255 char string for name

	for (i=0; i<255; i++)
		szBuffer[i]=char('0'+((i+1)%10));
	szBuffer[255]='\0';
	hr = DmSetXboxName(szBuffer);
	VERIFY_HRESULT(DmSetXboxName(szBuffer /* < 255 char Name */), XBDM_NOERR);

	// Pass > 255 char string for name
	
	for (i=0; i<256; i++)
		szBuffer[i]=char('0'+((i+1)%10));
	szBuffer[256]='\0';
	VERIFY_HRESULT(DmSetXboxName(szBuffer /* > 255 char Name */), E_INVALIDARG);

	DmSetXboxName(szStoredName);
}

void testDmSetXboxNameNoRegister()
{
#ifndef _XBOX
	HRESULT		hr;
	char		szStoredName[256];
	char		szBuffer[260];
	DWORD		dwStoredSize;
	DWORD		i, dwIP;

	dwStoredSize = sizeof szStoredName;
	DmGetXboxName(szStoredName, &dwStoredSize);

	// Pass NULL for name

	VERIFY_HRESULT(DmSetXboxNameNoRegister(NULL), XBDM_NOERR);

	// Pass empty string for name

	VERIFY_HRESULT(DmSetXboxNameNoRegister(""), E_INVALIDARG);

	// Pass 1 char string for name

	VERIFY_HRESULT(DmSetXboxNameNoRegister("A"), XBDM_NOERR);

	// Pass numeric string for name (should resolve to IP)

	DmResolveXboxName(&dwIP);
	sprintf(szBuffer, "%d.%d.%d.%d", (dwIP>>24)&0xFF, (dwIP>>16)&0xFF, (dwIP>>8)&0xFF, dwIP&0xFF);
	VERIFY_HRESULT(DmSetXboxNameNoRegister(szBuffer /*IP*/), XBDM_NOERR);

	// Pass < 255 char string for name

	for (i=0; i<255; i++)
		szBuffer[i] = char('0'+((i+1)%10));
	szBuffer[255] = '\0';
	VERIFY_HRESULT(DmSetXboxNameNoRegister(szBuffer /* < 255 char Name */), XBDM_NOERR);

	// Pass > 255 char string for name
	
	for (i=0; i<256; i++)
		szBuffer[i] = char('0'+((i+1)%10));
	szBuffer[256] = '\0';
	VERIFY_HRESULT(DmSetXboxNameNoRegister(szBuffer /* > 255 char Name */), E_INVALIDARG);

	DmSetXboxName(szStoredName);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\dmapi\dmstress\dmstress.cpp ===
// DMAPI stress
//

#include <windows.h>
#include <stdio.h>
#include <crtdbg.h>
#include "xboxdbg.h"

#define DMSTRESSMSG(str) printf(str "\n")
#define DMSTRESSMSGWAIT printf(".")

DWORD __stdcall XboxNotificationHandler(ULONG dwNotification, DWORD dwParam);
DWORD __stdcall XboxNotificationProcessor(LPCSTR szNotification);
void ReconnectToXbox();
void XboxRerun(char *, char *);

// global variables
PDM_CONNECTION g_connection = NULL;
PDMN_SESSION g_session = NULL;
HANDLE g_hevtReboot;
int g_reconnect = 0;
HRESULT hr;

void __cdecl main(int argc, char *argv[])
{
    int count = 0;

	try
	{
		ReconnectToXbox();
		
		g_hevtReboot = CreateEvent(NULL, FALSE, FALSE, NULL);

		while (1)
		{	if (argc == 3)
				XboxRerun(argv[1], argv[2]);
			else
			{
				printf("USAGE: DMSTRESS [path] [xbe]");
				printf("defaulting to: E:\\samples\\fire fire.xbe");
				XboxRerun("E:\\samples\\fire", "fire.xbe");
			}
            printf("DmStress: [%d]\n", count);
            count++;
			Sleep(100);
		}
	}

	catch(...)
	{
        printf("*** Catch block invoked ***\n");
		CloseHandle(g_hevtReboot);

		DmNotify(g_session, DM_NONE, NULL);
		DmCloseNotificationSession(g_session);
		DmCloseConnection(g_connection);
	}
}

#define REPORTIFFAILED(expr) \
{ \
	hr = expr; \
	if (FAILED(hr)) \
	{ \
        char szErr[1024], szBuf[1024]; \
		DmTranslateErrorA(hr, szErr, 1024); \
		sprintf(szBuf, "FAILED: %s [%s]\n", #expr, szErr); \
		printf(szBuf); \
		Sleep(3000); \
	} \
    else \
		printf("SUCCEEDED: " #expr "\n"); \
}

void ReconnectToXbox()
{
	if (g_reconnect)
        printf("Calls to ReconnectToXbox() = %d\n", g_reconnect);

	g_reconnect++;

	if (g_session)
	{
		REPORTIFFAILED(DmNotify(g_session, DM_NONE, NULL));
		REPORTIFFAILED(DmCloseNotificationSession(g_session));
		g_session = NULL;
	}
	if (g_connection)
	{
		REPORTIFFAILED(DmCloseConnection(g_connection));
		g_connection = NULL;
	}

	REPORTIFFAILED(DmOpenConnection(&g_connection));
	REPORTIFFAILED(DmUseSharedConnection(TRUE));
	REPORTIFFAILED(DmOpenNotificationSession(DM_PERSISTENT, &g_session));
	//REPORTIFFAILED(DmNotify(g_session, DM_DEBUGSTR, XboxNotificationHandler));
	REPORTIFFAILED(DmNotify(g_session, DM_EXCEPTION, XboxNotificationHandler));
	//REPORTIFFAILED(DmNotify(g_session, DM_ASSERT, XboxNotificationHandler));
	//REPORTIFFAILED(DmNotify(g_session, DM_RIP, XboxNotificationHandler));
	REPORTIFFAILED(DmNotify(g_session, DM_EXEC, XboxNotificationHandler));
	//REPORTIFFAILED(DmRegisterNotificationProcessor(g_session, "Gravity", XboxNotificationProcessor));

	REPORTIFFAILED(DmConnectDebugger(TRUE));
}


DWORD __stdcall XboxNotificationHandler(ULONG dwNotification, DWORD dwParam)
{
	// Make sure there's no way we get in here twice.
	static bool inHere = false;
	if (inHere)
		return 0;
	inHere = true;
	
	switch (dwNotification & DM_NOTIFICATIONMASK)
	{
		case DM_DEBUGSTR:
		{
			DMSTRESSMSG("XboxNotificationHandler: DM_DEBUGSTR");
			DMN_DEBUGSTR* info = (DMN_DEBUGSTR*) dwParam;
			break;
		}

		case DM_EXCEPTION:
		{
			DMSTRESSMSG("XboxNotificationHandler: DM_EXCEPTION");
			break;
		}

		case DM_ASSERT:
		{
			DMSTRESSMSG("XboxNotificationHandler: DM_ASSERT");
			if (dwNotification & DM_STOPTHREAD)
			{
				/*
				int ret = MessageBox(str, MB_ABORTRETRYIGNORE);
				if (ret == IDABORT)
				{
					RebootXbox(true);
				}
				else
				{
					DmGo();
				}
				*/
			}
			break;
		}
		case DM_RIP:
		{
			DMSTRESSMSG("XboxNotificationHandler: DM_RIP");
			break;
		}

		case DM_EXEC:
		{
			switch (dwParam)
			{
			case DMN_EXEC_STOP :
				DMSTRESSMSG("XboxNotificationHandler: DM_EXEC(DMN_EXEC_STOP)");
				break;
			case DMN_EXEC_START :
				DMSTRESSMSG("XboxNotificationHandler: DM_EXEC(DMN_EXEC_START)");
				break;
			case DMN_EXEC_REBOOT :
				DMSTRESSMSG("XboxNotificationHandler: DM_EXEC(DMN_EXEC_REBOOT)");
				break;
			case DMN_EXEC_PENDING :
				DMSTRESSMSG("XboxNotificationHandler: DM_EXEC(DMN_EXEC_PENDING)");
				break;
			default :
				 DMSTRESSMSG("XboxNotificationHandler: DM_EXEC(???)");
				break;
			}
			//if (dwParam != DMN_EXEC_REBOOT)
			if (dwParam == DMN_EXEC_PENDING)
				SetEvent(g_hevtReboot);
			break;
		}
	}

	inHere = false;
	return 0;
}


DWORD __stdcall XboxNotificationProcessor(LPCSTR szNotification)
{
	// do nothing
	return 0;
}


bool RebootXbox(bool rebootToTitleLauncher)
{
	ResetEvent(g_hevtReboot);
	
	bool rebootCompleted = false;
	while (true)
	{
		HRESULT hr = DmReboot(DMBOOT_WARM | (rebootToTitleLauncher ? 0 : DMBOOT_WAIT));
		if (SUCCEEDED(hr))
		{
			DMSTRESSMSG("Waiting for g_hevtReboot event");
			while (true)
			{
				DMSTRESSMSGWAIT;
				if (WaitForSingleObject(g_hevtReboot, 0) == WAIT_OBJECT_0)
				{
					return true;
				}
				Sleep(250);
			}
		}
		else if (hr == XBDM_CONNECTIONLOST)
		{
			DMSTRESSMSG("RebootXbox() : DmReboot() returned XBDM_CONNECTIONLOST, calling ReconnectToXbox()");
			ReconnectToXbox();
		}
	}

	return false;
}

void XboxRerun(char *szXBEDir, char *szXBEName)
{
	_ASSERT(_CrtCheckMemory());

	if (RebootXbox(false))
	{	
		while (true)
		{
			DMSTRESSMSG("XboxRerun() : calling DmSetTitle()");
			REPORTIFFAILED(DmSetTitle(szXBEDir, szXBEName, ""));
			if (SUCCEEDED(hr))
			{
				while (true)
				{
					DMSTRESSMSG("XBoxRerun() : DmGo()...");
					REPORTIFFAILED(DmGo());
					if (SUCCEEDED(hr))
						goto Done;
					else if (hr == XBDM_CONNECTIONLOST)
					{
						DMSTRESSMSG("XBoxRerun() : DmGo() returned XBDM_CONNECTIONLOST, calling ReconnectToXbox()");
						Sleep(250);
						ReconnectToXbox();
					}
					else
					{
						DMSTRESSMSG("XBoxRerun() : DmGo() failed but not XBDM_CONNECTIONLOST");
                        Sleep(3000);
					}
				}
			}
			else if (hr == XBDM_CONNECTIONLOST)
			{
				DMSTRESSMSG("XBoxRerun() : DmSetTitle() returned XBDM_CONNECTIONLOST, calling ReconnectToXbox()");
				Sleep(250);
				ReconnectToXbox();
			}
			else
			{
				DMSTRESSMSG("XBoxRerun() : DmSetTitle() failed but not XBDM_CONNECTIONLOST");
                Sleep(3000);
			}
		}
	}

Done:
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\dmapi\DmTestHarness\main.cpp ===
// Main.cpp : Defines the entry point for the console application.
//

#include "tests.h"

void __cdecl main(int argc, char* argv[])
{
	testPerfCounters();
	return;

	// notification
	testNotification();

	// breakpoint routines
	testBreakpoint();
	testExecution();

	// reboot
	testDmReboot();

	// memory
	testMemory();

	// thread routines
	testThreadSupport();

	// xtl data, modules and sections, xbe info
	testDmGetXtlData();
	testModulesAndSections();
	testDmGetXbeInfo();

	// socket-level commands
	testSocketCommands();

	// filesystem
	testFileSystem();

	// time
	testDmGetSystemTime();

	// config and name functions
	testConfig();

	// management functions
	testSecurity();

	// title to launch

	// screenshot/snapshot

	// start/stop profile data collection

	// performance counters
	testPerfCounters();

	// drive info
	testDmGetDriveList();
	testDmGetDiskFreeSpace();

	// error codes
	testDmTranslateError();

	// image file routines
	testImageFileRoutines();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\dmapi\DmTestHarness\memory.cpp ===
//
// Scratch area for writing quick code snippets
//
//

#include "tests.h"
#include "logging.h"
#include <stdio.h>

// retail xbox units have 64Mb of memory
// address range is 0x00000000 - 0x03FFFFFF
// development kits have 128 Mb
// address range is 0x04000000 - 0x07FFFFFF

#define VALID_ADDR_LO 0x00040000
#define VALID_ADDR_HI 0x04040000

void VerifyMemory(const char *buf, unsigned int len, char expected, char *errhdr)
{
	char sztmp[160];
	for (unsigned int i = 0; i < len; i++)
		if (buf[i] != expected)
		{
			sprintf(sztmp, "at %03d expected 0x%02x, found 0x%02x", i, expected, buf[i]);
			LogTestResult(errhdr, false, sztmp);
		}
}

void testMemory()
{
	HRESULT	hr;
	char	buffer[512];
	DWORD	size;

	/* unmapped section of memory */
	VERIFY_HRESULT(DmGetMemory(0, sizeof buffer, buffer, &size), XBDM_NOERR);	// size = 0
	VERIFY_HRESULT(DmGetMemory(0, 10, buffer, &size), XBDM_NOERR);				// size = 0
	VERIFY_HRESULT(DmGetMemory(0, sizeof buffer, buffer, NULL), XBDM_MEMUNMAPPED);
	VERIFY_HRESULT(DmGetMemory(0, 1, buffer, &size), XBDM_NOERR);				// size = 0
	VERIFY_HRESULT(DmGetMemory(0, 1, buffer, NULL), XBDM_MEMUNMAPPED);
	VERIFY_HRESULT(DmGetMemory(0, 0, buffer, &size), XBDM_NOERR);
	VERIFY_HRESULT(DmGetMemory(0, 0, buffer, NULL), XBDM_NOERR);
	VERIFY_HRESULT(DmGetMemory(0, 10, NULL, &size), E_INVALIDARG);
	VERIFY_HRESULT(DmGetMemory(0, 10, NULL, NULL), E_INVALIDARG);

	/* mapped section of memory */
	VERIFY_HRESULT(DmGetMemory((const void *) VALID_ADDR_LO, sizeof buffer, buffer, &size), XBDM_NOERR);
	VERIFY_HRESULT(DmGetMemory((const void *) VALID_ADDR_LO, sizeof buffer, NULL, &size), E_INVALIDARG);
	VERIFY_HRESULT(DmGetMemory((const void *) VALID_ADDR_LO, sizeof buffer, NULL, NULL), E_INVALIDARG);

	VERIFY_HRESULT(DmGetMemory((const void *) VALID_ADDR_HI, sizeof buffer, buffer, &size), XBDM_NOERR);
	VERIFY_HRESULT(DmGetMemory((const void *) VALID_ADDR_HI, sizeof buffer, NULL, &size), E_INVALIDARG);
	VERIFY_HRESULT(DmGetMemory((const void *) VALID_ADDR_HI, sizeof buffer, NULL, NULL), E_INVALIDARG);

	FillMemory(buffer, sizeof buffer, 0);

	/* unmapped section of memory */
	VERIFY_HRESULT(DmSetMemory(0, sizeof buffer, buffer, &size), XBDM_MEMUNMAPPED);
	VERIFY_HRESULT(DmSetMemory(0, 10, buffer, &size), XBDM_MEMUNMAPPED);
	VERIFY_HRESULT(DmSetMemory(0, sizeof buffer, buffer, NULL), XBDM_MEMSETINCOMPLETE);
	VERIFY_HRESULT(DmSetMemory(0, 1, buffer, &size), XBDM_MEMUNMAPPED);
	VERIFY_HRESULT(DmSetMemory(0, 1, buffer, NULL), XBDM_MEMSETINCOMPLETE);
	VERIFY_HRESULT(DmSetMemory(0, 0, buffer, &size), XBDM_NOERR);
	VERIFY_HRESULT(DmSetMemory(0, 0, buffer, NULL), XBDM_NOERR);
	VERIFY_HRESULT(DmSetMemory(0, 10, NULL, &size), E_INVALIDARG);
	VERIFY_HRESULT(DmSetMemory(0, 10, NULL, NULL), E_INVALIDARG);

	/* mapped section of memory */
	VERIFY_HRESULT(DmSetMemory(( void *) VALID_ADDR_LO, sizeof buffer, buffer, &size), XBDM_NOERR);
	VERIFY_HRESULT(DmSetMemory(( void *) VALID_ADDR_LO, sizeof buffer, NULL, &size), E_INVALIDARG);
	VERIFY_HRESULT(DmSetMemory(( void *) VALID_ADDR_LO, sizeof buffer, NULL, NULL), E_INVALIDARG);

	//VERIFY_HRESULT(DmSetMemory(( void *) VALID_ADDR_HI, sizeof buffer, buffer, &size), XBDM_NOERR);
	VERIFY_HRESULT(DmSetMemory(( void *) VALID_ADDR_HI, sizeof buffer, NULL, &size), E_INVALIDARG);
	VERIFY_HRESULT(DmSetMemory(( void *) VALID_ADDR_HI, sizeof buffer, NULL, NULL), E_INVALIDARG);

	/* check memory transfers */

	// put 0x2d in one buffer-sized block, and immediately get it
	FillMemory(buffer, sizeof buffer, 0x2d);
	VERIFY_HRESULT(DmSetMemory(( void *) VALID_ADDR_LO, sizeof buffer, buffer, &size), XBDM_NOERR);
	ZeroMemory(buffer, sizeof buffer);
	VERIFY_HRESULT(DmGetMemory(( void *) VALID_ADDR_LO, sizeof buffer, buffer, &size), XBDM_NOERR);
	VerifyMemory(buffer, sizeof buffer, 0x2d, "DmSetMemory/DmGetMemory");

	// put 0x3c in one buffer-sized block, and above it put 0x6f's
	FillMemory(buffer, sizeof buffer, 0x3c);
	VERIFY_HRESULT(DmSetMemory(( void *) VALID_ADDR_LO, sizeof buffer, buffer, &size), XBDM_NOERR);
	FillMemory(buffer, sizeof buffer, 0x6f);
	VERIFY_HRESULT(DmSetMemory(( void *) (VALID_ADDR_LO + sizeof buffer), sizeof buffer, buffer, &size), XBDM_NOERR);

	// get half the 0x3c's: we expect the buffer to be half 0x03c, half 0x6f's
	// because we didn't clear the local buffer from the previous exercise
	VERIFY_HRESULT(DmGetMemory((const void *) VALID_ADDR_LO, sizeof buffer / 2, buffer, &size), XBDM_NOERR);
	VerifyMemory(buffer, (sizeof buffer) / 2, 0x3c, "DmGetMemory [split block, lower half]");
	VerifyMemory(buffer + ((sizeof buffer) / 2), (sizeof buffer) / 2, 0x6f, "DmGetMemory [split block, upper half]");

	// get all the 0x3c's
	ZeroMemory(buffer, sizeof buffer);
	VERIFY_HRESULT(DmGetMemory((const void *) VALID_ADDR_LO, sizeof buffer, buffer, &size), XBDM_NOERR);
	VerifyMemory(buffer, sizeof buffer, 0x3c, "DmGetMemory [lower block]");

	// get all the 0x6f's
	ZeroMemory(buffer, sizeof buffer);
	VERIFY_HRESULT(DmGetMemory((const void *) (VALID_ADDR_LO + sizeof buffer), sizeof buffer, buffer, &size), XBDM_NOERR);
	VerifyMemory(buffer, sizeof buffer, 0x6f, "DmGetMemory [upper block]");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\dmapi\DmTestHarness\Test.cpp ===
//
// Scratch area for writing quick code snippets
//
//

#include "tests.h"
#include "logging.h"

void testRebootAndSetTitle()
{
	HRESULT	hr;

	//
	// Reboot box and wait 15 seconds
	//
	hr = DmReboot(DMBOOT_WAIT);

	//
	// This call should be blocked until the box's connection comes back
	// online. And thus set the launch title to dolphin classic. It appears that
	// if you call this too early, it times out after 30 seconds. Need to wait
	// till the IP address appears on the screen prior to calling this API.
	//
	Sleep(16000);		// This appears to be the time it takes the box to cold boot
	hr = DmSetTitle("e:\\samples\\dolphinclassic", "dolphinclassic.xbe", "");
	hr = hr + 1;	// dummy code to set a breakpoint on.
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\dmapi\DmTestHarness\socket.cpp ===
//
// Debug API - Socket Functions
//

#include "tests.h"
#include "logging.h"

void testDmOpenConnection();
void testDmCloseConnection();

void testSocketCommands()
{
	LogNote("*** testSecurity not ready for primetime ***");
	return;

	testDmOpenConnection();
	testDmCloseConnection();
}

void testDmOpenConnection()
{
	HRESULT			hr;
	PDM_CONNECTION	pConnection, apConnection[256];

	// Pass NULL

	VERIFY_HRESULT(DmOpenConnection(NULL), E_INVALIDARG);

	// Open with valid pConnection

	if (VERIFY_HRESULT(DmOpenConnection(&pConnection), XBDM_NOERR))
		hr = DmCloseConnection(pConnection);

	// Open till Max Connections

	for (int i=0; i<256; i++)
	{
		if (! VERIFY_HRESULT_ALT(DmOpenConnection(&apConnection[i]), XBDM_NOERR, XBDM_MAXCONNECT))
			break;
	}

	// Clean up open connections
	for (int j=0; j<i; j++)
		DmCloseConnection(apConnection[j]);
}


void testDmCloseConnection()
{
	HRESULT			hr;
	PDM_CONNECTION	pConnection;

	// using Null

	VERIFY_HRESULT(DmCloseConnection(NULL), E_INVALIDARG);

	// using valid pointer

	hr = DmOpenConnection(&pConnection);
	VERIFY_HRESULT(DmCloseConnection(pConnection), XBDM_NOERR);
}


void testDmUseSharedConnection()
{
	HRESULT hr;

	// Call with true after call with false

	hr = DmUseSharedConnection(false);
	VERIFY_HRESULT(DmUseSharedConnection(true), XBDM_NOERR);

	// Call with true after call with true

	hr = DmUseSharedConnection(true);
	VERIFY_HRESULT(DmUseSharedConnection(true), XBDM_NOERR);

	// Call with false after call with true

	hr = DmUseSharedConnection(true);
	VERIFY_HRESULT(DmUseSharedConnection(false), XBDM_NOERR);

	// Call with false after call with false

	hr = DmUseSharedConnection(false);
	VERIFY_HRESULT(DmUseSharedConnection(false), XBDM_NOERR);
}


void testDmResolveXboxName()
{
	HRESULT			hr;
	unsigned char	storedName[256];
	char			buffer[1024];
	DWORD			storedSize = 256;

	DWORD			Type;
	HKEY			key;
	DWORD			IP, oldIP;

	// Get Registry entry for XboxName, just in case
	
	LogNote("Obtaining XboxName stored in registry");

	RegOpenKeyEx(HKEY_CURRENT_USER, "Software\\Microsoft\\XboxSDK", 0, KEY_QUERY_VALUE, &key);
	RegQueryValueEx(key, "XboxName", NULL, &Type, storedName, &storedSize);
	RegCloseKey(key);
	
	storedSize = strlen(reinterpret_cast<const char *>(storedName));
	wsprintf(buffer, "Registry XboxName: %s", storedName);
	LogNote(buffer);

	// Pass NULL

	VERIFY_HRESULT(DmResolveXboxName(NULL), E_INVALIDARG);

	// Verify IP address matches XboxName in registry

	hr = DmResolveXboxName(&oldIP);
	wsprintf(buffer, "%d.%d.%d.%d", (oldIP>>24)&0xFF, (oldIP>>16)&0xFF, (oldIP>>8)&0xFF, oldIP&0xFF);
	hr = DmSetXboxName(buffer);
	IP = 0;
	hr = DmResolveXboxName(&IP);
	if (IP != oldIP)
		LogTestResult("DmResolveXboxName(&IP) returns valid IP", false, "value != actual IP");
	else
		LogTestResult("DmResolveXboxName(&IP) returns valid IP", true, "");

	// Set XboxName to bogus value

	IP = 0;
	hr = DmSetXboxName("La Di Da");
	VERIFY_HRESULT(DmResolveXboxName(&IP), XBDM_CANNOTCONNECT);

	// Restore name to original value

	LogNote("Restoring XboxName registry to original value");

	hr = DmSetXboxName(reinterpret_cast<const char *>(storedName));
}


void testDmReceiveBinary()
{
	HRESULT			hr;
	PDM_CONNECTION	pConnection;
	char			buffer[1024];
	DWORD			size;

	// Pass valid pConnection
	// Pass cb == 0
	// Pass cb == 1
	// Pass cb < data being sent
	// Pass cb > data being sent

	hr = DmOpenConnection(&pConnection);
	if (hr != XBDM_NOERR)
	{
		LogNote("Unable to open Connection to test DmReceiveBinary()");
		return;
	}

	size = 0;
	memset(buffer, 0, sizeof buffer);

	// Pass NULL for pConnection

	VERIFY_HRESULT(DmReceiveBinary(NULL, buffer, sizeof buffer, &size), E_INVALIDARG);

	// Pass NULL for pw

	VERIFY_HRESULT(DmReceiveBinary(pConnection, NULL, sizeof buffer, &size), E_INVALIDARG);

#if 0	// Bug 3545
	// Pass NULL for pcbRet

	VERIFY_HRESULT(DmReceiveBinary(pConnection, buffer, sizeof buffer, NULL), E_INVALIDARG);
#endif

	// Pass valid pConnection

	hr = DmSendBinary(pConnection, "SYSTIME\n\r", 9);
	VERIFY_HRESULT(DmReceiveBinary(pConnection, buffer, sizeof buffer, &size), XBDM_NOERR);

	// Pass cb == 0

	hr = DmSendBinary(pConnection, "SYSTIME\n\r", 9);
	VERIFY_HRESULT(DmReceiveBinary(pConnection, buffer, 0, &size), XBDM_NOERR);

	// Pass cb == -1
	// Pass cb == data being sent

	hr = DmCloseConnection(pConnection);
}

void testDmReceiveSocketLine()
{
	HRESULT			hr;
	PDM_CONNECTION	pConnection;
	char			buffer[1024];
	DWORD			size;


	hr = DmOpenConnection(&pConnection);
	if (hr != XBDM_NOERR)
	{
		LogNote("Unable to open Connection to test DmReceiveSocketLine()");
		return;
	}

	size = sizeof buffer;
	memset(buffer, 'X', size);

	// Pass NULL for pConnection

	hr = DmSendBinary(NULL, "SYSTIME\n\r", 9);
	VERIFY_HRESULT(DmReceiveSocketLine(NULL, buffer, &size), E_INVALIDARG);

	// Pass NULL for szResponse

	hr = DmSendBinary(pConnection, "SYSTIME\n\r", 9);
	VERIFY_HRESULT(DmReceiveSocketLine(pConnection, NULL, &size), E_INVALIDARG);

	// Pass NULL for lpdwResponseSize

	hr = DmSendBinary(pConnection, "SYSTIME\n\r", 9);
	VERIFY_HRESULT(DmReceiveSocketLine(pConnection, buffer, NULL), E_INVALIDARG);

	// Pass valid pConnection

	hr = DmSendBinary(pConnection, "SYSTIME\n\r", 9);
	VERIFY_HRESULT(DmReceiveSocketLine(pConnection, buffer, &size), XBDM_NOERR);

	// Pass size == 0

	hr = DmSendBinary(pConnection, "SYSTIME\n\r", 9);
	VERIFY_HRESULT(DmReceiveSocketLine(pConnection, buffer, 0), E_INVALIDARG);

	// Pass size > incoming data
	// Pass size < incoming data
	// Pass size == 1

	hr = DmCloseConnection(pConnection);
}

void testDmReceiveStatusResponse()
{
	HRESULT			hr;
	PDM_CONNECTION	pConnection;
	char			buffer[1024];
	DWORD			size;

	hr = DmOpenConnection(&pConnection);
	if (hr != XBDM_NOERR)
	{
		LogNote("Unable to open Connection to test DmReceiveStatusResponse()");
		return;
	}

	size = sizeof buffer;
	memset(buffer, 'X', size);

	// Pass NULL for pConnection

	hr = DmSendBinary(NULL, "SYSTIME\n\r", 9);
	VERIFY_HRESULT(DmReceiveStatusResponse(NULL, buffer, &size), E_INVALIDARG);

	// Pass NULL for szResponse
/* ******* NEED TO LOOK INTO THIS *******
	TEST_BEGIN("DmReceiveStatusResponse(pConnection, NULL, &size)");
	hr = DmSendBinary(pConnection, "SYSTIME\n\r", 9);
	hr = DmReceiveStatusResponse(pConnection, NULL, &size);
	VERIFY_HRESULT("DmReceiveStatusResponse(pConnection, NULL, &size)", hr);
	TEST_END("DmReceiveStatusResponse(pConnection, NULL, &size)");
*/
	// Pass NULL for lpdwResponseSize

	hr = DmSendBinary(pConnection, "SYSTIME\n\r", 9);
	VERIFY_HRESULT(DmReceiveStatusResponse(pConnection, buffer, NULL), E_INVALIDARG);

	// Pass valid pConnection

	hr = DmSendBinary(pConnection, "SYSTIME\n\r", 9);
	VERIFY_HRESULT(DmReceiveStatusResponse(pConnection, buffer, &size), XBDM_NOERR);

	// Pass size == 0

	hr = DmSendBinary(pConnection, "SYSTIME\n\r", 9);
	VERIFY_HRESULT(DmReceiveStatusResponse(pConnection, buffer, 0), E_INVALIDARG);

	// Pass size > incoming data
	// Pass size < incoming data
	// Pass size == 1

	hr = DmCloseConnection(pConnection);
}

void testDmSendBinary()
{
	HRESULT			hr;
	PDM_CONNECTION	pConnection;
	char			buffer[1024];
	DWORD			size;


	hr = DmOpenConnection(&pConnection);
	if (hr != XBDM_NOERR)
	{
		LogNote("Unable to open Connection to test DmSendBinary()");
		return;
	}

	size = sizeof buffer;
	memset(buffer, 'X', size);

	// Pass NULL for pConnection

	VERIFY_HRESULT(DmSendBinary(NULL, buffer, size), E_INVALIDARG);

	// Pass NULL for pw

	VERIFY_HRESULT(DmSendBinary(pConnection, NULL, size), E_INVALIDARG);

	// Pass valid pConnection

	VERIFY_HRESULT(DmSendBinary(pConnection, buffer, size), XBDM_NOERR);

	// Pass cb == 0

	VERIFY_HRESULT(DmSendBinary(pConnection, buffer, 0), XBDM_NOERR);

	// Pass cb == -1
	// Pass cb == data being sent

	hr = DmCloseConnection(pConnection);
}

void testDmSendCommand()
{
	HRESULT			hr;
	PDM_CONNECTION	pConnection;
	char			buffer[1024];
	DWORD			size;

	hr = DmOpenConnection(&pConnection);
	if (hr != XBDM_NOERR)
	{
		LogNote("Unable to open Connection to test DmSendCommand()");
		return;
	}

	DmUseSharedConnection(false);
	// Pass NULL for pConnection

	size = sizeof buffer;
	VERIFY_HRESULT(DmSendCommand(NULL, "SYSTIME", buffer, &size), E_INVALIDARG);

	// Pass NULL for szCommand

	size = sizeof buffer;
	VERIFY_HRESULT(DmSendCommand(pConnection, NULL, buffer, &size), E_INVALIDARG);

	// Pass NULL for szResponse

	size = sizeof buffer;
	VERIFY_HRESULT(DmSendCommand(pConnection, "SYSTIME", NULL, &size), XBDM_NOERR);

	// Pass NULL for lpdwResponseSize

	size = sizeof buffer; 
	VERIFY_HRESULT(DmSendCommand(pConnection, "SYSTIME", buffer, NULL), E_INVALIDARG);

	// Pass valid pConnection

	size = sizeof buffer;
	VERIFY_HRESULT(DmSendCommand(pConnection, "SYSTIME", buffer, &size), XBDM_NOERR);

	// Pass empty string for szCommand

	size = sizeof buffer;
	VERIFY_HRESULT(DmSendCommand(pConnection, "", buffer, &size), XBDM_INVALIDCMD);

	// Pass 1 char for szCommand
	// Pass Command, but no handler for szCommand
	// Pass long string for szCommand
	// Pass 0 for size
	// Pass 1 for size
	// Pass size of buffer for size

	hr = DmCloseConnection(pConnection);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\dmapi\DmTestHarness\perf.cpp ===
//
// Debug API - Socket Functions
//

#include "tests.h"
#include "logging.h"

static void testDmQueryPerformanceCounter();
static void testDmWalkPerformanceCounters();
static void testDmCloseCounters();
static void testDmEnableGPUCounter();
static void testDmScreenShot();
static void testDmPixelShaderSnapshot();
static void testDmVertextShaderSnapshot();

void testPerfCounters()
{
	testDmQueryPerformanceCounter();
	testDmWalkPerformanceCounters();
	testDmCloseCounters();
	testDmEnableGPUCounter();
	testDmScreenShot();
	testDmPixelShaderSnapshot();
	testDmVertextShaderSnapshot();
}

void testDmQueryPerformanceCounter()
{
#ifndef _XBOX
	HRESULT				hr;
	PDM_WALK_COUNTERS	walk_counters = NULL;
	DM_COUNTINFO		counter;
	DM_COUNTDATA		data;

	VERIFY_HRESULT(DmUseSharedConnection(TRUE), XBDM_NOERR);
	VERIFY_HRESULT(DmQueryPerformanceCounter("% CPU:total", 0x21, &data), XBDM_NOERR);
	VERIFY_HRESULT(DmQueryPerformanceCounter("% CPU:TOTAL", 0x21, &data), XBDM_NOERR);
	VERIFY_HRESULT(DmQueryPerformanceCounter("% CPU:total",    0, &data), E_INVALIDARG);
	VERIFY_HRESULT(DmQueryPerformanceCounter("% CPU:total", 0x21,  NULL), E_INVALIDARG);
	VERIFY_HRESULT(DmQueryPerformanceCounter(      "BOGUS", 0x21, &data), XBDM_NOSUCHFILE);
	VERIFY_HRESULT(DmQueryPerformanceCounter(           "", 0x21, &data), XBDM_NOSUCHFILE);
	VERIFY_HRESULT(DmQueryPerformanceCounter(         NULL, 0x21, &data), E_INVALIDARG);

	VERIFY_HRESULT_ALT(DmWalkPerformanceCounters(&walk_counters, &counter), XBDM_NOERR, XBDM_ENDOFLIST);
	while (SUCCEEDED(hr) && (hr != XBDM_ENDOFLIST))
	{
		VERIFY_HRESULT_ALT(DmQueryPerformanceCounter(counter.Name, counter.Type, &data), XBDM_NOERR, XBDM_COUNTUNAVAILABLE);

		VERIFY_HRESULT_ALT(DmWalkPerformanceCounters(&walk_counters, &counter), XBDM_NOERR, XBDM_ENDOFLIST);
	}
	VERIFY_HRESULT(DmCloseCounters(walk_counters), XBDM_NOERR);
#endif
}

void testDmWalkPerformanceCounters()
{
	HRESULT				hr;
	PDM_WALK_COUNTERS	walk_counters = NULL;
	DM_COUNTINFO		counter;
	char				buf[256];

	OutputDebugString("*** begin perf counter walk ***\n");
	VERIFY_HRESULT_ALT(DmWalkPerformanceCounters(&walk_counters, &counter), XBDM_NOERR, XBDM_ENDOFLIST);
	while (SUCCEEDED(hr) && (hr != XBDM_ENDOFLIST))
	{
		wsprintf(buf, "counter: %-16s type: 0x%08X\n", 
				counter.Name,
				counter.Type
				);
		OutputDebugString(buf);
		VERIFY_HRESULT_ALT(DmWalkPerformanceCounters(&walk_counters, &counter), XBDM_NOERR, XBDM_ENDOFLIST);
	}
	OutputDebugString("*** end perf counter walk ***\n");
	VERIFY_HRESULT(DmCloseCounters(walk_counters), XBDM_NOERR);
}

void testDmCloseCounters()
{
	HRESULT				hr;
	PDM_WALK_COUNTERS	walk_counters = NULL;
	DM_COUNTINFO		counter;

	// no walk, immediate close

	VERIFY_HRESULT_ALT(DmWalkPerformanceCounters(&walk_counters, &counter), XBDM_NOERR, XBDM_ENDOFLIST);
	VERIFY_HRESULT(DmCloseCounters(walk_counters), XBDM_NOERR);

	// full walk

	walk_counters = NULL;
	VERIFY_HRESULT_ALT(DmWalkPerformanceCounters(&walk_counters, &counter), XBDM_NOERR, XBDM_ENDOFLIST);
	while (SUCCEEDED(hr) && (hr != XBDM_ENDOFLIST))
	{
		VERIFY_HRESULT_ALT(DmWalkPerformanceCounters(&walk_counters, &counter), XBDM_NOERR, XBDM_ENDOFLIST);
	}
	VERIFY_HRESULT(DmCloseCounters(walk_counters), XBDM_NOERR);

	// null and ptr to null

	VERIFY_HRESULT(DmCloseCounters(NULL), E_INVALIDARG);
	VERIFY_HRESULT(DmCloseCounters(walk_counters = NULL), E_INVALIDARG);
}

void testDmEnableGPUCounter()
{
	HRESULT	hr;
	DM_COUNTDATA gpu, frontend, backend;

	VERIFY_HRESULT(DmEnableGPUCounter(TRUE), XBDM_NOERR);
	// enable when already enabled
	VERIFY_HRESULT(DmEnableGPUCounter(TRUE), XBDM_NOERR);

	VERIFY_HRESULT(DmQueryPerformanceCounter("% GPU", 0x21, &gpu), XBDM_NOERR);
	VERIFY_HRESULT(DmQueryPerformanceCounter("% GPU Frontend", 0x21, &frontend), XBDM_NOERR);
	VERIFY_HRESULT(DmQueryPerformanceCounter("% GPU Backend", 0x21, &backend), XBDM_NOERR);

	VERIFY_HRESULT(DmEnableGPUCounter(FALSE), XBDM_NOERR);

	VERIFY_HRESULT(DmQueryPerformanceCounter("% GPU", 0x21, &gpu), XBDM_COUNTUNAVAILABLE);
	VERIFY_HRESULT(DmQueryPerformanceCounter("% GPU Frontend", 0x21, &frontend), XBDM_COUNTUNAVAILABLE);
	VERIFY_HRESULT(DmQueryPerformanceCounter("% GPU Backend", 0x21, &backend), XBDM_COUNTUNAVAILABLE);

	// disable already disabled
	VERIFY_HRESULT(DmEnableGPUCounter(FALSE), XBDM_NOERR);
}

void testDmScreenShot()
{
#ifndef _XBOX
	HRESULT hr;
	char szTempPath[MAX_PATH];

	DWORD dwNeeded = GetEnvironmentVariableA("TEMP", szTempPath, sizeof szTempPath);
	if (!dwNeeded || (dwNeeded > sizeof szTempPath))
		return;
	strcat(szTempPath, "\\scrnshot.bmp");

	VERIFY_HRESULT(DmScreenShot(szTempPath), XBDM_NOERR);
	HANDLE hScreenShot = CreateFile(szTempPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);
	VERIFY_TRUE(hScreenShot != INVALID_HANDLE_VALUE);
	VERIFY_TRUE(GetFileSize(hScreenShot, NULL) != 0);
	CloseHandle(hScreenShot);
	DeleteFile(szTempPath);

	// reuse filename
	VERIFY_HRESULT(DmScreenShot(szTempPath), XBDM_NOERR);
	VERIFY_HRESULT(DmScreenShot(szTempPath), XBDM_NOERR);
	hScreenShot = CreateFile(szTempPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);
	VERIFY_TRUE(hScreenShot != INVALID_HANDLE_VALUE);
	VERIFY_TRUE(GetFileSize(hScreenShot, NULL) != 0);
	CloseHandle(hScreenShot);
	DeleteFile(szTempPath);

	VERIFY_HRESULT(DmScreenShot(NULL), E_INVALIDARG);
	VERIFY_HRESULT(DmScreenShot(""), XBDM_FILEERROR);
	VERIFY_HRESULT(DmScreenShot("C:\\Invalid+File%Name|.bmp"), XBDM_FILEERROR);
	VERIFY_HRESULT(DmScreenShot("C:\\PathThatDoesntExist\\scrnshot.bmp"), XBDM_FILEERROR);
	VERIFY_HRESULT(DmScreenShot("\\\\xdk\\xdktest\\scrnshot.bmp"), XBDM_NOERR);
#endif
}

void testDmPixelShaderSnapshot()
{
#ifndef _XBOX
	// TODO: DmPixelShaderSnapshot - figure out
#endif
}

void testDmVertextShaderSnapshot()
{
#ifndef _XBOX
	// TODO: DmVertexShaderSnapshot - figure out
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\dmapi\DmTestHarness\Misc.cpp ===
//
// Debug API - Miscellaneous Functions
//

#include "tests.h"
#include "logging.h"
#include <wchar.h>

void testBreakpoint()
{
	LogNote("*** testBreakpoint not ready for primetime ***");
	return;
	HRESULT	hr;
/*
	hr = DmSetBreakpoint(0);					// success
	hr = DmSetBreakpoint((void *)0x0040000);	// success
	hr = DmSetBreakpoint((void *)0xFFFFFFF);	// success

	hr = DmRemoveBreakpoint(0);					// success
	hr = DmRemoveBreakpoint((void *)0x0040000);	// success
	hr = DmRemoveBreakpoint((void *)0x0040000);	// 2nd time should fail (XBDM_UNDEFINED)
	hr = DmRemoveBreakpoint((void *)0xFFFFFFF);	// success

	hr = DmSetDataBreakpoint(0, DMBREAK_READWRITE, 1);	// success
	hr = DmSetDataBreakpoint(0, DMBREAK_READWRITE, 0);	// E_INVALIDARG
	hr = DmSetDataBreakpoint((void *)0x0040000, DMBREAK_READWRITE, 1);	// success
	hr = DmSetDataBreakpoint((void *)0x0040000, DMBREAK_READWRITE, 0);	// E_INVALIDARG
*/
	hr = DmSetInitialBreakpoint();			// XBDM_UNDEFINED
}

void testExecution()
{
	LogNote("*** testExecution not ready for primetime ***");
	return;
	HRESULT	hr;

	hr = DmGo();								// XBDM_UNDEFINED
	hr = DmStop();								// success
	hr = DmStop();								// XBDM_UNDEFINED
	hr = DmGo();								// success

	hr = DmStopOn(DMSTOP_CREATETHREAD, true);
	hr = DmStopOn(DMSTOP_CREATETHREAD, false);
	hr = DmStopOn(DMSTOP_FCE, true);
	hr = DmStopOn(DMSTOP_FCE, false);
	hr = DmStopOn(DMSTOP_DEBUGSTR, true);
	hr = DmStopOn(DMSTOP_DEBUGSTR, false);
	hr = DmStopOn(9999, true);					// success ???
	hr = DmStopOn(9999, false);					// success ???
}

void testDmGetXtlData()
{
	DM_XTLDATA xtlData;

	// TODO: DmGetXtlData - get more info

	DmGetXtlData(&xtlData);
}

void testDmGetSystemTime()
{
#ifndef _XBOX
	HRESULT		hr;
	SYSTEMTIME	st;

	// Pass NULL for LPSYSTEMTIME

	VERIFY_HRESULT(DmGetSystemTime(NULL), E_INVALIDARG);

	// Verify SYSTEMTIME returned is valid

	memset(&st, 0, sizeof st);
//	wsprintf(buffer, "SYSTEMTIME: %02d/%02x/%02s %02d:%02d:%02d.%03d\n",
//		st.wMonth, st.wDay, st.wYear, st.wHour, 
//		st.wMinute, st.wSecond, st.wMilliseconds);
//	LogNote(buffer);
	VERIFY_HRESULT(DmGetSystemTime(&st), XBDM_NOERR);
#endif
}

#define TRANSLATEERRORTEST(TYPE,STRING) \
	hr = DmTranslateErrorA(TYPE, buffer, sizeof buffer); \
	if (strcmp(buffer,STRING)) \
		LogTestResult("DmTranslateErrorA(" #TYPE ", buffer, 512)", false, #TYPE " should return: " #STRING); \
	else \
		LogTestResult("DmTranslateErrorA(" #TYPE ", buffer, 512)", true, ""); \

	/*
	hr = DmTranslateErrorW(TYPE, wbuffer, sizeof wbuffer); \
	if (wcscmp(wbuffer,L##STRING)) \
		LogTestResult("DmTranslateErrorW(" #TYPE ", wbuffer, 512)", false, #TYPE " should return: " #STRING); \
	else \
		LogTestResult("DmTranslateErrorW(" #TYPE ", wbuffer, 512)", true, "");
	*/

void testDmTranslateError()
{
#ifndef _XBOX
	HRESULT		hr;
	char		buffer[512];
	WCHAR		wbuffer[512];

	// Pass NULL for lpBuffer

	VERIFY_HRESULT(DmTranslateError(XBDM_UNDEFINED, NULL, 512), E_INVALIDARG);

	// Pass 0 for nBufferMax

	VERIFY_HRESULT(DmTranslateError(XBDM_UNDEFINED, buffer, 0), E_INVALIDARG);

	// Pass 1 for nBufferMax
	// fails because of BUG 3396 (won't fix)
	// VERIFY_HRESULT(DmTranslateError(XBDM_UNDEFINED, buffer, 1), XBDM_BUFFER_TOO_SMALL);

	// Pass # > error string size for nBufferMax

	VERIFY_HRESULT(DmTranslateError(XBDM_UNDEFINED, buffer, 512), XBDM_NOERR);

	// Pass 0 for HRESULT

	VERIFY_HRESULT(DmTranslateError(0, buffer, 512), XBDM_NOERRORSTRING);

	// Pass all Error codes for HRESULT

	TRANSLATEERRORTEST(XBDM_UNDEFINED       , "Undefined network error");
	TRANSLATEERRORTEST(XBDM_MAXCONNECT      , "Maximum number of Xbox connections exceeded");
	TRANSLATEERRORTEST(XBDM_NOSUCHFILE      , "No such file exists on the Xbox");
	TRANSLATEERRORTEST(XBDM_NOMODULE        , "No such module");
	TRANSLATEERRORTEST(XBDM_MEMUNMAPPED     , "Xbox memory unmapped");
	TRANSLATEERRORTEST(XBDM_NOTHREAD        , "No such Xbox thread id");
	TRANSLATEERRORTEST(XBDM_INVALIDCMD      , "Unexpected Xbox network error");
	TRANSLATEERRORTEST(XBDM_NOTSTOPPED      , "Thread not stopped");
	TRANSLATEERRORTEST(XBDM_MUSTCOPY        , "File must be copied, not moved");
	TRANSLATEERRORTEST(XBDM_ALREADYEXISTS   , "File already exists");
	TRANSLATEERRORTEST(XBDM_DIRNOTEMPTY     , "Directory not empty");
	TRANSLATEERRORTEST(XBDM_BADFILENAME     , "Illegal filename");
	TRANSLATEERRORTEST(XBDM_CANNOTCREATE    , "Cannot create file");
	TRANSLATEERRORTEST(XBDM_CANNOTACCESS    , "Cannot access file");
	TRANSLATEERRORTEST(XBDM_DEVICEFULL      , "Device is full");
	TRANSLATEERRORTEST(XBDM_NOTDEBUGGABLE   , "Title is not debuggable");
	TRANSLATEERRORTEST(XBDM_CANNOTCONNECT   , "Cannot connect to Xbox");
	TRANSLATEERRORTEST(XBDM_CONNECTIONLOST  , "Connection to Xbox lost");
	TRANSLATEERRORTEST(XBDM_FILEERROR       , "Unexpected file error");
	TRANSLATEERRORTEST(XBDM_ENDOFLIST       , "");
	TRANSLATEERRORTEST(XBDM_BUFFER_TOO_SMALL, "");
	TRANSLATEERRORTEST(XBDM_NOTXBEFILE      , "File is not an Xbox executable image");
	TRANSLATEERRORTEST(XBDM_MEMSETINCOMPLETE, "Not all requested memory could be written");
	TRANSLATEERRORTEST(XBDM_NOXBOXNAME      , "No address for Xbox has been set");
	TRANSLATEERRORTEST(XBDM_NOERRORSTRING   , "");

	// Pass all Success codes for HRESULT

	VERIFY_HRESULT(DmTranslateError(XBDM_NOERR, buffer, 512), XBDM_NOERRORSTRING);
	VERIFY_HRESULT(DmTranslateError(XBDM_CONNECTED, buffer, 512), XBDM_NOERRORSTRING);
	VERIFY_HRESULT(DmTranslateError(XBDM_MULTIRESPONSE, buffer, 512), XBDM_NOERRORSTRING);
	VERIFY_HRESULT(DmTranslateError(XBDM_BINRESPONSE, buffer, 512), XBDM_NOERRORSTRING);
	VERIFY_HRESULT(DmTranslateError(XBDM_READYFORBIN, buffer, 512), XBDM_NOERRORSTRING);
	VERIFY_HRESULT(DmTranslateError(XBDM_DEDICATED, buffer, 512), XBDM_NOERRORSTRING);
#endif
}

void testDmGetDriveList()
{
#ifndef _XBOX
	HRESULT hr;
	char szDrives[26];
	DWORD dwSize;

	dwSize = sizeof szDrives;
	VERIFY_HRESULT(DmGetDriveList(szDrives, &dwSize), XBDM_NOERR);
	dwSize -= 1;
	VERIFY_HRESULT(DmGetDriveList(szDrives, &dwSize), XBDM_BUFFER_TOO_SMALL);
	/*
	TODO: DmGetDriveList - file bugs against these!  
	dwSize = sizeof szDrives;
	VERIFY_HRESULT(DmGetDriveList(NULL, &dwSize), E_INVALIDARG);
	dwSize = sizeof szDrives;
	VERIFY_HRESULT(DmGetDriveList(szDrives, NULL), E_INVALIDARG);
	*/
#endif
}

void testDmGetDiskFreeSpace()
{
#ifndef _XBOX
	HRESULT hr;
	char szDrives[26];
	char szDrive[4] = "A:\\";
	DWORD dwSize;
	ULARGE_INTEGER nFreeToCaller, nTotal, nTotalFree;

	dwSize = sizeof szDrives;
	DmGetDriveList(szDrives, &dwSize);
	for (unsigned int i = 0; i < dwSize; i++)
	{
		szDrive[0] = szDrives[i];
		VERIFY_HRESULT(DmGetDiskFreeSpace(szDrive, &nFreeToCaller, &nTotal, &nTotalFree), XBDM_NOERR);
		VERIFY_HRESULT(DmGetDiskFreeSpace(szDrive, NULL, &nTotal, &nTotalFree), E_INVALIDARG);
		VERIFY_HRESULT(DmGetDiskFreeSpace(szDrive, &nFreeToCaller, NULL, &nTotalFree), E_INVALIDARG);
		VERIFY_HRESULT(DmGetDiskFreeSpace(szDrive, &nFreeToCaller, &nTotal, NULL), E_INVALIDARG);
	}

	VERIFY_HRESULT(DmGetDiskFreeSpace(NULL, &nFreeToCaller, &nTotal, &nTotalFree), E_INVALIDARG);
	szDrive[0] = 'Q';
	VERIFY_HRESULT(DmGetDiskFreeSpace(szDrive, &nFreeToCaller, &nTotal, &nTotalFree), E_INVALIDARG);
#endif
}

void testDmReboot()
{
	LogNote("*** testDmReboot not ready for primetime ***");
	return;
	HRESULT	hr;

	// Pass DMBOOT_WAIT

	VERIFY_HRESULT(DmReboot(DMBOOT_WAIT), XBDM_NOERR);
	Sleep(10000);

	// Pass DMBOOT_WARM

	VERIFY_HRESULT(DmReboot(DMBOOT_WARM), XBDM_NOERR);
	Sleep(10000);
	
	// Pass invalid value for dwFlags

#define INVALID_DMBOOT_FLAGS (~(DMBOOT_WAIT|DMBOOT_WARM|DMBOOT_NODEBUG|DMBOOT_STOP))
	VERIFY_HRESULT(DmReboot(INVALID_DMBOOT_FLAGS), E_INVALIDARG);
	Sleep(10000);

	/* TODO: DmReboot - pass combo of valid flags

	TEST_BEGIN("DmReboot(DMBOOT_WARM | DMBOOT_NODEBUG)");
	hr = DmReboot(DMBOOT_WARM | DMBOOT_NODEBUG);
	VERIFY_HRESULT("DmReboot(DMBOOT_WARM | DMBOOT_NODEBUG)", hr);
	TEST_END("DmReboot(DMBOOT_WARM | DMBOOT_NODEBUG)");
	*/
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\dmapi\DmTestHarness\notification.cpp ===
//
// Debug API - Socket Functions
//

#include "tests.h"
#include "logging.h"

#define INVALID_DM_FLAGS (~(DM_PERSISTENT|DM_DEBUGSESSION|DM_ASYNCSESSION))

void testDmOpenNotificationSession();
void testDmCloseNotificationSession();
void testDmNotify();
void testDmRegisterNotificationProcessor();

void testNotification()
{
	testDmOpenNotificationSession();
	testDmCloseNotificationSession();
	testDmNotify();
	testDmRegisterNotificationProcessor();
}

DWORD __stdcall MyProcessor(LPCSTR szNotification)
{
	return XBDM_NOERR;
}

DWORD __stdcall MyHandler(ULONG dwNotification, DWORD dwParam)
{
	return XBDM_NOERR;
}

void testDmOpenNotificationSession()
{
	HRESULT			hr;
	PDMN_SESSION	pSession = NULL;

#define RESET_SESSION(p) if (p) { DmCloseNotificationSession(p); p = NULL; }

	VERIFY_HRESULT(DmOpenNotificationSession(0, NULL), E_INVALIDARG);
	RESET_SESSION(pSession);
	VERIFY_HRESULT(DmOpenNotificationSession(INVALID_DM_FLAGS, &pSession), E_INVALIDARG);
	RESET_SESSION(pSession);
	VERIFY_HRESULT(DmOpenNotificationSession(0, &pSession), XBDM_NOERR);
	RESET_SESSION(pSession);
	VERIFY_HRESULT(DmOpenNotificationSession(DM_PERSISTENT, &pSession), XBDM_NOERR);
	RESET_SESSION(pSession);

	// TODO: DmOpenNotificationSession - multiple notification sessions
}

void testDmCloseNotificationSession()
{
	HRESULT			hr;
	PDMN_SESSION	pSession;

	if (FAILED(DmOpenNotificationSession(0, &pSession)))
	{
		LogNote("Unable to open Connection to test DmCloseNotificationSession()");
		return;
	}

	VERIFY_HRESULT(DmCloseNotificationSession(NULL), E_INVALIDARG);
	VERIFY_HRESULT(DmCloseNotificationSession(pSession), XBDM_NOERR);

	// TODO: DmCloseNotificationSession - add more cases

	DmCloseNotificationSession(pSession);
}

void testDmNotify()
{
	HRESULT			hr;
	PDMN_SESSION	pSession = NULL;

	VERIFY_HRESULT(DmOpenNotificationSession(0, &pSession), XBDM_NOERR);
	VERIFY_HRESULT(DmRegisterNotificationProcessor(pSession, "DEFAULT", MyProcessor), XBDM_NOERR);
	VERIFY_HRESULT(DmNotify(pSession, DM_MODLOAD, MyHandler), XBDM_NOERR);
	VERIFY_HRESULT(DmNotify(NULL, DM_MODLOAD, MyHandler), E_INVALIDARG);
	VERIFY_HRESULT(DmNotify(pSession, INVALID_DM_FLAGS, MyHandler), E_INVALIDARG);
	VERIFY_HRESULT(DmNotify(pSession, DM_MODLOAD, NULL), E_INVALIDARG);
	VERIFY_HRESULT(DmCloseNotificationSession(pSession), XBDM_NOERR);
}

void testDmRegisterNotificationProcessor()
{
	HRESULT			hr;
	PDM_CONNECTION	pConnection;
	PDMN_SESSION	pSession;

	hr = DmOpenConnection(&pConnection);
	if (hr != XBDM_NOERR)
	{
		LogNote("Unable to open Connection to test DmRegisterNotificationProcessor()");
		return;
	}

	hr = DmOpenNotificationSession(0, &pSession);
	if (hr != XBDM_NOERR)
	{
		LogNote("Unable to open Session to test DmRegisterNotificationProcessor()");
		return;
	}

	VERIFY_HRESULT(DmRegisterNotificationProcessor(pSession, "DEFAULT", MyProcessor), XBDM_NOERR);
	VERIFY_HRESULT(DmRegisterNotificationProcessor(pSession, "", MyProcessor), XBDM_NOERR);
	VERIFY_HRESULT(DmRegisterNotificationProcessor(NULL, "DEFAULT", MyProcessor), E_INVALIDARG);
	VERIFY_HRESULT(DmRegisterNotificationProcessor(pSession, NULL, MyProcessor), E_INVALIDARG);
	VERIFY_HRESULT(DmRegisterNotificationProcessor(pSession, "DEFAULT", NULL), XBDM_NOERR);

	DmCloseNotificationSession(pSession);
	DmCloseConnection(pConnection);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\dmapi\DmTestHarness\secure.cpp ===
//
// Debug API - Socket Functions
//

#include "tests.h"
#include "logging.h"

static void testDmIsSecurityEnabled();
static void testDmAddUser();
static void testDmRemoveUser();
static void testUserAccess();
static void testDmWalkUserList();
static void testDmCloseUserList();
static void testDmSetAdminPassword(); // Win32 only

unsigned int hlpNumberOfUsers()
{
	PDM_WALK_USERS	walk = NULL;
	DM_USER			user;
	unsigned int	count = 0;
	char			buf[256];
	HRESULT			hr;

	OutputDebugString("*** begin users list ***\n");
	VERIFY_HRESULT_ALT(DmWalkUserList(&walk, &user), XBDM_NOERR, XBDM_ENDOFLIST);
	while (SUCCEEDED(hr) && (hr != XBDM_ENDOFLIST))
	{
		count++;
		wsprintf(buf, "user: %-12s access: [%s]read [%s]write [%s]ctrl [%s]cfg [%s]manage\n", 
				user.UserName,
				user.AccessPrivileges & DMPL_PRIV_READ		? "+" : "-",
				user.AccessPrivileges & DMPL_PRIV_WRITE		? "+" : "-",
				user.AccessPrivileges & DMPL_PRIV_CONTROL	? "+" : "-",
				user.AccessPrivileges & DMPL_PRIV_CONFIGURE	? "+" : "-",
				user.AccessPrivileges & DMPL_PRIV_MANAGE	? "+" : "-"
				);
		OutputDebugString(buf);
		VERIFY_HRESULT_ALT(DmWalkUserList(&walk, &user), XBDM_NOERR, XBDM_ENDOFLIST);
	}
	
	DmCloseUserList(walk);
	OutputDebugString("*** end users list ***\n");
	return count;
}

void testSecurity()
{
	testDmIsSecurityEnabled();
	testDmAddUser();
	testDmRemoveUser();
	testUserAccess();
}

void testDmIsSecurityEnabled()
{
	HRESULT			hr;
	BOOL			fTemp, fSetting;

	// very important!  why is that?
	VERIFY_HRESULT(DmUseSharedConnection(TRUE), XBDM_NOERR);

	VERIFY_HRESULT(DmIsSecurityEnabled(NULL), E_INVALIDARG);
	VERIFY_HRESULT(DmIsSecurityEnabled(&fTemp /* valid ptr */), XBDM_NOERR);

	VERIFY_HRESULT(DmEnableSecurity(TRUE), XBDM_NOERR);
	VERIFY_HRESULT(DmIsSecurityEnabled(&fSetting), XBDM_NOERR);
	VERIFY_TRUE(fSetting == TRUE);

	VERIFY_HRESULT(DmEnableSecurity(FALSE), XBDM_NOERR);
	VERIFY_HRESULT(DmIsSecurityEnabled(&fSetting), XBDM_NOERR);
	VERIFY_TRUE(fSetting == FALSE);
}

void testDmAddUser()
{
	HRESULT			hr;
	BOOL			fSecure;
	char			szLocalhost[256];
	DWORD			dwSize = sizeof szLocalhost;

	// get name of this box, for later use
	// TODO: DmAddUser - figure out what to do when running natively on xbox

	GetComputerName(szLocalhost, &dwSize);

	VERIFY_HRESULT(DmUseSharedConnection(TRUE), XBDM_NOERR);
	VERIFY_HRESULT(DmIsSecurityEnabled(&fSecure), XBDM_NOERR);

	// unlock box for start of tests, and abort if it fails

	if (fSecure)
		VERIFY_HRESULT(DmEnableSecurity(FALSE), XBDM_NOERR);
	if (FAILED(hr))
		return;

	// try adding users while the box isn't locked

	VERIFY_HRESULT(DmAddUser("BOGUS-NOTLOCKED", -1), XBDM_NOTLOCKED);
	VERIFY_TRUE(hlpNumberOfUsers() == 0);

	// now lock box

	VERIFY_HRESULT(DmEnableSecurity(TRUE), XBDM_NOERR);

	// fire up some users

	VERIFY_TRUE(hlpNumberOfUsers() == 0);
	VERIFY_HRESULT(DmAddUser(szLocalhost, -1), XBDM_NOERR);
	VERIFY_TRUE(hlpNumberOfUsers() == 1);
	VERIFY_HRESULT(DmAddUser(szLocalhost /* dupe */, -1), XBDM_ALREADYEXISTS);
	VERIFY_TRUE(hlpNumberOfUsers() == 1);

	// reverse case of username	

	for (int i = strlen(szLocalhost); i; i--)
	{
		if (isupper(szLocalhost[i-1]))
			szLocalhost[i-1] = tolower(szLocalhost[i-1]);
		else
			szLocalhost[i-1] = toupper(szLocalhost[i-1]);
	}

	VERIFY_HRESULT(DmAddUser(szLocalhost /* dupe in diff case */, -1), XBDM_ALREADYEXISTS);
	VERIFY_TRUE(hlpNumberOfUsers() == 1);

	VERIFY_HRESULT(DmAddUser("DmAddUser-NONE", 0), E_INVALIDARG);
	VERIFY_HRESULT(DmAddUser(NULL, DMPL_PRIV_READ), E_INVALIDARG);
	// woot: bug
	VERIFY_HRESULT(DmAddUser("", DMPL_PRIV_READ), E_INVALIDARG);

	VERIFY_HRESULT(DmAddUser("DmAddUser-READ", DMPL_PRIV_READ), XBDM_NOERR);
	VERIFY_HRESULT(DmAddUser("DmAddUser-WRITE", DMPL_PRIV_WRITE), XBDM_NOERR);
	VERIFY_HRESULT(DmAddUser("DmAddUser-CTRL", DMPL_PRIV_CONTROL), XBDM_NOERR);
	VERIFY_HRESULT(DmAddUser("DmAddUser-CFG", DMPL_PRIV_CONFIGURE), XBDM_NOERR);
	VERIFY_HRESULT(DmAddUser("DmAddUser-MANAGE", DMPL_PRIV_MANAGE), XBDM_NOERR);
	VERIFY_HRESULT(DmAddUser("DmAddUser-MIXED", DMPL_PRIV_READ|DMPL_PRIV_WRITE|DMPL_PRIV_MANAGE), XBDM_NOERR);
	VERIFY_TRUE(hlpNumberOfUsers() == 7);

	// TODO: DmAddUser - mbcs user name
	// unlock on exit

	VERIFY_HRESULT(DmEnableSecurity(FALSE), XBDM_NOERR);
}

void testDmRemoveUser()
{
	HRESULT			hr;
	BOOL			fSecure;
	char			szLocalhost[256];
	DWORD			dwSize = sizeof szLocalhost;

	// get name of this box, for later use
	// TODO: DmRemoveUser - figure out what to do when running natively on xbox

	GetComputerName(szLocalhost, &dwSize);

	VERIFY_HRESULT(DmUseSharedConnection(TRUE), XBDM_NOERR);
	VERIFY_HRESULT(DmIsSecurityEnabled(&fSecure), XBDM_NOERR);

	// unlock box for start of tests, and abort if it fails

	if (fSecure)
		VERIFY_HRESULT(DmEnableSecurity(FALSE), XBDM_NOERR);
	if (FAILED(hr))
		return;

	// try removing users while the box isn't locked

	VERIFY_HRESULT(DmRemoveUser("BOGUS-NOTLOCKED"), XBDM_NOTLOCKED);

	// now lock box

	VERIFY_HRESULT(DmEnableSecurity(TRUE), XBDM_NOERR);

	// fire up some users for the test to delete

	VERIFY_HRESULT(DmAddUser(szLocalhost, -1), XBDM_NOERR);
	VERIFY_HRESULT(DmAddUser("DmRemoveUser-OK", -1), XBDM_NOERR);
	VERIFY_HRESULT(DmAddUser("DmRemoveUser-READ", DMPL_PRIV_READ), XBDM_NOERR);
	VERIFY_HRESULT(DmAddUser("DmRemoveUser-WRITE", DMPL_PRIV_WRITE), XBDM_NOERR);
	VERIFY_HRESULT(DmAddUser("DmRemoveUser-CTRL", DMPL_PRIV_CONTROL), XBDM_NOERR);
	VERIFY_HRESULT(DmAddUser("DmRemoveUser-CFG", DMPL_PRIV_CONFIGURE), XBDM_NOERR);
	VERIFY_HRESULT(DmAddUser("DmRemoveUser-MANAGE", DMPL_PRIV_MANAGE), XBDM_NOERR);
	VERIFY_HRESULT(DmAddUser("DmRemoveUser-MIXED", DMPL_PRIV_READ|DMPL_PRIV_WRITE|DMPL_PRIV_MANAGE), XBDM_NOERR);

	// start deleting...

	VERIFY_HRESULT(DmRemoveUser(NULL), E_INVALIDARG);
	VERIFY_HRESULT(DmRemoveUser(""), XBDM_NOSUCHFILE);
	VERIFY_HRESULT(DmRemoveUser("DmRemoveUser-OK"), XBDM_NOERR);
	VERIFY_HRESULT(DmRemoveUser("DmRemoveUser-NOTTHERE"), XBDM_NOSUCHFILE);
	VERIFY_HRESULT(DmRemoveUser("DmRemoveUser-mixed" /* diff case than add */), XBDM_NOERR);

	// throw in an add, and continue deleting

	VERIFY_HRESULT(DmAddUser("DmRemoveUser-OK", -1), XBDM_NOERR);
	VERIFY_HRESULT(DmRemoveUser("DmRemoveUser-OK"), XBDM_NOERR);
	VERIFY_HRESULT(DmRemoveUser("DmRemoveUser-READ"), XBDM_NOERR);
	VERIFY_HRESULT(DmRemoveUser("DmRemoveUser-WRITE"), XBDM_NOERR);
	VERIFY_HRESULT(DmRemoveUser("DmRemoveUser-CTRL"), XBDM_NOERR);
	VERIFY_HRESULT(DmRemoveUser("DmRemoveUser-CFG"), XBDM_NOERR);
	VERIFY_HRESULT(DmRemoveUser("DmRemoveUser-MANAGE"), XBDM_NOERR);
	VERIFY_TRUE(hlpNumberOfUsers() == 1);

	// unlock on exit

	VERIFY_HRESULT(DmEnableSecurity(FALSE), XBDM_NOERR);

}

void testUserAccess()
{
	HRESULT			hr;
	BOOL			fSecure;
	char			szLocalhost[256];
	DWORD			dwSize = sizeof szLocalhost;
	DWORD			dwAccess;

	// get name of this box, for later use
	// TODO: testUserAccess - figure out what to do when running natively on xbox

	GetComputerName(szLocalhost, &dwSize);

	VERIFY_HRESULT(DmUseSharedConnection(TRUE), XBDM_NOERR);
	VERIFY_HRESULT(DmIsSecurityEnabled(&fSecure), XBDM_NOERR);

	// unlock box for start of tests, and abort if it fails

	if (fSecure)
		VERIFY_HRESULT(DmEnableSecurity(FALSE), XBDM_NOERR);
	if (FAILED(hr))
		return;

	// now all user settings have been cleared...					  

	VERIFY_HRESULT(DmGetUserAccess("BOGUS-NOTLOCKED", &dwAccess), XBDM_NOTLOCKED);
	VERIFY_HRESULT(DmSetUserAccess("BOGUS-NOTLOCKED", -1), XBDM_NOTLOCKED);

	// now lock box

	VERIFY_HRESULT(DmEnableSecurity(TRUE), XBDM_NOERR);

	VERIFY_HRESULT(DmAddUser(szLocalhost, -1), XBDM_NOERR);
	VERIFY_HRESULT(DmAddUser("UserAccess-NONE", 0), XBDM_NOERR);
	VERIFY_HRESULT(DmAddUser("UserAccess-ALL", -1), XBDM_NOERR);

	// test cases

	VERIFY_HRESULT(DmGetUserAccess("UserAccess-NONE", &dwAccess), XBDM_NOERR);
	VERIFY_TRUE(dwAccess == 0);
	VERIFY_HRESULT(DmGetUserAccess("UserAccess-ALL", &dwAccess), XBDM_NOERR);
	VERIFY_TRUE(dwAccess == -1);
	VERIFY_HRESULT(DmSetUserAccess("UserAccess-NONE", DMPL_PRIV_CONTROL), XBDM_NOERR);
	VERIFY_HRESULT(DmGetUserAccess("UserAccess-NONE", &dwAccess), XBDM_NOERR);
	VERIFY_TRUE(dwAccess == DMPL_PRIV_CONTROL);

	VERIFY_HRESULT(DmGetUserAccess("BOGUS", &dwAccess), XBDM_NOSUCHFILE);
	VERIFY_HRESULT(DmSetUserAccess("BOGUS", -1), XBDM_NOSUCHFILE);
	// woot: bug
	VERIFY_HRESULT(DmGetUserAccess(NULL, &dwAccess), E_INVALIDARG);
	VERIFY_HRESULT(DmSetUserAccess(NULL, -1), E_INVALIDARG);
	VERIFY_HRESULT(DmGetUserAccess("", &dwAccess), XBDM_NOSUCHFILE);
	VERIFY_HRESULT(DmSetUserAccess("", -1), XBDM_NOSUCHFILE);

	// unlock on exit

	VERIFY_HRESULT(DmEnableSecurity(FALSE), XBDM_NOERR);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\dmapi\DmTestHarness\Module.cpp ===
//
// Debug API - Module Access Functions
//

#include "tests.h"
#include "logging.h"

static void testDmWalkLoadedModules();
static void testDmCloseLoadedModules();
static void testDmWalkModuleSections();
static void testDmCloseModuleSections();
static void testDmGetModuleLongName();
static void testWalkAllModulesAndSections();

void testModulesAndSections()
{
	testDmWalkLoadedModules();
	testDmCloseLoadedModules();
	testDmWalkModuleSections();
	testDmCloseModuleSections();
	testDmGetModuleLongName();
	testWalkAllModulesAndSections();
}

void testDmWalkLoadedModules()
{
	HRESULT				hr;
	PDM_WALK_MODULES	pWalkMod = NULL;
	DMN_MODLOAD			ModLoad;
	char				buf[256];

	// Pass NULL for ppWalkMod, pModLoad

	VERIFY_HRESULT(DmWalkLoadedModules(NULL, &ModLoad), E_INVALIDARG);
	VERIFY_HRESULT(DmWalkLoadedModules(&pWalkMod, NULL), E_INVALIDARG);

	// Call function repeatedly to obtain all modules

	memset(&ModLoad, 0, sizeof ModLoad);
	hr = DmWalkLoadedModules(&pWalkMod, &ModLoad);
	while (hr == XBDM_NOERR)
	{
		wsprintf(buf, "%-20s - Addr: 0x%08x  Size: %8ul  Time: %08x  ChkSum: %08x", 
				ModLoad.Name, ModLoad.BaseAddress, 
				ModLoad.Size, ModLoad.TimeStamp, ModLoad.CheckSum);
		LogNote(buf);
		memset(&ModLoad, 0, sizeof ModLoad);
		VERIFY_HRESULT_ALT(DmWalkLoadedModules(&pWalkMod, &ModLoad), XBDM_NOERR, XBDM_ENDOFLIST);
	}

	if (pWalkMod)
		DmCloseLoadedModules(pWalkMod);
}

void testDmWalkModuleSections()
{
	HRESULT				hr;
	PDM_WALK_MODULES	pWalkMod = NULL;
	DMN_MODLOAD			ModLoad;
	DMN_SECTIONLOAD		SectLoad;
	PDM_WALK_MODSECT	pWalkModSect;

	hr = DmWalkLoadedModules(&pWalkMod, &ModLoad);
	if (hr != XBDM_NOERR)
	{
		LogNote("Cannot run DmWalkModuleSections() tests due to inability to obtain Module object");
		return;
	}

	// Pass NULL for ppWalkModSect

	VERIFY_HRESULT(DmWalkModuleSections(NULL, "", &SectLoad), E_INVALIDARG);

	// Pass NULL for pModLoad

	pWalkModSect = NULL;
	VERIFY_HRESULT(DmWalkModuleSections(&pWalkModSect, NULL, &SectLoad), XBDM_NOMODULE);
	if (pWalkModSect)
		DmCloseModuleSections(pWalkModSect);

	// Pass NULL for lzModName

	pWalkModSect = NULL;
	VERIFY_HRESULT(DmWalkModuleSections(&pWalkModSect, ModLoad.Name, NULL), E_INVALIDARG);
	if (pWalkModSect)
		DmCloseModuleSections(pWalkModSect);

	// Pass empty string for ModName

	pWalkModSect = NULL;
	VERIFY_HRESULT(DmWalkModuleSections(&pWalkModSect, "", &SectLoad), XBDM_NOMODULE);
	if (pWalkModSect)
		DmCloseModuleSections(pWalkModSect);

	// Pass valid module for ModName

	pWalkModSect = NULL;
	VERIFY_HRESULT(DmWalkModuleSections(&pWalkModSect, ModLoad.Name, &SectLoad), XBDM_NOERR);
	if (pWalkModSect)
		DmCloseModuleSections(pWalkModSect);

	// Pass invalid module for ModName

	pWalkModSect = NULL;
	VERIFY_HRESULT(DmWalkModuleSections(&pWalkModSect, "$@BogusName@$", &SectLoad), XBDM_NOMODULE);
	if (pWalkModSect)
		DmCloseModuleSections(pWalkModSect);

	// Pass valid module with mixed case for ModName
	// Pass valid module with leading/trailing spaces for ModName

	if (pWalkMod)
		DmCloseLoadedModules(pWalkMod);
}

void testDmCloseLoadedModules()
{
	HRESULT				hr;
	PDM_WALK_MODULES	pWalkMod = NULL;
	DMN_MODLOAD			ModLoad;
	
	// using Null

	VERIFY_HRESULT(DmCloseLoadedModules(NULL), E_INVALIDARG);

	// using valid DM_WALK_MODULES object

	pWalkMod = NULL;
	VERIFY_HRESULT(DmWalkLoadedModules(&pWalkMod, &ModLoad), XBDM_NOERR);
	if (pWalkMod)
		DmCloseLoadedModules(pWalkMod);
}

void testDmCloseModuleSections()
{
	HRESULT				hr;
	PDM_WALK_MODULES	pWalkMod = NULL;
	DMN_MODLOAD			ModLoad;
	DMN_SECTIONLOAD		SectLoad;
	PDM_WALK_MODSECT	pWalkModSect;
	
	// using Null

	VERIFY_HRESULT(DmCloseModuleSections(NULL), E_INVALIDARG);

	// using valid DM_WALK_MODULES object

	pWalkMod = NULL;
	hr = DmWalkLoadedModules(&pWalkMod, &ModLoad);
	if (hr != XBDM_NOERR)
	{
		// Error code
		LogTestResult("DmCloseModuleSections(pWalkModSect)", false, "Unable to obtain valid LoadModule to use");
		return;
	}

	pWalkModSect = NULL;
	VERIFY_HRESULT(DmWalkModuleSections(&pWalkModSect, ModLoad.Name, &SectLoad), XBDM_NOERR);
	if (hr != XBDM_NOERR)
		DmCloseModuleSections(pWalkModSect);
}

void testDmGetModuleLongName()
{
	HRESULT				hr;
	PDM_WALK_MODULES	pWalkMod = NULL;
	DMN_MODLOAD			ModLoad;
	char				LongName[512];
	DWORD				size;

	hr = DmWalkLoadedModules(&pWalkMod, &ModLoad);
	if (hr != XBDM_NOERR)
	{
		LogNote("Cannot run DmGetModuleLongName() tests due to inability to obtain Module object");
		return;
	}
/*
	// Pass NULL for ShortName

	TEST_BEGIN("DmGetModuleLongName(NULL, LongName, &size)");
	size = sizeof LongName;
	memset(LongName, 0, size);
	hr = DmGetModuleLongName(NULL, LongName, &size);
	if (hr != XBDM_NOMODULE)
		LogTestResult("DmGetModuleLongName(NULL, LongName, &size)", false, "E_INVALIDARG error should have been returned");
	else
		LogTestResult("DmGetModuleLongName(NULL, LongName, &size)", true, "");
	TEST_END("DmGetModuleLongName(NULL, LongName, &size)");

	// Pass NULL for LongName

	TEST_BEGIN("DmGetModuleLongName(ModLoad.Name, NULL, &size)");
	size = sizeof LongName;
	hr = DmGetModuleLongName(ModLoad.Name, NULL, &size);
	if (hr != E_INVALIDARG)
		LogTestResult("DmGetModuleLongName(ModLoad.Name, NULL, &size)", false, "E_INVALIDARG error should have been returned");
	else
		LogTestResult("DmGetModuleLongName(ModLoad.Name, NULL, &size)", true, "");
	TEST_END("DmGetModuleLongName(ModLoad.Name, NULL, &size)");

	// Pass NULL for pcch

	TEST_BEGIN("DmGetModuleLongName(ModLoad.Name, LongName, NULL)");
	size = sizeof LongName;
	memset(LongName, 0, size);
	hr = DmGetModuleLongName(ModLoad.Name, LongName, NULL);
	if (hr != E_INVALIDARG)
		LogTestResult("DmGetModuleLongName(ModLoad.Name, LongName, NULL)", false, "E_INVALIDARG error should have been returned");
	else
		LogTestResult("DmGetModuleLongName(ModLoad.Name, LongName, NULL)", true, "");
	TEST_END("DmGetModuleLongName(ModLoad.Name, LongName, NULL)");
*/
	// Pass valid ShortName

	size = sizeof LongName;
	memset(LongName, 0, size);
	VERIFY_HRESULT(DmGetModuleLongName(ModLoad.Name, LongName, &size), XBDM_NOERR);

	// Pass invalid ShortName

	size = sizeof LongName;
	memset(LongName, 0, size);
	VERIFY_HRESULT(DmGetModuleLongName("$@BogusName@$", LongName, &size), XBDM_NOMODULE);

	// Pass valid ShortName with mixed case
	// Pass valid ShortName with leading/trailing spaces
	// Pass pcch value of 0
	// Pass pcch value of 1
	// Pass pcch value < incoming data size
	// Pass pcch value > incoming data size
	// Verify LongName only returns if /debug used

	if (pWalkMod)
		DmCloseLoadedModules(pWalkMod);
}

void testWalkAllModulesAndSections()
{
	HRESULT				hr;
	PDM_WALK_MODULES	pWalkMod = NULL;
	DMN_MODLOAD			ModLoad;
	DMN_SECTIONLOAD		SectLoad;
	PDM_WALK_MODSECT	pWalkModSect;
	char				buf[256];

	//
	// Walk Modules currently running on Xbox
	//
	hr = DmWalkLoadedModules(&pWalkMod, &ModLoad);
	while (hr == XBDM_NOERR)	// && hr != XBDM_ENDOFLIST)
	{
		wsprintf(buf, "%-25s - Addr: 0x%08x  Size: %8ul  Time: %08x  ChkSum: %08x\n", 
				ModLoad.Name, ModLoad.BaseAddress, 
				ModLoad.Size, ModLoad.TimeStamp, ModLoad.CheckSum);
		OutputDebugString(buf);
		//
		// Walk Sections of Current module
		//
		pWalkModSect = NULL;
		hr = DmWalkModuleSections(&pWalkModSect, ModLoad.Name, &SectLoad);
		while (hr == XBDM_NOERR)
		{
			wsprintf(buf, "     %-20s - Addr: 0x%08x  Size: %8ul\n", 
					SectLoad.Name, SectLoad.BaseAddress, 
					SectLoad.Size);
			OutputDebugString(buf);
			hr = DmWalkModuleSections(&pWalkModSect, ModLoad.Name, &SectLoad);
		}
		if (hr == XBDM_ENDOFLIST || pWalkModSect)
			DmCloseModuleSections(pWalkModSect);

		hr = DmWalkLoadedModules(&pWalkMod, &ModLoad);
	}
	if (hr == XBDM_ENDOFLIST || pWalkMod)	
		DmCloseLoadedModules(pWalkMod);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\repair\EEPROMdump\constants.h ===
#ifndef _CONSTANTS_H_
#define _CONSTANTS_H_

#include <xtl.h>
#include <av.h>

#define APP_TITLE_NAME_A                        "Recovery"

// Screen Dimensions
#define SCREEN_WIDTH                            640
#define SCREEN_HEIGHT                           480
#define SCREEN_X_CENTER                         ( SCREEN_WIDTH / 2 )
#define SCREEN_Y_CENTER                         ( SCREEN_HEIGHT / 2 )

// Progress Bar Dimensions
#define PROGRESS_WIDTH                           200.0f
#define PROGRESS_HEIGHT                           32.0f
#define PROGRESS_BORDER_OUTER_OFFSET             7.0f
#define PROGRESS_BORDER_GAP                      3.0f
#define PROGRESS_BORDER_WIDTH                    5
#define PROGRESS_X1                               (SCREEN_X_CENTER - (PROGRESS_WIDTH / 2))
#define PROGRESS_X2                               (SCREEN_X_CENTER + (PROGRESS_WIDTH / 2))
#define PROGRESS_Y1                               264.0f
#define PROGRESS_Y2                               (PROGRESS_Y1 + PROGRESS_HEIGHT)

// Launcher Menu Item Information
#define MENU_LAUNCH_MACHINENAME_X1              SCREEN_X_CENTER             // This is not used, it is calculated
#define MENU_LAUNCH_MACHINENAME_Y1              ( SCREEN_HEIGHT - 65.0f )
#define MENU_LAUNCH_NUMXBES_Y1                  MENUBOX_MAINAREA_Y1 - 28.0f
#define MENU_LAUNCH_MACHINENAME_FONTHEIGHT      28
#define MENU_LAUNCH_TOP_BORDER_SIZE             10.0f
#define MENU_LAUNCH_UPARROW_X1                  113     // Bitmaps, use int
#define MENU_LAUNCH_UPARROW_Y1                  106     // Bitmaps, use int
#define MENU_LAUNCH_DOWNARROW_X1                113     // Bitmaps, use int
#define MENU_LAUNCH_DOWNARROW_Y1                380     // Bitmaps, use int

// Menubox constants
#define MENUBOX_MAINAREA_X1                      99.0f
#define MENUBOX_MAINAREA_Y1                     134.0f
#define MENUBOX_MAINAREA_X2                     535.0f
#define MENUBOX_MAINAREA_Y2                     375.0f

#define MENUBOX_SELECTBAR_X1                    MENUBOX_MAINAREA_X1
#define MENUBOX_SELECTBAR_X2                    ( MENUBOX_MAINAREA_X2 + 1 )

#define MENUBOX_TEXT_TOP_BORDER                   16.0f
#define MENUBOX_TEXT_BOTTOM_BORDER                0.0f
#define MENUBOX_TEXT_LSIDE_BORDER                 8.0f
#define MENUBOX_TEXT_RSIDE_BORDER                 8.0f

#define MENUBOX_TEXTAREA_X1                     ( MENUBOX_MAINAREA_X1 + MENUBOX_TEXT_LSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y1                     ( MENUBOX_MAINAREA_Y1 + MENUBOX_TEXT_TOP_BORDER )
#define MENUBOX_TEXTAREA_X2                     ( MENUBOX_MAINAREA_X2 - MENUBOX_TEXT_RSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y2                     ( MENUBOX_MAINAREA_Y2 - MENUBOX_TEXT_BOTTOM_BORDER )

#define MENUBOX_BUILDNUM_Y1                     ( MENUBOX_TEXTAREA_Y2 - 22.0f )

// Behaviour constants
#define KEY_PRESS_INITIAL_DELAY                 400         // milliseconds
#define KEY_PRESS_REPEAT_DELAY                  50
#define EXECUTABLE_DIRECTORY_POLL_INTERVAL      5000        // 5 seconds
#define CLEAR_SCREEN_PAUSE_MS                   250         // milliseconds

// Font info
#define FONT_DEFAULT_HEIGHT                     20
#define FONT_DEFAULT_WIDTH                      8
#define FONT_ALIAS_LEVEL                        4
#define FONT_DEFAULT_STYLE                      XFONT_NORMAL // XFONT_BOLD | XFONT_ITALICS | XFONT_BOLDITALICS
#define FILE_DATA_DEFAULT_FONT_FILENAME         FILE_DATA_MEDIA_DIRECTORY L"\\tahoma.ttf"

// Screen Item Constants
#define SCREEN_ITEM_TEXT_LENGTH                 40

// Colors
#define COLOR_WHITE                             0xFFFFFFFF
#define COLOR_BLACK                             0xFF000000
#define COLOR_LIGHT_YELLOW                      0xFFDFF77F
#define COLOR_YELLOW                            0xFFFFFF00
#define COLOR_LIGHT_GRAY                        0xFFC8C8C8
#define COLOR_DARK_GRAY                         0xFF828282
#define COLOR_LIME_GREEN                        0xFF9BD351
#define COLOR_BRIGHT_GREEN                      0xFF73C034
#define COLOR_MEDIUM_GREEN                      0xFF57932E
#define COLOR_DARK_GREEN2                       0xFF357515
#define COLOR_DARK_GREEN                        0xFF2C531E

#define SCREEN_DEFAULT_BACKGROUND_COLOR         COLOR_BLACK
#define SCREEN_DEFAULT_TEXT_FG_COLOR            COLOR_LIGHT_YELLOW
#define SCREEN_DEFAULT_TEXT_BG_COLOR            SCREEN_DEFAULT_BACKGROUND_COLOR

// Menu Item constants
#define ITEM_SELECTOR_BORDER_SPACE              2
#define ITEM_VERT_SPACING                       7.0f
#define ITEM_SELECTOR_COLOR                     COLOR_LIME_GREEN
#define ITEM_XBELIST_FONT_HEIGHT                17 // 18

// Keypad and Keyboard location information
#define KEYBOARD_TOPROW_Y1                      225
#define KEYPAD_TOPROW_Y1                        225
#define MENU_DISPSET_BUTTON_Y1                  211

// File path and location constants
#define FILE_DATA_DRIVE                        L"d:"
#define FILE_DATA_DRIVE_A                       "d:"
#define FILE_DATA_MEDIA_DIRECTORY               FILE_DATA_DRIVE  L"\\recmedia"
#define FILE_DATA_MEDIA_DIRECTORY_A             FILE_DATA_DRIVE_A "\\recmedia"
#define FILE_DATA_IMAGE_DIRECTORY_A             FILE_DATA_DRIVE_A "\\recmedia"

#endif // _CONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\dmapi\DmTestHarness\tests.h ===
//
// Test cases - sorted according to API appearance in xboxdbg.h/xbdm.h
//
#ifdef _XBOX
#include <xtl.h>
#include <xbdm.h>
#else
#include <windows.h>
#include <xboxdbg.h>
#endif

// notification
void testNotification();

// breakpoint routines
void testBreakpoint();
void testExecution();

// reboot
void testDmReboot();

// memory
void testMemory();

// thread routines
void testThreadSupport();

// xtl data, modules and sections, xbe info
void testDmGetXtlData();
void testModulesAndSections();
void testDmGetXbeInfo();

// socket-level commands
void testSocketCommands();

// filesystem
void testFileSystem();

// time
void testDmGetSystemTime();

// config and name functions
void testConfig();

// management functions
void testSecurity();

// title to launch

// screenshot/snapshot

// start/stop profile data collection

// performance counters
void testPerfCounters();

// drive info
void testDmGetDriveList();
void testDmGetDiskFreeSpace();

// error codes
void testDmTranslateError();

// image file routines
void testImageFileRoutines();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\dmapi\DmTestHarness\util.cpp ===
// utility functions

#include "tests.h"

///////////////////////////////////////////////////////////
// Win32 goodies
///////////////////////////////////////////////////////////

#ifndef _XBOX

char szValidLocalXbePath[MAX_PATH];
WCHAR wszValidLocalXbePath[MAX_PATH];
char szValidRemoteXbePath[MAX_PATH];

void BuildLocalXbe()
{
}

char *GetValidLocalXbePathA()
{
	return szValidLocalXbePath;
}

WCHAR *GetValidLocalXbePathW()
{
	return wszValidLocalXbePath;
}

char *GetValidRemoteXbePath()
{
	return szValidRemoteXbePath;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\dmapi\DmTestHarness\xbe.cpp ===
#include "tests.h"
#include "logging.h"

static void testXbeGetLocalModulePath();
static void testXbeGetXbeInfo();
static void testXbeGetBuilderArgs();

void testImageFileRoutines()
{
	testXbeGetLocalModulePath();
	testXbeGetXbeInfo();
	testXbeGetBuilderArgs();
}

void testXbeGetLocalModulePath()
{
#ifndef _XBOX
	HRESULT	hr;
	char	buffer[512];

	// Pass NULL for szXBE

	VERIFY_HRESULT(XbeGetLocalModulePathA(NULL, "INIT", buffer, sizeof buffer), XBDM_NOSUCHFILE);
	//VERIFY_HRESULT(XbeGetLocalModulePathW(NULL, "INIT", buffer, sizeof buffer), XBDM_NOSUCHFILE);

	// Pass NULL for szModule

	VERIFY_HRESULT(hr = XbeGetLocalModulePathA("e:\\samples\\cartoon\\cartoon.xbe", NULL, buffer, sizeof buffer), XBDM_NOSUCHFILE);
	//VERIFY_HRESULT(hr = XbeGetLocalModulePathW(L"e:\\samples\\cartoon\\cartoon.xbe", NULL, buffer, sizeof buffer), XBDM_NOSUCHFILE);

	// pass NULL for szPath

	VERIFY_HRESULT(hr = XbeGetLocalModulePathA("e:\\samples\\cartoon\\cartoon.xbe", "INIT", NULL, sizeof buffer), E_INVALIDARG);
	//VERIFY_HRESULT(hr = XbeGetLocalModulePathW(L"e:\\samples\\cartoon\\cartoon.xbe", "INIT", NULL, sizeof buffer), E_INVALIDARG);

	// TODO: XbeGetLocalModulePath - other cases
	// Pass empty string for szXBE
	// Pass valid filename for szXBE
	// Pass valid filename with mixed case for szXBE
	// Pass valid filename with leading/trailing spaces for szXBE
	// Pass invalid filename for szXBE
	// Pass valid module for szModule
	// Pass valid module with mixed case for szModule
	// Pass valid module with leading/trailing spaces for szModule
	// Pass 0 for cchPath
	// Pass 1 for cchPath
	// Pass # < actual path size for cchPath
	// Pass # > actual path size for cchPath
/*
	TEST_BEGIN("XbeGetLocalModulePath(\"e:\\samples\\cartoon\\cartoon.xbe\", \"XTL.DLL\", buffer, sizeof buffer)");
	hr = XbeGetLocalModulePath("e:\\samples\\cartoon\\cartoon.xbe", \"XTL.DLL\", buffer, sizeof buffer);
	if (hr != E_INVALIDARG)
		LogTestResult("XbeGetLocalModulePath(\"e:\\samples\\cartoon\\cartoon.xbe\", \"XTL.DLL\", buffer, sizeof buffer)", false, "E_INVALIDARG Error should be returned");
	else
		LogTestResult("XbeGetLocalModulePath(\"e:\\samples\\cartoon\\cartoon.xbe\", \"XTL.DLL\", buffer, sizeof buffer)", true, "");
	TEST_END("XbeGetLocalModulePath(\"e:\\samples\\cartoon\\cartoon.xbe\", \"XTL.DLL\", buffer, sizeof buffer)");
*/
#endif
}

void testDmGetXbeInfo()
{
	HRESULT	hr;
	DM_XBE	xbeinfo;

	// Pass NULL for szName

	ZeroMemory(&xbeinfo, sizeof xbeinfo);
	VERIFY_HRESULT(DmGetXbeInfo(NULL, &xbeinfo), XBDM_NOSUCHFILE);
	ZeroMemory(&xbeinfo, sizeof xbeinfo);
	VERIFY_HRESULT(DmGetXbeInfo("e:\\samples\\cartoon\\cartoon.xbe", NULL), E_INVALIDARG);
	ZeroMemory(&xbeinfo, sizeof xbeinfo);
	VERIFY_HRESULT(DmGetXbeInfo("", &xbeinfo), XBDM_NOSUCHFILE);

	// TODO: DmGetXbeInfo - other cases
	// copy all new testcases from testXbeGetXbeInfo
}

void testXbeGetXbeInfo()
{
#ifndef _XBOX
	HRESULT	hr;
	DM_XBE	xbeinfo;

	// Pass NULL for szName

	memset(&xbeinfo, 0, sizeof xbeinfo);
	VERIFY_HRESULT(XbeGetXbeInfoA(NULL, &xbeinfo), XBDM_NOSUCHFILE);
	//VERIFY_HRESULT(XbeGetXbeInfoW(NULL, &xbeinfo), XBDM_NOSUCHFILE);

	// Pass NULL for pXbeInfo

	memset(&xbeinfo, 0, sizeof xbeinfo);
	VERIFY_HRESULT(XbeGetXbeInfoA("e:\\samples\\cartoon\\cartoon.xbe", NULL), E_INVALIDARG);
	//VERIFY_HRESULT(XbeGetXbeInfoW(L"e:\\samples\\cartoon\\cartoon.xbe", NULL), E_INVALIDARG);

	// Pass empty string for szName

	memset(&xbeinfo, 0, sizeof xbeinfo);
	VERIFY_HRESULT(XbeGetXbeInfoA("", &xbeinfo), XBDM_NOSUCHFILE);
	//VERIFY_HRESULT(XbeGetXbeInfoW(L"", &xbeinfo), XBDM_NOSUCHFILE);

	// Call when no XBE is running

	memset(&xbeinfo, 0, sizeof xbeinfo);
	hr = DmReboot(DMBOOT_WARM);
	Sleep(10000);
	VERIFY_HRESULT(XbeGetXbeInfoA("e:\\samples\\cartoon\\cartoon.xbe", &xbeinfo), XBDM_NOERR);
	/*
	memset(&xbeinfo, 0, sizeof xbeinfo);
	hr = DmReboot(DMBOOT_WARM);
	Sleep(10000);
	VERIFY_HRESULT(XbeGetXbeInfoA(L"e:\\samples\\cartoon\\cartoon.xbe", &xbeinfo), XBDM_NOERR);
	*/

	// TODO: XbeGetXbeInfo - other cases
	// Pass valid szName with mixed case
	// Pass valid szName with leading/trailing spaces
	// Pass full path for szName
	// Pass long filename for szName
	// Call when XBE already running
#endif
}

void testXbeGetBuilderArgs()
{
#ifndef _XBOX
	HRESULT	hr;
	char	szArgs[512];
	DWORD	dwSize;

#define VALID_LOCAL_XBE ""

	ZeroMemory(szArgs, sizeof szArgs);
	dwSize = sizeof szArgs;
	VERIFY_HRESULT(XbeGetBuilderArgsA(VALID_LOCAL_XBE, szArgs, &dwSize), XBDM_NOSUCHFILE);
	//VERIFY_HRESULT(XbeGetBuilderArgsW(VALID_LOCAL_XBE, szArgs, &dwSize), XBDM_NOSUCHFILE);

	VERIFY_HRESULT(XbeGetBuilderArgsA(NULL, NULL, &dwSize), E_INVALIDARG);
	//VERIFY_HRESULT(XbeGetBuilderArgsW(NULL, NULL, &dwSize), E_INVALIDARG);

	VERIFY_HRESULT(XbeGetBuilderArgsA(NULL, szArgs, NULL), E_INVALIDARG);
	//VERIFY_HRESULT(XbeGetBuilderArgsW(NULL, szArgs, NULL), E_INVALIDARG);

	dwSize = 0;
	VERIFY_HRESULT(XbeGetBuilderArgsA(VALID_LOCAL_XBE, szArgs, &dwSize), XBDM_NOSUCHFILE);
	//VERIFY_HRESULT(XbeGetBuilderArgsW(VALID_LOCAL_XBE, szArgs, &dwSize), XBDM_NOSUCHFILE);

	// TODO:XbeGetBuilderArgs - other cases
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\repair\EEPROMdump\EEPROMdump.cpp ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      EEPROMdump.cpp
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


#include "recovpch.h"
#include "xboxvideo.h"


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ DEFINES ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#if DBG
extern "C" ULONG XDebugOutLevel;
#endif

#define RC4_CONFOUNDER_LEN 8

// Threshold for analog buttons
#define XINPUT_ANALOGBUTTONTHRESHOLD 32

typedef void (*FPTR)(void);

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ STRUCTURES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//
// Header before encrypted data
//
typedef struct _RC4_SHA1_HEADER {
    UCHAR Checksum[XC_SERVICE_DIGEST_SIZE];
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
} RC4_SHA1_HEADER, *PRC4_SHA1_HEADER;


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ GLOBAL OBJECTS +++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// g_pVideo             -- Interface to the xbox video display
CXBoxVideo* g_pVideo;

// g_pBackgroundBitmap  -- The bitmap to display behind the text
BitmapFile* g_pBackgroundBitmap;

// g_szResult           -- Used to store result string displayed to user.
TCHAR g_szResult[1000];

EEPROM_LAYOUT* eeprom;
XBOX_FACTORY_SETTINGS* factorySettings;
XBOX_USER_SETTINGS* userSettings;
XBOX_ENCRYPTED_SETTINGS * pEncryptedEEPROMData;
BOOL fEncryptedEEPROM;
BOOL fEEPROMValid;
char RecoveryKey[8];

int DrawOffset = 0;

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  DebugOutput
// Purpose:   Outputs a debug string to the console
// Arguments: tszErr        -- The format string
//            ...           -- Optional parameters
// Return:    None
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void DebugOutput(TCHAR *tszErr, ...)
{
    TCHAR tszErrOut[256];

    va_list valist;

    va_start (valist,tszErr);
    wvsprintf (tszErrOut, tszErr, valist);
    OutputDebugString (tszErrOut);

    va_end (valist);
}


void DrawInit()
{
    assert(g_pVideo && g_pBackgroundBitmap);
	g_pVideo->ClearScreen(COLOR_BLACK);
	g_pBackgroundBitmap->render(g_pVideo->GetD3DDevicePtr());
	DrawOffset = 0;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  DrawMessage
// Purpose:   Outputs a one or two line message to the screen
// Arguments: pcszTextLine1 -- First line to output
//            pcszTextLine2 -- Second line to output
// Return:    None
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void DrawMessage(LPCWSTR pcszText)
{
    assert(g_pVideo);

    if (NULL != pcszText)
        g_pVideo->DrawText(SCREEN_X_CENTER,
                           MENUBOX_TEXTAREA_Y1 + (FONT_DEFAULT_HEIGHT * DrawOffset++),
                           SCREEN_DEFAULT_TEXT_FG_COLOR,
                           SCREEN_DEFAULT_TEXT_BG_COLOR,
                           pcszText);
}




// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  WaitForAnyButton
// Purpose:   Waits for a button to be pressed.
// UNDONE:    This function was cut-and-paste from recovery.cpp, and as such
//            contains a lot of unnecessary code.  This will eventually be
//            pared down to the minimal required functionality.
//            As a result, this function is left as-is and is uncommented.
// Arguments: None
// Return:    None
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void WaitForAnyButton()
{
    DWORD dwNewVideoMode;
    BOOL fYButton;
    PDWORD pdwNewVideoMode = &dwNewVideoMode;
    PBOOL pfYButton = &fYButton;
    BOOL fButtonPressed = FALSE;
    static DWORD dwPads = 0;
    DWORD dwInsertions, dwRemovals;
    static HANDLE hPads[XGetPortCount()] = { 0 };
    int i;

    ASSERT(pdwNewVideoMode);
    *pdwNewVideoMode = 0xFFFFFFFF;

    while (!fButtonPressed) {
        if (XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals)) {
            dwPads |= dwInsertions;
            dwPads &= ~dwRemovals;

            for (i = 0; i < XGetPortCount(); i++) {
                if ((1 << i) & dwRemovals) {
                    if (NULL != hPads[i])
                        XInputClose(hPads[i]);
                        hPads[i] = NULL;
                }

                if ((1 << i) & dwInsertions) {
                    if (NULL == hPads[i])
                        hPads[i] = XInputOpen(XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT0 + i, XDEVICE_NO_SLOT, NULL);;
                }
            }
        }

        for (i = 0; i < XGetPortCount(); i++) {
            if ((1 << i) & dwPads) {
                if (NULL != hPads[i]) {
                    XINPUT_STATE State;

                    if (ERROR_SUCCESS == XInputGetState(hPads[i], &State)) {
                        if ((State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > XINPUT_ANALOGBUTTONTHRESHOLD) &&
                            (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > XINPUT_ANALOGBUTTONTHRESHOLD))
                        {
                            if (State.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP)
                                *pdwNewVideoMode = AV_STANDARD_PAL_I | AV_FLAGS_50Hz;
                            else if (State.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_RIGHT)
                                *pdwNewVideoMode = AV_STANDARD_NTSC_M | AV_FLAGS_60Hz;
                            else if (State.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_LEFT)
                                *pdwNewVideoMode = AV_STANDARD_NTSC_J | AV_FLAGS_60Hz;
                        }
                        else if ((0 != ((XINPUT_GAMEPAD_START | XINPUT_GAMEPAD_BACK) & State.Gamepad.wButtons)) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_B] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_Y] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_WHITE] > XINPUT_ANALOGBUTTONTHRESHOLD))
                        {
                            fButtonPressed = TRUE;

                            if (pfYButton)
                                *pfYButton = (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_Y] >
                                                XINPUT_ANALOGBUTTONTHRESHOLD);
                        }
                    }
                }
            }

            if (fButtonPressed || (*pdwNewVideoMode != 0xFFFFFFFF)) {
                fButtonPressed = TRUE;
                break;
            }
        }
    }
}

static void rc4HmacEncrypt(
    IN PUCHAR confounder, // RC4_CONFOUNDER_LEN bytes
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    BYTE LocalKey[XC_SERVICE_DIGEST_SIZE];
    BYTE Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];

    //
    // Create the header - the confounder & checksum
    //
    RtlZeroMemory( CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE );
    RtlCopyMemory( CryptHeader->Confounder, confounder, RC4_CONFOUNDER_LEN );

    //
    // Checksum everything but the checksum
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Confounder, RC4_CONFOUNDER_LEN,
            pbInput, cbInput,
            CryptHeader->Checksum );

    //
    // HMAC the checksum into the key
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE,
            NULL, 0,
            LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    XcRC4Key( Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey );

    //
    // Encrypt everything but the checksum
    //
    XcRC4Crypt( Rc4KeyStruct, RC4_CONFOUNDER_LEN, CryptHeader->Confounder );
    XcRC4Crypt( Rc4KeyStruct, cbInput, pbInput );
}


static BOOL rc4HmacDecrypt(
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    IN PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    RC4_SHA1_HEADER TempHeader;
    BYTE Confounder[RC4_CONFOUNDER_LEN];
    BYTE LocalKey[XC_SERVICE_DIGEST_SIZE];
    BYTE Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];

    RtlCopyMemory( TempHeader.Confounder, CryptHeader->Confounder, RC4_CONFOUNDER_LEN );

    //
    // HMAC the checksum into the key
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE,
            NULL, 0,
            LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    XcRC4Key( Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey );

    //
    // Decrypt confounder and data
    //
    XcRC4Crypt( Rc4KeyStruct, RC4_CONFOUNDER_LEN, TempHeader.Confounder );
    XcRC4Crypt( Rc4KeyStruct, cbInput, pbInput );

    //
    // Now verify the checksum.
    //
    XcHMAC( pbKey, cbKey,
            TempHeader.Confounder, RC4_CONFOUNDER_LEN,
            pbInput, cbInput,
            TempHeader.Checksum );

    //
    // Decrypt is successful only if checksum matches
    //
    return ( RtlEqualMemory(
                TempHeader.Checksum,
                CryptHeader->Checksum,
                XC_SERVICE_DIGEST_SIZE) );
}

BOOL FReadEPROM()
{
    NTSTATUS status;
    BOOL bResult;
    HRESULT hr;
    BYTE b;
    int i;



    //
    // Use the EEPROM-KEY to decrypt the EEPROM
    //
    b = 0;
    for(i = 0; i < 8; ++i)
        b |= pEncryptedEEPROMData->Confounder[i];

    if (b)
    {
        bResult = rc4HmacDecrypt(
            (LPBYTE)(*XboxEEPROMKey), XBOX_KEY_LENGTH,
            pEncryptedEEPROMData->HDKey, sizeof(pEncryptedEEPROMData->HDKey) + sizeof(pEncryptedEEPROMData->GameRegion),
            (LPBYTE)&(pEncryptedEEPROMData->Checksum) );
        if ( !bResult )
        {
            return FALSE;
        }
        fEncryptedEEPROM = TRUE;
    } else
        fEncryptedEEPROM = FALSE;

    //
    // Double check the hard drive key
    //
    ASSERT( HARD_DRIVE_KEY_LEN == XBOX_KEY_LENGTH );
    if (!RtlEqualMemory( pEncryptedEEPROMData->HDKey, (LPBYTE)(*XboxHDKey), XBOX_KEY_LENGTH ))
    {
        ASSERT(!"HardDriveKey does not match");
        return FALSE;
    }

    MorphKeyByHardDriveKey( factorySettings->OnlineKey, sizeof(factorySettings->OnlineKey) );
    ComputeRecoveryKey( pEncryptedEEPROMData->HDKey, RecoveryKey );

    return TRUE;
}



void Screen1()
{
	DrawInit();

	wsprintf(g_szResult, TEXT("Kernel Ver : %d.%d.%d.%d"),
                 XboxKrnlVersion->Major, XboxKrnlVersion->Minor,
                 XboxKrnlVersion->Build, XboxKrnlVersion->Qfe & 0x7FFF);
    DrawMessage(g_szResult);

    if(!fEEPROMValid)
        DrawMessage(TEXT("CORRUPT EEPROM!"));
    else if(fEncryptedEEPROM)
        DrawMessage(TEXT("ENCRYPTED SECTION (DECRYPTED):"));
    else
        DrawMessage(TEXT("ENCRYPTED SECTION (UNENCRYPTED):"));
        
    DrawMessage(TEXT("Checksum:"));
    wsprintf(g_szResult, TEXT("%02x%02x%02x%02x%02x%02x%02x%02x %02x%02x%02x%02x%02x%02x%02x%02x %02x%02x%02x%02x"),
		pEncryptedEEPROMData->Checksum[0],  pEncryptedEEPROMData->Checksum[1],
		pEncryptedEEPROMData->Checksum[2],  pEncryptedEEPROMData->Checksum[3],
		pEncryptedEEPROMData->Checksum[4],  pEncryptedEEPROMData->Checksum[5],
		pEncryptedEEPROMData->Checksum[6],  pEncryptedEEPROMData->Checksum[7],
		pEncryptedEEPROMData->Checksum[8],  pEncryptedEEPROMData->Checksum[9],
		pEncryptedEEPROMData->Checksum[10], pEncryptedEEPROMData->Checksum[11],
		pEncryptedEEPROMData->Checksum[12], pEncryptedEEPROMData->Checksum[13],
		pEncryptedEEPROMData->Checksum[14], pEncryptedEEPROMData->Checksum[15],
		pEncryptedEEPROMData->Checksum[16], pEncryptedEEPROMData->Checksum[17],
		pEncryptedEEPROMData->Checksum[18], pEncryptedEEPROMData->Checksum[19]
    );
    DrawMessage(g_szResult);

    wsprintf(g_szResult, TEXT("Confounder : %02x%02x%02x%02x %02x%02x%02x%02x"),
    	pEncryptedEEPROMData->Confounder[0],  pEncryptedEEPROMData->Confounder[1],
    	pEncryptedEEPROMData->Confounder[2],  pEncryptedEEPROMData->Confounder[3],
    	pEncryptedEEPROMData->Confounder[4],  pEncryptedEEPROMData->Confounder[5],
    	pEncryptedEEPROMData->Confounder[6],  pEncryptedEEPROMData->Confounder[7]
    );
    DrawMessage(g_szResult);

    DrawMessage(TEXT("Hard Drive Key"));
    wsprintf(g_szResult, TEXT("%02x%02x%02x%02x %02x%02x%02x%02x %02x%02x%02x%02x %02x%02x%02x%02x"),
    	pEncryptedEEPROMData->HDKey[0],  pEncryptedEEPROMData->HDKey[1],
    	pEncryptedEEPROMData->HDKey[2],  pEncryptedEEPROMData->HDKey[3],
    	pEncryptedEEPROMData->HDKey[4],  pEncryptedEEPROMData->HDKey[5],
    	pEncryptedEEPROMData->HDKey[6],  pEncryptedEEPROMData->HDKey[7],
    	pEncryptedEEPROMData->HDKey[8],  pEncryptedEEPROMData->HDKey[9],
    	pEncryptedEEPROMData->HDKey[10], pEncryptedEEPROMData->HDKey[11],
    	pEncryptedEEPROMData->HDKey[12], pEncryptedEEPROMData->HDKey[13],
    	pEncryptedEEPROMData->HDKey[14], pEncryptedEEPROMData->HDKey[15]
    );
    DrawMessage(g_szResult);

    wsprintf(g_szResult, TEXT("Game Region: %08x"), pEncryptedEEPROMData->GameRegion);
    DrawMessage(g_szResult);

    g_pVideo->ShowScreen();
}

void Screen2()
{
	DrawInit();

    DrawMessage(TEXT("FACTORY SECTION:"));

    wsprintf(g_szResult, TEXT("Checksum: %08x"), factorySettings->Checksum);
    DrawMessage(g_szResult);

    DrawMessage(TEXT("Serial Number:"));
    wsprintf(g_szResult, TEXT("'%c%c%c%c%c%c%c%c%c%c%c%c'"),
    	factorySettings->SerialNumber[0], factorySettings->SerialNumber[1],
    	factorySettings->SerialNumber[2], factorySettings->SerialNumber[3],
    	factorySettings->SerialNumber[4], factorySettings->SerialNumber[5],
    	factorySettings->SerialNumber[6], factorySettings->SerialNumber[7],
    	factorySettings->SerialNumber[8], factorySettings->SerialNumber[9],
    	factorySettings->SerialNumber[10], factorySettings->SerialNumber[11]
    );
    DrawMessage(g_szResult);

    wsprintf(g_szResult, TEXT("MAC Addr: %02x%02x %02x%02x %02x%02x"),
        factorySettings->EthernetAddr[0], factorySettings->EthernetAddr[1],
        factorySettings->EthernetAddr[2], factorySettings->EthernetAddr[3],
        factorySettings->EthernetAddr[4], factorySettings->EthernetAddr[5]
    );
    DrawMessage(g_szResult);

    DrawMessage(TEXT("Online Key:"));
    wsprintf(g_szResult, TEXT("%02x%02x%02x%02x %02x%02x%02x%02x %02x%02x%02x%02x %02x%02x%02x%02x"),
        factorySettings->OnlineKey[0], factorySettings->OnlineKey[1],
        factorySettings->OnlineKey[2], factorySettings->OnlineKey[3],
        factorySettings->OnlineKey[4], factorySettings->OnlineKey[5],
        factorySettings->OnlineKey[6], factorySettings->OnlineKey[7],
        factorySettings->OnlineKey[8], factorySettings->OnlineKey[9],
        factorySettings->OnlineKey[10], factorySettings->OnlineKey[11],
        factorySettings->OnlineKey[12], factorySettings->OnlineKey[13],
        factorySettings->OnlineKey[14], factorySettings->OnlineKey[15]
	);
    DrawMessage(g_szResult);

    wsprintf(g_szResult, TEXT("AV Region  : %08x"), factorySettings->AVRegion);
    DrawMessage(g_szResult);

    g_pVideo->ShowScreen();
}

void Screen3()
{
	DrawInit();

    DrawMessage(TEXT("USER DATA SECTION (Part 1):"));

    wsprintf(g_szResult, TEXT("Checksum: %08x"), userSettings->Checksum);
    DrawMessage(g_szResult);

    wsprintf(g_szResult, TEXT("TZ Bias: %d"), userSettings->TimeZoneBias);
    DrawMessage(g_szResult);

    wsprintf(g_szResult, TEXT("TZ Name Std: %c%c%c   Dlt: %c%c%c"),
    	userSettings->TimeZoneStdName[0],
    	userSettings->TimeZoneStdName[1],
    	userSettings->TimeZoneStdName[2],
    	userSettings->TimeZoneDltName[0],
    	userSettings->TimeZoneDltName[1],
    	userSettings->TimeZoneDltName[2]
    );
    DrawMessage(g_szResult);

    wsprintf(g_szResult, TEXT("TZ Std Bias: %d   Dlt Bias: %d"),
	userSettings->TimeZoneStdBias, userSettings->TimeZoneDltBias
    );
    DrawMessage(g_szResult);

	wsprintf(g_szResult, TEXT("Date Std Event: %d/%d (%d of 7) %02d:00"),
		userSettings->TimeZoneStdDate.Month,
		userSettings->TimeZoneStdDate.Day,
		userSettings->TimeZoneStdDate.DayOfWeek,
		userSettings->TimeZoneStdDate.Hour
	);
	DrawMessage(g_szResult);


	wsprintf(g_szResult, TEXT("Date Dlt Event: %d/%d (%d of 7) %02d:00"),
		userSettings->TimeZoneDltDate.Month,
		userSettings->TimeZoneDltDate.Day,
		userSettings->TimeZoneDltDate.DayOfWeek,
		userSettings->TimeZoneDltDate.Hour
	);
	DrawMessage(g_szResult);

    wsprintf(g_szResult, TEXT("Language: %08x"), userSettings->Language);
    DrawMessage(g_szResult);

    wsprintf(g_szResult, TEXT("Audio/Video Flags: %08x / %08x"), userSettings->AudioFlags, userSettings->VideoFlags);
    DrawMessage(g_szResult);

    g_pVideo->ShowScreen();

    ULONG ParentalControlGames;             // 60 +  4
    ULONG ParentalControlPassword;          // 64 +  4
    ULONG ParentalControlMovies;            // 68 +  4
    ULONG OnlineIpAddress;                  // 72 +  4
    ULONG OnlineDnsAddress;                 // 76 +  4
    ULONG OnlineDefaultGatewayAddress;      // 80 +  4
    ULONG OnlineSubnetMask;                 // 84 +  4
    ULONG MiscFlags;                        // 88 +  4
    ULONG DvdRegion;                        // 92 +  4
}

void Screen4()
{
	DrawInit();

    DrawMessage(TEXT("USER DATA SECTION (Part 2):"));

    wsprintf(g_szResult, TEXT("ParentalControlGames: %08x"), userSettings->ParentalControlGames);
    DrawMessage(g_szResult);

    wsprintf(g_szResult, TEXT("ParentalControlPassword: %08x"), userSettings->ParentalControlPassword);
    DrawMessage(g_szResult);

    wsprintf(g_szResult, TEXT("ParentalControlMovies: %08x"), userSettings->ParentalControlMovies);
    DrawMessage(g_szResult);

    wsprintf(g_szResult, TEXT("Online IP Addr: %d.%d.%d.%d"),
    	(userSettings->OnlineIpAddress & 0xff000000) >> 24,
    	(userSettings->OnlineIpAddress & 0xff0000) >> 16,
    	(userSettings->OnlineIpAddress & 0xff00) >> 8,
    	(userSettings->OnlineIpAddress & 0xff)
   	);
    DrawMessage(g_szResult);

    wsprintf(g_szResult, TEXT("Online DNS Addr: %d.%d.%d.%d"),
    	(userSettings->OnlineDnsAddress & 0xff000000) >> 24,
    	(userSettings->OnlineDnsAddress & 0xff0000) >> 16,
    	(userSettings->OnlineDnsAddress & 0xff00) >> 8,
    	(userSettings->OnlineDnsAddress & 0xff)
   	);
    DrawMessage(g_szResult);

    wsprintf(g_szResult, TEXT("Online Gateway Addr: %d.%d.%d.%d"),
    	(userSettings->OnlineDefaultGatewayAddress & 0xff000000) >> 24,
    	(userSettings->OnlineDefaultGatewayAddress & 0xff0000) >> 16,
    	(userSettings->OnlineDefaultGatewayAddress & 0xff00) >> 8,
    	(userSettings->OnlineDefaultGatewayAddress & 0xff)
   	);
    DrawMessage(g_szResult);

    wsprintf(g_szResult, TEXT("Online Subnet Mask: %d.%d.%d.%d"),
    	(userSettings->OnlineSubnetMask & 0xff000000) >> 24,
    	(userSettings->OnlineSubnetMask & 0xff0000) >> 16,
    	(userSettings->OnlineSubnetMask & 0xff00) >> 8,
    	(userSettings->OnlineSubnetMask & 0xff)
   	);
    DrawMessage(g_szResult);

    wsprintf(g_szResult, TEXT("Misc Flags: %08x"), userSettings->MiscFlags);
    DrawMessage(g_szResult);

    wsprintf(g_szResult, TEXT("DVD Region: %08x"), userSettings->DvdRegion);
    DrawMessage(g_szResult);

    g_pVideo->ShowScreen();
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  main
// Purpose:   Main entry point to application
// Arguments: None
// Return:    None
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void __cdecl main()
{
    BYTE buf[EEPROM_TOTAL_MEMORY_SIZE];
    DWORD type, size;
	int current = 0;
	FPTR Screens[4] = {Screen1, Screen2, Screen3, Screen4};

    wsprintf(g_szResult, TEXT("Generic Failure"));

	//
    // Initialize core peripheral port support
    //
    XInitDevices(0, NULL);

	//
    // Create the video subsytem and background bitmap objects
	//
    g_pVideo = new CXBoxVideo;
    g_pBackgroundBitmap = new BitmapFile;
    if ((NULL == g_pVideo) || (NULL == g_pBackgroundBitmap))
    {
        OutputDebugString(TEXT("Couldn't allocate video objects"));
        Sleep(INFINITE);
    }

	//
    // Initialize the screen and read in the background bitmap
    //
    g_pBackgroundBitmap->read(0, 0, FILE_DATA_IMAGE_DIRECTORY_A "\\backgrnd.bmp");
    g_pVideo->Initialize( SCREEN_WIDTH, SCREEN_HEIGHT );

    //
    // read EEPROM Data
    //
    if (!NT_SUCCESS(ExQueryNonVolatileSetting(XC_MAX_ALL, &type, buf, sizeof(buf), &size)))
    {
        ASSERT(false);
    }

    ASSERT( type == REG_BINARY );
    ASSERT( size == EEPROM_TOTAL_MEMORY_SIZE );

    eeprom = (EEPROM_LAYOUT*) buf;
    factorySettings = (XBOX_FACTORY_SETTINGS*) &eeprom->FactorySection;
    userSettings = (XBOX_USER_SETTINGS*) &eeprom->UserConfigSection;
    pEncryptedEEPROMData = (XBOX_ENCRYPTED_SETTINGS *) &eeprom->EncryptedSection;

	fEEPROMValid = FReadEPROM();

	while (true)
	{
		Screens[current]();
		WaitForAnyButton();
		current = (current+1)%4;
		Sleep(150);
	}

    Sleep(INFINITE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\dmapi\DmTestHarness\threads.cpp ===
//
// thread routines
// for both Win32 and Xbox APIs
//

#include "tests.h"
#include "logging.h"

#define INVALID_THREADID 9999
void testThreadSupport()
{
	HRESULT				hr;
	DWORD				Threads[512];
	DWORD				numThreads;
	DM_THREADINFO		threadInfo;
	DM_THREADSTOP		threadStop;
	CONTEXT				context;

#ifdef _XBOX
	// TODO: testThreadSupport - create a whole slew of threads which we can verify results against
#endif

	// DmGetThreadList
	// - valid and invalid parameters

	numThreads = sizeof Threads;
	VERIFY_HRESULT(DmGetThreadList(Threads, &numThreads), XBDM_NOERR);
	numThreads = sizeof Threads;
	VERIFY_HRESULT(DmGetThreadList(NULL, &numThreads), E_INVALIDARG);
	VERIFY_HRESULT(DmGetThreadList(Threads, NULL), E_INVALIDARG);
	numThreads = 0;
	VERIFY_HRESULT(DmGetThreadList(Threads, &numThreads), XBDM_BUFFER_TOO_SMALL);
	if (numThreads > 1)
	{
		numThreads = 1;
		VERIFY_HRESULT(DmGetThreadList(Threads, &numThreads), XBDM_BUFFER_TOO_SMALL);
	}

	// DmGetThreadContext/DmSetThreadContext

	numThreads = sizeof Threads;
	DmGetThreadList(Threads, &numThreads);
	ZeroMemory(&context, sizeof context);
	context.ContextFlags = CONTEXT_FULL;

	// Get/Set with an active thread
	VERIFY_HRESULT(DmGetThreadContext(Threads[0], &context), XBDM_NOERR);
	VERIFY_HRESULT(DmSetThreadContext(Threads[0], &context), XBDM_NOTSTOPPED);

	// Get/Set with all threads stopped
	VERIFY_HRESULT(DmStop(), XBDM_NOERR);
	VERIFY_HRESULT(DmGetThreadContext(Threads[0], &context), XBDM_NOERR);
	VERIFY_HRESULT(DmSetThreadContext(Threads[0], &context), XBDM_NOERR);
	VERIFY_HRESULT(DmGo(), XBDM_NOERR);

	// Get/Set with invalid parameters
	VERIFY_HRESULT(DmStop(), XBDM_NOERR);
	VERIFY_HRESULT(DmGetThreadContext(Threads[0], NULL), E_INVALIDARG);
	VERIFY_HRESULT(DmGetThreadContext(INVALID_THREADID, &context), XBDM_NOTHREAD);
	VERIFY_HRESULT(DmSetThreadContext(Threads[0], NULL), E_INVALIDARG);
	VERIFY_HRESULT(DmSetThreadContext(INVALID_THREADID, &context), XBDM_NOTHREAD);
	VERIFY_HRESULT(DmGo(), XBDM_NOERR);

	// Get/Set with suspended threads
	VERIFY_HRESULT(DmSuspendThread(Threads[0]), XBDM_NOERR);
	VERIFY_HRESULT(DmGetThreadContext(Threads[0], &context), XBDM_NOERR);
	VERIFY_HRESULT(DmSetThreadContext(Threads[0], &context), XBDM_NOERR);
	VERIFY_HRESULT(DmResumeThread(Threads[0]), XBDM_NOERR);

	if (numThreads > 1)
	{
		VERIFY_HRESULT(DmStop(), XBDM_NOERR);
		VERIFY_HRESULT(DmGetThreadContext(Threads[1], &context), XBDM_NOERR);
		VERIFY_HRESULT(DmSetThreadContext(Threads[1], &context), XBDM_NOERR);
		VERIFY_HRESULT(DmGetThreadContext(Threads[numThreads - 1], &context), XBDM_NOERR);
		VERIFY_HRESULT(DmSetThreadContext(Threads[numThreads - 1], &context), XBDM_NOERR);
		VERIFY_HRESULT(DmGo(), XBDM_NOERR);
	}

	// DmGetThreadInfo
	// - valid and invalid parameters

	numThreads = sizeof Threads;
	DmGetThreadList(Threads, &numThreads);
	VERIFY_HRESULT(DmGetThreadInfo(Threads[0], &threadInfo), XBDM_NOERR);
	VERIFY_HRESULT(DmGetThreadInfo(Threads[numThreads - 1], &threadInfo), XBDM_NOERR);

	ZeroMemory(&(Threads[0]), sizeof (Threads[0]));
	VERIFY_HRESULT(DmGetThreadInfo(Threads[0], &threadInfo), XBDM_NOTHREAD);
	VERIFY_HRESULT(DmGetThreadInfo(NULL, &threadInfo), XBDM_NOTHREAD);
	numThreads = sizeof Threads;
	DmGetThreadList(Threads, &numThreads);
	VERIFY_HRESULT(DmGetThreadInfo(Threads[0], NULL), E_INVALIDARG);

	// DmSuspendThread and DmResumeThread
	// - suspend and resume
	// - suspend and resume with delay
	// - multiple suspend and resume
	// - suspend suspended thread
	// - resume non-suspended thread
	// - suspend/resume invalid thread

	VERIFY_HRESULT(DmSuspendThread(Threads[0]), XBDM_NOERR);
	VERIFY_HRESULT(DmResumeThread(Threads[0]), XBDM_NOERR);

	VERIFY_HRESULT(DmSuspendThread(Threads[0]), XBDM_NOERR);
	Sleep(250);
	VERIFY_HRESULT(DmResumeThread(Threads[0]), XBDM_NOERR);

	if (numThreads > 1)
	{
		VERIFY_HRESULT(DmSuspendThread(Threads[numThreads - 1]), XBDM_NOERR);
		VERIFY_HRESULT(DmSuspendThread(Threads[numThreads - 2]), XBDM_NOERR);
		Sleep(250);
		VERIFY_HRESULT(DmResumeThread(Threads[numThreads - 1]), XBDM_NOERR);
		VERIFY_HRESULT(DmResumeThread(Threads[numThreads - 2]), XBDM_NOERR);
	}

	VERIFY_HRESULT(DmSuspendThread(Threads[numThreads / 2]), XBDM_NOERR);
	Sleep(250);
	VERIFY_HRESULT(DmSuspendThread(Threads[numThreads / 2]), XBDM_NOERR);
	Sleep(250);
	VERIFY_HRESULT(DmResumeThread(Threads[numThreads / 2]), XBDM_NOERR);
	Sleep(250);
	VERIFY_HRESULT(DmResumeThread(Threads[numThreads / 2]), XBDM_NOERR);

	VERIFY_HRESULT(DmSuspendThread(INVALID_THREADID), XBDM_NOTHREAD);
	VERIFY_HRESULT(DmResumeThread(INVALID_THREADID), XBDM_NOTHREAD);

	// DmIsThreadStopped
	// - valid and invalid parameters

	// interaction with DmStop/DmGo

	VERIFY_HRESULT(DmIsThreadStopped(Threads[0], &threadStop), XBDM_NOTSTOPPED);
	VERIFY_HRESULT(DmStop(), XBDM_NOERR);
	VERIFY_HRESULT(DmIsThreadStopped(Threads[0], &threadStop), XBDM_NOERR);
	VERIFY_HRESULT(DmGo(), XBDM_NOERR);
	VERIFY_HRESULT(DmIsThreadStopped(Threads[0], &threadStop), XBDM_NOTSTOPPED);

	// interaction with DmSuspendThread/DmResumeThread

	VERIFY_HRESULT(DmIsThreadStopped(Threads[0], &threadStop), XBDM_NOTSTOPPED);
	VERIFY_HRESULT(DmSuspendThread(Threads[0]), XBDM_NOERR);
	VERIFY_HRESULT(DmIsThreadStopped(Threads[0], &threadStop), XBDM_NOERR);
	VERIFY_HRESULT(DmResumeThread(Threads[0]), XBDM_NOERR);
	VERIFY_HRESULT(DmIsThreadStopped(Threads[0], &threadStop), XBDM_NOTSTOPPED);

	// interaction with DmHaltThread/DmContinueThread

	VERIFY_HRESULT(DmIsThreadStopped(Threads[0], &threadStop), XBDM_NOTSTOPPED);
	VERIFY_HRESULT(DmHaltThread(Threads[0]), XBDM_NOERR);
	VERIFY_HRESULT(DmIsThreadStopped(Threads[0], &threadStop), XBDM_NOERR);
	VERIFY_HRESULT(DmContinueThread(Threads[0], FALSE), XBDM_NOERR);
	VERIFY_HRESULT(DmGo(), XBDM_NOERR);
	VERIFY_HRESULT(DmIsThreadStopped(Threads[0], &threadStop), XBDM_NOTSTOPPED);

	// invalid parameters

	VERIFY_HRESULT(DmIsThreadStopped(INVALID_THREADID, &threadStop), XBDM_NOTHREAD);
	VERIFY_HRESULT(DmIsThreadStopped(Threads[0], NULL), E_INVALIDARG);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\repair\EEPROMdump\av.h ===
/*--

Copyright (c) Microsoft Corporation

Module Name:

    av.h

Abstract:

    This module contains the public data structures and procedure
    prototypes to identify AV packs and program TV encoder

--*/

#ifndef _AV_H
#define _AV_H

#if !defined(_NTSYSTEM_)
#define NTKERNELAVAPI DECLSPEC_IMPORT
#else
#define NTKERNELAVAPI
#endif

//
// AV pack identifiers
//
#define AV_PACK_NONE                      0x00000000

#define AV_PACK_STANDARD                  0x00000001
#define AV_PACK_RFU                       0x00000002
#define AV_PACK_SCART                     0x00000003
#define AV_PACK_HDTV                      0x00000004
#define AV_PACK_VGA                       0x00000005
#define AV_PACK_SVIDEO                    0x00000006
#define AV_PACK_MAX                       0x00000007

#define AV_PACK_MASK                      0x000000FF

//
// AV_ region types
//
#define AV_STANDARD_NTSC_M                0x00000100
#define AV_STANDARD_NTSC_J                0x00000200
#define AV_STANDARD_PAL_I                 0x00000300
#define AV_STANDARD_PAL_M                 0x00000400
#define AV_STANDARD_MAX                   0x00000500

#define AV_STANDARD_MASK                  0x0000FF00
#define AV_STANDARD_BIT_SHIFT             8

// Allows 16:9 for all SDTV and DTV modes.  HDTV 
// modes (720p and 1080i) are assumed to support 16:9.
//
#define AV_FLAGS_WIDESCREEN               0x00010000
#define AV_FLAGS_LETTERBOX                0x00100000

#define AV_ASPECT_RATIO_MASK              (AV_FLAGS_WIDESCREEN | AV_FLAGS_LETTERBOX)

// 480i support is assumed.
#define AV_FLAGS_HDTV_480i                0x00000000
#define AV_FLAGS_HDTV_720p                0x00020000
#define AV_FLAGS_HDTV_1080i               0x00040000
#define AV_FLAGS_HDTV_480p                0x00080000

#define AV_HDTV_MODE_MASK                 (AV_FLAGS_HDTV_480p | AV_FLAGS_HDTV_720p | AV_FLAGS_HDTV_1080i | AV_FLAGS_HDTV_480i)

// Whether the display is interlaced or not.
#define AV_FLAGS_INTERLACED               0x00200000

// Indicates a field-rendered mode.
#define AV_FLAGS_FIELD                    0x01000000

// Indicates that this is in the funky pixel aspect ratio mode.
#define AV_FLAGS_10x11PAR                 0x02000000

// The refresh rate supported by the display.
#define AV_FLAGS_60Hz                     0x00400000
#define AV_FLAGS_50Hz                     0x00800000

#define AV_REFRESH_MASK                   (AV_FLAGS_60Hz | AV_FLAGS_50Hz)

#define AV_USER_FLAGS_MASK                (AV_ASPECT_RATIO_MASK | AV_HDTV_MODE_MASK | AV_FLAGS_60Hz)
#define AV_USER_FLAGS_BIT_SHIFT           16

//
// TV encoder options
//

// !!! Do not change the MACROVISION_MODE value without
//    updating the DVD software!

#define AV_OPTION_MACROVISION_MODE        1
#define AV_OPTION_ENABLE_CC               2
#define AV_OPTION_DISABLE_CC              3
#define AV_OPTION_SEND_CC_DATA            4
#define AV_QUERY_CC_STATUS                5
#define AV_QUERY_AV_CAPABILITIES          6
#define AV_OPTION_BLANK_SCREEN            9
#define AV_OPTION_MACROVISION_COMMIT      10
#define AV_OPTION_FLICKER_FILTER          11
#define AV_OPTION_ZERO_MODE               12
#define AV_OPTION_QUERY_MODE              13
#define AV_OPTION_ENABLE_LUMA_FILTER      14
#define AV_OPTION_GUESS_FIELD             15
#define AV_QUERY_ENCODER_TYPE             16
#define AV_QUERY_MODE_TABLE_VERSION       17

//
// TV encoder types.
//

#define AV_ENCODER_CONEXANT_871           0

//
// Macrovision modes
//

#define AV_MV_OFF                         0
#define AV_MV_AGC_ONLY                    1
#define AV_MV_TWO_STRIPES_PLUS_AGC        2
#define AV_MV_FOUR_STRIPES_PLUS_AGC       3

NTKERNELAVAPI
ULONG
NTAPI
AvSetDisplayMode(
    IN  PVOID RegisterBase,
    IN  ULONG Step,
    IN  ULONG DisplayMode,            // mode from the AV_MODE list (avmode.h)
    IN  ULONG SourceColorFormat,      // D3DFORMAT
    IN  ULONG Pitch,
    IN  ULONG FrameBuffer
    );

NTKERNELAVAPI
VOID
NTAPI
AvSendTVEncoderOption(
    IN  PVOID RegisterBase,
    IN  ULONG Option,
    IN  ULONG Param,
    OUT PULONG Result
    );

NTKERNELAVAPI
PVOID
NTAPI
AvGetSavedDataAddress(
    VOID
    );

NTKERNELAVAPI
VOID
NTAPI
AvSetSavedDataAddress(
    PVOID Address
    );

VOID
NTAPI
AvRelocateSavedDataAddress(
    IN PVOID Address,
    IN SIZE_T NumberOfBytes
    );

NTKERNELAVAPI
ULONG
NTAPI
AvSMCVideoModeToAVPack(
    ULONG VideoMode
    );

#endif // _AV_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\repair\EEPROMdump\imagefile.cpp ===
#include "recovpch.h"
#include "imagefile.h"

//////////////////////////////////////////////////////////////////////
// .BMP File format functions

BitmapFile::BitmapFile() {
	xpos = 0;
	ypos = 0;

	// Initialize Bitmap File Header
	Type	  = 19778;
	FileSize  = 192056;	//check this
	Reserved1 = 0;
	Reserved2 = 0;
	OffBits	  = 54;	//check this

	// Initialize Bitmap Info Header
	InfoSize	  = 40;
	Width		  = 0;
	Height		  = 0;
	Planes		  = 1;
	BitCount	  = 24;
	Compression	  = 0;
	SizeImage	  = 0;
	XPelsPerMeter = 2834;
	YPelsPerMeter = 2834;
	ClrUsed		  = 0;
	ClrImportant  = 0;
}

BitmapFile::~BitmapFile() {
    if( pixels )
    {
	    delete [] pixels;
        pixels = NULL;
    }
}

void BitmapFile::write(char *file, int imageWidth, int imageHeight, DWORD *pixels) {
	FILE *output;

	Width     = imageWidth;
	Height	  = imageHeight;
	ImageSize = imageWidth * imageHeight;

	//open the new bitmap file
	output = fopen(file, "wb");

	// Write the Bitmap File header information
	fwrite(&Type, sizeof(WORD), 1, output);
	fwrite(&FileSize, sizeof(DWORD), 1, output);
	fwrite(&Reserved1, sizeof(WORD), 1, output);
	fwrite(&Reserved2, sizeof(WORD), 1, output);
	fwrite(&OffBits, sizeof(DWORD), 1, output);

	//Write the Bitmap Info header information
	fwrite(&InfoSize, sizeof(DWORD), 1, output);
	fwrite(&Width, sizeof(DWORD), 1, output);
	fwrite(&Height, sizeof(DWORD), 1, output);
	fwrite(&Planes, sizeof(WORD), 1, output);
	fwrite(&BitCount, sizeof(WORD), 1, output);
	fwrite(&Compression, sizeof(DWORD), 1, output);
	fwrite(&SizeImage, sizeof(DWORD), 1, output);
	fwrite(&XPelsPerMeter, sizeof(DWORD), 1, output);
	fwrite(&YPelsPerMeter, sizeof(DWORD), 1, output);
	fwrite(&ClrUsed, sizeof(DWORD), 1, output);
	fwrite(&ClrImportant, sizeof(DWORD), 1, output);

	fclose(output);
}

int BitmapFile::imagesize(char *file) {
	FILE *input;
	input = fopen(file, "rb");

	// Read the Bitmap File header information
	fread(&Type, sizeof(WORD), 1, input);
	fread(&FileSize, sizeof(DWORD), 1, input);
	fread(&Reserved1, sizeof(WORD), 1, input);
	fread(&Reserved2, sizeof(WORD), 1, input);
	fread(&OffBits, sizeof(DWORD), 1, input);

	//Read the Bitmap Info header information
	fread(&InfoSize, sizeof(DWORD), 1, input);
	fread(&Width, sizeof(DWORD), 1, input);
	fread(&Height, sizeof(DWORD), 1, input);

	fclose(input);

	return (Width * Height);
}

void BitmapFile::read(int xloc, int yloc, char *file) {
	FILE *input;
	xpos = xloc;
	ypos = yloc;

	//open the new bitmap file
	input = fopen(file, "rb");
    if( !input )
    {
        return;
    }

	// Read the Bitmap File header information
	fread(&Type, sizeof(WORD), 1, input);
	fread(&FileSize, sizeof(DWORD), 1, input);
	fread(&Reserved1, sizeof(WORD), 1, input);
	fread(&Reserved2, sizeof(WORD), 1, input);
	fread(&OffBits, sizeof(DWORD), 1, input);

	//Read the Bitmap Info header information
	fread(&InfoSize, sizeof(DWORD), 1, input);
	fread(&Width, sizeof(DWORD), 1, input);
	fread(&Height, sizeof(DWORD), 1, input);
	fread(&Planes, sizeof(WORD), 1, input);
	fread(&BitCount, sizeof(WORD), 1, input);
	fread(&Compression, sizeof(DWORD), 1, input);
	fread(&SizeImage, sizeof(DWORD), 1, input);
	fread(&XPelsPerMeter, sizeof(DWORD), 1, input);
	fread(&YPelsPerMeter, sizeof(DWORD), 1, input);
	fread(&ClrUsed, sizeof(DWORD), 1, input);
	fread(&ClrImportant, sizeof(DWORD), 1, input);

	ImageSize = Width * Height;
	pixels = new DWORD[ImageSize];

	float remainer = (float)Width / 4;
	float delta = remainer - (int)remainer;

	BYTE blue, green, red;
	for(int y = (int)Height - 1; y >= 0 ; y--)
	{
		for(int x = 0; x < (int)Width; x++)
		{
			fread(&blue, sizeof(BYTE), 1, input);
			fread(&green, sizeof(BYTE), 1, input);
			fread(&red, sizeof(BYTE), 1, input);
			int position = (y * (int)Width) + x;
			pixels[position] = (0xff << 24) | (red << 16) | (green << 8) | (blue);
		}
		
		//account for the extra bytes in bitmap files
		if(delta == 0.25f) fseek(input, 1, SEEK_CUR);
		else if(delta == 0.50f) fseek(input, 2, SEEK_CUR);
		else if(delta == 0.75f) fseek(input, 3, SEEK_CUR);
	}

	fclose(input);
}

bool BitmapFile::render(IDirect3DDevice8 *d3dDevice) {
	HRESULT hr;
	IDirect3DSurface8 *backBuffer;
	D3DLOCKED_RECT backBufferInfo;
	hr = d3dDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &backBuffer);
	if( FAILED( hr ))
	{
		return false;
	}

	RECT container;
	container.top = ypos;
	container.left = xpos;
	container.bottom = ypos + Height;
	container.right = xpos + Width;	

	hr = backBuffer->LockRect(&backBufferInfo, &container, D3DLOCK_TILED);
	if( FAILED( hr ))
	{
        backBuffer->Release();
		return false;
	}

	int destPitch = backBufferInfo.Pitch;
	int sourcePitch = Width * 4;
	BYTE *s = (BYTE*)pixels;
	BYTE *p = (BYTE*)backBufferInfo.pBits;
	for(int y = 0; y < (int)Height; y++)
	{
		memcpy(p, s, sourcePitch);
		s += sourcePitch;
		p += destPitch;
	}

	backBuffer->UnlockRect();
    backBuffer->Release();
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\repair\EEPROMdump\xboxvideo.h ===
/*****************************************************
*** xboxvideo.h
***
*** Header file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
*** 
*** by James N. Helm
*** November 1st, 2000
*** 
*****************************************************/

#ifndef _XBOXVIDEO_H_
#define _XBOXVIDEO_H_

#include "constants.h"

// Macros
#define CHECK(code) do { int _ret__; _ret__ = code; if(_ret__ != D3D_OK) XDBGWRN( APP_TITLE_NAME_A, #code "File %s Line %d, Failed: %d", __LINE__, __FILE__, _ret__); } while (0);

#define NUM_VB_VERTS            100

// XBox configuration
class CXBoxVideo
{
public:
    // Constructors and Destructors
    CXBoxVideo( void );
    ~CXBoxVideo( void );

    // Public Properties

    // Public Methods
    void Initialize( int width,                         // Initialize D3D for this screen -- height and width default
                     int height );
    
    void DeInitialize( void );                          // Free our objects
    void ClearScreen( DWORD color );                    // Clear the current screen
    
    void DrawBox( float x1,                             // Draw a box on the screen
                  float y1,
                  float x2,
                  float y2,
                  DWORD color );

    void DrawBitBlt( float fx,                          // Draw the inputed bit array to the screen
                     float fy,
                     ULONG ulWidth,
                     ULONG ulHeight,
                     const DWORD* pData );
    
    void DrawClearRect( float x1,                       // Draw a clear rectangle to the screen
                        float y1,
                        float x2,
                        float y2,
                        DWORD color );

    HRESULT DrawLine( float x1,                         // Draw a line on the screen
                      float y1,
                      float x2,
                      float y2,
                      float fLineWidth,
                      DWORD color );

    void DrawOutline( float x1,                         // Draw an outline at the current location with a specific border size
                      float y1,
                      float x2,
                      float y2,
                      float fLineWidth,
                      DWORD color );

    int DrawText( float x1,                             // Prints formatted text, using the default font size and color
                  float y1,
                  DWORD fgcolor,
                  DWORD bgcolor,
                  const TCHAR* format,
                  ... );

    int GetStringPixelWidth( IN LPCWSTR string,         // Get the pixel width of a string
                             IN int length = -1 );

    int GetStringPixelWidth( IN char* string,           // Get the pixel width of a char*
                             IN int length /*=-1*/ ); 

    void GetFontSize( unsigned int* pheight,            // Get the size of the currently selected font
                      unsigned int* pdecent );

    void LightenImage( int nWidth,                      // Lighten the image specified by "pBits"
                       int nHeight,
                       DWORD* pBits,
                       DWORD dwAddto );
    void DarkenImage( int nWidth,                       // Darken the image specified by "pBits"
                      int nHeight,
                      DWORD* pBits,
                      DWORD dwSubtract );

    HRESULT TruncateStringToFit( char* pString,         // Truncate a string to fit within a certain screen size
                                 unsigned int nStrSize,
                                 float x1,
                                 float x2 );

    HRESULT TruncateStringToFit( WCHAR* pString,        // Truncate a string to fit within a certain screen size
                                 unsigned int nStrSize,
                                 float x1,
                                 float x2 );

    IDirect3DDevice8* GetD3DDevicePtr() { return m_Device; }; // Return the D3DDevice pointer to the caller

    void ShowScreen();                                  // Display the current backbuffer on the screen

    HRESULT GetTransform( D3DTRANSFORMSTATETYPE State,  // Get the D3D Transform
                          D3DMATRIX* pMatrix );         // Set the D3D Transform

    HRESULT SetTransform( D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix );

    HRESULT SetVertexShader( DWORD Handle );            // Set the D3D Vertex Shader
    HRESULT GetVertexShader( DWORD* pHandle );          // Get the D3D Vertex Shader



private:
    // Vertext structure
    struct MYVERTEX
    {
	    D3DXVECTOR3 v;
	    float       fRHW;
	    D3DCOLOR    cDiffuse;
    };

    // Private Properties
    IDirect3DDevice8* m_Device;
    IDirect3DSurface8* m_BackBuffer;
    IDirect3DVertexBuffer8* m_VertexBuffer;
    int m_ScreenWidth; 
    int m_ScreenHeight;
    
    // Font Properties
    XFONT* m_Font;
    float m_FontWidth;
    float m_FontHeight;
    DWORD m_FontColor;
    DWORD m_FontBgColor;

    // Private Methods
};

#endif // _XBOXVIDEO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\repair\EEPROMdump\recovpch.h ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      recovpch.h
// Contents:
// Revisions: 22-Sep-2001: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#include <ntos.h>
//#include <ntdddisk.h>
//#include <ntddscsi.h>
#include <init.h>
#include <xtl.h>
#include <assert.h>
#include <xboxp.h>
#include <xconfig.h>
#include <av.h>
#include <stdio.h>
#include <xdbg.h>
#include <malloc.h>
#include "xboxverp.h"
#include "imagefile.h"
#include "xsum.h"
#include "PerBoxData.h"
#include "cryptkeys.h"
#include <init.h>

#define XFONT_TRUETYPE
#include <xfont.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\repair\EEPROMdump\imagefile.h ===
#ifndef __ImageFile_H
#define __ImageFile_H

#include "constants.h"

typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;

class BitmapFile {
private:
	int ImageSize;
	DWORD *pixels;
	int xpos, ypos;

	// Bitmap File Header
	WORD Type;
	DWORD FileSize;
	WORD Reserved1;
	WORD Reserved2;
	DWORD OffBits;
	
	// Bitmap Info Header
	DWORD InfoSize;
	DWORD Width;
	DWORD Height;
	WORD Planes;
	WORD BitCount;
	DWORD Compression;
	DWORD SizeImage;
	DWORD XPelsPerMeter;
	DWORD YPelsPerMeter;
	DWORD ClrUsed;
	DWORD ClrImportant;

public:
	BitmapFile(void);
	~BitmapFile(void);
	
	void write(char *file, int imageWidth, int imageHeight, DWORD *pixels);
	int imagesize(char *file);
	void read(int xloc, int yloc, char *file);
	bool render(IDirect3DDevice8 *d3dDevice);

    DWORD GetWidth() { return Width; };         // Get the Width of the bitmap file
    DWORD GetHeight() { return Height; };       // Get the Height of the bitmap file
    int   GetXPos() { return xpos; };           // Get the X Position of the bitmap file
    int   GetYPos() { return ypos; };           // Get the Y Position of the bitmap file
    void  SetXPos( int x ) { xpos = x; };       // Set the X Position of the bitmap file
    void  SetYPos( int y ) { ypos = y; };       // Set the Y Position of the bitmap file
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\repair\EEPROMdump\xboxvideo.cpp ===
/*****************************************************
*** xboxvideo.cpp
***
*** CPP file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
*** 
*** by James N. Helm
*** November 1st, 2000
*** 
*****************************************************/

#include "recovpch.h"
#include "xboxvideo.h"

// Constructor
CXBoxVideo::CXBoxVideo( void )
{
    XDBGTRC( APP_TITLE_NAME_A, "CXBoxVideo::CXBoxVideo()" );

    m_Device = NULL;
    m_BackBuffer = NULL;
    m_VertexBuffer = NULL;

    // Font properties
    m_Font = NULL;
    m_FontWidth = FONT_DEFAULT_WIDTH;
    m_FontHeight = FONT_DEFAULT_HEIGHT;
    m_FontColor = SCREEN_DEFAULT_TEXT_FG_COLOR;
    m_FontBgColor = SCREEN_DEFAULT_TEXT_BG_COLOR;

    m_ScreenWidth = SCREEN_WIDTH;       // Default the screen width to 640
    m_ScreenHeight = SCREEN_HEIGHT;     // Default the screen height to 480
}

// Destructor
CXBoxVideo::~CXBoxVideo( void )
{
    XDBGTRC( APP_TITLE_NAME_A, "CXBoxVideo::~CXBoxVideo()" );

    if( m_Device )
    {
        m_Device->Release();
        m_Device = NULL;
    }
    
    if( m_BackBuffer )
    {
        m_BackBuffer->Release();
        m_BackBuffer = NULL;
    }

    if( m_VertexBuffer )
    {
        m_VertexBuffer->Release();
        m_VertexBuffer = NULL;
    }
}

// Clear the screen
void CXBoxVideo::ClearScreen( DWORD color )
{
    if( FAILED( m_Device->Clear( 0, NULL, D3DCLEAR_TARGET, color, 1.0f, 0 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXboxVideo::ClearScreen():Failed to clear the screen!!" );
    }
}


// Draw the inputed bit array to the screen
//
// Parameters:
//      fx - the upper left x coordinate on screen
//      fy - the upper left y coordinate on screen
//      ulWidth - the width of the bitmap
//      ulHeight - the height of the bitmap
//      pData - a pointer to the array of pixel values
void CXBoxVideo::DrawBitBlt( float fx, float fy, ULONG ulWidth, ULONG ulHeight, const DWORD* pData )
{
    // Check to make sure we received a valid pointer
    if( !pData )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawBitBlt():pData not a valid pointer!" );

        return;
    }

    // Draw the bitmap on the screen, pixel by pixel
	for ( ULONG y = 0; y < ulHeight; y++ )
	{
		for ( ULONG x = 0; x < ulWidth; x++ )
		{
			if ( 0 != pData[y * ulWidth + x] )
			{
				DrawLine( fx + x, fy + y, fx + x, fy + y, 1.0f, pData[y * ulWidth + x] );
			}
		}
	}
}

// Draw a box on the screen
void CXBoxVideo::DrawBox( float x1, float y1, float x2, float y2, DWORD color )
{
	MYVERTEX* pb;
	float maxx, minx;
	float maxy, miny;

	CHECK( m_Device->BeginScene() );
	CHECK( m_VertexBuffer->Lock( 0, sizeof( MYVERTEX ) * 4, (BYTE**)&pb, 0 ) );
	
	if( IsBadWritePtr( pb, 128 ) )
	{
		XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawBox(): Lockreturned '%p', which is BAD!", pb );

		return;
	}

	if( x1 < x2 )
    {
		minx = x1;
		maxx = x2;
	}
    else
    {
		minx = x2;
		maxx = x1;
	}

	if( y1 < y2 )
    {
		miny = y1;
		maxy = y2;
	}
    else
    {
		miny = y2;
		maxy = y1;
	}

	if( x1 == x2 )
    {
		maxx++;
	}

	pb[0].v.x = minx; pb[0].v.y = miny; pb[0].v.z = .1f; pb[0].fRHW = .9f; pb[0].cDiffuse = color;
	pb[1].v.x = maxx; pb[1].v.y = miny; pb[1].v.z = .1f; pb[1].fRHW = .9f; pb[1].cDiffuse = color;
	pb[2].v.x = maxx; pb[2].v.y = maxy; pb[2].v.z = .1f; pb[2].fRHW = .9f; pb[2].cDiffuse = color;
	pb[3].v.x = minx; pb[3].v.y = maxy; pb[3].v.z = .1f; pb[3].fRHW = .9f; pb[3].cDiffuse = color;

	m_VertexBuffer->Unlock();

	m_Device->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, 2);
	m_Device->EndScene();
}


// Draw a clear rectangle to the screen
void CXBoxVideo::DrawClearRect( float x1, float y1, float x2, float y2, DWORD color ) 
{
	D3DRECT rect;

	if ( m_Device )
	{
		if( x1 < x2 )
        {
			rect.x1 = (long)x1; 
			rect.x2 = (long)x2 + 1;
		}
        else
        {
			rect.x1 = (long)x2; 
			rect.x2 = (long)x1 + 1;
		}

		if( y1 < y2 )
        {
			rect.y1 = (long)y1;
			rect.y2 = (long)y2 + 1;
		}
        else
        {
			rect.y1 = (long)y2;
			rect.y2 = (long)y1 + 1;
		}

		m_Device->Clear( 1, &rect, D3DCLEAR_TARGET, color, 0, 0 );
	}
}

// Draw a line to the screen
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      color          --- the RGBA color to draw the box with
HRESULT CXBoxVideo::DrawLine( float x1, float y1, float x2, float y2, float fLineWidth, DWORD color )
{
    HRESULT hr = S_OK;     // Return code for D3D functions that are called, and for the function
	MYVERTEX* pb;   // Vertex information

    // Set the line width
    if( FAILED( hr = m_Device->SetRenderState( D3DRS_LINEWIDTH, *(DWORD*)&fLineWidth ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Failed: m_Device->SetRenderState( D3DRS_LINEWIDTH, *(DWORD*)&fLineWidth )! - '%d'", hr );
    }

    // Before any rendering can be done, this must be called
	if( FAILED( hr = m_Device->BeginScene() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->BeginScene()! - '%d'", hr );
    }

    // Locks a range of vertex data and obtains a pointer to the vertex buffer memory.
	if( FAILED( hr = m_VertexBuffer->Lock( 0, sizeof( MYVERTEX ) * NUM_VB_VERTS, (BYTE**)&pb, 0 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_VertexBuffer->Lock()! - '%d'", hr );
    }

    pb[0].v.x = x1;  pb[0].v.y = y1; pb[0].v.z = .1f;  pb[0].fRHW = .9f;  pb[0].cDiffuse = color;
	pb[1].v.x = x2;  pb[1].v.y = y2; pb[1].v.z = .1f;  pb[1].fRHW = .9f;  pb[1].cDiffuse = color;

    // Unlock the vertext data
	if( FAILED( hr = m_VertexBuffer->Unlock() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_VertexBuffer->Unlock()! - '%d'", hr );
        
        return hr;
    }

    // Renders a sequence of nonindexed, geometric primitives of the specified type from the current set of data input streams
    if( FAILED( hr = m_Device->DrawPrimitive( D3DPT_LINELIST, 0, 1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->DrawPrimitive()! - '%d'", hr );
    }

    // Once rendering is complete, this must be called
    // We should try this, even on a failure, in case BeginScene() was successful
    // We'll report it to the debugger, but will not return the fail/success code to the
    // caller
	if( FAILED( m_Device->EndScene() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->EndScene()! - '%d'", hr );
    }

    return hr;
}

// Draw an outline to the screen
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      borderSize     --- width in pixels of the border
//      color          --- the RGBA color to draw the box with
void CXBoxVideo::DrawOutline( float x1, float y1, float x2, float y2, float fLineWidth, DWORD color )
{
    // Draw the box on the screen
    DrawLine( x1, y1, x1, y2, fLineWidth, color );     // Left Line
    DrawLine( x1, y2, x2, y2, fLineWidth, color );     // Bottom Line
    DrawLine( x2, y2, x2, y1, fLineWidth, color );     // Right Line
    DrawLine( x2, y1, x1, y1, fLineWidth, color );     // Top Line
}


// DeInitialize our Screen by freeing our objects
void CXBoxVideo::DeInitialize( void )
{
    if( m_BackBuffer)
    {
        m_BackBuffer->Release();
        m_BackBuffer = NULL;
    }

    if( m_Device )
    {
	    m_Device->Release();
        m_Device = NULL;
    }
}

// Prints formatted text using the default font to the screen
// Set colors to 0 to use default color
int CXBoxVideo::DrawText( float x1, float y1, DWORD fgcolor, DWORD bgcolor, const TCHAR* format, ... )
{
    if( !m_Font )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawText():The font is not set!!" );
        return -1;
    }

	int i;                  // Return Value
	HRESULT hr;             // Return Value for XFONT
	va_list v;              // Argument List
	TCHAR wstr[256];        // Honkin Buffer
    DWORD currentFGColor;   // Current FG Color
    DWORD currentBGColor;   // Current FG Color

    // Set our FONT colors if the user wishes to
    if( fgcolor || bgcolor )
    {
        // Set the foreground color if the user wants to
        if( fgcolor )
        {
            XFONT_SetTextColor( m_Font, fgcolor );
        }

        // Set the background color if the user wants to
        if( bgcolor )
        {
            XFONT_SetBkColor( m_Font, bgcolor );
        }
    }

	va_start( v, format );
	i = wvsprintf( wstr, format, v );

    // Print the Text to the backbuffer
    hr = XFONT_TextOut( m_Font, m_BackBuffer, wstr, i, (long)x1, (long)y1 );

    // If we have a valid font object, check the HRESULT
    if( FAILED( hr ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawText():XFONT_TextOut failed!!  HRESULT: %x", hr );
    }

	va_end( v );
	
    return i;
}

// Get the size of the current font
void CXBoxVideo::GetFontSize( unsigned int* pheight, unsigned int* pdecent )
{
    // Make sure we have loaded a font
    if( !m_Font )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetFontSize():The font is not set!!" );

        return;
    }

    // Verify the parameters that were passed in are corred
    if( ( !pheight ) || ( !pdecent ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetFontSize():Invalid arguments passed!!" );

        return;
    }

    XFONT_GetFontMetrics( m_Font, pheight, pdecent );
}

// Get the pixel width of a string
//
// Parameters:
//      string -- The string to get the length in pixels
//      length -- OPTIONAL.  The length of the string (-1 if NULL terminated, this is default)
int CXBoxVideo::GetStringPixelWidth( IN LPCWSTR string, IN int length /*=-1*/ ) 
{
    // Make sure we have loaded a font
    if( !m_Font )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( WCHAR* ):The font is not set!!" );

        return -1;
    }
    
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( WCHAR* ):Invalid (string) pointer passed in!" );

        return -1;
    }

	unsigned int outlen = 0;        // Return value

	XFONT_GetTextExtent( m_Font, string, length, &outlen );
	
    return outlen;
}

// Get the width of the char*
int CXBoxVideo::GetStringPixelWidth( IN char* string, IN int length /*=-1*/ ) 
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( char* ):Invalid pointer passed in!" );

        return -1;
    }

    int len = strlen( string );

    WCHAR newWStr[MAX_PATH];
    ZeroMemory( newWStr, MAX_PATH * sizeof( WCHAR ) );

    _snwprintf( newWStr, MAX_PATH - 1, L"%S", string );

    return GetStringPixelWidth( newWStr, length );
}

// Get a D3D Transform
HRESULT CXBoxVideo::GetTransform( D3DTRANSFORMSTATETYPE State, D3DMATRIX* pMatrix )
{
    return m_Device->GetTransform( State, pMatrix );
}

// Get the D3D Vertex Shader
HRESULT CXBoxVideo::GetVertexShader( DWORD* pHandle )
{
    return m_Device->GetVertexShader( pHandle );
}

// Lighten the image specified by "pBits"
void CXBoxVideo::LightenImage( int nWidth, int nHeight, DWORD* pBits, DWORD dwAddto )
{
	DWORD dwSize = nWidth * nHeight;
	_asm{
		mov ecx, [dwSize];
		shr ecx, 1;
		movd mm0, [dwAddto];
		pshufw mm0, mm0, 01000100b
		mov esi, [pBits]
theloop:
		movq mm1, [esi]
		paddusb mm1, mm0 ;//add, saturating to 255 if wrap would occur
		movq [esi], mm1
		add esi, 8
		dec ecx
		jnz theloop

        emms
	}
}

// Darken the image specified by "pBits"
void CXBoxVideo::DarkenImage( int nWidth, int nHeight, DWORD* pBits, DWORD dwSubtract )
{
	DWORD dwSize = nWidth * nHeight;
	_asm{
		mov ecx, [dwSize];
		shr ecx, 1;
		movd mm0, [dwSubtract];
		pshufw mm0, mm0, 01000100b ;;//propegate "subtract" into both dwords of mm0
		mov esi, [pBits]
theloop:
		movq mm1, [esi]
		psubusb mm1, mm0 ;//subtract, saturating to 0 or 255 if wrap would occur
		movq [esi], mm1
		add esi, 8
		dec ecx
		jnz theloop

        emms
	}
}

// Initialize D3D for this screen
void CXBoxVideo::Initialize( int width = SCREEN_WIDTH, int height = SCREEN_HEIGHT )
{
    IDirect3D8* pD3D = NULL;
    m_ScreenWidth = width;
    m_ScreenHeight = height;

	if ( m_Device == NULL )
	{
        // Create D3D 8.
		if( FAILED( pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) )
        {
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize(): Failed to create pD3D!" );
			return;
        }

        // Set the screen mode.
		D3DPRESENT_PARAMETERS d3dpp;
		ZeroMemory( &d3dpp, sizeof( d3dpp ) );

		d3dpp.BackBufferWidth                 = width;
		d3dpp.BackBufferHeight                = height;
		d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
		d3dpp.BackBufferCount                 = 1;

        d3dpp.hDeviceWindow                   = NULL;                    // Ignored on Xbox
		d3dpp.Windowed                        = FALSE;                   // Must be false for Xbox
		d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
        d3dpp.EnableAutoDepthStencil          = FALSE; // TRUE;
        d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
        d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_DEFAULT;

    // Always do interlaced output on an HDTV.
    if (XGetAVPack() == XC_AV_PACK_HDTV)
    {
        d3dpp.Flags = D3DPRESENTFLAG_INTERLACED;
    }

		// Create the m_Device.
		if ( FAILED ( pD3D->CreateDevice( D3DADAPTER_DEFAULT,
                                          D3DDEVTYPE_HAL,
                                          NULL,      // Ignored on Xbox
                                          D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                          &d3dpp,
                                          &m_Device ) ) )
		{
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to CreateDevice!" );
			pD3D->Release();

			return;
		}

		// Now we no longer need the D3D interface so let's free it.
		pD3D->Release();
	}

    if( FAILED( m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) Failed!!" );
    }

    // Create our vertex buffer
	if( FAILED( m_Device->CreateVertexBuffer( sizeof( MYVERTEX ) * NUM_VB_VERTS, 0, D3DFVF_XYZRHW | D3DFVF_DIFFUSE, D3DPOOL_DEFAULT, &m_VertexBuffer ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to create the Vertex Buffer!!" );
    }

    // Set the stream source
	m_Device->SetStreamSource( 0, m_VertexBuffer, sizeof( MYVERTEX ) );

    // Set our initial vertex shader that is compatible with our 2D scene
	if( FAILED( m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) Failed!!" );
    }

    // Setup matricies
    // Setup our identity matrix
    D3DMATRIX mat;
    mat._11 = mat._22 = mat._33 = mat._44 = 1.0f;
    mat._12 = mat._13 = mat._14 = mat._41 = 0.0f;
    mat._21 = mat._23 = mat._24 = mat._42 = 0.0f;
    mat._31 = mat._32 = mat._34 = mat._43 = 0.0f;

    // World Matrix
    // The world matrix controls the position and orientation 
    // of the polygons in world space. We'll use it later to 
    // spin the triangle.
    D3DMATRIX WorldMatrix = mat;

    // Set the transforms for our 3D world
    if( FAILED( m_Device->SetTransform( D3DTS_WORLD, &WorldMatrix ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the World Matrix!!" );
    }
    
    // View Matrix
    // The view matrix defines the position and orientation of 
    // the camera. Here, we are just moving it back along the z-
    // axis by 10 units.
    D3DMATRIX ViewMatrix = mat;
    ViewMatrix._43 = 10.0f;

    if( FAILED( m_Device->SetTransform( D3DTS_VIEW, &ViewMatrix ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the View Matrix!!" );
    }

    // Projection Matrix
    // The projection matrix defines how the 3-D scene is "projected" 
    // onto the 2-D render target surface. 

    // Set up a very simple projection that scales x and y 
    // by 2, and translates z by -1.0.
    D3DXMATRIX ProjectionMatrix; //  = mat;
    D3DXMatrixPerspectiveFovLH( &ProjectionMatrix, 1.57f, 640.0f/480.0f, 0.001f, 30.0f );

    if( FAILED( m_Device->SetTransform( D3DTS_PROJECTION, &ProjectionMatrix ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the Projection Matrix!!" );
    }
    
    // Viewport
    D3DVIEWPORT8 D3DViewport;    // Direct3D Viewport

    D3DViewport.X      = 0;
    D3DViewport.Y      = 0;
    D3DViewport.Width  = width;  // rect.right - rect.left;
    D3DViewport.Height = height; // rect.bottom - rect.top;
    D3DViewport.MinZ   = 0.0f;
    D3DViewport.MaxZ   = 1.0f;

    // Set our Viewport
    if( FAILED( m_Device->SetViewport( &D3DViewport ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set the viewport!!" );
    }
    
    XFONT_OpenTrueTypeFont( FILE_DATA_DEFAULT_FONT_FILENAME, 4096, &m_Font );

	if( m_Font )
    {
	    if( FAILED( m_Device->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &m_BackBuffer ) ) )
        {
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->GetBackBuffer() Failed!!" );
        }

        XFONT_SetTextColor( m_Font, SCREEN_DEFAULT_TEXT_FG_COLOR );
        XFONT_SetTextAlignment( m_Font, XFONT_CENTER );
        XFONT_SetBkColor( m_Font, SCREEN_DEFAULT_TEXT_BG_COLOR );
        XFONT_SetTextHeight( m_Font, FONT_DEFAULT_HEIGHT );
        XFONT_SetTextAntialiasLevel( m_Font, FONT_ALIAS_LEVEL );
        XFONT_SetTextStyle( m_Font, FONT_DEFAULT_STYLE );
    }
}


// Set a D3D Transform
HRESULT CXBoxVideo::SetTransform( D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix )
{
    return m_Device->SetTransform( State, pMatrix );
};

// Display the current backbuffer on to the screen
void CXBoxVideo::ShowScreen()
{
	if( m_Device )
    {
		m_Device->Present( NULL, NULL, NULL, NULL );
	}
}


// Set the D3D Vertex Shader
HRESULT CXBoxVideo::SetVertexShader( DWORD Handle )
{
    return m_Device->SetVertexShader( Handle );
}


// Truncate a string to fit within a certain screen size
HRESULT CXBoxVideo::TruncateStringToFit( WCHAR* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::TruncateStringToFit():Invalid argument!! x1 - '%f', x2 - '%f'", x1, x2 );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[wcslen( pString ) - 1] = L'\0';

        // Ensure we don't end up in an endless loop
        if( L'\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}


// Truncate a string to fit within a certain screen size
HRESULT CXBoxVideo::TruncateStringToFit( char* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::TruncateStringToFit():Invalid argument!! x1 - '%f', x2 - '%f'", x1, x2 );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[strlen( pString ) - 1] = '\0';

        // Ensure we don't end up in an endless loop
        if( '\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4177\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4181\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4180\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4180\4180.cpp ===
#include <xtl.h>

void __cdecl main()
{
    class Foo
    {
    public:
        virtual ~Foo() {}
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\makefile.inc ===
#
# Standard inference rule for generating dsp files.
#
.SUFFIXES: .dsp .dsx

{}.dsx{}.dsp:
    m4 -DPROJNAME=$(PROJNAME) -DTARGETNAME=$(TARGETNAME) -DTITLEID=$(TITLEID) -DCOMMONSOURCEFILELIST= -DRELEASELIBS= -DDEBUGLIBS= $** > tmp.m4
    m4 -DPOUND=# tmp.m4 > $@
    del tmp.m4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4182\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4177\4177.cpp ===
#include <xtl.h>

class vec4
{
public :
	float x,y,z,w;

	vec4() {}
	vec4(const vec4 &bug):x(bug.x), y(bug.y), z(bug.z), w(bug.w) {}
};

class mat
{
public:
	vec4 vec[4];
};

class mat2
{
public:
	mat a, b;

	mat2() {}
	mat2(const mat &y):a(y), b(y) {}
};

mat2 *yy1, *yy2;

void FooBar(void)
{
	*yy1 = mat2(yy1->a);
}

void __cdecl main()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4183\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4182\4182.cpp ===
#include <xtl.h>

// This compiles  fine with VC6

template <class T = float, class Tr = VectorTraits2<T> >
class BaseVector2
{
	BaseVector2();
	BaseVector2& operator += (const BaseVector2& v);
	BaseVector2<T,Tr>& set(T n);

private:
  T mN[3];
};

template <class T, class Tr>
inline BaseVector2<T,Tr>&
BaseVector2<T,Tr>::operator += (const BaseVector2<T,Tr>& v)
{ 
	mN[0] += v.mN[0];
	mN[1] += v.mN[1];
	return *this;
}

template <class T, class Tr>
inline BaseVector2<T,Tr>&
BaseVector2<T,Tr>::set(T n)
{ 
	mN[0] = n;
	mN[1] = n;
	return *this;
}

void __cdecl main()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4181\4181.cpp ===
#include <xtl.h>
// This compiles  fine with VC6 and gcc

class test1
{
public:
    void Foo(int) {}
    void Foo2(void) {}
};

class test2
{
public:
	/*
	template <class T>
		void Set(char* n, T* o, void (T::*func)(void)) { someVal = 1;}
	*/
	template <class T, class R>
		void Set(char* n, T* o, R (T::*func)(void)) { someVal = 1;}
	template <class T, class R, class P1>
		void Set(char* n, T* o, R (T::*func)(P1)) { someVal = 2; }
	template <class T, class R, class P1, class P2>
		void Set(char* n, T* o, R (T::*func)(P1,P2)) { someVal = 3; }

	int someVal;
};

void __cdecl main()
{
    test1 t1;
    test2 t2;

    t2.Set("blah", &t1, &test1::Foo);
    t2.Set("blah", &t1, &test1::Foo2);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4229\CarWheelNumbers.h ===
#ifndef __CAR_WHEEL_NUMBERS
#define __CAR_WHEEL_NUMBERS

//      X
//      ^
//      |
//     0 1
// Y<--
//     2 3

// note that this is partially handy because it means
// that as we iterate through the wheels, we render the
// two instances of each wheel in order.
enum
{
	CAR_WHEEL_LF = 0,
	CAR_WHEEL_RF,
	CAR_WHEEL_LR,
	CAR_WHEEL_RR,

	CAR_WHEELS
};

#define CAR_WHEEL_MASK_RIGHT 1
#define CAR_WHEEL_MASK_REAR  2

#define CAR_WHEEL_FRONT(w) (!((w) & CAR_WHEEL_MASK_REAR))
#define CAR_WHEEL_BACK(w )   ((w) & CAR_WHEEL_MASK_REAR)
#define CAR_WHEEL_RIGHT(w)   ((w) & CAR_WHEEL_MASK_RIGHT)
#define CAR_WHEEL_LEFT(w)  (!((w) & CAR_WHEEL_MASK_RIGHT))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4229\CarWheel.h ===
#ifndef __CARWHEEL_H
#define __CARWHEEL_H

#ifndef __VECTOR_H
#include "vector.h"
#endif

struct Car;
struct SkidMarkBlock;


struct CarWheel
{
	// transform wheel into world coords
	M4    m_transform;                  // transform of wheel
	M4    m_caliperTransform;           // transform of caliper, does not rotate
	V3    m_lastPosition;               // position before physics this frame
	float m_lastSpinVel;                // copied from m_car->m_physicsCar
	V2    m_slip;                       // amount of wheel-local slip this frame in m/s
	
	// position of last skid mark, even if it was not actually laid down.
	// essentially works out to previous two corners of strip.
	V3 m_skidPosition[4];               // corners of current skid quad
	// 0 = no skid mark, 255 = black skid mark.
	int m_skidding;                     // how much I am skidding
	int m_skiddingLast;                 // how much I was skidding last frame
	int m_skidTimer;                    // how long I have been skidding

	int m_index;                        // what wheel we are

	Car           *m_car;               // my car
	SkidMarkBlock *m_skidMark;          // my skid marks

	CarWheel();
	void  m_Init();
	void  m_FrameInit();
	void  m_InvalidateLastPosition(void);
	void  m_CalculateVelocities(void);

	void  m_AbortSkidMarks(void);
	void  m_LeaveSkidMarks(void);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4183\4183.cpp ===
// Repro code:

struct kkk
{
	operator const float &()
	{
		static const float r = 0.F;
		return r;
	}
};

void __cdecl main()
{
	float kk;
	kk = kkk();

	class Foo2
	{
	public:
		virtual ~Foo2() {}
	};
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\Setup\Include\install.inc ===
'$include 'winapi.inc'
'$resource 'install.vtr'
' File name: install.inc
'
' Author: Winthrop Chan (winthc@microsoft.com)
' Date  : March 12, 2001
'
' Description:
'	Shared routines for performing install and uninstall automation for the Xbox SDK
'

'
' @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
'
' Global variables and constants
'
' @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
'

'
' Global constants used by Automation
'
Global BuildNumber                as string
Global DefaultTimeOut             as integer
Global UninstallKey               as string
Global TempLocalInstallSourcePath as string
Global TempLocalInstallTargetPath as string
Global TempNetInstallSourcePath   as string
Global TempNetInstallTargetPath   as string
Global TempStartMenuPath          as string
Global DefaultInstallSourceRoot   as string
Global DefaultInstallTargetPath   as string
Global DefaultStartMenuPath       as string

Global CurrentWindow              as Long
Global TimeOut                    as Long
Global ReleaseNotes               as integer

Const  iniFile                    = "c:\XDKSetupTest.ini"
DefaultInstallSourceRoot          = "\\xbuilds\release\usa"
'DefaultInstallSourceRoot          = "\\xbuilds\pvtrelease\usa"
'
' Constants for Find Window flags
'
Const EXIST     = FW_FOCUS or FW_PART or FW_ERROR or FW_ALL
Const NO_EXIST  = FW_NOEXIST or FW_PART or FW_ERROR or FW_ALL
Const MAY_EXIST = FW_FOCUS or FW_PART or FW_ALL
Const FW_BASE_FLAGS = FW_FOCUS Or FW_IGNOREFILE Or FW_ERROR
Const FINDWINDOWFLAGS = FW_BASE_FLAGS

'
' Function definitions for localization support
'
declare function GetSystemDefaultLangID      lib "kernel32.dll" alias "GetSystemDefaultLangID"     () as long
declare function GetSystemDefaultUILanguage  lib "kernel32.dll" alias "GetSystemDefaultUILanguage" () as long


'
' @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
'
' Initialization
'
' @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
'
LoadSettings
'
' Workaround for bug when release notes are missing from build
'
ReleaseNotes = true


'
' Localization Support Strings
'
Global strInstallShield_Wizard$
Global strConfirm_File_Deletion$
Global strMaintenance_Complete$
Global strMicrosoft_Xbox_SDK_Setup$
Global strWelcome_to_Microsoft_Xbox_SDK_Setup$
Global strSevere$
Global strIn_Use$
Global strXbox_SDK_Setup_Notes$
Global strChoose_Destination_Location$
Global strPlease_choose_the_installation_folder$
Global strSelect_Program_Folder$
Global strStart_Copying_Files$
Global strSetup_Status$
Global strXDK_Release_Notes$
Global strXDK_Update_Instructions$
Global strExit_Setup$
Global strWarning$
Global strSetup_Needs_The_Next_Disk$
Global strInstallShield_Wizard_Complete$

'
' Select correct strings for locale
'
if GetSystemDefaultLangID() <> 1041 then	' English Localized strings
	strInstallShield_Wizard  = "InstallShield Wizard"
	strConfirm_File_Deletion = "Confirm File Deletion"
	strMaintenance_Complete  = "Maintenance Complete"
	strMicrosoft_Xbox_SDK_Setup = "Microsoft Xbox SDK Setup"
	strWelcome_to_Microsoft_Xbox_SDK_Setup = "Welcome to Microsoft Xbox SDK Setup"
	strSevere = "Severe"
	strIn_Use = "One or more Visual C++ files is in use. Please close and try again."
	strXbox_SDK_Setup_Notes = "Xbox SDK Setup Notes"
	strChoose_Destination_Location = "Choose Destination Location"
	strPlease_choose_the_installation_folder = "Please choose the installation folder."
	strSelect_Program_Folder = "Select Program Folder"
	strStart_Copying_Files = "Start Copying Files"
	strSetup_Status = "Setup Status"
'	strXDK_Release_Notes = "XDK Release Notes"
'	strXDK_Update_Instructions = "XDK Update Instructions"
	strXDK_Release_Notes = "XDK "
	strXDK_Update_Instructions = "XDK "
	strExit_Setup = "Exit Setup"
	strWarning = "Warning"
	strSetup_Needs_The_Next_Disk = "Setup Needs The Next Disk"
	strInstallShield_Wizard_Complete = "InstallShield Wizard Complete"
else	' Japanese Localized strings
	strInstallShield_Wizard  = "InstallShield "
	strConfirm_File_Deletion = "mF"
	strMaintenance_Complete  = ""
	strMicrosoft_Xbox_SDK_Setup = "Microsoft Xbox SDK ZbgAbv"
	strWelcome_to_Microsoft_Xbox_SDK_Setup = "Microsoft Xbox SDK ZbgAbv"+chr$(13)
	strSevere = ""
	strIn_Use = " Visual C++ t@CgpBgpt@CAxB"
	strXbox_SDK_Setup_Notes = "Xbox SDK ZbgAbv m[g"
	strChoose_Destination_Location = "I"
	strPlease_choose_the_installation_folder = "IB"
	strSelect_Program_Folder = " I"
	strStart_Copying_Files = " Jn"
	strSetup_Status = " "
'	strXDK_Release_Notes = "XDK [X m[g"
'	strXDK_Update_Instructions = "XDK Abvf[g"
	strXDK_Release_Notes = "XDK "
	strXDK_Update_Instructions = "XDK "
	strExit_Setup = "~"
	strWarning = "x"
	strSetup_Needs_The_Next_Disk = "}"
	strInstallShield_Wizard_Complete = "InstallShield Wizard Complete"
end if




'
' @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
'
' Function definition section
'
' @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
'


'
' Function:    LoadSettings()
'
' Parameters:  none
' Returns:     Nothing
'
' Description: Retrieves Setup Automation settings from INI file
'
' Note:        Only tested with InstallShield based setup Build 3406 +
'
sub LoadSettings()
	Dim strBuffer$
	Dim retVal%


	'
	' BuildNumber
	'
	strBuffer = space(2048)
	retVal = GetPrivateProfileString("Setup Automation Settings", "BuildNumber", "0", strBuffer, len(strBuffer), iniFile)
	if BuildNumber = "0" then
		BuildNumber = LatestBuild
	else
		BuildNumber = trim$(strBuffer)
	end if
	'
	' DefaultTimeOut
	'
	strBuffer = space(2048)
	TimeOut = GetPrivateProfileInt("Setup Automation Settings","DefaultTimeOut", 5, iniFile)
	'
	' UninstallKey
	'
	strBuffer = space(2048)
	retVal = GetPrivateProfileString("Setup Automation Settings","UninstallKey","{958CD46E-504C-4D7B-8336-EA13AAE02B15}", strBuffer, len(strBuffer), iniFile)
	UninstallKey = left$(strBuffer, retVal)
	'
	' TempLocalInstallSourcePath
	'
	strBuffer = space(2048)
	retVal = GetPrivateProfileString("Setup Automation Settings","TempLocalInstallSourcePath","c:\$$Setup$.$$$", strBuffer, len(strBuffer), iniFile)
	TempLocalInstallSourcePath = left$(strBuffer, retVal)
	'
	' TempLocalInstallTargetPath
	'
	strBuffer = space(2048)
	retVal = GetPrivateProfileString("Setup Automation Settings","TempLocalInstallTargetPath","c:\$$Xbox$$.$$$", strBuffer, len(strBuffer), iniFile)
	TempLocalInstallTargetPath = left$(strBuffer, retVal)
	'
	' TempNetInstallSourcePath
	'
	strBuffer = space(2048)
	retVal = GetPrivateProfileString("Setup Automation Settings","TempNetInstallSourcePath","\\xdk\XDKTest\SetupScratch\Setup", strBuffer, len(strBuffer), iniFile)
	TempNetInstallSourcePath = left$(strBuffer, retVal)
	'
	' TempNetInstallTargetPath
	'
	strBuffer = space(2048)
	retVal = GetPrivateProfileString("Setup Automation Settings","TempNetInstallTargetPath","\\xdk\XDKTest\SetupScratch\Target", strBuffer, len(strBuffer), iniFile)
	TempNetInstallTargetPath = left$(strBuffer, retVal)
	'
	' TempStartMenuPath
	'
	strBuffer = space(2048)
	retVal = GetPrivateProfileString("Setup Automation Settings","TempStartMenuPath","Accessories\MS Xbox SDK", strBuffer, len(strBuffer), iniFile)
	TempStartMenuPath = left$(strBuffer, retVal)
	'
	' DefaultInstallSourceRoot
	'
	strBuffer = space(2048)
	retVal = GetPrivateProfileString("Setup Automation Settings","DefaultInstallSourceRoot","\\xbuilds\release\usa", strBuffer, len(strBuffer), iniFile)
	DefaultInstallSourceRoot = left$(strBuffer, retVal)
	'
	' DefaultInstallTargetPath
	'
	strBuffer = space(2048)
	retVal = GetPrivateProfileString("Setup Automation Settings","DefaultInstallTargetPath","c:\Program Files\Microsoft Xbox SDK", strBuffer, len(strBuffer), iniFile)
	DefaultInstallTargetPath = left$(strBuffer, retVal)
	'
	' DefaultStartMenuPath
	'
	strBuffer = space(2048)
	retVal = GetPrivateProfileString("Setup Automation Settings","DefaultStartMenuPath","Microsoft Xbox SDK", strBuffer, len(strBuffer), iniFile)
	DefaultStartMenuPath = left$(strBuffer, retVal)
	'
	' If no INI file exists, then Save settings
	'
	if not exists(iniFile) then
		SaveSettings(false)	
	end if
end sub


'
' Function:    SaveSettings()
'
' Parameters:  useDefaults - Boolean. True if use default values. False if save existing values
' Returns:     Nothing
'
' Description: Saves Setup Automation settings to INI file
'
' Note:        Only tested with InstallShield based setup Build 3406 +
'
sub SaveSettings(useDefaults%=true)
	Dim locBuildNumber$, locDefaultTimeOut$, locUninstallKey$
	Dim locTempLocalInstallSourcePath$, locTempLocalInstallTargetPath$
	Dim locTempNetInstallSourcePath$, locTempNetInstallTargetPath$
	Dim locTempStartMenuPath$, locDefaultInstallSourceRoot$
	Dim locDefaultInstallTargetPath$, locDefaultStartMenuPath$

	if useDefaults then
		locBuildNumber                = LatestBuild()
		locDefaultTimeOut             = "5"
		locUninstallKey               = "{958CD46E-504C-4D7B-8336-EA13AAE02B15}"
		locTempLocalInstallSourcePath = "c:\$$Setup$.$$$"
		locTempLocalInstallTargetPath = "c:\$$Xbox$$.$$$"
		locTempNetInstallSourcePath   = "\\xdk\XDKTest\SetupScratch\Setup"
		locTempNetInstallTargetPath   = "\\xdk\XDKTest\SetupScratch\Target"
		locTempStartMenuPath          = "Accessories\MS Xbox SDK"
		locDefaultInstallSourceRoot   = "\\xbuilds\release\usa"
		locDefaultInstallTargetPath   = "c:\Program Files\Microsoft Xbox SDK"
		locDefaultStartMenuPath       = "Microsoft Xbox SDK"
	else
		locBuildNumber                = trim(BuildNumber)
		locDefaultTimeOut             = trim(str(TimeOut))
		locUninstallKey               = UninstallKey
		locTempLocalInstallSourcePath = TempLocalInstallSourcePath
		locTempLocalInstallTargetPath = TempLocalInstallTargetPath
		locTempNetInstallSourcePath   = TempNetInstallSourcePath
		locTempNetInstallTargetPath   = TempNetInstallTargetPath
		locTempStartMenuPath          = TempStartMenuPath
		locDefaultInstallSourceRoot   = DefaultInstallSourceRoot
		locDefaultInstallTargetPath   = DefaultInstallTargetPath
		locDefaultStartMenuPath       = DefaultStartMenuPath
	end if

	'
	' BuildNumber
	'
	WritePrivateProfileString("Setup Automation Settings","BuildNumber", locBuildNumber, iniFile)
	'
	' DefaultTimeOut
	'
	WritePrivateProfileString("Setup Automation Settings","DefaultTimeOut", locDefaultTimeOut, iniFile)
	'
	' UninstallKey
	'
	WritePrivateProfileString("Setup Automation Settings","UninstallKey", locUninstallKey, iniFile)
	'
	' TempLocalInstallSourcePath
	'
	WritePrivateProfileString("Setup Automation Settings","TempLocalInstallSourcePath", locTempLocalInstallSourcePath, iniFile)
	'
	' TempLocalInstallTargetPath
	'
	WritePrivateProfileString("Setup Automation Settings","TempLocalInstallTargetPath", locTempLocalInstallTargetPath, iniFile)
	'
	' TempNetInstallSourcePath
	'
	WritePrivateProfileString("Setup Automation Settings","TempNetInstallSourcePath", locTempNetInstallSourcePath, iniFile)
	'
	' TempNetInstallTargetPath
	'
	WritePrivateProfileString("Setup Automation Settings","TempNetInstallTargetPath", locTempNetInstallTargetPath, iniFile)
	'
	' TempStartMenuPath
	'
	WritePrivateProfileString("Setup Automation Settings","TempStartMenuPath", locTempStartMenuPath, iniFile)
	'
	' DefaultInstallSourceRoot
	'
	WritePrivateProfileString("Setup Automation Settings","DefaultInstallSourceRoot", locDefaultInstallSourceRoot, iniFile)
	'
	' DefaultInstallTargetPath
	'
	WritePrivateProfileString("Setup Automation Settings","DefaultInstallTargetPath", locDefaultInstallTargetPath, iniFile)
	'
	' DefaultStartMenuPath
	'
	WritePrivateProfileString("Setup Automation Settings","DefaultStartMenuPath", locDefaultStartMenuPath, iniFile)
end sub

'
' Function:    Init()
'
' Parameters:  none
' Returns:     Nothing
'
' Description: Opens Settings Dialog to set Automation settings
'
sub Init()
	dim Dlg as IDD_SETTINGS

	viewport clear

	LoadSettings()

	dlg.Proc = varptr(SettingsDlgProc)

	dlg.IDC_BUILDNUM         = trim$(BuildNumber)
	dlg.IDC_TIMEOUT          = trim(str(TimeOut))
	dlg.IDC_UNINSTALLKEY     = UninstallKey
	dlg.IDC_DEFAULTSOURCE    = DefaultInstallSourceRoot
	dlg.IDC_DEFAULTTARGET    = DefaultInstallTargetPath
	dlg.IDC_DEFAULTSTARTMENU = DefaultStartMenuPath
	dlg.IDC_TEMPSTARTMENU    = TempStartMenuPath
	dlg.IDC_LOCALSOURCE      = TempLocalInstallSourcePath
	dlg.IDC_NETWORKSOURCE    = TempNetInstallSourcePath
	dlg.IDC_LOCALTARGET      = TempLocalInstallTargetPath
	dlg.IDC_NETWORKTARGET    = TempNetInstallTargetPath

	dialog(dlg)
	SaveSettings(false)
end sub


'
' Function:    SettingsDlgProc()
'
' Parameters:  ...
' Returns:     long
'
' Description: Settings Dialog Command procedure
'
Function SettingsDlgProc(hwnd&, msg&, wParam&, lParam&) as long
	SettingsDlgProc = TRUE
	select case msg
		Case WM_COMMAND
			Select Case wParam
				Case IDOK
					BuildNumber                = trim$(edittext("#"+trim$(str$(IDC_BUILDNUM))))
					TimeOut                    = val(edittext("#"+trim$(str$(IDC_TIMEOUT))))
					UninstallKey               = trim$(edittext("#"+trim$(str$(IDC_UNINSTALLKEY))))
					DefaultInstallSourceRoot   = trim$(edittext("#"+trim$(str$(IDC_DEFAULTSOURCE))))
					DefaultInstallTargetPath   = trim$(edittext("#"+trim$(str$(IDC_DEFAULTTARGET))))
					DefaultStartMenuPath       = trim$(edittext("#"+trim$(str$(IDC_DEFAULTSTARTMENU))))
					TempStartMenuPath          = trim$(edittext("#"+trim$(str$(IDC_TEMPSTARTMENU))))
					TempLocalInstallSourcePath = trim$(edittext("#"+trim$(str$(IDC_LOCALSOURCE))))
					TempNetInstallSourcePath   = trim$(edittext("#"+trim$(str$(IDC_NETWORKSOURCE))))
					TempLocalInstallTargetPath = trim$(edittext("#"+trim$(str$(IDC_LOCALTARGET))))
					TempNetInstallTargetPath   = trim$(edittext("#"+trim$(str$(IDC_NETWORKTARGET))))

					SettingsDlgProc = FALSE
				Case IDC_DEFAULTS
					wEditSetText("#"+trim$(str$(IDC_BUILDNUM)),         LatestBuild())
					wEditSetText("#"+trim$(str$(IDC_TIMEOUT)),          "5")
					wEditSetText("#"+trim$(str$(IDC_UNINSTALLKEY)),     "{958CD46E-504C-4D7B-8336-EA13AAE02B15}")
					wEditSetText("#"+trim$(str$(IDC_DEFAULTSOURCE)),    "\\xbuilds\release\usa")
					wEditSetText("#"+trim$(str$(IDC_DEFAULTTARGET)),    "c:\Program Files\Microsoft Xbox SDK")
					wEditSetText("#"+trim$(str$(IDC_DEFAULTSTARTMENU)), "Microsoft Xbox SDK")
					wEditSetText("#"+trim$(str$(IDC_TEMPSTARTMENU)),    "Accessories\MS Xbox SDK")
					wEditSetText("#"+trim$(str$(IDC_LOCALSOURCE)),      "c:\$$Setup$.$$$")
					wEditSetText("#"+trim$(str$(IDC_NETWORKSOURCE)),    "\\xdk\XDKTest\SetupScratch\Setup")
					wEditSetText("#"+trim$(str$(IDC_LOCALTARGET)),      "c:\$$Xbox$$.$$$")
					wEditSetText("#"+trim$(str$(IDC_NETWORKTARGET)),    "\\xdk\XDKTest\SetupScratch\Target")
			End select
		case else
			SettingsDlgProc = FALSE
	end select
end function


'
' Function:    HitKey()
'
' Parameters:  CurDialog%		- Current Dialog of setup
'              buttonID%		- Array of button ID's
'              buttonKey%		- Array of button Keystrokes
'              CancelAt%		- Install dialog to call cancel at
'									0 - Updater Start Dialog
'									1 - Updater Extracting setup dialog
'									2 - Main setup welcome screen
'									3 - Setup notes screen
'									4 - Destination Location screen
'									5 - Program Folder Screen
'									6 - Start Copying Files screen
'									7 - Setup Status Screen
' Returns:     Nothing
'
' Description: Helper function to call either the button click or hotkey
'
' Note:        Only tested with InstallShield based setup Build 3406 +
'
Sub HitKey(CurDialog%, buttonID$(), buttonKey$(), UseHotKeys%=false, CancelAt%=-1)
	Dim hitType%

	if CurDialog = CancelAt then
		hitType = 1
	else
		hitType = 0
	End if

	'
	' Problem with InstallShield. Need to set focus on a button prior to sendkey
	'
	WButtonSetFocus(buttonID(CurDialog, hitType))
	if UseHotKeys then
		Play buttonKey(CurDialog, hitType)
	else
		WButtonClick(buttonID(CurDialog, hitType), 10)
	end if
end Sub


'
' Function:    IsInstalled()
'
' Parameters:  none
' Returns:     True		- If Xbox SDK is installed
'              False	- If Xbox SDK is not installed
'
' Description: Checks to see if SDK is installed
'
' Note:        Only tested with InstallShield based setup Build 3406 +
'
function IsInstalled() as short
	IsInstalled = RegistryKeyExists("HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\"+UninstallKey)
end function


'
' Function:    LatestBuild()
'
' Parameters:  none
' Returns:     String	- If a build number exists
'              NULL		- If unable to determine build
'
' Description: Returns latest build on network drop
'
' Note:        Only tested with InstallShield based setup Build 3406 +
'
function LatestBuild() as string
	Dim tempBuild$
	Dim intFile as integer

	'
	' Get latest Build Number
	'
	if not exists(DefaultInstallSourceRoot+"\latest.txt") then
		LatestBuild = "0"
	else
		intfile = FREEFILE
		open DefaultInstallSourceRoot+"\latest.txt" for input as intfile
		line input #intFile, tempBuild
		close #1
		LatestBuild = trim$(tempBuild)
	end if
end function


'
' Function:    GetXDKPath()
'
' Parameters:  none
' Returns:     String	- path to XDK Installation if it exists
'
' Description: returns path to XDK Installation if it exists
'
' Note:        Only tested with InstallShield based setup Build 3406 +
'
function GetXDKPath() as string
	if RegistryValueExists("HKEY_CURRENT_USER\Environment","XDK") then
		GetXDKPath = RegistryGetValue("HKEY_CURRENT_USER\Environment","XDK")
	else
		GetXDKPath = ""
	endif
end function


'
' Function:    CancelInstall()
'
' Parameters:  UseHotKeys%	- True if using hotkeys. False if using buttons
' Returns:     nothing
'
' Description: Automates the Install process for the SDK
'
' Note:        Only tested with InstallShield based setup Build 3406 +
'
sub CancelInstall(UseHotKeys%=false)
	CurrentWindow = WFndWndC(strExit_Setup, "#32770", FINDWINDOWFLAGS, 15)
	if UseHotKeys then
		Play "%(y)"
	else
		WButtonSetFocus("#6")
		WButtonClick("#6", 10)
	end if
	sleep 5
end sub


'
' Function:    Install()
'
' Parameters:  BuildNum%		- Build Number to install
'              UseUpdater%		- True to use the updater setup and false to run the full SDK setup
'              UseHotKeys%		- True to use hotkeys and false to use button clicks
'              CancelAt%		- Install dialog to call cancel at
'									0 - Updater Start Dialog
'									1 - Updater Extracting setup dialog
'									2 - Main setup welcome screen
'									3 - Setup notes screen
'									4 - Destination Location screen
'									5 - Program Folder Screen
'									6 - Start Copying Files screen
'									7 - Setup Status Screen
'              InstallSource$	- Path to executable. If BuildNum is 0, then this is the full pathname to run
'              InstallPath$		- Path to install SDK
'              StartMenuPath$	- Start Menu path
'              RelNoteTitle$    - Window title for release notes
' Returns:     Nothing
'
' Description: Automates the Install process for the SDK
'
' Note:        Only tested with InstallShield based setup Build 3406 +
'
Sub Install(BuildNum$, UseUpdater%, UseHotKeys%=false, CancelAt%=-1, InstallSource$="", InstallPath$="", StartMenuPath$="", RelNoteTitle$="")
	Dim strSetupExeFile As String
	Dim intBuild As long
	Dim IsUpdaterSetup as integer
	Dim hwnd as long
	Dim details as INFO
	Dim buttonID$(15,2)
	Dim buttonKey$(15,2)
	Dim IsUpdate as integer
	Dim FinishString$
	Dim InstalledBuild$
	Dim IsQFE as integer
	Dim BuildKey$


	'
	' Special condition when running the setup on an existing installation
	'
	if RegistryKeyExists("HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\XboxSDK") then
		if RegistryValueExists("HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\XboxSDK", "July01SDK") then
			BuildKey = "July01SDK"
		elseif RegistryValueExists("HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\XboxSDK", "June01SDK") then
			BuildKey = "June01SDK"
		elseif RegistryValueExists("HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\XboxSDK", "May01SDK") then
			BuildKey = "May01SDK"
		elseif RegistryValueExists("HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\XboxSDK", "April01SDK") then
			BuildKey = "April01SDK"
		elseif RegistryValueExists("HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\XboxSDK", "March01SDK") then
			BuildKey = "March01SDK"
		elseif RegistryValueExists("HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\XboxSDK", "Build") then
			BuildKey = "Build"
		else
			BuildKey = ""
		end if
		if BuildKey <> "" then
			InstalledBuild = trim$(str$(RegistryGetValue("HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\XboxSDK", BuildKey)))
		else
			InstalledBuild = "0"
		end if
	else
		InstalledBuild = "0"
	end if
		
	if IsInstalled and (InstalledBuild < BuildNum) then
		IsUpdate = true
		FinishString = strMaintenance_Complete
		if instr(BuildNum, ".") <> 0 then
			IsQFE = true
			if BuildNum > "3147" then
				FinishString = 	strInstallShield_Wizard_Complete
			end if
		end if
	else
		IsUpdate = false
		FinishString = strMicrosoft_Xbox_SDK_Setup
	end if

	'
	' Initialize Keystrokes
	'
	' Updater Start Dialog
	buttonID ( 0,0) = _id(&h3024)
	buttonKey( 0,0) = "%(n)"
	buttonID ( 0,1) = _id(2)
	buttonKey( 0,1) = "{ESC}"
	' Updater Extracting Setup Dialog
	buttonID ( 1,0) = ""
	buttonKey( 1,0) = ""
	buttonID ( 1,1) = _id(2)
	buttonKey( 1,1) = " "
	' Main Setup Welcome
	buttonID ( 2,0) = _id(1)
	buttonKey( 2,0) = "%(n)"
	buttonID ( 2,1) = _id(9)
	buttonKey( 2,1) = "{ESC}"
	' Setup Notes
	buttonID ( 3,0) = _id(6)
	buttonKey( 3,0) = "%(y)"
	buttonID ( 3,1) = _id(9)
	buttonKey( 3,1) = "%(n)"
	' Destination Location
	buttonID ( 4,0) = _id(1)
	buttonKey( 4,0) = "%(n)"
	buttonID ( 4,1) = _id(9)
	buttonKey( 4,1) = " "
	' Program Folder
	buttonID ( 5,0) = _id(1)
	buttonKey( 5,0) = "%(n)"
	buttonID ( 5,1) = _id(9)
	buttonKey( 5,1) = " "
	' Start Copying Files
	buttonID ( 6,0) = _id(1)
	buttonKey( 6,0) = "%(n)"
	buttonID ( 6,1) = _id(9)
	buttonKey( 6,1) = " "
	' Setup Status
	buttonID ( 7,0) = ""
	buttonKey( 7,0) = ""
	buttonID ( 7,1) = _id(2)
	buttonKey( 7,1) = " "
	' Setup Complete
	buttonID ( 8,0) = _id(1)
	buttonKey( 8,0) = "{ENTER}"
	buttonID ( 8,1) = ""
	buttonKey( 8,1) = ""


	if trim$(InstallSource) = "" then
		strSetupExeFile = DefaultInstallSourceRoot + "\" + trim$(BuildNum) + "\"
	else
		if lcase(right(trim$(InstallSource),4)) <> ".exe" then
			strSetupExeFile = InstallSource + "\"
		else
			strSetupExeFile = InstallSource
		endif
	end if

	if strSetupExeFile <> InstallSource then
		if UseUpdater then
			strSetupExeFile = strSetupExeFile + "XboxSDKUpdate" + trim$(BuildNum) + ".exe"
		else
			strSetupExeFile = strSetupExeFile + "sdk\setup.exe"
		end if
	end if

	LOG #10, "Executing Installer: "+strSetupExeFile
	if exists(strSetupExeFile) then
		Run strSetupExeFile, NOWAIT
	else
		FAIL "Install Program does not exist: "+strSetupExeFile
	end if

	if UseUpdater AND not IsQFE then
		'
		' Initial Updater dialog
		'
		CurrentWindow = WFndWndC("Microsoft Xbox SDK Update - InstallShield Wizard", "#32770", FINDWINDOWFLAGS, 300)
		HitKey(0, buttonID, buttonKey, UseHotKeys, CancelAt)
		if (CancelAt = 0) then
			sleep 5
			goto installverify
		end if

		'
		' Expand setup files dialog
		'
		hwnd = WButtonFind(_id(2), 10)
		if hwnd <> 0 and CancelAt = 1 then
			sleep 2
			HitKey(1, buttonID, buttonKey, UseHotKeys, CancelAt)
			CurrentWindow = WFndWndC("Microsoft Xbox SDK Update", "#32770", FINDWINDOWFLAGS, 15)
			if UseHotKeys then
				Play "%(y)"
			else
				WButtonSetFocus("#6")
				WButtonClick("#6", 10)
			end if
			goto installverify
		end if
	end if

	'
	' Setup Welcome Dialog
	'
	CurrentWindow = WFndWndC(strMicrosoft_Xbox_SDK_Setup, "#32770", MAY_EXIST or FW_NOERROR, 240)
	if CurrentWindow = 0 then
		hwnd = WFndWndC(strSevere, "#32770", EXIST, 15)
		if hwnd <> 0 then
			hwnd = WStaticFind(strIn_Use, 5)
			if hwnd <> 0 then WButtonClick("#2")
			FAIL "An Instance of VC was running during the install"
		end if
	end if
	hwnd = WStaticFind(strWelcome_to_Microsoft_Xbox_SDK_Setup, 5)
	if hwnd = 0 then
		FAIL "Setup should be at '"+strWelcome_to_Microsoft_Xbox_SDK_Setup+"' dialog"
	end if
	HitKey(2, buttonID, buttonKey, UseHotKeys, CancelAt)
	if (CancelAt = 2) then
		CancelInstall(UseHotKeys)
		goto installverify
	end if

'
' Need this since running updater on top of existing install skips these screens
'		
if NOT IsUpdate then
	'
	' Setup Notes
	'
	CurrentWindow = WFndWndC(strMicrosoft_Xbox_SDK_Setup, "#32770", EXIST, 30)
	hwnd = WStaticFind(strXbox_SDK_Setup_Notes, 5)
	if hwnd = 0 then
		FAIL "Setup should be at '"+strXbox_SDK_Setup_Notes+"' dialog"
	end if
	WButtonSetfocus("#9")
	HitKey(3, buttonID, buttonKey, UseHotKeys, CancelAt)
	if (CancelAt = 3) then
		CancelInstall(UseHotKeys)
		goto installverify
	end if

	'
	' Setup Destination Location
	'
	CurrentWindow = WFndWndC(strMicrosoft_Xbox_SDK_Setup, "#32770", EXIST, 30)
	hwnd = WStaticFind(strChoose_Destination_Location, 5)
	if hwnd = 0 then
		FAIL "Setup should be at '"+strChoose_Destination_Location+"' dialog"
	end if
	if InstallPath = "" then
		InstallPath = DefaultInstallTargetPath
	else
		WButtonSetFocus("#9")
		if UseHotKeys then
			Play "%(b)"
'			Play "%(r)"	' Japanese
		else
			WButtonClick("#196")
		end if
		hwnd = WStaticFind(strPlease_choose_the_installation_folder, 5)
		if hwnd = 0 then
			FAIL "Setup should be at '"+strPlease_choose_the_installation_folder+"' dialog"
		end if
		WEditSetText("#4", InstallPath, 30)
		WButtonSetFocus("#1")
		WButtonClick("#1")
		if exists(InstallPath, "+d") = false then
			sleep 1
			WButtonClick("#6")
		end if
	end if
	HitKey(4, buttonID, buttonKey, UseHotKeys, CancelAt)
	if (CancelAt = 4) then
		CancelInstall(UseHotKeys)
		goto installverify
	end if


	'
	' Setup Start Menu Folder
	'
	CurrentWindow = WFndWndC(strMicrosoft_Xbox_SDK_Setup, "#32770", EXIST, 30)
	hwnd = WStaticFind(strSelect_Program_Folder, 5)
	if hwnd = 0 then
		FAIL "Setup should be at '"+strSelect_Program_Folder+"' dialog"
	end if
	if StartMenuPath = "" then
		StartMenuPath = defaultStartMenuPath
	else
		WEditSetText("#301", StartMenuPath, 30)
	end if
	HitKey(5, buttonID, buttonKey, UseHotKeys, CancelAt)
	if (CancelAt = 5) then
		CancelInstall(UseHotKeys)
		goto installverify
	end if

	'
	' Start Copying Files Dialog
	'
	CurrentWindow = WFndWndC(strMicrosoft_Xbox_SDK_Setup, "#32770", EXIST, 30)
	hwnd = WStaticFind(strStart_Copying_Files, 5)
	if hwnd = 0 then
		FAIL "Setup should be at '"+strStart_Copying_Files+"' dialog"
	end if
	HitKey(6, buttonID, buttonKey, UseHotKeys, CancelAt)
	if (CancelAt = 6) then
		CancelInstall(UseHotKeys)
		goto installverify
	end if
end if

if not IsQFE then
	'
	' Setup Status dialog (cancel only)
	'
	CurrentWindow = WFndWndC(strMicrosoft_Xbox_SDK_Setup, "#32770", EXIST, 30)
	hwnd = WStaticFind(strSetup_Status, 5)
	if hwnd = 0 then
		FAIL "Setup should be at '"+strSetup_Status+"' dialog"
	end if
	if CancelAt = 7 then
		sleep 5
		HitKey(7, buttonID, buttonKey, UseHotKeys, CancelAt)
		CancelInstall(UseHotKeys)
		goto installverify
	end if
end if

	'
	' Setup Complete Dialog
	'
	CurrentWindow = WFndWndC(strMicrosoft_Xbox_SDK_Setup, "#32770", EXIST, 30)
	hwnd = WStaticFind(FinishString, 480)
	if hwnd = 0 then
		FAIL "Setup should be at '"+FinishString+"' dialog"
	end if
	if IsQFE and BuildNum > "3147" then
		WOptionSetFocus("#503")
		WOptionClick("#503", 10)
	end if
	HitKey(8, buttonID, buttonKey, UseHotKeys, CancelAt)

	'
	' Release notes
	'
	if RelNoteTitle = "" then
		if IsUpdate then
			RelNoteTitle = strXDK_Update_Instructions
		else
			RelNoteTitle = strXDK_Release_Notes
		end if
	end if
	CurrentWindow = WFndWnd(RelNoteTitle, MAY_EXIST or FW_NOERROR, 30)
	if CurrentWindow = 0 then
		if ReleaseNotes then
			LOG #1, "Setup should have launched release notes in browser"
		end if
	else
		Play "%{F4}"
'		Play "%(f)"
'		WMenuSelect("&Close")
	end if

	'
	' Verify Microsoft Xbox SDK Setup is shutdown
	'
installverify:
	CurrentWindow = WFndWndC(strMicrosoft_Xbox_SDK_Setup, "#32770", NO_EXIST, 30)
	Sleep 5
End Sub


'
' Function:    Uninstall()
'
' Parameters:  None
' Returns:     Nothing
'
' Description: Calls uninstall procedure as stored in the registry for the Xbox SDK Setup
'
' Note:        Only tested with InstallShield based setup Build 3407
'
Sub Uninstall()
	Dim uninstallApp As String

	' Used for storing the return values for WINAPI calls

	uninstallApp = NULL

	' Initilize values for use
	uninstallApp = SPACE$(1024)

	uninstallApp = trim$(RegistryGetValue("HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\"+UninstallKey, "UninstallString"))

	If uninstallApp <> "" Then
		'Start the uninstall program
		Run uninstallApp, NOWAIT
		'
		' Wait for initial setup screen
		'
		wFndWndC(strInstallShield_Wizard, "#32770", EXIST, 300)
		WButtonSetFocus("#1")
		Play "%(r)"	' select remove
		wButtonClick("#1")
		'
		' Confirm deletion
		'
		wFndWndC(strConfirm_File_Deletion, "#32770", EXIST, 30)
		wButtonClick("OK")
		'
		' Make sure dialog is gone
		'
		wFndWndC(strConfirm_File_Deletion, "#32770", NO_EXIST, 5)
		'
		' Dismiss Uninstall program
		'
		wFndWndC(strInstallShield_Wizard, "#32770", EXIST, 300)
		WStaticFind(strMaintenance_Complete, 420)
		WButtonSetFocus("#1")
		wButtonClick("#1")
		'
		' Make sure InstallShield is shutdown
		'
		wFndWndC(strInstallShield_Wizard, "#32770", NO_EXIST, 5)
	EndIf
	'
	' Wait about 10 seconds for InstallShield to properly clean up and shutdown
	'
	Sleep 10
End Sub


'
' Function:    ModifyInstall()
'
' Parameters:  None
' Returns:     Nothing
'
' Description: Calls setup procedure and attempts to modify installation (should always fail)
'
' Note:        Only tested with InstallShield based setup Build 3407
'
sub ModifyInstall()
	Dim uninstallApp As String

	' Used for storing the return values for WINAPI calls

	uninstallApp = NULL

	' Initilize values for use
	uninstallApp = SPACE$(1024)

	uninstallApp = trim$(RegistryGetValue("HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\"+UninstallKey, "UninstallString"))

	If uninstallApp <> "" Then

		'Start the uninstall program
		Run uninstallApp, NOWAIT
		'
		' Wait for initial setup screen
		'
		wFndWndC(strInstallShield_Wizard, "#32770", EXIST, 300)
		WButtonSetFocus("#1")
		Play "%(m)"	' select modify
		wButtonClick("#1")
		'
		' Confirm you cannot do this
		'
		wFndWndC(strWarning, "#32770", EXIST, 30)
		wButtonClick("#2")
		'
		' Make sure dialog is gone
		'
		wFndWndC(strWarning, "#32770", NO_EXIST, 5)
		'
		' Dismiss Uninstall program
		'
		wFndWndC(strInstallShield_Wizard, "#32770", EXIST, 30)
		wButtonClick("#9")
		'
		' Dismiss program
		'
		wFndWndC(strExit_Setup, "#32770", EXIST, 300)
		wButtonClick("#6")
		'
		' Make sure InstallShield is shutdown
		'
		wFndWndC(strInstallShield_Wizard, "#32770", NO_EXIST, 5)
	EndIf
	'
	' Wait about 10 seconds for InstallShield to properly clean up and shutdown
	'
	Sleep 10
end sub

'
' Function:    RepairInstall()
'
' Parameters:  None
' Returns:     Nothing
'
' Description: Calls setup procedure and attempts to repair installation
'
' Note:        Only tested with InstallShield based setup Build 3407
'
sub RepairInstall()
	Dim uninstallApp As String
	Dim hwnd as long

	uninstallApp = NULL

	' Initilize values for use
	uninstallApp = SPACE$(1024)

	'See if the app has an UninstallString in the registry.
	'If it does, assume the app is installed and uninstall it.
	uninstallApp = trim$(RegistryGetValue("HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\"+UninstallKey, "UninstallString"))

	If uninstallApp <> "" Then

		'Start the uninstall program
		Run uninstallApp, NOWAIT
		'
		' Wait for initial setup screen
		'
		wFndWndC(strInstallShield_Wizard, "#32770", EXIST, 300)
		WButtonSetFocus("#1")
		Play "%(e)"	' select Repair
		wButtonClick("#1")
		'
		' Look for Setup Status and then Finish
		'
		hwnd = wFndWndC(strSetup_Needs_The_Next_Disk, "#32770", MAY_EXIST, 3)
		if hwnd <> 0 then
			wButtonClick("#9")
			'
			' Hit cancel
			'
'			wFndWndC(strInstallShield_Wizard, "#32770", EXIST, 30)
'			WButtonClick("#9")
			CurrentWindow = WFndWndC(strExit_Setup, "#32770", FINDWINDOWFLAGS, 15)
			WButtonSetFocus("#6")
			WButtonClick("#6", 10)
		else
			wFndWndC(strInstallShield_Wizard, "#32770", EXIST, 30)
			hwnd = WStaticFind(strSetup_Status, 5)
			'
			' Dismiss Uninstall program
			'
			wFndWndC(strInstallShield_Wizard, "#32770", EXIST, 30)
			hwnd = WStaticFind(strMaintenance_Complete, 420)
			WButtonSetFocus("#1")
			wButtonClick("#1")
		end if

		'
		' Make sure InstallShield is shutdown
		'
		wFndWndC(strInstallShield_Wizard, "#32770", NO_EXIST, 5)
	EndIf
	'
	' Wait about 10 seconds for InstallShield to properly clean up and shutdown
	'
	Sleep 10
end sub


'
' Function:    KillDir()
'
' Parameters:  strDir$     - Directory to remove
' Returns:     Nothing
'
' Description: Deletes directory and all contents (including sub directories)
'
' Note:        Only tested with InstallShield based setup Build 3407
'
Sub KillDir(strDir$)
	If Not Exists(strDir, "+d") Then Exit Sub 
	run "cmd /a /c rd /s /q """+strDir+"""",, SW_HIDE
End Sub 


'
' Function:    CopyDir()
'
' Parameters:  srcDir$    - Directory to copy from
'              destDir$   - Directory to copy to
' Returns:     Nothing
'
' Description: copies directory and all contents (including sub directories)
'
' Note:        Only tested with InstallShield based setup Build 3407
'
sub CopyDir(srcDir$, destDir$)
	run "cmd /a /c xcopy /e /h /r /k /y /z """+srcDir+"\*.*"" "+destDir
end sub


'
' Function:    VerifyFile()
'
' Parameters:  verifyType%      - VerifyFile type
'                   1 = Reference List
'                   2 = Found in Installation
'                   3 = In Reference but not Installed
'                   4 = Installed, but not in Reference
'                   5 = Mismatched Timestamps/versions
'              FileArray$()     - Returns all the items in the File ListView
'              RegArray$()      - Returns all the items in the Registry ListView
'              RefList$=""      - Alternate Reference File. Default is "", which uses the apps default value
'              SDKPath$=""      - Alternate SDK Path. Default is "", which uses the apps default value
'              VSCommonPath$="" - Alternate VStudio Common Path. Default is "", which uses the apps default value
' Returns:     Nothing
'
' Description: Calls File Verification tool and returns results found in ListViews
'
' Note:        Only tested with InstallShield based setup Build 3407
'
sub VerifyFile(verifyType%=3, FileArray$(), RegArray$(), RefList$="", SDKPath$="", VSCommonPath$="")
	dim FileListView$, RegListView$
	dim actFCol$, actRCol$
	dim count%, item%
	dim hwnd as long

	FileListView = "#1002"
	RegListView  = "#1003"

	'
	' Check to see if tool is available
	'
	if not exists("\\xdk\XDKTest\Tools\File Verification\xdkfiles.exe") then
		FAIL "Unable to find File Verification tool at: \\xdk\XDKTest\Tools\File Verification\xdkfiles.exe"
	end if
	'
	' Kill off other instances of tool first
	'
	hwnd = WFndWndC("XBox SDK Files Checker", "#32770", MAY_EXIST or FW_NOERROR, 5)
	while hwnd <> 0
		WSetActWnd(hwnd)
		WButtonSetFocus("#1011", 30)
		Play "%{f4}"
		hwnd = WFndWndC("XBox SDK Files Checker", "#32770", MAY_EXIST or FW_NOERROR, 5)
	wend

	'
	' Call Tool and set it to active
	'
	run "\\xdk\XDKTest\Tools\File Verification\xdkfiles.exe", NOWAIT
	hwnd = WFndWndC("XBox SDK Files Checker", "#32770", FINDWINDOWFLAGS, 30)

	'
	' Set Reference List path if one was passed and it exists
	' 
	WSetActWnd(hwnd)
	if trim$(RefList) <> "" then
		if not exists(RefList) then
			FAIL "Invalid Reference List passed to VerifyFile()"
			exit sub
		end if
		WEditSetFocus("#1009")
		WEditSetText("#1009", RefList, 30)
	end if
	'
	' Set SDK Installation path if one was passed and it exists
	' 
	if trim$(SDKPath) <> "" then
		if not exists(SDKPath, "+d") then
			FAIL "Invalid SDK Installation Path passed to VerifyFile()"
			exit sub
		end if
		WEditSetFocus("#1012")
		WEditSetText("#1012", SDKPath, 30)
	end if
	'
	' Set VStudio Common path if one was passed and it exists
	' 
	if trim$(VSCommonPath) <> "" then
		if not exists(VSCommonPath, "+d") then
			FAIL "Invalid VC Common Path passed to VerifyFile()"
			exit sub
		end if
		WEditSetFocus("#1016")
		WEditSetText("#1016", VSCommonPath, 30)
	end if

	'
	' Select Verify Type to execute
	'
	WSetActWnd(hwnd)
	WButtonSetFocus("#1011")
	select case verifyType
		case 1	' Reference List
			WOptionClick("#1018", 30)
		case 2	' Found in Installation
			WOptionClick("#1014", 30)
		case 3	' In Reference but not Installed
			WOptionClick("#1013", 30)
		case 4	' Installed, but not in Reference
			WOptionClick("#1015", 30)
		case 5	' Mismatched Timestamps/versions
			WOptionClick("#1021", 30)
		case else
			FAIL "Invalid Verify Type passed to VerifyFile()"
	end select
	'
	' Execute File Verify and wait 30 seconds for completion
	'
	WButtonClick("#1011", 30)	' Check Installation
	sleep 5

	'
	' Set columns to grab depending on type
	'
	if verifyType = 5 then
		actFCol = "@5"
		actRCol = "@3"
	else
		actFCol = "@3"
		actRCol = "@2"
	end if

	'
	' Set Active window to FileVerify tool
	'
	WSetActWnd(hwnd)
	'
	' Grab items from File ListView
	'
	count = WViewCount(FileListView)
	Redim FileArray$(count, 3)
	For item = 0 to count-1
		FileArray(item, 0) = ViewItemText(FileListView,_ord(item+1), "@1")
		FileArray(item, 2) = ViewItemText(FileListView,_ord(item+1), actFCol)
		if verifyType = 5 then
			if FileArray(item, 2) = "" then
				FileArray(item, 1) = ViewItemText(FileListView,_ord(item+1), "@2")
				FileArray(item, 2) = ViewItemText(FileListView,_ord(item+1), "@3")
			else
				FileArray(item, 1) = ViewItemText(FileListView,_ord(item+1), "@4")
			end if
		end if
	Next item
	'
	' Set Active window to FileVerify tool
	'
	WSetActWnd(hwnd)
	'
	' Grab items from Registry ListView
	'
	count = WViewCount(RegListView)
	Redim RegArray$(count, 3)
	For item = 0 to count-1
		RegArray(item, 0) = ViewItemText(RegListView,_ord(item+1), "@1")
		RegArray(item, 2) = ViewItemText(RegListView,_ord(item+1), actRCol)
		if verifyType = 5 then
			RegArray(item, 1) = ViewItemText(RegListView,_ord(item+1), "@2")
		end if
	Next item

	'
	' Shutdown FileVer Tool
	'
	WSetActWnd(hwnd)
	WButtonSetFocus("#1011", 30)
	Play "%{f4}"
	'
	' Make sure it's gone
	'
	CurrentWindow = WFndWndC("XBox SDK Files Checker", "#32770", NO_EXIST, 30)
end sub


'
' Assumes fresh install of samples
' Assumes no DSW file exists
'
function BuildProject(project$, rebuildAll%=false) as integer
	Dim VStudio as variant, prop as variant, doc as variant
	Dim projCol as variant, proj as variant
	Dim numProjects as variant, numConfigs as variant, i as long, j as long
	Dim configCol as variant, config as variant
	Dim projType as variant, numErrors as long
	Dim projName as string
	Dim pass%

	pass = true

	'
	' Make sure project exists
	'
	if not exists(project) then
		LOG #10, "Project file does not exist"
		BuildProject = false
		exit function
	end if
	'
	' Get automation object for Visual Studio
	'
	VStudio = OleCreateObject("MSDev.Application")
	if TypeID(VStudio) = 0 then
		LOG #10, "Unable to retrieve automation object for Visual Studio"
	end if
	'
	' Make Visual Studio visible
	'
	prop = OleSetProperty(VStudio, "Visible", true)
	
	'
	' Get document object for Visual Studio
	'
	doc = OleGetProperty(VStudio, "Documents")
	if TypeID(doc) = 0 then
		LOG #10, "Unable to retrieve document object for Visual Studio"
	end if
	'
	' Close All documents and open the selected project
	'
	dim ret as variant
	CurrentWindow = Wfndwnd("Visual C++", FW_PART)
	OleDispatch(doc, "CloseAll")
	Play "%(f)k"
	Play "^(o)"
	CurrentWindow = Wfndwnd("Open Workspace")
	WEditSetText("#1152", project)
	WButtonClick("#1")

	projCol = OleGetProperty(VStudio, "Projects")
	numProjects = OleGetProperty(projCol, "Count")
	For i = 1 To numProjects
		proj = OleDispatch(projCol, "Item", i)
		projName = OleGetProperty(proj, "Name")
		projType = OleGetProperty(proj, "Type")
		If projType = "Build" Then
			configCol = OleGetProperty(proj, "Configurations")
			numConfigs = OleGetProperty(configCol, "Count")
			SetRemotePath(ProjName)
			For j = 1 to numConfigs
				CurrentWindow = Wfndwnd("Visual C++", FW_PART)
				Play "%(b)"
				sleep 1
				Play "o"
				CurrentWindow = Wfndwnd("Set Active Project Configuration", FW_PART,15)
				WListItemClk("#16087", "@"+trim(str(j)))
				WButtonClick("#1")

				config = OleDispatch(configCol, "Item", j)
				
				If rebuildAll then
					CurrentWindow = Wfndwnd("Visual C++", FW_PART)
					' OleDispatch(VStudio, "RebuildAll", config)
'					WMenuSelect("&Build\&Rebuild All")
					Play "%(b)"
					sleep 1
					Play "r"
'					WMenuSelect("&Rebuild All")
				Else
					' OleDispatch(VStudio, "Build", config)
					Play "%(b)"
					sleep 1
					Play "b"
'					WMenuSelect("&Build\&Build")
				End If
				Sleep 30

				numErrors = OleGetProperty(VStudio, "Errors")
				If numErrors > 0 Then
					LOG #10, trim$(str(numErrors))+" Build Errors on: "+OleGetProperty(config, "Name")
					pass = false
				End if
				numErrors = OleGetProperty(VStudio, "Warnings")
				if (numErrors > 0) Then
					LOG #10, trim$(str(numErrors))+" Build Warnings on: "+OleGetProperty(config, "Name")
					pass = false
				End If
				OleReleaseObject(config)
			Next
			OleReleaseObject(configCol)
		End If
		OleReleaseObject(proj)
	next i

	'
	' Clean up
	'
	OleDispatch(VStudio, "Quit")
	OleReleaseObject(ProjCol)
	OleReleaseObject(doc)
	OleReleaseObject(VStudio)
	BuildProject = pass
end sub

sub SetRemotePath(projName$)
	Dim index%, count%, i%
	Play "%{f7}"
	sleep 2
	CurrentWindow = WFndWnd("Project Settings", , 30)
	Play "^{Tab}"
	count = WComboCount("#16434")
	for i = 1 to count
		if trim$(lcase(ComboItemText("#16434", (i)))) <> "all configurations" then
			WComboItemClk("#16434", "@"+trim$(str$(i)))
			WEditSetFocus("#16125")
			WEditSetText("#16125", "e:\samples\"+trim$(projName)+"\"+trim$(projName)+trim$(str$(i))+".xbe")
		end if
	next i
	WButtonClick("#1")
	sleep 2
end sub


function ValidateFilesOnUninstall as integer
	Dim FileArray$(0,3), RegArray$(0,3)
	Dim item%, pass%
	Dim xdkpath$

	pass = true

	VerifyFile(4, FileArray, RegArray)
	'
	' If upper bound > 0 then there were files returned
	'
	if ubound(FileArray, 1) <> 0 then
		pass = false
		LOG #10, "FAIL: The following "+trim$(str$(ubound(FileArray, 1)))+" files are still installed"
		for item = lbound(FileArray, 1) to ubound(FileArray, 1)-1
			LOG #10, "   "+FileArray(item, 0)
		next item
	end if
	'
	' If failed, the flag error
	'
	ValidateFilesOnUninstall = pass
end function
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4229\CarGeometry.h ===
#ifndef __CARGEOMETRY_H
#define __CARGEOMETRY_H

#ifdef EXPORTER
#include <stdio.h>
#endif

#ifndef __VECTOR_H
#include "vector.h"
#endif

#ifndef __FLOATCOLOR_H
#include "FloatColor.h"
#endif
#ifndef __CARWHEELNUMBERS_H
#include "CarWheelNumbers.h"
#endif
#ifndef __FMATERIALDATABASE_H
#include "FMaterialDatabase.h"
#endif

struct FShape;
#ifdef ENABLE_FDEFORMABLESHAPE
struct FDeformableShape;
#endif
struct FJoint;

#define CAR_LOD_LEVELS 4

// storage space: 2mb for now max size
#define CAR_MAX_SIZE (1024 * 256)

// storage space: 2mb for now max size
#define CARGFX_MAX_SIZE (1024*1024 + 512*1024)

// actual size: allows for at least 5m x 3m cars
#define CAR_MAX_RADIUS 3.0f

struct CarWheelGeometry
{
	V3               m_position;              // wheel position relative to origin of car, should be at (?,?,radius)
	FShape          *m_shape[CAR_LOD_LEVELS]; // model data, front two point to same, as do back two
	FShape          *m_caliperShape;          // model data, four different ones

	void             m_Relocate(void *base, void *gfxBase);
};

// used for setting up lens flares
struct CarLight
{
	FloatColor       m_color;                 // color of light
	V3               m_brightness;            // brightness of light

	V3               m_position;              // position of point of light cone
	V3               m_direction;             // direction of light cone
	float            m_cone;                  // visibility of light flare

	void             m_Relocate(void *base);
};

struct CarLightGroup
{
	FMaterial      **m_material;              // material to modify when the group changes
	CarLight        *m_light;                 // info per light
	int              m_lights;                // number of lights

#ifdef GAME
	void             m_Relocate(void *base);
#endif
};

struct CarExhaustPipe
{
	V3               m_position;              // position of end of pipe relative to car origin
	V3               m_direction;             // direction pipe faces (some pipes are tilted)

	void             m_Relocate(void *base);
};



#define CAR_COOKIE(n) char n[8] = { 'C','A','R', 13,10,26, 0,0 };

struct CarGeometry
{
	// Car position and orientation:
	//
	// The car's wheels are sitting on the X/Y plane.
	// The car is centered over the X/Y origin.  This is used for camera targeting.
	// Positive X points out through the nose.
	// Positive Y points out through the left door.
	// Positive Z points out through the roof.
	//
	//                  Z
	//                  |
	//                  |        
	//                  |        Y
	//       \___   ____|___   /
	//       _ |___/    :   \ /
	//      |           :    `-----.
	//      |   / \     :       __  \
	//      |__|   |___________/  \__|
	//          \_/     |/_____\__/______ X
	//
	// All positions herein are offsets from the above origin.
	
	char                m_cookie[8];             // CAR,13,10,26,0,0

	int                 m_headerSize;            // size of this structure to check for old files
	int                 m_version;               // make sure we don't load incompatible cars
	#define             CAR_VERSION 3

	V3                  m_head;                  // approximate location of player's head, probably temporary

	V3                  m_seat;                  // where the player model's butt sits
	V3                  m_seatNormal;            // angle of the seat the player model's butt is on
	V3                  m_back;                  // where the player model's back rests
	V3                  m_backNormal;            // angle of the seat back the player model's back is against
	V3                  m_pedal;                 // approximate location of accelerator pedal for player model

	V3                  m_centerOfGravity;       // where the center of mass/gravity is versus the origin of the car

	FMaterialDatabase   m_materials;             // all materials in one place

	CarLightGroup       m_drivingLights;         // on if at least driving lights are on, includes passive tail lights
	CarLightGroup       m_headLights;            // on if headlights are on
	CarLightGroup       m_brakeLights;           // on if brakes are on
	CarLightGroup       m_combinedLights;        // on if brakes are on, else halfway if headlights are on

	CarExhaustPipe     *m_exhaustPipe;           // if we do exhaust
	int                 m_exhaustPipes;          // if we do exhaust

	CarWheelGeometry    m_wheel[CAR_WHEELS];     // each wheel's info and shape
#ifdef ENABLE_FDEFORMABLESHAPE
	FDeformableShape   *m_body;                  // the body's shape, origin is geographical center of car but ON THE GROUND
	FDeformableShape   *m_frontHood;             // the body's shape, origin is geographical center of car but ON THE GROUND
	FDeformableShape   *m_frontEngine;           // the body's shape, origin is geographical center of car but ON THE GROUND
	FDeformableShape   *m_rearHood;              // the body's shape, origin is geographical center of car but ON THE GROUND
	FDeformableShape   *m_rearEngine;            // the body's shape, origin is geographical center of car but ON THE GROUND
	FDeformableShape   *m_wing;                  // the body's shape, origin is geographical center of car but ON THE GROUND
#else
	FShape             *m_body[CAR_LOD_LEVELS];  // the body's shape at various LOD's, origin is geographical center of car but ON THE GROUND
	FShape             *m_wing[CAR_LOD_LEVELS];  // the wing's shape, origin is geographical center of car but ON THE GROUND
#endif
	FShape             *m_cockpit[CAR_LOD_LEVELS];// the cockpit, same model space as body

	FJoint             *m_steeringWheel;         // ui steeringWheel;
	FShape             *m_uiCockpit;             // ui cockpit, same model space as body
	FJoint             *m_uiSteeringWheel;       // ui steeringWheel;

//	FAnimation         *m_flipUpAnimation;       // flip-up headlights, first keyframe down, last keyframe up, unlit until up
//	FHierarchy         *m_flipUpLights;          // draw for cars with flip-up headlights (these are NULL if not)

	void                m_Relocate(void *base, void *gfxBase);

#ifdef EXPORTER
	void                m_Init(void);
	void                m_Write(FILE *fp);
#endif
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4229\Car.h ===
#ifndef __CAR_H
#define __CAR_H

// max number of laps and cars is in here
#ifndef __GAME_H
#include "game.h"
#endif

#ifndef __CARWHEEL_H
#include "CarWheel.h"
#endif
#ifndef __CARWHEELNUMBERS_H
#include "CarWheelNumbers.h"
#endif

struct PhysicsCar;
struct AI;

struct CarItem;

struct CarGeometry;
struct CameraPath;
struct IDirect3DCubeTexture8;

struct EngineSounds;
struct GearSounds;

struct GTCarLodLevel
{
	float size;
	u16 level;
	u16 flags;
	#define GT_CAR_LOD_BODY_1         0x0001
	#define GT_CAR_LOD_BODY_2         0x0002
	#define GT_CAR_LOD_BODY_3         0x0004
	#define GT_CAR_LOD_NO_MIRRORS     0x0008
	#define GT_CAR_LOD_NO_WING        0x0010
	#define GT_CAR_LOD_NO_WHEELS      0x0020
	#define GT_CAR_LOD_NO_ENV_MAP     0x0040
	#define GT_CAR_LOD_NO_SHADOW      0x0080
	#define GT_CAR_LOD_REDUCED_SHADOW 0x0100
	#define GT_CAR_LOD_NO_CAR         0x0200
	#define GT_CAR_LOD_NO_CAR_IN_RVM  0x0400
};

extern GTCarLodLevel g_carLodLevel[];



struct SkidMarkBlock;
struct Car;
struct TrackGate;
struct ParticleSystem;
struct Input;
struct GTTrackEnvironmentMap;

struct CarLapTracker
{
	int   m_lap;
	int   m_lapLast;
	int   m_rankLap;
	int   m_rank;
	float m_raceDistance;
	float m_raceDistanceDelta;

	float m_raceDistanceVsP1;
	int   m_rankVsP1;
	
	CarLapTracker();

	TrackGate *m_prevGate;
	TrackGate *m_nextGate;
	TrackGate *m_trueNextGate;
};

struct CarTimes
{
	float m_lap[MAX_RACE_LAPS];
	float m_bestLap;
	float m_race;
	int   m_rankLap;
};

struct Car
{
	CarGeometry *m_geometry;        // point me at the actual graphics headers
	void        *m_uma;             // point me at the actual graphics objects

	CarItem     *m_item;     // whence I came

	// chad's engine sounds and stuff
	EngineSounds       *m_sound;		// Engine sounds

	// hack to allow switching cars during game for Gabe
	int m_loadNextFrame;
	int m_loadPalNextFrame;
	
	// transform into and out of world coords
	M4 m_transform;
//	M4 m_transformInverse;

	// transform of car at the start of this frame
	M4 m_lastTransform;

	// these are in the same order as the model.  use WHEEL_LF,RF,LR,RR
	CarWheel m_wheel[CAR_WHEELS];
	void m_LeaveSkidMarks(void);
	
	// extents of car in model space (multiplied by GT_CAR_SCALE_F)
	V3 m_min,m_max;
//	V3 minSort,maxSort;

	// where camera's target is, relative to center of mass
	V3      m_target;
	
	int     m_index;                         // player number - 1, basically

	int     m_gridPosition;                  // position in starting grid
	void    m_SetGridPosition(int p);

	// don't touch, this is for predicting the need to check visibility
	// on the brake light lens flares.
	int     m_brakesSoon;                    // brake button pressed in upcoming frame?
	
	int m_brakes;
//	int m_brakeGlow;
	int m_reverse;
//	void m_DoBrakeGlow(void);

//	PhysicsPolygonTracker m_polygon;
	
	// velocities per second
	float   m_speed;         // world space
	float   m_speedXY;       // ignore vertical change, used in skids/smoke
	float   m_topSpeed;      // record for this race

	// note that avgSpeed can be calculated at end of race:
	//   track.trackGfx->paths.oneLapDistance*race.laps / car->raceTime
	
	V3      m_velocity;      // world space
	V3      m_velocityLocal; // car space
	
#if 0
	// where we are
	Path   *m_path;          // path we're on
	int     m_segment;       // segment of path we're on
	float   m_segDist;       // dist along segment from start
	V3      m_segPos;        // actual world position of closest point on path
	bool    m_FindClosestPath(void);
#endif
	
	// transform of the car's shadow on the ground,
 	// obviously not necessarily the same as the car's
	// or the ground's.
	// DO NOT USE THIS FOR ANYTHING THAT CAN AFFECT
	// THE PHYSICS.  THIS IS FOR VISUALS ONLY AND IS
	// *NOT* SAVED IN REPLAYS.
	M4    m_shadowTransform;
	
	// helps decide when to draw car
	float m_distFromCameraForward;
	float m_distFromCameraSide;
	float m_distFromCameraUp;
	float m_distFromCamera;
	
	// vertices defining the basic rectangular shadow
	// shape and the custom outline.
	
//	GTPolyset m_shadowInstancePolyset;
//	GTInstance m_shadowInstance;
//	
//	zVtxSrc m_shadowVtx[8];
	
	// computed before drawing each viewport, used for lod
	// and fading out environment maps
	float m_sizeOnScreen;
	int m_lod;
	
	u8  m_lighting[3];
	int m_carBaseBrightness;
	
	u32 m_unaffectedLightColor;
	// don't touch this.
	u32 m_unaffectedLightColorLast;

	// tracks the position of lens flares on head/tail lights.
	// only calculated once per frame and only if the car is drawn.
	V4 lightFlareWorldPos;
	
	// was the car drawn in any viewport this frame?
	int m_drawn;

	// the following variables are used by the sound driver
//	s16	sound_effect[2];		// upto 2 channels assigned per car, these are the channel ids
//	float	rpmLast;					// last calculated RPM or -1 if not calculated last frame
//	short	gearLast;				// last gear the car was in -1 if initial pass
//	short	wheelLast;				// last wheel that generated a skid noise
//	s16	lastSfxEnvId;			// last env type that generates a sfx encountered
//	u16	lastSfxEnvVol;			// last env volume (this is faded)
//	u32	lastSfxEnvFreq;		// last frequency for sfx
	// end of the sound effects variables
	
	void m_BrakeAtStartLine(void);
	void m_DoPhysics(float dt);
	void m_MakeSparks(V3 norm, V3 point, float size);
	struct CarSpark
	{
		V3    m_norm;
		V3    m_point;
		float m_size;
	};
	#define CAR_SPARKS 4
	CarSpark m_spark[CAR_SPARKS];
	int      m_sparkIndex;

	void m_GateAndLapInit(void);
	void m_GateAndLapCheck(void);
	CarLapTracker m_pos;
	bool m_Finished(void);
	void m_ElapseTime(void);
	CarTimes      m_time;

	// am I connected via an input to a human?
	bool m_human;
	void m_SetHuman(bool h)     { m_human = h; }
	bool m_Human(void)          { return(m_human); }

	AI   *m_ai;
	
	int  m_Load(CarItem *car);
	int  m_Load(int c);
	Car();
	void m_Init(void);
	void m_InitOnce(void);
	void m_MoveToStartLine(void);
	void m_InvalidateLastPosition(void);
	
	void m_SetBrakes(register int b);
	void m_SetReverse(register int r);
	
	void m_StickToGround(void);
	void m_CalculateVelocities(void);
	void m_CalculateWheelPositions(void);
	void m_CalculateWheelAngles(void);
	void m_CalculateRaceDistance(void);
	void m_CheckForLapOrFinishMessage(void);
	void m_AdjustRank(void);
	void m_InitRank(void);

	void m_FrameInit(void);             // call before game frame

	void m_FrameDrawInit(void);         // call before draw frame
	void m_DrawInit(void);              // call before each camera/vp in draw frame

	void m_MakeShadowPolysets(void);
	
	// draws it where it is, right now, with loaded matrices.
	void m_Draw(bool interiorView = false);
	void m_DoLensFlare(void);

	// draws it where it is, right now, but scales it correctly
	// first so you don't need to know hot to do it.  calls
	// Draw() with given level, brightness, and shininess.
	// note that for x in r,g,b,a, lightColor.x+shineColor.x <= 255.
	void m_ExternalDraw(int level,u32 lightColor,u32 shineColor);

	int  m_opacity;
	int  m_particleJitterIndex1;
	int  m_particleJitterIndex2;
	int  m_particleJitterIndex3;
	int  m_particleJitterIndex4;
	
	ParticleSystem *m_smoke;
	ParticleSystem *m_sparks;
	GTTrackEnvironmentMap *m_envMap;

	void                   m_ReleaseDeviceObjects(void);

	// physics
	unsigned long m_physicsRandomSeed;  // ensures ghost mode works right
	PhysicsCar   *m_physicsCar;
	void          m_InitPhysics(void);
};

struct CarWheelSaveState
{
	// we copy the fwd,side,up and wheelAngle of the car to make a matrix.
	// note that we don't actually do this yet, we remake the entire matrix
	// every frame.  but we will.
	V3   m_position;
	int  m_skidding;
	void m_CopyOut(CarWheel *wheel);
	void m_CopyIn (CarWheel *wheel);
};

struct CarSaveState
{
#if 0
	Matrix4 transform;
	Matrix4 lastTransform;
	int brakes;
	int reverse;
//	GTPhysicsPolygonTracker polygon;
	float wheelAngle;
	float steeringAngle;
	GTCarWheelSaveState wheel[4];

	//---------------------------------------------------------
	// starting here, I don't think we really need this.
	
	// velocities per frame
	float   frameSpeed;         // world space
	Vector3 frameVelocity;      // world space
	Vector3 frameVelocityLocal; // car space
	float   frameWheelAngularVelocity;  // how fast are wheels turning?

	// velocities per second
	float   speed;         // world space
	Vector3 velocity;      // world space
	Vector3 velocityLocal; // car space
	float   wheelAngularVelocity;  // how fast are wheels turning?

	// where we are
	GTPath *path;
	int     segment;
	float   segDist;
	Vector3 segPos;

	// end I really don't think we need this
	//---------------------------------------------------------

	GTCarLapTracker pos;
	GTCarTimes      time;
	GTCarAI         ai;
	AIPath          ai_path;
	
	robCar robCar;
#else
	Car   m_carSaved;
#endif
	void  m_CopyOut(Car *car);
	void  m_CopyIn(Car *car);
};

extern Car g_car[MAX_CAR_SLOTS];
extern int g_cars;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4229\floattype.h ===
#ifndef __FLOATTYPE_H
#define __FLOATTYPE_H

#define FLOATTYPE_BITS 32
typedef float floatType;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4229\fault.h ===
#ifndef __FAULT_H
#define __FAULT_H

void PrintCustomFault(const char *s, ...);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4229\Fade.h ===
#ifndef __FADE_H
#define __FADE_H

struct Fade
{
	int         m_fade;
	int         m_rate;
	int         m_r;
	int         m_g;
	int         m_b;

	void        m_Draw(void);
	void        m_Draw(int x,int y,int w,int h);

	inline bool m_FadedOut(void) { return(m_fade==255); }
	inline bool m_FadedIn (void) { return(m_fade==0); }
	inline void m_SetFade(int r) { m_fade = r; }
	inline void m_SetFadedOut(void) { m_fade = 255; }
	inline void m_SetFadedIn (void) { m_fade = 0; }
	inline void m_SetRate(int r) { m_rate = r; }
	inline void m_SetColor(int r,int g,int b) { m_r=r; m_g=g; m_b=b; }

	void        m_OneFrameUpkeep(void);
};

#define STANDARD_FADE_RATE 12

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4229\FloatColor.h ===
#ifndef __FLOATCOLOR_H
#define __FLOATCOLOR_H

struct FloatColor
{
	float            m_r;                       // red
	float            m_g;                       // green
	float            m_b;                       // blue
	float            m_a;                       // alpha
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4229\FMaterialDatabase.h ===
#ifndef __FMATERIALDATABASE_H
#define __FMATERIALDATABASE_H

#ifdef EXPORTER
#include <stdio.h>
#endif

struct FMaterial;
struct FTextureDatabase;

struct FMaterialDatabase
{
	FTextureDatabase  *m_textures;              // all textures in one place

	int                m_materials;             // number of materials
	FMaterial         *m_material;              // actual materials

	void               m_Relocate(void *base, void *baseGfx);

#ifdef EXPORTER
	bool               m_Create(void);
	void               m_WriteIndirectData(FILE *fp, FILE *fpGfx, FMaterialDatabase *header);
	FMaterialDatabase *m_WriteHeader(FILE *fp, FMaterialDatabase *header);
	void               m_CleanHeader(void);

	FMaterialDatabase();
	~FMaterialDatabase();
#endif
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4229\Game.h ===
#ifndef __GAME_H
#define __GAME_H

#undef X
#undef Y
#undef Z
#undef W
#define X m_X
#define Y m_Y
#define Z m_Z
#define W m_W
#ifdef CAR_CONSTRUCTOR
#include <windows.h>
#include <winbase.h>
#include <stdarg.h>
#include <stdio.h>
#include <d3d8.h>
#include <XboxTypes.h>
#include <Xbox3D8.h>
#else
#include <xtl.h>
#include <stdio.h>
#endif
#undef X
#undef Y
#undef Z
#undef W
#define X 0
#define Y 1
#define Z 2
#define W 3

#ifdef CAR_CONSTRUCTOR
#define D3DXBOX(n) XBOX3D##n
#define IDirect3DXbox(n) IXbox3D##n
#else
#define D3DXBOX(n) D3D##n
#define IDirect3DXbox(n) IDirect3D##n
#endif

void PrintCustomFault(const char *s,...);
#undef printf
#define printf myprintf
//int myprintf(const char *, ...);
void myprintf(const char *fmt,...);

extern float g_deltaTime,g_oneOverDeltaTime;
extern float g_displayFrequency;


// this is globally useful... determine the number of entries in
// a static array (ie. "short zot[] = { ... };").
// note this does NOT work on pointers, only actual arrays!
#define entries(array) (sizeof(array)-sizeof((array)[0]))


#define MAX_ONSCREEN_PLAYERS 4
#define MAX_CAR_SLOTS 8
#define MAX_RACE_LAPS 30

#ifndef __TYPES_H
#include "types.h"
#endif

#ifndef __FADE_H
#include "fade.h"
#endif

struct Game
{
	static Fade   m_fade;
	static bool   m_exiting;
	static u32    m_frame;
	static bool   m_allHumanCarsFinished;
	static int    m_over;
	
	static void (*m_nextElapseFunc)(void);
	static void   m_SetNextElapseFunc(void (*l)(void));
	
	static void   m_StartExit(void);
//	static void   m_DrawCallback(void)
	
	static void   m_Init(void);
	
	static void   m_DoFrame(bool timeHasElapsed);
	static void   m_DoAI(void);
	
	static void   m_Draw(void);
	static void   m_Elapse(void);
	
	static bool   m_ReadoutToggleOK(void);
	static bool   m_CameraToggleOK(void);
	static bool   m_SpecialInputHandling(void);
	static bool   m_PrematureExitPossible(void);
	static bool   m_IntroTimedOut(void);

	static void   m_CheckGeneralDebugInput(void);
	static void   m_CheckPrematureExit(void);

	static void   m_RunMaterialAnims(float dt);
	static void   m_RunSkinAnims(float dt);
	static void   m_RunPaletteCycles(float dt);
	static void   m_ApplyFade(void);
	static void   m_MultiFrameUpkeep(float dt);

	static void   m_OneFrameUpkeep(void);
	static void   m_ZeroFramesUpkeep(void);

	static bool   m_AllHumanCarsFinished(void);
	static void   m_CheckExiting(void);
	static void   m_GetResults(void);

	static void   m_HideInputIfExiting(void);

#if !FINAL_ROM
	static void   m_CarAndTrackSwitcher(void);
#else
	static inline void m_CarAndTrackSwitcher(void) {}
#endif
};

// temporary hack
struct Interface : public Game
{
};

struct Car;
extern Car *g_inputCar[MAX_ONSCREEN_PLAYERS];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4229\output.cxx ===
#include "names.h"
#include "types.h"
#include "game.h"

void myprintf(const char *fmt, ...)
{
	static char buf[1024];
	va_list arg;
	va_start(arg, fmt);
	vsprintf(buf, fmt, arg);
	va_end(arg);
	OutputDebugString(buf);
}

void PrintCustomFault(const char *fmt, ...)
{
	static char buf[1024];
	va_list arg;
	va_start(arg, fmt);
	vsprintf(buf, fmt, arg);
	va_end(arg);
	OutputDebugString(buf);
	for(;;)
	{
		Sleep(1000);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4229\moremath.cxx ===
#ifdef GAME
#include "names.h"
#endif

#ifndef GAME
#include <stdio.h>
#include <stdlib.h>
#include <d3d8.h>
#else
#include "fault.h"
#include <xtl.h>
#endif
#include <string.h>


#include "floattype.h"
#include "moremath.h"

// please note that this file is shared with mkdata, thus the use
// of floatType vs. float or double

typedef floatType floatType2[2];
typedef floatType floatType3[3];
typedef floatType floatType4[4];

union FloatAndULong
{
	floatType f;
#if FLOATTYPE_BITS==32
	unsigned long      l;
#else
	unsigned long long l;
#endif
};


//--------------------------------------------------------------
// table-based sin/cos
//--------------------------------------------------------------

#if FLOATTYPE_BITS==32
#define RIGHT_JUSTIFIER_POS    (floatType)(1<<23)
#define RIGHT_JUSTIFIER_POSNEG (floatType)((1<<23)+(1<<22))
#define TABLE_ENTRY_SIZE_BITS 2
#else
#define RIGHT_JUSTIFIER_POS    (floatType)(1LL<<52)
#define RIGHT_JUSTIFIER_POSNEG (floatType)((1LL<<52)+(1LL<<51))
#define TABLE_ENTRY_SIZE_BITS 3
#endif
#define TABLE_ENTRY_SIZE (1<<TABLE_ENTRY_SIZE_BITS)

#define SIN_TABLE_BITS 10
#define SIN_TABLE_SIZE (1<<SIN_TABLE_BITS)
#define SIN_TABLE_MASK (SIN_TABLE_SIZE-1)
#define SIN_TABLE_SIZE_FLOATSIZE (SIN_TABLE_SIZE*TABLE_ENTRY_SIZE)
#define SIN_TABLE_MASK_FLOATSIZE (SIN_TABLE_MASK*TABLE_ENTRY_SIZE)
#define RADIANS_TO_KDIANS(r) ((r)*(floatType)(SIN_TABLE_SIZE/(GAME_PI*2.0)))
#define RADIANS_TO_KDIANS_FLOATSIZE(r) ((r)*(floatType)(SIN_TABLE_SIZE_FLOATSIZE/(GAME_PI*2.0)))
#define KDIANS_TO_RADIANS(k) ((k)*(floatType)((GAME_PI*2.0)/SIN_TABLE_SIZE))
#define KDIAN_COS_OFFSET (SIN_TABLE_SIZE>>2)
#define KDIAN_COS_OFFSET_FLOATSIZE (KDIAN_COS_OFFSET*TABLE_ENTRY_SIZE)
	
#define SIN_TABLE_90DEG_MASK (SIN_TABLE_MASK>>2)
#define SIN_TABLE_180DEG_MASK (SIN_TABLE_MASK>>1)
#define SIN_TABLE_90DEG_SIZE (SIN_TABLE_SIZE>>2)
#define SIN_TABLE_180DEG_SIZE (SIN_TABLE_SIZE>>1)
	
#define SIN_TABLE_90DEG_MASK_FLOATSIZE  (SIN_TABLE_90DEG_MASK *TABLE_ENTRY_SIZE)
#define SIN_TABLE_180DEG_MASK_FLOATSIZE (SIN_TABLE_180DEG_MASK*TABLE_ENTRY_SIZE)
#define SIN_TABLE_90DEG_SIZE_FLOATSIZE  (SIN_TABLE_90DEG_SIZE *TABLE_ENTRY_SIZE)
#define SIN_TABLE_180DEG_SIZE_FLOATSIZE (SIN_TABLE_180DEG_SIZE*TABLE_ENTRY_SIZE)
	
floatType sinTable[SIN_TABLE_90DEG_SIZE+1];

// note that when we scale to convert from radians to kdians,
// we also essentially shift the result left to create an offset in
// bytes so the C compiler doesn't have to shift left when it loads
// the float (usually floatTable[z] converts to floatTable+(z<<2))

#ifndef MATH_USE_ASM
floatType table_sinf(register floatType theta)
{
	FloatAndULong fl;

	fl.f = RADIANS_TO_KDIANS_FLOATSIZE(theta)+RIGHT_JUSTIFIER_POSNEG;
	register unsigned long index = fl.l;
	register unsigned long in90  = index&SIN_TABLE_90DEG_SIZE_FLOATSIZE;
	register unsigned long in180 = index&SIN_TABLE_180DEG_SIZE_FLOATSIZE;
	
	index&=SIN_TABLE_90DEG_MASK_FLOATSIZE;

	if(in90)
	{
		index=in90-index;
	}
	
	register floatType v = *(floatType *)((char *)sinTable+(index));
	
	if(in180)
	{
		v=-v;
	}
	
	return(v);
}

floatType table_cosf(floatType theta)
{
	register FloatAndULong fl;
	
	fl.f = RADIANS_TO_KDIANS_FLOATSIZE(theta)+(RIGHT_JUSTIFIER_POSNEG+KDIAN_COS_OFFSET_FLOATSIZE);
	
	register unsigned long index = fl.l;
	register unsigned long in90  = index&SIN_TABLE_90DEG_SIZE_FLOATSIZE;
	register unsigned long in180 = index&SIN_TABLE_180DEG_SIZE_FLOATSIZE;
	
	index&=SIN_TABLE_90DEG_MASK_FLOATSIZE;

	if(in90)
	{
		index=in90-index;
	}
	
	register floatType v = *(floatType *)((char *)sinTable+(index));
	
	if(in180)
	{
		v=-v;
	}
	
	return(v);
}
#endif

void InitSinTable(void)
{
	register int i;
	for(i=0;i<SIN_TABLE_SIZE/4;i++)
	{
		sinTable[i] = SIN(KDIANS_TO_RADIANS(i));
	}
	// make damned sure of the important ones
	sinTable[0] = 0.0f;
	sinTable[SIN_TABLE_SIZE/4] = 1.0f;
	table_sinf(0);
}



#if 1
float mypowf(float x,float y)
{
    float r1=1.0f,c,r2;
    float i;
#if 0
    float pf,mpf;
    pf=powf(x,y);
    printf("%.9f ",pf);
#endif
    // stupid iterative solution to get the int part of the power computed
    while(y>=1.0f)
    {
        r1*=x;
        y-=1.0f;
    }
    // covers both no-fract and zero exponent cases
    if(y==0.0f)
    {
        return(r1);
    }
    // now compute x^fract
    // first, x must be x-1.0 so that we're doing (1+x)^y -> (1+(x-1))^y -> x^y
    x-=1.0f;
    c=y*x;
    r2=1.0f+c;
    for(i=1.0f; i<30.0f; )
    {
        c*=(y-i)*x;
        i+=1.0f;
        c/=i;
        r2+=c;
    }
#if 0
    mpf=r1*r2;
    printf("%.9f ",mpf);
    for(;i<30.0f;)
    {
        c*=(y-i)*x;
        i+=1.0f;
        c/=i;
        r2+=c;
    }
    mpf=r1*r2;
    printf("%.9f\n",mpf);
#endif
    return(r1*r2);
}
#endif

#ifndef INLINE_VECTOR_SET
#ifndef MATH_USE_ASM
void V4Set(register floatType dest[3],register floatType x,register floatType y,register floatType z,register floatType w)
{
	dest[X]=x;
	dest[Y]=y;
	dest[Z]=z;
	dest[W]=w;
}

void V3Set(register floatType dest[3],register floatType x,register floatType y,register floatType z)
{
	dest[X]=x;
	dest[Y]=y;
	dest[Z]=z;
}

void V2Set(register floatType dest[2],register floatType x,register floatType y)
{
	dest[X]=x;
	dest[Y]=y;
}

void V4Set(register floatType dest[4],register floatType src[4])
{
	dest[X]=src[X];
	dest[Y]=src[Y];
	dest[Z]=src[Z];
	dest[W]=src[W];
}

void V3Set(register floatType dest[3],register floatType src[3])
{
	dest[X]=src[X];
	dest[Y]=src[Y];
	dest[Z]=src[Z];
}

void V2Set(register floatType dest[2],register floatType src[2])
{
	dest[X]=src[X];
	dest[Y]=src[Y];
}
#endif
#endif

void V3Set(register floatType dest[3],register short src[3])
{
	dest[0] = (floatType)src[0];
	dest[1] = (floatType)src[1];
	dest[2] = (floatType)src[2];
}

// this does V3Cross(dest,(p1-p0),(p2-p0))
void V3Cross(register floatType dest[3],register floatType p0[3],register floatType p1[3],register floatType p2[3])
{
	register floatType src1[3],src2[3];

	V3Sub(src1,p1,p0);
	V3Sub(src2,p2,p0);
	V3Cross(dest,src1,src2);
}



// does the above AND makes a unit normal out of it
void V3Norm(register floatType dest[3],register floatType p0[3],register floatType p1[3],register floatType p2[3])
{
	register floatType src1[3],src2[3];

	V3Sub(src1,p1,p0);
	V3Sub(src2,p2,p0);
	V3Cross(dest,src1,src2);
	V3Norm(dest);
}



#ifndef MATH_USE_ASM
// handy for getting 2D normals
void V2Rot90(register floatType dest[2],register floatType src[2])
{
	register floatType d1;
    d1      =  src[0];
    dest[0] = -src[1];
	dest[1] =  d1;
}
void V2RotNeg90(register floatType dest[2],register floatType src[2])
{
	register floatType d1;
    d1      = -src[0];
    dest[0] =  src[1];
	dest[1] =  d1;
}



void V3Cross(register floatType dest[3],register floatType src1[3],register floatType src2[3])
{
	register floatType d2,d1;
    d2      = src1[0]*src2[1]-src1[1]*src2[0];
    d1      = src1[2]*src2[0]-src1[0]*src2[2];
    dest[0] = src1[1]*src2[2]-src1[2]*src2[1];
	dest[1] = d1;
	dest[2] = d2;
}



// this because the cross product of two 2D values is always 0,0,something
// and so it's pretty dumb to set a 2D result (0,0)
floatType V2CrossProductZVal(register floatType src1[2],register floatType src2[2])
{
	return(src1[0]*src2[1]-src1[1]*src2[0]);
}



floatType V3Dot(register floatType v1[3],register floatType v2[3]) 
{
    return(v1[X]*v2[X] + v1[Y]*v2[Y] + v1[Z]*v2[Z]);
}


floatType V2Dot(register floatType v1[2],register floatType v2[2]) 
{
    return(v1[X]*v2[X] + v1[Y]*v2[Y]);
}


void V3Neg(register floatType dest[3],register floatType src[3]) 
{
	dest[X] = -src[X];
	dest[Y] = -src[Y];
	dest[Z] = -src[Z];
}


void V3Neg(register floatType dest[3]) 
{
	dest[X] = -dest[X];
	dest[Y] = -dest[Y];
	dest[Z] = -dest[Z];
}


void V2Neg(register floatType dest[2],register floatType src[2]) 
{
	dest[X] = -src[X];
	dest[Y] = -src[Y];
}


void V2Neg(register floatType dest[2]) 
{
	dest[X] = -dest[X];
	dest[Y] = -dest[Y];
}


void V2Mul(register floatType dest[2],register floatType src1[2],register floatType src2[2])
{
    dest[0]=src1[0]*src2[0];
    dest[1]=src1[1]*src2[1];
}



void V2Mul(register floatType dest[2],register floatType src[2],register floatType mult)
{
    dest[0]=mult*src[0];
    dest[1]=mult*src[1];
}



void V2Mul(register floatType dest[2],register floatType mult)
{
    dest[0]*=mult;
    dest[1]*=mult;
}



void V4Mul(register floatType dest[4],register floatType src1[4],register floatType src2[4])
{
    dest[0] = src1[0] * src2[0];
    dest[1] = src1[1] * src2[1];
    dest[2] = src1[2] * src2[2];
    dest[3] = src1[3] * src2[3];
}



void V4Mul(register floatType dest[4],register floatType src[4])
{
    dest[0] *= src[0];
    dest[1] *= src[1];
    dest[2] *= src[2];
    dest[3] *= src[3];
}



void V4Mul(register floatType dest[4],register floatType src[4],register floatType mult)
{
    dest[0] = mult * src[0];
    dest[1] = mult * src[1];
    dest[2] = mult * src[2];
    dest[3] = mult * src[3];
}



void V4Mul(register floatType dest[4],register floatType mult)
{
    dest[0] *= mult;
    dest[1] *= mult;
    dest[2] *= mult;
    dest[3] *= mult;
}


void V3Mul(register floatType dest[3],register floatType src1[3],register floatType src2[3])
{
    dest[0] = src1[0] * src2[0];
    dest[1] = src1[1] * src2[1];
    dest[2] = src1[2] * src2[2];
}



void V3Mul(register floatType dest[3],register floatType src[3])
{
    dest[0] *= src[0];
    dest[1] *= src[1];
    dest[2] *= src[2];
}



void V3Mul(register floatType dest[3],register floatType src[3],register floatType mult)
{
    dest[0] = mult * src[0];
    dest[1] = mult * src[1];
    dest[2] = mult * src[2];
}



void V3Mul(register floatType dest[3],register floatType mult)
{
    dest[0] *= mult;
    dest[1] *= mult;
    dest[2] *= mult;
}


void V3Div(register floatType dest[3],register floatType src[3],register floatType div)
{
	div=1/div;
    dest[0]=src[0]*div;
    dest[1]=src[1]*div;
    dest[2]=src[2]*div;
}



void V3Div(register floatType dest[3],register floatType div)
{
	div=1/div;
    dest[0]*=div;
    dest[1]*=div;
    dest[2]*=div;
}



void V2Div(register floatType dest[2],register floatType div)
{
	div=1/div;
    dest[0]*=div;
    dest[1]*=div;
}



void V3Norm(register floatType dest[3],register floatType from[3],register floatType to[3])
{
	register floatType x,y,z;
    register floatType len;
	x=to[0]-from[0];
	y=to[1]-from[1];
	z=to[2]-from[2];
    if(len=SQRT(x*x+y*y+z*z))
    {
		len=(floatType)1.0/len;
        dest[0]=x*len;
        dest[1]=y*len;
        dest[2]=z*len;
    }
    else
    {
        dest[0]=(floatType)0.0;
        dest[1]=(floatType)0.0;
        dest[2]=(floatType)1.0;
    }
}




void V3Norm(register floatType v[3])
{
    register floatType len;
    if(len=SQRT(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]))
    {
		len=(floatType)1.0/len;
        v[0]*=len;
        v[1]*=len;
        v[2]*=len;
    }
	else
    {
        v[0]=(floatType)0.0;
        v[1]=(floatType)0.0;
        v[2]=(floatType)1.0;
    }
}


void V3Norm(register floatType dest[3],register floatType src[3])
{
	register floatType len;
	if(len=SQRT(src[0]*src[0]+src[1]*src[1]+src[2]*src[2]))
	{
		len=(floatType)1.0/len;
		dest[0]=src[0]*len;
		dest[1]=src[1]*len;
		dest[2]=src[2]*len;
	}
	else
	{
		dest[0]=(floatType)0.0;
		dest[1]=(floatType)0.0;
		dest[2]=(floatType)1.0;
	}
}




void V2Norm(register floatType dest[2],register floatType from[2],register floatType to[2])
{
	register floatType x,y;
    register floatType len;
	x=to[0]-from[0];
	y=to[1]-from[1];
    if(len=SQRT(x*x+y*y))
    {
		len=(floatType)1.0/len;
        dest[0]=x*len;
        dest[1]=y*len;
    }
    else
    {
        dest[0]=(floatType)0.0;
        dest[1]=(floatType)0.0;
    }
}




void V2Norm(register floatType dest[2],register floatType src[2])
{
	register floatType len;
	if(len=SQRT(src[0]*src[0]+src[1]*src[1]))
	{
		len=(floatType)1.0/len;
		dest[0]=src[0]*len;
		dest[1]=src[1]*len;
	}
	else
	{
		dest[0]=(floatType)0.0;
		dest[1]=(floatType)1.0;
	}
}


void V2Norm(register floatType v[2])
{
    register floatType len;
    if(len=SQRT(v[0]*v[0]+v[1]*v[1]))
    {
		len=(floatType)1.0/len;
        v[0]*=len;
        v[1]*=len;
    }
	else
    {
        v[0]=(floatType)0.0;
        v[1]=(floatType)1.0;
    }
}



void V3Sub(register floatType dest[3],register floatType src1[3],register floatType src2[3])
{
    dest[0]=src1[0]-src2[0];
    dest[1]=src1[1]-src2[1];
    dest[2]=src1[2]-src2[2];
}



void V3Sub(register floatType dest[3],register floatType src[3])
{
    dest[0]-=src[0];
    dest[1]-=src[1];
    dest[2]-=src[2];
}



void V2Sub(register floatType dest[2],register floatType src1[2],register floatType src2[2])
{
    dest[0]=src1[0]-src2[0];
    dest[1]=src1[1]-src2[1];
}



void V2Sub(register floatType dest[3],register floatType src[3])
{
    dest[0]-=src[0];
    dest[1]-=src[1];
}



void V3Add(register floatType dest[3],register floatType src1[3],register floatType src2[3])
{
    dest[0]=src1[0]+src2[0];
    dest[1]=src1[1]+src2[1];
    dest[2]=src1[2]+src2[2];
}
void V3Add(register floatType dest[3],register floatType src[3])
{
    dest[0]+=src[0];
    dest[1]+=src[1];
    dest[2]+=src[2];
}

void V2Add(register floatType dest[2],register floatType src1[2],register floatType src2[2])
{
    dest[0]=src1[0]+src2[0];
    dest[1]=src1[1]+src2[1];
}
void V2Add(register floatType dest[2],register floatType src[2])
{
    dest[0]+=src[0];
    dest[1]+=src[1];
}




void V4Lerp(register floatType dest[4],register floatType src1[4],register floatType src2[4],register floatType l)
{
    dest[0]=(src1[0]-src2[0])*l+src2[0];
    dest[1]=(src1[1]-src2[1])*l+src2[1];
    dest[2]=(src1[2]-src2[2])*l+src2[2];
    dest[3]=(src1[3]-src2[3])*l+src2[3];
}

void V3Lerp(register floatType dest[3],register floatType src1[3],register floatType src2[3],register floatType l)
{
    dest[0]=(src1[0]-src2[0])*l+src2[0];
    dest[1]=(src1[1]-src2[1])*l+src2[1];
    dest[2]=(src1[2]-src2[2])*l+src2[2];
}

void V2Lerp(register floatType dest[2],register floatType src1[2],register floatType src2[2],register floatType l)
{
    dest[0]=(src1[0]-src2[0])*l+src2[0];
    dest[1]=(src1[1]-src2[1])*l+src2[1];
}



void V3Mac(register floatType dest[3],floatType src1[3],floatType src2[3],register floatType s)
{
    dest[0]=src1[0]+src2[0]*s;
    dest[1]=src1[1]+src2[1]*s;
    dest[2]=src1[2]+src2[2]*s;
}



void V3Mac(register floatType dest[3],register floatType src[3],register floatType s)
{
    dest[0]+=src[0]*s;
    dest[1]+=src[1]*s;
    dest[2]+=src[2]*s;
}



void V2Mac(register floatType dest[2],register floatType src1[2],register floatType src2[2],register floatType s)
{
    dest[0]=src1[0]+src2[0]*s;
    dest[1]=src1[1]+src2[1]*s;
}



void V2Mac(register floatType dest[2],register floatType src[2],register floatType s)
{
    dest[0]+=src[0]*s;
    dest[1]+=src[1]*s;
}






void V3Avg(register floatType dest[3],register floatType src1[3],register floatType src2[3])
{
    dest[0]=(src1[0]+src2[0])*(floatType)0.5;
    dest[1]=(src1[1]+src2[1])*(floatType)0.5;
    dest[2]=(src1[2]+src2[2])*(floatType)0.5;
}



void V2Avg(register floatType dest[2],register floatType src1[2],register floatType src2[2])
{
    dest[0]=(src1[0]+src2[0])*(floatType)0.5;
    dest[1]=(src1[1]+src2[1])*(floatType)0.5;
}



// this is now doneinline
// void VectorZero(register floatType dest[3])
// {
//     dest[0]=dest[1]=dest[2]=(floatType)0.0;
// }




floatType V3Dist(register floatType v1[3],register floatType v2[3])
{
    register floatType x,y,z;
    x=v1[0]-v2[0];
    y=v1[1]-v2[1];
    z=v1[2]-v2[2];
    return(SQRT(x*x+y*y+z*z));
}

floatType V2Dist(register floatType v1[2],register floatType v2[2])
{
	register floatType x,y;
	x=v1[0]-v2[0];
	y=v1[1]-v2[1];
	return(SQRT(x*x+y*y));
}



floatType V3DistSq(register floatType v1[3],register floatType v2[3])
{
    register floatType x,y,z;
    x=v1[0]-v2[0];
    y=v1[1]-v2[1];
    z=v1[2]-v2[2];
    return(x*x+y*y+z*z);
}


floatType V2DistSq(register floatType v1[2],register floatType v2[2])
{
    register floatType x,y;
    x=v1[0]-v2[0];
    y=v1[1]-v2[1];
    return(x*x+y*y);
}



floatType V3Len(register floatType v[3])
{
    return(SQRT(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]));
}

floatType V2Len(register floatType v[3])
{
    return(SQRT(v[0]*v[0]+v[1]*v[1]));
}

floatType V3LenSq(register floatType v[3])
{
    return(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]);
}

floatType V2LenSq(register floatType v[3])
{
    return(v[0]*v[0]+v[1]*v[1]);
}

#endif






void V3Rot(register floatType dest[3],floatType angle,register floatType axis[3])
{
    register floatType s = SIN(angle);
    register floatType c = COS(angle);
    register floatType t = (floatType)1.0-c;

	register floatType ax = axis[X];
	register floatType ay = axis[Y];
	register floatType az = axis[Z];
	
	register floatType taxay  = t*ax;
	register floatType taxaz  = taxay*az;
	taxay *= ay;
	register floatType tayaz  = t*ay*az;

	register floatType sax = s*ax;
	register floatType say = s*ay;
	register floatType saz = s*az;
	
	register floatType x = dest[X];
	register floatType y = dest[Y];
	register floatType z = dest[Z];
	
    dest[X] =
        x*(t*ax*ax + c  ) +
        y*(taxay   + saz) +
        z*(taxaz   - say);
    
    dest[Y] =
        x*(taxay   - saz) +
        y*(t*ay*ay + c  ) +
        z*(tayaz   + sax);
    
    dest[Z] =
        x*(taxaz   + say) +
        y*(tayaz   - sax) +
        z*(t*az*az + c  );
}


void V2Rot(register floatType dest[2],floatType angle)
{
    register floatType s,c,x,y;
	
    s = SIN(angle);
    c = COS(angle);

	x = dest[X];
	y = dest[Y];
	
    dest[X] = x*c + y*s;
    dest[Y] = y*c - x*s;
}


// some matrix stuff
void V3Mul4x4(register floatType dest[3],register floatType src1[3],register floatType src2[4][4])
{
	register floatType x,y,z,w;
	x = src1[0];
	y = src1[1];
	z = src1[2];
	w = (floatType)1.0 / (x*src2[0][3] + y*src2[1][3] + z*src2[2][3] + src2[3][3]);
	dest[0] = (x*src2[0][0] + y*src2[1][0] + z*src2[2][0] + src2[3][0]) * w;
	dest[1] = (x*src2[0][1] + y*src2[1][1] + z*src2[2][1] + src2[3][1]) * w;
	dest[2] = (x*src2[0][2] + y*src2[1][2] + z*src2[2][2] + src2[3][2]) * w;
}



void V3Mul4x4_XYZW(register floatType dest[4],register floatType src1[3],register floatType src2[4][4])
{
	register floatType x,y,z;
	x = src1[0];
	y = src1[1];
	z = src1[2];
	dest[0] = (x*src2[0][0] + y*src2[1][0] + z*src2[2][0] + src2[3][0]);
	dest[1] = (x*src2[0][1] + y*src2[1][1] + z*src2[2][1] + src2[3][1]);
	dest[2] = (x*src2[0][2] + y*src2[1][2] + z*src2[2][2] + src2[3][2]);
	dest[3] = (x*src2[0][3] + y*src2[1][3] + z*src2[2][3] + src2[3][3]);
}



void VS3Mul4x4_XYZW(register floatType dest[4],register short src1[3],register floatType src2[4][4])
{
	register floatType x,y,z;
	x = src1[0];
	y = src1[1];
	z = src1[2];
	dest[0] = (x*src2[0][0] + y*src2[1][0] + z*src2[2][0] + src2[3][0]);
	dest[1] = (x*src2[0][1] + y*src2[1][1] + z*src2[2][1] + src2[3][1]);
	dest[2] = (x*src2[0][2] + y*src2[1][2] + z*src2[2][2] + src2[3][2]);
	dest[3] = (x*src2[0][3] + y*src2[1][3] + z*src2[2][3] + src2[3][3]);
}



void V3Mul4x4_XY(register floatType dest[3],register floatType src1[3],register floatType src2[4][4])
{
	register floatType x,y,z,w;
	x = src1[0];
	y = src1[1];
	z = src1[2];
	
	if(w = (x*src2[0][3] + y*src2[1][3] + z*src2[2][3] + src2[3][3]))
	{
		w = (floatType)1.0 / w;
	}
	// else leave it 0
	
	dest[0] = (x*src2[0][0] + y*src2[1][0] + z*src2[2][0] + src2[3][0]) * w;
	dest[1] = (x*src2[0][1] + y*src2[1][1] + z*src2[2][1] + src2[3][1]) * w;
}



void V3Mul4x3_XY(register floatType dest[3],register floatType src1[3],register floatType src2[4][4])
{
	register floatType x,y,z;
	x = src1[0];
	y = src1[1];
	z = src1[2];
	
	dest[0] = (x*src2[0][0] + y*src2[1][0] + z*src2[2][0] + src2[3][0]);
	dest[1] = (x*src2[0][1] + y*src2[1][1] + z*src2[2][1] + src2[3][1]);
}



void V3Mul3x4(register floatType dest[3],register floatType src1[3],register floatType src2[4][4])
{
	register floatType x,y,z,w;
	x = src1[0];
	y = src1[1];
	z = src1[2];
	w = (floatType)1.0 / (x*src2[0][3] + y*src2[1][3] + z*src2[2][3] + src2[3][3]);
	dest[0] = (x*src2[0][0] + y*src2[1][0] + z*src2[2][0]) * w;
	dest[1] = (x*src2[0][1] + y*src2[1][1] + z*src2[2][1]) * w;
	dest[2] = (x*src2[0][2] + y*src2[1][2] + z*src2[2][2]) * w;
}



void V3Mul4x3(register floatType dest[3],register floatType src1[3],register floatType src2[4][4])
{
	register floatType x=src1[0],y=src1[1],z=src1[2];
	dest[0] = x*src2[0][0] + y*src2[1][0] + z*src2[2][0] + src2[3][0];
	dest[1] = x*src2[0][1] + y*src2[1][1] + z*src2[2][1] + src2[3][1];
	dest[2] = x*src2[0][2] + y*src2[1][2] + z*src2[2][2] + src2[3][2];
}



// 3x3: get into world orientation from local orientation
void V3Mul3x3(register floatType dest[3],register floatType src1[3],register floatType src2[4][4])
{
	register floatType x=src1[0],y=src1[1],z=src1[2];
	dest[0] = x*src2[0][0] + y*src2[1][0] + z*src2[2][0];
	dest[1] = x*src2[0][1] + y*src2[1][1] + z*src2[2][1];
	dest[2] = x*src2[0][2] + y*src2[1][2] + z*src2[2][2];
}



// 3x3 transposed: good for getting into local orientation,
// as long as mtx is orthonormal
void V3Mul3x3T(register floatType dest[3],register floatType src1[3],register floatType src2[4][4])
{
	register floatType x=src1[0],y=src1[1],z=src1[2];
	dest[0] = x*src2[0][0] + y*src2[0][1] + z*src2[0][2];
	dest[1] = x*src2[1][0] + y*src2[1][1] + z*src2[1][2];
	dest[2] = x*src2[2][0] + y*src2[2][1] + z*src2[2][2];
}



void V4Plane(floatType *dest, floatType *src1, floatType *src2, floatType *src3)
{
	V3Cross(dest, src1, src2, src3);
	V3Norm(dest);
	dest[3] = V3Dot(dest, src1);
}



void V3Mul3x3_XY(register floatType dest[2],register floatType src1[3],register floatType src2[4][4])
{
	register floatType x=src1[0],y=src1[1],z=src1[2];
	dest[0] = x*src2[0][0] + y*src2[1][0] + z*src2[2][0];
	dest[1] = x*src2[0][1] + y*src2[1][1] + z*src2[2][1];
}



// TODO - REWRITE THIS FUCKING THING
void M4Mul(register floatType dest[4][4],register floatType src1[4][4],register floatType src2[4][4])
{
	register int i,j;
	if(dest!=src1 && dest!=src2)
	{
		for(i=0; i<4 ;i++)
		{
			for(j=0; j<4; j++)
			{
				dest[i][j]  = src1[i][0]*src2[0][j]
				            + src1[i][1]*src2[1][j]
				            + src1[i][2]*src2[2][j]
				            + src1[i][3]*src2[3][j];
			}
		}
	}
	else
	{
		register floatType m[4][4];
		for(i=0; i<4; i++)
		{
			for(j=0; j<4; j++)
			{
				m[i][j]  = src1[i][0]*src2[0][j]
				         + src1[i][1]*src2[1][j]
				         + src1[i][2]*src2[2][j]
				         + src1[i][3]*src2[3][j];
			}
		}
		M4Set(dest, m);
	}
}



void M4Mul4x3(register floatType dest[4][4],register floatType src1[4][4],register floatType src2[4][4])
{
	if(dest==src2)
	{
		M4PreMul4x3(dest, src1);
	}
	else
	{
		register int i,j;
		register floatType m[4][4];
		for(i=0; i<4; i++)
		{
			for(j=0; j<3; j++)
			{
				m[i][j]  = src1[i][0]*src2[0][j]
				         + src1[i][1]*src2[1][j]
				         + src1[i][2]*src2[2][j]
				         + src1[i][3]*src2[3][j];
			}
		}
		M4Set(dest, m);
	}
}



void M4Ident(register floatType dest[4][4])
{
	dest[0][0] = 1.0f;
	dest[0][1] = 0.0f;
	dest[0][2] = 0.0f;
	dest[0][3] = 0.0f;

	dest[1][0] = 0.0f;
	dest[1][1] = 1.0f;
	dest[1][2] = 0.0f;
	dest[1][3] = 0.0f;

	dest[2][0] = 0.0f;
	dest[2][1] = 0.0f;
	dest[2][2] = 1.0f;
	dest[2][3] = 0.0f;

	dest[3][0] = 0.0f;
	dest[3][1] = 0.0f;
	dest[3][2] = 0.0f;
	dest[3][3] = 1.0f;
}



void M4Mul(register floatType dest[4][4],register floatType src[4][4])
{
	register floatType x,y,z,w;
	register floatType4 *destRowThree = (floatType4 *)dest + 3;
	
	for(;;)
	{
		x=dest[0][0];
		y=dest[0][1];
		z=dest[0][2];
		w=dest[0][3];
		dest[0][0] = x*src[0][0] + y*src[1][0] + z*src[2][0] + w*src[3][0];
		dest[0][1] = x*src[0][1] + y*src[1][1] + z*src[2][1] + w*src[3][1];
		dest[0][2] = x*src[0][2] + y*src[1][2] + z*src[2][2] + w*src[3][2];
		dest[0][3] = x*src[0][3] + y*src[1][3] + z*src[2][3] + w*src[3][3];
		if(dest==destRowThree)
		{
			return;
		}
		dest = (floatType4 *)dest + 1;
	}
}



void M4Mul4x3(register floatType dest[4][4],register floatType src[4][4])
{
	register floatType x,y,z,xo,yo,zo;
	register floatType4 *destRowThree = (floatType4 *)dest + 3;

	for(;;)
	{
		x=dest[0][0];
		y=dest[0][1];
		z=dest[0][2];
		
		xo = x*src[0][0] + y*src[1][0] + z*src[2][0];
		yo = x*src[0][1] + y*src[1][1] + z*src[2][1];
		zo = x*src[0][2] + y*src[1][2] + z*src[2][2];
		
		if(dest==destRowThree)
		{
			dest[0][0] = xo + src[3][0];
			dest[0][1] = yo + src[3][1];
			dest[0][2] = zo + src[3][2];
			return;
		}
		
		dest[0][0] = xo;
		dest[0][1] = yo;
		dest[0][2] = zo;
		
		dest = (floatType4 *)dest+1;
	}
}



void M4PreMul4x3(register floatType dest[4][4],register floatType src1[4][4])
{
	// src2 and dest are the same, ignore src2 from now on
	register floatType4 *destColTwo = (floatType4 *)((float *)dest + 2);
	for(;;)
	{
		floatType x = dest[0][0];
		floatType y = dest[1][0];
		floatType z = dest[2][0];

		dest[0][0]  = x*src1[0][0] + y*src1[0][1] + z*src1[0][2];
		dest[1][0]  = x*src1[1][0] + y*src1[1][1] + z*src1[1][2];
		dest[2][0]  = x*src1[2][0] + y*src1[2][1] + z*src1[2][2];
		dest[3][0] += x*src1[3][0] + y*src1[3][1] + z*src1[3][2];  // = xx + yy + zz + w;

		if(dest==destColTwo)
		{
			return;
		}

		// move to next column
		dest = (floatType4 *)((floatType *)dest + 1);
	}
}



void M4Mul3x3(register floatType dest[4][4],register floatType src1[4][4],register floatType src2[4][4])
{
	// not the world's most efficient func
	register floatType m[4][4];
	register int i,j;
	for(i=0;i<3;i++)
	{
		for(j=0;j<3;j++)
		{
			m[i][j]  = src1[i][0]*src2[0][j];
			m[i][j] += src1[i][1]*src2[1][j];
			m[i][j] += src1[i][2]*src2[2][j];
		}
	}
	for(i=0;i<3;i++)
	{
		for(j=0;j<3;j++)
		{
			dest[i][j] = m[i][j];
		}
	}
}



#ifndef MATH_USE_ASM
void M4Scale3x3(register floatType dest[4][4],register floatType scale)
{
	dest[0][0]*=scale;
	dest[0][1]*=scale;
	dest[0][2]*=scale;
	dest[1][0]*=scale;
	dest[1][1]*=scale;
	dest[1][2]*=scale;
	dest[2][0]*=scale;
	dest[2][1]*=scale;
	dest[2][2]*=scale;
}



void M4Transpose(register floatType dest[4][4],register floatType src[4][4])
{
	// note that we interleave here so that we can follow dest=t with t=src
	// and not get a MIPS pipeline stall.
	register floatType t1,t2;
	
	#define MSWAP1(i,j) t1=src[i][j]; dest[i][j]=src[j][i]; dest[j][i]=t1;
	#define MSWAP2(i,j) t2=src[i][j]; dest[i][j]=src[j][i]; dest[j][i]=t2;
	
	MSWAP1(0,1);
	MSWAP2(0,2);
	MSWAP1(0,3);
	MSWAP2(1,2);
	MSWAP1(1,3);
	MSWAP2(2,3);

	if(src!=dest)
	{
		// copy the rest
		dest[0][0] = src[0][0];
		dest[1][1] = src[1][1];
		dest[2][2] = src[2][2];
		dest[3][3] = src[3][3];
	}
}



void M4Transpose3x3(register floatType dest[4][4],register floatType src[4][4])
{
	// note that we interleave here so that we can follow dest=t with t=src
	// and not get a MIPS pipeline stall.
	register floatType t1,t2;
	
	#define MSWAP1(i,j) t1=src[i][j]; dest[i][j]=src[j][i]; dest[j][i]=t1;
	#define MSWAP2(i,j) t2=src[i][j]; dest[i][j]=src[j][i]; dest[j][i]=t2;
	
	MSWAP1(0,1);
	MSWAP2(0,2);
	MSWAP1(1,2);

	if(src!=dest)
	{
		// copy the rest
		dest[0][0] = src[0][0];
		dest[0][3] = src[0][3];
		dest[1][1] = src[1][1];
		dest[1][3] = src[1][3];
		dest[2][2] = src[2][2];
		dest[2][3] = src[2][3];
		dest[3][0] = src[3][0];
		dest[3][1] = src[3][1];
		dest[3][2] = src[3][2];
		dest[3][3] = src[3][3];
	}
}



void M4Set(register floatType dest[4][4],register floatType src[4][4])
{
	memcpy(dest,src,sizeof(dest[0][0])*4*4);
}

void M4ViewFromOriginCamera(register floatType vm[4][4],register floatType cm[4][4])
{
	// we can convert camera to viewing matrix without using guLookAt
	// because the guLookAt just returns a rearranged version of the
	// camera matrix anyway.

	vm[0][0] = -cm[1][0];
	vm[0][1] =  cm[2][0];
	vm[0][2] = -cm[0][0];
	vm[0][3] =    0.0f;
	vm[1][0] = -cm[1][1];
	vm[1][1] =  cm[2][1];
	vm[1][2] = -cm[0][1];
	vm[1][3] =    0.0f;
	vm[2][0] = -cm[1][2];
	vm[2][1] =  cm[2][2];
	vm[2][2] = -cm[0][2];
	vm[2][3] =    0.0f;
#ifdef ADJUST_FOR_CAMERA
	vm[3][0] =    0.0f;
	vm[3][1] =    0.0f;
	vm[3][2] =    0.0f;
#else
	vm[3][0] =  V3Dot(cm[1],cm[3]);
	vm[3][1] = -V3Dot(cm[2],cm[3]);
	vm[3][2] =  V3Dot(cm[0],cm[3]);
#endif
	vm[3][3] =    1.0f;
}
#endif


void M4FromXYZRot(register floatType dest[4][4],register floatType rx,register floatType ry,register floatType rz)
{
	register floatType crx, cry, crz;
	register floatType srx, sry, srz;
	register floatType crxsrz, crxcrz;
	register floatType srxsrz, srxcrz;

	// I wonder if doing srx = SQRT(1.0-crx) would be faster here...
	if(rx)
	{
		crx = COS(rx);
		srx = SIN(rx);
	}
	else
	{
		crx = 1.0f;
		srx = 0.0f;
	}
	if(ry)
	{
		cry = COS(ry);
		sry = SIN(ry);
	}
	else
	{
		cry = 1.0f;
		sry = 0.0f;
	}
	if(rz)
	{
		crz = COS(rz);
		srz = SIN(rz);
	}
	else
	{
		crz = 1.0f;
		srz = 0.0f;
	}

	dest[0][0] = cry*crz;
	dest[0][1] = cry*srz;
	dest[0][2] = -sry;
	dest[0][3] = (floatType)0.0;
	
	crxsrz = crx*srz;
	crxcrz = crx*crz;
	srxsrz = srx*srz;
	srxcrz = srx*crz;

	dest[1][0] = srxcrz*sry - crxsrz;
	dest[1][1] = srxsrz*sry + crxcrz;
	dest[1][2] = srx*cry;
	dest[1][3] = (floatType)0.0;

	dest[2][0] = crxcrz*sry + srxsrz;
	dest[2][1] = crxsrz*sry - srxcrz;
	dest[2][2] = crx*cry;
	dest[2][3] = (floatType)0.0;
	
	dest[3][0] = (floatType)0.0;
	dest[3][1] = (floatType)0.0;
	dest[3][2] = (floatType)0.0;
	dest[3][3] = (floatType)1.0;
}



void M4FromYZXRot(register floatType dest[4][4],register floatType rx,register floatType ry,register floatType rz)
{
#if 1
	// TODO - make fast n stuff
	floatType tmp[4][4];	
	M4FromXYZRot(dest, 0.0f, ry,   rz);
	M4FromXYZRot(tmp,  rx,   0.0f, 0.0f);
	M4Mul4x3(dest, tmp);
#else
	register floatType crx, cry, crz;
	register floatType srx, sry, srz;
	register floatType crxsrz, crxcrz;
	register floatType srxsrz, srxcrz;

	// I wonder if doing srx = SQRT(1.0-crx) would be faster here...
	if(rx)
	{
		crx = COS(rx);
		srx = SIN(rx);
	}
	else
	{
		crx = 1.0f;
		srx = 0.0f;
	}
	if(ry)
	{
		cry = COS(ry);
		sry = SIN(ry);
	}
	else
	{
		cry = 1.0f;
		sry = 0.0f;
	}
	if(rz)
	{
		crz = COS(rz);
		srz = SIN(rz);
	}
	else
	{
		crz = 1.0f;
		srz = 0.0f;
	}

	dest[0][0] = cry*crz;
	dest[0][1] = cry*srz;
	dest[0][2] = -sry;
	dest[0][3] = (floatType)0.0;
	
	crxsrz = crx*srz;
	crxcrz = crx*crz;
	srxsrz = srx*srz;
	srxcrz = srx*crz;

	dest[1][0] = srxcrz*sry - crxsrz;
	dest[1][1] = srxsrz*sry + crxcrz;
	dest[1][2] = srx*cry;
	dest[1][3] = (floatType)0.0;

	dest[2][0] = crxcrz*sry + srxsrz;
	dest[2][1] = crxsrz*sry - srxcrz;
	dest[2][2] = crx*cry;
	dest[2][3] = (floatType)0.0;
	
	dest[3][0] = (floatType)0.0;
	dest[3][1] = (floatType)0.0;
	dest[3][2] = (floatType)0.0;
	dest[3][3] = (floatType)1.0;
#endif
}



#if 0
// TODO - delete this code, it's specific to Alias
void M4MakeJoint(register floatType m[4][4],
				 register floatType scale,
				 floatType translateIn[3],
				 register floatType rotate[3],
				 floatType translateOut[3])
{
	// hack scale,translateIn for now

// 	scale=0.821184f;
// 	translateIn[X] = -5.835590f ;
// 	translateIn[Y] = -8.090000f;
// 	translateIn[Z] = -0.506314f;
// 	rotate[X] = -119.800000f*GAME_PI/180.0f;
// 	rotate[Y] =   89.700000f*GAME_PI/180.0f;
// 	rotate[Z] =  -83.600000f*GAME_PI/180.0f;
// 	translateOut[X] = -0.598111f;
// 	translateOut[Y] =  5.198980f;
// 	translateOut[Z] =  3.841100f;
	
	m[0][0] = scale; m[0][1] = 0.0f;  m[0][2] = 0.0f;  m[0][3] = 0.0f;
	m[1][0] = 0.0f;  m[1][1] = scale; m[1][2] = 0.0f;  m[1][3] = 0.0f;
	m[2][0] = 0.0f;  m[2][1] = 0.0f;  m[2][2] = scale; m[2][3] = 0.0f;
	m[3][0] = translateIn[X];
	m[3][1] = translateIn[Y];
	m[3][2] = translateIn[Z];                          m[3][3] = 1.0f;
	
	// do rotate
	floatType mrt[4][4];
	if(rotate[X] || rotate[Y] || rotate[Z])
	{
		M4FromXYZRot(mrt,rotate[X],rotate[Y],rotate[Z]);
//	printf("rotate %.3f %.3f %.3f\n",rotate[X],rotate[Y],rotate[Z]);
// 	// redo rotate
// 	floatType rx[4][4];
// 	floatType ry[4][4];
// 	floatType rz[4][4];
// 	guRotateF(rx,ry,rz)
	
		// do translateOut
		mrt[POSITION][X]=translateOut[X];
		mrt[POSITION][Y]=translateOut[Y];
		mrt[POSITION][Z]=translateOut[Z];
	
//[0.821184 0.821184 0.821184] [-5.83559 -8.09 -0.506314] [-119.8 89.7 -83.6] [-0.598111 5.19898 3.8411]
// ---------------------------------------
// flag
// sp: -0.598112 5.198979 3.841095
// rp: -0.598111 5.198979 3.841096

// si: -7.106315 -9.851623 -0.616566
// s:  0.821184 0.821184 0.821184
// so: 7.106315 9.851623 0.616566
// ri: -7.106315 -9.851623 -0.616566
// r:  -119.800000 89.700000 -83.600000
// ro: 7.106315 9.851623 0.616566
// t:  -7.704427 -4.652643 3.224530

// 0:  0.000479 -0.004273 -0.821173
// 1:  -0.484995 0.662653 -0.003731
// 2:  0.662664 0.484990 -0.002137
// 3:  3.767894 -1.597895 9.714684

// 0:  0.000479 -0.004273 -0.821173
// 1:  -0.484995 0.662653 -0.003731
// 2:  0.662664 0.484990 -0.002137
// 3:  3.767894 -1.597895 9.714684

//	scale
// 0:  0.821184 0.000000 0.000000
// 1:  0.000000 0.821184 0.000000
// 2:  0.000000 0.000000 0.821184
// 3:  -5.835594 -8.089997 -0.506314

//  rotate
// 0:  0.000584 -0.005203 -0.999986
// 1:  -0.590604 0.806948 -0.004544
// 2:  0.806961 0.590599 -0.002602
// 3:  -0.598111 5.198980 3.841096
// ---------------------------------------
// 	static int printit=1;
// 			if(printit)
// 			{
// 				printf("-----------------------------\n");
// 				printf("[%f %f %f] [%f %f %f] [%f %f %f] [%f %f %f]\n",
// 					   scale,scale,scale,
// 					   translateIn[X],translateIn[Y],translateIn[Z],
// 					   rotate[X],rotate[Y],rotate[Z],
// 					   translateOut[X],translateOut[Y],translateOut[Z]);
// 				printf("%.6f %.6f %.6f %.6f\n",m[0][0],m[0][1],m[0][2]);
// 				printf("%.6f %.6f %.6f %.6f\n",m[1][0],m[1][1],m[1][2]);
// 				printf("%.6f %.6f %.6f %.6f\n",m[2][0],m[2][1],m[2][2]);
// 				printf("%.6f %.6f %.6f %.6f\n",m[3][0],m[3][1],m[3][2]);
// 				printf("\n");
// 				printf("%.6f %.6f %.6f %.6f\n",mrt[0][0],mrt[0][1],mrt[0][2]);
// 				printf("%.6f %.6f %.6f %.6f\n",mrt[1][0],mrt[1][1],mrt[1][2]);
// 				printf("%.6f %.6f %.6f %.6f\n",mrt[2][0],mrt[2][1],mrt[2][2]);
// 				printf("%.6f %.6f %.6f %.6f\n",mrt[3][0],mrt[3][1],mrt[3][2]);
// 			}
				
	M4Mul(m,mrt);
	}
	else
	{
		// do translateOut
		m[POSITION][X]+=translateOut[X];
		m[POSITION][Y]+=translateOut[Y];
		m[POSITION][Z]+=translateOut[Z];
	}
// 			if(printit)
// 			{
// 				printf("\n");
// 				printf("%.6f %.6f %.6f %.6f\n",m[0][0],m[0][1],m[0][2]);
// 				printf("%.6f %.6f %.6f %.6f\n",m[1][0],m[1][1],m[1][2]);
// 				printf("%.6f %.6f %.6f %.6f\n",m[2][0],m[2][1],m[2][2]);
// 				printf("%.6f %.6f %.6f %.6f\n",m[3][0],m[3][1],m[3][2]);
// 				printit=0;
// 			}
}

void M4MakeJointWeighted(floatType m[4][4],
							  floatType scale,
							  floatType translateIn[3],
							  floatType rotate[3],
							  floatType translateOut[3],
							  floatType weight)
{
	if(weight==(floatType)1.0)
	{
		M4MakeJoint(m,scale,translateIn,rotate,translateOut);
	}
	else
	{
		floatType newTranslateIn[3];
		floatType newRotate[3];
		floatType newTranslateOut[3];
		scale*=weight;
		V3Mul(newTranslateIn,translateIn,weight);
		V3Mul(newRotate,rotate,weight);
		V3Mul(newTranslateOut,translateOut,weight);
		M4MakeJoint(m,scale,newTranslateIn,newRotate,newTranslateOut);
	}
}
#endif



/****
 *
 * affine_matrix4_inverse
 *
 * Computes the inverse of a 3D affine matrix; i.e. a matrix with a dimen-
 * sionality of 4 where the right column has the entries (0, 0, 0, 1).
 *
 * This procedure treats the 4 by 4 matrix as a block matrix and
 * calculates the inverse of one submatrix for a significant perform-
 * ance improvement over a general procedure that can invert any non-
 * singular matrix:
 *          --        --          --          --
 *          |          | -1       |    -1      |
 *          | A      0 |          |   A      0 |
 *    -1    |          |          |            |
 *   M   =  |          |     =    |     -1     |
 *          | C      1 |          | -C A     1 |
 *          |          |          |            |
 *          --        --          --          --
 *
 *  where     M is a 4 by 4 matrix,
 *            A is the 3 by 3 upper left submatrix of M,
 *            C is the 1 by 3 lower left submatrix of M.
 *
 * Input:
 *   in   - 3D affine matrix
 *
 * Output:
 *   out  - inverse of 3D affine matrix
 *
 * Returned value:
 *   TRUE   if input matrix is nonsingular
 *   FALSE  otherwise
 *
 ***/

int M4Inv(floatType out[4][4],floatType in[4][4])
{
    register  floatType    det_1;
              floatType    pos, neg, temp, absDet;

#define ACCUMULATE    \
    if (temp >= (floatType)0.0)  \
        pos += temp;  \
    else              \
        neg += temp;

#define PRECISION_LIMIT (floatType)(1.0e-15)

    /*
     * Calculate the determinant of submatrix A and determine if the
     * the matrix is singular as limited by the double precision
     * floating-point data representation.
     */
    pos = neg = (floatType)0.0;
    temp =  in[0][0] * in[1][1] * in[2][2];
    ACCUMULATE
    temp =  in[0][1] * in[1][2] * in[2][0];
    ACCUMULATE
    temp =  in[0][2] * in[1][0] * in[2][1];
    ACCUMULATE
    temp = -in[0][2] * in[1][1] * in[2][0];
    ACCUMULATE
    temp = -in[0][1] * in[1][0] * in[2][2];
    ACCUMULATE
    temp = -in[0][0] * in[1][2] * in[2][1];
    ACCUMULATE
    det_1 = pos + neg;

    /* Is the submatrix A singular? */
	if((absDet = (det_1 / (pos - neg))) < (floatType)0.0)
	{
		absDet=-absDet;
	}
	
    if ((det_1 == (floatType)0.0) || (absDet < PRECISION_LIMIT)) {

        /* Matrix M has no inverse */
#ifdef GAME
		PrintCustomFault("M4Inverse: singular matrix");
        return(0);
#else
        printf("M4Inverse: singular matrix\n");
		for(;;);
#endif
    }
    else {

        /* Calculate inverse(A) = adj(A) / det(A) */
        det_1 = (floatType)1.0 / det_1;
        out[0][0] =   ( in[1][1] * in[2][2] -
						in[1][2] * in[2][1] ) * det_1;
        out[1][0] = - ( in[1][0] * in[2][2] -
						in[1][2] * in[2][0] ) * det_1;
        out[2][0] =   ( in[1][0] * in[2][1] -
						in[1][1] * in[2][0] ) * det_1;
        out[0][1] = - ( in[0][1] * in[2][2] -
						in[0][2] * in[2][1] ) * det_1;
        out[1][1] =   ( in[0][0] * in[2][2] -
						in[0][2] * in[2][0] ) * det_1;
        out[2][1] = - ( in[0][0] * in[2][1] -
						in[0][1] * in[2][0] ) * det_1;
        out[0][2] =   ( in[0][1] * in[1][2] -
						in[0][2] * in[1][1] ) * det_1;
        out[1][2] = - ( in[0][0] * in[1][2] -
						in[0][2] * in[1][0] ) * det_1;
        out[2][2] =   ( in[0][0] * in[1][1] -
						in[0][1] * in[1][0] ) * det_1;
		
        /* Calculate -C * inverse(A) */
        out[3][0] = - ( in[3][0] * out[0][0] +
						in[3][1] * out[1][0] +
						in[3][2] * out[2][0] );
        out[3][1] = - ( in[3][0] * out[0][1] +
						in[3][1] * out[1][1] +
						in[3][2] * out[2][1] );
        out[3][2] = - ( in[3][0] * out[0][2] +
						in[3][1] * out[1][2] +
						in[3][2] * out[2][2] );

        /* Fill in last column */
        out[0][3] = out[1][3] = out[2][3] = (floatType)0.0;
        out[3][3] = (floatType)1.0;

        return(1);
    }
}


void M4OrthoInv(floatType out[4][4],floatType in[4][4])
{
	M4Transpose3x3(out,in);
	V3Neg(out[POSITION]);
	V3Mul3x3(out[POSITION],out[POSITION],out);
}


floatType zeroVector[4] =
{
	(floatType)0.0,
	(floatType)0.0,
	(floatType)0.0,
	(floatType)0.0
};

#ifndef MATH_USE_ASM
void M4Align(register floatType mf[4][4],register floatType up[3],register floatType forward[3])
{
	M4Align(mf,up,forward,zeroVector);
}

void M4Align(register floatType mf[4][4],register floatType up[3],register floatType target[3],register floatType pos[3])
{
	mf[FORWARD] [3] = (floatType)0.0;
	mf[SIDE]    [3] = (floatType)0.0;
	mf[UP]      [0] = up[X];
	mf[UP]      [1] = up[Y];
	mf[UP]      [2] = up[Z];
	mf[UP]      [3] = (floatType)0.0;
	mf[POSITION][0] = pos[X];
	mf[POSITION][1] = pos[Y];
	mf[POSITION][2] = pos[Z];
	mf[POSITION][3] = (floatType)1.0;

	V3Norm(mf[FORWARD],pos,target);
	V3Cross(mf[SIDE],mf[UP],mf[FORWARD]);
	
	register floatType len = V3Len(mf[SIDE]);
	if(!len)
	{
		// yucky code to get a vector that isn't colinear
		register floatType pt5 = (floatType)0.5;
		register floatType one = (floatType)1.0;
		V3Zero(mf[FORWARD]);
		if     (mf[UP][X] < pt5)
		{
			mf[FORWARD][X] = one;
		}
		else if(mf[UP][Y] < pt5)
		{
			mf[FORWARD][Y] = one;
		}
		else
		{
			mf[FORWARD][Z] = one;
		}
		V3Cross(mf[SIDE],mf[UP],mf[FORWARD]);
		len = V3Len(mf[SIDE]);
	}
	// if len somehow still==0.0, we will end up with a yucky matrix,
	// but that's better than something with an inf in it.
	if(len)
	{
		V3Div(mf[SIDE],len);
	}
	// we assume unit up vector, and we just made side a unit, so we can also
	// assume that forward out of this orthogonal cross product will be a unit.
	V3Cross(mf[FORWARD],mf[SIDE],mf[UP]);
}
#endif



floatType CoarseAngle(register floatType x,register floatType y)
{
	register floatType s,position,step,angle=(floatType)0.0,temp;
	register int i,add=1;
	
	// down to half the world
	if(y<0)
	{
		angle+=(floatType)GAME_PI;
		x=-x;
		y=-y;
	}
	
	// down to a quarter of the world
	if(x<0)
	{
		angle+=(floatType)(GAME_PI/2.0);
		temp=x;
		x=y;
		y=-temp;
	}

	// down to an octant
	if(x<y)
	{
		angle+=(floatType)(GAME_PI/4.0);
		
		temp=x;
		x=y;
		y=temp;
		
		add=0;
	}

	// normalize so that y = sin(angle)
	// note that we sacrifice x here to be a temp var.  this
	// saves on register vars.
	
	if(!(x = SQRT(y*y+x*x)))
	{
		return((floatType)0.0);
	}
	y/=x;

	// a little binary search to find theta such that y ~= sin(theta).
	// we start in the middle of the octant (22.5 degrees)
	// and step by half of that.
	
	position = (floatType)(GAME_PI/8.0);
	step = position*(floatType)0.5;

	// do up to 16 iterations
	for(i=0;i<16;i++)
	{
		// it's coarse anyway, might as well be fast too
		s=table_sinf(position);
		
		if(s < y)
		{
			// close enough
			if(y-s < (floatType)0.0025)
			{
//				printf("@ %d\n",i);
				break;
			}
			
			position+=step;
		}
		else if(s > y)
		{
			// close enough
			if(s-y < (floatType)0.0025)
			{
//				printf("@ %d\n",i);
				break;
			}
			
			position-=step;
		}
		else
		{
//			printf("@ %d\n",i);
			break;
		}
		
		step *= (floatType)0.5;
	}

	if(add)
	{
		return(angle + position);
	}
	else
	{
		return(angle + ((floatType)(GAME_PI/4.0)-position));
	}
}



int pointInsideTriangle(register floatType *p, register floatType *v0, register floatType *v1, register floatType *v2, register floatType *n)
{
	register floatType vp0[3], vp1[3];//, vp2[3];
	register floatType v10[3], v21[3], v02[3];
	register floatType np[3];
	
	/* normal for first side with point p */
	V3Sub(v10, v1, v0);
	V3Sub(vp1, p, v1);
	V3Cross(np, v10, vp1);
	
	/* if this normal points opposite direction of triangle normal */
	/* then return outside                                        */
	if(V3Dot(np,n) < 0.0f)
	{
		return(0);
	}
	
	/* normal for second side with point p */
	V3Sub(v21, v2, v1);
//	V3Sub(vp2, p, v2);
//	V3Cross(np, v21, vp2);
	// v1 is on this segment too, might as well use what we've made already
	V3Cross(np, v21, vp1);
	
	/* if this normal points opposite direction of triangle normal */
	/* then return outside                                        */
	if(V3Dot(np,n) < 0.0f)
	{
		return(0);
	}
	
	/* normal for third side with point p */
	V3Sub(v02, v0, v2);
	V3Sub(vp0, p, v0);
	V3Cross(np, v02, vp0);
	
	/* if this normal points opposite direction of triangle normal */
	/* then return outside                                        */
	if(V3Dot(np,n) < 0.0f)
	{
		return(0);
	}
	
	/* if all 3 inside-outside tests passed */
	/* return inside                        */
	return(1);
}
/* End of pointInsideTriangle( float *p, float *v0, float *v1, float *v2 ) */



// negative tolerance makes the triangle bigger, positive smaller
int pointInsideTriangle(register floatType *p, register floatType *v0, register floatType *v1, register floatType *v2, register floatType *n,register floatType tolerance)
{
	register floatType vp0[3], vp1[3];//, vp2[3];
	register floatType v10[3], v21[3], v02[3];
	register floatType np[3];
	
	/* normal for first side with point p */
	V3Sub(v10, v1, v0);
	V3Sub(vp1, p, v1);
	V3Cross(np, v10, vp1);
	
	/* if this normal points opposite direction of triangle normal */
	/* then return outside                                        */
	if(V3Dot(np,n) < tolerance)
	{
		return(0);
	}
	
	/* normal for second side with point p */
	V3Sub(v21, v2, v1);
//	V3Sub(vp2, p, v2);
//	V3Cross(np, v21, vp2);
	// v1 is on this segment too, might as well use what we've made already
	V3Cross(np, v21, vp1);
	
	/* if this normal points opposite direction of triangle normal */
	/* then return outside                                        */
	if(V3Dot(np,n) < tolerance)
	{
		return(0);
	}
	
	/* normal for third side with point p */
	V3Sub(v02, v0, v2);
	V3Sub(vp0, p, v0);
	V3Cross(np, v02, vp0);
	
	/* if this normal points opposite direction of triangle normal */
	/* then return outside                                        */
	if(V3Dot(np,n) < tolerance)
	{
		return(0);
	}
	
	/* if all 3 inside-outside tests passed */
	/* return inside                        */
	return(1);
}
/* End of pointInsideTriangle( float *p, float *v0, float *v1, float *v2 ) */



// assumes counterclockwise winding!  polygon normal must be 0,0,1
bool V2InsideTriangle(register floatType *p, register floatType *v0, register floatType *v1, register floatType *v2)
{
	register floatType vp0[2], vp1[2];
	register floatType v10[2], v21[2], v02[2];
//	register floatType np[2];
	
	// normal for first side with point p
	V2Sub(v10, v1, v0);
	V2Sub(vp1, p, v1);
	
	// if this normal points opposite direction of triangle normal
	// then return "outside" (assume normal = 0,0,1)
	if(V2CrossProductZVal(v10, vp1) < 0.0f)
	{
		return(false);
	}
	
	// normal for second side with point p
	V2Sub(v21, v2, v1);
	
	// if this normal points opposite direction of triangle normal
	// then return "outside" (assume normal = 0,0,1)
	if(V2CrossProductZVal(v21, vp1) < 0.0f)
	{
		return(false);
	}
	
	// normal for third side with point p
	V2Sub(v02, v0, v2);
	V2Sub(vp0, p, v0);
	
	// if this normal points opposite direction of triangle normal
	// then return "outside" (assume normal = 0,0,1)
	if(V2CrossProductZVal(v02, vp0) < 0.0f)
	{
		return(false);
	}
	
	// if all 3 inside-outside tests passed
	// return "inside"
	return(true);
}


// TODO - why does this still use v3's?
// negative tolerance makes the triangle bigger, positive smaller

bool V2InTri(register floatType *p, register floatType *v0, register floatType *v1, register floatType *v2, register floatType *n,register floatType tolerance)
{
	register floatType vp0[3], vp1[3];//, vp2[3];
	register floatType v10[3], v21[3], v02[3];
	register floatType np[3];
	
	/* normal for first side with point p */
	V3Sub(v10, v1, v0);
	V3Sub(vp1, p, v1);
	V3Cross(np, v10, vp1);
	
	/* if this normal points opposite direction of triangle normal */
	/* then return outside                                        */
	if(V3Dot(np,n) < tolerance)
	{
		return(false);
	}
	
	/* normal for second side with point p */
	V3Sub(v21, v2, v1);
//	V3Sub(vp2, p, v2);
//	V3Cross(np, v21, vp2);
	// v1 is on this segment too, might as well use what we've made already
	V3Cross(np, v21, vp1);
	
	/* if this normal points opposite direction of triangle normal */
	/* then return outside                                        */
	if(V3Dot(np,n) < tolerance)
	{
		return(false);
	}
	
	/* normal for third side with point p */
	V3Sub(v02, v0, v2);
	V3Sub(vp0, p, v0);
	V3Cross(np, v02, vp0);
	
	/* if this normal points opposite direction of triangle normal */
	/* then return outside                                        */
	if(V3Dot(np,n) < tolerance)
	{
		return(false);
	}
	
	/* if all 3 inside-outside tests passed */
	/* return inside                        */
	return(true);
}
/* End of pointInsideTriangle( float *p, float *v0, float *v1, float *v2 ) */



// assumes tri points up
// all math is in 2d
// NOTE!!! I AM USING THIS TO TEST FOR BEING *INSIDE*, NOT ON!
bool V2InTri(register floatType *p, register floatType *v0, register floatType *v1, register floatType *v2)
{
	register floatType n[3];
	register floatType tmp[3];

	V2Sub(tmp, p, v1);
	V2Sub(n, v1, v0);
	V2Rot90(n, n);
	if(V2Dot(tmp, n) < 0)
	{
		return(false);
	}

	V2Sub(tmp, p, v2);
	V2Sub(n, v2, v1);
	V2Rot90(n, n);
	if(V2Dot(tmp, n) < 0)
	{
		return(false);
	}

//	V2Sub(tmp, p, v0);  // v2 will do since it's on the third segment too
	V2Sub(n, v0, v2);
	V2Rot90(n, n);
	if(V2Dot(tmp, n) < 0)
	{
		return(false);
	}
	
	// inside all three side, must be inside the triangle
	return(true);
}
bool V2OnTri(register floatType *p, register floatType *v0, register floatType *v1, register floatType *v2)
{
	register floatType n[3];
	register floatType tmp[3];

	V2Sub(tmp, p, v1);
	V2Sub(n, v1, v0);
	V2Rot90(n, n);
	if(V2Dot(tmp, n) <= 0)
	{
		return(false);
	}

	V2Sub(tmp, p, v2);
	V2Sub(n, v2, v1);
	V2Rot90(n, n);
	if(V2Dot(tmp, n) <= 0)
	{
		return(false);
	}

//	V2Sub(tmp, p, v0);  // v2 will do since it's on the third segment too
	V2Sub(n, v0, v2);
	V2Rot90(n, n);
	if(V2Dot(tmp, n) <= 0)
	{
		return(false);
	}
	
	// inside all three side, must be inside the triangle
	return(true);
}




// basically swiped from GGIII

int SegIntersect(register floatType *l1p1,register floatType *l1p2,register floatType *l2p1,register floatType *l2p2)
{
    register floatType max,min;
    register floatType a,b,c,d;

    // bounding box check
    max = (l1p1[X]>l1p2[X])? l1p1[X] : l1p2[X];
    min = (l2p1[X]<l2p2[X])? l2p1[X] : l2p2[X];
    if(max<min)
    {
        return(0);
    }
    max = (l2p1[X]>l2p2[X])? l2p1[X] : l2p2[X];
    min = (l1p1[X]<l1p2[X])? l1p1[X] : l1p2[X];
    if(max<min)
    {
        return(0);
    }
    max = (l1p1[Y]>l1p2[Y])? l1p1[Y] : l1p2[Y];
    min = (l2p1[Y]<l2p2[Y])? l2p1[Y] : l2p2[Y];
    if(max<min)
    {
        return(0);
    }
    max = (l2p1[Y]>l2p2[Y])? l2p1[Y] : l2p2[Y];
    min = (l1p1[Y]<l1p2[Y])? l1p1[Y] : l1p2[Y];
    if(max<min)
    {
        return(0);
    }

    // see if the endpoints of the second segment lie on opposite
    // sides of the first
    a = (l2p1[X]-l1p1[X]) * (l1p2[Y]-l1p1[Y]) -
        (l2p1[Y]-l1p1[Y]) * (l1p2[X]-l1p1[X]);
    b = (l2p2[X]-l1p1[X]) * (l1p2[Y]-l1p1[Y]) -
        (l2p2[Y]-l1p1[Y]) * (l1p2[X]-l1p1[X]);

    if(a!=0.0f && b!=0.0f && a*b>0.0f)
    {
        return(0);
    }
    
    // see if the endpoints of the first segment lie on opposite
    // sides of the second
    c = (l1p1[X]-l2p1[X]) * (l2p2[Y]-l2p1[Y]) -
        (l1p1[Y]-l2p1[Y]) * (l2p2[X]-l2p1[X]);
    d = (l1p2[X]-l2p1[X]) * (l2p2[Y]-l2p1[Y]) -
        (l1p2[Y]-l2p1[Y]) * (l2p2[X]-l2p1[X]);

    if(c!=0.0f && d!=0.0f && c*d>0.0f)
    {
        return(0);
    }

    // are they colinear?
    if(a-b==0.0f)
    {
        return(2);
    }

    // skip the actual determination of the point and just return

    return(1);
}



int SegIntersect(register floatType *l1p1,register floatType *l1p2,register floatType *l2p1,register floatType *l2p2,floatType *percent)
{
    register floatType max,min;
    register floatType a,b,c,d;

    // bounding box check
    max = (l1p1[X]>l1p2[X])? l1p1[X] : l1p2[X];
    min = (l2p1[X]<l2p2[X])? l2p1[X] : l2p2[X];
    if(max<min)
    {
        return(0);
    }
    max = (l2p1[X]>l2p2[X])? l2p1[X] : l2p2[X];
    min = (l1p1[X]<l1p2[X])? l1p1[X] : l1p2[X];
    if(max<min)
    {
        return(0);
    }
    max = (l1p1[Y]>l1p2[Y])? l1p1[Y] : l1p2[Y];
    min = (l2p1[Y]<l2p2[Y])? l2p1[Y] : l2p2[Y];
    if(max<min)
    {
        return(0);
    }
    max = (l2p1[Y]>l2p2[Y])? l2p1[Y] : l2p2[Y];
    min = (l1p1[Y]<l1p2[Y])? l1p1[Y] : l1p2[Y];
    if(max<min)
    {
        return(0);
    }

    // see if the endpoints of the second segment lie on opposite
    // sides of the first
    a = (l2p1[X]-l1p1[X]) * (l1p2[Y]-l1p1[Y]) -
        (l2p1[Y]-l1p1[Y]) * (l1p2[X]-l1p1[X]);
    b = (l2p2[X]-l1p1[X]) * (l1p2[Y]-l1p1[Y]) -
        (l2p2[Y]-l1p1[Y]) * (l1p2[X]-l1p1[X]);

    if(a!=0.0f && b!=0.0f && a*b>0.0f)
    {
        return(0);
    }
    
    // see if the endpoints of the first segment lie on opposite
    // sides of the second
    c = (l1p1[X]-l2p1[X]) * (l2p2[Y]-l2p1[Y]) -
        (l1p1[Y]-l2p1[Y]) * (l2p2[X]-l2p1[X]);
    d = (l1p2[X]-l2p1[X]) * (l2p2[Y]-l2p1[Y]) -
        (l1p2[Y]-l2p1[Y]) * (l2p2[X]-l2p1[X]);

    if(c!=0.0f && d!=0.0f && c*d>0.0f)
    {
        return(0);
    }

	floatType det = a-b;
	
    // are they colinear?
    if(det==0.0f)
    {
        return(2);
    }

	floatType tdet = -c;
	floatType sdet =  a;
	if(det < 0)
	{
		det=-det;
		sdet=-sdet;
		tdet=-tdet;
	}

	// we return the position on the second segment
	*percent = sdet/det;
	
    return(1);
}



// line,segment
int LineSegIntersect(register floatType *l1p1,register floatType *l1p2,register floatType *l2p1,register floatType *l2p2)
{
//    floatType max,min;
    register floatType a,b;//,c,d;

    // see if the endpoints of the second segment lie on opposite
    // sides of the first line
    a = (l2p1[X]-l1p1[X]) * (l1p2[Y]-l1p1[Y]) -
        (l2p1[Y]-l1p1[Y]) * (l1p2[X]-l1p1[X]);
    b = (l2p2[X]-l1p1[X]) * (l1p2[Y]-l1p1[Y]) -
        (l2p2[Y]-l1p1[Y]) * (l1p2[X]-l1p1[X]);

    if(a!=0.0f && b!=0.0f && a*b>0.0f)
    {
        return(0);
    }
    
    // are they colinear?
    if(a-b==0.0f)
    {
        return(2);
    }

    // skip the actual determination of the point and just return

    return(1);
}



// scrooit, I'm just gonna put this here

// don't seed with 0!
static unsigned long g_randomSeed;
void GameRandomSeed(register unsigned long seed)
{
	g_randomSeed = seed;
}

int GameRandom(void)
{
	return((int)(g_randomSeed=(16807*g_randomSeed)&0x7ffffff));
}
unsigned long GetGameRandomSeed(void)
{
	return(g_randomSeed);
}


// note that this leaves the matrix alone if the lookat is up or down the
// worldUp vector, on the assumption that the last frame's orientation is
// still stored there and is closer to valid than any arbitrary setup we
// could do here.
void M4LookAtAgain(register floatType mf[4][4], floatType eye[3], floatType target[3], floatType worldUp[3])
{
	register floatType distToTarget;
	floatType toTarget[3];
	
	V3Sub(toTarget, target,eye);
	if(distToTarget = V3Len(toTarget))
	{
		V3Cross(mf[SIDE], worldUp,    mf[FORWARD]);
		V3Norm (mf[SIDE]);
		V3Cross(mf[UP],   mf[FORWARD],mf[SIDE]);
	}
//	else
//	{
		// we're sitting right on the target, which makes
		// life hard.

		// use whatever mf[FORWARD] was the last time,
		// since we probably just moved straight forward to land
		// right on the target.  side and up won't change
		// either.
//	}

	V3Set  (mf[POSITION],eye);
}



// use this if you don't have a recent and presumably similar matrix in mf
void M4LookAt(register floatType mf[4][4], floatType eye[3], floatType target[3], floatType worldUp[3])
{
	register floatType distToTarget;
	floatType toTarget[3];
	
	V3Sub(toTarget, target,eye);
	if(!(distToTarget = V3Len(toTarget)))
	{
#if defined(GAME)
#  if !FINAL_ROM
		PrintCustomFault("Bad M4LookAt() matrix, eye==target\n");
#  endif
#else
		printf("Bad M4LookAt() matrix, eye==target\n");
#endif
		// arbitrary but legal substitute
		V3Set(mf[FORWARD],(floatType)1.0,(floatType)0.0,(floatType)0.0);
	}
	else
	{
		V3Div  (mf[FORWARD], toTarget, distToTarget);
	}
	V3Cross(mf[SIDE],     worldUp,     mf[FORWARD]);
	V3Norm (mf[SIDE]);
	V3Cross(mf[UP],       mf[FORWARD], mf[SIDE]);
	V3Set  (mf[POSITION], eye);

	mf[0][3] = (floatType)0.0;
	mf[1][3] = (floatType)0.0;
	mf[2][3] = (floatType)0.0;
	mf[3][3] = (floatType)1.0;
}



// use this if you don't have a recent and presumably similar matrix in mf
void M4LookAtD3D(register floatType mf[4][4], floatType eye[3], floatType target[3], floatType worldUp[3])
{
	register floatType distToTarget;
	floatType toTarget[3];
	

	V3Sub(toTarget, eye, target);
	if(!(distToTarget = V3Len(toTarget)))
	{
#if defined(GAME)
#  if !FINAL_ROM
		PrintCustomFault("Bad M4LookAt() matrix, eye==target\n");
#  endif
#else
		printf("Bad M4LookAt() matrix, eye==target\n");
#endif
		// arbitrary but legal substitute
		V3Set(mf[2], (floatType)-1.0, (floatType)0.0, (floatType)0.0);
	}
	else
	{
		V3Div(mf[2], toTarget, distToTarget);
	}
	V3Cross(mf[0], worldUp, mf[2]);
	V3Norm (mf[0]);
	V3Cross(mf[1], mf[2],   mf[0]);

	// before transpose,
	// mf[2] is forward
	// mf[1] is up
	// mf[0] is side
	
	M4Transpose(mf, mf);

	V3Mul3x3(mf[3], eye, mf);
	V3Neg(mf[3]);

	mf[0][3] = (floatType)0.0;
	mf[1][3] = (floatType)0.0;
	mf[2][3] = (floatType)0.0;
	mf[3][3] = (floatType)1.0;
}



void M4LookAtD3DFlipX(register floatType mf[4][4], floatType eye[3], floatType target[3], floatType worldUp[3])
{
	register floatType distToTarget;
	floatType toTarget[3];
	

	V3Sub(toTarget, eye, target);
	if(!(distToTarget = V3Len(toTarget)))
	{
#if defined(GAME)
#  if !FINAL_ROM
		PrintCustomFault("Bad M4LookAt() matrix, eye==target\n");
#  endif
#else
		printf("Bad M4LookAt() matrix, eye==target\n");
#endif
		// arbitrary but legal substitute
		V3Set(mf[2], (floatType)-1.0, (floatType)0.0, (floatType)0.0);
	}
	else
	{
		V3Div(mf[2], toTarget, distToTarget);
	}
	V3Cross(mf[0], worldUp, mf[2]);
	V3Norm (mf[0]);
	V3Cross(mf[1], mf[2],   mf[0]);

	// before transpose,
	// mf[2] is forward
	// mf[1] is up
	// mf[0] is side
	
	V3Neg(mf[0]);
	M4Transpose(mf, mf);

	V3Mul3x3(mf[3], eye, mf);
	V3Neg(mf[3]);

	mf[0][3] = (floatType)0.0;
	mf[1][3] = (floatType)0.0;
	mf[2][3] = (floatType)0.0;
	mf[3][3] = (floatType)1.0;
}



void M4Frust(floatType dest[4][4], floatType l, floatType r, floatType b, floatType t, floatType n, floatType f)
{
	floatType     n2 = n*2.0f;
	floatType   oo_w =  1.0f/(r-l);
	floatType   oo_h =  1.0f/(t-b);
	floatType n_oo_d = -1.0f/(f-n);

	dest[0][0] =  n2 * oo_w;
	dest[0][1] =  0.0f;
	dest[0][2] =  0.0f;
	dest[0][3] =  0.0f;

	dest[1][0] =  0.0f;
	dest[1][1] =  n2 * oo_h;
	dest[1][2] =  0.0f;
	dest[1][3] =  0.0f;

	dest[2][0] =  (r+l) *   oo_w;
	dest[2][1] =  (t+b) *   oo_h;
#define PERSP_OPENGL
#ifdef PERSP_OPENGL
	dest[2][2] =  (f+n) * n_oo_d;
	dest[2][3] = -1.0f;
#else
	dest[2][2] =    f   * n_oo_d;
	dest[2][3] = -1.0f;
#endif

	dest[3][0] =  0.0f;
	dest[3][1] =  0.0f;
#ifdef PERSP_OPENGL
	dest[3][2] =  (n2*f) * n_oo_d;
#else
	dest[3][2] =  (n*f) * n_oo_d;
#endif
	dest[3][3] =  0.0f;
}



// NOTE: the angle is in RADIANS and is HALF the vertical angle
void M4Persp(floatType dest[4][4], floatType angle, floatType aspect, floatType n, floatType f)
{
	floatType hh = TAN(angle) * n;
	floatType hw = hh * aspect;
	M4Frust(dest,-hw,hw,-hh,hh,n,f);
}

void M4PerspFlipX(floatType dest[4][4], floatType angle, floatType aspect, floatType n, floatType f)
{
	floatType hh = TAN(angle) * n;
	floatType hw = hh * aspect;
	M4Frust(dest,hw,-hw,-hh,hh,n,f);
}


// NOTE: the angle is in RADIANS and is HALF the vertical angle
void M4Ortho(floatType dest[4][4], floatType l, floatType r, floatType b, floatType t, floatType n, floatType f)
{
	floatType oo_w = 1.0f/(r-l);
	floatType oo_h = 1.0f/(t-b);
	floatType oo_d = 1.0f/(f-n);

	dest[0][0] =  2.0f * oo_w;
	dest[0][1] =  0.0f;
	dest[0][2] =  0.0f;
	dest[0][3] =  0.0f;

	dest[1][0] =  0.0f;
	dest[1][1] =  2.0f * oo_h;
	dest[1][2] =  0.0f;
	dest[1][3] =  0.0f;

	dest[2][0] =  0.0f;
	dest[2][1] =  0.0f;
	dest[2][2] = -2.0f * oo_d;
	dest[2][3] =  0.0f;

	dest[3][0] =  (r+l) * oo_w;
	dest[3][1] =  (t+b) * oo_h;
	dest[3][2] =  (f+n) * oo_d;
	dest[3][3] =  1.0f;
}


// rotate the upper 3x3 of dest by angle around axis
void M4Rot3x3(floatType dest[4][4], floatType angle, floatType axis[3])
{
    register floatType s = SIN(angle);
    register floatType c = COS(angle);
    register floatType t = (floatType)1.0-c;

	register floatType ax = axis[X];
	register floatType ay = axis[Y];
	register floatType az = axis[Z];
	
	register floatType taxay  = t*ax;
	register floatType taxaz  = taxay*az;
	taxay *= ay;
	register floatType tayaz  = t*ay*az;

	register floatType sax = s*ax;
	register floatType say = s*ay;
	register floatType saz = s*az;
	
	register floatType x = dest[0][X];
	register floatType y = dest[0][Y];
	register floatType z = dest[0][Z];
	
    dest[0][X] =
        x*(t*ax*ax + c  ) +
        y*(taxay   + saz) +
        z*(taxaz   - say);
    
    dest[0][Y] =
        x*(taxay   - saz) +
        y*(t*ay*ay + c  ) +
        z*(tayaz   + sax);
    
    dest[0][Z] =
        x*(taxaz   + say) +
        y*(tayaz   - sax) +
        z*(t*az*az + c  );
	
	x = dest[1][X];
	y = dest[1][Y];
	z = dest[1][Z];
	
    dest[1][X] =
        x*(t*ax*ax + c  ) +
        y*(taxay   + saz) +
        z*(taxaz   - say);
    
    dest[1][Y] =
        x*(taxay   - saz) +
        y*(t*ay*ay + c  ) +
        z*(tayaz   + sax);
    
    dest[1][Z] =
        x*(taxaz   + say) +
        y*(tayaz   - sax) +
        z*(t*az*az + c  );
	
	x = dest[2][X];
	y = dest[2][Y];
	z = dest[2][Z];
	
    dest[2][X] =
        x*(t*ax*ax + c  ) +
        y*(taxay   + saz) +
        z*(taxaz   - say);
    
    dest[2][Y] =
        x*(taxay   - saz) +
        y*(t*ay*ay + c  ) +
        z*(tayaz   + sax);
    
    dest[2][Z] =
        x*(taxaz   + say) +
        y*(tayaz   - sax) +
        z*(t*az*az + c  );
}



void M4Set(D3DMATRIX *md, floatType mf[4][4])
{
	M4Transpose(md->m,mf);
}


void M4Set(floatType mf[4][4], D3DMATRIX *md)
{
	M4Transpose(mf,md->m);
}



bool V4Equal(floatType *src1, floatType *src2)
{
	return(src1[0] == src2[0] &&
	       src1[1] == src2[1] &&
		   src1[2] == src2[2] &&
		   src1[3] == src2[3]);
}
bool V3Equal(floatType *src1, floatType *src2)
{
	return(src1[0] == src2[0] &&
	       src1[1] == src2[1] &&
		   src1[2] == src2[2]);
}
bool V2Equal(floatType *src1, floatType *src2)
{
	return(src1[0] == src2[0] &&
	       src1[1] == src2[1]);
}



#undef TOLERANCE
#define TOLERANCE 0.000009953976
#undef TOLERABLE
#define TOLERABLE(x) ((x) < -TOLERANCE || (x) > TOLERANCE)

void V2Gouraud4(floatType dest[4], floatType point[2],
			    floatType triVert0[2], floatType triVert1[2], floatType triVert2[2],
			    floatType triSrc0[4],  floatType triSrc1[4],  floatType triSrc2[4])
{
}
void V2Gouraud3(floatType out[3], floatType pos[2],
			    floatType v0[2], floatType v1[2], floatType v2[2],
			    floatType c0[3], floatType c1[3], floatType c2[3])
{
	{	
		// order with respect to Y (tiny bubble sort)
		register floatType *vt;
		#define VSWAP(a,b) vt=v##a;v##a=v##b;v##b=vt;vt=c##a;c##a=c##b;c##b=vt
		if(v1[Y] < v0[Y])
		{
			VSWAP(0,1);
		}
		if(v2[Y] < v1[Y])
		{
			VSWAP(1,2);
		}
		if(v1[Y] < v0[Y])
		{
			VSWAP(0,1);
		}

		// rearrange so that we are between 0 and 1
		// and between 0 and 2
		if(v1[Y] <= pos[Y] && v1[Y]!=v2[Y])
		{
			VSWAP(0,2);
		}
	}

	// get "scan line" endpoint values for gouraud shade
	// TODO - make sure len can't be 0.0
	floatType3 ci0,ci1;
	
	register floatType len;
	register floatType frac;
	register floatType vi0x,vi1x;
	
	register floatType dist = (pos[Y] - v0[Y]);

	// v0-v1 interpolate
	len = v1[Y] - v0[Y];
	frac = TOLERABLE(len)? (dist/len) : 0.0f;
	V3Lerp(ci0,c1,c0,frac);
	ScalarLerp(vi0x,v1[X],v0[X],frac);
	
	// v0-v2 interpolate
	len = v2[Y] - v0[Y];
	frac = TOLERABLE(len)? (dist/len) : 0.0f;
	V3Lerp(ci1,c2,c0,frac);
	ScalarLerp(vi1x,v2[X],v0[X],frac);
	
	// interpolated points v01-v02 interpolate
	dist = pos[X] - vi0x;
	len = vi1x - vi0x;
	frac = TOLERABLE(len)? (dist/len) : 0.0f;
	V3Lerp(out,ci1,ci0,frac);
}
void V2GouraudN(floatType dest[3], floatType point[2], int n,
			    floatType triVert0[2], floatType triVert1[2], floatType triVert2[2],
			    floatType triSrc0[3],  floatType triSrc1[3],  floatType triSrc2[3])
{
}
void V2GouraudFactor(floatType out[3], floatType pos[2],
			    floatType v0[2], floatType v1[2], floatType v2[2])
{
	int from0=0,from1=1,from2=2;
	{	
		// order with respect to Y (tiny bubble sort)
		register floatType *vt;
		register int     ft;
		#undef VSWAP
		#define VSWAP(a,b) vt=v##a;v##a=v##b;v##b=vt;ft=from##a;from##a=from##b;from##b=ft;
		if(v1[Y] < v0[Y])
		{
			VSWAP(0,1);
		}
		if(v2[Y] < v1[Y])
		{
			VSWAP(1,2);
		}
		if(v1[Y] < v0[Y])
		{
			VSWAP(0,1);
		}

		// rearrange so that we are between 0 and 1
		// and between 0 and 2
		if(v1[Y] <= pos[Y] && v1[Y]!=v2[Y])
		{
			VSWAP(0,2);
		}
	}

	// get "scan line" endpoint values for gouraud shade
	// TODO - make sure len can't be 0.0
	floatType3 ci0,ci1;
	
	register floatType len;
	register floatType frac;
	register floatType vi0x,vi1x;
	
	register floatType dist = (pos[Y] - v0[Y]);

	// v0-v1 interpolate
	len = v1[Y] - v0[Y];
	frac = TOLERABLE(len)? (dist/len) : 0.0f;
	V3Set(ci0, 1.0f-frac, frac, 0.0f);
	ScalarLerp(vi0x,v1[X],v0[X],frac);
	
	// v0-v2 interpolate
	len = v2[Y] - v0[Y];
	frac = TOLERABLE(len)? (dist/len) : 0.0f;
	V3Set(ci1, 1.0f-frac, 0.0f, frac);
	ScalarLerp(vi1x,v2[X],v0[X],frac);
	
	// interpolated points v01-v02 interpolate
	dist = pos[X] - vi0x;
	len = vi1x - vi0x;
	frac = TOLERABLE(len)? (dist/len) : 0.0f;
	V3Lerp(ci0,ci1,ci0,frac);

	out[from0] = ci0[0];
	out[from1] = ci0[1];
	out[from2] = ci0[2];
}

// I always use a divisor of a power of 2 because that
// typically executes faster.  not sure of intel processors mind you.
// 1/8192 = ~0.0001
#define V2ONSEG_EPSILON (1.0f / 8192.0f)
bool V2SnapToSeg(floatType *teFrac, floatType p[2], floatType tev0[2], floatType tev1[2])
{
	floatType v[2], n[2], tmp[2];
	V2Sub(v, tev1, tev0);
	floatType len = V2Len(v);
	// TODO - trap len==0.0
	if(len == 0.0f)
	{
//		printf("argh\n");
	}
	V2Div(v, len);
	V2Rot90(n, v);
	V2Sub(tmp, p, tev0);
	floatType dist = V2Dot(n, tmp);
	if(dist < V2ONSEG_EPSILON && dist > -V2ONSEG_EPSILON)
	{
		// on line, is it on seg?
		floatType pos = V2Dot(v, tmp);

		// is it in the latter half of the line?
		if(pos >= (len * 0.5f))
		{
			// yes, reorient so we have more precision near the far vertex
			V2Sub(tmp, p, tev1);
			pos = V2Dot(v, tmp);
			if(pos <= V2ONSEG_EPSILON)  // not too far past far point
			{
				if(pos > 0.0f)
				{
					// if indeed past endpoint, check semicircle on far point
					if(V2DistSq(tev1, p) < (V2ONSEG_EPSILON*V2ONSEG_EPSILON))
					{
						*teFrac = 1.0f;
						return(true);
					}
				}
				else if(pos >= -V2ONSEG_EPSILON)  // close enough to far point?
				{
					// within snapping distance of far point
					*teFrac = 1.0f;
					return(true);
				}
				else
				{
					// else put it where it is on line
					*teFrac = 1.0f + (pos / len);
					return(true);
				}
			}
		}
		else
		{
			if(pos >= -V2ONSEG_EPSILON)
			{
				if(pos < 0.0f)
				{
					// past the endpoint, check a circle around it
					if(V2DistSq(tev0, p) < (V2ONSEG_EPSILON*V2ONSEG_EPSILON))
					{
						*teFrac = 0.0f;
						return(true);
					}
				}
				else if(pos <= V2ONSEG_EPSILON)
				{
					*teFrac = 0.0f;
					return(true);
				}
				else
				{
					*teFrac = pos / len;
					return(true);
				}
			}
		}
	}
	return(false);
}



void V3Ceil(floatType vec[3])
{
	vec[0] = CEIL(vec[0]);
	vec[1] = CEIL(vec[1]);
	vec[2] = CEIL(vec[2]);
}



void V2Ceil(floatType vec[2])
{
	vec[0] = CEIL(vec[0]);
	vec[1] = CEIL(vec[1]);
}



void V3Floor(floatType vec[3])
{
	vec[0] = FLOOR(vec[0]);
	vec[1] = FLOOR(vec[1]);
	vec[2] = FLOOR(vec[2]);
}



void V2Floor(floatType vec[2])
{
	vec[0] = FLOOR(vec[0]);
	vec[1] = FLOOR(vec[1]);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4229\Input.h ===
#ifndef __INPUT_H
#define __INPUT_H

#define SANE_CONTROLLER

// MAXCONTROLLERS is defined by os.h and is a decent signal
// of whether or not it has been included.
#ifndef MAXCONTROLLERS
struct OSContPad;
#endif

#define MAX_CONTROLLERS    4
#define ACTIVE_CONTROLLERS 4

//-----------------------------------------------------------------------------
// input structure
//-----------------------------------------------------------------------------

#define CHEAT_BUFFER_SIZE (1<<5)
#define CHEAT_BUFFER_MASK (CHEAT_BUFFER_SIZE-1)
	
struct Frame;

#define FIRST_REPEAT      0.6f
#define SUBSEQUENT_REPEAT 0.2f

struct InputComponent
{
	float m_repeatTimer;
	float m_repeatInterval;
	bool  m_repeat;

	bool  m_debounced,m_debouncedNeg;

	bool  m_boolValue,m_boolValueNeg;
	int   m_intValue;
	float m_floatValue;

	int   m_digitalMin,m_digitalOrigin,m_digitalMax;

	static float m_GentleDeadSpace(float analog);

	void m_InsertDeadSpace(void) 
	{ 
		m_floatValue = m_GentleDeadSpace(m_floatValue); 
	}

	void m_ApplyDebounce(void);

#define PRESS_THRESHOLD   0.6f
#define RELEASE_THRESHOLD 0.3f

	void m_Set(int v);

	void m_Debounce(void)
	{
		if(m_boolValue)
		{
			m_debounced  = true;

			m_intValue   = 0;
			m_floatValue = 0.0f;
			m_boolValue  = false;
		}
	}
	inline void m_DebouncePos(void) { m_Debounce(); }
	void m_DebounceNeg(void)
	{
		if(m_boolValueNeg)
		{
			m_debouncedNeg = true;

			m_intValue     = 0;
			m_floatValue   = 0.0f;
			m_boolValueNeg = false;
		}
	}

	void m_SetRange(int min,int origin,int max)
	{
		m_digitalMin    = min;
		m_digitalOrigin = origin;
		m_digitalMax    = max;
	}

	void m_Flip(void)
	{
		m_floatValue   = -m_floatValue;
		m_intValue     = -m_intValue;

		bool tmp       = m_boolValue;
		m_boolValue    = m_boolValueNeg;
		m_boolValueNeg = tmp;
	}

	inline void  m_RepeatOn(void)  { m_repeat = true; }
	inline void  m_RepeatOff(void) { m_repeat = false; }

	inline int   m_AsInt(void)      { return(m_intValue); }
	inline float m_AsFloat(void)    { return(m_floatValue); }

	inline bool  m_Pressed(void)    { return(m_boolValue); }
	inline bool  m_PressedPos(void) { return(m_boolValue); }
	inline bool  m_PressedNeg(void) { return(m_boolValueNeg); }

	bool         m_ReallyPressed(void);

	inline bool  m_PressedAndDebounced(void)    { if(m_Pressed())    { m_Debounce();    return(true); } return(false); }
	inline bool  m_PressedPosAndDebounced(void) { if(m_PressedPos()) { m_DebouncePos(); return(true); } return(false); }
	inline bool  m_PressedNegAndDebounced(void) { if(m_PressedNeg()) { m_DebounceNeg(); return(true); } return(false); }

	InputComponent()
	{
		m_repeat       = false;
		m_intValue     = 0;
		m_floatValue   = 0.0f;
		m_boolValue    = false;
		m_boolValueNeg = false;
	}
};

struct InputAnalogButton : public InputComponent
{
	void m_Set(bool v)
	{
		if(m_boolValue = v)
		{
			m_intValue   = 255;
			m_floatValue = 1.0f;
		}
		else
		{
			m_intValue   = 0;
			m_floatValue = 0.0f;
		}
	}

	inline void m_Set(int v) { InputComponent::m_Set(v); }

	void m_Set(unsigned long flags,unsigned long mask)
	{
		if(flags & mask)
		{
			m_boolValue  = true;
			m_intValue   = 255;
			m_floatValue = 1.0f;
		}
		else
		{
			m_boolValue  = false;
			m_intValue   = 0;
			m_floatValue = 0.0f;
		}
	}

	void m_From(InputAnalogButton &b)
	{
		if(b.m_digitalMax    == m_digitalMax   &&
		   b.m_digitalOrigin == m_digitalOrigin)
		{
			m_intValue   = b.m_intValue;
			m_floatValue = b.m_floatValue;
			m_boolValue  = b.m_boolValue;
		}
		else
		{
			InputComponent::m_Set((int)(b.m_floatValue*(m_digitalMax-m_digitalOrigin)));
		}
	}

	InputAnalogButton() : InputComponent()
	{
		m_SetRange(0,0,255);
	}
};

struct InputAnalogAxis : public InputComponent
{
	void m_From(InputAnalogButton &min,InputAnalogButton &max)
	{
		m_Set((int)((max.m_floatValue - min.m_floatValue)*(m_digitalMax-m_digitalOrigin)));
	}

	void m_From(InputAnalogAxis &a)
	{
		if(a.m_digitalMax    == m_digitalMax   &&
		   a.m_digitalMin    == m_digitalMin   &&
		   a.m_digitalOrigin == m_digitalOrigin)
		{
			m_intValue   = a.m_intValue;
			m_floatValue = a.m_floatValue;
			m_boolValue  = a.m_boolValue;
		}
		else
		{
			InputComponent::m_Set((int)(a.m_floatValue*(m_digitalMax-m_digitalOrigin)));
		}
	}

	void m_SetRange(int min,int origin,int max)
	{
		if(min!=-max)
		{
			printf("min!=-max in analog axis\n");
			min = -max;
		}
		InputComponent::m_SetRange(min,origin,max);
	}

	InputAnalogAxis() : InputComponent()
	{
#ifdef SANE_CONTROLLER
		m_SetRange(-105,0,105);
#else
		m_SetRange(-70,0,70);
#endif
	}
};

struct InputAnalogPad
{
	// different from stick because two buttons CAN be pressed at once
	InputAnalogButton m_right;
	InputAnalogButton m_down;
	InputAnalogButton m_left;
	InputAnalogButton m_up;

	void m_From(InputAnalogPad &p)
	{ 
		m_right.m_From(p.m_right); 
		m_down.m_From(p.m_down); 
		m_left.m_From(p.m_left); 
		m_up.m_From(p.m_up); 
	}

	void m_InsertDeadSpace(void) 
	{ 
		m_right.m_InsertDeadSpace();
		m_down.m_InsertDeadSpace();
		m_left.m_InsertDeadSpace();
		m_up.m_InsertDeadSpace();
	}

	// consistent with InputAnalogStick
	inline bool m_PressedUp(void)    { return(m_up.m_Pressed()); }
	inline bool m_PressedDown(void)  { return(m_down.m_Pressed()); }
	inline bool m_PressedRight(void) { return(m_right.m_Pressed()); }
	inline bool m_PressedLeft(void)  { return(m_left.m_Pressed()); }

	void m_ApplyDebounce(void)
	{
		m_right.m_ApplyDebounce();
		m_down.m_ApplyDebounce();
		m_left.m_ApplyDebounce();
		m_up.m_ApplyDebounce();
	}
};

struct InputAnalogStick
{
	// ie input->m_leftStick.m_x.m_asFloat()
	InputAnalogAxis m_x;
	InputAnalogAxis m_y;

	void m_InsertDeadSpace(void) 
	{ 
		m_x.m_InsertDeadSpace();
		m_y.m_InsertDeadSpace();
	}

	void m_From(InputAnalogPad &p) { m_x.m_From(p.m_left,p.m_right); m_y.m_From(p.m_down,p.m_up); }
	void m_From(InputAnalogStick &s) { m_x.m_From(s.m_x); m_y.m_From(s.m_y); }

	// consistent with InputAnalogPad
	inline bool m_PressedUp(void)    { return(m_y.m_PressedPos()); }
	inline bool m_PressedDown(void)  { return(m_y.m_PressedNeg()); }
	inline bool m_PressedRight(void) { return(m_x.m_PressedPos()); }
	inline bool m_PressedLeft(void)  { return(m_x.m_PressedNeg()); }

	void m_ApplyDebounce(void)
	{
		m_x.m_ApplyDebounce();
		m_y.m_ApplyDebounce();
	}
};

struct Input
{
	int m_port;

	// make sure all of these are present in Input::ApplyDebounce()

	// real
	InputAnalogPad    m_pad;

	InputAnalogButton m_a;
	InputAnalogButton m_b;

	InputAnalogButton m_x;
	InputAnalogButton m_y;

	InputAnalogButton m_white;
	InputAnalogButton m_black;

	InputAnalogButton m_lThumb;
	InputAnalogButton m_rThumb;

	InputAnalogButton m_start;
	InputAnalogButton m_back;

	InputAnalogButton m_leftTrigger;
	InputAnalogButton m_rightTrigger;

	InputAnalogStick  m_leftStick;
	InputAnalogStick  m_rightStick;

	// virtual
	InputAnalogButton m_accelerator;
	InputAnalogButton m_reverse;
	InputAnalogButton m_brake;
	InputAnalogButton m_eBrake;

	InputAnalogButton m_gearUp;
	InputAnalogButton m_gearDown;

	InputAnalogPad    m_view;

	InputAnalogAxis   m_steering;

	// for interface
	InputAnalogButton m_left;   // combined from all three sticks
	InputAnalogButton m_right;
	InputAnalogButton m_up;
	InputAnalogButton m_down;

	InputAnalogButton m_ok;     // used for selecting items, clicking ok, etc
	InputAnalogButton m_cancel;   // back out, cancel

	// controller types (for translation from physical to virtual buttons)
	enum Type
	{
		TYPE_A=0
	};
	Type   m_type;
	bool   m_missing;
	
	u16    m_cheatBuffer[CHEAT_BUFFER_SIZE];
	int    m_cheatPos;
	
//	int port;
//	OSContPad *controller;
	
	Frame *m_forFrame;
	
	void   m_CopyBasicInfo(Input *in);
	void   m_UpdateCheats(void);
	void   m_Get(void);
    void   m_Debounce(int p);
    void   m_ApplyDebounce(void);
    void   m_UsePadForAnalog(void);
	void   m_InsertDeadSpace(void);
	void   m_Init(int port);

	// these two are the same but it's more readable to have both
//	inline int Pressed(register int mask)    { return( pad&(unsigned long)mask       ); }
//	inline int AnyPressed(register int mask) { return( pad&(unsigned long)mask       ); }
	// only valid if all are pressed
//	inline int AllPressed(register int mask) { return((pad&(unsigned long)mask)==mask); }
	// these also debounce for you if the return is nonzero
//	int PressedAndDebounced(register int mask);
//	int AllPressedAndDebounced(register int mask);
	// add in buttons
//	inline void Press(register int mask) { pad|=(unsigned long)mask; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4229\PhyEngine.h ===
#ifndef __ENGINE_H
#define __ENGINE_H

#define MAX_GEARS 8

enum
{
	DRIVE_FRONTWHEEL= 0,
	DRIVE_REARWHEEL,
	DRIVE_FOURWHEEL
};

struct PhysicsCar;

struct TRACTION;


struct Engine
{
	PhysicsCar *m_phyCar;   // pointer back to the car to which we belong
	float m_maxRPM;         // (rpm) speed at which power reaches maximum value
	float m_maxPower;         // (kW) maximum power
	float m_enginePower;
	float m_maxAcceleration;
	float m_finalRatio;
	float m_wheelRadius[4];
	float m_engineCoefs[4];
	float m_equivalentMass;
	float m_gearRatio[MAX_GEARS];  // 0 = Reverse, 1-7 = gears 1-7
	float m_shiftPoint[MAX_GEARS-1];   // rad/sec
	float m_accelTorque[4];
	float m_brakeTorque[4];
	float m_brakeFront;
	float m_brakeRear;
	float m_inertiaEngine;
	float m_inertiaWheel;
	float m_inertiaTransmission;
	short m_driveWheels;         // front, rear, four

	int m_gearCount;  // not counting reverse
	int m_currGear;
	float m_revvy;
	float m_acceleration;    // 0.0f to 1.0f  (for Chad's sound stuff)

	bool  m_automatic;

	float m_accelWeight[4];
	float m_brakeWeight[4];

	void m_Init();
	float m_DetermineWheelTorque(float wheelrev, float accIn);
	void m_LimitRevs(float wheelRev,float wheelSpinVel[4]);
	void m_AutoBox(float wheelRev/*, Input *in*/);
	void m_ComputeAccelAndBrakeTorques(float accel, float brake, short isEBrake, 
		                               short isReverse, float torqeMulitplier = 1.0f);
	float m_ComputeWheelAcceleration(float wheelVel, int wheel, float fx);
};

#endif  // __ENGINE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4229\moremath.h ===
#ifndef __MOREMATH_H
#define __MOREMATH_H

#ifndef __FLOATTYPE_H
#include "floattype.h"
#endif

#  include <math.h>

//#define MATH_USE_ASM

#  ifndef X
#    define X 0
#  elif X!=0
#    error "X should be 0!"
#  endif

#  ifndef Y
#    define Y 1
#  elif X!=0
#    error "Y should be 1!"
#  endif

#  ifndef Z
#    define Z 2
#  elif Z!=2
#    error "Z should be 2!"
#  endif

#  ifndef W
#    define W 3
#  elif W!=3
#    error "W should be 3!"
#  endif


#  ifndef FORWARD
#    define FORWARD X
#  elif FORWARD!=X
#    error "FORWARD should be X!"
#  endif

#  ifndef SIDE
#    define SIDE Y
#  elif SIDE!=Y
#    error "SIDE should be Y!"
#  endif

#  ifndef UP
#    define UP Z
#  elif UP!=Z
#    error "UP should be Z!"
#  endif

#  ifndef POSITION
#    define POSITION 3
#  elif POSITION!=3
#    error "POSITION should be 3!"
#  endif


#define GAME_PI     ((floatType)(3.14159265358979323846))
#define GAME_2PI    ((floatType)(3.14159265358979323846*2.0))
#define GAME_PI2    ((floatType)(3.14159265358979323846*0.5))
#define GAME_HALFPI GAME_PI2
	
#define SIN(x)   sinf(x)
#define COS(x)   cosf(x)
#define TAN(x)   tanf(x)
#define ATAN(x)  atanf(x)
#define ACOS(x)  acosf(x)
#define ASIN(x)  asinf(x)
#define SQRT(x)  sqrtf(x)
// note that mypowf is not accurate
#define POW(x,y) powf(x,y)
#define FLOOR(x) floorf(x)
#define FMOD(x,y) fmodf(x,y)
#define CEIL(x) ceilf(x)

#define RAD2DEG     57.295779f
#define RPM2RADPSEC (GAME_2PI / 60.0f)
#define SIGN(x) ((x)>=0.0f? 1.0f: -1.0f)
//#define SGN(x)  ((x)>0.0f?  1:    -1)
#define SIGN_AS(a, y)  ABS(a)*SIGN(y)
#define ABS(x) ((x)>0.0f?(x):-(x))
#define MAX(a,b) ((a)>(b)? (a) : (b))



#define trunci(f) ((int)(truncf(f)))

__forceinline void FloatToInt(int *int_pointer, float f) 
{
	__asm
	{
		fld		f
		mov		edx,int_pointer
		FRNDINT
		fistp	dword ptr [edx];
	}
}



inline void V4Zero(floatType dest[3])
{
	// I cast to long because otherwise the silly compiler
	// copies the zero register to a floating point register
	// before it stores to dest.
#if FLOATTYPE_BITS==64
	((unsigned long long *)dest)[X]=0;
	((unsigned long long *)dest)[Y]=0;
	((unsigned long long *)dest)[Z]=0;
	((unsigned long long *)dest)[W]=0;
#else
	((unsigned long *)dest)[X]=0;
	((unsigned long *)dest)[Y]=0;
	((unsigned long *)dest)[Z]=0;
	((unsigned long *)dest)[W]=0;
#endif
}
inline void V3Zero(floatType dest[3])
{
	// I cast to long because otherwise the silly compiler
	// copies the zero register to a floating point register
	// before it stores to dest.
#if FLOATTYPE_BITS==64
	((unsigned long long *)dest)[X]=0;
	((unsigned long long *)dest)[Y]=0;
	((unsigned long long *)dest)[Z]=0;
#else
	((unsigned long *)dest)[X]=0;
	((unsigned long *)dest)[Y]=0;
	((unsigned long *)dest)[Z]=0;
#endif
}
inline void V2Zero(floatType dest[2])
{
	// I cast to long because otherwise the silly compiler
	// copies the zero register to a floating point register
	// before it stores to dest.
#if FLOATTYPE_BITS==64
	((unsigned long long *)dest)[X]=0;
	((unsigned long long *)dest)[Y]=0;
#else
	((unsigned long *)dest)[X]=0;
	((unsigned long *)dest)[Y]=0;
#endif
}

#ifdef INLINE_VECTOR_SET
inline void V4Set(register floatType dest[4],register floatType x,register floatType y,register floatType z,register floatType w)
{
	dest[X]=x;
	dest[Y]=y;
	dest[Z]=z;
	dest[W]=w;
}

inline void V3Set(register floatType dest[3],register floatType x,register floatType y,register floatType z)
{
	dest[X]=x;
	dest[Y]=y;
	dest[Z]=z;
}

inline void V2Set(register floatType dest[2],register floatType x,register floatType y)
{
	dest[X]=x;
	dest[Y]=y;
}

inline void V4Set(register floatType dest[4],register floatType src[4])
{
	dest[X]=src[X];
	dest[Y]=src[Y];
	dest[Z]=src[Z];
	dest[W]=src[W];
}

inline void V3Set(register floatType dest[3],register floatType src[3])
{
	dest[X]=src[X];
	dest[Y]=src[Y];
	dest[Z]=src[Z];
}

inline void V2Set(register floatType dest[2],register floatType src[2])
{
	dest[X]=src[X];
	dest[Y]=src[Y];
}
#else
void V4Set(register floatType dest[4],register floatType x,register floatType y,register floatType z,register floatType w);
void V3Set(register floatType dest[3],register floatType x,register floatType y,register floatType z);
void V2Set(register floatType dest[2],register floatType x,register floatType y);
void V4Set(register floatType dest[4],register floatType src[4]);
void V3Set(register floatType dest[3],register floatType src[3]);
void V2Set(register floatType dest[2],register floatType src[2]);
void V3Set(floatType dest[3],short src[3]);
#endif



void V4Plane(floatType *dest, floatType *src1, floatType *src2, floatType *src3);

void V3Cross(floatType dest[3],floatType src1[3],floatType src2[3]);
void V2Rot90(floatType dest[2],floatType src[2]);
void V2RotNeg90(floatType dest[2],floatType src[2]);
floatType V2Cross(floatType src1[2],floatType src2[2]);
void V2Mul(floatType dest[2],floatType src1[2],floatType src2[2]);
void V2Mul(floatType dest[2],floatType src[2],floatType mult);
void V2Mul(floatType dest[2],floatType src[2]);
void V2Mul(floatType dest[2],floatType mult);
void V3Mul(floatType dest[3],floatType src1[3],floatType src2[3]);
void V3Mul(floatType dest[3],floatType src[3],floatType mult);
void V3Mul(floatType dest[3],floatType src[3]);
void V3Mul(floatType dest[3],floatType mult);
void V4Mul(floatType dest[3],floatType src1[3],floatType src2[3]);
void V4Mul(floatType dest[3],floatType src[3],floatType mult);
void V4Mul(floatType dest[3],floatType src[3]);
void V4Mul(floatType dest[3],floatType mult);
void V2Div(floatType dest[2],floatType src[2],floatType div);
void V2Div(floatType dest[2],floatType div);
void V3Div(floatType dest[3],floatType src[3],floatType div);
void V3Div(floatType dest[3],floatType div);
// normalize v or src
void V3Norm(floatType v[3]);
void V2Norm(floatType v[2]);
void V3Norm(floatType dest[3],floatType src[3]);
void V2Norm(floatType dest[2],floatType src[2]);
// normal pointing from first to second arg
void V3Norm(floatType dest[3],floatType from[3],floatType to[3]);
void V2Norm(floatType dest[2],floatType from[2],floatType to[2]);
// normal pointing out of plane of p0,p1,p2
void V3Norm(floatType dest[3],floatType p0[3],floatType p1[3],floatType p2[3]);
void V3Sub(floatType dest[3],floatType src1[3],floatType src2[3]);
void V3Sub(floatType dest[3],floatType src[3]);
void V2Sub(floatType dest[2],floatType src1[2],floatType src2[2]);
void V2Sub(floatType dest[3],floatType src[3]);
void V2Add(floatType dest[2],floatType src1[2],floatType src2[2]);
void V2Add(floatType dest[2],floatType src[2]);
void V3Add(floatType dest[3],floatType src1[3],floatType src2[3]);
void V3Add(floatType dest[3],floatType src[3]);
// l is the amount of src1 you want, 1-l is how much src2
void V4Lerp(floatType dest[4],floatType src1[4],floatType src2[4],floatType l);
void V3Lerp(floatType dest[3],floatType src1[3],floatType src2[3],floatType l);
void V2Lerp(floatType dest[2],floatType src1[2],floatType src2[2],floatType l);
#define ScalarLerp(d,s1,s2,p) d=((s1)-(s2))*(p)+(s2)
#define ScalarSet(d,s) d=(s)
void V3Mac(floatType dest[3],floatType src1[3],floatType src2[3],floatType s);
void V3Mac(floatType dest[3],floatType src[3],floatType s);
void V2Mac(floatType dest[2],floatType src1[2],floatType src2[2],floatType s);
void V2Mac(floatType dest[2],floatType src[2],floatType s);
void V3Avg(floatType dest[3],floatType src1[3],floatType src2[3]);
void V2Avg(floatType dest[2],floatType src1[2],floatType src2[2]);
floatType V2Dist(floatType dest[2],floatType src[2]);
floatType V2DistSq(floatType dest[2],floatType src[2]);
floatType V3Dist(floatType dest[3],floatType src[3]);
floatType V3DistSq(floatType dest[3],floatType src[3]);
floatType V3Len(floatType v[3]);
floatType V3LenSq(floatType v[3]);
floatType V2Len(floatType v[2]);
floatType V2LenSq(floatType v[2]);
floatType V3Dot(floatType v1[3],floatType v2[3]);
floatType V2Dot(floatType v1[2],floatType v2[2]);
void V3Rot(floatType dest[3],floatType angle,floatType axis[3]);
void V2Rot(floatType dest[3],floatType angle);
void V3Neg(floatType dest[3],floatType src[3]);
void V3Neg(floatType dest[3]);
void V2Neg(floatType dest[2],floatType src[2]);
void V2Neg(floatType dest[2]);

// some matrix stuff
void V3Mul4x4(floatType dest[3],floatType src1[3],floatType src2[4][4]);
void V3Mul4x3(register floatType dest[3],register floatType src1[3],register floatType src2[4][4]);
void V3Mul4x4_XY(floatType dest[3],floatType src1[3],floatType src2[4][4]);
void V3Mul4x3_XY(floatType dest[3],floatType src1[3],floatType src2[4][4]);
void V3Mul4x4_XYZW(floatType dest[4],floatType src1[3],floatType src2[4][4]);
void VS3Mul4x4_XYZW(floatType dest[4],short src1[3],floatType src2[4][4]);
void V3Mul3x4(floatType dest[3],floatType src1[3],floatType src2[4][4]);
void V3Mul3x3(floatType dest[3],floatType src1[3],floatType src2[4][4]);
void V3Mul3x3T(floatType dest[3],floatType src1[3],floatType src2[4][4]);
void V3Mul3x3_XY(floatType dest[3],floatType src1[3],floatType src2[4][4]);
	
void M4Mul(floatType dest[4][4],floatType src1[4][4],floatType src2[4][4]);
void M4Mul(floatType dest[4][4],floatType src1[4][4]);
void M4Mul3x3(floatType dest[4][4],floatType src1[4][4],floatType src2[4][4]);
void M4Mul4x3(floatType dest[4][4],floatType src1[4][4],floatType src2[4][4]);
void M4Mul4x3(floatType dest[4][4],floatType src[4][4]);
void M4PreMul4x3(floatType dest[4][4],floatType src[4][4]);
void M4Transpose(floatType dest[4][4],floatType src[4][4]);
void M4Transpose3x3(floatType dest[4][4],floatType src[4][4]);
void M4Set(floatType dest[4][4],floatType src[4][4]);
void M4Ident(floatType mf[4][4]);
void M4Scale3x3(floatType dest[4][4],floatType scale);

typedef struct _D3DMATRIX D3DMATRIX;
void M4Set(D3DMATRIX *md, floatType mf[4][4]);
void M4Set(floatType mf[4][4],D3DMATRIX *md);

void M4ViewFromOriginCamera(register floatType vm[4][4],register floatType cm[4][4]);

void M4FromXYZRot(register floatType dest[4][4],register floatType rx,register floatType ry,register floatType rz);
void M4FromYZXRot(register floatType dest[4][4],register floatType rx,register floatType ry,register floatType rz);
void M4Joint(floatType m[4][4],floatType scale,floatType translateIn[3],floatType rotate[3],floatType translateOut[3]);
void M4WeightedJoint(floatType m[4][4],floatType scale,floatType translateIn[3],floatType rotate[3],floatType translateOut[3],floatType weight);

int  M4Inv(floatType out[4][4],floatType in[4][4]);
void M4OrthoInv(floatType out[4][4],floatType in[4][4]);

void M4Align(floatType mf[4][4],floatType up[3],floatType target[3],floatType pos[3]);
void M4Align(floatType mf[4][4],floatType up[3],floatType forward[3]);
	
float mypowf(float x,float y);
floatType table_sinf(floatType a);
floatType table_cosf(floatType a);

floatType CoarseAngle(floatType x,floatType y);

bool V3InTri(floatType *p, floatType *v0, floatType *v1, floatType *v2, floatType *n);
bool V3InTri(floatType *p, floatType *v0, floatType *v1, floatType *v2, floatType *n, floatType tolerance);
bool V2InTri(floatType *p, floatType *v0, floatType *v1, floatType *v2);
bool V2InTri(floatType *p, floatType *v0, floatType *v1, floatType *v2, floatType *n, floatType tolerance);
bool V2OnTri(floatType *p, floatType *v0, floatType *v1, floatType *v2);
bool V2OnTri(floatType *p, floatType *v0, floatType *v1, floatType *v2, floatType *n, floatType tolerance);
int  SegIntersect(floatType *l1p1,floatType *l1p2,floatType *l2p1,floatType *l2p2);
int  SegIntersect(floatType *l1p1,floatType *l1p2,floatType *l2p1,floatType *l2p2,floatType *percent);
int  LineSegIntersect(floatType *l1p1,floatType *l1p2,floatType *l2p1,floatType *l2p2);

void M4RotFromUF(floatType mat[4][4]);
int  positionInsideTriangle(floatType *p, floatType *v0, floatType *v1, floatType *v2, floatType *n, floatType tolerance);

void M4LookAt(register floatType mf[4][4], floatType eye[3], floatType target[3], floatType worldUp[3]);
void M4LookAtD3D(register floatType mf[4][4], floatType eye[3], floatType target[3], floatType worldUp[3]);
void M4LookAtD3DFlipX(register floatType mf[4][4], floatType eye[3], floatType target[3], floatType worldUp[3]);
// NOTE: the angle is in RADIANS and is HALF the vertical angle
void M4Persp(floatType dest[4][4], floatType angle, floatType aspect, floatType n, floatType f);
void M4PerspFlipX(floatType dest[4][4], floatType angle, floatType aspect, floatType n, floatType f);
void M4Frust(floatType dest[4][4], floatType l, floatType r, floatType b, floatType t, floatType n, floatType f);
void M4Ortho(floatType dest[4][4], floatType l, floatType r, floatType b, floatType t, floatType n, floatType f);
#define M4OrthoFlipX(dest, l,r, b,t, n,f) M4Ortho(dest, r,l, b,t, n,f)

// rotate dest's upper 3x3 by angle around axis
void M4Rot3x3(floatType dest[4][4], floatType angle, floatType axis[3]);


bool V4Equal(floatType src1[4], floatType src2[4]);
bool V3Equal(floatType src1[3], floatType src2[3]);
bool V2Equal(floatType src1[2], floatType src2[2]);

bool V2OnSeg(floatType *teFrac, floatType p[2], floatType tev0[2], floatType tev1[2]);
// snaps to segment and also snaps to 0.0,1.0 if near the endpoint
bool V2SnapToSeg(floatType *teFrac, floatType p[2], floatType tev0[2], floatType tev1[2]);

void V2Gouraud4(floatType dest[4], floatType point[2],
			    floatType triVert0[2], floatType triVert1[2], floatType triVert2[2],
			    floatType triSrc0[4],  floatType triSrc1[4],  floatType triSrc2[4]);
void V2Gouraud3(floatType dest[3], floatType point[2],
			    floatType triVert0[2], floatType triVert1[2], floatType triVert2[2],
			    floatType triSrc0[3],  floatType triSrc1[3],  floatType triSrc2[3]);
void V2Gouraud2(floatType dest[2], floatType point[2],
			    floatType triVert0[2], floatType triVert1[2], floatType triVert2[2],
			    floatType triSrc0[2],  floatType triSrc1[2],  floatType triSrc2[2]);
void V2GouraudN(floatType dest[], floatType point[2], int n,
			    floatType triVert0[2], floatType triVert1[2], floatType triVert2[2],
			    floatType triSrc0[],   floatType triSrc1[],   floatType triSrc2[]);

void V3Ceil(floatType vec[3]);
void V2Ceil(floatType vec[2]);
void V3Floor(floatType vec[3]);
void V2Floor(floatType vec[2]);

void GameRandomSeed(unsigned long seed);
int  GameRandom(void);
unsigned long GetGameRandomSeed(void);

#ifdef GAME
void InitSinTable(void);

// for #ifdef GAME
#endif

// for #ifndef __GAMEMATH
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4229\names.h ===
#ifndef __NAMES_H
#define __NAMES_H

/* NOTE: FINAL_ROM is now defined 1/0 by the MSDev configuration */

/*#if defined(_LANGUAGE_C) || defined(_LANGUAGE_C_PLUS_PLUS)*/
#  if !FINAL_ROM
/* special version per person/station */
/* these values are set based on person.h */
/* do NOT include person.h! */
extern bool g_brian;
extern bool g_derek;
extern bool g_chris;
extern bool g_richard;
extern bool g_rob;
extern bool g_colin;
extern bool g_chad;
extern bool g_msBuild;
extern bool g_testersBuild;
extern bool g_artistsBuild;
#  endif
/*#endif*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4229\PhysicsCar.cxx ===
#include "Game.h"

#include "names.h"
#include "types.h"
#include "physicscar.h"
#include <string.h>
#include <stdio.h>
#include "moremath.h"
#include "input.h"
#include "PhyTrack.h"
#include "CarWheelNumbers.h"
#include "SurfaceType.h"


#define WQ 0
#define XQ 1
#define YQ 2
#define ZQ 3
#define POSVELOFFSET        3
#define QUATOFFSET          6
#define ROTVELOFFSET       10
#define WHEELOFFSET        13
#define WHEELVELOFFSET     25
#define WHEELSPINOFFSET    37
//#define WHEELTANSLIPOFFSET 41
#define NUMBEROFEQU        41

#define THREE_FOURTHS 0.75f
#define TWO_THIRDS    0.66666666f
#define ONE_THIRD     0.33333333f

#define MAX_LINE_LENGTH   1000  // needs to be bigger than longest line in .phycar file. (text version)

#define MYTIMESTEP					1.0f/300.0f
#define MIN_TIME_STEP               1.0f/(300.0f*4.0f)
#define INTEGRATORLOOPCOUNT			20  
#define MAXGROUNDFORCE				20000  // Newtons
#define EPS                         0.0001f
#define SPRING_Y_CONNECTION_POINT   0.75f

#define INITIALSUSPENSIONANGLE		0.3f

#define FRONTALAREA                 2.0f
#define AIRDENSITY                  1.2256f
#define ROLLING_RESISTANCE          120.0f
#define GIMBLE_LOCK_ANGLE           0.82f   // 35 degrees
#define GIMBLE_LOCK_ROT_ADJUST     -0.2f
#define MIN_PENETRATION_DIST       -0.1f



// boolean defines for testing
#define LOCK_STEERING 0
#define LEVEL_GROUND  0
#define TESTING_WALLS 0

#define VECBYQUAT(r,v,q)  {(r)[0] = -(v)[0]*(q)[1] - (v)[1]*(q)[2] - (v)[2]*(q)[3]; \
                           (r)[1] =  (q)[0]*(v)[0] + (v)[1]*(q)[3] - (v)[2]*(q)[2]; \
                           (r)[2] =  (q)[0]*(v)[1] + (v)[2]*(q)[1] - (v)[0]*(q)[3]; \
                           (r)[3] =  (q)[0]*(v)[2] + (v)[0]*(q)[2] - (v)[1]*(q)[1];}

#define QLENGTH(a)        sqrtf((a)[0]*(a)[0] + (a)[1]*(a)[1] + (a)[2]*(a)[2] + (a)[3]*(a)[3])


void QNORMALISE(register float* q) 
{
  register float oolen = 1.0f/QLENGTH(q);
  q[0]=(q[0]*oolen);
  q[1]=(q[1]*oolen);
  q[2]=(q[2]*oolen);
  q[3]=(q[3]*oolen);
}

void EulerToQuat(float roll, float pitch, float yaw, float *quat)
{
	float cr,cp,cy,sr,sp,sy;
	cr = COS(roll/2.0f);
	cp = COS(pitch/2.0f);
	cy = COS(yaw/2.0f);

	sr = SIN(roll/2.0f);
	sp = SIN(pitch/2.0f);
	sy = SIN(yaw/2.0f);

	// order is important
	// roll, pitch, yaw
	float cpcy = cp * cy;
	float spsy = sp * sy;

	quat[0] = cr * cpcy + sr * spsy;
	quat[1] = sr * cpcy - cr * spsy;
	quat[2] = cr * sp * cy + sr * cp * sy;
	quat[3] = cr * cp * sy - sr * sp * cy;
}


const float g_groundSlowTable[SURFACETYPE_COUNT] = 
{
	1.0f,   // road
	10.0f,   // runofff
	50.0f,  // sand
	20.0f    // grass
};

const float g_jostleTable[SURFACETYPE_COUNT] = 
{
	0.0f,   // road
	(0.06f/(float)(0x7ffffff)),
	(0.10f/(float)(0x7ffffff)),
	(0.03f/(float)(0x7ffffff)),
};

const float g_tireXSlowTable[SURFACETYPE_COUNT] = 
{
	0.0f,   // road
	100.0f,
	200.0f,
	100.0f,
};

const float g_tireYSlowTable[SURFACETYPE_COUNT] = 
{
	0.0f,   // road
	300.0f,
	300.0f,
	300.0f,
};

// g_contraintX is the wheel contraint keeping the wheel in the YZ plane, ie. X vector
float g_constraintX[3] = 
{
	1.0f, 0.0f, 0.0f
};

float g_gravity[3] =
{
	0.0f, 0.0f, -9.8f
};

float XMATRIX[3][4]=
{
	{1.0f/290.0f, 0.0f,          0.0f,         0.0f},
	{0.0f,        1.0f/1094.0f,  0.0f,         0.0f},
	{0.0f,        0.0f,          1.0f/1210.0f, 0.0f}
};

float IMATRIX[3][4] =
{
	{290.0f,    0.0f,    0.0f, 0.0f},
	{  0.0f, 1094.0f,    0.0f, 0.0f},
	{  0.0f,    0.0f, 1210.0f, 0.0f}
};



//extern CCarConstructorApp theApp;
//extern PhyTrack g_phyTrack;

float g_nDotR1 = 0.0f;
float g_nDotR2 = 0.0f;
float g_nDotR = 0.0f;
float g_rDotR = 0.0f;
#ifdef CAR_CONSTRUCTOR
JOYINFO g_joyInfo;


extern short g_accelTest;
short Accel()
{
	if (g_accelTest)
	{
		return (TRUE);
	}
	MMRESULT result = joyGetPos(JOYSTICKID1,&g_joyInfo);
	if (result == JOYERR_NOERROR)
	{
		if (g_joyInfo.wButtons & JOY_BUTTON1)
		{
			return (true);
		}
	}
	return (false);
}
short Brake()
{
	MMRESULT result = joyGetPos(JOYSTICKID1,&g_joyInfo);
	if (result == JOYERR_NOERROR)
	{
		if (g_joyInfo.wButtons & JOY_BUTTON2)
		{
			return (true);
		}
	}
	return (false);
}
short Reverse()
{
	MMRESULT result = joyGetPos(JOYSTICKID1,&g_joyInfo);
	if (result == JOYERR_NOERROR)
	{
		if (g_joyInfo.wButtons & JOY_BUTTON3)
		{
			return (true);
		}
	}
	return (false);
}
#endif


void ReadInShort(char *token,short *offset)
{
	int i=0;
	char seps[] = " ,";
	while( token != NULL )
	{
		token = strtok( NULL, seps );
		if (token)
		{
			offset[i] = (short)atoi(token);
		}
		i++;
	}
}

void ReadInInt(char *token,int *offset)
{
	int i=0;
	char seps[] = " ,";
	while( token != NULL )
	{
		token = strtok( NULL, seps );
		if (token)
		{
			offset[i] = atoi(token);
		}
		i++;
	}
}

void ReadInFloats(char *token,float *offset)
{
	int i=0;
	char seps[] = " ,";
	while( token != NULL )
	{
		token = strtok( NULL, seps );
		if (token)
		{
			sscanf(token,"%f",&offset[i]);
		}
		i++;
	}
}


void PhysicsCar::m_InitCar()
{
}


int PhysicsCar::m_LoadCar(char *filename)
{
	FILE *fp;
	fp = fopen(filename, "rb");
	if (!fp)
	{
#ifdef GAME
		PrintCustomFault("Cannot open file for reading: \"%s\" (Read Error)", filename);
#else
		MessageBox(NULL,"Cannot open file for reading.","Read Error",MB_OK);
		return FALSE;
#endif
	}
	
#if !FINAL_ROM
#endif
	{
		memset(this,0,sizeof(PhysicsCar));
	}
	m_suspension.m_Init();
	m_engine.m_Init();

	// until steertable is saved off in car structure
	m_steerTable[0] = 0.6000f;
	m_steerTable[1] = 0.5500f;
	m_steerTable[2] = 0.5000f;
	m_steerTable[3] = 0.3500f;
	m_steerTable[4] = 0.2000f;
	m_steerTable[5] = 0.1600f;
	m_steerTable[6] = 0.1300f;
	m_steerTable[7] = 0.1025f;
	m_steerTable[8] = 0.0900f;
	m_steerTable[9] = 0.0825f;
	m_steerTable[10] = 0.0750f;
	m_steerTable[11] = 0.0675f;
	m_steerTable[12] = 0.0600f;
	m_steerTable[13] = 0.0525f;
	m_steerTable[14] = 0.0450f;
	m_steerTable[15] = 0.0450f;

	char tmp[MAX_LINE_LENGTH+1];
	char seps[] = " ,";
	char *token;
	while (!feof(fp))
	{
		fgets(tmp,MAX_LINE_LENGTH,fp);
		token = strtok( tmp, seps);
		if (!strcmp(tmp,"m_bodyMass"))
		{
			ReadInFloats(token,&m_bodyMass);
		}
		else if (!strcmp(tmp,"m_invBodyMass"))
		{
			ReadInFloats(token,&m_invBodyMass);
		}
		else if (!strcmp(tmp,"m_wheelMass"))
		{
			ReadInFloats(token,&m_wheelMass);
		}
		else if (!strcmp(tmp,"m_invWheelMass"))
		{
			ReadInFloats(token,&m_invWheelMass);
		}
		else if (!strcmp(tmp,"m_tireRelaxLength"))
		{
			ReadInFloats(token,&m_tireRelaxLength);
		}
		else if (!strcmp(tmp,"m_bodyOffset"))
		{
			ReadInFloats(token,&m_bodyOffset[0]);
		}
		else if (!strcmp(tmp,"m_width"))
		{
			ReadInFloats(token,&m_width);
		}
		else if (!strcmp(tmp,"m_height"))
		{
			ReadInFloats(token,&m_height);
		}
		else if (!strcmp(tmp,"m_length"))
		{
			ReadInFloats(token,&m_length);
		}
		else if (!strcmp(tmp,"m_boxOffset"))
		{
			ReadInFloats(token,&m_boxOffset);
		}
		else if (!strcmp(tmp,"m_iMatrix1"))
		{
			ReadInFloats(token,&m_iMatrix[0][0]);
		}
		else if (!strcmp(tmp,"m_iMatrix2"))
		{
			ReadInFloats(token,&m_iMatrix[1][0]);
		}
		else if (!strcmp(tmp,"m_iMatrix3"))
		{
			ReadInFloats(token,&m_iMatrix[2][0]);
		}
		else if (!strcmp(tmp,"m_xMatrix1"))
		{
			ReadInFloats(token,&m_xMatrix[0][0]);
		}
		else if (!strcmp(tmp,"m_xMatrix2"))
		{
			ReadInFloats(token,&m_xMatrix[1][0]);
		}
		else if (!strcmp(tmp,"m_xMatrix3"))
		{
			ReadInFloats(token,&m_xMatrix[2][0]);
		}
		else if (!strcmp(tmp,"m_stabilizerBar"))
		{
			ReadInFloats(token,&m_stabilizerBar[0]);
		}
		else if (!strcmp(tmp,"m_wheelToe"))
		{
			ReadInFloats(token,&m_wheelToe);
		}
		else if (!strcmp(tmp,"m_differential"))
		{
			ReadInFloats(token,&m_differential[0]);
		}
		else if (!strcmp(tmp,"m_aeroDrag"))
		{
			ReadInFloats(token,&m_aeroDrag);
		}
		else if (!strcmp(tmp,"m_aeroFront"))
		{
			ReadInFloats(token,&m_aeroFront);
		}
		else if (!strcmp(tmp,"m_aeroRear"))
		{
			ReadInFloats(token,&m_aeroRear);
		}
		else if (!strcmp(tmp,"m_steerTable"))
		{
			ReadInFloats(token,&m_steerTable[0]);
		}
		// engine crap
		else if (!strcmp(tmp,"m_maxRPM"))
		{
			ReadInFloats(token,&m_engine.m_maxRPM);
		}
		else if (!strcmp(tmp,"m_maxPower"))
		{
			ReadInFloats(token,&m_engine.m_maxPower);
		}
		else if (!strcmp(tmp,"m_enginePower"))
		{
			ReadInFloats(token,&m_engine.m_enginePower);
		}
		else if (!strcmp(tmp,"m_maxAcceleration"))
		{
			ReadInFloats(token,&m_engine.m_maxAcceleration);
		}
		else if (!strcmp(tmp,"m_finalRatio"))
		{
			ReadInFloats(token,&m_engine.m_finalRatio);
		}
		else if (!strcmp(tmp,"m_wheelRadius"))
		{
			ReadInFloats(token,&m_engine.m_wheelRadius[0]);
		}
		else if (!strcmp(tmp,"m_engineCoefs"))
		{
			ReadInFloats(token,&m_engine.m_engineCoefs[0]);
		}
		else if (!strcmp(tmp,"m_equivalentMass"))
		{
			ReadInFloats(token,&m_engine.m_equivalentMass);
		}
		else if (!strcmp(tmp,"m_gearRatio"))
		{
			ReadInFloats(token,&m_engine.m_gearRatio[0]);
		}
		else if (!strcmp(tmp,"m_shiftPoint"))
		{
			ReadInFloats(token,&m_engine.m_shiftPoint[0]);
		}
		else if (!strcmp(tmp,"m_brakeFront"))
		{
			ReadInFloats(token,&m_engine.m_brakeFront);
		}
		else if (!strcmp(tmp,"m_brakeRear"))
		{
			ReadInFloats(token,&m_engine.m_brakeRear);
		}
		else if (!strcmp(tmp,"m_inertiaEngine"))
		{
			ReadInFloats(token,&m_engine.m_inertiaEngine);
		}
		else if (!strcmp(tmp,"m_inertiaWheel"))
		{
			ReadInFloats(token,&m_engine.m_inertiaWheel);
		}
		else if (!strcmp(tmp,"m_inertiaTransmission"))
		{
			ReadInFloats(token,&m_engine.m_inertiaTransmission);
		}
		else if (!strcmp(tmp,"m_driveWheels"))
		{
			ReadInShort(token,&m_engine.m_driveWheels);
		}
		else if (!strcmp(tmp,"m_gearCount"))
		{
			ReadInInt(token,&m_engine.m_gearCount);
		}
		// suspension settings
		else if (!strcmp(tmp,"m_springLength"))
		{
			ReadInFloats(token,&m_suspension.m_springLength[0]);
		}
		else if (!strcmp(tmp,"m_springConstA"))
		{
			ReadInFloats(token,&m_suspension.m_springConstA[0]);
		}
		else if (!strcmp(tmp,"m_springConstB"))
		{
			ReadInFloats(token,&m_suspension.m_springConstB[0]);
		}
		else if (!strcmp(tmp,"m_springDamper"))
		{
			ReadInFloats(token,&m_suspension.m_springDamper[0]);
		}
		else if (!strcmp(tmp,"m_initialCamber"))
		{
			ReadInFloats(token,&m_suspension.m_initialCamber[0]);
		}
		else if (!strcmp(tmp,"m_rollCenter1"))
		{
			ReadInFloats(token,&m_suspension.m_rollCenter[0][0]);
		}
		else if (!strcmp(tmp,"m_rollCenter2"))
		{
			ReadInFloats(token,&m_suspension.m_rollCenter[1][0]);
		}
		else if (!strcmp(tmp,"m_rollCenter3"))
		{
			ReadInFloats(token,&m_suspension.m_rollCenter[2][0]);
		}
		else if (!strcmp(tmp,"m_rollCenter4"))
		{
			ReadInFloats(token,&m_suspension.m_rollCenter[3][0]);
		}
		else if (!strcmp(tmp,"m_springBodyPoint1"))
		{
			ReadInFloats(token,&m_suspension.m_springBodyPoint[0][0]);
		}
		else if (!strcmp(tmp,"m_springBodyPoint2"))
		{
			ReadInFloats(token,&m_suspension.m_springBodyPoint[1][0]);
		}
		else if (!strcmp(tmp,"m_rollCenterFrontTable"))
		{
			ReadInFloats(token,&m_suspension.m_rollCenterFrontTable[0]);
		}
		else if (!strcmp(tmp,"m_rollCenterRearTable"))
		{
			ReadInFloats(token,&m_suspension.m_rollCenterRearTable[0]);
		}
		else if (!strcmp(tmp,"m_rcToWheelLengthTable1"))
		{
			ReadInFloats(token,&m_suspension.m_rcToWheelLengthTable[0][0]);
		}
		else if (!strcmp(tmp,"m_rcToWheelLengthTable2"))
		{
			ReadInFloats(token,&m_suspension.m_rcToWheelLengthTable[1][0]);
		}
		else if (!strcmp(tmp,"m_camberTable1"))
		{
			ReadInFloats(token,&m_suspension.m_camberTable[0][0]);
		}
		else if (!strcmp(tmp,"m_camberTable2"))
		{
			ReadInFloats(token,&m_suspension.m_camberTable[1][0]);
		}
		else if (!strcmp(tmp,"m_maxSpringCompression"))
		{
			ReadInFloats(token,&m_suspension.m_maxSpringCompression);
		}
		// Tire settings
		else if (!strcmp(tmp,"m_baseLoad1"))
		{
			ReadInFloats(token,&m_tire[0].m_baseLoad);
		}
		else if (!strcmp(tmp,"m_corneringStiffness1"))
		{
			ReadInFloats(token,&m_tire[0].m_corneringStiffness);
		}
		else if (!strcmp(tmp,"m_csSensitivityToFv1"))
		{
			ReadInFloats(token,&m_tire[0].m_csSensitivityToFv);
		}
		else if (!strcmp(tmp,"m_muY1"))
		{
			ReadInFloats(token,&m_tire[0].m_muY);
		}
		else if (!strcmp(tmp,"m_muX1"))
		{
			ReadInFloats(token,&m_tire[0].m_muX);
		}
		else if (!strcmp(tmp,"m_muYSensitivityToFv1"))
		{
			ReadInFloats(token,&m_tire[0].m_muYSensitivityToFv);
		}
		else if (!strcmp(tmp,"m_muXSensitivityToFv1"))
		{
			ReadInFloats(token,&m_tire[0].m_muXSensitivityToFv);
		}
		else if (!strcmp(tmp,"m_camberStiffness1"))
		{
			ReadInFloats(token,&m_tire[0].m_camberStiffness);
		}
		else if (!strcmp(tmp,"m_longStiffness1"))
		{
			ReadInFloats(token,&m_tire[0].m_longStiffness);
		}
		else if (!strcmp(tmp,"m_a1"))
		{
			ReadInFloats(token,&m_tire[0].m_a);
		}
		else if (!strcmp(tmp,"m_b1"))
		{
			ReadInFloats(token,&m_tire[0].m_b);
		}
		else if (!strcmp(tmp,"m_c1"))
		{
			ReadInFloats(token,&m_tire[0].m_c);
		}
		else if (!strcmp(tmp,"m_d1"))
		{
			ReadInFloats(token,&m_tire[0].m_d);
		}
		else if (!strcmp(tmp,"m_e1"))
		{
			ReadInFloats(token,&m_tire[0].m_e);
		}
		else if (!strcmp(tmp,"m_tireSpringConst1"))
		{
			ReadInFloats(token,&m_tire[0].m_tireSpringConst);
		}
		else if (!strcmp(tmp,"m_peakTraction1"))
		{
			ReadInFloats(token,&m_tire[0].m_peakTraction);
		}
		else if (!strcmp(tmp,"m_model1"))
		{
			ReadInInt(token,&m_tire[0].m_model);
		}
		// Rear Tire Settings
		else if (!strcmp(tmp,"m_baseLoad2"))
		{
			ReadInFloats(token,&m_tire[1].m_baseLoad);
		}
		else if (!strcmp(tmp,"m_corneringStiffness2"))
		{
			ReadInFloats(token,&m_tire[1].m_corneringStiffness);
		}
		else if (!strcmp(tmp,"m_csSensitivityToFv2"))
		{
			ReadInFloats(token,&m_tire[1].m_csSensitivityToFv);
		}
		else if (!strcmp(tmp,"m_muY2"))
		{
			ReadInFloats(token,&m_tire[1].m_muY);
		}
		else if (!strcmp(tmp,"m_muX2"))
		{
			ReadInFloats(token,&m_tire[1].m_muX);
		}
		else if (!strcmp(tmp,"m_muYSensitivityToFv2"))
		{
			ReadInFloats(token,&m_tire[1].m_muYSensitivityToFv);
		}
		else if (!strcmp(tmp,"m_muXSensitivityToFv2"))
		{
			ReadInFloats(token,&m_tire[1].m_muXSensitivityToFv);
		}
		else if (!strcmp(tmp,"m_camberStiffness2"))
		{
			ReadInFloats(token,&m_tire[1].m_camberStiffness);
		}
		else if (!strcmp(tmp,"m_longStiffness2"))
		{
			ReadInFloats(token,&m_tire[1].m_longStiffness);
		}
		else if (!strcmp(tmp,"m_a2"))
		{
			ReadInFloats(token,&m_tire[1].m_a);
		}
		else if (!strcmp(tmp,"m_b2"))
		{
			ReadInFloats(token,&m_tire[1].m_b);
		}
		else if (!strcmp(tmp,"m_c2"))
		{
			ReadInFloats(token,&m_tire[1].m_c);
		}
		else if (!strcmp(tmp,"m_d2"))
		{
			ReadInFloats(token,&m_tire[1].m_d);
		}
		else if (!strcmp(tmp,"m_e2"))
		{
			ReadInFloats(token,&m_tire[1].m_e);
		}
		else if (!strcmp(tmp,"m_tireSpringConst2"))
		{
			ReadInFloats(token,&m_tire[1].m_tireSpringConst);
		}
		else if (!strcmp(tmp,"m_peakTraction2"))
		{
			ReadInFloats(token,&m_tire[1].m_peakTraction);
		}
		else if (!strcmp(tmp,"m_model2"))
		{
			ReadInInt(token,&m_tire[1].m_model);
		}

	}
	fclose(fp);
//	m_ResetCar();

	return (true);
}

void PhysicsCar::m_ResetCar()
{
	m_engine.m_phyCar = this;
	m_engine.m_automatic = true;

	// clean out walls
	memset(m_wall, 0, sizeof(m_wall));

	m_posVel[0] = 0.0f;
	m_posVel[1] = 0.0f;
	m_posVel[2] = 0.0f;
	m_rotVel[0] = 0.0f;
	m_rotVel[1] = 0.0f;
	m_rotVel[2] = 0.0f;
#if !FINAL_ROM
	{
#endif
	m_quat[0] = 1.0f;    // rotate 0 degrees
	m_quat[1] = 0.0f;
	m_quat[2] = 0.0f;
	m_quat[3] = 0.0f;
#if !FINAL_ROM
	}
#endif
	for (int i=0; i<4; i++)
	{
		m_wheelVel[i][0] = 0.0f;
		m_wheelVel[i][1] = 0.0f;
		m_wheelVel[i][2] = 0.0f;
		m_wheelSpinVel[i] = 0.0f;
		m_wheelTanSlip[i] = 0.0f;
	}
	m_steerAngle = 0.0f;


#if !FINAL_ROM
	{
#endif
	m_MoveToStart(0);

#if !FINAL_ROM
	}
	{
		// Just for Brian, don't move the car back to the start line.
		m_pos[2] += 0.3f;
		for (int tire=0; tire < TIRECOUNT; tire++)
		{
			m_wheel[tire][0] = m_pos[0] + m_suspension.m_rollCenter[tire][0];
			m_wheel[tire][1] = m_pos[1] + cosf(INITIALSUSPENSIONANGLE)*m_suspension.m_rcToWheelLength[tire] * (CAR_WHEEL_RIGHT(tire)?-1.0f:1.0f);
			m_wheel[tire][2] = m_pos[2] - m_suspension.m_springLength[tire];
		}
		m_ComputeTransformMatrix();
		m_FindStartingPatch();

		// current forward vector is going to be 1, 0, 0
		// dot product with the dir we want to face gives cos angle
		// rotate angle around z axis 
		float angle = -acosf(m_transform[0][0]);
		if (m_transform[0][1] < 0.0f)
		{
			angle = GAME_2PI - angle;
		}
		EulerToQuat(0.0f, 0.0f,-angle,m_quat);
		m_ComputeTransformMatrix();
		// set the wheel positions
		// rotate around Z axis
		float rot[4][4] = 
		{
			{ cosf(angle),  -sinf(angle),  0.0f,  0.0f },
			{ sinf(angle),   cosf(angle),  0.0f,  0.0f },
			{ 0.0f,          0.0f,         1.0f,  0.0f },
			{ 0.0f,          0.0f,         0.0f,  1.0f }
		};
		float tmp[3];
		for (int i=0; i<4; i++)
		{
			m_WorldToBody(tmp,m_wheel[i]);
			V3Mul3x3(tmp,tmp,rot);
			m_BodyToWorld(m_wheel[i],tmp);
		}
		m_WorldToBody(tmp,m_pos);
		V3Mul3x3(tmp,tmp,rot);
		m_BodyToWorld(m_pos,tmp);
	}

#endif

	float wheelbase = m_suspension.m_rollCenter[0][0] - m_suspension.m_rollCenter[2][0];
	// set cog heigth
	float springRayRear[3] = {0.0f,0.0f,0.0f};
	float springRayFront[3] = {0.0f,0.0f,0.0f};
	float wheelPos[3];
	m_WorldToBody(wheelPos,m_wheel[CAR_WHEEL_LR]);
	springRayRear[1] = wheelPos[1] - m_suspension.m_springBodyPoint[1][1];
	springRayRear[2] = m_suspension.m_springLength[CAR_WHEEL_LR] + m_suspension.m_springBodyPoint[1][2];
	V3Norm(springRayRear);
	float cogRear = springRayRear[2] * m_suspension.m_springLength[CAR_WHEEL_LR];
	m_WorldToBody(wheelPos,m_wheel[CAR_WHEEL_LF]);
	springRayFront[1] = wheelPos[1] - m_suspension.m_springBodyPoint[0][1];
	springRayFront[2] = m_suspension.m_springLength[CAR_WHEEL_LF] + m_suspension.m_springBodyPoint[0][2];
	V3Norm(springRayFront);
	float cogFront = springRayFront[2] * m_suspension.m_springLength[CAR_WHEEL_LF];
	m_cogHeight = (cogRear * ABS(m_suspension.m_rollCenter[CAR_WHEEL_LR][0]) / wheelbase) +
				  (cogFront * ABS(m_suspension.m_rollCenter[CAR_WHEEL_LF][0]) / wheelbase);

	// setup spring load const
	for (int tire = 0; tire<TIRECOUNT; tire++)
	{
		float wheelpercentage = 0.5f * (1.0f - (ABS(m_suspension.m_rollCenter[tire][0]) / wheelbase));
		m_springLoadConstant[tire] = wheelpercentage * m_bodyMass * g_gravity[2];
	}

	// initialize the wall segments
	for ( i=0; i<CACHED_WALL_COUNT; i++)
	{
		m_wall[i].m_planeValid = 0;
	}
	m_corner[0][0] = m_length * 0.5f + m_boxOffset;
	m_corner[0][1] = m_width * 0.5f;
	m_corner[1][0] = m_length * 0.5f + m_boxOffset;
	m_corner[1][1] = -m_width * 0.5f;
	m_corner[2][0] = -m_length * 0.5f + m_boxOffset;
	m_corner[2][1] = m_width * 0.5f;
	m_corner[3][0] = -m_length * 0.5f + m_boxOffset;
	m_corner[3][1] = -m_width * 0.5f;

}

void PhysicsCar::m_ComputeTransformMatrix()
{
	float w2,x2,y2,z2,xy,wz,xz,wy,yz,wx;
	if (m_normalizeQuaternion)
	{
		QNORMALISE(m_quat);
	}

	w2 = m_quat[WQ]*m_quat[WQ];
	x2 = m_quat[XQ]*m_quat[XQ];
	y2 = m_quat[YQ]*m_quat[YQ];
	z2 = m_quat[ZQ]*m_quat[ZQ];

	xy = 2.0f*m_quat[XQ]*m_quat[YQ];
	wz = 2.0f*m_quat[WQ]*m_quat[ZQ];
	xz = 2.0f*m_quat[XQ]*m_quat[ZQ];
	wy = 2.0f*m_quat[WQ]*m_quat[YQ];
	yz = 2.0f*m_quat[YQ]*m_quat[ZQ];
	wx = 2.0f*m_quat[WQ]*m_quat[XQ];

	// Fill in the Rotation terms
	m_transform[0][0] = w2+x2-y2-z2;
	m_transform[0][1] = xy+wz;
	m_transform[0][2] = xz-wy;

	m_transform[0][3] = 0.0f;

	m_transform[1][0] = xy-wz;
	m_transform[1][1] = w2-x2+y2-z2;
	m_transform[1][2] = yz+wx;

	m_transform[1][3] = 0.0f;

	m_transform[2][0] = xz+wy;
	m_transform[2][1] = yz-wx;
	m_transform[2][2] = w2-x2-y2+z2;

	m_transform[2][3] = 0.0f;

	// Fill in Translations
	m_transform[3][0] = m_pos[0];
	m_transform[3][1] = m_pos[1];
	m_transform[3][2] = m_pos[2];
	  
	m_transform[0][3] = 0.0f;
	m_transform[1][3] = 0.0f;
	m_transform[2][3] = 0.0f;
	m_transform[3][3] = 1.0f;

	// compute the inverse matrix
	for (int i=0; i<3; i++)
	{
		m_invTransform[3][i] = 0.0f;
		for (int j=0; j<3; j++)
		{
			m_invTransform[i][j] = m_transform[j][i];
			m_invTransform[3][i] += -m_transform[3][j] * m_transform[i][j];
		}
	}
	m_invTransform[0][3] = 0.0f;
	m_invTransform[1][3] = 0.0f;
	m_invTransform[2][3] = 0.0f;
	m_invTransform[3][3] = 1.0f;
}




void PhysicsCar::m_GetTireDemand(int tire, float steerAngle, TRACTION *out)
{
}


#define OVERSTEERTHRESHOLD 4.0f
#define MAXSTEERDEMAND 2.5f
 
void PhysicsCar::m_HandleDriverInput(Input *in)
{	
}



void PhysicsCar::m_LocalWheelVel(float *localWheelVel, int tire)
{

}



float PhysicsCar::m_DiffTanSlip(float wheelTanSlip, float vY, float absVX)
{

#if 0
	float current = wheelTanSlip;
//	float diffTanSlip = (target - current)*15;//m_tireRelaxLength;
	float diffTanSlip = SIGN(target - current) * 1.7f;

#endif

	#define EPS2 1.0f
	// calculate the tan slip angle
//	m_tireRelaxLength = 0.5f;
	float diffTanSlip = (vY - wheelTanSlip*absVX)/m_tireRelaxLength;
//	printf("wheelTanSlip[%d] - %10.6f   ",tire, wheelTanSlip[tire]);
	if (absVX < EPS2) 
	{
		diffTanSlip *= 1.0f + 50.0f * (1.0f-absVX/EPS2);
	}

														  
	/*
	if (diffTanSlip > 150.0f)
		return 150.0f;
	if (diffTanSlip < -150.0f)
		return -150.0f;
	*/

	return diffTanSlip;
}


 
void PhysicsCar::m_UpdatePosition(float dt)
{

	// which walls do we need to check against
	m_UpdateActivePatchGroups();

	int loopCount = (dt == 1.0f/60.0f)? 5 : 6;

	int tire;
	float velTmp = m_posVel[0] * m_posVel[0] + m_posVel[1] * m_posVel[1];
//	float roughness;
	for (tire =0; tire<TIRECOUNT; tire++)
	{

#if LEVEL_GROUND
		m_groundHeight[tire] = 3.3f;
		m_groundNormal[tire][0] = 0.0f;
		m_groundNormal[tire][1] = 0.0f;
		m_groundNormal[tire][2] = 1.0f;
#endif
	}


	float timeStep;
	float timeAdjust;
	short penetrating;
	int wall = 0;
	int hitWall = 0;
	short saveOff = false;
	static float carState[NUMBEROFEQU];
	static float diff[NUMBEROFEQU];
	static float newCarState[NUMBEROFEQU];
#if TESTING_WALLS
	short section;
	WallSegment derekWall[5][CACHED_WALL_COUNT];
	float derekState[5][NUMBEROFEQU];
	float derekTimeStep;
	float derekMatrix[4][4];
	memcpy(derekState[0], carState,sizeof(carState));
	memcpy(derekWall[0], m_wall,sizeof(m_wall));
	derekTimeStep = MYTIMESTEP;
		
#endif


	for (int loop=0; loop<loopCount; loop++)
	{
		V3Set(carState, m_pos);
		V3Set(carState+POSVELOFFSET, m_posVel);
		V4Set(carState+QUATOFFSET, m_quat);
		V3Set(carState+ROTVELOFFSET, m_rotVel);
		V3Set(carState+WHEELOFFSET, m_wheel[0]);
		V3Set(carState+WHEELOFFSET+3, m_wheel[1]);
		V3Set(carState+WHEELOFFSET+6, m_wheel[2]);
		V3Set(carState+WHEELOFFSET+9, m_wheel[3]);
		V3Set(carState+WHEELVELOFFSET, m_wheelVel[0]);
		V3Set(carState+WHEELVELOFFSET+3, m_wheelVel[1]);
		V3Set(carState+WHEELVELOFFSET+6, m_wheelVel[2]);
		V3Set(carState+WHEELVELOFFSET+9, m_wheelVel[3]);
		V4Set(carState+WHEELSPINOFFSET, m_wheelSpinVel);
//		V4Set(carState+WHEELTANSLIPOFFSET, m_wheelTanSlip);

#if TESTING_WALLS
		memcpy(derekState[loop],carState,sizeof(carState));
		memcpy(derekWall[loop],m_wall,sizeof(m_wall));
		section = 1;
#endif
		timeStep = MYTIMESTEP;
		timeAdjust = MYTIMESTEP;
		penetrating = false;
		wall = 0;
		hitWall = 0;
		saveOff = true;
		m_normalizeQuaternion = true;
		m_EvalDiff(carState, diff);
		m_Integrator(carState, diff, timeStep, newCarState);
		m_normalizeQuaternion = false;

		V3Set(m_pos, newCarState);
		V3Set(m_posVel, newCarState+POSVELOFFSET);
		V4Set(m_quat, newCarState+QUATOFFSET);
		V3Set(m_rotVel, newCarState+ROTVELOFFSET);
		V3Set(m_wheel[0], newCarState+WHEELOFFSET);
		V3Set(m_wheel[1], newCarState+WHEELOFFSET+3);
		V3Set(m_wheel[2], newCarState+WHEELOFFSET+6);
		V3Set(m_wheel[3], newCarState+WHEELOFFSET+9);
		V3Set(m_wheelVel[0], newCarState+WHEELVELOFFSET);
		V3Set(m_wheelVel[1], newCarState+WHEELVELOFFSET+3);
		V3Set(m_wheelVel[2], newCarState+WHEELVELOFFSET+6);
		V3Set(m_wheelVel[3], newCarState+WHEELVELOFFSET+9);
		V4Set(m_wheelSpinVel, newCarState+WHEELSPINOFFSET);

		m_AdjustWheelHeights(carState, newCarState);
		m_CheckForGroundingCorners();
		

	}
	m_CheckCollisionWithCone();

	m_CheckGimbleLock();

	m_RePositionWheels();

	// update wheel rotation
	for (tire =0; tire<TIRECOUNT; tire++)
	{
		m_wheelRotationAngle[tire] += m_wheelSpinVel[tire] * dt;
		while (m_wheelRotationAngle[tire] > GAME_2PI)
		{
			m_wheelRotationAngle[tire] -= GAME_2PI;
		}
		while (m_wheelRotationAngle[tire] < 0.0f)
		{
			m_wheelRotationAngle[tire] += GAME_2PI;
		}		
	}
}

void PhysicsCar::m_AdjustWheelHeights(float *carOld, float *carNew)
{
	float dist[2];
	for (int tire=0; tire<TIRECOUNT; tire++)
	{
		V2Sub(dist, carNew+WHEELOFFSET + tire*3, carOld+WHEELOFFSET + tire*3);
		m_groundHeight[tire] -= V2Dot(dist, m_groundNormal[tire]);
	}
}

void PhysicsCar::m_RePositionWheels(void)
{

}

void PhysicsCar::m_CheckGimbleLock()
{
}

//  m_WorldToBodyPos
//  converts world positions to body positions
void PhysicsCar::m_WorldToBody(float *out, float *in)
{
	V3Mul4x4(out,in,m_invTransform);
}


void PhysicsCar::m_WorldToBodyRotate(float *out, float *in)
{
	float tmp[3];
	for (int i=0; i<3; i++)
	{
		tmp[i] = 0.0f;
		for (int j=0; j<3; j++)
		{
			tmp[i] += in[j] * m_invTransform[j][i];
		}
	}
	out[0] = tmp[0];
	out[1] = tmp[1];
	out[2] = tmp[2];
}

void PhysicsCar::m_BodyToWorld(float *out, float *in)
{
	V3Mul4x4(out,in,m_transform);
}

void PhysicsCar::m_BodyToWorldRotate(float *out, float *in)
{
	float tmp[3];
	for (int i=0; i<3; i++)
	{
		tmp[i] = 0.0f;
		for (int j=0; j<3; j++)
		{
			tmp[i] += in[j] * m_transform[j][i];
		}
	}
	out[0] = tmp[0];
	out[1] = tmp[1];
	out[2] = tmp[2];

}

//-------------------------------------------------------------------------------
//  Private Functions
//-------------------------------------------------------------------------------

void PhysicsCar::m_UpdateWheelDifferentials()
{
}


//  m_UpdateSpringForces  
//  all forces are in local space. This computes the spring force including damper
//  for each wheel.
void PhysicsCar::m_UpdateSpringForces(float springForce[4][3], float rcToWheel[4][3],
									  float wheelPos[4][3], float wheelVel[4][3],
									  float posVel[3], float rotVel[3])
{
}

void PhysicsCar::m_UpdateAerodynamicForces(float bodyVel[3], float aeroForce[3], float downForce[2])
{
}

// X component of springForce will be 0
void PhysicsCar::m_UpdateBodyTorque(float bodyTorque[3], float springForce[4][3], float downForce[2])
{
}

void PhysicsCar::m_UpdateBodyForces(float bodyForce[3], float springForce[4][3],
									float aeroForce[3], float downForce[2])
{
}


void PhysicsCar::m_UpdateWheelForces(float wheelForce[4][3], float springForce[4][3], float wheelHeightWorld[4])
{
}


// m_UpdateTireForces addes the longitudinal and lateral tire forces to the wheels
void PhysicsCar::m_UpdateTireForces(float wheelForce[4][3], float wheelVel[4][3],
									float wheelSpinVel[4], float wheelTanSlip[4],
									float wheelHeightWorld[4])
{

}



void PhysicsCar::m_ComputeConstraintForces(float fc[8],float tireForce[4][3],
										   float bodyForce[3], float bodyTorque[3], float wheelPos[4][3], 
										   float wheelVel[4][3], float rcToWheel[4][3],
										   float posVel[3], float rotVel[3])
{
#if 0
	for (int i=0; i<4; i++)
	{
		printf("wheel %f, %f, %f\n", wheelPos[i][0], wheelPos[i][1], wheelPos[i][2]);
		printf("rc %f, %f, %f\n", rcToWheel[i][0], rcToWheel[i][1], rcToWheel[i][2]);
	}
#endif
	float a[8][8];
	m_ComputeCoefMatrixForConstraintForces(a, wheelPos, rcToWheel);

	fc[0] = m_ComputeResultFromEqB(rcToWheel[0], m_suspension.m_rollCenter[0], bodyTorque, tireForce[0],
								  bodyForce,wheelVel[0],posVel,rotVel);
	fc[1] = m_ComputeResultFromEqA(wheelPos[0], bodyTorque,tireForce[0], bodyForce,
								  wheelVel[0], posVel, rotVel);
	fc[2] = m_ComputeResultFromEqB(rcToWheel[1], m_suspension.m_rollCenter[1], bodyTorque, tireForce[1],
		                          bodyForce, wheelVel[1], posVel, rotVel);
	fc[3] = m_ComputeResultFromEqA(wheelPos[1], bodyTorque, tireForce[1], bodyForce,
		                          wheelVel[1], posVel, rotVel);

	fc[4] = m_ComputeResultFromEqB(rcToWheel[2], m_suspension.m_rollCenter[2], bodyTorque, tireForce[2],
		                          bodyForce, wheelVel[2], posVel, rotVel);
	fc[5] = m_ComputeResultFromEqA(wheelPos[2], bodyTorque, tireForce[2], bodyForce,
		                          wheelVel[2], posVel, rotVel);

	fc[6] = m_ComputeResultFromEqB(rcToWheel[3], m_suspension.m_rollCenter[3], bodyTorque, tireForce[3],
		                          bodyForce,wheelVel[3], posVel, rotVel);
	fc[7] = m_ComputeResultFromEqA(wheelPos[3], bodyTorque, tireForce[3], bodyForce,
		                          wheelVel[3], posVel, rotVel);

	// use gauss elimination to solve Ax = b
	float tmp;
	// Gauss part
	for (int i=0; i<8; i++)
	{
		float div = 1.0f/a[i][i];
		for (int j=i; j<8; j++)
		{
			a[i][j] *= div;
		}
		fc[i] *= div;

		for (int r=i+1; r<8; r++)
		{
			fc[r] -= fc[i] * a[r][i];
			tmp = a[r][i];
			for (int j=i; j<8; j++)
			{
				a[r][j] -= a[i][j] * tmp;
			}
		}
	}
	// backwards substitution
	for (i=7; i>=0; i--)
	{
		for (int j=i+1; j<8; j++)
		{
			fc[i] -= a[i][j] * fc[j]; 
		}
	}
	// array fc now contains the constraint forces (i hope)
}



void PhysicsCar::m_ComputeCoefMatrixForConstraintForces(float out[8][8], float wheelPos[4][3],
														float rcToWheel[4][3])
{
#if 0
	for (int i=0; i<4; i++)
	{
	printf("rollCenter %f, %f, %f\n", m_suspension.m_rollCenter[i][0], 
									  m_suspension.m_rollCenter[i][1], m_suspension.m_rollCenter[i][2]);
	}
#endif
	// first row 
	out[0][0] = m_ComputeCoefFromEqC(rcToWheel[0], m_suspension.m_rollCenter[0], wheelPos[0], rcToWheel[0]);
	out[0][1] = m_ComputeCoefFromEqC(rcToWheel[0], m_suspension.m_rollCenter[0], wheelPos[0], g_constraintX);
	out[0][2] = m_ComputeCoefFromEqD(rcToWheel[0], m_suspension.m_rollCenter[0], wheelPos[1], rcToWheel[1]);
	out[0][3] = m_ComputeCoefFromEqD2(rcToWheel[0], m_suspension.m_rollCenter[0], wheelPos[1]);
	out[0][4] = m_ComputeCoefFromEqD(rcToWheel[0], m_suspension.m_rollCenter[0], wheelPos[2], rcToWheel[2]);
	out[0][5] = m_ComputeCoefFromEqD2(rcToWheel[0], m_suspension.m_rollCenter[0], wheelPos[2]);
	out[0][6] = m_ComputeCoefFromEqD(rcToWheel[0], m_suspension.m_rollCenter[0], wheelPos[3], rcToWheel[3]);
	out[0][7] = m_ComputeCoefFromEqD2(rcToWheel[0], m_suspension.m_rollCenter[0], wheelPos[3]);

	// second row
	out[1][0] = m_ComputeCoefFromEqA(wheelPos[0], rcToWheel[0]);
	out[1][1] = m_ComputeCoefFromEqA(wheelPos[0], g_constraintX);
	out[1][2] = m_ComputeCoefFromEqB(wheelPos[0], wheelPos[1], rcToWheel[1]);
	out[1][3] = m_ComputeCoefFromEqB2(wheelPos[0], wheelPos[1]);
	out[1][4] = m_ComputeCoefFromEqB(wheelPos[0], wheelPos[2], rcToWheel[2]);
	out[1][5] = m_ComputeCoefFromEqB2(wheelPos[0], wheelPos[2]);
	out[1][6] = m_ComputeCoefFromEqB(wheelPos[0], wheelPos[3], rcToWheel[3]);
	out[1][7] = m_ComputeCoefFromEqB2(wheelPos[0], wheelPos[3]);

	// third row
	out[2][0] = m_ComputeCoefFromEqD(rcToWheel[1], m_suspension.m_rollCenter[1], wheelPos[0], rcToWheel[0]);
	out[2][1] = m_ComputeCoefFromEqD2(rcToWheel[1], m_suspension.m_rollCenter[1], wheelPos[0]);
	out[2][2] = m_ComputeCoefFromEqC(rcToWheel[1], m_suspension.m_rollCenter[1], wheelPos[1], rcToWheel[1]);
	out[2][3] = m_ComputeCoefFromEqC(rcToWheel[1], m_suspension.m_rollCenter[1], wheelPos[1], g_constraintX);
	out[2][4] = m_ComputeCoefFromEqD(rcToWheel[1], m_suspension.m_rollCenter[1], wheelPos[2], rcToWheel[2]);
	out[2][5] = m_ComputeCoefFromEqD2(rcToWheel[1], m_suspension.m_rollCenter[1], wheelPos[2]);
	out[2][6] = m_ComputeCoefFromEqD(rcToWheel[1], m_suspension.m_rollCenter[1], wheelPos[3], rcToWheel[3]);
	out[2][7] = m_ComputeCoefFromEqD2(rcToWheel[1], m_suspension.m_rollCenter[1], wheelPos[3]);

	// fourth row
	out[3][0] = m_ComputeCoefFromEqB(wheelPos[1], wheelPos[0], rcToWheel[0]);
	out[3][1] = m_ComputeCoefFromEqB2(wheelPos[1], wheelPos[0]);
	out[3][2] = m_ComputeCoefFromEqA(wheelPos[1], rcToWheel[1]);
	out[3][3] = m_ComputeCoefFromEqA(wheelPos[1], g_constraintX);
	out[3][4] = m_ComputeCoefFromEqB(wheelPos[1], wheelPos[2], rcToWheel[2]);
	out[3][5] = m_ComputeCoefFromEqB2(wheelPos[1], wheelPos[2]);
	out[3][6] = m_ComputeCoefFromEqB(wheelPos[1], wheelPos[3], rcToWheel[3]);
	out[3][7] = m_ComputeCoefFromEqB2(wheelPos[1], wheelPos[3]);

	// fifth row
	out[4][0] = m_ComputeCoefFromEqD(rcToWheel[2], m_suspension.m_rollCenter[2], wheelPos[0], rcToWheel[0]);
	out[4][1] = m_ComputeCoefFromEqD2(rcToWheel[2], m_suspension.m_rollCenter[2], wheelPos[0]);
	out[4][2] = m_ComputeCoefFromEqD(rcToWheel[2], m_suspension.m_rollCenter[2], wheelPos[1], rcToWheel[1]);
	out[4][3] = m_ComputeCoefFromEqD2(rcToWheel[2], m_suspension.m_rollCenter[2], wheelPos[1]);
	out[4][4] = m_ComputeCoefFromEqC(rcToWheel[2], m_suspension.m_rollCenter[2], wheelPos[2], rcToWheel[2]);
	out[4][5] = m_ComputeCoefFromEqC(rcToWheel[2], m_suspension.m_rollCenter[2], wheelPos[2], g_constraintX);
	out[4][6] = m_ComputeCoefFromEqD(rcToWheel[2], m_suspension.m_rollCenter[2], wheelPos[3], rcToWheel[3]);
	out[4][7] = m_ComputeCoefFromEqD2(rcToWheel[2], m_suspension.m_rollCenter[2], wheelPos[3]);

	// sixth row
	out[5][0] = m_ComputeCoefFromEqB(wheelPos[2], wheelPos[0], rcToWheel[0]);
	out[5][1] = m_ComputeCoefFromEqB2(wheelPos[2], wheelPos[0]);
	out[5][2] = m_ComputeCoefFromEqB(wheelPos[2], wheelPos[1], rcToWheel[1]);
	out[5][3] = m_ComputeCoefFromEqB2(wheelPos[2], wheelPos[1]);
	out[5][4] = m_ComputeCoefFromEqA(wheelPos[2], rcToWheel[2]);
	out[5][5] = m_ComputeCoefFromEqA(wheelPos[2], g_constraintX);
	out[5][6] = m_ComputeCoefFromEqB(wheelPos[2], wheelPos[3], rcToWheel[3]);
	out[5][7] = m_ComputeCoefFromEqB2(wheelPos[2], wheelPos[3]);

	// seventh row
	out[6][0] = m_ComputeCoefFromEqD(rcToWheel[3], m_suspension.m_rollCenter[3], wheelPos[0], rcToWheel[0]);
	out[6][1] = m_ComputeCoefFromEqD2(rcToWheel[3], m_suspension.m_rollCenter[3], wheelPos[0]);
	out[6][2] = m_ComputeCoefFromEqD(rcToWheel[3], m_suspension.m_rollCenter[3], wheelPos[1], rcToWheel[1]);
	out[6][3] = m_ComputeCoefFromEqD2(rcToWheel[3], m_suspension.m_rollCenter[3], wheelPos[1]);
	out[6][4] = m_ComputeCoefFromEqD(rcToWheel[3], m_suspension.m_rollCenter[3], wheelPos[2], rcToWheel[2]);
	out[6][5] = m_ComputeCoefFromEqD2(rcToWheel[3], m_suspension.m_rollCenter[3], wheelPos[2]);
	out[6][6] = m_ComputeCoefFromEqC(rcToWheel[3], m_suspension.m_rollCenter[3], wheelPos[3], rcToWheel[3]);
	out[6][7] = m_ComputeCoefFromEqC(rcToWheel[3], m_suspension.m_rollCenter[3], wheelPos[3], g_constraintX);

	// eigth row
	out[7][0] = m_ComputeCoefFromEqB(wheelPos[3], wheelPos[0], rcToWheel[0]);
	out[7][1] = m_ComputeCoefFromEqB2(wheelPos[3], wheelPos[0]);
	out[7][2] = m_ComputeCoefFromEqB(wheelPos[3], wheelPos[1], rcToWheel[1]);
	out[7][3] = m_ComputeCoefFromEqB2(wheelPos[3], wheelPos[1]);
	out[7][4] = m_ComputeCoefFromEqB(wheelPos[3], wheelPos[2], rcToWheel[2]);
	out[7][5] = m_ComputeCoefFromEqB2(wheelPos[3], wheelPos[2]);
	out[7][6] = m_ComputeCoefFromEqA(wheelPos[3], rcToWheel[3]);
	out[7][7] = m_ComputeCoefFromEqA(wheelPos[3], g_constraintX);
	for (int i=0; i<8; i++)
	{
		for (int j=0; j<8; j++)
		{
			printf("out[%d][%d] = %f\n", i, j, out[i][j]);
		}
	}
	PrintCustomFault("Done with first loop:\n");
}


// wc is position of wheel contact i, r is vector from body COG to wheel contact j,
// contraint is contraint vector on tire contact j. All are in body space. 
float PhysicsCar::m_ComputeCoefFromEqA(float wheelPos[3], float constraint[3])
{
	float result = m_ComputeCoefFromEqB(wheelPos, wheelPos, constraint);
	result -= (constraint[0] * m_invWheelMass);
	return (result);
}

float PhysicsCar::m_ComputeCoefFromEqB(float wheelPos[3], float ray[3], float constraint[3])
{
	float tmp[3],tmp2[3];
	float result;
#if 0
	V3Cross(tmp,ray,constraint);
	V3Mul3x3(tmp,tmp,m_xMatrix);
	V3Cross(tmp,g_constraintX,tmp);
	result = -V3Dot(wheelPos,tmp);
	V3Mul(tmp,constraint,m_invBodyMass);
	result -= tmp[0]; // V3Dot(g_constraintX,tmp);
#else
	tmp[0] = 0.0f;
	tmp[1] = ray[2] * constraint[0] - ray[0] * constraint[2];
	tmp[2] = ray[0] * constraint[1] - ray[1] * constraint[0];
	tmp[1] *= m_xMatrix[1][1];
	tmp[2] *= m_xMatrix[2][2];
	tmp2[0] = 0.0f;
	tmp2[1] = -tmp[2];
	tmp2[2] = tmp[1];
	result = -(wheelPos[1]*tmp2[1] + wheelPos[2]*tmp2[2]);
	result -= (constraint[0] * m_invBodyMass);
#endif
	return (result);
}

float PhysicsCar::m_ComputeCoefFromEqB2(float wheelPos[3], float ray[3])
{
	float tmp[3];
	float result;
	tmp[0] = 0.0f;
	tmp[1] = ray[1] * m_xMatrix[2][2];
	tmp[2] = ray[2] * m_xMatrix[1][1];
	result = -(wheelPos[1]*tmp[1] + wheelPos[2]*tmp[2]) - m_invBodyMass;

	return (result);
}


// constraint1 is rcToWheel so no X component
float PhysicsCar::m_ComputeCoefFromEqC(float constraint1[3], float rc[3], 
									   float ray[3], float constraint2[3])
{
	float tmp[3];
	float result = m_ComputeCoefFromEqD(constraint1, rc, ray, constraint2);
	tmp[0] = 0.0f;
	tmp[1] = constraint2[1] * m_invWheelMass;
	tmp[2] = constraint2[2] * m_invWheelMass;
	result += (constraint1[1] * tmp[1] + constraint1[2] * tmp[2]);
	return (result);
}

// constraint1 is rcToWheel so no X component
float PhysicsCar::m_ComputeCoefFromEqD(float constraint1[3], float rc[3], 
									   float ray[3], float constraint2[3])
{
//	printf("const1 %5.8f, %5.8f, %5.8f\n", constraint1[0], constraint1[1], constraint1[2]);
//	printf("rc %5.8f, %5.8f, %5.8f\n", rc[0], rc[1], rc[2]);
//	printf("ray %5.8f, %5.8f, %5.8f\n", ray[0], ray[1], ray[2]);
//	printf("const2 %5.8f, %5.8f, %5.8f\n",constraint2[0], constraint2[1], constraint2[2]);
	float tmp[3],tmp2[3];
	float result;
#if 0
	V3Cross(tmp,ray,constraint2);
	V3Mul3x3(tmp,tmp,m_xMatrix);
	V3Cross(tmp,rc,tmp);
	result = -V3Dot(constraint1,tmp);
	V3Mul(tmp,constraint2,m_invBodyMass);
	result += V3Dot(constraint1,tmp);
#else
	tmp[0] = ray[1] * constraint2[2] - ray[2] * constraint2[1];
	tmp[1] = ray[2] * constraint2[0] - ray[0] * constraint2[2];
	tmp[2] = ray[0] * constraint2[1] - ray[1] * constraint2[0];
	tmp[0] *= m_xMatrix[0][0];
	tmp[1] *= m_xMatrix[1][1];
	tmp[2] *= m_xMatrix[2][2];
	tmp2[0] = 0.0f;
	tmp2[1] = rc[2] * tmp[0] - rc[0] * tmp[2];
	tmp2[2] = rc[0] * tmp[1] - rc[1] * tmp[0];
	result = -(constraint1[1] * tmp2[1] + constraint1[2]*tmp2[2]);
	tmp[0] = 0.0f;
	tmp[1] = constraint2[1] * m_invBodyMass;
	tmp[2] = constraint2[2] * m_invBodyMass;
	result += (constraint1[1] * tmp[1] + constraint1[2]*tmp[2]);
#endif
	return (result);

}

// constraint1 is rcToWheel so no X component
float PhysicsCar::m_ComputeCoefFromEqD2(float constraint1[3], float rc[3], 
									    float wheelPos[3])
{
	float tmp[3],tmp2[3];
	float result;
	tmp[0] = 0.0f;
	tmp[1] = wheelPos[2] * m_xMatrix[1][1];
	tmp[2] = -wheelPos[1] * m_xMatrix[2][2];
	tmp2[0] = 0.0f;
	tmp2[1] = -rc[0] * tmp[2];
	tmp2[2] = rc[0] * tmp[1];
	result = -(constraint1[1] * tmp2[1] + constraint1[2] *tmp2[2]);

	return (result);
}

float PhysicsCar::m_ComputeResultFromEqA(float tirePos[3], float bodyTorque[3],
										 float tireForce[3], float bodyForce[3],
										 float wheelVel[3], float posVel[3], float rotVel[3])
{
	float tmp[3],tmp2[3];
	float result;
#if 0
	// first term
	V3Cross(tmp, rotVel, g_constraintX);
	V3Cross(tmp, rotVel, tmp);
	result = V3Dot(tirePos, tmp);
	// second term
	V3Mul3x3(tmp, bodyTorque, m_xMatrix);
	V3Cross(tmp, g_constraintX, tmp);
	result -= V3Dot(tirePos, tmp);
	// third term
	V3Cross(tmp, rotVel, g_constraintX);
	result += (2.0f*V3Dot(tmp, wheelVel));

	// fourth term
	V3Cross(tmp, rotVel, g_constraintX);
	result -= (2.0f*V3Dot(tmp, posVel));
	// fifth term
	V3Mul(tmp,tireForce, m_invWheelMass);
	result += tmp[0]; // V3Dot(g_constraintX,tmp);
	// sixth term
	V3Mul(tmp,bodyForce, m_invBodyMass);
	result -= tmp[0]; // V3Dot(g_constraintX,tmp);
#else
	// first term
	tmp[0] = 0.0f;
	tmp[1] = rotVel[2];
	tmp[2] = -rotVel[1];
	tmp2[0] = rotVel[1] * tmp[2] - rotVel[2] * tmp[1];
	tmp2[1] = -rotVel[0] * tmp[2];
	tmp2[2] = rotVel[0] * tmp[1];
	result = (tirePos[0] * tmp2[0] + tirePos[1] * tmp2[1] + tirePos[2] * tmp2[2]);
	// second term
	tmp[0] = bodyTorque[0] * m_xMatrix[0][0];
	tmp[1] = bodyTorque[1] * m_xMatrix[1][1];
	tmp[2] = bodyTorque[2] * m_xMatrix[2][2];
	tmp2[0] = 0.0f;
	tmp2[1] = -tmp[2];
	tmp2[2] = tmp[1];
	result -= (tirePos[1] * tmp2[1] + tirePos[2] * tmp2[2]);
	// third term
	tmp[0] = 0.0f;
	tmp[1] = rotVel[2];
	tmp[2] = -rotVel[1];
	result += (2.0f*(wheelVel[1] * tmp[1] + wheelVel[2] * tmp[2]));
	// fourth term
	tmp[0] = 0.0f;
	tmp[1] = rotVel[2];
	tmp[2] = -rotVel[1];
	result -= (2.0f*(posVel[1] * tmp[1] + posVel[2] * tmp[2]));
	// fifth term
	result += tireForce[0] * m_invWheelMass; 
	// sixth term
	result -= bodyForce[0] * m_invBodyMass; 
#endif

	return (-result);
}

// m_ComputeResultFromEqB
float PhysicsCar::m_ComputeResultFromEqB(float rcToWheel[3], float rc[3], float bodyTorque[3],
										 float tireForce[3], float bodyForce[3], 
										 float wheelVel[3], float posVel[3], float rotVel[3])
{
	float tmp[3],tmp2[3];
	float result;
#if 0
	// first term
	V3Cross(tmp, rotVel, rc);
	V3Add(tmp, posVel, tmp);
	V3Sub(tmp, wheelVel, tmp);
	result = -V3Dot(tmp, tmp);
	// second term
	V3Mul(tmp,tireForce, m_invWheelMass);
	result -= V3Dot(rcToWheel,tmp);
	// third term
	V3Mul3x3(tmp,bodyTorque, m_xMatrix);
	V3Cross(tmp, rc, tmp);
	result -= V3Dot(rcToWheel, tmp);
	// fourth term
	V3Cross(tmp, rotVel, rc);
	V3Cross(tmp, rotVel, tmp);
	result += V3Dot(rcToWheel, tmp);
	// fifth term
	V3Mul(tmp, bodyForce, m_invBodyMass);
	result += V3Dot(rcToWheel, tmp);
#else
	// first term
	tmp[0] = rotVel[1] * rc[2] - rotVel[2] * rc[1] + posVel[0] - wheelVel[0];
	tmp[1] = rotVel[2] * rc[0] - rotVel[0] * rc[2] + posVel[1] - wheelVel[1];
	tmp[2] = rotVel[0] * rc[1] - rotVel[1] * rc[0] + posVel[2] - wheelVel[2];
	result = -(tmp[0] * tmp[0] + tmp[1] * tmp[1] + tmp[2] * tmp[2]);
	// second term
	tmp[0] = 0.0f;
	tmp[1] = tireForce[1] * m_invWheelMass;
	tmp[2] = tireForce[2] * m_invWheelMass;
	result -= (rcToWheel[1] * tmp[1] + rcToWheel[2] * tmp[2]);
	// third term
	tmp[0] = bodyTorque[0]*m_xMatrix[0][0];
	tmp[1] = bodyTorque[1]*m_xMatrix[1][1];
	tmp[2] = bodyTorque[2]*m_xMatrix[2][2];
	tmp2[0] = 0.0f;
	tmp2[1] = rc[2] * tmp[0] - rc[0] * tmp[2];
	tmp2[2] = rc[0] * tmp[1] - rc[1] * tmp[0];
	result -= (rcToWheel[1] * tmp2[1] + rcToWheel[2] * tmp2[2]);
	// fourth term
	tmp[0] = rotVel[1] * rc[2] - rotVel[2] * rc[1];
	tmp[1] = rotVel[2] * rc[0] - rotVel[0] * rc[2];
	tmp[2] = rotVel[0] * rc[1] - rotVel[1] * rc[0];
	tmp2[1] = rotVel[2] * tmp[0] - rotVel[0] * tmp[2];
	tmp2[2] = rotVel[0] * tmp[1] - rotVel[1] * tmp[0];
	result += (rcToWheel[1] * tmp2[1] + rcToWheel[2] * tmp2[2]);
	// fifth term
	tmp[0] = 0.0f;
	tmp[1] = bodyForce[1] * m_invBodyMass;
	tmp[2] = bodyForce[2] * m_invBodyMass;
	result += (rcToWheel[1] * tmp[1] + rcToWheel[2] * tmp[2]);
#endif
	return (-result);
}


void PhysicsCar::m_EvalDiff(float *in, float *out)
{
	float wheelPos[TIRECOUNT][3];
	float wheelVel[TIRECOUNT][3];
	float rcToWheel[TIRECOUNT][3];
	float springForce[4][3];
	float aeroForce[3];
	float downForce[2]; // front and back
	float wheelForce[4][3];
	float bodyForce[3] = {0.0f, 0.0f, 0.0f};
	float bodyTorque[3] = {0.0f,0.0f,0.0f};
	float fc[8];  // fc(i1), fc(i2), fc(j1), fc(j2), fc(k1), fc(k2), fc(l1), fc(l2)
	float posVel[3];
	float rotVel[3];
	float wheelSpinVel[4];
	float wheelTanSlip[4];
	float wheelHeightWorld[4];

	m_ComputeTransformMatrix();

	// convert from world to body space
	for (int i=0; i<TIRECOUNT; i++)
	{
		m_WorldToBody(wheelPos[i], in+WHEELOFFSET+i*3);
		m_WorldToBodyRotate(wheelVel[i], in+WHEELVELOFFSET+i*3);
		rcToWheel[i][0] = 0.0f;
		rcToWheel[i][1] = wheelPos[i][1] - m_suspension.m_rollCenter[i][1];
		rcToWheel[i][2] = wheelPos[i][2] - m_suspension.m_rollCenter[i][2];

		wheelHeightWorld[i] = *(in+WHEELOFFSET+i*3+2);
	}
	m_WorldToBodyRotate(posVel, in+POSVELOFFSET);
	m_WorldToBodyRotate(rotVel, in+ROTVELOFFSET);
	V4Set(wheelSpinVel, in+WHEELSPINOFFSET);
	V4Set(wheelTanSlip, m_wheelTanSlip);


	// Calculate all the forces acting on the body and wheels
	m_UpdateSpringForces(springForce, rcToWheel, wheelPos, wheelVel, posVel, rotVel);
//	printf("spring force is %5.2f, %5.2f, %5.2f\n", springForce[0][0], springForce[0][1], springForce[0][2]);

	m_UpdateAerodynamicForces(posVel, aeroForce, downForce);
//	printf("aero force is %5.2f, %5.2f, %5.2f\n", aeroForce[0], aeroForce[1], aeroForce[2]);

	m_UpdateBodyForces(bodyForce, springForce, aeroForce, downForce);
//	printf("body force is %5.2f, %5.2f, %5.2f\n", bodyForce[0], bodyForce[1], bodyForce[2]);

	m_UpdateBodyTorque(bodyTorque, springForce, downForce);
//	printf("bodyTorque is %5.2f, %5.2f, %5.2f\n", bodyTorque[0], bodyTorque[1], bodyTorque[2]);

	m_UpdateWheelForces(wheelForce, springForce, wheelHeightWorld);
//	printf("wheel force is %5.2f, %5.2f, %5.2f\n", wheelForce[0][0], wheelForce[0][1], wheelForce[0][2]);

	m_UpdateTireForces(wheelForce, wheelVel, wheelSpinVel, wheelTanSlip, wheelHeightWorld);
//	printf("wheel force is %5.2f, %5.2f, %5.2f\n", wheelForce[0][0], wheelForce[0][1], wheelForce[0][2]);

	m_ComputeConstraintForces(fc, wheelForce, bodyForce, bodyTorque, wheelPos, 
							  wheelVel, rcToWheel, posVel, rotVel);
//	printf("fc is \n");
	for (int i=0; i<8; i++)
	{
//		printf("%5.2f\n", fc[i]);
	}
	float tmp[3];
	float acc[3];

	// set pos to be velocity
	V3Set(out, in+POSVELOFFSET);

	// Fci = fc[0] * rcToWheel + fc[1] * g_constraintX
	// body accel = (Fext + Fci + Fcj + Fck + Fcl) / bodyMass
	V3Set(acc, bodyForce);
	for (int tire = 0; tire<TIRECOUNT; tire++)
	{
		acc[0] += fc[tire*2+1];
		acc[1] += fc[tire*2] * rcToWheel[tire][1];
		acc[2] += fc[tire*2] * rcToWheel[tire][2];
	}
	V3Mul(acc, acc, m_invBodyMass);

	m_BodyToWorldRotate(out+POSVELOFFSET, acc);

	// quaternion update
	V3Set(tmp, in+ROTVELOFFSET);
	V3Mul(tmp, tmp, 0.5f);
	VECBYQUAT(out+QUATOFFSET, tmp, in+QUATOFFSET);

	// angular accel = (Text + (ri x Fci) + (rj x Fcj) + (rk x Fck) + (rl x Fcl) - (w x Iw)) / I
	// update rotational velocity and quaternion
	// store off current rotational velocity
	V3Set(acc, bodyTorque);
	for (tire=0; tire<TIRECOUNT; tire++)
	{
		tmp[0] = fc[tire*2+1];
		tmp[1] = fc[tire*2] * rcToWheel[tire][1];
		tmp[2] = fc[tire*2] * rcToWheel[tire][2];
		V3Cross(tmp, wheelPos[tire], tmp);
		V3Add(acc, acc, tmp);
	}
	// subtract off (w x Iw) 
	V3Mul3x3(tmp, rotVel, m_iMatrix);
	V3Cross(tmp, rotVel, tmp);
	V3Sub(acc, acc, tmp);

	V3Mul3x3(acc, acc, m_xMatrix);
	m_BodyToWorldRotate(out+ROTVELOFFSET, acc);

	// wheel acceleration = (Fext - Fci, Fext - Fcj, etc.) / wheelMass
	for (tire=0; tire<TIRECOUNT; tire++)
	{
		V3Set(out+WHEELOFFSET+tire*3,in+WHEELVELOFFSET+tire*3);
		acc[0] = (wheelForce[tire][0] - fc[tire*2+1]) * m_invWheelMass;
		acc[1] = (wheelForce[tire][1] - fc[tire*2] * rcToWheel[tire][1]) * m_invWheelMass;
		acc[2] = (wheelForce[tire][2] - fc[tire*2] * rcToWheel[tire][2]) * m_invWheelMass;
		m_BodyToWorldRotate(out+WHEELVELOFFSET+tire*3,acc);
	}
	V4Set(out+WHEELSPINOFFSET, wheelSpinVel);
//	V4Set(out+WHEELTANSLIPOFFSET, wheelTanSlip);
}

void PhysicsCar::m_IntegratorEuler(float *y, float *dydx, float h, float *yout)
{
	for (int i = 0; i<NUMBEROFEQU; i++) 
	{
		yout[i] = dydx[i]*h + y[i];
	}
}


void PhysicsCar::m_IntegratorRK2(float *y, float *dydx, float h, float *yout) 
{
	float h34;					// Some step contants
	float dyt[NUMBEROFEQU];		//      ditto
	float yt[NUMBEROFEQU];		//      ditto

	h34 = THREE_FOURTHS*h;
	
	// Step 1
	for (int i = 0; i<NUMBEROFEQU; i++) 
	{
		yt[i] = y[i] + h34*dydx[i];
	}

	m_EvalDiff(yt, dyt);

	for (i = 0; i<NUMBEROFEQU; i++) 
	{
		yout[i] = (TWO_THIRDS*dyt[i] + ONE_THIRD*dydx[i])*h + y[i];
	}

}


void PhysicsCar::m_IntegratorRK4(float *y, float *dydx,float h, float *yout) 
{
	int i;
	float hh,h6;				// Some step contants
	float dym[NUMBEROFEQU];		// partial evaluation
	float dyt[NUMBEROFEQU];		//      ditto
	float yt[NUMBEROFEQU];		//      ditto


	// init some values
	
	hh = 0.5f*h;
	h6 = h*(1.0f/6.0f);

	// First Step
	for (i = 0; i<NUMBEROFEQU; i++) 
	{
		yt[i] = y[i] + hh*dydx[i];		// Same as simple euler method to halfway
	}
	
	// Second Step
	m_EvalDiff(yt, dyt);				// use first order approx to compute dirrivatives
	for (i = 0; i<NUMBEROFEQU; i++) 
	{
		yt[i] = y[i] + hh*dyt[i];		// use new diff as actual step (second order approx)
	}


	// Third Step
	m_EvalDiff(yt, dym);				// use second order approx 
	for (i = 0; i<NUMBEROFEQU; i++) 
	{
		yt[i] = y[i]+h*dym[i];			// compte 3rd order approx
		dym[i] += dyt[i];				// accumulate 2nd and 3rd order dirrivatives
	}

	// Forth Step
	m_EvalDiff(yt, dyt);				// use third order approx but step to end
	
	// Accumulate Increments with appropriate weights
	for (i = 0; i<NUMBEROFEQU; i++) 
	{
		yout[i] = y[i] + h6*(dydx[i] + dyt[i] + 2.0f*dym[i]);
	}

}


void PhysicsCar::m_Integrator(float *y, float *dydx,float h, float *yout)
{
	m_IntegratorRK2(y, dydx,h, yout);
//	m_IntegratorEuler(y, dydx,h, yout);
}


void PhysicsCar::m_SetBrakes(float brakes)
{
}

void PhysicsCar::m_SetSteering(float steer)
{
}

void PhysicsCar::m_SetDrive(float revs)
{
}

void PhysicsCar::m_MoveTo(float transform[4][4])
{
//	V3Set(m_transform[3],transform[3]);
}

void PhysicsCar::m_MoveToPosition(V2 pos)
{
}

void PhysicsCar::m_MoveToStart(int position)
{
}

void PhysicsCar::m_SetGear(int gear)
{
//	m_engine.m_currGear = gear;
}

void PhysicsCar::m_GetTransform(float transform[4][4])
{
	M4Set(transform, m_transform);
	V3Mul4x3(transform[POSITION], m_bodyOffset, transform);
}

void PhysicsCar::m_GetWheelTransform(short tire, float transform[4][4], float caliperTransform[4][4])
{
	float rx  = (CAR_WHEEL_RIGHT(tire)? GAME_PI : 0.0f) - m_suspension.m_camber[tire];
	float ry  = (CAR_WHEEL_RIGHT(tire)? -m_wheelRotationAngle[tire] : m_wheelRotationAngle[tire]);
	float rz  =  CAR_WHEEL_FRONT(tire)? (CAR_WHEEL_RIGHT(tire)? -m_steerAngle : m_steerAngle) : 0.0f;

	M4FromYZXRot(transform,        rx,  ry,   rz);

	rx = -m_suspension.m_camber[tire];
	rz =  CAR_WHEEL_FRONT(tire)? m_steerAngle : 0.0f;
	M4FromYZXRot(caliperTransform, rx, 0.0f, rz);

	M4Mul4x3(transform,        m_transform);
	M4Mul4x3(caliperTransform, m_transform);

	V3Mac(transform[POSITION], m_wheel[tire], m_transform[UP], m_engine.m_wheelRadius[tire]);
	V3Set(caliperTransform[POSITION], transform[POSITION]);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4229\PhyEngine.cxx ===
#include "names.h"
#include "types.h"
#ifdef GAME
#include "Game.h"
//#include "CarGeometry.h"
//#include "Car.h"
#endif

#include "PhyEngine.h"
#include "moremath.h"
#include "CarWheelNumbers.h"
#include "PhysicsCar.h"



#define STALLSPEED ((800.0f/60.0f) * 2.0f * 3.14159265f)
#define CLUTCHRATE (1.0f/1.8f)

#define RPM2RADSEC(x) ((x)*2.0f*3.14159265f/60.0f)

#define MAXRPM                     12000.0f
#define MAXWHEELSPEEDDIFF          3000.0f//30000.0f
#define MIN_GROUND_SPEED                  0.01f
#define MIN_BRAKE_TORQUE				  50.0f
#define EPS                               0.01f

void Engine::m_Init()
{
	m_gearCount = 5;
	m_finalRatio = 4.1f;
	m_gearRatio[0] = 0.0f;
	m_gearRatio[1] = 3.83f;
	m_gearRatio[2] = 2.20f;
	m_gearRatio[3] = 1.40f;
	m_gearRatio[4] = 1.0f;
	m_gearRatio[5] = 0.83f;
	m_gearRatio[6] = 0.0f;
	m_gearRatio[7] = 0.0f;
	m_shiftPoint[0] = 33.0f;  // rads/sec
	m_shiftPoint[1] = 76.0f;
	m_shiftPoint[2] = 130.0f;
	m_shiftPoint[3] = 170.0f;
	m_shiftPoint[4] = 700.0f;
	m_shiftPoint[5] = 700.0f;
	m_shiftPoint[6] = 700.0f;
	m_maxAcceleration = 0.0f;
	m_maxPower = 149.2f;
	m_maxRPM = 6750.0f;
	m_currGear = 0;
	m_revvy = 0.0f;
	m_driveWheels = DRIVE_FRONTWHEEL;

	float maxW = RPM2RADSEC(m_maxRPM);  // convert to Rad/sec
	m_engineCoefs[0] = m_maxPower/maxW;
	m_engineCoefs[1] = m_maxPower/(maxW*maxW);
	m_engineCoefs[2] = -m_maxPower/(maxW*maxW*maxW);
	m_engineCoefs[3] = 0.0f;

	m_inertiaWheel = 7.0f;   // inertia per wheel
	m_inertiaEngine = 0.7f;   // inertia of engine, clutch 
	m_inertiaTransmission = 0.08f;  // inertia of propeller shaft & all elements of transmission
	for (int i=0; i<4; i++)
	{
		m_accelTorque[i] = 0.0f;
		m_brakeTorque[i] = 0.0f;
		m_wheelRadius[i] = 0.33f;  
	}
	m_brakeFront = 2000.0f;
	m_brakeRear = 2000.0f;
 
	m_automatic = true;

	m_accelWeight[0] = 1.0f;
	m_accelWeight[1] = 1.0f;
	m_accelWeight[2] = 1.0f;
	m_accelWeight[3] = 1.0f;
	m_brakeWeight[0] = 1.0f;
	m_brakeWeight[1] = 1.0f;
	m_brakeWeight[2] = 1.0f;
	m_brakeWeight[3] = 1.0f;
}

float Engine::m_DetermineWheelTorque(float wheelrev, float accIn) 
{
	return 0;
}

void Engine::m_LimitRevs(float wheelRev,float wheelSpinVel[4]) 
{
	float rev = ABS(wheelRev * m_finalRatio * m_gearRatio[m_currGear]);
	// Compute Engine revs

	if (rev>RPM2RADSEC(MAXRPM)) 
	{
		rev = RPM2RADSEC(MAXRPM);
		wheelRev = SIGN_AS(ABS(rev/(m_finalRatio * m_gearRatio[m_currGear])), wheelRev);
		switch (m_driveWheels)
		{
		case (DRIVE_FRONTWHEEL):
			wheelSpinVel[0] = wheelSpinVel[1] = wheelRev;
			break;
		case (DRIVE_REARWHEEL):
			wheelSpinVel[2] = wheelSpinVel[3] = wheelRev;
			break;
		default: // (DRIVE_FOURWHEEL):
			wheelSpinVel[0] = wheelSpinVel[1] = wheelSpinVel[2] = wheelSpinVel[3] = wheelRev;
			break;
		}
	}
}

void Engine::m_AutoBox(float wheelRev/*, Input *in*/) 
{
	if (m_currGear == -1)
	{
		return;
	}


#if 0
	if (in && (in->Pressed(PAD_REVERSE) && m_currGear ==0)) 
	{
		return;
	}
#endif

/*
#ifdef GT
	if (c->flags & RCF_MANUAL_TRANSMISSION)
	{
		if (in->PressedAndDebounced(PAD_GEARUP) && (m_currGear < (m_gearCount-1))) 
		{
			m_currGear++;
		}
		if (in->PressedAndDebounced(PAD_GEARDOWN) && (m_currGear > 0)) 
		{
			m_currGear--;
		}
	}
	else
#endif
*/
	{
		// we only shift gears if the car is on the ground.
//		if (!c->noWheelContact)
		{
			if (m_currGear < (m_gearCount))
			{
				if (wheelRev > (m_shiftPoint[m_currGear-1]*1.05f))
				{
					m_currGear++;
				}
			}
			if (m_currGear > 1)
			{
				if (wheelRev < (m_shiftPoint[m_currGear-2]*0.80f))
				{
					m_currGear--;
				}
			}
		}
	}

}



#define TIREMAXDEMAND 3.5f

void Engine::m_ComputeAccelAndBrakeTorques(float accel, float brakes, short isEBrake,
										   short isReverse, float torqueMultiplier)
{	
}


// Input is Wheel and applied Longitudinal force
float Engine::m_ComputeWheelAcceleration(float wheelSpinVel, int wheel, float fx) 
{
	float ret = 0.0f;
	return ret;	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4229\PhyTire.h ===
// Tire.h: interface for the CTire class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __TIRE_H
#define __TIRE_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

extern float g_minLoadWeight;

#define SIMTIRE 0			// 1 = Pajejka tire  0 = WDC cubic tire
#define SIMLOAD 1			// 1 = Actual load changes 0 = Limited load shifts - overrides producer number
#define FIXEDLOAD 0			// 1 = No load shift (always set to minload)
#define MINLOAD (4200.0f*(g_minLoadWeight/100.0f))
#define MAXLOAD 16000.0f
#define LIMITEDLOADSHIFT 0	// 


struct Tire  
{
public:
	float m_baseLoad;
	float m_corneringStiffness;
	float m_csSensitivityToFv;
	float m_muY;
	float m_muX;
	float m_muYSensitivityToFv;
	float m_muXSensitivityToFv;
	float m_camberStiffness;
	float m_longStiffness;
	float m_a, m_b, m_c, m_d, m_e;
	float m_tireSpringConst;
	float m_peakTraction;
	int m_model;

	void m_Init();
	float m_NormalizedCamber(float c, float mu);
	void m_ComputeTireForces(float fz, float camber, float tanSlipAngle, float slipRatio, 
							 float *fy, float*fx, short groundType);
	float m_MuY(float fv, short groundType);
	float m_MuX(float fv, short groundType);
	float m_CorneringStiffness(float fv);
	float m_Pacejka(float x);

private:



};

#endif // !defined(AFX_TIRE_H__6B1E5952_9D85_42CC_A5FA_EC21883F6003__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4229\PhyTire.cxx ===
// Tire.cpp: implementation of the CTire class.
//
//////////////////////////////////////////////////////////////////////

#include "PhyTire.h"

#include "moremath.h"
#include "SurfaceType.h"


float g_minLoadWeight = 100.0f;

const float g_muSurfaceTable[SURFACETYPE_COUNT] = 
{
	1.0f,   // road
	0.7f,   // runofff
	0.5f,  // sand
	0.9f    // grass
};


#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#define EPS (0.0001f)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


void Tire::m_Init()
{
	m_a = 0.0f;
	m_b = 0.714f;
	m_c = 1.4f;
	m_d = 1.0f;
	m_e = -0.2f;

	// Real numbers for an F1 car
	m_corneringStiffness = 40.0f; // per Rad
	m_baseLoad = 832.0f;
	m_csSensitivityToFv = 0.1f;
	m_muY = 1.6f;
	m_muX = 1.4f;
	m_muYSensitivityToFv = -0.24f;
	m_muXSensitivityToFv = -0.24f;

	m_camberStiffness = 0.42f;

	m_longStiffness = 25.0f;		// Initial gradient of Normalised long force versus Slip
	m_tireSpringConst = 150000.0f;
	m_peakTraction = 0.1f;  // where on the tire curve is the maximum traction point

}


float Tire::m_Pacejka(float alpha)
{
	return 0;

}

float Tire::m_CorneringStiffness(float fv)
{
	return (m_corneringStiffness * (float)exp((double)-m_csSensitivityToFv*(fv/m_baseLoad - 1)));
}

float Tire::m_MuY(float fv, short groundType)
{
	float ret;
	if (fv <= EPS)
	{
		return (EPS);
	}
	else
	{
		ret = m_muY * powf(fv/m_baseLoad, m_muYSensitivityToFv);
	}
	if (groundType != SURFACETYPE_ROAD)
	{
		ret *= g_muSurfaceTable[groundType];
	}
	return (ret);
}


float Tire::m_MuX(float fv, short groundType)
{
	float ret;
	if (fv <= EPS)
	{
		return (EPS);
	}
	else
	{
		ret = m_muX * powf(fv/m_baseLoad, m_muXSensitivityToFv);
	}
	if (groundType != SURFACETYPE_ROAD)
	{
		ret *= g_muSurfaceTable[groundType];
	}
	return (ret);
}


float Tire::m_NormalizedCamber(float c, float mu)
{
	return m_camberStiffness * sinf(c) / mu;
}



#define sign(x) ((x)>=0.0f? 1.0f: -1.0f)

void Tire::m_ComputeTireForces(float fz, float camber, float tanSlipAngle, float slipRatio, 
							   float *fy, float *fx, short groundType)
{
#if (!SIMLOAD)
	if (fz<MINLOAD)
		fz = MINLOAD;
	if (fz>MAXLOAD)
		fz = MAXLOAD;
#endif
#if (FIXEDLOAD)
	fz = MINLOAD;
#endif
#if (LIMITEDLOADSHIFT)

#endif
	

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4229\PhyTrack.h ===
#ifndef __PHYPATCH_H
#define __PHYPATCH_H

#ifndef __VECTOR_H
#include "vector.h"
#endif

#define NEIGHBOR_COUNT 4
#define MAX_CONE_COUNT  10
#define MAX_PATCHES_PER_CURB 50
#define MAX_EDGE_COUNT  3000

enum
{
	VPOS = 0,
	UPOS,
	VNEG,
	UNEG
};

enum
{
	EDGE_INSIDE = 1,
	EDGE_OUTSIDE	
};

struct PhyCone
{
	// those orange cones people like to run over
	float m_pos[3];
	float m_posVel[3];
	float m_rotVel[3];
	float m_quat[4];
	float m_transform[4][4];
	float m_radius;
	float m_groundHeight;
	float m_quatFinal[4];
	short m_interpolating;
};

struct PhyCurb
{
	// rumble strips
	float m_controlPts[MAX_PATCHES_PER_CURB][3][3][3];	
	int m_count;
};

struct PhyPatch 
{
public:
	float m_controlPts[3][3][3];
	int m_neighbor[NEIGHBOR_COUNT];  // index into PhyTrack.m_patch[];   
	short m_checked;
	int m_group;
	int m_curbIndex;                   // -1 if no curb, otherwise index into g_phyTrack.m_curb[]
	short m_isEdge;
	short m_divisions;            // number of subdivision along the track (not across)
	short m_forwardDirection;     // is the coord along the track UPOS, UNEG, VPOS, or VNEG
	short m_groundType;
};

// PhyEdge holds all the edges for each group
struct PhyEdge
{
public:
	int m_pt1;         // index into PhyTrack.m_edgeVerts[]
	int m_pt2;         // index into PhyTrack.m_edgeVerts[]
	float m_plane[4];  // wall normal and dist
	short m_side;      // EDGE_INSIDE or EDGE_OUTSIDE 
};

struct PhyEdgeGroup
{
public:
	int m_edgeIndex;           // index into PhyEdge list
	int m_edgeCount;           // edge count for this group
	float m_length;            // distance along midline for this group
	float m_distanceToStart;   // distance from this group to start group
	float m_forward[3];        // vector that points positive direction along track in world space
	float m_center[3];         // center point of group
};


struct PhyTrack
{
public:
	PhyTrack();

	PhyCone m_cone[MAX_CONE_COUNT];
	PhyCurb *m_curb;
	PhyPatch *m_patch;           // array of patches
	PhyEdge *m_edge;
	PhyEdgeGroup *m_edgeGroup;   // each group contains index into m_edge
	V3 *m_edgeVert;
	int m_coneCount;
	int m_curbCount;
	int m_patchCount;
	int m_edgeCount;
	int m_groupCount;
	int m_vertCount;
	int m_isClockwise;               // clockwise is decreasing group numbers, while counterclockwise is increasing
	int m_startGroup;

	void m_UpdateCones(float dt);
	void m_LoadTrack(char *trackName);
	void m_AttachNeighbors();
	void m_FixWhackedPatches();
	void m_GroupPatches();
	short m_PointInPatch(float *pt, int patch);
	void m_AddEdgesToGroups();
	void m_CreateVertsFromBezier(float cp[3][3], int group, int divisions, short side);
	void m_ComputeEdges();
	void m_ComputeGroupForwardVector();
	void m_ComputeGroupDistanceFromStart();
	void m_ComputeCoordinatesAlongPatch();
	void m_FindPatchCurb();

private:
	void m_GetEdgeCornerPoints(PhyPatch *p, int edge, V3 pt1, V3 pt2);
};

#ifdef GAME
extern PhyTrack g_phyTrack;
#endif

#endif // __PHYPATCH_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4229\PhysicsCollision.cxx ===
// Patch1Test.cpp : Defines the entry point for the application.
//

//#include "stdafx.h"
#include "PhysicsCar.h"
#include "PhyTrack.h"
#include "moremath.h"
#include "vector.h"
#if GAME
#include "names.h"
#include "types.h"
#include "Game.h"
#include "CarGeometry.h"
#include "Car.h"
#endif

#define MAXITERATIONS                    7
#define ROOTCHECK_EPSLION                 0.005f
#define MAX_PATCH_SEARCHES               10
#define MAX_UV_STEP                      0.2f
#define MIN_CAR_DISTANCE_FROM_WALL       3.0f
#define SLOW_DOWN_MULTIPLIER             0.975f
#define DEFLECTION_MULTIPLIER            1.05f
#define MIN_DEFLECTION_FORCE            -0.20f
#define MIN_ACTIVE_WALL_DISTANCE         20.0f
#define MIN_WALL_COUNT                   12
#define ONE_FIFTH                        0.2f
#define WALL_COLLISION_DIST              0.1f
#define MIN_SPARK_SPEED                  5.0f
 
const float ONE = 1.0f;
const float TWO = 2.0f;
const AV4 U3 = {1.0f,0.0f,1.0f,0.0f};
const __declspec(align(16)) int ABSMASK[4] = {0x7FFFFFFF,0x7FFFFFFF,
                                              0x7FFFFFFF,0x7FFFFFFF};

//extern PhyTrack g_phyTrack;
extern float g_constraintX[3];


#if GAME
extern Car g_car[MAX_CAR_SLOTS];
extern int g_cars;
#endif


#define BEZIERBASIS 1
#if BEZIERBASIS
// Bezier basis
static float BMatrix[3][4] =
{
    {  1.0f, -2.0f,  1.0f, 0.0f },
    { -2.0f,  2.0f,  0.0f, 0.0f },
    {  1.0f,  0.0f,  0.0f, 0.0f }
};

#else
// B-spline basis
static float BMatrix[3][4] =
{
    {  0.5f, -1.0f,  0.5f, 0.0f },
    { -1.0f,  1.0f,  0.0f, 0.0f },
    {  0.5f,  0.5f,  0.0f, 0.0f }
};
#endif

void PhysicsCar::m_FindStartingPatch()
{
}

// %%% DEREK - look into storing off projected cps for each wheel in phycar (might save some work) - derek
void PhysicsCar::m_SearchForCurb(int tire)
{
}

void PhysicsCar::m_TrackPosition(short tire)
{
}


// Find the u & v values of point (0,0) on the current patch. Return TRUE if point is on the patch,
// return FALSE if not on the patch
short PhysicsCar::m_NewtonIteration(float cpProj[3][3][2], float &uValue, float &vValue)
{
	return (true);
}


// Always project the control points down the world's UP vector. The roads will
// always be pretty damn close to parallel with the XY plane
void PhysicsCar::m_FindProjectedControlPoints(short tire,
											  float cpts[NUM_S_CPS][NUM_T_CPS][3],
										      float cpProj[NUM_S_CPS][NUM_T_CPS][2])
{

}


//-------------------------------------------

void PhysicsCar::m_ComputeMxy(float cp[3][3][2], float Mxy[9][4])
{
}

void PhysicsCar::m_UpdateUV(float Mxy[9][4], float &uValue, float &vValue, float &rootCheck)
{
}



void PhysicsCar::m_ComputeRoadNormal(float s, float t, float cp[NUM_T_CPS][NUM_S_CPS][3],
									 float *normal)
{
}

void PhysicsCar::m_GetPatchIntersectionPoint(float s, float t, float cp[NUM_T_CPS][NUM_S_CPS][3],
											 float *roadPt)
{
}

float PhysicsCar::m_HeightOfRoad(float s, float t,
								 float cp[NUM_T_CPS][NUM_S_CPS][3])
{
	return 0;
}



void PhysicsCar::m_AddToEndOfWallCache()
{
}

void PhysicsCar::m_AddToFrontOfWallCache()
{
}

void PhysicsCar::m_UpdateActivePatchGroups()
{
	
	if (m_wallCount == 0)
	{
		return;
	}
	m_AddToFrontOfWallCache();
	m_AddToEndOfWallCache();
}

// m_DeterminePlaneIntersection returns true if there is an intersection,
// false otherwise.
short PhysicsCar::m_DeterminePlaneIntersection(float *plane)
{
#if 1
	float tmp[3];
	V3Norm(tmp, m_transform[FORWARD]);
	V3Mul(tmp, m_boxOffset);
	V3Add(tmp, m_pos);
#endif
	float carDist = V3Dot(plane, tmp) - plane[3];

	if (carDist > MIN_CAR_DISTANCE_FROM_WALL)
	{
		// if center of car is too far away from wall we trivially reject (no collision)
		return (false);
	}

	float xDist = m_length * 0.5f * V3Dot(m_transform[FORWARD], plane);
	float yDist = m_width * 0.5f * V3Dot(m_transform[SIDE], plane);

	if (((carDist + xDist + yDist) < 0.0f) ||
		((carDist + xDist - yDist) < 0.0f) ||
		((carDist - xDist + yDist) < 0.0f) ||
		((carDist - xDist - yDist) < 0.0f))
	{ 
		return (true);
	}
	return (false);
}


// m_FindSeparatingPlane returns TRUE if a separating plane exists (no collision) 
// or FALSE if there is no separating plane (we have a collision)
short PhysicsCar::m_FindSeparatingPlane(WallSegment *wallSeg, float timeStep, short saveOff)
{
	return (false);
}


// If saveOff is true and we find a new sep plane for a particular wall
// then the curr sep plane for that wall is saved off. Otherwise, we only save off
// on a full integrator step, not on sub-divided steps.
short PhysicsCar::m_CheckCollisionWithWall(int &activeWall, float timeStep, short saveOff)
{
	return (false);
}

void PhysicsCar::m_FindCollidingCorner(float *plane, int &corner, float *vel)
{	
}

// plane, velocity are in body space
void PhysicsCar::m_ApplyWallImpulse(float *planeBS, float *posVelBS, float *rotVelBS, 
									float *cornerVelBS, float *cornerBS)
{
}

void PhysicsCar::m_CheckForGroundingCorners()
{
}

short PhysicsCar::m_CheckCollisionWithCone()
{
	return (false);
}

void V2Mul2x2(float *dest, float *src1, float src2[4][4]) 
{
	register floatType x,y;
	x = src1[0];
	y = src1[1];
	dest[0] = x*src2[0][0] + y*src2[1][0];
	dest[1] = x*src2[0][1] + y*src2[1][1];
}

void V2Mul2x2T(float *dest, float *src1, float src2[4][4]) 
{
	register floatType x,y;
	x = src1[0];
	y = src1[1];
	dest[0] = x*src2[0][0] + y*src2[0][1];
	dest[1] = x*src2[1][0] + y*src2[1][1];
}


// This applies an impulse with a somewhat scaled down rotatinal component
// Also assume car is flat (which is probably not true
void BodgedImpulse(PhysicsCar *c1, float rx, float ry, PhysicsCar *c2, float rx2, float ry2, float *N, float j) 
{
}

// ---------------------------------------------------------------
// I think B[3][3] is in   M*c form 
int BoxIntersection(float B[4][4], float T[3], float a[3], float b[3])
{
	return 0;
}

//float pListIn[5][2] = { {2.22f, 0.996f}, {2.22f, -0.996f}, {-2.22f, -0.996f}, {-2.22f, 0.996f}, {2.22f, 0.996f}};
float pListInT[9][2];
float pListOut1[9][2];


int ClipVsPlane(float pin[][2], int points, float *PE, float pout[][2]) 
{
	return 0;
}


int GetCollisionManifoldCentroid(float B[4][4], float T[3], float a[3], float b[3], float *out) 
{
	return 0;
}



#define THRESHOLD 1.1f
#define MINSEPSPEED 0.5f
#define MAXSEP 1.5f
#define RR 1.02f 
#define RR2 1.001f
#define SPTEST 10.0f
#define SAFEDIST 7.0f
#define CAR_SIZE_ADJUST 0.15f

// Perform a check between 2 cars and resolve response
// Assumes that c1 vertex is hitting c2 (not always right but not a horrible approximation

short PhysicsCar::m_CheckCollisionWithCar(PhysicsCar *c2) 
{
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4229\PhysicsCar.h ===
#ifndef __PHYSICSCAR_H
#define __PHYSICSCAR_H

#ifndef __PHYENGINE_H
#include "PhyEngine.h"
#endif
#ifndef __PHYTIRE_H
#include "PhyTire.h"
#endif
#ifndef __SUSPENSION_H
#include "Suspension.h"
#endif
#ifndef __VECTOR_H
#include "vector.h"
#endif

#define TIRECOUNT   4
#define NUM_S_CPS 3 
#define NUM_T_CPS 3
#define CACHED_WALL_COUNT  150
#define MAX_STEER_ENTRIES 16



struct Input;
struct PhyPatch;
struct PhyEdge;

enum
{
	SUSP_FRONT_LEFT = 0,
	SUSP_FRONT_RIGHT,
	SUSP_BACK_LEFT,
	SUSP_BACK_RIGHT,
	SUSP_LENGTH_COUNT
};

struct TRACTION
{
	float x, y, t;
};

struct WallSegment
{
	float m_pt1[3];
	float m_pt2[3];
	float m_plane[4];        // wall's normal and dist
	float m_sepPlane[4];     // last valid separating plane with car
	float m_sepPlaneOld[4];  // previous valid sep plane
	int m_group;
	short m_planeValid;
	short m_planeValidOld;
	short m_side;            
};



struct PhysicsCar 
{
public:
	Engine m_engine;
	Suspension m_suspension;
	Tire  m_tire[2];      // front and back

	float m_pos[3];       // position
	float m_posVel[3];    // positional velocities, world space
	float m_quat[4];      // quaternion
	float m_rotVel[3];    // rotational velocities, world space
	float m_wheel[TIRECOUNT][3];      // Contact point of wheel, world space
	float m_wheelVel[TIRECOUNT][3];   // wheel positional velocity, world space
	float m_wheelSpinVel[TIRECOUNT];  // spinning speed of wheels, rads/sec
	float m_wheelTanSlip[TIRECOUNT];
	float m_wheelRotationAngle[TIRECOUNT];

	float m_steerTable[MAX_STEER_ENTRIES];
	float m_cogHeight;
	float m_bodyMass;
	float m_invBodyMass;
	float m_wheelMass;
	float m_invWheelMass;
	float m_tireRelaxLength;
	float m_differential[3];       // front, back, front to back
	float m_aeroDrag;              // aerodynamic drag
	float m_aeroFront;             
	float m_aeroRear;              
	float m_oldAeroFront;

	float m_bodyOffset[3];         // offset from cog to car model origin
	float m_width;                 // car width
	float m_height;
	float m_length;
	float m_corner[4][3];          // corners in body space
	float m_boxOffset;             // forward offset of collision box

	float m_transform[4][4];       // transformation matrix (body -> world)
	float m_invTransform[4][4];    // world to body
	float m_iMatrix[3][4];         // inertia matrix (really 3x3)
	float m_xMatrix[3][4];         // inverse inertia matrix (really 3x3)

	float m_stabilizerBar[2];      // force applied to prevent body roll, front, back

	float m_wheelToe;              // angle in radians
	float m_springLoadConstant[TIRECOUNT];  // ensures the car "rests" at 0 spring compression

	float m_groundNormal[TIRECOUNT][3];     // normal of ground under car
	float m_groundHeight[TIRECOUNT];        // height of ground below each wheel
	PhyPatch *m_patch[TIRECOUNT];           // patch tracked for each tire
	float m_groupDist[TIRECOUNT];           // distance percentage (0 - 1) along group for each tire

	float m_steerAngle;
	short m_inContact[TIRECOUNT];           // in contact with the road

	WallSegment m_wall[CACHED_WALL_COUNT];
	short m_wallIndex;
	short m_wallCount;

	float m_overSteerWeight;
	TRACTION m_traction[4];

	short m_normalizeQuaternion;        // don't re-normalize during collision checks
public:
	void m_InitCar(void);
	int  m_LoadCar(char* filename);
	void m_ResetCar(void);
	void m_HandleDriverInput(Input *in);
	void m_UpdatePosition(float dt);
	void m_RePositionWheels(void);
	void m_BodyToWorld(float *out, float *in);
	void m_BodyToWorldRotate(float *out, float *in);
	void m_WorldToBody(float *out, float *in);
	void m_WorldToBodyRotate(float *out, float *in);
	void m_UpdateWheelDifferentials(void);	
	void m_LocalWheelVel(float *localWheelVel, int tire);
	float m_DiffTanSlip(float wheelTanSlip, float vY, float absVX);
	void m_GetTireDemand(int tire, float steerAngle, TRACTION *out);



private:
	void m_AdjustWheelHeights(float *carOld, float *carNew);
	void m_CheckGimbleLock(void);
	void m_ComputeTransformMatrix(void);  // compute transform from pos & rotation
	void m_UpdateSpringForces(float springForce[4][3], float rcToWheel[4][3],
							float wheelPos[4][3], float wheelVel[4][3],
							float posVel[3],float rotVel[3]);
	void m_UpdateAerodynamicForces(float posVel[3], float aeroForce[3], float downForce[2]);
	void m_UpdateBodyForces(float bodyForce[3],float springForce[4][3],
							float aeroForce[3],float downForce[2]);
	void m_UpdateBodyTorque(float bodyTorque[3], float springForce[4][3], float downForce[2]);
	void m_UpdateWheelForces(float wheelForce[4][3], float springForce[4][3], float wheelHeightWorld[4]);
	void m_UpdateTireForces(float wheelForce[4][3],float wheelVel[4][3],
							float wheelSpinVel[4],float wheelTanSlip[4],float wheelHeightWorld[4]);
	void m_ComputeConstraintForces(float fc[8],float wheelForce[4][3],float bodyForce[3], float bodyTorque[3],
								   float wheelPos[4][3],float wheelVel[4][3],
								   float rcToWheel[4][3], float posVel[3], float rotVel[3]);
	void m_ComputeCoefMatrixForConstraintForces(float out[8][8],float wheelPos[4][3],
												float rcToWheel[4][3]);
	float m_ComputeCoefFromEqA(float wheel[3],float contraint[3]);
	float m_ComputeCoefFromEqB(float wheel[3], float rayToWheel[3], float contraint[3]);
	float m_ComputeCoefFromEqB2(float wheel[3], float rayToWheel[3]);
	float m_ComputeCoefFromEqC(float constraint1[3], float rc[3], 
							   float ray[3], float constraint2[3]);
	float m_ComputeCoefFromEqD(float constraint1[3], float rc[3], 
							   float ray[3], float constraint2[3]);
	float m_ComputeCoefFromEqD2(float constraint1[3], float rc[3],float ray[3]);
	float m_ComputeResultFromEqA(float tirePos[3], float bodyTorque[3],
								 float tireForce[3], float bodyForce[3], 
								 float wheelVel[3], float posVel[3], float rotVel[3]);
	float m_ComputeResultFromEqB(float ray[3], float rc[3], float bodyTorque[3],
								 float tireForce[3], float bodyForce[3], 
								 float wheelVel[3], float posVel[3], float rotVel[3]);
	void m_EvalDiff(float *in, float *out); 
	void m_IntegratorEuler(float *y, float *dydx, float h, float *yout);
	void m_IntegratorRK2(float *y, float *dydx, float h, float *yout);
	void m_IntegratorRK4(float *y, float *dydx, float h, float *yout);
	void m_Integrator(float *y, float *dydx, float h, float *yout);

	// Collision functions
	void m_SearchForCurb(int tire);
	void m_TrackPosition(short tire);
	short m_NewtonIteration(float cpProj[NUM_S_CPS][NUM_T_CPS][2], float &uValue, float &vValue);
	void m_FindProjectedControlPoints(short tire,float cpts[NUM_S_CPS][NUM_T_CPS][3],
									  float cpProj[NUM_S_CPS][NUM_T_CPS][2]);
	void m_UpdateUV(float Mxy[9][4], float &uValue, float &vValue, float &rootCheck);
	void m_ComputeMxy(float cp[3][3][2], float M[9][4]);
	void m_AddToFrontOfWallCache(void);
	void m_AddToEndOfWallCache(void);
	void m_UpdateActivePatchGroups(void);
	short m_DeterminePlaneIntersection(float *plane);
	short m_FindSeparatingPlane(WallSegment *wall, float timeStep, short saveOff);
	short m_CheckCollisionWithWall(int &activeWall, float timeStep, short saveOff);
	void m_FindCollidingCorner(float *planeBS, int &corner, float *vel);
	void m_ApplyWallImpulse(float *wallNorm, float *posVelBS, float *rotVelBS, 
						    float *cornerVel, float *cornerBS);
	void m_CheckForGroundingCorners(void);
	short m_CheckCollisionWithCone();
	short m_CheckCollisionWithCar(PhysicsCar *c2);

public:
	void m_FindStartingPatch(void);
	void m_ComputeRoadNormal(float s, float t, float cp[NUM_T_CPS][NUM_S_CPS][3],
							 float *normal);
	void m_GetPatchIntersectionPoint(float s, float t, float cp[NUM_T_CPS][NUM_S_CPS][3],
								     float *result);
	float m_HeightOfRoad(float s, float t, float cp[NUM_T_CPS][NUM_S_CPS][3]);

	// overrides for AI cars
	void m_SetBrakes(float brake);
	void m_SetDrive(float drive);
	void m_SetGear(int gear);
	void m_SetSteering(float steer);
	// for setting the car's approximate start line position
	void m_MoveTo(float transform[4][4]);
	void m_MoveToPosition(V2 pos);
	void m_MoveToStart(int position);
	void m_GetTransform(float transform[4][4]); 
	void m_GetWheelTransform(short wheel, float transform[4][4], float caliperTransform[4][4]);
};

#endif  // __PHYSICSCAR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4229\Suspension.cxx ===
#include "suspension.h"
#include "CarWheelNumbers.h"
#include "moremath.h"

// Roll and Camber Tables are filled out in TestGraph.cxx

void Suspension::m_Init()
{
	for (int tire=0; tire<TIRECOUNT; tire++)
	{
		if (CAR_WHEEL_FRONT(tire))
		{
			m_springConstA[tire] = 35000.0f;
			m_springConstB[tire] = 35000.0f;
			m_springDamper[tire] = 3000.0f;
			m_rollCenter[tire][0] = 1.35f;
			m_rollCenter[tire][1] = 0.0f;
			m_rollCenter[tire][2] = -0.35f;
			m_springLength[tire] = 0.30f;
		}
		else
		{
			m_springConstA[tire] = 35000.0f;
			m_springConstB[tire] = 35000.0f;
			m_springDamper[tire] = 3200.0f;
			m_rollCenter[tire][0] = -1.4f;
			m_rollCenter[tire][1] = 0.0f;
			m_rollCenter[tire][2] = -0.35f;
			m_springLength[tire] = 0.32f;
		}
		m_camber[tire] = 0.0f;
		m_initialCamber[tire] = 0.0f;
		m_rcToWheelLength[tire] = 0.8f;
	}
	m_springBodyPoint[0][0] = 0.0f;  // x offset is never used
	m_springBodyPoint[0][1] = 0.7f;
	m_springBodyPoint[0][2] = 0.0f;
	m_springBodyPoint[1][0] = 0.0f;  // x offset is never used
	m_springBodyPoint[1][1] = 0.7f;
	m_springBodyPoint[1][2] = 0.0f;
	for (int i=0; i<MAXROLLCENTERTABLE; i++)
	{
		m_rollCenterFrontTable[i] = 0.0f;
		m_rollCenterRearTable[i] = 0.0f;
		m_rcToWheelLengthTable[0][i] = 0.85f;
		m_rcToWheelLengthTable[1][i] = 0.85f;
		m_camberTable[0][i] = 0.0f;
		m_camberTable[1][i] = 0.0f;
	}

	m_maxSpringCompression = 0.12f;  // initialize to 12 cm ( CANNOT BE GREATER THAN 0.15 WITHOUT CHANGING "MAXROLLCENTERTABLE" in suspension.h)
}

void Suspension::m_UpdateRollCenter(float wheelHeight, short wheel)
{
	short index = (short)((m_springLength[wheel] + wheelHeight) * 100.0f + MAXROLLCENTERTABLE * 0.5f);
	if (index < 0)
	{
		index = 0;
	}
	if (index > MAXROLLCENTERTABLE-1)
	{
		index = MAXROLLCENTERTABLE-1;
	}

	if (wheel < 2)
	{
		// front suspension
		m_rollCenter[wheel][2] = m_rollCenterFrontTable[index];
		m_rcToWheelLength[wheel] = m_rcToWheelLengthTable[0][index];
		m_camber[wheel] = m_camberTable[0][index];
	}
	else
	{
		// rear suspension
		m_rollCenter[wheel][2] = m_rollCenterRearTable[index];
		m_rcToWheelLength[wheel] = m_rcToWheelLengthTable[1][index];
		m_camber[wheel] = m_camberTable[1][index];
	}
	if (CAR_WHEEL_RIGHT(wheel))
	{
		m_camber[wheel] = -m_camber[wheel];
	}
//			m_camber[wheel] = 0.1f;
	m_camber[wheel] += m_initialCamber[wheel];
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4229\SurfaceType.h ===
#ifndef __SURFACETYPE_H
#define __SURFACETYPE_H


enum SurfaceType
{
	SURFACETYPE_ROAD = 0, 
	SURFACETYPE_RUNOFF = 1, 
	SURFACETYPE_SAND = 2, 
	SURFACETYPE_GRASS = 3,
	SURFACETYPE_COUNT
};


// g_groundSlowTable located in PhysicsCar.cxx
extern const float g_groundSlowTable[SURFACETYPE_COUNT];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4229\vector.h ===
#ifndef __VECTOR_H
#define __VECTOR_H

#ifndef __FLOATTYPE_H
#include "floattype.h"
#endif


//-----------------------------------------------------------------
// this file is shared between mkdata and the game.  therefore,
// use the special "(floatType)" to cast constants (allowing 
// mkdata to use high-but-slow precision and the game to use
// low-but-fast precision with the same constants).  also,
// declare any members of classes or structures as "gameFloatType"
// if the classes will be used in the game itself (to insure
// consistent structure sizes), otherwise just use floatType.
//-----------------------------------------------------------------


//==================================================================
// Typedefs and class declarations
//==================================================================

#define X 0
#define Y 1
#define Z 2
#define W 3

// doesn't seem to be a good idea right now.  gets larger and runs
// slower.
//#define INLINE_VECTOR_SET

//------------------------------------------------------------------
// V2, V3, V4, M4, M3, M2
//------------------------------------------------------------------


typedef floatType V8[8];
typedef floatType V7[7];
typedef floatType V6[6];
typedef floatType V5[5];
typedef floatType V4[4];
typedef floatType V3[3];
typedef floatType V2[2];

typedef double DV8[8];
typedef double DV7[7];
typedef double DV6[6];
typedef double DV5[5];
typedef double DV4[4];
typedef double DV3[3];
typedef double DV2[2];

#define AV8 __declspec(align(16)) V8
#define AV7 __declspec(align(16)) V7
#define AV6 __declspec(align(16)) V6
#define AV5 __declspec(align(16)) V5
#define AV4 __declspec(align(16)) V4
#define AV3 __declspec(align(16)) V3
#define AV2 __declspec(align(16)) V2

typedef floatType M4[4][4];
typedef floatType M3[3][3];
typedef floatType M2[2][2];
typedef floatType M44[4][4];
typedef floatType M43[4][3];
typedef floatType M34[3][4];
typedef floatType M33[3][3];
typedef floatType M32[3][2];
typedef floatType M22[2][2];

#define AM4  __declspec(align(16)) M4
#define AM2  __declspec(align(16)) M3
#define AM3  __declspec(align(16)) M2
#define AM44 __declspec(align(16)) M44
#define AM34 __declspec(align(16)) M34
#define AM33 __declspec(align(16)) M33
#define AM32 __declspec(align(16)) M32
#define AM22 __declspec(align(16)) M22

typedef short VS8[8];
typedef short VS7[7];
typedef short VS6[6];
typedef short VS5[5];
typedef short VS4[4];
typedef short VS3[3];
typedef short VS2[2];

typedef short MS4[4][4];
typedef short MS3[3][3];
typedef short MS2[2][2];
typedef short MS44[4][4];
typedef short MS43[4][3];
typedef short MS33[3][3];
typedef short MS32[3][2];
typedef short MS22[2][2];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4229\types.h ===
#ifndef __TYPES_H

typedef   signed    char s8;
typedef unsigned    char u8;
typedef   signed   short s16;
typedef unsigned   short u16;
typedef   signed    long s32;
typedef unsigned    long u32;
typedef   signed __int64 s64;
typedef unsigned __int64 u64;

#define MAX_U8   0xFF               //                   255
#define MAX_S8   0x7F               //                   127
#define MIN_S8  -0x80               //                  -128
#define MAX_U16  0xFFFF             //                 65535
#define MAX_S16  0x7FFF             //                 32767
#define MIN_S16 -0x8000             //                -32768
#define MAX_U32  0xFFFFFFFF         //            4294967295
#define MAX_S32  0x7FFFFFFF         //            2147483647
#define MIN_S32 -0x80000000         //           -2147483648
#define MAX_U64  0xFFFFFFFFFFFFFFFF // 184467440737XXXXXXXX5 - not sure :)
#define MAX_S64  0x7FFFFFFFFFFFFFFF //  922337203685XXXXXXX7 - not sure :)
#define MIN_S64 -0x8000000000000000 // -922337203685XXXXXXX8 - not sure :)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4331\4331.cpp ===
#include <xtl.h>

template <class T> struct boom
{
    static const int x = 3;
    static const int y = x + 1;
};

void __cdecl main() { return; }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4229\Suspension.h ===
#ifndef __SUSPENSION_H
#define __SUSPENSION_H

#define MAXROLLCENTERTABLE 31
#define TIRECOUNT 4

struct Suspension
{
public:
	float m_springLength[TIRECOUNT];  // from COG to bottom of wheel
	float m_springConstA[TIRECOUNT];
	float m_springConstB[TIRECOUNT];
	float m_springDamper[TIRECOUNT];
	float m_rollCenter[TIRECOUNT][3];
	float m_rcToWheelLength[TIRECOUNT];  // dist from tire to roll center
	float m_camber[TIRECOUNT];          // from behind, counter-clockwise is a positive angle    
	float m_initialCamber[TIRECOUNT];       // angle in radians, from behind counterclockwise is positive
	float m_springBodyPoint[2][3];  // point where spring connects to body of car (local coords) front & rear

	float m_rollCenterFrontTable[MAXROLLCENTERTABLE];   // table holds all roll center heights based on wheel height
	float m_rollCenterRearTable[MAXROLLCENTERTABLE];
	float m_rcToWheelLengthTable[2][MAXROLLCENTERTABLE];
	float m_camberTable[2][MAXROLLCENTERTABLE];

	float m_maxSpringCompression;  // maximum compression of suspension springs

	void m_Init();
	void m_UpdateRollCenter(float wheelHeight,short wheel);
	void m_FillRollCenterTables();
private:

};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4332\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4229\test.cxx ===
#include <stdio.h>
#include "types.h"
#include "game.h"
#include "physicsCar.h"

#define printf myprintf

#if 0
float g_constraintX[3] = {1.0f, 0.0f, 0.0f};
float g_invWheelMass = 0.0227273f;
float g_invBodyMass = 0.000781250f;
	float rollCenter[4][3] = 
	{
		{0.968000f, 0.000000f, -0.249383f},
		{0.968000f, 0.000000f, -0.249383f},
		{-1.450000f, 0.000000f, -0.317419f},
		{-1.450000f, 0.000000f, -0.317419f},
	};
#endif





void main(void)
{
	PhysicsCar phyCar;
	phyCar.m_LoadCar("D:\\AudiTT.pcr");
	phyCar.m_ResetCar();
	while (1)
	{
		phyCar.m_UpdatePosition(1/60.0f);
		PrintCustomFault("Done with first loop:\n");
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4331\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4332\4332.cpp ===
#include <xtl.h>

#define BOOL bool

class VisibleTest
{
BOOL BoundingBoxVisible( 
D3DMATRIX *objectToClipMatrix, 
D3DVECTOR *boxCenter, 
D3DVECTOR *boxHalf, 
DWORD *visCodes 
);
};


BOOL VisibleTest::BoundingBoxVisible( 
D3DMATRIX *objectToClipMatrix, 
D3DVECTOR *boxCenter, 
D3DVECTOR *boxHalf, 
DWORD *visCodes 
) 
{ 
__declspec(align(16)) static const unsigned long xsign[4] = {0x80000000, 0x00000000, 0x80000000, 0x00000000}; 
__declspec(align(16)) static const unsigned long ysign[4] = {0x80000000, 0x80000000, 0x00000000, 0x00000000}; 
__declspec(align(16)) static const unsigned long notsign[4] = {0x7fffffff, 0x7fffffff, 0x7fffffff, 0x7fffffff}; 
__declspec(align(16)) static float box_xs[4], box_ys[4], box_zs_front[4], box_zs_back[4]; 
__declspec(align(16)) static float xs[4], ys[4]; 

int allCodes; 
int clipCodes; 

int res; 

__asm 
{ 
// push ebp 
// mov ebp, esp 
// sub esp, 8 // make room for the variables 

push ebx 
mov eax, dword ptr [visCodes] // ebp + 8 + 4*3 

push edi 
mov edx, [boxCenter] // ebp + 8 + 4*1 
mov ecx, [objectToClipMatrix] // ebp + 8 + 4*0 

push esi 
test eax, eax 
jnz COMPUTE_BOX_CORNERS 

// **************************************************************** 
// the caller doesn't care to find out if all points are visible, 
// hence a center point test may save us some time 
// **************************************************************** 
movups xmm4, xmmword ptr [edx] 

movups xmm0, xmmword ptr [ecx + 0] 
movlhps xmm5, xmm4 
movhlps xmm6, xmm4 

movups xmm1, xmmword ptr [ecx + 16] 
shufps xmm4, xmm4, 00000000b 
movups xmm2, xmmword ptr [ecx + 32] 
shufps xmm5, xmm5, 11111111b 
movups xmm3, xmmword ptr [ecx + 48] 
shufps xmm6, xmm6, 00000000b 
// 0: m03 | m02 | m01 | m00 
// 1: m13 | m12 | m11 | m10 
// 2: m23 | m22 | m21 | m20 
// 3: m33 | m32 | m31 | m30 
// 4: x | x | x | x 
// 5: y | y | y | y 
// 6: z | z | z | z 
mulps xmm0, xmm4 
mulps xmm1, xmm5 
mulps xmm2, xmm6 
// 0: m03*x | m02*x | m01*x | m00*x 
// 1: m13*y | m12*y | m11*y | m10*y 
// 2: m23*z | m22*z | m21*z | m20*z 
// 3: m33 | m32 | m31 | m30 
addps xmm0, xmm1 
addps xmm2, xmm3 
addps xmm0, xmm2 
// 0: W | Z | Y | X 
movaps xmm1, xmm0 
// 0: W | Z | Y | X 
// 1: W | Z | Y | X 
movhlps xmm2, xmm0 
movaps xmm3, xmmword ptr [notsign] 
shufps xmm2, xmm2, 01010101b 
// take absolute value of all Ws by zeroing out the sign bit 
andps xmm2, xmm3 
// 0: W | Z | Y | X 
// 1: W | Z | Y | X 
// 2: W | W | W | W 
addps xmm1, xmm2 
subps xmm2, xmm0 
// 1: W+W | Z+W | Y+W | X+W 
// 2: W-W | W-Z | W-Y | W-X 
movaps xmm0, xmm2 
// 0: W-W | W-Z | W-Y | W-X 
// 1: W+W | Z+W | Y+W | X+W 
// 2: W-W | W-Z | W-Y | W-X 
unpcklps xmm2, xmm1 
unpckhps xmm0, xmm1 
// 0: W+W | W-W | Z+W | W-Z 
// 2: Y+W | W-Y | X+W | W-X 
movmskps eax, xmm2 
movmskps ecx, xmm0 

shl ecx, 4 
and ecx, 0x30 
or eax, ecx 

jnz COMPUTE_BOX_CORNERS 

mov eax, 1 
jmp DONE 

COMPUTE_BOX_CORNERS: 
// **************************************************************** 
// either the projected points are required or the center point was not visible 
// we check all the points 
// **************************************************************** 

// **************************************************************** 
// Transform the box points 
// **************************************************************** 
// +Y 
// | 
// | 
// 6*------*7 
// /| /| 
// / | / | 
// 2*------*3 | 
// | 4*---|--*5 
// | / | /____+X 
// |/ |/ 
// 0*------*1 
// / 
// / 
// +Z 
// 
// 0: bcX-bhX, bcY-bhY, bcZ+bhZ 
// 1: bcX+bhX, bcY-bhY, bcZ+bhZ 
// 2: bcX-bhX, bcY+bhY, bcZ+bhZ 
// 3: bcX+bhX, bcY+bhY, bcZ+bhZ 
// 4: bcX-bhX, bcY-bhY, bcZ-bhZ 
// 5: bcX+bhX, bcY-bhY, bcZ-bhZ 
// 6: bcX-bhX, bcY+bhY, bcZ-bhZ 
// 7: bcX+bhX, bcY+bhY, bcZ-bhZ 
// 

// **************************************************************** 
// first we compute the bounding box corner points 
// so we can transform them 
// **************************************************************** 
mov dword ptr [allCodes], 0xffffffff // ebp - 8 
mov eax, dword ptr [boxCenter] // ebp + 8 + 4*1 
prefetchnta dword ptr [xsign] 

mov dword ptr [clipCodes], 0 // ebp - 4 
mov ecx, dword ptr [boxHalf] // ebp + 8 + 4*2 
prefetchnta dword ptr [ysign] 

movups xmm0, xmmword ptr [eax] 
// 0: bcW | bcZ | bcY | bcX 
movups xmm5, xmmword ptr [ecx] 
// 0: bcW | bcZ | bcY | bcX 
// 5: bhW | bhZ | bhY | bhX 
movlhps xmm1, xmm0 
movhlps xmm2, xmm0 
// 0: bcW | bcZ | bcY | bcX 
// 1: bcY | bcX | | 
// 2: | | bcW | bcZ 
// 5: bhW | bhZ | bhY | bhX 
shufps xmm0, xmm0, 00000000b 
movlhps xmm6, xmm5 
movhlps xmm7, xmm5 

shufps xmm1, xmm1, 11111111b 
movss xmm3, xmm2 
// 0: bcX | bcX | bcX | bcX 
// 1: bcY | bcY | bcY | bcY 
// 2: | | bcW | bcZ 
// 3: | | | bcZ 
// 5: bhW | bhZ | bhY | bhX 
// 6: bhY | bhX | | 
// 7: | | bhW | bhZ 
shufps xmm5, xmm5, 00000000b 
shufps xmm6, xmm6, 11111111b 
// 0: bcX | bcX | bcX | bcX 
// 1: bcY | bcY | bcY | bcY 
// 2: | | bcW | bcZ 
// 3: | | | bcZ 
// 5: bhX | bhX | bhX | bhX 
// 6: bhY | bhY | bhY | bhY 
// 7: | | bhW | bhZ 
addss xmm2, xmm7 
subss xmm3, xmm7 
// 0: bcX | bcX | bcX | bcX 
// 1: bcY | bcY | bcY | bcY 
// 2: | | bcW | bcZ+bhZ 
// 3: | | | bcZ-bhZ 
// 5: bhX | bhX | bhX | bhX 
// 6: bhY | bhY | bhY | bhY 
// 7: | | bhW | bhZ 
xorps xmm5, xmmword ptr [xsign] 
xorps xmm6, xmmword ptr [ysign] 
// 0: bcX | bcX | bcX | bcX 
// 1: bcY | bcY | bcY | bcY 
// 2: | | bcW | bcZ+bhZ 
// 5:-bhX | bhX |-bhX | bhX 
// 6:-bhY |-bhY | bhY | bhY 
// 7: | | bhW | bhZ 
shufps xmm2, xmm2, 00000000b 
shufps xmm3, xmm3, 00000000b 
shufps xmm7, xmm7, 00000000b 
// 0: bcX | bcX | bcX | bcX 
// 1: bcY | bcY | bcY | bcY 
// 2: bcZ+bhZ | bcZ+bhZ | bcZ+bhZ | bcZ+bhZ 
// 3: bcZ-bhZ | bcZ-bhZ | bcZ-bhZ | bcZ-bhZ 
// 5:-bhX | bhX |-bhX | bhX 
// 6:-bhY |-bhY | bhY | bhY 
// 7: bhZ | bhZ | bhZ | bhZ 
addps xmm0, xmm5 
addps xmm1, xmm6 
// 0: bcX-bhX | bcX+bhX | bcX-bhX | bcX+bhX 
// 1: bcY-bhY | bcY-bhY | bcY+bhY | bcY+bhY 
// 2: bcZ+bhZ | bcZ+bhZ | bcZ+bhZ | bcZ+bhZ 
// 3: bcZ-bhZ | bcZ-bhZ | bcZ-bhZ | bcZ-bhZ 

// **************************************************************** 
// store the box_xs, box_ys, and zs so we can use them again later 
// **************************************************************** 
movntps xmmword ptr [box_xs], xmm0 
movntps xmmword ptr [box_ys], xmm1 
movntps xmmword ptr [box_zs_front], xmm2 
movntps xmmword ptr [box_zs_back], xmm3 

// **************************************************************** 
// now we transform the first 4 box corner points (box's front face) 
// **************************************************************** 
mov edx, dword ptr [objectToClipMatrix] // ebp + 8 + 4*0 

movss xmm4, dword ptr [edx + 0 + 12] 
movss xmm5, dword ptr [edx + 16 + 12] 
movss xmm6, dword ptr [edx + 32 + 12] 
movss xmm7, dword ptr [edx + 48 + 12] 
shufps xmm4, xmm4, 00000000b 
shufps xmm5, xmm5, 00000000b 
shufps xmm6, xmm6, 00000000b 
shufps xmm7, xmm7, 00000000b 
// 0: bcX-bhX | bcX+bhX | bcX-bhX | bcX+bhX 
// 1: bcY-bhY | bcY-bhY | bcY+bhY | bcY+bhY 
// 2: bcZ+bhZ | bcZ+bhZ | bcZ+bhZ | bcZ+bhZ 
// 4: m03 | m03 | m03 | m03 
// 5: m13 | m13 | m13 | m13 
// 6: m23 | m23 | m23 | m23 
// 7: m33 | m33 | m33 | m33 
mulps xmm0, xmm4 
mulps xmm1, xmm5 
mulps xmm2, xmm6 
// 0: (bcX-bhX)*m03 | (bcX+bhX)*m03 | (bcX-bhX)*m03 | (bcX+bhX)*m03 
// 1: (bcY-bhY)*m13 | (bcY-bhY)*m13 | (bcY+bhY)*m13 | (bcY+bhY)*m13 
// 2: (bcZ+bhZ)*m23 | (bcZ+bhZ)*m23 | (bcZ+bhZ)*m23 | (bcZ+bhZ)*m23 
// 7: m33 | m33 | m33 | m33 
addps xmm0, xmm1 
addps xmm2, xmm7 
addps xmm0, xmm2 
// 0: w0 | w1 | w2 | w3 
movaps xmm4, xmmword ptr [notsign] 
movaps xmm1, xmmword ptr [box_xs] 
movaps xmm2, xmmword ptr [box_ys] 
movaps xmm3, xmmword ptr [box_zs_front] 
andps xmm0, xmm4 
// 0: w0 | w1 | w2 | w3 
// 1: bcX-bhX | bcX+bhX | bcX-bhX | bcX+bhX 
// 2: bcY-bhY | bcY-bhY | bcY+bhY | bcY+bhY 
// 3: bcZ+bhZ | bcZ+bhZ | bcZ+bhZ | bcZ+bhZ 
movss xmm4, dword ptr [edx + 0 + 0] 
movss xmm5, dword ptr [edx + 16 + 0] 
movss xmm6, dword ptr [edx + 32 + 0] 
movss xmm7, dword ptr [edx + 48 + 0] 
shufps xmm4, xmm4, 00000000b 
shufps xmm5, xmm5, 00000000b 
shufps xmm6, xmm6, 00000000b 
shufps xmm7, xmm7, 00000000b 
// 0: w0 | w1 | w2 | w3 
// 1: bcX-bhX | bcX+bhX | bcX-bhX | bcX+bhX 
// 2: bcY-bhY | bcY-bhY | bcY+bhY | bcY+bhY 
// 3: bcZ+bhZ | bcZ+bhZ | bcZ+bhZ | bcZ+bhZ 
// 4: m00 | m00 | m00 | m00 
// 5: m10 | m10 | m10 | m10 
// 6: m20 | m20 | m20 | m20 
// 7: m30 | m30 | m30 | m30 
mulps xmm1, xmm4 
mulps xmm2, xmm5 
mulps xmm3, xmm6 
// 0: w0 | w1 | w2 | w3 
// 1: (bcX-bhX)*m00 | (bcX+bhX)*m00 | (bcX-bhX)*m00 | (bcX+bhX)*m00 
// 2: (bcY-bhY)*m10 | (bcY-bhY)*m10 | (bcY+bhY)*m10 | (bcY+bhY)*m10 
// 3: (bcZ+bhZ)*m20 | (bcZ+bhZ)*m20 | (bcZ+bhZ)*m20 | (bcZ+bhZ)*m20 
// 7: m30 | m30 | m30 | m30 
addps xmm1, xmm2 
addps xmm3, xmm7 
addps xmm1, xmm3 
// 0: w0 | w1 | w2 | w3 
// 1: x0 | x1 | x2 | x3 
movaps xmm2, xmmword ptr [box_ys] 
movaps xmm3, xmmword ptr [box_zs_front] 
movntps xmmword ptr [xs], xmm1 
movaps xmm1, xmmword ptr [box_xs] 
// 0: w0 | w1 | w2 | w3 
// 1: bcX-bhX | bcX+bhX | bcX-bhX | bcX+bhX 
// 2: bcY-bhY | bcY-bhY | bcY+bhY | bcY+bhY 
// 3: bcZ+bhZ | bcZ+bhZ | bcZ+bhZ | bcZ+bhZ 
movss xmm4, dword ptr [edx + 0 + 4] 
movss xmm5, dword ptr [edx + 16 + 4] 
movss xmm6, dword ptr [edx + 32 + 4] 
movss xmm7, dword ptr [edx + 48 + 4] 
shufps xmm4, xmm4, 00000000b 
shufps xmm5, xmm5, 00000000b 
shufps xmm6, xmm6, 00000000b 
shufps xmm7, xmm7, 00000000b 
// 0: w0 | w1 | w2 | w3 
// 1: bcX-bhX | bcX+bhX | bcX-bhX | bcX+bhX 
// 2: bcY-bhY | bcY-bhY | bcY+bhY | bcY+bhY 
// 3: bcZ+bhZ | bcZ+bhZ | bcZ+bhZ | bcZ+bhZ 
// 4: m01 | m01 | m01 | m01 
// 5: m11 | m11 | m11 | m11 
// 6: m21 | m21 | m21 | m21 
// 7: m31 | m31 | m31 | m31 
mulps xmm1, xmm4 
mulps xmm2, xmm5 
mulps xmm3, xmm6 
// 0: w0 | w1 | w2 | w3 
// 1: (bcX-bhX)*m01 | (bcX+bhX)*m01 | (bcX-bhX)*m01 | (bcX+bhX)*m01 
// 2: (bcY-bhY)*m11 | (bcY-bhY)*m11 | (bcY+bhY)*m11 | (bcY+bhY)*m11 
// 3: (bcZ+bhZ)*m21 | (bcZ+bhZ)*m21 | (bcZ+bhZ)*m21 | (bcZ+bhZ)*m21 
// 7: m31 | m31 | m31 | m31 
addps xmm1, xmm2 
addps xmm3, xmm7 
addps xmm1, xmm3 
// 0: w0 | w1 | w2 | w3 
// 1: y0 | y1 | y2 | y3 
movaps xmm2, xmmword ptr [box_ys] 
movaps xmm3, xmmword ptr [box_zs_front] 
movntps xmmword ptr [ys], xmm1 
movaps xmm1, xmmword ptr [box_xs] 
// 0: w0 | w1 | w2 | w3 
// 1: bcX-bhX | bcX+bhX | bcX-bhX | bcX+bhX 
// 2: bcY-bhY | bcY-bhY | bcY+bhY | bcY+bhY 
// 3: bcZ+bhZ | bcZ+bhZ | bcZ+bhZ | bcZ+bhZ 
movss xmm4, dword ptr [edx + 0 + 8] 
movss xmm5, dword ptr [edx + 16 + 8] 
movss xmm6, dword ptr [edx + 32 + 8] 
movss xmm7, dword ptr [edx + 48 + 8] 
shufps xmm4, xmm4, 00000000b 
shufps xmm5, xmm5, 00000000b 
shufps xmm6, xmm6, 00000000b 
shufps xmm7, xmm7, 00000000b 
// 0: w0 | w1 | w2 | w3 
// 1: bcX-bhX | bcX+bhX | bcX-bhX | bcX+bhX 
// 2: bcY-bhY | bcY-bhY | bcY+bhY | bcY+bhY 
// 3: bcZ+bhZ | bcZ+bhZ | bcZ+bhZ | bcZ+bhZ 
// 4: m02 | m02 | m02 | m02 
// 5: m12 | m12 | m12 | m12 
// 6: m22 | m22 | m22 | m22 
// 7: m32 | m32 | m32 | m32 
mulps xmm1, xmm4 
mulps xmm2, xmm5 
mulps xmm3, xmm6 
// 0: w0 | w1 | w2 | w3 
// 1: (bcX-bhX)*m02 | (bcX+bhX)*m02 | (bcX-bhX)*m02 | (bcX+bhX)*m02 
// 2: (bcY-bhY)*m12 | (bcY-bhY)*m12 | (bcY+bhY)*m12 | (bcY+bhY)*m12 
// 3: (bcZ+bhZ)*m22 | (bcZ+bhZ)*m22 | (bcZ+bhZ)*m22 | (bcZ+bhZ)*m22 
// 7: m32 | m32 | m32 | m32 
addps xmm1, xmm2 
addps xmm3, xmm7 
addps xmm1, xmm3 
// 0: w0 | w1 | w2 | w3 
// 1: z0 | z1 | z2 | z3 

// **************************************************************** 
// we've compute the 4 xyzw's, so now compute their clip codes 
// we compute the z clip codes first 
// **************************************************************** 
movaps xmm2, xmm0 
// 0: w0 | w1 | w2 | w3 
// 1: z0 | z1 | z2 | z3 
// 2: w0 | w1 | w2 | w3 
subps xmm2, xmm1 
addps xmm1, xmm0 
// 0: w0 | w1 | w2 | w3 
// 1: z0+w0 | z1+w1 | z2+w2 | z3+w3 
// 2: w0-z0 | w1-z1 | w2-z2 | w3-z3 
movaps xmm3, xmm2 
// 0: w0 | w1 | w2 | w3 
// 1: z0+w0 | z1+w1 | z2+w2 | z3+w3 
// 2: w0-z0 | w1-z1 | w2-z2 | w3-z3 
// 3: w0-z0 | w1-z1 | w2-z2 | w3-z3 
unpcklps xmm2, xmm1 
unpckhps xmm3, xmm1 
// 0: w0 | w1 | w2 | w3 
// 1: z0+w0 | z1+w1 | z2+w2 | z3+w3 
// 2: z2+w2 | w2-z2 | z3+w3 | w3-z3 
// 3: z0+w0 | w0-z0 | z1+w1 | w1-z1 
movmskps ecx, xmm2 // z2 | z3 clip codes 
movmskps eax, xmm3 // z0 | z1 clip codes 

// **************************************************************** 
// now that we have the z clip codes, compute the xy clip codes as well 
// **************************************************************** 
movaps xmm1, xmmword ptr [xs] 
movaps xmm2, xmmword ptr [ys] 
// 0: w0 | w1 | w2 | w3 
// 1: x0 | x1 | x2 | x3 
// 2: y0 | y1 | y2 | y3 
movaps xmm3, xmm0 
mov edx, ecx 
movaps xmm4, xmm0 
mov ebx, eax 
// 0: w0 | w1 | w2 | w3 
// 1: x0 | x1 | x2 | x3 
// 2: y0 | y1 | y2 | y3 
// 3: w0 | w1 | w2 | w3 
// 4: w0 | w1 | w2 | w3 
subps xmm3, xmm1 
shl eax, 2 
subps xmm4, xmm2 
shl ebx, 4 
addps xmm1, xmm0 
shl ecx, 2 
addps xmm2, xmm0 
shl edx, 4 
// 1: x0+w0 | x1+w1 | x2+w2 | x3+w3 
// 2: y0+w0 | y1+w1 | y2+w2 | y3+w3 
// 3: w0-x0 | w1-x1 | w2-x2 | w3-x3 
// 4: w0-y0 | w1-y1 | w2-y2 | w3-y3 
movaps xmm5, xmm1 
and eax, 0x30 // z0 clip codes 
movaps xmm6, xmm3 
and ebx, 0x30 // z1 clip codes 
// 1: x0+w0 | x1+w1 | x2+w2 | x3+w3 
// 2: y0+w0 | y1+w1 | y2+w2 | y3+w3 
// 3: w0-x0 | w1-x1 | w2-x2 | w3-x3 
// 4: w0-y0 | w1-y1 | w2-y2 | w3-y3 
// 5: x0+w0 | x1+w1 | x2+w2 | x3+w3 
// 6: w0-x0 | w1-x1 | w2-x2 | w3-x3 
unpcklps xmm5, xmm2 
and ecx, 0x30 // z2 clip codes 
unpcklps xmm6, xmm4 
and edx, 0x30 // z3 clip codes 
// 1: x0+w0 | x1+w1 | x2+w2 | x3+w3 
// 2: y0+w0 | y1+w1 | y2+w2 | y3+w3 
// 3: w0-x0 | w1-x1 | w2-x2 | w3-x3 
// 4: w0-y0 | w1-y1 | w2-y2 | w3-y3 
// 5: y2+w2 | x2+w2 | y3+w3 | x3+w3 
// 6: w2-y2 | w2-x2 | w3-y3 | w3-x3 
movaps xmm0, xmm6 
// 0: w2-y2 | w2-x2 | w3-y3 | w3-x3 
// 1: x0+w0 | x1+w1 | x2+w2 | x3+w3 
// 2: y0+w0 | y1+w1 | y2+w2 | y3+w3 
// 3: w0-x0 | w1-x1 | w2-x2 | w3-x3 
// 4: w0-y0 | w1-y1 | w2-y2 | w3-y3 
// 5: y2+w2 | x2+w2 | y3+w3 | x3+w3 
// 6: w2-y2 | w2-x2 | w3-y3 | w3-x3 
unpcklps xmm6, xmm5 
unpckhps xmm0, xmm5 
// 0: y2+w2 | w2-y2 | x2+w2 | w2-x2 
// 1: x0+w0 | x1+w1 | x2+w2 | x3+w3 
// 2: y0+w0 | y1+w1 | y2+w2 | y3+w3 
// 3: w0-x0 | w1-x1 | w2-x2 | w3-x3 
// 4: w0-y0 | w1-y1 | w2-y2 | w3-y3 
// 5: y2+w2 | x2+w2 | y3+w3 | x3+w3 
// 6: y3+w3 | w3-y3 | x3+w3 | w3-x3 
movmskps edi, xmm6 // xy3 clip codes 
movmskps esi, xmm0 // xy2 clip codes 

or edx, edi // xyz3 clip codes 
or ecx, esi // xyz2 clip codes 

// **************************************************************** 
// if any clip code was zero, and we don't need to compute all clip codes 
// we can just return now, knowing at least one corner of the box is visible 
// **************************************************************** 
mov edi, dword ptr [visCodes] // ebp + 8 + 4*3 
test edi, edi 
jnz CLIPCODES_2MORE 

test ecx, ecx 
jnz CHECK_XYZ3_CLIPCODE 

mov eax, 1 
jmp DONE 

CHECK_XYZ3_CLIPCODE: 
test edx, edx 
jnz CLIPCODES_2MORE 

mov eax, 1 
jmp DONE 

CLIPCODES_2MORE: 
// 1: x0+w0 | x1+w1 | x2+w2 | x3+w3 
// 2: y0+w0 | y1+w1 | y2+w2 | y3+w3 
// 3: w0-x0 | w1-x1 | w2-x2 | w3-x3 
// 4: w0-y0 | w1-y1 | w2-y2 | w3-y3 
unpckhps xmm3, xmm4 
unpckhps xmm1, xmm2 
// 1: y0+w0 | x0+w0 | y1+w1 | x1+w1 
// 2: y0+w0 | y1+w1 | y2+w2 | y3+w3 
// 3: w0-y0 | w0-x0 | w1-y1 | w1-x1 
// 4: w0-y0 | w1-y1 | w2-y2 | w3-y3 
movaps xmm0, xmm3 
// 0: w0-y0 | w0-x0 | w1-y1 | w1-x1 
// 1: y0+w0 | x0+w0 | y1+w1 | x1+w1 
// 2: y0+w0 | y1+w1 | y2+w2 | y3+w3 
// 3: w0-y0 | w0-x0 | w1-y1 | w1-x1 
// 4: w0-y0 | w1-y1 | w2-y2 | w3-y3 
unpcklps xmm3, xmm1 
unpckhps xmm0, xmm1 
// 0: y0+w0 | w0-y0 | x0+w0 | w0-x0 
// 1: y0+w0 | x0+w0 | y1+w1 | x1+w1 
// 2: y0+w0 | y1+w1 | y2+w2 | y3+w3 
// 3: y1+w1 | w1-y1 | x1+w1 | w1-x1 
// 4: w0-y0 | w1-y1 | w2-y2 | w3-y3 
movmskps edi, xmm3 // xy1 clip codes 
movmskps esi, xmm0 // xy0 clip codes 

or ebx, edi // xyz1 clip codes 
or eax, esi // xyz0 clip codes 

mov edi, dword ptr [visCodes] // ebp + 8 + 4*3 
test edi, edi 
jnz UPDATE_CLIPCODES 

test eax, eax 
jnz CHECK_XYZ1_CLIPCODE 

mov eax, 1 
jmp DONE 

CHECK_XYZ1_CLIPCODE: 
test ebx, ebx 
jnz UPDATE_CLIPCODES 

mov eax, 1 
jmp DONE 

UPDATE_CLIPCODES: 
// **************************************************************** 
// combine all the clip codes 
// **************************************************************** 
mov edi, dword ptr [allCodes] // ebp - 8 
mov esi, dword ptr [clipCodes] // ebp - 4 

and edi, eax 
or esi, eax 
and edi, ebx 
or esi, ebx 
and edi, ecx 
or esi, ecx 
and edi, edx 
or esi, edx 

mov dword ptr [allCodes], edi // ebp - 8 
mov dword ptr [clipCodes], esi // ebp - 4 

// **************************************************************** 
// now we transform the last 4 box corner points (box's back face) 
// **************************************************************** 
mov edx, dword ptr [objectToClipMatrix] // ebp + 8 + 4*0 

movaps xmm0, xmmword ptr [box_xs] 
movaps xmm1, xmmword ptr [box_ys] 
movaps xmm2, xmmword ptr [box_zs_back] 
// 0: bcX-bhX | bcX+bhX | bcX-bhX | bcX+bhX 
// 1: bcY-bhY | bcY-bhY | bcY+bhY | bcY+bhY 
// 2: bcZ-bhZ | bcZ-bhZ | bcZ-bhZ | bcZ-bhZ 
movss xmm4, dword ptr [edx + 0 + 12] 
movss xmm5, dword ptr [edx + 16 + 12] 
movss xmm6, dword ptr [edx + 32 + 12] 
movss xmm7, dword ptr [edx + 48 + 12] 
shufps xmm4, xmm4, 00000000b 
shufps xmm5, xmm5, 00000000b 
shufps xmm6, xmm6, 00000000b 
shufps xmm7, xmm7, 00000000b 
// 0: bcX-bhX | bcX+bhX | bcX-bhX | bcX+bhX 
// 1: bcY-bhY | bcY-bhY | bcY+bhY | bcY+bhY 
// 2: bcZ-bhZ | bcZ-bhZ | bcZ-bhZ | bcZ-bhZ 
// 4: m03 | m03 | m03 | m03 
// 5: m13 | m13 | m13 | m13 
// 6: m23 | m23 | m23 | m23 
// 7: m33 | m33 | m33 | m33 
mulps xmm0, xmm4 
mulps xmm1, xmm5 
mulps xmm2, xmm6 
// 0: (bcX-bhX)*m03 | (bcX+bhX)*m03 | (bcX-bhX)*m03 | (bcX+bhX)*m03 
// 1: (bcY-bhY)*m13 | (bcY-bhY)*m13 | (bcY+bhY)*m13 | (bcY+bhY)*m13 
// 2: (bcZ-bhZ)*m23 | (bcZ-bhZ)*m23 | (bcZ-bhZ)*m23 | (bcZ-bhZ)*m23 
// 7: m33 | m33 | m33 | m33 
addps xmm0, xmm1 
addps xmm2, xmm7 
addps xmm0, xmm2 
// 0: w0 | w1 | w2 | w3 
// take absolute value of all Ws by zeroing out the sign bit 
movaps xmm4, xmmword ptr [notsign] 
movaps xmm1, xmmword ptr [box_xs] 
movaps xmm2, xmmword ptr [box_ys] 
movaps xmm3, xmmword ptr [box_zs_back] 
andps xmm0, xmm4 
// 0: w0 | w1 | w2 | w3 
// 1: bcX-bhX | bcX+bhX | bcX-bhX | bcX+bhX 
// 2: bcY-bhY | bcY-bhY | bcY+bhY | bcY+bhY 
// 3: bcZ-bhZ | bcZ-bhZ | bcZ-bhZ | bcZ-bhZ 
movss xmm4, dword ptr [edx + 0 + 0] 
movss xmm5, dword ptr [edx + 16 + 0] 
movss xmm6, dword ptr [edx + 32 + 0] 
movss xmm7, dword ptr [edx + 48 + 0] 
shufps xmm4, xmm4, 00000000b 
shufps xmm5, xmm5, 00000000b 
shufps xmm6, xmm6, 00000000b 
shufps xmm7, xmm7, 00000000b 
// 0: w0 | w1 | w2 | w3 
// 1: bcX-bhX | bcX+bhX | bcX-bhX | bcX+bhX 
// 2: bcY-bhY | bcY-bhY | bcY+bhY | bcY+bhY 
// 3: bcZ-bhZ | bcZ-bhZ | bcZ-bhZ | bcZ-bhZ 
// 4: m00 | m00 | m00 | m00 
// 5: m10 | m10 | m10 | m10 
// 6: m20 | m20 | m20 | m20 
// 7: m30 | m30 | m30 | m30 
mulps xmm1, xmm4 
mulps xmm2, xmm5 
mulps xmm3, xmm6 
// 0: w0 | w1 | w2 | w3 
// 1: (bcX-bhX)*m00 | (bcX+bhX)*m00 | (bcX-bhX)*m00 | (bcX+bhX)*m00 
// 2: (bcY-bhY)*m10 | (bcY-bhY)*m10 | (bcY+bhY)*m10 | (bcY+bhY)*m10 
// 3: (bcZ-bhZ)*m20 | (bcZ-bhZ)*m20 | (bcZ-bhZ)*m20 | (bcZ-bhZ)*m20 
// 7: m30 | m30 | m30 | m30 
addps xmm1, xmm2 
addps xmm3, xmm7 
addps xmm1, xmm3 
// 0: w0 | w1 | w2 | w3 
// 1: x0 | x1 | x2 | x3 
movaps xmm2, xmmword ptr [box_ys] 
movaps xmm3, xmmword ptr [box_zs_back] 
movntps xmmword ptr [xs], xmm1 
movaps xmm1, xmmword ptr [box_xs] 
// 0: w0 | w1 | w2 | w3 
// 1: bcX-bhX | bcX+bhX | bcX-bhX | bcX+bhX 
// 2: bcY-bhY | bcY-bhY | bcY+bhY | bcY+bhY 
// 3: bcZ-bhZ | bcZ-bhZ | bcZ-bhZ | bcZ-bhZ 
movss xmm4, dword ptr [edx + 0 + 4] 
movss xmm5, dword ptr [edx + 16 + 4] 
movss xmm6, dword ptr [edx + 32 + 4] 
movss xmm7, dword ptr [edx + 48 + 4] 
shufps xmm4, xmm4, 00000000b 
shufps xmm5, xmm5, 00000000b 
shufps xmm6, xmm6, 00000000b 
shufps xmm7, xmm7, 00000000b 
// 0: w0 | w1 | w2 | w3 
// 1: bcX-bhX | bcX+bhX | bcX-bhX | bcX+bhX 
// 2: bcY-bhY | bcY-bhY | bcY+bhY | bcY+bhY 
// 3: bcZ-bhZ | bcZ-bhZ | bcZ-bhZ | bcZ-bhZ 
// 4: m01 | m01 | m01 | m01 
// 5: m11 | m11 | m11 | m11 
// 6: m21 | m21 | m21 | m21 
// 7: m31 | m31 | m31 | m31 
mulps xmm1, xmm4 
mulps xmm2, xmm5 
mulps xmm3, xmm6 
// 0: w0 | w1 | w2 | w3 
// 1: (bcX-bhX)*m01 | (bcX+bhX)*m01 | (bcX-bhX)*m01 | (bcX+bhX)*m01 
// 2: (bcY-bhY)*m11 | (bcY-bhY)*m11 | (bcY+bhY)*m11 | (bcY+bhY)*m11 
// 3: (bcZ-bhZ)*m21 | (bcZ-bhZ)*m21 | (bcZ-bhZ)*m21 | (bcZ-bhZ)*m21 
// 7: m31 | m31 | m31 | m31 
addps xmm1, xmm2 
addps xmm3, xmm7 
addps xmm1, xmm3 
// 0: w0 | w1 | w2 | w3 
// 1: y0 | y1 | y2 | y3 
movaps xmm2, xmmword ptr [box_ys] 
movaps xmm3, xmmword ptr [box_zs_back] 
movntps xmmword ptr [ys], xmm1 
movaps xmm1, xmmword ptr [box_xs] 
// 0: w0 | w1 | w2 | w3 
// 1: bcX-bhX | bcX+bhX | bcX-bhX | bcX+bhX 
// 2: bcY-bhY | bcY-bhY | bcY+bhY | bcY+bhY 
// 3: bcZ-bhZ | bcZ-bhZ | bcZ-bhZ | bcZ-bhZ 
movss xmm4, dword ptr [edx + 0 + 8] 
movss xmm5, dword ptr [edx + 16 + 8] 
movss xmm6, dword ptr [edx + 32 + 8] 
movss xmm7, dword ptr [edx + 48 + 8] 
shufps xmm4, xmm4, 00000000b 
shufps xmm5, xmm5, 00000000b 
shufps xmm6, xmm6, 00000000b 
shufps xmm7, xmm7, 00000000b 
// 0: w0 | w1 | w2 | w3 
// 1: bcX-bhX | bcX+bhX | bcX-bhX | bcX+bhX 
// 2: bcY-bhY | bcY-bhY | bcY+bhY | bcY+bhY 
// 3: bcZ-bhZ | bcZ-bhZ | bcZ-bhZ | bcZ-bhZ 
// 4: m02 | m02 | m02 | m02 
// 5: m12 | m12 | m12 | m12 
// 6: m22 | m22 | m22 | m22 
// 7: m32 | m32 | m32 | m32 
mulps xmm1, xmm4 
mulps xmm2, xmm5 
mulps xmm3, xmm6 
// 0: w0 | w1 | w2 | w3 
// 1: (bcX-bhX)*m02 | (bcX+bhX)*m02 | (bcX-bhX)*m02 | (bcX+bhX)*m02 
// 2: (bcY-bhY)*m12 | (bcY-bhY)*m12 | (bcY+bhY)*m12 | (bcY+bhY)*m12 
// 3: (bcZ+bhZ)*m22 | (bcZ+bhZ)*m22 | (bcZ+bhZ)*m22 | (bcZ+bhZ)*m22 
// 7: m32 | m32 | m32 | m32 
addps xmm1, xmm2 
addps xmm3, xmm7 
addps xmm1, xmm3 
// 0: w0 | w1 | w2 | w3 
// 1: z0 | z1 | z2 | z3 

// **************************************************************** 
// we've compute the 4 xyzw's, so now compute their clip codes 
// we compute the z clip codes first 
// **************************************************************** 
movaps xmm2, xmm0 
// 0: w0 | w1 | w2 | w3 
// 1: z0 | z1 | z2 | z3 
// 2: w0 | w1 | w2 | w3 
subps xmm2, xmm1 
addps xmm1, xmm0 
// 0: w0 | w1 | w2 | w3 
// 1: z0+w0 | z1+w1 | z2+w2 | z3+w3 
// 2: w0-z0 | w1-z1 | w2-z2 | w3-z3 
movaps xmm3, xmm2 
// 0: w0 | w1 | w2 | w3 
// 1: z0+w0 | z1+w1 | z2+w2 | z3+w3 
// 2: w0-z0 | w1-z1 | w2-z2 | w3-z3 
// 3: w0-z0 | w1-z1 | w2-z2 | w3-z3 
unpcklps xmm2, xmm1 
unpckhps xmm3, xmm1 
// 0: w0 | w1 | w2 | w3 
// 1: z0+w0 | z1+w1 | z2+w2 | z3+w3 
// 2: z2+w2 | w2-z2 | z3+w3 | w3-z3 
// 3: z0+w0 | w0-z0 | z1+w1 | w1-z1 
movmskps ecx, xmm2 // z2 | z3 clip codes 
movmskps eax, xmm3 // z0 | z1 clip codes 

// **************************************************************** 
// now that we have the z clip codes, compute the xy clip codes as well 
// **************************************************************** 
movaps xmm1, xmmword ptr [xs] 
movaps xmm2, xmmword ptr [ys] 
// 0: w0 | w1 | w2 | w3 
// 1: x0 | x1 | x2 | x3 
// 2: y0 | y1 | y2 | y3 
movaps xmm3, xmm0 
mov edx, ecx 
movaps xmm4, xmm0 
mov ebx, eax 
// 0: w0 | w1 | w2 | w3 
// 1: x0 | x1 | x2 | x3 
// 2: y0 | y1 | y2 | y3 
// 3: w0 | w1 | w2 | w3 
// 4: w0 | w1 | w2 | w3 
subps xmm3, xmm1 
shl eax, 2 
subps xmm4, xmm2 
shl ebx, 4 
addps xmm1, xmm0 
shl ecx, 2 
addps xmm2, xmm0 
shl edx, 4 
// 1: x0+w0 | x1+w1 | x2+w2 | x3+w3 
// 2: y0+w0 | y1+w1 | y2+w2 | y3+w3 
// 3: w0-x0 | w1-x1 | w2-x2 | w3-x3 
// 4: w0-y0 | w1-y1 | w2-y2 | w3-y3 
movaps xmm5, xmm1 
and eax, 0x30 // z0 clip codes 
movaps xmm6, xmm3 
and ebx, 0x30 // z1 clip codes 
// 1: x0+w0 | x1+w1 | x2+w2 | x3+w3 
// 2: y0+w0 | y1+w1 | y2+w2 | y3+w3 
// 3: w0-x0 | w1-x1 | w2-x2 | w3-x3 
// 4: w0-y0 | w1-y1 | w2-y2 | w3-y3 
// 5: x0+w0 | x1+w1 | x2+w2 | x3+w3 
// 6: w0-x0 | w1-x1 | w2-x2 | w3-x3 
unpcklps xmm5, xmm2 
and ecx, 0x30 // z2 clip codes 
unpcklps xmm6, xmm4 
and edx, 0x30 // z3 clip codes 
// 1: x0+w0 | x1+w1 | x2+w2 | x3+w3 
// 2: y0+w0 | y1+w1 | y2+w2 | y3+w3 
// 3: w0-x0 | w1-x1 | w2-x2 | w3-x3 
// 4: w0-y0 | w1-y1 | w2-y2 | w3-y3 
// 5: y2+w2 | x2+w2 | y3+w3 | x3+w3 
// 6: w2-y2 | w2-x2 | w3-y3 | w3-x3 
movaps xmm0, xmm6 
// 0: w2-y2 | w2-x2 | w3-y3 | w3-x3 
// 1: x0+w0 | x1+w1 | x2+w2 | x3+w3 
// 2: y0+w0 | y1+w1 | y2+w2 | y3+w3 
// 3: w0-x0 | w1-x1 | w2-x2 | w3-x3 
// 4: w0-y0 | w1-y1 | w2-y2 | w3-y3 
// 5: y2+w2 | x2+w2 | y3+w3 | x3+w3 
// 6: w2-y2 | w2-x2 | w3-y3 | w3-x3 
unpcklps xmm6, xmm5 
unpckhps xmm0, xmm5 
// 0: y2+w2 | w2-y2 | x2+w2 | w2-x2 
// 1: x0+w0 | x1+w1 | x2+w2 | x3+w3 
// 2: y0+w0 | y1+w1 | y2+w2 | y3+w3 
// 3: w0-x0 | w1-x1 | w2-x2 | w3-x3 
// 4: w0-y0 | w1-y1 | w2-y2 | w3-y3 
// 5: y2+w2 | x2+w2 | y3+w3 | x3+w3 
// 6: y3+w3 | w3-y3 | x3+w3 | w3-x3 
movmskps edi, xmm6 // xy3 clip codes 
movmskps esi, xmm0 // xy2 clip codes 

or edx, edi // xyz3 clip codes 
or ecx, esi // xyz2 clip codes 

// **************************************************************** 
// if any clip code was zero, and we don't need to compute all clip codes 
// we can just return now, knowing at least one corner of the box is visible 
// **************************************************************** 
mov edi, dword ptr [visCodes] // ebp + 8 + 4*3 
test edi, edi 
jnz CLIPCODES_2MORE_2ND 

test ecx, ecx 
jnz CHECK_XYZ2_CLIPCODE 

mov eax, 1 
jmp DONE 

CHECK_XYZ2_CLIPCODE: 
test edx, edx 
jnz CLIPCODES_2MORE_2ND 

mov eax, 1 
jmp DONE 

CLIPCODES_2MORE_2ND: 
// 1: x0+w0 | x1+w1 | x2+w2 | x3+w3 
// 2: y0+w0 | y1+w1 | y2+w2 | y3+w3 
// 3: w0-x0 | w1-x1 | w2-x2 | w3-x3 
// 4: w0-y0 | w1-y1 | w2-y2 | w3-y3 
unpckhps xmm3, xmm4 
unpckhps xmm1, xmm2 
// 1: y0+w0 | x0+w0 | y1+w1 | x1+w1 
// 2: y0+w0 | y1+w1 | y2+w2 | y3+w3 
// 3: w0-y0 | w0-x0 | w1-y1 | w1-x1 
// 4: w0-y0 | w1-y1 | w2-y2 | w3-y3 
movaps xmm0, xmm3 
// 0: w0-y0 | w0-x0 | w1-y1 | w1-x1 
// 1: y0+w0 | x0+w0 | y1+w1 | x1+w1 
// 2: y0+w0 | y1+w1 | y2+w2 | y3+w3 
// 3: w0-y0 | w0-x0 | w1-y1 | w1-x1 
// 4: w0-y0 | w1-y1 | w2-y2 | w3-y3 
unpcklps xmm3, xmm1 
unpckhps xmm0, xmm1 
// 0: y0+w0 | w0-y0 | x0+w0 | w0-x0 
// 1: y0+w0 | x0+w0 | y1+w1 | x1+w1 
// 2: y0+w0 | y1+w1 | y2+w2 | y3+w3 
// 3: y1+w1 | w1-y1 | x1+w1 | w1-x1 
// 4: w0-y0 | w1-y1 | w2-y2 | w3-y3 
movmskps edi, xmm3 // xy1 clip codes 
movmskps esi, xmm0 // xy0 clip codes 

or ebx, edi // xyz1 clip codes 
or eax, esi // xyz0 clip codes 

mov edi, dword ptr [visCodes] // ebp + 8 + 4*3 
test edi, edi 
jnz UPDATE_CLIPCODES_2ND 

test eax, eax 
jnz CHECK_XYZ0_CLIPCODE 

mov eax, 1 
jmp DONE 

CHECK_XYZ0_CLIPCODE: 
test ebx, ebx 
jnz UPDATE_CLIPCODES_2ND 

mov eax, 1 
jmp DONE 

UPDATE_CLIPCODES_2ND: 
// **************************************************************** 
// combine all the clip codes 
// **************************************************************** 
mov edi, dword ptr [allCodes] // ebp - 8 
mov esi, dword ptr [clipCodes] // ebp - 4 

and edi, eax 
or esi, eax 
and edi, ebx 
or esi, ebx 
and edi, ecx 
or esi, ecx 
and edi, edx 
or esi, edx 

mov dword ptr [allCodes], edi // ebp - 8 
mov dword ptr [clipCodes], esi // ebp - 4 

mov eax, dword ptr [visCodes] // ebp + 8 + 4*3 
test eax, eax 
jz TEST_ALLCODES 

mov dword ptr [eax], esi // *visCodes = clipCodes; 

TEST_ALLCODES: 

mov eax, 1 // return TRUE 

test edi, edi 
jz DONE 

xor eax, eax // return FALSE 

DONE: 
pop esi 
pop edi 
pop ebx 

// mov esp, ebp 
// pop ebp 

// ret 

mov dword ptr [res], eax // store the result 
} 

return res; 
} 

void __cdecl main() { return; }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4564\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4542\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4333\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4773\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4794\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4809\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4542\4542.cpp ===
#include <xtl.h>
#include <stdlib.h>

extern "C" int ___mb_cur_max_func();
extern "C" int ___lc_handle_func();
extern "C" int ___lc_collate_cp_func();
extern "C" int ___lc_codepage_func();

void __cdecl main()
{
	___mb_cur_max_func();
	___lc_handle_func();
	___lc_collate_cp_func();
	___lc_codepage_func();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4773\4773.cpp ===
#include <xtl.h>

extern "C" unsigned int DbgPrint(const char *, ...);


struct struct_x
{
    enum enum_x
    {
        struct_normal_enum_zero = 0,
        struct_normal_enum_one = 1,
        struct_normal_enum_two = 2,
        struct_normal_enum_three = 3
    };

    struct
	{
		enum enum_y
		{
			struct_anon_enum_zero = 0,
			struct_anon_enum_one = 1,
			struct_anon_enum_two = 2,
			struct_anon_enum_three = 3
		};
		// data member prevents C2625 error
		int foo;
	};
};


void __cdecl main()
{
	// demonstrate the enum-within-anonymous-struct bug
    DbgPrint("x: %d %d %d %d\n",
        struct_x::struct_normal_enum_zero,
        struct_x::struct_normal_enum_one,
        struct_x::struct_normal_enum_two,
        struct_x::struct_normal_enum_three
    );

    DbgPrint("anon: %d %d %d %d\n",
        struct_x::struct_anon_enum_zero,
        struct_x::struct_anon_enum_one,
        struct_x::struct_anon_enum_two,
        struct_x::struct_anon_enum_three
    );

    DbgPrint("both lines above should contain 0 1 2 3\n");

	while (1)
		Sleep(500);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4564\4564.cpp ===
#include <xtl.h>

class foo
{
    int _identifier;
    // int _id;
};

void __cdecl main() { return; }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4333\4333.cpp ===
#include <xtl.h>

typedef unsigned int Value_Type;

struct Test
{
	static Test __fastcall Get_Value();
	Value_Type m_value;
};

void __fastcall Show_The_Bug()
{
	// begin bug-> (build Release for repro)

	Test a = Test::Get_Value();
	// lea ecx,[esp]
	// call 00400000

	Test b = Test::Get_Value();
	// lea ecx,[esp]            // both values are written into the same address
	// call 00400000

	// mov eax,dword ptr [esp]    // compares the value to itself
	// cmp eax,dword ptr [esp]
	// jne 0040003A
    
	// <- end bug

	if(a.m_value == b.m_value)
	{
		OutputDebugStringA("Bug\n");    // this happens in the release build
	}
	else
	{
		OutputDebugStringA("No bug\n");
	}
}

Value_Type some_value = 0;

__declspec( naked ) Test __fastcall Test::Get_Value()
{
    __asm
    {
        mov        eax, some_value
        inc        [some_value]
        mov        [ecx], eax
        mov        eax, ecx
        ret
    }
}

void __cdecl main()
{
    Show_The_Bug();

    while(true)
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4818\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4809\4809.cpp ===
#include <xtl.h>
#include <map>


template<class T> void foo(std::map<int, T> &) {}
template<class T> void foo(std::map<double, T> &) {}


void __cdecl main()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4794\4794.cpp ===
#include <xtl.h>
#include <string>

void __cdecl main()
{
    std::string kk = "hajkhgyueuujdgytrn";

    while (true)
        ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4970\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4918\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4818\4818.cpp ===
#include <xtl.h>

struct Die
{
    Die() {}
};

namespace doom
{
    void death();
}

void doom::death()
{
    Die msvc[2];
}

void __cdecl main()
{
    while (1)
        Sleep(500);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\6751\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\7345\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\7775\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\8521\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\9385\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\7345\7345.cpp ===
#include <xtl.h>

static struct
{
    struct
    {
        IDirect3DTexture8 TestTex;
        IDirect3DTexture8 *pTex;
    } TexList[100];
} glb;

void xbGfxCloseTexture(long texture)
{
    IDirect3DTexture8 *pTexture = glb.TexList[texture].pTex;
    static long foo_bar = pTexture ? pTexture->UnlockRect(0) : 0;
}

void __cdecl main()
{
    xbGfxCloseTexture(0);
    xbGfxCloseTexture(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\8521\8521.cpp ===
#pragma optimize("", on)

#ifndef _XBOX
#include <windows.h>
#else
#include <xtl.h>
#endif

#define ktest3(x) (char)((x<0) ? 0 : ((x>0) ? 0:x))

void ktest1(float a, char r, char g, char b)
{
    volatile float t=a+r+g+b;
}

void ktest2()
{
    volatile float t=0;
    ktest1(0,ktest3(t),ktest3(t),0);
}

#ifndef _XBOX
void main()
#else
void __cdecl main()
#endif
{
    ktest2();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4970\4970.cpp ===
#include <xtl.h>
#include <stdio.h>

float DivideBy27(float x)
{
    return(x/27.0f);
}

void __cdecl main()
{
	char szTemp[1024];

	float foo = 1.0f;
	for (int i = 0; i < 4; i++)
		foo = DivideBy27(foo);

    sprintf(szTemp, "%.12e\n", foo);
	OutputDebugString(szTemp);

	// debug produces       1.881676325866e-006
	// release /O2 produces 1.881676423159e-006
	// release /O1 produces 1.881676479237e-006

	while (1)
		;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\7775\7775.cpp ===
//-----------------------------------------------------------------------------
// Xbox bug# 7775
// VC7 loop unroll optimization bug
//-----------------------------------------------------------------------------
#ifdef _XBOX
#include <xtl.h>
#else
#include <d3d8.h>
#include <d3dx8.h>
#endif

//-----------------------------------------------------------------------------
// Name: Tree
// Desc: Simple structure to hold data for rendering a tree
//-----------------------------------------------------------------------------
struct Tree
{
    D3DXVECTOR4 vScale;
    D3DXVECTOR4 vPosition;
    D3DXVECTOR4 vColor;
};


//-----------------------------------------------------------------------------
// Defines, constants, and global variables
//-----------------------------------------------------------------------------
#define NUM_TREES 2300


// Simple function to define "hilliness" for terrain
inline FLOAT HeightField( FLOAT x, FLOAT y )
{
    return 3*(cosf(x/20+0.2f)*cosf(y/15-0.2f)+1.0f);
}

inline FLOAT GaussianRand( FLOAT min, FLOAT max, FLOAT width )
{
    FLOAT x = (FLOAT)(rand()-rand())/RAND_MAX;
    return (max-min)*expf( -width*x*x) + min;
}


//-----------------------------------------------------------------------------
// Name: class CXboxBug
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXboxBug
{
    Tree*              m_Trees;              // Array of tree info
    Tree**             m_pTreeArray;         // Array of tree info
public:
    HRESULT Render();

    CXboxBug();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXboxBug xbApp;
    xbApp.Render();
#ifdef _XBOX
    XLaunchNewImage(0, 0);
#endif
}




//-----------------------------------------------------------------------------
// Name: CXboxBug()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXboxBug::CXboxBug()
{
    // Initialize the tree data
    m_Trees      = new Tree[NUM_TREES];
    m_pTreeArray = new Tree*[NUM_TREES];

    DWORD side = (DWORD)sqrtf( NUM_TREES );

    for( DWORD i=0; i<NUM_TREES; i++ )
    {
        // Position the trees
        FLOAT x = 60.0f * ( (FLOAT)(i%side) - (FLOAT)(side/2) ) / (FLOAT)(side/2);
        FLOAT z = 60.0f * ( (FLOAT)(i/side) - (FLOAT)(side/2) ) / (FLOAT)(side/2);

        x += 60.0f * 0.1f * ((FLOAT)(rand()-rand())/RAND_MAX) / (FLOAT)(side/2);
        z += 60.0f * 0.1f * ((FLOAT)(rand()-rand())/RAND_MAX) / (FLOAT)(side/2);
        
        FLOAT y = HeightField( x, z );

        // Size the trees randomly
        FLOAT fWidth  = GaussianRand( 5.0f, 2.0f, 2.0f );
        FLOAT fHeight = GaussianRand( 7.0f, 4.0f, 2.0f );

        // Each tree is a random color between red and green
        FLOAT r = (1.0f-0.75f) + (0.75f*rand())/RAND_MAX;
        FLOAT g = (1.0f-0.75f) + (0.75f*rand())/RAND_MAX;
        FLOAT b = 0.0f;

        m_Trees[i].vPosition      = D3DXVECTOR4( x, y, z, 1.0f );
        m_Trees[i].vColor         = D3DXVECTOR4( r, g, b, 1.0f );
        m_Trees[i].vScale         = D3DXVECTOR4( fWidth, fHeight, 1.0f, 1.0f );

        m_pTreeArray[i] = &m_Trees[i];
    }

	// bug 7775 repro code
	{
		Tree*		pMaxXTree = m_Trees;
		Tree*		pTree     = m_Trees;

		for (int n=0; n<NUM_TREES; n++, pTree++)
		{
			if ((pTree->vPosition.x > pMaxXTree->vPosition.x))
			{
				pMaxXTree = pTree;
			}
		}

		pMaxXTree->vScale.y *= 10;
	}
	// end repro code
}


//-----------------------------------------------------------------------------
// Name: App_Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXboxBug::Render()
{
#ifdef UNICODE
	OutputDebugStringW(L"CXboxBug::Render");
#else
	OutputDebugString("CXboxBug::Render");
#endif
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\9385\9385.cpp ===
/*
********************************************************** 
*** VC7 with manual precompiled headers (/Yc & /Yu) and *** 
*** global optimizations (/Og) can initialize a chain   *** 
*** of dependent global constants in the wrong order.   *** 
*********************************************************** 
*/

//-------------------- main.cpp -------------------- 
// 
//  VC7 & "cinit" bug 
// 
//      VC7 with manual precompiled headers (/Yc & /Yu) 
//      and global optimizations (/Og) can initialize 
//      a chain of dependent global constants in the 
//      wrong order.  Counter-intuitively, if you USE 
//      the constants in the order of their definition, 
//      they are "cinit'd" backwards, but only with /Og. 
//
//  If building this using the auto-generated DSP, make sure
//  to change C/C++ optimization settings to use global optimizations
//  (if building the Debug configuration)

#include "stdafx.h" 
#define  VC7BUG 

float showbug() 
{ 
#ifdef   VC7BUG 
    float one = Pie1;   // Pie1 = 3.14  (cinit'd second) 
    float two = Pie2;   // Pie2 = 0     (cinit'd first ) BUG 
#else 
    float two = Pie2;   // Pie2 = 6.28  (cinit'd second) 
    float one = Pie1;   // Pie1 = 3.14  (cinit'd first ) A-OK 
#endif 
    return one + two; 
}

#ifdef _XBOX
#include <xtl.h>
extern "C" int DbgPrint(const char *, ...);
#endif

#include <stdio.h>

void __cdecl main()
{
	char temp[20];
	sprintf(temp, "%e", showbug());

    DbgPrint("Expected result is 9.420000e+000\n");
    DbgPrint("Actual result is %s\n", temp);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\4918\4918.cpp ===
#ifndef _XBOX
#include <stdio.h>
#define PRINTF printf
#else
#include <xtl.h>
extern "C" void __cdecl DbgPrint(const char *, ...);
#define PRINTF DbgPrint
#endif

#define BUGGY_RESULTS

class StringPtr
{
public:
   StringPtr() : Data(NULL)   {};
   StringPtr(char *data) : Data(data)   {};

   char *Data;
};

template<typename KEY, typename VALUE>
class Resource
{
public:

   Resource() {};
   ~Resource(){ };
   bool  Find(KEY key, VALUE *value);
};

template<typename KEY, typename VALUE>
bool Resource<KEY, VALUE>::Find(KEY key, VALUE *value)
{
   PRINTF("Address %p\n", key.Data);
   return false;
}

Resource<StringPtr, int> Function;

char *Names[] = {{"Name1"}, {"Name2"}, {"Name3"}, {NULL}};

void __cdecl main()
{
   char **AnimNames = Names;
   int thing;

#ifdef BUGGY_RESULTS
   /* demonstrate that key.Data is wrong inside the Find function */
   while( *AnimNames )
   {
      PRINTF("%s, Address pointer: %p\n", *AnimNames, *AnimNames);
      Function.Find(*AnimNames++, &thing );
   }
#else
  /* produces correct output */
   while( *AnimNames )
   {
      PRINTF("%s, Address pointer: %p\n", *AnimNames, *AnimNames);
      Function.Find(*AnimNames, &thing );
      AnimNames++;
   }
#endif

#ifdef _XBOX
   while (1)
	   ;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\9387\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\9385\stdafx.cpp ===
/*
*********************************************************** 
*** VC7 with manual precompiled headers (/Yc & /Yu) and *** 
*** global optimizations (/Og) can initialize a chain   *** 
*** of dependent global constants in the wrong order.   *** 
*********************************************************** 
*/

//-------------------- stdafx.cpp -------------------- 
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\xbounce\main.cpp ===
#include <xtl.h>
#include "bounce.h"

void __cdecl main()
{
    CBounce bounce;

	while (1)
	{
		bounce.DrawStuff();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\9385\stdafx.h ===
/*
*********************************************************** 
*** VC7 with manual precompiled headers (/Yc & /Yu) and *** 
*** global optimizations (/Og) can initialize a chain   *** 
*** of dependent global constants in the wrong order.   *** 
*********************************************************** 
*/

//-------------------- stdafx.h -------------------- 
const float Pie  = 3.14f; 
const float Pie1 = Pie*1;   // "Pie1" depends on "Pie" 
const float Pie2 = Pie1*2;  // "Pie2" depends on "Pie1"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\dumpfst\CFile.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CFile.cpp
// Contents:  Specialized file class for xbPremaster.
// Revisions: 2-Jun-2001: Created (jeffsim)
// Notes:     * This is a very specialized file class for the xbPremaster app.  It is not
//              recommended that this class be used for other applications.
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CFile::CFile
// Purpose:   Constructor for the CFile class.  Opens the specified file in preparation for READING
//            This will only be called on disk sources.
// Arguments: szFilename        -- name of the file to open
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CFile::CFile(char *szFilename)
{
    // Validate parameters
    if (szFilename == NULL)
    {
        SetInited(E_INVALIDARG);
        return;
    }

    // Track the name of our file.
    strcpy(m_szFilename, szFilename);
    
    // Track the last action performed
    m_taskLast = TASK_OPEN;

    // Open the file for READ-ONLY access.  The file must exist or we fail.
    m_hFile = CreateFile(szFilename, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
    if (m_hFile == INVALID_HANDLE_VALUE)
    {
        // NOTE: Non-OLE compatible error code.  Acceptable here ONLY because I catch it elsewhere
        // (see note at top of this file).  Difficult to use OLE for errors here since it doesn't
        // have a lot of errors we need to catch (ie file not found).
        SetInited(GetLastError());
        return;
    }

    SetInited(S_OK);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CFile::~CFile
// Purpose:   CFile destructor.  Close the handle to our file and cleanup after ourselves.
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CFile::~CFile()
{
    Close();
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CFile::SeekTo
// Purpose:   Seeks to the specified position in the file (from the beginning of the file)
//            This is only called on disk sources.
// Arguments: liDist        -- Number of bytes to seek forward
// Return:    Error code, or S_OK if successful.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CFile::SeekTo(LARGE_INTEGER liDist)
{
    if (!IsInited())
        return E_FAIL;
    
    // Track the last action performed
    m_taskLast = TASK_SEEK;

    if (SetFilePointer(m_hFile, liDist.LowPart, &liDist.HighPart, FILE_BEGIN) == 0xFFFFFFFF)
    {
        // Since 0xffffffff could be a valid low value, we need to check getlasterror as well
        DWORD dw = GetLastError();
        if (dw != NO_ERROR)
            return dw;

        // Otherwise, it was a valid value
    }

    return S_OK;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CFile::Read
// Purpose:   Reads the specified number of bytes from our file.
// Arguments: pby           -- Buffer containing bytes to read
//            cBytes        -- Number of bytes to read
//            pnRead        -- Will contain the actual number of bytes read.  Can be 'NULL'.
// Return:    Error code, or S_OK if successful
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CFile::Read(BYTE *pby, UINT cBytes, int *pnRead)
{
    DWORD dwRead;

    if (!IsInited())
        return GetInitCode();

    // Track the last action performed
    m_taskLast = TASK_READ;

    if (!ReadFile(m_hFile, pby, cBytes, &dwRead, 0))
    {
        // Failed to read the whole buffer.
        if (pnRead)
            *pnRead = dwRead;
        return (GetLastError());
    }
    if (pnRead)
        *pnRead = dwRead;

    return S_OK;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CFile::GetSize
// Purpose:   Gets the size of our file
//            Only called on disk sources
// Arguments: puliSize       -- Variable to contain the size of our file
// Return:    Error code, or S_OK if successful
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CFile::GetSize(ULARGE_INTEGER *puliSize)
{
    // Track the last action performed
    m_taskLast = TASK_GETSIZE;

    // Get the size of the file
    puliSize->LowPart = GetFileSize(m_hFile, &puliSize->HighPart);
    if (puliSize->LowPart != INVALID_FILE_SIZE)
        return S_OK;
    else
        return GetLastError();
}
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CFile::Close
// Purpose:   Closes our file
// Arguments: None
// Return:    Error code, or S_OK if successful
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CFile::Close()
{
    // Track the last action performed
    m_taskLast = TASK_CLOSE;

    // Close the handle to our file (if it was successfully opened in the first place).
    if (m_hFile)
    {
        CloseHandle(m_hFile);
        m_hFile = NULL;
    }

    return S_OK;
}

HRESULT CFile::ReadBYTE(BYTE *pbyData, int *pnRead)
{
    return Read(pbyData, 1, pnRead);
}

HRESULT CFile::ReadWORD(WORD *pwData, int *pnRead)
{
    return Read((BYTE*)pwData, 2, pnRead);
}

HRESULT CFile::ReadDWORD(DWORD *pdwData, int *pnRead)
{
    return Read((BYTE*)pdwData, 4, pnRead);
}

HRESULT CFile::ReadString(char *sz, int *pnRead)
{
    DWORD dwStrlen;
    int   nRead;
    HRESULT hr = ReadDWORD(&dwStrlen, &nRead);
    if (FAILED(hr))
        return hr;
    
    hr = Read((BYTE*)sz, dwStrlen, &nRead);
    if (FAILED(hr))
        return hr;
    if (nRead != (int)dwStrlen)
        return E_FAIL;
    
    sz[dwStrlen] = '\0';
    if (pnRead)
        *pnRead = nRead + 4;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\dumpfst\CFST.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CFST.cpp
// Contents:  FST file wrapper.  The FST file format is defined by the AMC tools.
// Revisions: 7-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"

// Taken from AMC's file "MediaBase.h"
struct TFileHeader
{
    char m_szFileType[32]; // FST? Error Map?
    char m_szMediaType[32]; // DVD, CD, etc
};

struct TMediaHeader
{
    DWORD uNumSectorsLayer0;
    DWORD uNumSectorsLayer1;
    BYTE m_ImpUseArea[120];       // total = 128 bytes
};

#define NUM_XDATA_SECTORS 1715632

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CFST::CFST
// Purpose:   Opens the specified FST file and reads the header information from it.
// Arguments: szFilename    -- Name of the fst file to open.
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CFST::CFST(char *szFilename) : CFile(szFilename)
{
    WORD  wByteOrder;
    DWORD dwTimestamp;
    int   cSectors;
    
    // Check to see if the file was successfully opened
    if (!IsInited())
        return;

    // Read the various necessary values out of the FST file's header block

    // The Byte order of the FST file can be big or little endian.  We only support one method
    // here.  If the FST file format changes, then we need to handle that here.
    if (Read((BYTE*)&wByteOrder, 2) != S_OK)
        return;

    assert (wByteOrder != 0xCDAB);

    if (wByteOrder != 0xABCD)
    {
        // This is a new format FST file (AMC changed their format)

        // Read in the AMC Header information
        TFileHeader tfh;
        TMediaHeader tmh;

        if (Read(((BYTE*)&tfh) + 2, sizeof(tfh) - 2) != S_OK)
            return;
        
        if (Read((BYTE*)&tmh, sizeof(tmh)) != S_OK)
            return;

        // Read the byte order
        if (Read((BYTE*)&wByteOrder, 2) != S_OK)
            return;

        assert (wByteOrder == 0xABCD);
    }

    // The timestamp is ignored here
    if (Read((BYTE*)&dwTimestamp, 4) != S_OK)
        return;

    // The number of sectors is also ignored (we know it to be a fixed size)
    if (Read((BYTE*)&cSectors, 4) != S_OK)
        return;

    if (cSectors != 1715632*2)
    {
        // This is a new format FST file (AMC changed their format to remove
        // the sector count).  In that case, we just read the number of entries
        m_cEntries = cSectors;

        // Force the number of sectors to a known value.  This will eventually
        // change when different sectors counts are possible
        cSectors = 1715632*2;
    }
    else
    {
        // Old format FST file
        // Read the number of files referenced in this FST file.
        if (Read((BYTE*)&m_cEntries, 4) != S_OK)
            return;
    }

    // Read the full size of the string table.  The string table contains all of the filenames.
    if (Read((BYTE*)&m_cbyStringTableSize, 4) != S_OK)
        return;
    
    // Allocate space for our string and entry tables
    m_ptes = new sTableEntry[m_cEntries];
    m_pchStringTable = new char[m_cbyStringTableSize];

    // Read in the entire entry and string tables
    if (Read((BYTE*)m_ptes, m_cEntries * sizeof(sTableEntry)) != S_OK)
        return;
    if (Read((BYTE*)m_pchStringTable, m_cbyStringTableSize) != S_OK)
        return;

    // Determine the first entry on layer 1
    for (int i = 0; i < m_cEntries; i++)
    {
        if (m_ptes[i].m_dwStart >= NUM_XDATA_SECTORS)
        {
            m_iFirstLayer1Entry = i;
            break;
        }
    }
    if (i == m_cEntries)
    {
        // No entries on layer 1!
        m_iFirstLayer1Entry = m_cEntries;
    }

    SetInited(S_OK);
    return;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CFST::~CFST
// Purpose:   CFST destructor.  Clean up after ourselves.
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CFST::~CFST()
{
    // Delete our string and entry tables
    if (m_pchStringTable)
        delete[] m_pchStringTable;

    if (m_ptes)
        delete[] m_ptes; 
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CFST::GetEntry
// Purpose:   
// Arguments: nLayer        -- Layer of the entry (0 or 1)
//            iEntry        -- Index of the entry to read (0 == first)
//            szName        -- Will be filled with the full path\filename of the entry
//            pnStartPSN    -- Will be filled with the start PSN of the entry
//            pnEndPSN      -- Will be filled with the end PSN of the entry
//            pdwOffset     -- Will be filled with the offset into the source file.
// Return:    'true' if successfully obtained.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CFST::GetEntry(int nLayer, int iEntry, char szName[MAX_PATH],
                    int *pnStartPSN, int *pnEndPSN, DWORD *pdwOffset,
                    BOOL fPackage, char szPackageDVDRoot[MAX_PATH])
{
    // If this is layer 1 and there are no entries in layer 1, return the requested entry doesn't
    // exist
    if (nLayer == 1 && m_iFirstLayer1Entry == (DWORD)m_cEntries)
        return false;

    // Offset entries in layer 1 to point at the first entry in the table
    if (nLayer == 1)
        iEntry += m_iFirstLayer1Entry;

    // If requested entry > than # of entries in the FST file, then return that the entry doesn't
    // exist
    if ((nLayer == 0 && iEntry >= (int)m_iFirstLayer1Entry) ||
        (nLayer == 1 && iEntry >= m_cEntries))
        return false;

    // Get a pointer to the requested entry in our entry table
    sTableEntry *pst = &m_ptes[iEntry];

    // Fill in the caller-requested information
    if (fPackage)
    {
        // Need to replace the root in the FST file with the temporary root
        // that we extracted all of the files to.
        char *szRelDir = &m_pchStringTable[pst->m_iDir] +
                         strlen(szPackageDVDRoot) - 1;

        // We know this FST exists in <temproot>\_amc\main.fst, so use that.
        strcpy(szName, m_szFilename);

        // Replace "\_amc\main.fst" with the relative directory & filename
        sprintf(szName + strlen(szName) - 13, "%s%s%s",szRelDir,
                (*szRelDir == '\0') ? "" :  "\\",
                &m_pchStringTable[pst->m_iName]);
    }
    else
    {
        sprintf(szName, "%c:%s/%s", m_szFilename[0], &m_pchStringTable[pst->m_iDir],
                &m_pchStringTable[pst->m_iName]);
    }
    *pnStartPSN = pst->m_dwStart;
    *pnEndPSN   = pst->m_dwStop;
    *pdwOffset  = pst->m_dwOffset;

    // Offset the layer one PSNs to be base-zero.
    if (nLayer == 1)
    {
        *pnStartPSN -= NUM_XDATA_SECTORS;
        *pnEndPSN -= NUM_XDATA_SECTORS;
    }

    // Return that the returned values are valid.
    return true;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CFST::Dump
// Purpose:   Dumps contents of FST object to stdout
// Arguments: None
// Return:    None
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CFST::Dump()
{
    int iLayer = 0;
    printf ("Layer 0:\n");
    printf ("File Name                                   LSN Start     LSN End  File Offset\n");
    printf ("------------------------------------------------------------------------------\n");
    for (int iEntry = 0; iEntry < m_cEntries; iEntry++)
    {
        sTableEntry *pst = &m_ptes[iEntry];
        char szName[MAX_PATH];

        sprintf(szName, "%s/%s", &m_pchStringTable[pst->m_iDir],
                &m_pchStringTable[pst->m_iName]);
       
        printf("%-40s   0x%08x  0x%08x  (0x%08x)\n", szName, pst->m_dwStart, pst->m_dwStop, pst->m_dwOffset);
        if (iLayer == 0 && pst->m_dwStart >= 1715632)
        {
            printf("\nLayer 1:\n");
            printf ("File Name                                   LSN Start     LSN End  File Offset\n");
            printf ("------------------------------------------------------------------------------\n");
            iLayer = 1;
        }
    }

    if (iLayer == 0)
    {
        printf("\nLayer 1:\n\n");
        printf ("File Name                                   LSN Start     LSN End  File Offset\n");
        printf ("------------------------------------------------------------------------------\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\vc7\9387\9387.cpp ===
/*

The following code prints [10.000000,10.000000,25.000000] instead of
[10.000000,25.000000,50.000000] when global optimizations and frame-pointer
omission are turned on (/Og and /Oy).  I don't have that much detailed
knowledge of calling conventions, so this might be by design.  However,
it seems wrong to me because:

1) 5, 25, and 55 are loaded up before the function call and those values
   are correctly changed to 10, 25, 50 after the function call leading me
   to believe that the function itself is OK.
2) The MSDN docs say "Frame pointer optimization (the /Oy compiler option)
   is not recommended, but it is automatically suppressed for a naked function."


It looks like the variables in the D3VECTOR struct are referenced out of
alignment after the function call returns.  

*/

#include <stdio.h>
#include <xtl.h> // needed for OutputDebugString -- probably would be windows.h for non-Xbox code

typedef struct {
    float x;
    float y;
    float z;
} D3VECTOR;

_declspec(naked) void __fastcall clampVectorSSEUnaligned(D3VECTOR *value, float *min, float *max)
// EAX  : Address of max..
// ECX	: Address of value (D3VECTOR - unaligned)...
// EDX  : Address of min...
// XMM0 : Contents of value (post loading - N/A, Z, Y, X)...
// XMM1 : Contents of min...
// XMM2 : Contents of max...
// XMM3 : NOT USED
// XMM4 : NOT USED
// XMM5 : NOT USED
// XMM6 : NOT USED
// XMM7 : NOT USED
{
	_asm
	{
		MOVSS	XMM0, DWORD PTR [ECX]			// Store parameter 'value (x)' in XMM0 (N/A, N/A, N/A, X)..
		SHUFPS	XMM0, XMM0, 39H					// Rotate the register (X, N/A, N/A, N/A)...
		MOVSS	XMM1, DWORD PTR [ECX + 4]		// Store parameter 'value (y)' in XMM0 (X, N/A, N/A, Y)...
		MOVSS	XMM0, XMM1
		SHUFPS	XMM0, XMM0, 39H					// Rotate the register (Y, X, N/A, N/A)...
		MOVSS	XMM1, DWORD PTR [ECX + 8]		// Store parameter 'value (z)' in XMM0 (Y, X, N/A, Z)...
		MOVSS	XMM0, XMM1
		SHUFPS	XMM0, XMM0, 4EH					// Shuffle the register (N/A, Z, Y, X)...

		MOVSS	XMM1, DWORD PTR [EDX]			// Store parameter 'min' in XMM0 (N/A, N/A, N/A, min)..
		SHUFPS	XMM1, XMM1, 00H					// Broadcast the value to the register (min, min, min, min)...
		MOVSS	XMM2, DWORD PTR [EAX]			// Store parameter 'max' in XMM0 (N/A, N/A, N/A, max)....
		SHUFPS	XMM2, XMM2, 00H					// Broadcast the value to the register (max, max, max, max)...

		MAXPS	XMM0, XMM1
		// Clamp min values...
		MINPS	XMM0, XMM2
		// Clamp max values...

		MOVSS	DWORD PTR [ECX], XMM0			// Save the results X -> [ECX]...
		SHUFPS	XMM0, XMM0, 39H					// Rotate the register (X, N/A, Z, Y)...
		MOVSS	DWORD PTR [ECX + 4], XMM0		// Save the results Y -> [ECX + 4]...
		SHUFPS	XMM0, XMM0, 39H					// Rotate the register (Y, X, N/A, Z)...
		MOVSS	DWORD PTR [ECX + 8], XMM0		// Save the results Z -> [ECX + 8]...
	}

	// Return (C 'return;' is not allowed)...
	_asm	RET
}

#pragma optimize ( "g", on )

#pragma optimize ( "y", off )

void ShowExpectedResults()
{
	D3VECTOR v;
	v.x = 5.0f;
	v.y = 25.0f;
	v.z = 55.0f;

	float fMin = 10.0f;
	float fMax = 50.0f;
	clampVectorSSEUnaligned(&v, &fMin, &fMax);

	char buf[100] = "";
	sprintf(buf, "Expected output is [%hf,%hf,%hf]\n", v.x, v.y, v.z);
	OutputDebugStringA(buf);
}

#pragma optimize ( "y", on )

void ShowBuggyResults()
{
	D3VECTOR v;
	v.x = 5.0f;
	v.y = 25.0f;
	v.z = 55.0f;

	float fMin = 10.0f;
	float fMax = 50.0f;
	clampVectorSSEUnaligned(&v, &fMin, &fMax);

	char buf[100] = "";
	sprintf(buf, "Actual output is [%hf,%hf,%hf]\n", v.x, v.y, v.z);
	OutputDebugStringA(buf);
}

#pragma optimize ( "", on )

void __cdecl main()
{
	ShowExpectedResults();
	ShowBuggyResults();
	while (1)
		Sleep(500);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\dumpfst\stdafx.h ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      stdafx.h
// Contents:  
// Revisions: 2-Jan-2002: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


#include <windows.h>
#include <stdio.h>
#include <Assert.h>

#include "CInitedObject.h"
#include "CFile.h"
#include "CFST.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\dumpfst\CFile.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CFile.h
// Contents:  Handles File input/output.
// Revisions: 31-May-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ CLASSES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Forward Class declarations
class CStep_Progress;

typedef enum eTask {TASK_OPEN, TASK_WRITE, TASK_READ, TASK_SEEK, TASK_GETSIZE, TASK_CLOSE};


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class:   CFile
// Purpose: Handles File input/output.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class CFile : public CInitedObject
{
public:

    // ++++ CONSTRUCTION-RELATED FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    // CFile            -- This constructor is only called for read files
    CFile(char *szFilename);
    
    // ~CFile           -- CFile destructor
    virtual ~CFile();

    // ++++ INPUT/OUTPUT-RELATED FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    
    // Read             -- Reads a set of bytes from the file
    HRESULT Read(BYTE *pby, UINT cBytes, int *pnRead = NULL);

    HRESULT ReadBYTE(BYTE *pbyData, int *pnRead = NULL);
    HRESULT ReadWORD(WORD *pwData, int *pnRead = NULL);
    HRESULT ReadDWORD(DWORD *pdwData, int *pnRead = NULL);
    HRESULT ReadString(char *sz, int *pnRead = NULL);

    // ++++ MEMBER-ACCESS FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    // GetSize          -- Returns the size of the file
    HRESULT GetSize(ULARGE_INTEGER *puliSize);

    // GetFilename      -- Returns the name of the file
    char *GetFilename() {return m_szFilename; }


    // ++++ MISCELLANEOUS FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    // Close            -- Closes the file
    HRESULT Close();

    // SeekTo           -- Sets the file's current file pointer to the specified location.
    HRESULT SeekTo(LARGE_INTEGER liDist);
    
private:

    // m_hFile          -- Handle to the Win32 file object that we encapsulate
    HANDLE m_hFile;

    // m_pstep          -- The step that this file was created in.
    CStep_Progress *m_pstep;

    // m_taskLast      -- The last task performed on this file
    eTask m_taskLast;

protected:

    // m_szFilename     -- name of this file.
    char m_szFilename[MAX_PATH];
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\dumpfst\CInitedObject.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     CInitedObject.h
// Contents: Contains the declaration of the CInitedObject object class.
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ CLASSES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class:   CInitedObject
// Purpose: Tracks initialization state of an object.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class CInitedObject
{
public:

    // ++++ CONSTRUCTION-RELATED FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    // CInitedObject        -- Standard constructor
    CInitedObject()
    {
        m_hrInit = E_FAIL;
    }


    // ++++ ACCESSOR FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    // GetInitCode          -- Returns the result of initialization
    HRESULT GetInitCode()
    {
            if (this == NULL)
                return E_FAIL;
            return m_hrInit;
            // Something unexpected happened - most likely we were passed an invalid 'this' pointer
            return E_FAIL;
    }

    // IsInited             -- Returns 'true' if the object was successfully initialized
    bool IsInited()
    {
        return GetInitCode() == S_OK;
    }


protected:

    // ++++ ACCESSOR FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    // SetInited            -- Allows a derived class to clear or set the initialized state to track
    //                         the derived class' initialization success.
    void SetInited(HRESULT hrInit)
    {
        m_hrInit = hrInit;
    }

private:

    // m_hrInit             -- Tracks the result of object initialization.
    HRESULT m_hrInit;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\dumpfst\dumpfst.cpp ===
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      xbdumpfst.cpp
// Contents:  
// Revisions: 2-Jan-2002: Created (jeffsim)
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- stdafxiled header file
#include "stdafx.h"

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

BOOL HandleCommandLine(int argc, void *argv[])
{
    if (argc != 2)
    {
        printf("Dump contents of Xbox FST file.  Specified file must be in "\
               "current directory.\n\nXBDUMPFST <filename>.\n\n");
        return FALSE;
    }
    return TRUE;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  main
// Purpose:   This is the default entry point into a console application.  
//            When the application is started, Windows calls into this
//            function - when this function exits, the application ends.
// Arguments: argc          -- The number of arguments on the command line
//            argv          -- The list of arguments on the command line
// Return:    Result value application returns to the operating system
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
int __cdecl main(int argc, void *argv[])
{
    if (!HandleCommandLine(argc, argv))
        return -1;

    // Open the file for parsing
    CFST fst((char*)argv[1]);
    fst.Dump();
    
    // Return success
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\CColorBar.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CColorbar.cpp
// Contents:  Contains the class definition for the CColorbar object.
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ColorBarWndProc
// Purpose:   Subclassed window procedure for the color bar static controls.
// Arguments: hwnd              -- The handle to the window that the message is
//                                 intended for.
//            uMsg              -- The message being reported.
//            wparam            -- Parameter 1 (message-specific)
//            lparam            -- Parameter 2 (message-specific)
// Return:    Result of the message processing - depends on the message sent.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LONG FAR PASCAL ColorBarWndProc(HWND hwnd, UINT uMsg, WORD wparam, LONG lparam)
{
    PAINTSTRUCT ps;

    // Determine which CColorbar this message is actually intended for.
    CColorBar *pcb = (CColorBar*)GetWindowLong(hwnd, GWL_USERDATA);

    switch(uMsg)
    {
    case WM_PAINT:
        BeginPaint(hwnd, &ps);
        pcb->Repaint(ps.hdc);
        EndPaint(hwnd, &ps);
        return 0;
    }

    // If we didn't handle the message above, then pass the message on to the
    // original wndproc for this control.
    return CallWindowProc(pcb->m_pfnStaticWndProc, hwnd, uMsg, wparam, lparam);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CColorBar::SetVisible
// Purpose:   Sets the visible state of the control to visible or hidden.
// Arguments: fVisible          -- True if the control should be shown.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CColorBar::SetVisible(bool fVisible)
{
    ShowWindow(m_hwnd, fVisible ? SW_SHOW : SW_HIDE);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CColorBar::CColorBar
// Purpose:   
// Arguments: 
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CColorBar::Init(CWindow *pwindow, COLORREF rgbTopColor, COLORREF rgbBotColor)
{
    // Create the hwnd
    m_hwnd = CreateWindow("static", "", WS_CHILD | WS_VISIBLE, 0, 0, 0, 0,
                          pwindow->m_hwnd, NULL, pwindow->m_hinst, NULL);
    if (!m_hwnd)
        return false;

    // Subclass the colorbar so that we can override erasebackground messages
    m_pfnStaticWndProc = (WNDPROC)SetWindowLong(m_hwnd, GWL_WNDPROC, (long)ColorBarWndProc);

    // Point our hwnd at 'this' object
    SetWindowLong(m_hwnd, GWL_USERDATA, (long)this);

    m_hwndTip = CreateWindowEx(NULL, TOOLTIPS_CLASS, NULL,
                            WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP,
                            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                            CW_USEDEFAULT, m_hwnd, NULL, pwindow->m_hinst, NULL);

    
    SetWindowPos(m_hwndTip, HWND_TOPMOST,0, 0, 0, 0,
             SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

    SetColors(rgbTopColor, rgbBotColor);

    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CColorBar::~CColorBar
// Purpose:   CColorBar destructor
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CColorBar::~CColorBar()
{
    if (m_hwnd)
        DestroyWindow(m_hwnd);
    if (m_hwndTip)
        DestroyWindow(m_hwndTip);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CColorBar::SetColors
// Purpose:   Sets the top and bottom colors that are interpolated across the
//            colorbar.
// Arguments: rgbTopColor       -- Color to display at the top of the object
//            rgbBotColor       -- Color to display at the bottom of the object
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CColorBar::SetColors(COLORREF rgbTopColor, COLORREF rgbBotColor)
{
    m_rgbTopColor = rgbTopColor;
    m_rgbBotColor = rgbBotColor;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CColorBar::MoveTo
// Purpose:   Called when the colorbar's owning window is resized, and this
//            object needs to resize (and repaint) itself
// Arguments: nX, nY            -- New location of the object
//            nW, nH            -- New dimensions of the object
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CColorBar::MoveTo(int nX, int nY, int nW, int nH)
{
    RECT rc = {0, 0, nW, nH};

    // Keep track of our new coordinates/dimensions
    m_rc = rc;

    // Move the Win32 window that encapsulates this object
    MoveWindow(m_hwnd, nX, nY, nW, nH, FALSE);

    // Repaint the window
    HDC hdc = GetDC(m_hwnd);
    Repaint(hdc);
    ReleaseDC(m_hwnd, hdc);

    // Update our tooltip's position
    TOOLINFO ti;

    char strTT[30] = "This is your tooltip string.";
    LPTSTR lptstr = strTT;
    
    ti.cbSize = sizeof(TOOLINFO);
    ti.uFlags = TTF_SUBCLASS;
    ti.hwnd = m_hwnd;
    ti.hinst = g_hinst;
    ti.uId = 0;
    ti.lpszText = LPSTR_TEXTCALLBACK;//"Green = Faster\nRed = Slower";
    ti.rect = rc;
    
    // Delete Previous tool (if any)
//    SendMessage(m_hwndTip, TTM_DELTOOL, 0, (LPARAM) (LPTOOLINFO) &ti);

    // Send an ADDTOOL message to the tooltip control window
    SendMessage(m_hwndTip, TTM_ADDTOOL, 0, (LPARAM) (LPTOOLINFO) &ti);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CColorBar::Repaint
// Purpose:   Called when the colorbar needs to refresh its onscreen display
// Arguments: hdc               -- Device context to render to.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CColorBar::Repaint(HDC hdc)
{
    // Setup the necessary structures for the Win32 'GradientFill' call.
    TRIVERTEX rgtv[] = {m_rc.left, m_rc.top,
                        GetRValue(m_rgbTopColor)<<8,
                        GetGValue(m_rgbTopColor)<<8,
                        GetBValue(m_rgbTopColor)<<8, 0,
                        m_rc.right, m_rc.bottom,
                        GetRValue(m_rgbBotColor)<<8,
                        GetGValue(m_rgbBotColor)<<8,
                        GetBValue(m_rgbBotColor)<<8, 0};

    GRADIENT_RECT rggr = {0, 1};
    GradientFill(hdc, rgtv, 2, &rggr, 1, GRADIENT_FILL_RECT_V);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\dumpfst\CFST.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CFST.h
// Contents:  FST file wrapper.  The FST file format is defined by the AMC tools.
// Revisions: 7-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ CLASSES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class:   CFST
// Purpose: Encapsulates an FST file.  Provides accessors to the various entries in the FST file.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class CFST : public CFile
{
public:

    // ++++ CONSTRUCTION-RELATED FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    // CFST         -- CFST Constructor
    CFST(char *szFilename);

    // ~CFST        -- CFST Destructor
    ~CFST();


    // ++++ MEMBER-ACCESS FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    // GetEntry     -- Gets the information about a particular entry in the FST file
    bool GetEntry(int nLayer, int iEntry, char szName[MAX_PATH],
                  int *pnStartPSN, int *pnEndPSN, DWORD *pdwOffset,
                  BOOL fPackage = false, char szPackageDVDRoot[MAX_PATH] = NULL);

    void Dump();

private:

    // m_cEntries   -- The number of entries in the FST file
    int m_cEntries;

    // m_pchStringTable     -- The string table containing the entries' names
    char *m_pchStringTable;

    // m_cbyStringTableSize -- The size of the string table containing the entries' names
    int m_cbyStringTableSize;

    // sTableEntry  -- Contains information about a particular entry in the FST file
    struct sTableEntry
    {
        // m_dwStart    -- LSN that the entry starts on
        DWORD m_dwStart;
        
        // m_dwStop     -- LSN that the entry stops on
        DWORD m_dwStop;

        // m_iDir       -- String table index for the name of the directory for the entry 
        DWORD m_iDir;

        // m_iName      -- String table index for the name of the file for the entry
        DWORD m_iName;

        // m_dwOffset   -- Offset into the entry at which to begin reading data
        DWORD m_dwOffset;
    };

    // m_ptes       -- The list of entrys
    sTableEntry *m_ptes;

    // m_iFirstLayer1Entry  -- Tracks which entry is the first one found on layer 1.
    DWORD m_iFirstLayer1Entry;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\CColorBar.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      cColorbar.h
// Contents:  
// Revisions: 14-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

class CColorBar : public CInitedObject
{
public:
    bool Init(CWindow *pwindow, COLORREF rgbTopColor, COLORREF rgbBotColor);
    ~CColorBar();

    void MoveTo(int nX, int nY, int nW, int nH);

    void SetColors(COLORREF rgbTopColor, COLORREF rgbBotColor);

    HWND GetHwnd() {return m_hwnd; }
    void SetVisible(bool fVisible);

    void Repaint(HDC hdc);

    WNDPROC m_pfnStaticWndProc;
private:

    RECT m_rc;
    HWND m_hwndTip;
    COLORREF m_rgbTopColor, m_rgbBotColor;
    HWND m_hwnd;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\CDVD.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      cdvd.h
// Contents:  
// Revisions: 15-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


class CDVD : public CInitedObject
{
public:
    CDVD();
    ~CDVD();
    bool Reset();

    bool InsertForced(CObjList *ploLayer, CObject *pobjToInsert, DWORD dwLSN);

    //bool Insert(CObject *pobjToInsert, CObject *pobjInsertAt);
    //bool Insert(CObjList *ploLayer, CObject *pobjToInsert, CObject *pobjInsertAt);
    //bool Insert(CObject *rgpobjToInsert[], CObject *pobjInsertAt);
//    bool Insert(CObjList *ploLayer, CObject *rgpobjToInsert[], CObject *pobjInsertAt);

    bool Insert(CObjList *ploLayer, CObject *poToInsert, CObject *poInsertAt);
    bool Insert(CObject *poToInsert, CObject *poInsertAt);

    bool Insert(CObjList *ploLayer, CObjList *polToInsert, CObject *poInsertAt);

    bool ValidatePlaceholders(bool fWarnUser = true);
    void PopulateToList(int iLayer, CListView *plistview);
    bool FileExists(char *szFullFileName);

	bool PersistTo(CFile *pfile);
    bool CreateFrom(CFile *pfile);

    bool PersistFST(char *szBinDir, char *szBinName, CFile *pfileFST);
    bool PersistBIN(CWorkspace *pws, CFile *pfile);

    int GetNumFiles(int nLayer);
    int GetNumEmptySectors(int nLayer);
    int GetNumUsedSectors(int nLayer);
  //  bool MoveSelectedObjectsToScratch(int nLayer, CWindow_Scratch *pscratch);
//    bool MoveSelectedObjectsFromScratch(int nLayer, CWindow_Scratch *pscratch);
    bool InsertObjectList(CObjList *pol, int nLayer, CObject *pobjDropAt);
    bool InsertAtEnd(CObject *pobjToInsert);

    bool RemoveObjectFromLayer(CObject *pobj, int nLayer);
    bool RemoveObjectsFromLayer(CObjList *pol, int nLayer);

    bool CompactLayer(int nLayer);

    bool RefreshDirectoryEntries(CWorkspace *pws, bool fBuildForEmulation);
    bool RefreshFolderDirectoryEntry(CObj_Folder *pof, bool fBuildForEmulation);
    bool PopulateDirEntries(CObj_Folder *pof, CObject *rgoSorted[], int *piIndex, int iMin, int iMax);

    bool RemoveChildObjects(CObj_Folder* pof, CObjList *pol);

//private:

    void SetInitialPlaceholderLSNs();

    bool CheckValidPlaceholderLSN(CObj_Security *pobjPlaceholder, DWORD dwLSN);

    void RefreshRelationships();

    // list of placeable objects
    CObjList *m_rgpolLayer[2];

    CObj_Folder *m_povdRoot;

    void RefreshPlaceholders(bool fValidate = true);

    CObjNodeList m_onlPH;
    bool m_fWarnedTooManyFiles;
};

extern char g_szRootFolderName[MAX_PATH];

// Taken from AMC's file "MediaBase.h"
struct TFileHeader
{
    char m_szFileType[32]; // FST? Error Map?
    char m_szMediaType[32]; // DVD, CD, etc
};

struct TMediaHeader
{
    DWORD uNumSectorsLayer0;
    DWORD uNumSectorsLayer1;
    BYTE m_ImpUseArea[120];       // total = 128 bytes
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\CDVD_Persist.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      cdvd_persist.cpp
// Contents:  Persistance-related functionality for the CDVD class
// Revisions: 6-Jul-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"
#include "IFld.h"

// sTableEntry  -- Contains information about a particular entry in the FST file
struct sTableEntry
{
    // m_dwStart    -- LSN that the entry starts on
    DWORD m_dwStart;
    
    // m_dwStop     -- LSN that the entry stops on
    DWORD m_dwStop;

    // m_iDir       -- String table index for the name of the directory for the entry 
    DWORD m_iDir;

    // m_iName      -- String table index for the name of the file for the entry
    DWORD m_iName;

    // m_dwOffset   -- Offset into the entry at which to begin reading data
    DWORD m_dwOffset;
};

static char *g_szVirtualDvdHeaderString = "AMC Virtual Media";

extern time_t g_timeLastSaved;


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDVD::PersistTo
// Purpose:   
// Arguments: 
// Return:    'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Save our contents to the specified FLD file
bool CDVD::PersistTo(CFile *pfile)
{
    StartProfile(PROFILE_PERSISTTO);    

    // Write the name of the root folder
    pfile->WriteString(g_szRootFolderName);

    if (m_rgpolLayer[0]->PersistTo(pfile) &&
		m_rgpolLayer[1]->PersistTo(pfile))
    {
        EndProfile(PROFILE_PERSISTTO);    
        return true;
    }
    EndProfile(PROFILE_PERSISTTO);    
	return false;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDVD::CreateFrom
// Purpose:   
// Arguments: 
// Return:    'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CDVD::CreateFrom(CFile *pfile)
{
    StartProfile(PROFILE_CREATEFROM);    
    m_onlPH.RemoveAll();

    m_rgpolLayer[0]->Reset();
    m_rgpolLayer[1]->Reset();

    // Get the name of the root folder
    pfile->ReadString(g_szRootFolderName);

    if (!SetCurrentDirectory(g_szRootFolderName))
    {
        char sz[MAX_PATH + 300];
        sprintf(sz, "The FLD file points at a DVD root location (%s) which\n"
                    "is not currently accessible.  Please ensure the path is "
                    "accessible\nand try again.", g_szRootFolderName);
        MessageBox(NULL, sz,  "Invalid DVD Root Location",
                   MB_ICONEXCLAMATION | MB_OK | MB_APPLMODAL);
        EndProfile(PROFILE_CREATEFROM);    
        return false;
    }

    if (m_rgpolLayer[0]->CreateFrom(pfile) && 
		m_rgpolLayer[1]->CreateFrom(pfile))
    {
        EndProfile(PROFILE_CREATEFROM);    
        return true;
    }

    EndProfile(PROFILE_CREATEFROM);    
    return false;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDVD::PersistFST
// Purpose:   
// Arguments: 
// Return:    'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CDVD::PersistFST(char *szBinDir, char *szBinName, CFile *pfile)
{
    CObjList *polLayer;
    StartProfile(PROFILE_PERSISTFST);

    // Write out the AMC Header information
    TFileHeader tfh;
    memset(&tfh, 0, sizeof(TFileHeader));
    strcpy(tfh.m_szFileType, g_szVirtualDvdHeaderString);
    strcpy(tfh.m_szMediaType, "Xbox DVD-ROM");
    if (!pfile->WriteData(&tfh, sizeof(TFileHeader)))
        return false;

    TMediaHeader tmh;
    memset(&tmh, 0, sizeof(TMediaHeader));
    tmh.uNumSectorsLayer0 = 1715632;
    tmh.uNumSectorsLayer1 = 1715632;
    if (!pfile->WriteData(&tmh, sizeof(TMediaHeader)))
        return false;

    // Write out the byte order.
    if (!pfile->WriteWORD(0xABCD))
        return false;

    // Write out a timestamp.
    if (!pfile->WriteDWORD(g_timeLastSaved))
        return false;

    // Write out the number of sectors
// Removed because AMC FST file format changed in latest release.
//    if (!pfile->WriteDWORD(1715632*2))
//        return false;

    // Write out the total number of files on both layers
    int cFiles = GetNumFiles(0) + GetNumFiles(1) + 1;
    if (!pfile->WriteDWORD(cFiles))
        return false;

    // Create the entry table
    sTableEntry *rgte = new sTableEntry[cFiles];
    if (!rgte)
        FatalError(E_OUTOFMEMORY);

    // Create the string table that contains the full path names of all the files
    // Allocate the maximum space that could be required (rather than enumerating
    // the files for exact length).  Only the necessary amount will be written to disk.
    char *rgStrings = new char[cFiles*MAX_PATH];
    if (!rgStrings)
        FatalError(E_OUTOFMEMORY);

    int iEntry = 0;
    int iUdfsDir, iUdfsName;
    int iStringLoc = 0;
    bool fUdfsEmitted = false;

    // Populate the entry table and string table with our file information
    for (int nLayer = 0; nLayer <= 1; nLayer++)
    {
        polLayer = m_rgpolLayer[nLayer];

        // offset by 2 in code below is because we don't want to store the drive ("C:\") (emulator doesn't like it).

        CObject *poCur;
        if (nLayer == 0)
            poCur = polLayer->GetInside();
        else
            poCur = polLayer->GetOutside();
        while (poCur)
        {
            if (poCur->GetType() == OBJ_FILE || poCur->GetType() == OBJ_FOLDER || poCur->GetType() == OBJ_VOLDESC)
            {
                sTableEntry *pteCur = &rgte[iEntry];
                pteCur->m_dwStart = poCur->m_dwLSN;
                pteCur->m_dwStop  = poCur->m_dwLSN + poCur->m_dwBlockSize - 1;

                if (poCur->GetType() == OBJ_FOLDER || poCur->GetType() == OBJ_VOLDESC)
                {
                    // For folders, point at udfs.bin and appropriate offset
                    if (!fUdfsEmitted)
                    {
                        // udfs.bin not emitted yet.  do so now.
                        // output the directory
                        iUdfsDir = iStringLoc;
                        strcpy(rgStrings + iStringLoc, szBinDir + 2);
                        iStringLoc += strlen(rgStrings + iStringLoc) + 1;

                        // output the name
                        iUdfsName = iStringLoc;
                        strcpy(rgStrings + iStringLoc, szBinName);
                        iStringLoc += strlen(rgStrings + iStringLoc) + 1;

                        fUdfsEmitted = true;
                    }
                    pteCur->m_iDir  = iUdfsDir;
                    pteCur->m_iName = iUdfsName;
                    if (poCur->GetType() == OBJ_FOLDER)
                        pteCur->m_dwOffset = ((CObj_Folder*)poCur)->m_dwUdfsOffset;
                    else
                        pteCur->m_dwOffset = ((CObj_VolDesc*)poCur)->m_dwUdfsOffset;
                }
                else
                {
                    // Only need to write out folders once; if already written then
                    // don't write again.
                    for (int i = 0; i < iEntry; i++)
                    {
                        if (!lstrcmpi(&rgStrings[rgte[i].m_iDir], poCur->m_szFolder))
                        {
                            // The folder already exists
                            break;
                        }
                    }
                    if (i == iEntry)
                    {
                        // Folder doesn't exist yet
                        pteCur->m_iDir = iStringLoc;
                        strcpy(rgStrings + iStringLoc, poCur->m_szFolder + 2);
                        iStringLoc += strlen(poCur->m_szFolder) + 1;
                    }
                    else
                        pteCur->m_iDir = rgte[i].m_iDir;

                    pteCur->m_dwOffset = 0;

                    pteCur->m_iName   = iStringLoc;
                    strcpy(rgStrings + iStringLoc, poCur->m_szName);
                    iStringLoc += strlen(poCur->m_szName) + 1;
                }
                iEntry++;
            }

            if (nLayer == 0)
                poCur = polLayer->GetNextOuter();
            else
                poCur = polLayer->GetNextInner();
        }
    }
    
    // Write out the full size of the string table.
    if (!pfile->WriteDWORD(iStringLoc))
        return false;

    // Write out the entry table
    if (!pfile->WriteData(rgte, sizeof(sTableEntry)*cFiles))
        return false;

    // Write out the string table
    if (!pfile->WriteData(rgStrings, iStringLoc))
        return false;
    
    EndProfile(PROFILE_PERSISTFST);
    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDVD::PersistBIN
// Purpose:   Enumerate the contents of gdfs.bin to the specified file.  This
//            includes the Volume Descriptor object, and the directory entries
//            cooresponding to all folder objects in the layout.  The folder
//            objects themselves already contain blocks of directory entries
//            describing their objects; we just need to output that information
//            and gaurantee that it is laid out in such a fashion that doesn't
//            violate certain rules (ie entries can't cross sector boundaries).
// Arguments: 
// Return:    'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CDVD::PersistBIN(CWorkspace *pws, CFile *pfile)
{
    // The BIN file consists of the directory entries for all of the files in
    // the layout.  Each of the folders in the layout contain a block of directory
    // entry structures -- those contain the information that needs to be
    // emitted here.  We convert each of them from a GDF_MAX_DIRECTORY_ENTRY
    // structure (our info+ structure) to the GDF_DIRECTORY_ENTRY structure
    // that the xbox file system is expecting.
    StartProfile(PROFILE_PERSISTBIN);
    static int rgnPadding[] = {0, 3, 2, 1};

    // We need to pad out sectors when directory entries try to straddle them,
    // so precreate a max-sized padding array that we can just memcpy out of.
    BYTE rgbyPadding[2048];
    memset(rgbyPadding, GDF_DIRECTORY_STREAM_PADDING, 2048);

    CObj_Folder *pof;

    // Keep track of the total number of bytes written to the
    // file -- this will be used to check sector boundaries.
    int cBytesWritten = 0;

    // Refresh the folders' directory entries.
    if (!RefreshDirectoryEntries(pws, true))
    {
        // Failed on the refresh.  User has already been notified
        EndProfile(PROFILE_PERSISTBIN);
        return false;
    }

    // Find each folder on the layout and emit its directory entries.  We also
    // keep track of where in the gdfs.bin file the folder's entries are laid
    // out since the FST file generation will need to know the offset into the BIN.
    for (int nLayer = 0; nLayer <= 1; nLayer++)
    {
        CObjList *polLayer = m_rgpolLayer[nLayer];

        // For each object in the layer...
        CObject *poCur = polLayer->GetInside();
        while (poCur)
        {
            switch(poCur->GetType())
            {
            case OBJ_VOLDESC:
                // The object is the volume descriptor object.
                // Track the location of the volume descriptor in the file
                ((CObj_VolDesc*)poCur)->m_dwUdfsOffset = pfile->GetCurLoc();

                // Emit the GDF_VOLUME_DESCRIPTOR information to the file
                pfile->WriteData(&((CObj_VolDesc*)poCur)->m_gdfvd,
                                 sizeof(GDF_VOLUME_DESCRIPTOR));
                // Note: There is no need to pad the sector here since the
                // size of the GDF_VOLUME_DESCRIPTOR is 2048.

                // Emit the xbLayout version information to the file
                pfile->WriteData(&((CObj_VolDesc*)poCur)->m_verinfo,
                                 sizeof(VERSION_INFO));
                break;

            case OBJ_FOLDER:
                // The object is a folder object.  The folder's directory
                // entries were precalculated in RefreshFolderDirectoryEntry,
                // so we just have to do a little bit of conversion (from our
                // data structure to the GDF_DIRECTORY_ENTRY that the OS is
                // expected), and handle padding as necessary.

                // We know the current object is a folder object, so cast a.
                // pointer to it.
                pof = (CObj_Folder*)poCur;

                // Track the folder's location in the gdfs.bin file.
                pof->m_dwUdfsOffset = pfile->GetCurLoc();

                // Emit the folder's directory entry information.  We need to be
                // sure two things happen:
                //  1. An entry doesn't cross a sector boundary.
                //  2. Each sector is padded with GDF_DIRECTORY_STREAM_PADDING.

                // For each directory entry in the folder...
                for (int i = 0; i < pof->m_cDirEntries; i++)
                {
                    // Store a pointer to our directory entry "info+" structure
                    GDF_MAX_DIRECTORY_ENTRY *pgdfmde = &pof->m_prgGDFMDE[i];

                    // Determine how many bytes we'll need to write out for the
                    // current directory entry.
                    int cBytesToWrite = sizeof(GDF_DIRECTORY_ENTRY) +
                                        pgdfmde->FileNameLength - 1;

                    // We need to be sure that the entry ends on a DWORD-
                    // boundary since the index values are shifted up by 4.
                    int nPadding = rgnPadding[cBytesToWrite % 4];
 
                    // Check to see if the current entry will cross a sector
                    // boundary
                    if (cBytesWritten / 2048 != (cBytesWritten + cBytesToWrite + nPadding) / 2048)
                    {
                        // We'll cross a sector boundary if we try to write out
                        // the current directory entry.  Instead, pad out the
                        // remainder of the current sector so that we write the
                        // current directory entry starting a the next sector.
                        // The index values were already calculated properly in
                        // the RefreshFolderDirectoryEntry funtion, so we don't
                        // have to modify them here.
                        pfile->WriteData(rgbyPadding, 2048 - (cBytesWritten % 2048));
                        cBytesWritten += 2048 - (cBytesWritten % 2048);
                    }

                    // Now that we know we're at a safe place to write out the
                    // directory entry, write out the GDF_DIRECTORY_ENTRY-
                    // specific information from the GDF_MAX_DIRECTORY_ENTRY
                    // structure (the latter structure is designed such that
                    // the GDF_DIRECTORY_ENTRY values occur first, so we can
                    // just do a simple write.
                    pfile->WriteData(pgdfmde, cBytesToWrite);

                    // Pad out to a DWORD boundary
                    if (nPadding)
                    {
                        pfile->WriteData(rgbyPadding, nPadding);
                        cBytesWritten += nPadding;
                    }
                    
                    // Track how many bytes we've written to gdfs.bin so far.
                    cBytesWritten += cBytesToWrite;
                }

                // Pad the remainder of the sector.
                int nExtra = 2048 - (cBytesWritten % 2048);
                pfile->WriteData(rgbyPadding, nExtra);
                cBytesWritten += nExtra;
                break;
            }

            poCur = polLayer->GetNextOuter();
        }
    }
    EndProfile(PROFILE_PERSISTBIN);
   
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\CFile.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CFile.cpp
// Contents:  
// Revisions: 8-Jul-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"
#include <malloc.h>

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CFile::CFile(char *szName, DWORD dwFlags) : CInitedObject()
{
    strcpy(m_szName, szName);
    m_fMemoryFile = dwFlags & FILE_MEMORY;
    if (m_fMemoryFile)
    {
        // File only exists in memory.  Allocate a block
        m_dwMemSize = 20000;
        m_rgbyData = (BYTE*)malloc(m_dwMemSize);
        if (!m_rgbyData)
            FatalError(E_OUTOFMEMORY);

        m_pbyMemCur = m_rgbyData;
    }
    else
    {
        // File exists on disk
        if (dwFlags & FILE_READ)
            m_hfile = CreateFile(szName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        else
            m_hfile = CreateFile(szName, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (m_hfile == INVALID_HANDLE_VALUE)
        {
            m_fClosed = true;
            return;
        }
    }
    m_fClosed = false;
    SetInited(S_OK);
}

CFile::~CFile()
{
    Close();
}

void CFile::IncreaseMemSize(DWORD dwBytes)
{
    DWORD dwOrigSize = m_dwMemSize;

    assert(m_dwMemSize);
    while (m_dwMemSize < (m_pbyMemCur - m_rgbyData) + dwBytes)
    {
        assert(m_dwMemSize*2);
        m_dwMemSize *= 2;
    }

    if (dwOrigSize != m_dwMemSize)
    {
        DWORD dwOffset = m_pbyMemCur - m_rgbyData;
        m_rgbyData = (BYTE*)realloc(m_rgbyData, m_dwMemSize);
        if (!m_rgbyData)
            FatalError(E_OUTOFMEMORY);

        m_pbyMemCur = m_rgbyData + dwOffset;
    }
}

void CFile::Close()
{
    if (m_fClosed)
        return;

    if (m_fMemoryFile)
    {
        free(m_rgbyData);
    }
    else
        CloseHandle(m_hfile);

    m_fClosed = true;
}

bool CFile::WriteData(void *pvData, DWORD cBytes)
{
    if (m_fMemoryFile)
    {
        IncreaseMemSize(cBytes);
        memcpy(m_pbyMemCur, pvData, cBytes);
        m_pbyMemCur += cBytes;
    }
    else
    {
        DWORD dwWritten;
        if (!WriteFile(m_hfile, (BYTE*)pvData, cBytes, &dwWritten, NULL) || dwWritten != cBytes)
            return false;
    }

    return true;

}

DWORD CFile::GetCurLoc()
{
    if (m_fMemoryFile)
    {
        return m_pbyMemCur - m_rgbyData;
    }
    else
    {
        // NOTE: only works with files < 2^32 bytes.  However, the GDF_DIR_ENTRY 'filesize' var can only be that big, so presumably this is okay...
        return SetFilePointer(m_hfile, 0, NULL, FILE_CURRENT);
    }
}

bool CFile::WriteBYTE(BYTE byData)
{
    if (m_fMemoryFile)
    {
        IncreaseMemSize(1);
        memcpy(m_pbyMemCur, &byData, 1);
        m_pbyMemCur += 1;
    }
    else
    {
        DWORD dwWritten;
        BYTE rgby[] = {byData};
        if (!WriteFile(m_hfile, rgby, 1, &dwWritten, NULL) || dwWritten != 1)
            return false;
    }
    return true;
}

bool CFile::WriteWORD(WORD wData)
{
    if (m_fMemoryFile)
    {
        IncreaseMemSize(2);
        memcpy(m_pbyMemCur, &wData, 2);
        m_pbyMemCur += 2;
    }
    else
    {
        DWORD dwWritten;
        WORD rgw[] = {wData};
        if (!WriteFile(m_hfile, rgw, 2, &dwWritten, NULL) || dwWritten != 2)
            return false;
    }

    return true;
}


bool CFile::WriteDWORD(DWORD dwData)
{
    if (m_fMemoryFile)
    {
        IncreaseMemSize(4);
        memcpy(m_pbyMemCur, &dwData, 4);
        m_pbyMemCur += 4;
    }
    else
    {
        DWORD dwWritten;
        DWORD rgdw[] = {dwData};
        if (!WriteFile(m_hfile, rgdw, 4, &dwWritten, NULL) || dwWritten != 4)
            return false;
    }
    return true;
}

bool CFile::WriteString(char *sz)
{
    if (m_fMemoryFile)
    {
        IncreaseMemSize(strlen(sz)+4);
        if (!WriteDWORD(strlen(sz)))
            return false;
        memcpy(m_pbyMemCur, sz, strlen(sz));
        m_pbyMemCur += strlen(sz);
    }
    else
    {
        DWORD dwWritten;
        if (!WriteDWORD(strlen(sz)))
            return false;
        if (!WriteFile(m_hfile, sz, strlen(sz), &dwWritten, NULL) || dwWritten != strlen(sz))
            return false;
    }
    return true;
}

bool CFile::ReadBYTE(BYTE *pbyData)
{
    if (m_fMemoryFile)
    {
        memcpy(pbyData, m_pbyMemCur, 1);
        m_pbyMemCur += 1;
    }
    else
    {
        DWORD dwRead;
        if (!ReadFile(m_hfile, pbyData, 1, &dwRead, NULL) || dwRead != 1)
            return false;
    }
    return true;
}

bool CFile::ReadWORD(WORD *pwData)
{
    if (m_fMemoryFile)
    {
        memcpy(pwData, m_pbyMemCur, 2);
        m_pbyMemCur += 2;
    }
    else
    {
        DWORD dwRead;
        if (!ReadFile(m_hfile, pwData, 2, &dwRead, NULL) || dwRead != 2)
            return false;
    }
    return true;
}

bool CFile::ReadDWORD(DWORD *pdwData)
{
    if (m_fMemoryFile)
    {
        memcpy(pdwData, m_pbyMemCur, 4);
        m_pbyMemCur += 4;
    }
    else
    {
        DWORD dwRead;
        if (!ReadFile(m_hfile, pdwData, 4, &dwRead, NULL) || dwRead != 4)
            return false;
    }
    return true;
}

bool CFile::ReadString(char *sz)
{
    if (m_fMemoryFile)
    {
        DWORD dwStrlen;
        if (!ReadDWORD(&dwStrlen))
            return false;
        memcpy(sz, m_pbyMemCur, dwStrlen);
        sz[dwStrlen] = '\0';
        m_pbyMemCur += dwStrlen;
    }
    else
    {
        DWORD dwStrlen, dwRead;
        if (!ReadDWORD(&dwStrlen))
            return false;
        if (!ReadFile(m_hfile, sz, dwStrlen, &dwRead, NULL) || dwRead != dwStrlen)
            return false;
        sz[dwStrlen] = '\0';
    }
    return true;
}

bool CFile::ReadData(void *pvData, DWORD cBytes)
{
    if (m_fMemoryFile)
    {
        memcpy(pvData, m_pbyMemCur, cBytes);
        m_pbyMemCur += cBytes;
    }
    else
    {
        DWORD dwRead;
        if (!ReadFile(m_hfile, pvData, cBytes, &dwRead, NULL) || dwRead != cBytes)
            return false;
    }
    return true;
}

bool CFile::SetPos(DWORD dwPos)
{
    if (m_fMemoryFile)
        m_pbyMemCur = m_rgbyData + dwPos;
    else
        SetFilePointer(m_hfile, dwPos, NULL, FILE_BEGIN);
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\CFile.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CFile.h
// Contents:  
// Revisions: 8-Jul-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#define FILE_MEMORY 0x0001
#define FILE_DISK   0x0002

#define FILE_READ   0x0004
#define FILE_WRITE  0x0008

class CFile : public CInitedObject
{
public:
    CFile(char *szName, DWORD dwFlags = FILE_DISK);
    ~CFile();
    void Close();
    bool WriteData(void *pvData, DWORD cBytes);
    DWORD GetCurLoc();
    bool WriteWORD(WORD wData);
    bool WriteBYTE(BYTE byData);
    bool WriteDWORD(DWORD dwData);
    bool WriteString(char *sz);

    bool ReadBYTE(BYTE *pbyData);
    bool ReadWORD(WORD *pwData);
    bool ReadDWORD(DWORD *pdwData);
    bool ReadString(char *sz);
    bool ReadData(void *pvData, DWORD cBytes);

    // true if file is stored only in memory
    bool m_fMemoryFile;
    bool SetPos(DWORD dwPos);
    char m_szName[MAX_PATH];
    
private:
    HANDLE m_hfile;
    DWORD m_dwMemSize;
    BYTE *m_rgbyData;
    void IncreaseMemSize(DWORD cBytes);
    BYTE *m_pbyMemCur;
    bool m_fClosed;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\CDVD.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CDVD.cpp
// Contents:  Declaration of numerous functions for the CDVD class.
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ DEFINES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// NUM_SECTORS          -- The number of sectors of the ximage region on each
//                         layer of the disc.
#define NUM_SECTORS 1715632

// NUM_PLACEHOLDERS     -- Total of 16 placeholders (8 per side).
#define NUM_PLACEHOLDERS 16


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ GLOBAL VARIABLES ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


char g_szRootFolderName[MAX_PATH];

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDVD::CDVD
// Purpose:   CDVD Constructor
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CDVD::CDVD() : CInitedObject()
{
    HRESULT hrInit = S_OK;

    // Create the DVD's two layers
    m_rgpolLayer[0] = new CObjList;
    m_rgpolLayer[1] = new CObjList;
    if (m_rgpolLayer[0] == NULL || m_rgpolLayer[1] == NULL)
    {
        hrInit = E_OUTOFMEMORY;
        goto done;
    }
    
    // Mark that layer 1's LSN order is opposite of 'normal', where normal is
    // arbitrarily defined to match Layer 0 (and the scratch window).
    m_rgpolLayer[1]->SetInsideOut(true);

done:

    // Set the result of initialization
    SetInited(hrInit);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDVD::~CDVD
// Purpose:   CDVD Destructor
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CDVD::~CDVD()
{
    // Delete our layers
    if (m_rgpolLayer[0])
        delete m_rgpolLayer[0];
    if (m_rgpolLayer[1])
        delete m_rgpolLayer[1];
}

static DWORD gs_rgdwSecurityLSNs[16];

static DWORD gs_rgdwInitSecLSNs[19] =
{
    93748, 171166, 248584, 326002, 403420, 480838, 558256, 635674, 713092, 790510,
    867928, 945345, 1022763, 1100181, 1177599, 1255017, 1332435, 1409853, 1642107
};


static const int gsc_nJitter = 3892;

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDVD::SetInitialPlaceholderLSNs
// Purpose:   
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CDVD::SetInitialPlaceholderLSNs()
{
    int iEntry;
    int cRuns = 0;
    BYTE rgbyPH[20];    // Note: The final entry is just for a bookend
    DWORD rgdwTemp[8];

    // -1 == layer 0 bias, 0 == even layer bias, +1 == layer 1 bias
    // 2 == don't place.
    memset(gs_rgdwSecurityLSNs, 0, 16*4);

    // Start out with everything unplaced.  Drop an 'endpoint' at the very
    // end to catch the last run
    memset(rgbyPH, 0, sizeof(rgbyPH));
    rgbyPH[19] = 2;

    // don't place 3 of them (randomly chosen)
    for (int i = 0; i < 3; i++) {
        do {
            iEntry = rand()%19;
        } while (rgbyPH[iEntry]);
        rgbyPH[iEntry] = 2;
    }

    // Count how many odd runs there are
    int cOddRuns = 0;
    int nRunStart = -1;
    
    for (i = 0; i < 20; i++) {
        if (rgbyPH[i] == 2) {
            if (i > nRunStart)
                cOddRuns += (i - nRunStart-1) % 2;
            nRunStart = i;
        }
    }

    // For the remaining entries, place them based on runs
    nRunStart = 0;
    int iRuns = 0;
    for (i = 0; i < 20; i++) {
        if (rgbyPH[i] == 2) {
            if (i > nRunStart) {
                if ((i-nRunStart)%2){
                    memset(rgbyPH + nRunStart, (iRuns < cOddRuns / 2) ? -1 : 1, i - nRunStart);
                    iRuns++;
                }
            }
            nRunStart = i+1;
        }
    }

    // Walk the list a second time, this time actually setting the placeholder LSNs
    int rgiSec[2] = {0, 8};
    int iLayer = 0;
    BYTE byPrevPH = 2;
    for (i = 0; i < 19; i++) {
        if (byPrevPH != rgbyPH[i]) {
            // new run
            if (rgbyPH[i] == 1) iLayer = 1;
            else iLayer = 0;
            byPrevPH = rgbyPH[i];
        }
        // place it
        if (rgbyPH[i] != 2) {
            int nJitter = (rand() % (gsc_nJitter*2)) - gsc_nJitter;
            gs_rgdwSecurityLSNs[rgiSec[iLayer]++] += gs_rgdwInitSecLSNs[i] + nJitter;
        }
        iLayer = 1 - iLayer;
    }
    // Reverse the order of the layer 1 PHs and convert their temp LSNs to final LSNs
    for (i = 8; i < 16; i++)
        rgdwTemp[i-8] = 2*1715632 - gs_rgdwSecurityLSNs[23-i] - 4096;
    memcpy(&gs_rgdwSecurityLSNs[8], rgdwTemp, 8 * 4);

    assert (rgiSec[0] == 8 && rgiSec[1] == 16);
}


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDVD::Reset
// Purpose:   Reset the DVD to a pristine state.  This means the only objects
//            are the default ones (bookends, placeholders, and volume
//            descriptor)
// Arguments: None.
// Return:    true if successful; false otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CDVD::Reset()
{
    if (!IsInited())
        return false;

    StartProfile(PROFILE_RESET);
    // Clean out all old objects in the object lists
    m_onlPH.RemoveAll();
    m_rgpolLayer[0]->Reset();
    m_rgpolLayer[1]->Reset();

    // Create the default objects
    CObject *poStart0  = new CObj_Bookend();
    CObject *poStart1  = new CObj_Bookend();
    CObject *poEnd0    = new CObj_Bookend();
    CObject *poEnd1    = new CObj_Bookend();
    CObj_VolDesc *povd = new CObj_VolDesc();
    if (!poStart0 || !poStart1 || !poEnd0 || !poEnd1 || !povd)
        FatalError(E_OUTOFMEMORY);

    // Insert the starting bookends onto the layers.  These are solely to make
    // traversing the lists easier.
    InsertForced(m_rgpolLayer[0], poStart0, 0);
    InsertForced(m_rgpolLayer[1], poStart1, NUM_SECTORS);

    // Insert the volume descriptor onto layer 0 at LSN 32 (as per gdformat.h).
    InsertForced(m_rgpolLayer[0], povd, 32);
    
    // Add the security placeholders to the list.  Preset their LSNs to known-
    // valid values.
    SetInitialPlaceholderLSNs();

    for (int i = 0; i < NUM_PLACEHOLDERS; i++)
    {
        // Create the security placeholder
        CObject *poSecurity = new CObj_Security();
        if (!poSecurity)
        {
            EndProfile(PROFILE_RESET);
            return false;
        }
        
        // Insert the security object into the 'disc' at the appropriate LSN
        InsertForced(i < NUM_PLACEHOLDERS/2 ? m_rgpolLayer[0] : m_rgpolLayer[1],
                     poSecurity, gs_rgdwSecurityLSNs[i]);
    }

    // Add the ending bookends
    InsertForced(m_rgpolLayer[0], poEnd0, NUM_SECTORS);
    InsertForced(m_rgpolLayer[1], poEnd1, NUM_SECTORS*2);

    // Track that we haven't yet warned the user if there are too many files in
    // their layout.
    m_fWarnedTooManyFiles = false;

    RefreshPlaceholders();
    EndProfile(PROFILE_RESET);
    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDVD::PopulateToList
// Purpose:   Populates the specified listview with the objects in the
//            specified layer.
// Arguments: nLayer        -- The layer to populate from.
//            plistview     -- The listview to populate to.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CDVD::PopulateToList(int nLayer, CListView *plistview)
{
    StartProfile(PROFILE_POPULATETOLIST);
    // Determine which listview the specified layer refers to.
    CObjList *plo = m_rgpolLayer[nLayer];

    // Keep track of which objects, if any, where selected in the listview prior
    // to clearing it, so that we can display them as selected post-insertion.
    // Also stores the current scroll position of the list for later use.
 //   plistview->StoreSelectedObjList();
    
    // Clear out the listview control.
    plistview->Clear();

    // Add the objects in the layer to the listview control
    CObject *poCur = plo->GetInside();
    CObject *pobjNext = plo->GetNextOuter();
    while (poCur)
    {
        // There can be no empty space inside of a group
        if (poCur->m_pog == NULL)
        {
            if (plo->IsInsideOut())
            {
                // Is there empty space between the current object and the next
                // one?  If so, then explicitly add an 'empty' object to the
                // listview so that it's obvious to the user.  We don't add it
                // to the layer though.
                if (pobjNext && (poCur->m_dwLSN - pobjNext->m_dwLSN >
                    pobjNext->m_dwBlockSize) && poCur->GetType() != OBJ_GROUP)
                {
                    CObj_Empty *poe = new CObj_Empty((poCur->m_dwLSN -
                          (pobjNext->m_dwLSN + pobjNext->m_dwBlockSize))*2048);
                    if (!poe)
                        FatalError(E_OUTOFMEMORY);
                    poe->m_dwLSN = pobjNext->m_dwLSN + pobjNext->m_dwBlockSize;
                    plistview->AddObject(poe);
                }
            }
            else
            {
                // Is there empty space between the current object and the next
                // one?  If so, then explicitly add an 'empty' object to the
                // listview so that it's obvious to the user.  We don't add it
                // to the layer though.
                if (pobjNext && (poCur->m_dwLSN + poCur->m_dwBlockSize < 
                                                            pobjNext->m_dwLSN))
                {
                    CObj_Empty *poe = new CObj_Empty((pobjNext->m_dwLSN -
                                  (poCur->m_dwLSN+poCur->m_dwBlockSize))*2048);
                    if (!poe)
                        FatalError(E_OUTOFMEMORY);
                    poe->m_dwLSN = poCur->m_dwLSN + poCur->m_dwBlockSize;
                    plistview->AddObject(poe);
                }
            }
        }

        // Don't add bookends or groups (they are not visible in the listview
        if (poCur->GetType() != OBJ_BE && poCur->GetType() != OBJ_GROUP)
            plistview->AddObject(poCur);
        
        // Step to the next object to be added to the listview
        poCur = pobjNext;
        pobjNext = plo->GetNextOuter();
    }

    plistview->m_fModified = false;

    // We're done with the list of selected objects so clear it out.  Also
    // restore the original scroll position.
//    plistview->ClearSelectedObjList();
    EndProfile(PROFILE_POPULATETOLIST);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDVD::FileExists
// Purpose:   Determine if a file exists on the dvd.  Searched by full pathname
//            Examines both layers to see if the specified file is present.
// Arguments: szFullFileName        -- Full path name of the file to search for
// Return:    'true' if the file exists on the dvd.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CDVD::FileExists(char *szFullFileName)
{
    if (m_rgpolLayer[0]->FindObjectByFullFileName(szFullFileName) || 
        m_rgpolLayer[1]->FindObjectByFullFileName(szFullFileName))
        return true;

    return false;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDVD::GetNumFiles
// Purpose:   Get the number of files and folders on the specified layer
// Arguments: nLayer        -- The layer to get the number of files on.
// Return:    The number of files on the specified layer
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
int CDVD::GetNumFiles(int nLayer)
{
    // Return the number of files and folders in the layer
    return m_rgpolLayer[nLayer]->GetNumObjects(OBJ_FILE | OBJ_FOLDER);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDVD::GetNumEmptySectors
// Purpose:   Get the number of empty sectors on the specified layer
// Arguments: nLayer        -- The layer to get the number of empty sectors on.
// Return:    The number of empty sectors on the specified layer
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
int CDVD::GetNumEmptySectors(int nLayer)
{
    // 1716532 sectors available on an empty disk.  Subtract how much is used
    // by the different objects, and we know how much space is left
    return NUM_SECTORS -
           m_rgpolLayer[nLayer]->GetObjectSizes(OBJ_FILE    | OBJ_FOLDER |
                                                OBJ_VOLDESC | OBJ_SEC);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDVD::GetNumUsedSectors
// Purpose:   Get the number of sectors used by files and folders on the layer
// Arguments: nLayer        -- The layer to check.
// Return:    The number of sectors used by files and folders on the layer
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
int CDVD::GetNumUsedSectors(int nLayer)
{
    // Return the number of sectors used by files and folders
    return m_rgpolLayer[nLayer]->GetObjectSizes(OBJ_FILE | OBJ_FOLDER);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDVD::RemoveObjectsFromLayer
// Purpose:   Remove a set of objects from the specified layer.
// Arguments: pol           -- The list of objects to remove from the layer
//            nLayer        -- The layer to remove the objects from
// Return:    'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CDVD::RemoveObjectsFromLayer(CObjList *pol, int nLayer)
{
    CObject *poCur = pol->GetOutside();
    while (poCur)
    {
        CObject *poNext = poCur->m_poInner;
        m_rgpolLayer[nLayer]->Remove(poCur);
        poCur = poNext;
    }
    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDVD::RemoveObjectFromLayer
// Purpose:   Removes a single object from a layer
// Arguments: pobj          -- The object to remove from the layer
//            nLayer        -- The layer to remove the object from.
// Return:    'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CDVD::RemoveObjectFromLayer(CObject *pobj, int nLayer)
{
    m_rgpolLayer[nLayer]->Remove(pobj);
    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDVD::RemoveChildObjects
// Purpose:   Remove all of the objects which belong to the folder, and add
//            them to the list of objects.
// Arguments: pof           -- Folder to check against.
//            polChildren   -- List to which objects inside 'pof' are added.
// Return:    'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CDVD::RemoveChildObjects(CObj_Folder* pof, CObjList *polChildren)
{
    // For each layer...
    for (int i = 0; i < 2; i++)
    {
        // For each file or folder object on both layers, if its parent folder
        // matches the one passed in, then remove it and add it to the list
        CObject *poCur = m_rgpolLayer[i]->GetInside();
        while (poCur)
        {
            CObject *poNext = poCur->m_poOuter;
            if (poCur->m_pof == pof)
            {
                poCur->RemoveFromList();
                polChildren->AddToTail(poCur);
            }
            poCur = poNext;
        }
    }
    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDVD::CompactLayer
// Purpose:   Compact the specified layer so that all files are as far outside
//            as possible.  Security placeholders are not moved during this
//            process.
// Arguments: nLayer            -- Layer to compact (0 or 1)
// Return:    'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CDVD::CompactLayer(int nLayer)
{
    StartProfile(PROFILE_COMPACTLAYER);
    CObjList olToInsert;
    CObjList *ploLayer = m_rgpolLayer[nLayer];
    
    // Remove all non-placeholder objects and add them to the list of objects
    // to be placed back into the layer.
    CObject *poCur = ploLayer->GetOutside()->m_poInner;
    while (poCur->GetType() != OBJ_BE)
    {
        CObject *poNext = poCur->m_poInner;
        if (poCur->GetType() != OBJ_SEC && poCur->GetType() != OBJ_VOLDESC)
        {
            ploLayer->Remove(poCur);
            if (poCur->m_pog == NULL)
                olToInsert.AddToHead(poCur);
        }
        poCur = poNext;
    }

    // At this point, the layer contains only placeholders and bookends.
    // Start out pointing at the outermost object (the outside bookend).
    CObject *poCompacted = ploLayer->GetOutside();
    CObject *poToInsert = olToInsert.GetOutside();
    while (poToInsert)
    {
        CObject *poInner = poCompacted->m_poInner;
        CObject *poNextInsert = poToInsert->m_poInner;
        
        olToInsert.Remove(poToInsert);

        // If the object is a member of a group, then ignore it and let the
        // group handle it atomically.  When the group itself is added, its
        // contained objects will be added at that point.
        if (poToInsert->m_pog)
            goto next;

        // Check if there's enough room to place the next object in the 'to
        // insert' list.
        while (true)
        {
            DWORD dwEmptySpace;
            if (ploLayer->IsInsideOut())
                dwEmptySpace = poInner->m_dwLSN - (poCompacted->m_dwLSN + poCompacted->m_dwBlockSize);
            else
                dwEmptySpace = poCompacted->m_dwLSN - (poInner->m_dwLSN + poInner->m_dwBlockSize);

            if (dwEmptySpace >= poToInsert->m_dwBlockSize)
                break;

            // Not enough space between the compacted object and the object
            // immediate 'inside' of it.  Step to the next object and
            // try again
            poCompacted = poInner;
            poInner = poCompacted->m_poInner;
            if (poCompacted->GetType() == OBJ_BE)
            {
                // Ran out of room!  We shouldn't ever get here since we know
                // that there was enough space *before* compacting.
                assert(false);
                EndProfile(PROFILE_COMPACTLAYER);
                return false;
            }
        }

        // Insert poToInsert inside poCompacted
        ploLayer->InsertInside(poToInsert, poCompacted);
        if (ploLayer->IsInsideOut())
            poToInsert->m_dwLSN = poCompacted->m_dwLSN + poCompacted->m_dwBlockSize;
        else
            poToInsert->m_dwLSN = poCompacted->m_dwLSN - poToInsert->m_dwBlockSize;

        if (poToInsert->GetType() == OBJ_GROUP)
        {
            DWORD dwPrevLSN = poToInsert->m_dwLSN;
            CObject *poPrevContained = poToInsert;
            CObject *poContained;
            if (ploLayer->IsInsideOut())
                poContained = ((CObj_Group*)poToInsert)->m_gol.Tail();
            else
                poContained = ((CObj_Group*)poToInsert)->m_gol.Head();
            while (poContained)
            {
                poContained->m_dwLSN = dwPrevLSN;
                ploLayer->InsertOutside(poContained, poPrevContained);
                dwPrevLSN += poContained->m_dwBlockSize;
                if (ploLayer->IsInsideOut())
                    poContained = ((CObj_Group*)poToInsert)->m_gol.Prev();
                else
                {
                    poPrevContained = poContained;
                    poContained = ((CObj_Group*)poToInsert)->m_gol.Next();
                }
            }
        }
        poCompacted = poToInsert;

next:
        // Handle the next object in the 'to insert' list
        poToInsert = poNextInsert;
    }
    EndProfile(PROFILE_COMPACTLAYER);
    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDVD::RefreshRelationships
// Purpose:   Refreshes the child->parent folder relationship for all file
//            and folder objects on the DVD
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CDVD::RefreshRelationships()
{
    StartProfile(PROFILE_REFRESHRELATIONSHIPS);
    // For each layer...
    for (int i = 0; i < 2; i++)
    {
        // For each file or folder object on the layer, find its parent folder
        // object and store a pointer to it.
        CObjList *ploLayer = m_rgpolLayer[i];
        CObject *poCur = ploLayer->GetInside();
        while (poCur)
        {
            // If it's a file or folder...
            if (poCur->GetType() == OBJ_FILE || poCur->GetType() == OBJ_FOLDER)
            {
                // Find the file or folder that it 'belongs to' (ie is within).
                CObject *poCheck = NULL;
                for (int j = 0; j < 2 && !poCheck; j++)
                {
                    poCheck = m_rgpolLayer[j]->GetInside();
                    while (poCheck)
                    {
                        if (poCheck->GetType() == OBJ_FOLDER)
                        {
                            // It's a folder; is it the right one?
                            if (!lstrcmpi(poCur->m_szFolder, poCheck->m_szFullFileName))
                            {
                                // yep - create the relationship.
                                poCur->m_pof = (CObj_Folder*)poCheck;
                                break;
                            }
                        }
                        poCheck = poCheck->m_poOuter;
                    }
                }
            }
            poCur = poCur->m_poOuter;
        }
    }
    EndProfile(PROFILE_REFRESHRELATIONSHIPS);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\CInitedObject.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     CInitedObject.h
// Contents: Contains the declaration of the CInitedObject object class.
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ CLASSES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class:   CInitedObject
// Purpose: Tracks initialization state of an object.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class CInitedObject
{
public:

    // ++++ CONSTRUCTION-RELATED FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    // CInitedObject        -- Standard constructor
    CInitedObject()
    {
        m_hrInit = E_FAIL;
    }


    // ++++ ACCESSOR FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    // GetInitCode          -- Returns the result of initialization
    HRESULT GetInitCode()
    {
        if (this == NULL)
            return E_FAIL;
        return m_hrInit;
    }

    // IsInited             -- Returns 'true' if the object was successfully initialized
    bool IsInited()
    {
        return GetInitCode() == S_OK;
    }


protected:

    // ++++ ACCESSOR FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    // SetInited            -- Allows a derived class to clear or set the initialized state to track
    //                         the derived class' initialization success.
    void SetInited(HRESULT hrInit)
    {
        m_hrInit = hrInit;
    }

private:

    // m_hrInit             -- Tracks the result of object initialization.
    HRESULT m_hrInit;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\CDVD_Insert.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      cdvd_insert.cpp
// Contents:  
// Revisions: 6-Jul-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDVD::InsertObjectList
// Purpose:   
// Arguments: 
// Return:    'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CDVD::InsertObjectList(CObjList *pol, int nLayer, CObject *pobjDropAt)
{
    return Insert(m_rgpolLayer[nLayer], pol, pobjDropAt);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDVD::InsertForced
// Purpose:   
// Arguments: 
// Return:    'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CDVD::InsertForced(CObjList *ploLayer, CObject *poToInsert, DWORD dwLSN)
{
    // This function is only called during initialization; the LSNs are gauranteed to be in the
    // proper order, so we can simply just Add the object as we go
    ploLayer->AddToTail(poToInsert);
    poToInsert->m_dwLSN = dwLSN;
    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDVD::InsertAtEnd
// Purpose:   
// Arguments: 
// Return:    'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CDVD::InsertAtEnd(CObject *poToInsert)
{
    // This function is only called during initialization; the LSNs are gauranteed to be in the
    // proper order, so we can simply just Add the object as we go
    // First try layer 0, if that fails, try layer 1
    if (Insert(m_rgpolLayer[0], poToInsert, NULL))
        return true;
    return Insert(m_rgpolLayer[1], poToInsert, NULL);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDVD::Insert
// Purpose:   
// Arguments: 
// Return:    true if successfully inserted; false otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CDVD::Insert(CObject *poToInsert, CObject *poInsertAt)
{
    // First try layer 0, if that fails, try layer 1
    return Insert(m_rgpolLayer[0], poToInsert, poInsertAt) ||
           Insert(m_rgpolLayer[1], poToInsert, poInsertAt);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDVD::Insert
// Purpose:   
// Arguments: 
// Return:    true if successfully inserted; false otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CDVD::Insert(CObjList *ploLayer, CObject *poToInsert, CObject *poInsertAt)
{
    CObjList ol;
    
    // Create a temp list for the main Insert function.
    ol.AddToTail(poToInsert);

    return Insert(ploLayer, &ol, poInsertAt);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDVD::Insert
// Purpose:   
// Arguments: 
// Return:    true if successfully inserted; false otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CDVD::Insert(CObjList *ploLayer, CObjList *polToInsert, CObject *poInsertAt)
{
    // We do not have to do this in an 'undo-able' fashion since the originator of this insertion
    // snapshot-ed the workspace before calling in here.  If we determine that the insertion
    // can't be done, then we just return false, and the caller handles restoring the pre-insertion
    // state.
    StartProfile(PROFILE_INSERT);

    ploLayer->m_fModified = true;

    // Check if caller specified an outside insertion
    if (poInsertAt == (CObject*)INSERT_OUTSIDEEDGE)
    {
        poInsertAt = ploLayer->GetOutside();
    }
    if (poInsertAt == (CObject*)INSERT_INSIDEEDGE)
    {
        poInsertAt = ploLayer->GetInside()->m_poOuter;
    }
    else if (poInsertAt == NULL)
    {
        // If the caller didn't specify an insertion point, then we simply insert it after the
        // farthest-inside object already in the list.

        // Start at the inside of the disc and move outward - the first time we hit a non-SEC
        // object, we've found our insertion point.
        poInsertAt = ploLayer->GetInside();

        // Skip the initial bookend
        poInsertAt = ploLayer->GetNextOuter();

        while (poInsertAt->GetType() == OBJ_SEC || poInsertAt->GetType() == OBJ_VOLDESC)
            poInsertAt = ploLayer->GetNextOuter();
    }
    else if (poInsertAt->m_pog)
    {
        // Tried dropping onto a group.  The only time this is allowed is when
        // it's the first item in the group (in which case, the user was actually
        // trying to insert before the group
        poInsertAt = poInsertAt->m_poInner;
    }
 
    CObj_Group *pogInsertion = poInsertAt->m_pog;
    int nDistMoveIn, nDistMoveOut;
    DWORD dwEmptySectors;
    int nLayer = (ploLayer == m_rgpolLayer[0]) ? 0 : 1;

    // We don't allow inserting into a group
    if (poInsertAt->m_pog != NULL)
    {
        EndProfile(PROFILE_INSERT);
        return false;
    }

    // Add all of the non-placeholder objects "inside of" the insertion point
    // to the list of objects to insert. Don't add members of groups -- the
    // group object will be handled as the sum of the contained objects.
    CObject *poCur = poInsertAt->m_poInner;
    while (poCur->GetType() != OBJ_BE)
    {
        CObject *poNext = poCur->m_poInner;
        if (poCur->GetType() != OBJ_SEC && poCur->GetType() != OBJ_VOLDESC)
        {
            ploLayer->Remove(poCur);
            if (poCur->m_pog == NULL)
                polToInsert->AddToHead(poCur);
        }
        poCur = poNext;
    }

    // NOTE: In all of this code, an object 'inside' of another object means closer to the inside
    // of the DVD.  When refering to 'inside a group', it will be explicitly stated.

    // Iterate over each object in the array of objects to insert
    CObject *poToInsert = polToInsert->GetOutside();
    while (poToInsert)
    {
        CObject *poInner = poInsertAt->m_poInner;

        // If the object is a member of a group, then ignore it and let the
        // group handle it atomically.  When the group itself is added, its
        // contained objects will be added at that point.
        while (poToInsert->m_pog)
        {
            poToInsert = polToInsert->GetNextInner();
        }

        // Move the insertion point inward until it's pointing at empty space
        while (true)
        {
            // Calculate how many empty sectors are between the current insertion point
            // and the object immediately inside of it (ie closer to the inside of the dvd).
            if (ploLayer->IsInsideOut())
                dwEmptySectors = poInner->m_dwLSN - (poInsertAt->m_dwLSN + poInsertAt->m_dwBlockSize);
            else
                dwEmptySectors = poInsertAt->m_dwLSN - (poInner->m_dwLSN + poInner->m_dwBlockSize);
            if (dwEmptySectors > 0)
                break;

            poInsertAt = poInsertAt->m_poInner;
            poInner    = poInsertAt->m_poInner;
            if (poInsertAt->GetType() == OBJ_BE)
            {
                // Hit the end of the list (inside of dvd) - no more room!.
                EndProfile(PROFILE_INSERT);
                return false;
            }
        }

        // At this point, m_poInsertAt points at a block of empty space.  Is it *enough* empty
        // space to hold the to-insert object?
        if (poToInsert->m_dwBlockSize <= dwEmptySectors)
        {
            // There's enough space here.  Place the object at the current insertion point.
            polToInsert->Remove(poToInsert);
            ploLayer->InsertInside(poToInsert, poInsertAt);
            if (nLayer == 0)
                poToInsert->m_dwLSN = poInsertAt->m_dwLSN - poToInsert->m_dwBlockSize;
            else
                poToInsert->m_dwLSN = poInsertAt->m_dwLSN + poInsertAt->m_dwBlockSize;

            // Continue with the next object in the 'to insert' list.
            poInsertAt = poToInsert;
            goto next;
        }

        // If the object inside of the current object is a bookend, then there's not enough
        // space for the object!
        if (poInner->GetType() == OBJ_BE)
        {
            // Hit the end of the list.  No need to undo anything.  The caller
            // will handle trying to insert on a different layer (or the scratch
            // window) or warn the user as appropriate
            EndProfile(PROFILE_INSERT);
            return false;
        }

        // Check if there's enough empty space combined between the empty space above poInsertAt
        // and the empty space (if any) between the placeholder above that and the next placeholder.
        // If not, then we can't fit it here, so move on to the next placeholder and try again.
        if (ploLayer->IsInsideOut())
            dwEmptySectors += poInner->m_poInner->m_dwLSN - (poInner->m_dwLSN + poInner->m_dwBlockSize);
        else
            dwEmptySectors += poInner->m_dwLSN - (poInner->m_poInner->m_dwLSN + poInner->m_poInner->m_dwBlockSize);
        if (dwEmptySectors < poToInsert->m_dwBlockSize)
        {
            // Not enough empty space.
            poInsertAt = poInner;

            // *don't* get the next 'to insert' object; repeat the loop with the same one.
            continue;
        }

        // Can't move voldesc, and we're not allowing anything above it. Thus,
        // if at this point the 'inner' object is a volume descriptor, then we
        // can't insert the next object.
        if (poInner->GetType() == OBJ_VOLDESC)
        {
            EndProfile(PROFILE_INSERT);
            return false;
        }

        // Can the security placeholder above the empty space at the current insertion point move
        // down to the insertion point (ie is that a valid location?).  The placeholder itself
        // is passed as well since we need to 'remove' it from the list of placeholders when checking
        // for validity.
        if (CheckValidPlaceholderLSN((CObj_Security*)poInner, poInsertAt->m_dwLSN - poInner->m_dwBlockSize))
            nDistMoveOut = abs(poInsertAt->m_dwLSN - (poInner->m_dwLSN + poInner->m_dwBlockSize));
        else
            nDistMoveOut = INT_MAX;

        // Can the security placeholder be moved up?  Two checks:  (1) there are no other placeholders
        // blocking this placeholder from moving up enough, (2) the position is a valid placeholder
        // position.
        if (!CheckValidPlaceholderLSN((CObj_Security*)poInner, poInsertAt->m_dwLSN - poToInsert->m_dwBlockSize - poInner->m_dwBlockSize))
            nDistMoveIn = INT_MAX;
        else
            nDistMoveIn = abs(poInner->m_dwLSN - (poInsertAt->m_dwLSN - poToInsert->m_dwBlockSize - poInner->m_dwBlockSize));

        // Move the placeholder the minimum valid distance possible
        if (nDistMoveOut == nDistMoveIn && nDistMoveOut == INT_MAX)
        {
            // Can't insert the object at the current position.  Move the current insertion pointer
            // to before the placeholder and try again
            poInsertAt = poInner;
            continue;
        }
        else if (nDistMoveOut < nDistMoveIn)
        {
            // insert the object before the placeholder
            polToInsert->Remove(poToInsert);
            ploLayer->InsertInside(poToInsert, poInner);

            // Set the placeholder's and object's LSNs
            if (nLayer == 0)
            {
                poInner->m_dwLSN    = poInsertAt->m_dwLSN - poInner->m_dwBlockSize;
                poToInsert->m_dwLSN = poInner->m_dwLSN - poToInsert->m_dwBlockSize;
            }
            else
            {
                poInner->m_dwLSN    = poInsertAt->m_dwLSN + poInsertAt->m_dwBlockSize;
                poToInsert->m_dwLSN = poInner->m_dwLSN + poInner->m_dwBlockSize;
            }
            
            // Set current insertion point to before the inserted object
            poInsertAt = poToInsert;
        }
        else
        {
            // Move the placeholder inward

            // Insert the object at the current insertion point
            polToInsert->Remove(poToInsert);
            ploLayer->InsertInside(poToInsert, poInsertAt);

            // Set the placeholder's and object's LSNs
            if (nLayer == 0)
            {
                poInner->m_dwLSN    = poInsertAt->m_dwLSN - poToInsert->m_dwBlockSize - poInner->m_dwBlockSize;
                poToInsert->m_dwLSN = poInsertAt->m_dwLSN - poToInsert->m_dwBlockSize;
            }
            else
            {
                poInner->m_dwLSN    = poInsertAt->m_dwLSN + poInsertAt->m_dwBlockSize + poToInsert->m_dwBlockSize + poInner->m_dwBlockSize;
                poToInsert->m_dwLSN = poInsertAt->m_dwLSN - poInsertAt->m_dwBlockSize;
            }
            
            // Set current insertion point to before the security placeholder
            poInsertAt = poInner;
        }

next:
        // If the newly placed object is a group object, then we need to add all of it's contained
        // objects immediately after the object itself (or before if on layer 1).
        if (poToInsert->GetType() == OBJ_GROUP)
        {
            // We just inserted a group -- we need to also insert all of it's
            // contained objects
            DWORD dwPrevLSN = poToInsert->m_dwLSN;
            CObject *poPrevContained = poToInsert;
            CObject *poContained;
            if (ploLayer->IsInsideOut())
                poContained = ((CObj_Group*)poToInsert)->m_gol.Tail();
            else
                poContained = ((CObj_Group*)poToInsert)->m_gol.Head();
            while (poContained)
            {
                poContained->RemoveFromList();
                poContained->m_dwLSN = dwPrevLSN;
                ploLayer->InsertOutside(poContained, poPrevContained);
                dwPrevLSN += poContained->m_dwBlockSize;
                if (ploLayer->IsInsideOut())
                {
                    poContained = ((CObj_Group*)poToInsert)->m_gol.Prev();
              //      poPrevContained->m_dwLSN = dwPrevLSN;
                }
                else
                {
                    poPrevContained = poContained;
                    poContained = ((CObj_Group*)poToInsert)->m_gol.Next();
                }
            }
        }

        // Get the 'outside'-most object from the to-insert list.
        poToInsert = polToInsert->GetOutside();
    }
    ValidatePlaceholders();
    EndProfile(PROFILE_INSERT);
    return true;
}

#define VALIDLSN_LAYER0_FIRST 89856
#define VALIDLSN_LAYER0_LAST  1646000
#define VALIDLSN_LAYER1_FIRST 1781168
#define VALIDLSN_LAYER1_LAST  3337312
#define NUM_SECTORS 1715632

bool CheckPHError(bool fWarnUser, bool fValid)
{
    if (fValid)
        return false;

    if (fWarnUser)
        MessageBox(NULL, "A placeholder was found in an invalid position.  Please notify Microsoft Xbox tech support immediately.",
                   "Invalid placeholder encountered", MB_ICONEXCLAMATION | MB_OK);
    return true;
}

bool CDVD::ValidatePlaceholders(bool fWarnUser)
{
    CObjNode *ponTemp, *ponCur = m_onlPH.m_ponHead;
    assert(ponCur);

    while (ponCur)
    {
        // verify this guy has the correct updated size hack fix
        if(ponCur->m_pobj->m_dwBlockSize != 4098)
            return false;

        // verify previous same-layer item before is > 132kb away
        ponTemp = ponCur->m_ponPrev;
        while (ponTemp && ponTemp->m_pobj->m_dwLSN / NUM_SECTORS != ponCur->m_pobj->m_dwLSN / NUM_SECTORS)
            ponTemp = ponTemp->m_ponPrev;
        if (ponTemp)
            if (CheckPHError(fWarnUser, ponCur->m_pobj->m_dwLSN - ponTemp->m_pobj->m_dwLSN > 0x21002))
                return false;

        // verify next same-layer item is > 132kb away
        ponTemp = ponCur->m_ponNext;
        while (ponTemp && ponTemp->m_pobj->m_dwLSN / NUM_SECTORS != ponCur->m_pobj->m_dwLSN / NUM_SECTORS)
            ponTemp = ponTemp->m_ponNext;
        if (ponTemp)
            if (CheckPHError(fWarnUser, ponTemp->m_pobj->m_dwLSN - ponCur->m_pobj->m_dwLSN > 0x21002))
                return false;

        // verify previous diff-layer item is > 64kb away
        ponTemp = ponCur->m_ponPrev;
        while (ponTemp && ponTemp->m_pobj->m_dwLSN / NUM_SECTORS == ponCur->m_pobj->m_dwLSN / NUM_SECTORS)
            ponTemp = ponTemp->m_ponPrev;
        if (ponTemp)
        {
            DWORD dwLSNTemp = 2 * 1715632 - ponTemp->m_pobj->m_dwLSN - 0x1002;
            if (CheckPHError(fWarnUser, ponCur->m_pobj->m_dwLSN - dwLSNTemp > 0x11002))
                return false;
        }

        // verify next diff-layer item is > 64kb away
        ponTemp = ponCur->m_ponNext;
        while (ponTemp && ponTemp->m_pobj->m_dwLSN / NUM_SECTORS == ponCur->m_pobj->m_dwLSN / NUM_SECTORS)
            ponTemp = ponTemp->m_ponNext;
        if (ponTemp)
        {
            DWORD dwLSNTemp = 2 * 1715632 - ponTemp->m_pobj->m_dwLSN - 0x1002;
            if (CheckPHError(fWarnUser, dwLSNTemp - ponCur->m_pobj->m_dwLSN > 0x11002))
                return false;
        }

        ponCur = ponCur->m_ponNext;
    }

    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDVD::CheckValidPlaceholderLSN
// Purpose:   Check if the specified placeholder can legally be placed at the
//            specified LSN
// Arguments: 
// Return:    'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CDVD::CheckValidPlaceholderLSN(CObj_Security *posPH, DWORD dwLSN)
{
    // There are a number of rules that must be obeyed in order for an LSN to
    // be valid for placeholder placement:
    //  1. The first possible layer 0 LSN start is 89856
    //  2. The last  possible layer 0 LSN start is 1646000
    //  3. The first possible layer 1 LSN start is 1781168
    //  4. The last  possible layer 1 LSN start is 3337312
    //  5. The end of a Placeholder cannot be any closer than 131072 sectors
    //     from the start of the next placeholder on the same layer.
    //  6. Placeholders on different layers must be separated by a minimum of
    //     65536 sectors from the one's complement of each placeholder's
    //     starting and ending addresses.
    StartProfile(PROFILE_CHECKVALIDPLACEHOLDERLSN);

    bool fValid = false;
    CObjNode *ponPH, *ponBase, *ponCur;
    CObject *poCur;
    DWORD dwLSNThis;

    poCur = m_onlPH.Head();
    if (!poCur)
    {
        EndProfile(PROFILE_CHECKVALIDPLACEHOLDERLSN);
        return false;
    }

    do { DebugOutput("%d  (%d)\r\n", poCur->m_dwLSN, poCur->m_dwLSN  >= 1715632 ? 1715632*2-poCur->m_dwLSN : 0); } while (poCur = m_onlPH.Next());
        
    // Verify that the LSN is within the valid ranges (rules 1-4 above)
    if (dwLSN < VALIDLSN_LAYER0_FIRST || dwLSN > VALIDLSN_LAYER1_LAST ||
        (dwLSN > VALIDLSN_LAYER0_LAST && dwLSN < VALIDLSN_LAYER1_FIRST))
    {
        EndProfile(PROFILE_CHECKVALIDPLACEHOLDERLSN);
        return false;
    }
    
    // Pointers to the placeholders are stored in sorted LSN order (relative
    // to start of layer!).  Find the specified placeholder and remove it from
    // the list in preparation for checking rules 5 and 6.
    ponPH = m_onlPH.GetObjectNode(posPH);
    assert(ponPH);

    // Track which element the removed placeholder was following in case we
    // need to reinsert
    ponBase = ponPH->m_ponPrev;

    // Remove the placeholder from the placeholders list
    m_onlPH.Remove(posPH);
    
    // Now that the placeholder has been removed, find the new point at which
    // the placeholder will be inserted (ie where dwLSN fits in).
    DWORD dwLSN1 = (dwLSN > 1715632) ? 1715632*2 - dwLSN : dwLSN;
    ponCur = m_onlPH.m_ponHead;
    while (ponCur) {
        DWORD dwLSN2 = (ponCur->m_pobj->m_dwLSN > 1715632) ? 
               1715632 * 2 - ponCur->m_pobj->m_dwLSN : ponCur->m_pobj->m_dwLSN;
        if (dwLSN2 > dwLSN1)
            break;
        ponCur = ponCur->m_ponNext;
    }

    // At this point, ponCur points at the placeholder node with the next highest
    // LSN.  posPH will fit in before it (if valid).  If ponCur is NULL, it means
    // that posPH has the highest (layer-relative) LSN.

    // Find the previous and next placeholders on both the same and opposite layer.
    CObjNode *ponPrevSame = ponCur, *ponPrevDiff = ponCur,
             *ponNextSame = ponCur, *ponNextDiff = ponCur;
    if (!ponCur) {
        ponPrevSame = ponPrevDiff = m_onlPH.m_ponTail;
        ponNextSame = ponNextDiff = NULL;
    } else {
        bool fFoundPrevSame = false, fFoundPrevDiff = false,
             fFoundNextSame = false, fFoundNextDiff = false;
        do {
            if (!fFoundPrevSame) {
                ponPrevSame = ponPrevSame->m_ponPrev;
                if (!ponPrevSame || ponPrevSame->m_pobj->m_dwLSN/NUM_SECTORS ==
                                    dwLSN/NUM_SECTORS)
                    fFoundPrevSame = true;
            }
            if (!fFoundPrevDiff) {
                ponPrevDiff = ponPrevDiff->m_ponPrev;
                if (!ponPrevDiff || ponPrevDiff->m_pobj->m_dwLSN/NUM_SECTORS !=
                                    dwLSN/NUM_SECTORS)
                    fFoundPrevDiff = true;
            }
            if (!fFoundNextSame) {
                if (!ponNextSame || ponNextSame->m_pobj->m_dwLSN/NUM_SECTORS ==
                                    dwLSN/NUM_SECTORS)
                    fFoundNextSame = true;
                else
                    ponNextSame = ponNextSame->m_ponNext;
            }
            if (!fFoundNextDiff) {
                if (!ponNextDiff || ponNextDiff->m_pobj->m_dwLSN/NUM_SECTORS !=
                                    dwLSN/NUM_SECTORS)
                    fFoundNextDiff = true;
                else
                    ponNextDiff = ponNextDiff->m_ponNext;
            }
        } while(!(fFoundPrevSame && fFoundPrevDiff && fFoundNextSame && fFoundNextDiff));
    }

    // Check rule 5: same-layer placeholders must be 131072 or more sectors apart
    if (ponNextSame)
        if ((int)(ponNextSame->m_pobj->m_dwLSN - (dwLSN + ponCur->m_pobj->m_dwBlockSize)) < 131072)
            goto done;
    if (ponPrevSame)
        if ((int)(dwLSN - (ponPrevSame->m_pobj->m_dwLSN + ponPrevSame->m_pobj->m_dwBlockSize)) < 131072)
            goto done;

    //  Check rule 6. Placeholders on different layers must be separated by a
    //                minimum of 65536 sectors from the one's complement of
    //                each placeholder's starting and ending addresses.

    // Convert the to-be-inserted PH's LSN to the other PH's numeric space
    dwLSNThis = 2 * 1715632 - dwLSN - 0x1002;
    if (ponNextDiff && abs(dwLSNThis - ponNextDiff->m_pobj->m_dwLSN) < 0x11002)
        goto done;
    if (ponPrevDiff && abs(dwLSNThis - ponPrevDiff->m_pobj->m_dwLSN) < 0x11002)
        goto done;

    // If here, then we passed all rules!
    fValid = true;
    
done:

    if (fValid) {
        // Insert at insertion point
        if (ponCur)
            m_onlPH.AddBefore(posPH, ponCur->m_pobj);
        else
            m_onlPH.Add(posPH);
    } else {
        // restore original point
        if (!ponBase) {
            ponBase = m_onlPH.m_ponHead;
            m_onlPH.AddBefore(posPH, ponBase->m_pobj);
        }
        else
            m_onlPH.AddAfter(posPH, ponBase->m_pobj);
    }

    ValidatePlaceholders();

    EndProfile(PROFILE_CHECKVALIDPLACEHOLDERLSN);
    return fValid;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDVD::RefreshPlaceholders
// Purpose:   
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CDVD::RefreshPlaceholders(bool fValidate)
{
    // refresh the placeholder list.  This must be called after open, new, or 
    // undo/redo operations (ie any time a placeholder could have been moved)
    DWORD dwLSNCur, dwLSNCur2;

    StartProfile(PROFILE_REFRESHPLACEHOLDERS);    
    m_onlPH.RemoveAll();

    // find all placeholders, add them to the list of placeholders in sorted
    // lsn order (relative to start of layer)
    for (int i = 0; i <= 1; i++)
    {
        CObjList *polLayer = m_rgpolLayer[i];
        CObject *poCur = polLayer->GetInside();
        while (poCur)
        {
            // If the object is a file-system object (folder or file), check
            // to see if it resides in the passed-in folder.
            if (poCur->GetType() == OBJ_SEC)
            {
                dwLSNCur = (poCur->m_dwLSN > 1715632) ? 1715632*2-poCur->m_dwLSN : poCur->m_dwLSN;
                // Find insertion point
                CObjNode *ponCur = m_onlPH.m_ponHead;
                while (ponCur) {
                    dwLSNCur2 = (ponCur->m_pobj->m_dwLSN > 1715632) ? 1715632*2-ponCur->m_pobj->m_dwLSN : ponCur->m_pobj->m_dwLSN;
                    if (dwLSNCur2 > dwLSNCur)
                        break;
                    ponCur = ponCur->m_ponNext;
                }
                if (ponCur)
                    m_onlPH.AddBefore(poCur, ponCur->m_pobj);
                else
                    m_onlPH.Add(poCur);
            }
            poCur = polLayer->GetNextOuter();
        }
    }
    if (fValidate)
        ValidatePlaceholders();

#ifdef _DEBUG1
    m_onlPH.Head();
    m_onlPH.Next();
    CheckValidPlaceholderLSN((CObj_Security*)m_onlPH.Next(), 48000+4100+131072);
#endif
    EndProfile(PROFILE_REFRESHPLACEHOLDERS);    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\CDVD_DirEntry.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      cdvd_direntry.cpp
// Contents:  Directory Entry-related functionality for the CDVD class
// Revisions: 6-Jul-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"
#include <xboxverp.h>

extern DWORD BlockSize(ULONGLONG ullSize);

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Define the upper case table used for file name comparisons.  This matches the
// case table used by the file system.
//
const UCHAR GdfUpperCaseTable[256] = {
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
    0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,
    0x60,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
    0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x7b,0x7c,0x7d,0x7e,0x7f,
    0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,
    0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,
    0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,
    0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
    0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,
    0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,
    0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,
    0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xf7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0x3f
};

int GdfCompareFileNames(LPCSTR pszFileName1,  LPCSTR pszFileName2)
{
    LONG n1, n2;
    LPCSTR Limit;
    UCHAR c1, c2;

    //
    // The following code is adapted from RtlCompareString in ntos\rtl\string.c.
    //

    n1 = (LONG)lstrlen(pszFileName1);
    n2 = (LONG)lstrlen(pszFileName2);
    Limit = pszFileName1 + (n1 <= n2 ? n1 : n2);
    while (pszFileName1 < Limit) {
        c1 = *pszFileName1++;
        c2 = *pszFileName2++;
        if (c1 != c2) {
            c1 = GdfUpperCaseTable[c1];
            c2 = GdfUpperCaseTable[c2];
            if (c1 != c2) {
                return (LONG)c1 - (LONG)c2;
            }
        }
    }
    return n1 - n2;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CompareObjectNames
// Purpose:   Comparison function for qsort.
// Arguments: pvElem1       -- The first element to compare.
//            pvElem2       -- The second element to compare.
// Return:    <0 if (elem1<elem2), 0 if (elem1==elem2), >0 if (elem1>elem2)
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
int _cdecl CompareObjectNames(const void *pvElem1, const void *pvElem2)
{
    // pvElem1 and pvElem2 are passed in as pointers to array elements.  Do
    // some wacky casting to get the actual object pointers.
    CObject *po1 = ((CObject*)*(DWORD*)pvElem1);
    CObject *po2 = ((CObject*)*(DWORD*)pvElem2);

    // Do a string comparison on the names of the objects.
    return (GdfCompareFileNames(po1->m_szName, po2->m_szName));
}
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDVD::PopulateDirEntries
// Purpose:   Populate pof's list of GDF_MAX_DIRECTORY_ENTRY structures.
// Arguments: pof           -- The folder whose items are to be sorted.
//            rgpoSorted     -- The list of object pointers, already sorted.
//            piIndex       -- Current index of GDF_MAX_DIRECTORY_ENTRY to
//                             populate.
//            iMin, iMax    -- Sorted parameters.
// Return:    'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CDVD::PopulateDirEntries(CObj_Folder *pof, CObject *rgpoSorted[],
                              int *piIndex, int iMin, int iMax)
{
    // Check if we've exhausted this branch of the search tree
    if (iMax < iMin)
        return false;

    StartProfile(PROFILE_POPULATEDIRENTRIES);
    // Determine the object midway between the two endpoints.
    int iObject = iMin + (iMax - iMin) / 2;

    // Keep a pointer to the object that we're creating a directory entry for.
    CObject *poToInsert = rgpoSorted[iObject];

    // Keep a pointer to the particular directory entry we're populating.
    GDF_MAX_DIRECTORY_ENTRY *pgdfde = &pof->m_prgGDFMDE[*piIndex];
    
    // Populate the directory entry

    // The first sector member points at the Logical Sector Number of the
    // file-system object (ie relative to the start of ximage0.dat)
    pgdfde->FirstSector = poToInsert->m_dwLSN;
    pgdfde->FileSize = poToInsert->m_dwBlockSize * 2048;
    
    // If the object being 'inserted into' pof's list of direntries is a file,
    // then set its size in the direntry.  If it's a folder, though, its size
    // may not have been calculated yet -- as a result, we can't store it yet.
    // Instead, we store the index of the appropriate direntry in the object
    // (we already store a pointer to poInsert's parent folder object).
    if (poToInsert->GetType() == OBJ_FILE)
    {
        // Note that the file size member can only support files up to 4GB in size.
        // This is a limitation of gdfs (see gdformat.h), and means we don't can
        // ignore m_uliSize.HighPart;
        pgdfde->FileSize = poToInsert->m_uliSize.LowPart;
    }
    else
    {
        poToInsert->m_iFolderDirEntry = *piIndex;
    }

    // Set the file's attributes.  The only attribute that's examined by gdfx
    // is FILE_ATTRIBUTE_DIRECTORY (see gdformat.h).
    if (poToInsert->GetType() == OBJ_FOLDER)
        pgdfde->FileAttributes = FILE_ATTRIBUTE_DIRECTORY;
    else
        pgdfde->FileAttributes = FILE_ATTRIBUTE_NORMAL;

    // Set the length of the file's name
    pgdfde->FileNameLength = strlen(poToInsert->m_szName);

    // Note that the maximum length of a filename is 255 bytes, as compared
    // to Win32's MAX_PATH value of 1024.  If the user tried to insert a file
    // with too long of a name, it should have been caught elsewhere.  However,
    // we assert here "just in case".
    assert(strlen(poToInsert->m_szName) < 256);

    // Copy the name of the object into the directory entry.  We don't want
    // to NULL terminate, so we use memcpy instead of strcpy
    memcpy((char*)&pgdfde->FileName[0], poToInsert->m_szName,
           pgdfde->FileNameLength);

    // The index on the left will point at the 'next' entry that's created.
    pgdfde->LeftEntryIndex  = ++(*piIndex);

    // Recursively handle the entries on the left
    if (!PopulateDirEntries(pof, rgpoSorted, piIndex, iMin, iObject-1))
    {
        // If there weren't any more objects 'before' this one, then mark the
        // left index as zero to indicate that fact to the OS.
        pgdfde->LeftEntryIndex = 0;
    }

    // The index on the right will be the one after all the left children have
    // been handled (they have already updated piindex accordingly, so just 
    // set to whatever value was passed back up the recursion tree).
    pgdfde->RightEntryIndex  = (USHORT)*piIndex;

    // Recursively handle the entries on the right.
    if (!PopulateDirEntries(pof, rgpoSorted, piIndex, iObject + 1, iMax))
    {
        // If there weren't any more objects 'after' this one, then mark the
        // right index as zero to indicate that fact to the OS.
        pgdfde->RightEntryIndex = 0;
    }
    EndProfile(PROFILE_POPULATEDIRENTRIES);
    return true;
}

char g_rgszLayerResizedFolder[500][MAX_PATH];
int  g_iCurResizeLayer;

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDVD::RefreshFolderDirectoryEntry
// Purpose:   Refresh the list of directory entries pertaining to the specified
//            folder's contents.
// Arguments: pof       -- The folder whose directory entries are to be
//                         refreshed.
// Return:    'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CDVD::RefreshFolderDirectoryEntry(CObj_Folder *pof, bool fBuildForEmulation)
{
    // 1. Determine the list of objects on the DVD that exist in the folder.
    // 2. Sort the list.
    // 3. Generate the list of GDF_DIRECTORY_ENTRY structures cooresponding to
    //    the folder's list of contained objects.

    static int rgnPadding[] = {0, 3, 2, 1};

    // onl      -- The list of objects that exist in the folder
    CObjNodeList onl;

    StartProfile(PROFILE_REFRESHFOLDERDIRECTORYENTRY);

    // We need to track which folder is the root folder, so check if this one is it.
    if (!lstrcmpi(pof->m_szFullFileName, g_szRootFolderName))
        m_povdRoot = pof;

    // For each layer...
    for (int nLayer = 0; nLayer <= 1; nLayer++)
    {
        CObjList *polLayer = m_rgpolLayer[nLayer];

        // Iterate over all objects in the layer.
        // Note: Don't use 'GetInside' or 'GetNextOuter' since the
        // RefreshDirectoryEntries function is already using them, and they
        // aren't reentrant.
        CObject *poCur = polLayer->m_poHead;
        while (poCur)
        {
            // If the object is a file-system object (folder or file), check
            // to see if it resides in the passed-in folder.
            if (poCur != pof && (poCur->GetType() == OBJ_FOLDER || poCur->GetType() == OBJ_FILE))
            {
                // Does the folder or file reside in 'pof'?
                if (!lstrcmpi(poCur->m_szFolder, pof->m_szFullFileName))
                {
                    // Don't add the object if it is in the scratch window
                    if (poCur->m_pol != NULL)
                    {
                        // Add it to the temporary list of objects residing in 'pof'
                        onl.Add(poCur);
                    }
                }
            }

            // Move to the next entry in the current layer
            if (nLayer == 0) 
                poCur = poCur->m_poOuter;
            else
                poCur = poCur->m_poInner;
        }
    }

    // 'onl' now contains the list of objects that reside in 'pof'.
    int cItems = onl.NumItems();

    // Move the list into an array for easier indexing.
    CObject **rgpoSorted = new CObject*[cItems];
    if (!rgpoSorted)
        FatalError(E_OUTOFMEMORY);
    onl.PopulateArray(rgpoSorted, onl.NumItems());

    // Sort the list using quicksort.
    qsort((void*)rgpoSorted, cItems, sizeof(CObject*), &CompareObjectNames);

    // Create the list of GDF_DIRECTORY_ENTRY structures for 'pof'

    // Delete the previous list, if one was previously created.
    if (pof->m_prgGDFMDE)
        delete[] pof->m_prgGDFMDE;
    
    // Allocate space for the list of directory entries
    pof->m_prgGDFMDE = new GDF_MAX_DIRECTORY_ENTRY[cItems];
    if (pof->m_prgGDFMDE == NULL)
        FatalError(E_OUTOFMEMORY);

    // Track how many directory entries are in the folder.
    pof->m_cDirEntries = cItems;

    // Populate pof's GDF_MAX_DIRECTORY_ENTRY structures with everything except
    // the final index values (which can't be calculated until all the other
    // information is known for all of the objects).
    int iObject = 0;
    PopulateDirEntries(pof, rgpoSorted, &iObject, 0, cItems-1);

    // We no longer need the array of objects
    delete[] rgpoSorted;

    // We now calculate the true LeftentryIndex and RightEntryIndex values for the
    // GDF_MAX_DIRECTORY_ENTRY structures.  At this point they simply contain the array
    // index of the appropriate entry.  Instead they need to contain the byte
    // offset (div 4) of the entry from the first entry.

    // first, a pass to determine the offset from the start of the block for each 
    // entry.
    int nOffsetFromStart = 0;
    bool fTooManyFiles = false;
    for (int i = 0; i < cItems; i++)
    {
        // Calculate the size of the entry we're about to add.
        int nEntrySize = sizeof(GDF_DIRECTORY_ENTRY) +
                         pof->m_prgGDFMDE[i].FileNameLength - 1;

        // We need to be sure that the entry ends on a DWORD-boundary since the
        // index values are shifted up by 4.
        nEntrySize += rgnPadding[nEntrySize % 4];

        // A single directory entry can't be bigger than one sector
        assert(nEntrySize <= 2048);

        // If the start and end points are on different sectors, then we need
        // to move the offset forward to the start of the next sector.
        if (nOffsetFromStart / 2048 != (nOffsetFromStart + nEntrySize) / 2048)
        {
            // Yep, we cross a boundary.  Move forward until we're pointing at 
            // the next sector
            nOffsetFromStart += 2048 - (nOffsetFromStart % 2048);
        }

        if (nOffsetFromStart >= 0x40000)
            fTooManyFiles = true;

        // Store where the current entry starts (relative to the start of the
        // folder's block of directory entries).
        pof->m_prgGDFMDE[i].OffsetFromStart = (USHORT)(nOffsetFromStart / 4);

        // Update the offset for the next entry.
        nOffsetFromStart += nEntrySize;
    }

    // Next, perform a second pass to set the actual index values, now that
    // we know the offsets of each entry.
    for (i = 0; i < cItems; i++)
    {
        GDF_MAX_DIRECTORY_ENTRY *pgdfmdeLeft  = &pof->m_prgGDFMDE[pof->m_prgGDFMDE[i].LeftEntryIndex];
        GDF_MAX_DIRECTORY_ENTRY *pgdfmdeRight = &pof->m_prgGDFMDE[pof->m_prgGDFMDE[i].RightEntryIndex];

        // As per gdformat.h, the indices are stored (div 4).
        pof->m_prgGDFMDE[i].LeftEntryIndex  = pgdfmdeLeft->OffsetFromStart;
        pof->m_prgGDFMDE[i].RightEntryIndex = pgdfmdeRight->OffsetFromStart;
    }

    // Also track the new size of the folder's block of directory entries.
    DWORD dwNewBlockSize = BlockSize(pof->m_uliSize.LowPart);

    // If the size of the folder's entries has shrunk, then we simply maintain
    // the original size so that the extra space is padded.  However, if the
    // size of the folder's entries has grown, then we have to do a relayout.
    // In this case, continue on, track the farthest out object on the current
    // layer so that we only relayout once per layer.
    if (dwNewBlockSize > pof->m_dwBlockSize)
    {
        // Size grew.  Track the object
        strcpy(g_rgszLayerResizedFolder[g_iCurResizeLayer++], pof->m_szFullFileName);
        pof->m_dwBlockSize = dwNewBlockSize;
    }
    
    // Always update the size -- the code above is only concerned with when the
    // block size changes.
    pof->m_uliSize.QuadPart = nOffsetFromStart;

    // Warn if there are more than 64k worth of directory entries in this folder
    if (fTooManyFiles && !m_fWarnedTooManyFiles)
    {
        MessageBox(NULL, "WARNING: Your game disc layout contains too many "
                         "files in a single directory.  Your disc image\r\n"
                         "may not function correctly.",
                         "Too Many Files in Directory",
                   MB_ICONWARNING | MB_APPLMODAL | MB_OK);

        // Don't warn on every folder, just the first one.
        m_fWarnedTooManyFiles = true;
    }
    EndProfile(PROFILE_REFRESHFOLDERDIRECTORYENTRY);
    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDVD::RefreshDirectoryEntries
// Purpose:   Called after the contents of one or more folders have been
//            modified.  Determines the list of GDF_DIRECTORY_ENTRY structures
//            that coorespond to the folder(s)'s contained files.  Also
//            recalculates the volume descriptor (since the location of the
//            root directory may have changed).
// Arguments: None
// Return:    'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CDVD::RefreshDirectoryEntries(CWorkspace *pws, bool fBuildForEmulation)
{
    SYSTEMTIME st;
    FILETIME   ft, ftLocal;
    bool fWarnRelayout = false, fErrRelayout = false;
    StartProfile(PROFILE_REFRESHDIRECTORYENTRIES);

start:

    // We'll want to track which object is the volume descriptor so that we
    // can update it accordingly afterwards.
    CObj_VolDesc *povd = NULL;

    m_povdRoot = NULL;
    strcpy(g_rgszLayerResizedFolder[0], "");
    strcpy(g_rgszLayerResizedFolder[1], "");

    g_iCurResizeLayer = 0;

    // Iterate over each folder on the DVD and refresh its directory entry list
    for (int nLayer = 0; nLayer <= 1; nLayer++)
    {
        // Start at the inside of the disc, and work outwards.
        CObject *poCur = m_rgpolLayer[nLayer]->GetInside();
        while (poCur)
        {
            // If the object is a folder, then refresh it's directory entries
            if (poCur->GetType() == OBJ_FOLDER)
                if (!RefreshFolderDirectoryEntry((CObj_Folder*)poCur, fBuildForEmulation))
                {
                    EndProfile(PROFILE_REFRESHDIRECTORYENTRIES);
                    return false;
                }
                
            // Track where the volume descriptor is; we'll need to populate it
            // once we're done (when we know where the root folder is)
            if (poCur->GetType() == OBJ_VOLDESC)
                povd = (CObj_VolDesc*)poCur;

            // Get the next outermost object on the disc.
            poCur = m_rgpolLayer[nLayer]->GetNextOuter();
        }
    }

    // Iterate over each folder on the DVD again, this time set the actual size
    // of the entries.  This is necessary as a second pass because we didn't know
    // the size of any folders that were added if they were handled later on in
    // the loop above.  Now, however, we know how big each folder is, so we
    // can set the size in any reference to it in another folder's direntry.
    for (nLayer = 0; nLayer <= 1; nLayer++)
    {
        // For each layer...
        CObjList *polLayer = m_rgpolLayer[nLayer];

        // Start at the inside of the disc, and work outwards.
        CObject *poCur = polLayer->GetInside();
        while (poCur)
        {
            // If the object is a folder, then store its size in it's parent
            // folder's direntry (the info for which we stored during the first
            // pass earlier).
            if (poCur->GetType() == OBJ_FOLDER && poCur->m_pof)
            {
                assert(poCur->m_iFolderDirEntry != -1);
                GDF_MAX_DIRECTORY_ENTRY *pgdfde = &poCur->m_pof->m_prgGDFMDE[poCur->m_iFolderDirEntry];
                assert(pgdfde);

                pgdfde->FileSize = BlockSize(poCur->m_uliSize.LowPart) * 2048;
            }

            // Get the next outermost object on the disc.
            poCur = polLayer->GetNextOuter();
        }
    }

    bool fRepeat = false;
    
    for (int i = 0; i < g_iCurResizeLayer; i++)
    {
        CObjList *ploLayer;
        CObj_Folder *pof = (CObj_Folder*)m_rgpolLayer[0]->FindObjectByFullFileName(g_rgszLayerResizedFolder[i]);
        if (pof)
            ploLayer = m_rgpolLayer[0];
        else
        {
            pof = (CObj_Folder*)m_rgpolLayer[1]->FindObjectByFullFileName(g_rgszLayerResizedFolder[i]);
            ploLayer = m_rgpolLayer[1];
        }
        assert(pof);

        // Now that we know how big all of the folders' directories are, check to 
        // see if any of them grew bigger than they were before.  We have already
        // stored pointers to the farthest out changed-size folder on each layer;
        // remove and reinsert them.  This will cause the desired relayout.
        if (pof != NULL)
        {
            // We resized at least one folder on the layer.  pof points at
            // the farthest out resized folder -- Remove it and reinsert it
            // to force reinsertion of it and everything above it.

            // First back everything up -- if the new-sized folder can't be
            // inserted back into the layer, then we want to restore everything
            // (since the insertion would have cancelled out part way through,
            // leaving everything in an unknown state), and then just drop the
            // new-sized folder into the scratch window.
            pws->QueueSnapspot();

            // We'll want to insert the folder back at it's original position,
            // so track that now.
            CObject *poInsertAt = pof->m_poInner;

            // Remove the folder from its list in preparation for re-insertion
            pof->RemoveFromList();

            // Reinsert the folder back into the list at its original position.
            if (!Insert(ploLayer, pof, poInsertAt))
            {
                // Failed to reinsert it!  Move the folder object to the
                // scratch window.

                // First, restore the world to the state before the insert.
                pws->DequeueSnapspot();

                // We need to 're-find' the folder since the Dequeue created
                // a whole new set of objects (thus invalidating our old pof)
                pof = (CObj_Folder*)m_rgpolLayer[0]->FindObjectByFullFileName(g_rgszLayerResizedFolder[i]);
                if (!pof)
                    pof = (CObj_Folder*)m_rgpolLayer[1]->FindObjectByFullFileName(g_rgszLayerResizedFolder[i]);
        
                assert(pof);
                
                // We need to re-remove the folder from the list (since the
                // dequeue placed it back in there)
                pof->RemoveFromList();

                // If this is the initial directory refresh then insert it into
                // layer 1; otherwise, into the scratch
                if (!fBuildForEmulation)
                {
                    if (!Insert(m_rgpolLayer[1], pof, NULL))
                        pws->m_pwindow->m_pscratch->AddObject(pof);
                }
                else
                {
                    // Add the folder to the scratch window
                    pws->m_pwindow->m_pscratch->AddObject(pof);

                    // Mark that we're going to need to warn the user of this
                    // situation.
                    fErrRelayout = true;
                }
            }
            else
            {
                // Succeeded on reinserting.  Track that we should warn the user
                // when we're done.
                fWarnRelayout = true;
            }
            
            // We need to update ALL folders'  direntries since their files may
            // have changed LSN and/or FileSize
            fRepeat = true;
        }
    }
    if (fRepeat)
        goto start;

    if (fBuildForEmulation)
    {
        if (fErrRelayout)
        {
            // Inform the user of the error.
            MessageBoxResource(pws->m_pwindow->m_hwnd, IDS_ERR_DIRGROW2_TEXT, IDS_ERR_DIRGROW2_CAPTION, MB_ICONEXCLAMATION | MB_APPLMODAL | MB_OK);
            pws->SetModified();
            pws->UpdateWindowCaption();
        }
        else if (fWarnRelayout)
        {
            MessageBoxResource(pws->m_pwindow->m_hwnd, IDS_ERR_DIRGROW_TEXT, IDS_ERR_DIRGROW_CAPTION, MB_ICONWARNING | MB_APPLMODAL | MB_OK);
            pws->SetModified();
            pws->UpdateWindowCaption();
        }
    }

    CompactLayer(0);
    CompactLayer(1);
    pws->UpdateViews();

    // Refresh the volume descriptor
    
    // A volume descriptor and root directory must have been found.
    assert(povd);
    assert(m_povdRoot);

    // Create the volume descriptor time stamp
    GetSystemTime(&st);
    
    // Convert the system time to file time, and then the file time to UTC file
    // time (as required per gdformat.h).
    SystemTimeToFileTime(&st, &ft);
    LocalFileTimeToFileTime(&ft, &ftLocal);

    // Update the contents of the volume descriptor.

    // Write out the head and tail signatures
    memcpy(povd->m_gdfvd.HeadSignature, GDF_VOLUME_DESCRIPTOR_SIGNATURE,
           GDF_VOLUME_DESCRIPTOR_SIGNATURE_LENGTH);
    memcpy(povd->m_gdfvd.TailSignature, GDF_VOLUME_DESCRIPTOR_SIGNATURE,
           GDF_VOLUME_DESCRIPTOR_SIGNATURE_LENGTH);

    // Write out the Logical Sector Number of the root directory.
    povd->m_gdfvd.RootDirectoryFirstSector = m_povdRoot->m_dwLSN;

    // Write out the size of the root directory's list of directory entries.
    povd->m_gdfvd.RootDirectoryFileSize = m_povdRoot->m_uliSize.LowPart;

    // Write out the volume time stamp.
    memcpy(&povd->m_gdfvd.TimeStamp.QuadPart, &ftLocal, sizeof(ftLocal));

    // The remaining bytes of the sector must be filled with zeroes.
    memset(&povd->m_gdfvd.Reserved, 0, sizeof(povd->m_gdfvd.Reserved));

    // Add version stamp information to the sector following the volume desc.
    memset(&povd->m_verinfo, 0, sizeof(povd->m_verinfo));

    // Add the signature
    strcpy((char*)povd->m_verinfo.rgbySig, VERSION_SIG);
    
    // Set the xblayout version stamp
    int nMajor, nMinor, nBuild, nQFE;
    sscanf(VER_PRODUCTVERSION_STR, "%d.%d.%d.%d", &nMajor, &nMinor, &nBuild,
                                                  &nQFE);
    *(WORD*)(&povd->m_verinfo.rgbyLayoutVersion[0]) = (WORD)nMajor;
    *(WORD*)(&povd->m_verinfo.rgbyLayoutVersion[2]) = (WORD)nMinor;
    *(WORD*)(&povd->m_verinfo.rgbyLayoutVersion[4]) = (WORD)nBuild;
    *(WORD*)(&povd->m_verinfo.rgbyLayoutVersion[6]) = (WORD)nQFE;

    // xbPremaster will handle storing it's version stamp...
    EndProfile(PROFILE_REFRESHDIRECTORYENTRIES);
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\CListview.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      clistview.cpp
// Contents:  
// Revisions: 14-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"
#include <zmouse.h>

// Default column widths
int gs_rgnDefColWidth[NUM_COLUMNS] = {125, 175, 80, 125};


extern DWORD BlockSize(ULONGLONG uliSize);

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ListViewWndProc
// Purpose:   
// Arguments: hwnd              -- The handle to the window that the message is intended for.
//            uMsg              -- The message being reported.
//            wparam            -- Parameter 1 (message-specific)
//            lparam            -- Parameter 2 (message-specific)
// Return:    Result of the message processing - depends on the message sent.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL CALLBACK ListViewWndProc(HWND hwnd, UINT uMsg, WPARAM wparam, LPARAM lparam) 
{
    // Determine which CListView this message is intended for, and call it instead
    CListView *plv = (CListView*)GetWindowLong(hwnd, GWL_USERDATA);
    return plv->WndProc(uMsg, wparam, lparam);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::WndProc
// Purpose:   
// Arguments: 
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL CListView::WndProc(UINT uMsg, WPARAM wparam, LPARAM lparam)
{
    NMLISTVIEW   *pnmlv = (NMLISTVIEW*)lparam;

    switch(uMsg)
    {
    case WM_LBUTTONUP:
        // This message ONLY gets sent to us if we're in a dragging state or
        // the user double clicks
        if (m_fDragging)
        {
            POINT pt = {(short)(lparam & 0xffff), (short)(lparam >> 16)};
            EndDrag(pt);
        }
        return 1;

    case WM_LBUTTONDOWN:
        ::SetFocus(m_hwnd);
        break;

    case WM_TIMER:
        if (m_fDragging)
        {
            // User is in the dragging state -- check if they want to scroll
            CheckDragScroll();
        }
        return 1;
        
//    case WM_MOUSEWHEEL:
//    case WM_VSCROLL:
//        return 0;
        
    case WM_MOUSEMOVE:
        m_dwMouseX = LOWORD(lparam); 
        m_dwMouseY = HIWORD(lparam);
        if (!m_fDragging)
            SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW)));
        else
        {
            POINT pt = {(short)(lparam & 0xffff), (short)(lparam >> 16)};
            UpdateDrag(pt);
        }
        break;
    }
    return CallWindowProc(m_wndprocOld, m_hwnd, uMsg, wparam, lparam);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::SetFocus
// Purpose:   
// Arguments: 
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CListView::SetFocus(bool fHaveFocus)
{
    m_fHaveFocus = fHaveFocus;
    if (!m_fHaveFocus)
    {
        // Remove the input focus rect
        int iItem = ListView_GetNextItem(m_hwnd, -1, LVNI_FOCUSED);
        if (iItem != -1)
            ListView_SetItemState(m_hwnd, iItem, 0, LVIS_FOCUSED);
    }

    InvalidateRect(m_hwnd, NULL, TRUE);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::Init
// Purpose:   
// Arguments: 
// Return:    'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CListView::Init(CWindow *pwindow, bool fInsideOut, bool fDisplayLSNs)
{
	LV_COLUMN lvcol;
    int rgnColSizes[NUM_COLUMNS];

    m_fModified = false;
    
    // Track which window we're connected to.
    m_pwindow = pwindow;

    // Create our Win32 listview control
	m_hwnd = CreateWindow(WC_LISTVIEW, "", WS_BORDER | WS_VISIBLE | WS_CHILD | LVS_REPORT |
                          LVS_SHOWSELALWAYS | LVS_NOSORTHEADER | LVS_OWNERDRAWFIXED,
                          0, 0, 0, 0, pwindow->m_hwnd, (HMENU)this, pwindow->m_hinst, NULL);
    if (!m_hwnd)
        return false;

    m_fInsideOut = fInsideOut;
    m_fSelecting = false;
    // Disable grid lines (we draw our own)
    ListView_SetExtendedListViewStyleEx(m_hwnd, LVS_EX_GRIDLINES, 0);

    m_iPrevBarEntry = -1;

    // Clear out the cursor since we'll be setting it ourselves (check MSDN for
    // info on why this is necessary).
    SetClassLong(m_hwnd, GCL_HCURSOR, NULL);

    // Set the cursor to the default 'arrow' cursor
    SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW)));

    // Add the columns to the listview

    // Load the column name strings
    m_nColumns = 3;
    LoadString(pwindow->m_hinst, IDS_COLUMN_NAME,   m_rgszColumnNames[0], MAX_PATH);
    LoadString(pwindow->m_hinst, IDS_COLUMN_FOLDER, m_rgszColumnNames[1], MAX_PATH);
    LoadString(pwindow->m_hinst, IDS_COLUMN_SIZE,   m_rgszColumnNames[2], MAX_PATH);
    if (fDisplayLSNs)
    {
        LoadString(pwindow->m_hinst, IDS_COLUMN_LSN, m_rgszColumnNames[3], MAX_PATH);
        m_nColumns++;
    }

    // Get the column sizes
    GetColumnSizes(rgnColSizes);

    m_fSelectedObjList = false;
    m_fSelectingAll = false;

    // Set up the mask so that we set the width, text, and subitem
	lvcol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;

    // Add each column
    int nColumns = fDisplayLSNs ? NUM_COLUMNS : NUM_COLUMNS - 1;
	for (int i = 0; i < nColumns; i++)
	{
		lvcol.cx       = rgnColSizes[i];
		lvcol.iSubItem = i;
        lvcol.fmt      = LVCFMT_LEFT;
	    lvcol.pszText  = m_rgszColumnNames[i];

        // Finally, insert the column at the 'ith' position
		if (ListView_InsertColumn(m_hwnd, i, &lvcol) == -1)
            return false;
	}

    m_hbmp = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDB_FOLDER));
    m_hbmpSel = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDB_FOLDERSEL));

    m_fDragging = false;
    SetInited(S_OK);

    // Override the listview's window procedure so that we can capture mouse events.
    m_wndprocOld = (WNDPROC)SetWindowLong(m_hwnd, GWL_WNDPROC, (long)ListViewWndProc);

    m_fPrevTop = false;
    m_fPrevBot = false;

    // Point our listview control's hwnd at 'this' object
    SetWindowLong(m_hwnd, GWL_USERDATA, (long)this);

    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::~CListView
// Purpose:   
// Arguments: 
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CListView::~CListView()
{
    if (m_hbmp)
        DeleteObject(m_hbmp);
    if (m_hbmpSel)
        DeleteObject(m_hbmpSel);

    if (m_hwnd)
        DestroyWindow(m_hwnd);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::SetVisible
// Purpose:   
// Arguments: 
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CListView::SetVisible(bool fVisible)
{
    ShowWindow(m_hwnd, fVisible ? SW_SHOW : SW_HIDE);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::GetColumnSizes
// Purpose:   
// Arguments: 
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CListView::GetColumnSizes(int rgnColSize[NUM_COLUMNS])
{
    // UNDONE: Read from registry if set during previous run

    // for now, just copy the default values
    memcpy(rgnColSize, gs_rgnDefColWidth, NUM_COLUMNS * 4);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::MoveTo
// Purpose:   
// Arguments: 
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CListView::MoveTo(int nX, int nY, int nW, int nH)
{
    m_rc.left = nX;
    m_rc.right = nX + nW;
    m_rc.top = nY;
    m_rc.bottom = nY + nH;

    MoveWindow(m_hwnd, nX, nY, nW, nH, FALSE);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::Clear
// Purpose:   
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CListView::Clear()
{
    ListView_DeleteAllItems(m_hwnd);
    m_fModified = true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::AddObject
// Purpose:   
// Arguments: pobj          -- The object to add to the listview
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CListView::AddObject(CObject *pobj)
{
    AddObjectAtIndex(pobj, 0);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::AddObject
// Purpose:   
// Arguments: pobj          -- The object to add to the listview
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CListView::AddObjectAtIndex(CObject *pobj, int iIndex)
{
    char szTemp[MAX_PATH];
    LVITEM item;

    if (pobj->GetType() == OBJ_GROUP)
        return;

    item.mask = LVIF_TEXT | LVIF_PARAM;
	item.iSubItem = 0;
    item.iItem = iIndex;
    item.lParam = (long)pobj;
    if (pobj->GetType() == OBJ_FOLDER)
    {
        if (!lstrcmpi(pobj->m_szFullFileName, g_szRootFolderName))
            sprintf(szTemp, "<.>");
        else
            sprintf(szTemp, "<%s>", pobj->m_szName);
        item.pszText = szTemp;
    }
    else
        item.pszText = pobj->m_szName;
	int index = ListView_InsertItem(m_hwnd, &item);

    // Relative path column
    if (!lstrcmpi(pobj->m_szFullFileName, g_szRootFolderName) || !lstrcmpi(pobj->m_szFolder, ""))
    {
        ListView_SetItemText(m_hwnd, index, 1, "");
    }
    else
    {
        char szFolder[MAX_PATH];
        if (!lstrcmpi(pobj->m_szFolder, g_szRootFolderName))
            strcpy(szFolder, ".");
        else if (lstrcmpi(pobj->m_szFolder, ""))
            sprintf(szFolder, ".%s", pobj->m_szFolder + strlen(g_szRootFolderName));
        ListView_SetItemText(m_hwnd, index, 1, szFolder);
    }

    // File size
    FormatByteString(BlockSize(pobj->m_uliSize.LowPart) * 2048, szTemp);
    ListView_SetItemText(m_hwnd, index, 2, szTemp);

    // LSN Range
    sprintf(szTemp, "%d - %d", pobj->m_dwLSN, pobj->m_dwLSN + pobj->m_dwBlockSize - 1);
    ListView_SetItemText(m_hwnd, index, 3, szTemp);

    // Check if the item was selected when previously removed and should now
    // be reselected.
    if (m_fSelectedObjList && pobj->m_fWasSelected)
        ListView_SetItemState(m_hwnd, iIndex, LVNI_SELECTED, LVNI_SELECTED);
    pobj->m_fWasSelected = false;

    m_fModified = true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::SelectAll
// Purpose:   
// Arguments: 
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CListView::SelectAll()
{
    LVITEM lvi;

    lvi.stateMask = LVIS_SELECTED;
    lvi.state     = LVIS_SELECTED;
    m_fSelectingAll = true;
    SendMessage(m_hwnd, LVM_SETITEMSTATE, -1, (LPARAM)&lvi);
    m_fSelectingAll = false;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::BeginDrag
// Purpose:   
// Arguments: 
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CListView::BeginDrag()
{
    if (ListView_GetSelectedCount(m_hwnd) == 0)
        return;
    
    m_fDragging = true;

    // Change the cursor the 'holding'
    HCURSOR hcur = LoadCursor(m_pwindow->m_hinst, MAKEINTRESOURCE(IDC_MOVECURSOR));
    SetCapture(m_hwnd);
    SetCursor(hcur);
    ::SetFocus(m_hwnd);

    // Start the dragscroll timer.
    SetTimer(m_hwnd, 1, 100, NULL);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::EndDrag
// Purpose:   
// Arguments: 
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CListView::EndDrag(POINT pt)
{
    ReleaseCapture();
    m_fDragging = false;

    // Change the cursor back to 'arrow'
    SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW)));

    MapWindowPoints(m_hwnd, m_pwindow->m_hwnd, &pt, 1);

    // Notify our window that a drag event (that started with us) has ended.
    m_pwindow->FinishedDrag(this, pt);

    KillTimer(m_hwnd, 1);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::CheckDragScroll
// Purpose:   
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CListView::CheckDragScroll()
{
    if (m_iPrevBarEntry == 0)
        return;

    int nTop = 40;
    if (m_iLayer == 2) nTop -= 20;

    POINT pt = {m_dwMouseX, m_dwMouseY+20}; 
    if ((signed short)m_dwMouseY < nTop)
    {
        // Have they been here since the last tick?
        if (m_fPrevTop)
        {
            ListView_Scroll(m_hwnd, 0, -GetColumnHeight());
            if (m_iPrevBarEntry != -1)
                DrawInsertionBar(pt);
        }
    
        m_fPrevTop = true;
    }
    else
        m_fPrevTop = false;

    DWORD dwBottom = (DWORD)m_rc.bottom - 40;
    if (m_rc.right - m_rc.left < GetLineLength())
        dwBottom -= 16; // account for the horz scroll bar

    if (m_dwMouseY > dwBottom && m_dwMouseY < dwBottom + 20)
    {
        if (m_fPrevBot)
        {
            ListView_Scroll(m_hwnd, 0, GetColumnHeight());
            if (m_iPrevBarEntry != -1)
                DrawInsertionBar(pt);
        }
        m_fPrevBot = true;
    }
    else
        m_fPrevBot = false;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::ObjectDropped
// Purpose:   
// Arguments: 
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CListView::ObjectDropped()
{
    m_iDropPoint = m_iPrevBarEntry;

    // Also track which object we dropped at.

    // Did user drop at end of list?
    if (m_iDropPoint >= GetTotalNumItems())
    {
        m_pobjDropAt = (CObject*)INSERT_OUTSIDEEDGE;
    }
    else
    {
        int iDropPoint = m_iDropPoint;
        do
        {
            m_pobjDropAt = GetObjectFromIndex(iDropPoint++);
        } while (m_pobjDropAt && m_pobjDropAt->GetType() == OBJ_EMPTY);
        
        if (!m_pobjDropAt)
            m_pobjDropAt = (CObject*)INSERT_INSIDEEDGE;
        else if (m_fInsideOut)
        {
            m_pobjDropAt = m_pobjDropAt->m_poOuter;
            if (m_pobjDropAt->GetType() == OBJ_GROUP)
                m_pobjDropAt = m_pobjDropAt->m_poOuter;
        }
    }
    m_pwindow->EraseAllSelectionBars();
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::UpdateDrag
// Purpose:   
// Arguments: 
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CListView::UpdateDrag(POINT pt)
{
    // Convert the point from relative to us, to relative to our parent window
    MapWindowPoints(m_hwnd, m_pwindow->m_hwnd, &pt, 1);

    // Inform our window that a drag move has occurred.  Our presence in this function
    // does not mean that the move occurred *over* us, merely that the mouse has moved
    // during a drag that *started in* us.  Our window needs to determine what listview
    // (if any) the drag is currently actually over.
    m_pwindow->DragMove(pt);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::GetHeaderHeight
// Purpose:   
// Arguments: 
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
int CListView::GetHeaderHeight()
{
    RECT rcHeader;
    HWND hwndHeader = ListView_GetHeader(m_hwnd);
    GetClientRect(hwndHeader, &rcHeader);
    return rcHeader.bottom - rcHeader.top;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::GetColumnHeight
// Purpose:   
// Arguments: 
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
int CListView::GetColumnHeight()
{
    POINT pt0, pt1;
    ListView_GetItemPosition(m_hwnd, 0, &pt0);
    ListView_GetItemPosition(m_hwnd, 1, &pt1);
    return pt1.y - pt0.y;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::GetTotalNumItems
// Purpose:   
// Arguments: 
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
int CListView::GetTotalNumItems()
{
    return ListView_GetItemCount(m_hwnd);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::GetNumVisibleRows
// Purpose:   
// Arguments: 
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
int CListView::GetNumVisibleRows()
{
    return ListView_GetCountPerPage(m_hwnd);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::GetTopRow
// Purpose:   
// Arguments: 
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
int CListView::GetTopRow()
{
    return ListView_GetTopIndex(m_hwnd);
}


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::GetListOfSelectedObjects
// Purpose:   
// Arguments: 
// Return:    'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// The list will be in top-to-bottom visibility order, regardless of the source
// list's sort insideout-ness
#define ITEM_BATCH 2
bool CListView::GetListOfSelectedObjects(CObjList *polToMove)
{
    // This function generates a list of all of the selected objects in the
    // listview, and removes them from their concordant layers (so that the only
    // place they exist is in polToMove).
    int *rgn = (int*)malloc(ITEM_BATCH*sizeof(int));
    int cItem = 0, cMaxItem = ITEM_BATCH;
    int iItem = -1;
    while ((iItem = ListView_GetNextItem(m_hwnd, iItem, LVNI_SELECTED)) != -1)
    {
        // Get the item's object pointer and add to the list
        CObject *pobj = GetObjectFromIndex(iItem);
        assert(pobj);

        // Keep track of the selected item indices -- we have to remove them
        // in reverse order as a post-processing step due to a bug in the Win32
        // listview class.
        if (cItem == cMaxItem) {
            cMaxItem += ITEM_BATCH;
            rgn = (int*)realloc(rgn, cMaxItem*sizeof(int));
        }
        rgn[cItem++] = iItem;

        // Remove the object from it's layer list.
        pobj->RemoveFromList();
        
        if (pobj->m_pog && !m_fInsideOut)
        {
            // If this is the top-most member of the group, then add the group
            // so that it appears after all of its objects
            if (pobj->m_pog->m_gol.IsFirstMember(pobj))
            {
                pobj->m_pog->RemoveFromList();
                polToMove->AddToHead(pobj->m_pog);
            }
        }

        // Add the object to the passed-in list.
        if (m_fInsideOut)
            polToMove->AddToHead(pobj);
        else
            polToMove->AddToTail(pobj);

        if (pobj->m_pog && m_fInsideOut)
        {
            if (pobj->m_pog->m_gol.IsFirstMember(pobj))
            {
                pobj->m_pog->RemoveFromList();
                polToMove->AddToHead(pobj->m_pog);
            }
        }
    }

    // Now delete the objects from the listview.  We have to do this as a post-
    // processing step due to an apparent bug in the Win32 listview class, in 
    // which certain circumstances caused a call to ListView_DeleteItem to
    // incorrectly remove selection state from a different item.
    for (iItem = cItem - 1; iItem >= 0; iItem--)
        ListView_DeleteItem(m_hwnd, rgn[iItem]);
    free(rgn);
    
    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::GetSelectedFileCountAndSize
// Purpose:   
// Arguments: 
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CListView::GetSelectedFileCountAndSize(int *pcFiles, int *pnbyFileSize)
{
    int iItem = -1;
    *pcFiles = 0;
    *pnbyFileSize = 0;

    while ((iItem = ListView_GetNextItem(m_hwnd, iItem, LVNI_SELECTED)) != -1)
    {
        // Get the item's object pointer and add to the list
        CObject *pobj = GetObjectFromIndex(iItem);
        assert(pobj);

        (*pcFiles)++;
        *pnbyFileSize += pobj->m_dwBlockSize * 2048;
    }
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::RemoveObjectList
// Purpose:   
// Arguments: 
// Return:    'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CListView::RemoveObjectList(CObject *rgpol[])
{
    for (int i = 0; rgpol[i] != NULL; i++)
    {
        LVFINDINFO lvfi;
        lvfi.flags = LVFI_PARAM;
        lvfi.lParam = (long)rgpol[i];
        // Remove object rgpol[i] from the list.
        int iItem = ListView_FindItem(m_hwnd, -1, &lvfi);
        if (iItem == -1)
        {
            // Object doesn't exist in this list.  Should never get here
            return false;
        }
        if (!ListView_DeleteItem(m_hwnd, iItem))
            return false;
    }

    m_fModified = true;

    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::RemoveObject
// Purpose:   
// Arguments: 
// Return:    'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CListView::RemoveObject(CObject *po)
{
    LVFINDINFO lvfi;
    lvfi.flags = LVFI_PARAM;
    lvfi.lParam = (long)po;
    // Remove object rgpol[i] from the list.
    int iItem = ListView_FindItem(m_hwnd, -1, &lvfi);
    if (iItem == -1)
    {
        // Object doesn't exist in this list.  Should never get here
        return false;
    }
    if (!ListView_DeleteItem(m_hwnd, iItem))
        return false;

    m_fModified = true;

    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::CanItemChange
// Purpose:   
// Arguments: 
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CListView::CanItemChange(int iItem, DWORD dwOldState, DWORD dwNewState)
{
    // If the item is nonmoveable, then don't allow selection or focus
    CObject *pobj = GetObjectFromIndex(iItem);
    if (!pobj)
        return false;
    if (pobj->m_fIgnoreNextUnselect && ((dwOldState & LVIS_SELECTED) && !(dwNewState & LVIS_SELECTED)))
    {
        pobj->m_fIgnoreNextUnselect = false;
        return false;
    }

    if ((pobj->GetType() == OBJ_SEC || pobj->GetType() == OBJ_VOLDESC || pobj->GetType() == OBJ_EMPTY))
        return false;

    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::ItemSelected
// Purpose:   
// Arguments: 
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CListView::ItemSelected(int iSelectedItem, bool fSelected)
{
    // note: must be at least two files selected to enable group
    bool fGroupable = true, fUngroupable = true;
    int iItem, cFiles, iPrevItem;

    if (m_fSelecting)
        return;
    m_fSelecting = true;

    CObject *pobj = GetObjectFromIndex(iSelectedItem);

    if (pobj->m_pog)
    {
        iItem = -1;
        while ((iItem = ListView_GetNextItem(m_hwnd, iItem, 0)) != -1)
        {
            CObject *pobj2 = GetObjectFromIndex(iItem);
            assert(pobj2);
            if (pobj2->m_pog == pobj->m_pog && pobj2 != pobj)
            {
                ListView_SetItemState(m_hwnd, iItem, (fSelected) ? LVNI_SELECTED : 0, LVNI_SELECTED);
                if (fSelected && !m_fSelectingAll)
                    pobj2->m_fIgnoreNextUnselect = true;
            }
        }
    }
    m_fSelecting = false;
    
    // Get the first selected object
    iItem = 0;
    cFiles = 0;
    iPrevItem = ListView_GetNextItem(m_hwnd, -1, LVNI_SELECTED);
    if (iPrevItem != -1 && IsGroupable(-1, iPrevItem))
    {
        while (iItem != -1)
        {
            cFiles++;
            iItem = ListView_GetNextItem(m_hwnd, iPrevItem, LVNI_SELECTED);
            if (iItem == -1)
                break; // done

            // verify it's groupable
            if (!IsGroupable(iPrevItem, iItem))
            {
                fGroupable = false;
                break;
            }

            iPrevItem = iItem;
        }
    }
    if (cFiles < 2)
        fGroupable = false;

    // If all selected items are grouped, then the user can ungroup them
    if (ListView_GetSelectedCount(m_hwnd) == 0)
        fUngroupable = false;
    else
    {
        iItem = -1;
        while ((iItem = ListView_GetNextItem(m_hwnd, iItem, LVNI_SELECTED)) != -1)
        {
            if (!IsUngroupable(iItem))
            {
                fUngroupable = false;
                break;
            }
        }
    }

    m_pwindow->SetGroupable(fGroupable);
    m_pwindow->SetUngroupable(fUngroupable);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::IsGroupable
// Purpose:   
// Arguments: 
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CListView::IsGroupable(int iPrevItem, int iItem)
{
    CObject *pobj = GetObjectFromIndex(iItem);
    if (pobj->GetType() == OBJ_GROUP || pobj->GetType() == OBJ_VOLDESC || pobj->m_pog != NULL)
        return false;

    // Verify it's contiguous
    if (iPrevItem != -1 && iItem != iPrevItem + 1)
    {
        if (iItem == iPrevItem + 2)
        {
            // We'll allow it if the intervening object is a placeholder
            if ((GetObjectFromIndex(iPrevItem + 1)->GetType() != OBJ_SEC))
                return false;
        }
        else
            return false;
    }

    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::IsUngroupable
// Purpose:   
// Arguments: 
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CListView::IsUngroupable(int iItem)
{
    CObject *pobj = GetObjectFromIndex(iItem);
    return (pobj->m_pog != NULL);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::ClearSelected
// Purpose:   
// Arguments: 
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CListView::ClearSelected()
{
    ListView_SetItemState(m_hwnd, -1, 0, LVIS_SELECTED);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::CheckDroppedOnSelf
// Purpose:   
// Arguments: 
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CListView::CheckDroppedOnSelf()
{
    CObject *pobj = GetObjectFromIndex(m_iPrevBarEntry);

    // Check if 'm_iPrevBarEntry' cooresponds to any of the currently selected
    // items.  If so, return true
    int iItem = -1;
    while ((iItem = ListView_GetNextItem(m_hwnd, iItem, LVNI_SELECTED)) != -1)
    {
        if (pobj && pobj->m_pog)
        {
            CObject *pobj2 = GetObjectFromIndex(iItem);
            if (pobj2->GetType() == OBJ_GROUP)
                return true;
        }
        if (iItem == m_iPrevBarEntry - (m_fInsideOut) ? 1 : 0)
            return true;
    }
    return false;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::GetObjectFromIndex
// Purpose:   
// Arguments: 
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CObject *CListView::GetObjectFromIndex(int iItem)
{
    LVITEM lvi;
    lvi.mask = LVIF_PARAM;
    lvi.iItem = iItem;
    if (!ListView_GetItem(m_hwnd, &lvi))
        return NULL;
        
    return (CObject*)lvi.lParam;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::GetIndexFromObject
// Purpose:   
// Arguments: 
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
int CListView::GetIndexFromObject(CObject *pobj)
{
    LVFINDINFO lvfi;
    lvfi.flags = LVFI_PARAM;
    lvfi.lParam = (long)pobj;
    return ListView_FindItem(m_hwnd, -1, &lvfi);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::GroupSelectedItems
// Purpose:   
// Arguments: 
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CObject *CListView::GroupSelectedItems(CObj_Group *pogNew)
{
    CObject *pobjToRet;

    // Get first selected item
    int iFirstSelectedItem = ListView_GetNextItem(m_hwnd, -1, LVNI_SELECTED);
    assert(iFirstSelectedItem != -1);

    // Move all of the selected objects into the new group object
    int iSelectedItem = -1, iFile = 0;
    while ((iSelectedItem = ListView_GetNextItem(m_hwnd, iSelectedItem, LVNI_SELECTED)) != -1)
    {
        // Get the object pointer
        CObject *pobj = GetObjectFromIndex(iSelectedItem);

        // Tell the object that it belongs in the group
        pobj->SetGroup(pogNew);

        // Set the group's LSN to be immediately before the files
        if (iFile == 0)
        {
            pogNew->m_dwLSN = pobj->m_dwLSN;
            pobjToRet = pobj;
        }

        iFile++;
    }
    InvalidateRect(m_hwnd, NULL, false);
    // We know we can't group now
    m_pwindow->SetGroupable(false);
    m_pwindow->SetUngroupable(true);

    m_fModified = true;

    return pobjToRet;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::UngroupSelectedItems
// Purpose:   
// Arguments: 
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CListView::UngroupSelectedItems(CWorkspace *pws, int nLayer)
{
    int iSelectedItem = -1;
    
    while ((iSelectedItem = ListView_GetNextItem(m_hwnd, iSelectedItem, LVNI_SELECTED)) != -1)
    {
        // If the item is in a group then remove it from the group.
        CObject *poCur = GetObjectFromIndex(iSelectedItem);
        CObj_Group *pog = poCur->m_pog;
        if (pog)
        {
            // Tell the group to remove all it's grouped objects
            pog->RemoveAllGroupedObjects();

            // Tell the workspace to remove the group
            pws->RemoveObjectFromLayer(pog, nLayer);
        }
    }
    
    m_fModified = true;

    // We know we can't ungroup now
    m_pwindow->SetUngroupable(false);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::GetFirstSelectedObject
// Purpose:   
// Arguments: 
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CObject *CListView::GetFirstSelectedObject()
{
    return GetObjectFromIndex(ListView_GetNextItem(m_hwnd, -1, LVNI_SELECTED));
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::GetLastSelectedObject
// Purpose:   
// Arguments: 
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CObject *CListView::GetLastSelectedObject()
{
    int iItem = -1;
    CObject *pobj = NULL;
    while ((iItem = ListView_GetNextItem(m_hwnd, iItem, LVNI_SELECTED)) != -1)
    {
        pobj = GetObjectFromIndex(iItem);
    }
    return pobj;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::StoreSelectedObjList
// Purpose:   
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CListView::StoreSelectedObjList()
{
    int iItem = -1;
    while ((iItem = ListView_GetNextItem(m_hwnd, iItem, LVNI_SELECTED)) != -1)
    {
        GetObjectFromIndex(iItem)->m_fWasSelected = true;
    }

    // Also store scroll position
    SCROLLINFO si;
    si.cbSize = sizeof(SCROLLINFO);
    si.fMask = SIF_POS;
    GetScrollInfo(m_hwnd, SB_VERT, &si);
    m_iScrollPos = si.nPos;

    m_fSelectedObjList = true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::ClearSelectedObjList
// Purpose:   
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CListView::ClearSelectedObjList()
{
    int n = m_iScrollPos;

    ListView_Scroll(m_hwnd, 0, n * GetColumnHeight());

    m_fSelectedObjList = false;
}


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ListViewCompareProc
// Purpose:   
// Arguments: 
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
int CALLBACK ListViewCompareProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    return ((CListView*)lParamSort)->CompareProc(lParam1, lParam2);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::SortByColumn
// Purpose:   
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CListView::Sort()
{
    // a little bit of hackery here to get around the fact that sorting works
    // through a callback function...
    ListView_SortItems(m_hwnd, ListViewCompareProc, this);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::CompareProc
// Purpose:   
// Arguments: 
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
int CListView::CompareProc(LPARAM lParam1, LPARAM lParam2)
{
    CObject *pobj1 = (CObject*)lParam1;
    CObject *pobj2 = (CObject*)lParam2;

    // Sort by LSN
    if (pobj1->m_dwLSN == pobj2->m_dwLSN)
        return 0;
    else
        return  (pobj1->m_dwLSN > pobj2->m_dwLSN) ? 1 : -1;
}	

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::MoveSelection
// Purpose:   
// Arguments: 
// Return:    'true' if we handled the move; 'false' if the os should
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CListView::MoveSelection(WORD wVKey)
{
    // Get the currently focused item
    int iItem = ListView_GetNextItem(m_hwnd, -1, LVNI_FOCUSED);
    if (iItem == -1)
        return false;

    // Determine which entry the user is trying to move towards
    int iTargetItem = iItem;
    switch (wVKey)
    {
    case VK_UP:    iTargetItem--; break;
    case VK_LEFT:  iTargetItem--; break;
    case VK_DOWN:  iTargetItem++; break;
    case VK_RIGHT: iTargetItem++; break;
    case VK_HOME:   // FUTURE: Move to topmost valid item
    case VK_END:    // FUTURE: move to bottommost valid item
    case VK_PRIOR:  // FUTURE:
    case VK_NEXT:   // FUTURE:
                   return false;
    default:       return true;
    }

    // Is the target item one that the user can move onto?
    if (!CanItemChange(iTargetItem, 0, 0))
    {
        // Item can't change, so pretend we already handled it.
        // FUTURE: Step over target item to next 'valid' one
        return true;
    }
    else
    {
        // Item can change - let os handle it
        return false;
    }   
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\CListView.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      clistview.h
// Contents:  
// Revisions: 14-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

class CWindow;
class CObject;
class CObjList;
class CObj_Group;
class CWorkspace;
class CObjNodeList;

// Number of columns to display
#define NUM_COLUMNS 4

class CListView : public CInitedObject
{
public:
    int m_iLayer;
    bool Init(CWindow *pwindow, bool fInsideOut, bool fDisplayLSNs);
    ~CListView();

    void MoveTo(int nX, int nY, int nW, int nH);

    void Clear();
    void AddObject(CObject *pobj);
    void AddObjectAtIndex(CObject *pobj, int iIndex);

    HWND GetHwnd() {return m_hwnd; }
    
    int CompareProc(LPARAM lParam1, LPARAM lParam2);
    void SetVisible(bool fVisible);

    void SelectAll();
    HWND m_hwnd;

    void BeginDrag();
    void EndDrag(POINT pt);
    void ItemSelected(int iItem, bool fSelected);

    BOOL WndProc(UINT uMsg, WPARAM wparam, LPARAM lparam);

    bool MoveSelection(WORD wVKey);

    void DrawInsertionBar(POINT ptScreen);
    void ErasePreviousSelectionBar();
    bool GetListOfSelectedObjects(CObjList *polToMove);
    bool RemoveObjectList(CObject *rgpol[]);
    bool RemoveObject(CObject *po);

    void ClearSelected();

    int m_iPrevBarEntry;
    int m_iDropPoint;
    bool m_fInsideOut;
    CObject *GroupSelectedItems(CObj_Group *pogNew);
    void UngroupSelectedItems(CWorkspace *pws, int nLayer);

    CObject *m_pobjDropAt;

    void ObjectDropped();
    CObject *GetFirstSelectedObject();
    CObject *GetLastSelectedObject();

    CObject *GetObjectFromIndex(int iItem);
    int GetIndexFromObject(CObject *pobj);
    bool CheckDroppedOnSelf();

    bool HandleDrawItem(LPDRAWITEMSTRUCT pdis);
    bool CanItemChange(int iItem, DWORD dwOldState, DWORD dwNewState);

    void GetSelectedFileCountAndSize(int *pcFiles, int *pnbyFileSize);

    void StoreSelectedObjList();
    void ClearSelectedObjList();
    bool m_fSelectedObjList;
    bool m_fModified;
	void Sort();
    void SetFocus(bool fHaveFocus);
private:

    void GetColumnSizes(int rgnColSize[NUM_COLUMNS]);
    int  GetLineLength();
    int  GetHeaderHeight();
    int  GetColumnHeight();
    int  GetTotalNumItems();
    int  GetNumVisibleRows();
    int  GetTopRow();

    bool IsGroupable(int iPrevItem, int iItem);
    bool IsUngroupable(int iItem);

    void UpdateDrag(POINT pt);

    void HandleFocusState(LPDRAWITEMSTRUCT pdis);
    void HandleSelectionState(LPDRAWITEMSTRUCT pdis, char *szBuf);
    void DrawGridLines(LPDRAWITEMSTRUCT pdis);

    WNDPROC m_wndprocOld;
    char m_rgszColumnNames[NUM_COLUMNS][MAX_PATH];
    bool m_fInvert;
    bool m_fDragging;
    CWindow *m_pwindow;
    RECT m_rc;
    bool m_fSelectingAll;
    int m_iScrollPos;
    int m_nColumns;
    void CheckDragScroll();
    bool m_fPrevTop, m_fPrevBot;

    DWORD m_dwMouseX, m_dwMouseY;
    bool m_fHaveFocus;
    bool IsItemSelected(int iItem);
    int m_iFocusItem;
    HBITMAP m_hbmp, m_hbmpSel;
    int m_fSelecting;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\CListView_OwnerDraw.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CListView_OwnerDraw.cpp
// Contents:  
// Revisions: 8-Jul-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"

extern int gs_rgnDefColWidth[NUM_COLUMNS];


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::GetLineLength
// Purpose:   
// Arguments: 
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
int CListView::GetLineLength()
{
    int nWidth = 0;
    for (int i = 0; i < m_nColumns; i++)
        nWidth += ListView_GetColumnWidth(m_hwnd, i);

    return nWidth;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::DrawInsertionBar
// Purpose:   
// Arguments: 
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CListView::DrawInsertionBar(POINT pt)
{
    // Convert coordinates to local to us
    MapWindowPoints(m_pwindow->m_hwnd, m_hwnd, &pt, 1);

    // Determine the entry that occurs immediately after the specified coordinate
    int iEntry = ((pt.y - GetColumnHeight()/2)/ GetColumnHeight()) + GetTopRow();

    // Don't let selection bar move past last entry
    if (iEntry >= GetTotalNumItems())
    {
        iEntry = GetTotalNumItems();
        if (m_fInsideOut)
        {
            // Find the farthest out object and use it.
            iEntry--;
            while (iEntry)
            {
                CObject *pobj = GetObjectFromIndex(iEntry);
                if (pobj && pobj->GetType() != OBJ_SEC && pobj->GetType() != OBJ_VOLDESC && pobj->GetType() != OBJ_EMPTY)
                    break;
                iEntry--;
            }
            iEntry++;
        }
    }

    // If the entry is at a nonmoveable object, then move outward until it's not
    CObject *pobj  = GetObjectFromIndex(iEntry);
    int iNextEntry = iEntry;
    while (pobj && (pobj->GetType() == OBJ_SEC   || pobj->GetType() == OBJ_VOLDESC ||
                    pobj->GetType() == OBJ_EMPTY))
    {
        iNextEntry = (m_fInsideOut) ? iEntry - 1 : iEntry + 1;
        if ((pobj = GetObjectFromIndex(iNextEntry)) == NULL)
            break;

        if (pobj && (pobj->GetType() == OBJ_FILE || pobj->GetType() == OBJ_FOLDER))
            break;
        iEntry = iNextEntry;
    }
    if (!m_fInsideOut)
        iEntry = iNextEntry;
    if (iEntry == -1)
        iEntry = 0;

    // Don't insert at a group - move "upward" until it's not.
    pobj = GetObjectFromIndex(iEntry);
    iNextEntry = iEntry;
    while (pobj && pobj->m_pog)
    {
        iNextEntry = iEntry - 1;
        if ((pobj = GetObjectFromIndex(iNextEntry)) == NULL || pobj->m_pog == NULL)
            break;
        iEntry = iNextEntry;
        pobj = GetObjectFromIndex(iEntry);
    }

    // Don't insert between two selected items - go to item "above" it.
    pobj = GetObjectFromIndex(iEntry);
    iNextEntry = iEntry;
    while (pobj && IsItemSelected(iNextEntry))
    {
        iNextEntry = iEntry - 1;
        if ((pobj = GetObjectFromIndex(iNextEntry)) == NULL || !IsItemSelected(iNextEntry))
            break;
        iEntry = iNextEntry;
        pobj = GetObjectFromIndex(iEntry);
    }

        
    // Don't redraw if not necessary
    if (m_iPrevBarEntry == iEntry)
        return;

    int nY = (iEntry - GetTopRow() )* GetColumnHeight() + GetHeaderHeight() + 1;

    // Draw the insertion line at the specified location
    HDC hdc = GetDC(m_hwnd);
    HPEN hpen = CreatePen(PS_SOLID, 1, RGB(0, 0, 255));
    HPEN hpenOld = (HPEN)SelectObject(hdc, hpen);

    MoveToEx(hdc, 0, nY, NULL);
    LineTo(hdc, GetLineLength(), nY);
    SelectObject(hdc, hpenOld);
    DeleteObject(hpen);

    ErasePreviousSelectionBar();
    ReleaseDC(m_hwnd, hdc);

    // Track which entry is the 'previous' entry for erasing purposes
    m_iPrevBarEntry = iEntry;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  
// Purpose:   
// Arguments: 
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CListView::IsItemSelected(int iItem)
{
    LVITEM lvi;
    lvi.mask = LVIF_STATE;
    lvi.iItem = iItem;
    lvi.iSubItem = 0;
    lvi.stateMask = LVIS_SELECTED;
    if (!ListView_GetItem(m_hwnd, &lvi))
        return false;
        
    return (lvi.state & LVIS_SELECTED) ? true: false;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::ErasePreviousSelectionBar
// Purpose:   
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CListView::ErasePreviousSelectionBar()
{
    // Erase the previous entry
    if (m_iPrevBarEntry != -1)
    {
        HDC hdc = GetDC(m_hwnd);
        HPEN hpen = CreatePen(PS_SOLID, 1, RGB(212, 208, 200));
        HPEN hpenOld = (HPEN)SelectObject(hdc, hpen);
        int nY = (m_iPrevBarEntry - GetTopRow() )* GetColumnHeight() + GetHeaderHeight() + 1;

        MoveToEx(hdc, 0, nY, NULL);
        LineTo(hdc, GetLineLength(), nY);
        SelectObject(hdc, hpenOld);
        DeleteObject(hpen);

        CObject *pobj = GetObjectFromIndex(m_iPrevBarEntry-1);
        if (pobj && pobj->m_pog)
        {
            // member of a group, so draw blue bar
            HPEN hpen = CreatePen(PS_SOLID, 1, RGB(0, 0, 128));
            HPEN hpenOld = (HPEN)SelectObject(hdc, hpen);
            MoveToEx(hdc, 2, nY, NULL);
            LineTo(hdc, min(6, GetLineLength()), nY);
            SelectObject(hdc, hpenOld);
            DeleteObject(hpen);
        }

        ReleaseDC(m_hwnd, hdc);
        m_iPrevBarEntry = -1;
    }
}

void CListView::DrawGridLines(LPDRAWITEMSTRUCT pdis)
{
    HPEN hpen = CreatePen(PS_SOLID, 0, RGB(212,208,200));
    HPEN hpenOld = (HPEN)SelectObject(pdis->hDC, hpen);
    HBRUSH hBrushOld = (HBRUSH)SelectObject(pdis->hDC, GetStockObject(NULL_BRUSH));
    Rectangle(pdis->hDC, pdis->rcItem.left-1, pdis->rcItem.top-1, pdis->rcItem.right, pdis->rcItem.bottom);

    int nWidth = 0;
    for (int i = 0; i < sizeof(gs_rgnDefColWidth)/sizeof(int)-1; i++)
    {
        nWidth += ListView_GetColumnWidth(m_hwnd, i);
        Rectangle(pdis->hDC, nWidth, pdis->rcItem.top-1, nWidth + 1, pdis->rcItem.bottom);
    }
    SelectObject(pdis->hDC, hpenOld);
    SelectObject(pdis->hDC, hBrushOld);
    DeleteObject(hpen);
}

void CListView::HandleSelectionState(LPDRAWITEMSTRUCT pdis, char *szBuf)
{
    HBRUSH hBrush;
    DWORD dwOldTextColor, dwOldBkColor;
    bool fGroupedItem = false, fLastGroupedItem = false, fFirstGroupedItem = false;

    // Set up the various rectangles we'll need for rendering
    int nColWidth = ListView_GetColumnWidth(m_hwnd, 0);
    
    // The main rectangle for the first subitem of the item
    RECT rcItem = pdis->rcItem;
    rcItem.left += 2;
    rcItem.right = rcItem.left + nColWidth - 2;

    RECT rcGroupVertLine = rcItem;
    rcGroupVertLine.right = rcGroupVertLine.left + 4;
    rcGroupVertLine.top--;
    rcGroupVertLine.bottom++;

    RECT rcGroupTopLine = rcItem;
    rcGroupTopLine.bottom = rcGroupTopLine.top + 2;
    rcGroupTopLine.right = rcGroupTopLine.left + 6;

    RECT rcGroupBotLine = rcItem;
    rcGroupBotLine.bottom--;
    rcGroupBotLine.top = rcGroupBotLine.bottom - 2;
    rcGroupBotLine.right = rcGroupBotLine.left + 6;

    // Get a pointer to the object in the current item
    CObject *pobj = GetObjectFromIndex(pdis->itemID);
    assert(pobj);
    
    // Is the object a member of a group?
    if (pobj->m_pog)
    {
        fGroupedItem = true;
        
        // Is the object the *first* member of the group?
        if (((!m_fInsideOut) && pobj->m_pog->m_gol.Head() == pobj) || ((m_fInsideOut) && pobj->m_pog->m_gol.Tail() == pobj))
        {
            fFirstGroupedItem = true;
            rcGroupVertLine.top++;
        }

        // Is the object the *last* member of the group?
        if (((!m_fInsideOut) && pobj->m_pog->m_gol.Tail() == pobj) || ((m_fInsideOut) && pobj->m_pog->m_gol.Head() == pobj))
        {
            fLastGroupedItem = true;
            rcGroupVertLine.bottom-=2;
        }
    }

    if (fGroupedItem)
    {
        rcItem.left += 8;
    }

    // if selected, draw selected item's text white, highlight rectangle blue
    if (pdis->itemState & ODS_SELECTED)
    {
        // draw background rectangle
        if (m_fHaveFocus)
            hBrush = CreateSolidBrush(RGB(0, 0, 128));
        else
            hBrush = CreateSolidBrush(RGB(192, 192, 192));
        RECT rcTemp = pdis->rcItem;
        rcTemp.bottom--;
        rcTemp.left--;
        FillRect(pdis->hDC, &rcTemp, hBrush);
        DeleteObject(hBrush);

        // Draw grid lines.  We don't use the default grid lines since we don't
        // want them to draw over the green 'grouped item' borders...
        DrawGridLines(pdis);

        // Draw group descriptor
        if (rcItem.left < rcItem.right)
            if (fGroupedItem)
            {
                hBrush = CreateSolidBrush(RGB(0, 0, 128));
                FillRect(pdis->hDC, &rcGroupVertLine, hBrush);
                if (fLastGroupedItem)
                    FillRect(pdis->hDC, &rcGroupBotLine, hBrush);
                if (fFirstGroupedItem)
                    FillRect(pdis->hDC, &rcGroupTopLine, hBrush);
                DeleteObject(hBrush);
            }
        if (rcItem.left < rcItem.right)
        {
            // change text and back ground color of list box's selection
            if (m_fHaveFocus)
            {
                dwOldTextColor = SetTextColor(pdis->hDC, RGB(255,255,255));
                dwOldBkColor = SetBkColor(pdis->hDC, RGB(0,0,255));
            }
            else
            {
                dwOldTextColor = SetTextColor(pdis->hDC, RGB(0, 0, 0));
                dwOldBkColor = SetBkColor(pdis->hDC, RGB(192,192,192));
            }
            if (pobj->GetType() == OBJ_FOLDER)
            {
                HDC hdcBmp = CreateCompatibleDC(pdis->hDC);
                SelectObject(hdcBmp, m_hbmpSel);
                BitBlt(pdis->hDC, rcItem.left, rcItem.top, 14, 12, hdcBmp, 0, 0, SRCCOPY);
                DeleteDC(hdcBmp);
                rcItem.left += 15;
            }

            ExtTextOut(pdis->hDC, (int)(rcItem.left), (int)(rcItem.top),
                       ETO_CLIPPED, &rcItem, (LPSTR)szBuf, lstrlen(szBuf), NULL);

            if (pobj->GetType() == OBJ_FOLDER)
                rcItem.left -= 15;

            // Draw the subitems
            if (fGroupedItem)
                rcItem.left -= 8;
            int nWidth = rcItem.left;
            for (int i = 1; i < NUM_COLUMNS; i++)
            {
                char sz[1024];
                rcItem.left += ListView_GetColumnWidth(m_hwnd, i-1);
                nWidth = ListView_GetColumnWidth(m_hwnd, i);

                ListView_GetItemText(m_hwnd, pdis->itemID, i, sz, 1024);
                rcItem.right = rcItem.left + nWidth - 2;
                ExtTextOut(pdis->hDC, (int)(rcItem.left), (int)(rcItem.top),
                           ETO_CLIPPED, &rcItem, (LPSTR)sz, lstrlen(sz), NULL);
            }
            // restore text and back ground color of list box's selection
            SetTextColor(pdis->hDC, dwOldTextColor);
            SetBkColor(pdis->hDC, dwOldBkColor);
        }
    }
    else // item not selected; draw black text on white background
    {
        // draw white back ground rectangle
        hBrush = (HBRUSH)GetStockObject(WHITE_BRUSH);
        RECT rcTemp = pdis->rcItem;
        rcTemp.bottom--;
        FillRect(pdis->hDC, &rcTemp, hBrush);

        // Draw grid lines.  We don't use the default grid lines since we don't
        // want them to draw over the green 'grouped item' borders...
        DrawGridLines(pdis);

        if (pobj->GetType() == OBJ_SEC || pobj->GetType() == OBJ_VOLDESC || pobj->GetType() == OBJ_EMPTY)
        {
            if (rcItem.left < rcItem.right)
            {
                if (pobj->GetType() == OBJ_EMPTY)
                    hBrush = CreateHatchBrush(HS_BDIAGONAL, RGB(0, 0, 192));
                else
                    hBrush = CreateHatchBrush(HS_BDIAGONAL, RGB(192, 0, 0));

                int nOldRight = rcItem.right;
                rcItem.right = min(rcItem.right, rcItem.left + 20);
                rcItem.bottom--;
                FillRect(pdis->hDC, &rcItem, hBrush);
                DeleteObject(hBrush);

                HPEN hpen;
                if (pobj->GetType() == OBJ_EMPTY)
                    hpen = CreatePen(PS_SOLID, 0, RGB(0, 0, 192));
                else
                    hpen = CreatePen(PS_SOLID, 0, RGB(192, 0, 0));
                HPEN hpenOld = (HPEN)SelectObject(pdis->hDC, hpen);
                hBrush = (HBRUSH)SelectObject(pdis->hDC, GetStockObject(NULL_BRUSH));
                Rectangle(pdis->hDC, rcItem.left, rcItem.top, rcItem.right, rcItem.bottom);
                SelectObject(pdis->hDC, hpenOld);
                SelectObject(pdis->hDC, hBrush);
                DeleteObject(hpen);

                rcItem.right = nOldRight - 1;
                ExtTextOut(pdis->hDC, (int)(rcItem.left) + 23, (int)(rcItem.top),
                           ETO_CLIPPED, &rcItem, (LPSTR)szBuf, lstrlen(szBuf), NULL);
            }
        }
        else
        {
            // Draw group descriptor
            if (rcItem.left < rcItem.right)
                if (fGroupedItem)
                {
                    hBrush = CreateSolidBrush(RGB(0, 0, 128));
                    FillRect(pdis->hDC, &rcGroupVertLine, hBrush);
                    if (fLastGroupedItem)
                        FillRect(pdis->hDC, &rcGroupBotLine, hBrush);
                    if (fFirstGroupedItem)
                        FillRect(pdis->hDC, &rcGroupTopLine, hBrush);
                    DeleteObject(hBrush);
                }

            if (pobj->GetType() == OBJ_FOLDER)
            {
                HDC hdcBmp = CreateCompatibleDC(pdis->hDC);
                SelectObject(hdcBmp, m_hbmp);
                BitBlt(pdis->hDC, rcItem.left, rcItem.top, 14, 12, hdcBmp, 0, 0, SRCCOPY);
                DeleteDC(hdcBmp);
                rcItem.left += 15;
            }
        
            // draw normal text
            if (rcItem.left < rcItem.right)
                ExtTextOut(pdis->hDC, (int)(rcItem.left), (int)(rcItem.top),
                           ETO_CLIPPED, &rcItem, (LPSTR)szBuf, lstrlen(szBuf), NULL);
            if (pobj->GetType() == OBJ_FOLDER)
                rcItem.left -= 15;
        }

        // Draw the subitems
        if (fGroupedItem)
            rcItem.left -= 8;
        int nWidth = rcItem.left;
        for (int i = 1; i < NUM_COLUMNS; i++)
        {
            char sz[1024];
            rcItem.left += ListView_GetColumnWidth(m_hwnd, i-1);
            nWidth = ListView_GetColumnWidth(m_hwnd, i);

            ListView_GetItemText(m_hwnd, pdis->itemID, i, sz, 1024);
            rcItem.right = rcItem.left + nWidth - 2;
            ExtTextOut(pdis->hDC, (int)(rcItem.left), (int)(rcItem.top),
                       ETO_CLIPPED, &rcItem, (LPSTR)sz, lstrlen(sz), NULL);
        }
    }
    return;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CListView::HandleFocusState
// Purpose:   Handles indicating focus of control with black dashed
//            rectangular border.  
// Arguments: 
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CListView::HandleFocusState(LPDRAWITEMSTRUCT pdis)
{
    pdis->rcItem.bottom--;
    DrawFocusRect(pdis->hDC, (LPRECT)&pdis->rcItem);
    return;
}

bool CListView::HandleDrawItem(LPDRAWITEMSTRUCT pdis)
{
    char szBuf[1024];

    // if there are no items in the control yet, indicate focus
    if (pdis->itemID == -1)
    {
        HandleFocusState(pdis);
        return (TRUE);
    }

    // normal/any item draw action -- checks for selection and focus
    if (pdis->itemAction & ODA_DRAWENTIRE)
    {
        ListView_GetItemText(m_hwnd, pdis->itemID, 0, szBuf, MAX_PATH);

        // Handle both selected and unselected states, so this
        //   itemAction's code could be combined with ODA_SELECT's.
        //   Typically, the selection state is an addition to drawing
        //   the normal state, but in this case the selection state
        //   is being draw differently, so don't draw normal state
        //   if selected.
        HandleSelectionState(pdis, szBuf);

        // Handle focus state if necessary
        if (pdis->itemState & ODS_FOCUS)
            HandleFocusState(pdis);
        return TRUE;
    }

    // selected/unselected item draw action -- white text on blue background
    if (pdis->itemAction & ODA_SELECT)
    {
        // Use the itemID to get to the text string
        SendMessage(m_hwnd, LB_GETTEXT, (WORD)pdis->itemID,
                    (LONG)(LPSTR)szBuf);
        HandleSelectionState(pdis, szBuf);
        
        // Handle focus state if necessary
        if (pdis->itemState & ODS_FOCUS)
            HandleFocusState(pdis);
        return TRUE;
    }

    // focus/unfocus item draw action -- dashed rectangular border
    if (pdis->itemAction & ODA_FOCUS)
    {
        HandleFocusState(pdis);
        return TRUE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\CObject.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CObject.h
// Contents:  
// Revisions: 14-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#define LSN_UNPLACED -1

#define LSN_AUTOPLACE -2

typedef enum eObjectType {
    OBJ_SEC       = 0x0001,
    OBJ_BE        = 0x0002,
    OBJ_VOLDESC   = 0x0004,
    OBJ_FILE      = 0x0008,
    OBJ_FOLDER    = 0x0010,
    OBJ_GROUP     = 0x0020,
    OBJ_EMPTY     = 0x0040,
    OBJ_ENDOFLIST = 0x0080};

typedef enum eInsert {INSERT_OUTSIDEEDGE = 1, INSERT_INSIDEEDGE};


class CListView;
class CObjList;
class CObj_Group;
class CObj_Folder;

class CObject : public CInitedObject
{
public:
    friend class CObjList;
    friend class CListView;
    friend class CDVD;
    friend class CWindow_Scratch;

    CObject();
    virtual ~CObject() {};
    virtual eObjectType GetType() = NULL;
	virtual bool PersistTo(CFile *pfile);
    void SetGroup(CObj_Group *pog);
    void SetGroupBeforeObject(CObj_Group *pog, CObject *poLoc);
    void SetGroupAfterObject(CObj_Group *pog, CObject *poLoc);
    void RemoveFromList();

    // An object can belong to at most one group at any one time.
    CObj_Group *m_pog;

    DWORD m_dwBlockSize;

//protected:
    // List navigation vars
    CObject *m_poInner;
    CObject *m_poOuter;
    CObjList *m_pol;

    // Geography-view vars
    DWORD m_dwLSN;
    ULARGE_INTEGER m_uliSize;
    char m_szName[MAX_PATH];
    char m_szFolder[MAX_PATH];
    char m_szFullFileName[MAX_PATH];
    bool m_fIgnoreNextUnselect;
    bool m_fWasSelected;

    CObj_Folder *m_pof;
    int m_iFolderDirEntry;
    DWORD m_dwParentFolderId;

    // Used for CheckModifiedFiles
    bool m_fCMF_Present;
    bool m_fCMF_Resized;
};

// PlaceableObject list
class CObjList
{
public:
    CObjList();
    ~CObjList();

    CObject *GetOutside()
    {
        return (m_fInsideOut) ? m_poCur = m_poHead : m_poCur = m_poTail;
    }
    
    CObject *GetInside()
    {
        return (m_fInsideOut) ? m_poCur = m_poTail : m_poCur = m_poHead;
    }
    
    CObject *GetStart()
    {
        return (m_fInsideOut) ? m_poTail : m_poHead;
    }

    CObject *GetNextInner()
    {
        if (m_poCur == NULL) return NULL; else return m_poCur = m_poCur->m_poInner;
    }
    
    CObject *GetNextOuter()
    {
        if (m_poCur == NULL) return NULL; else return m_poCur = m_poCur->m_poOuter;
    }

    CObject *FindObjectByFullFileName(char *szName);
    int GetNumObjects(DWORD dwObjTypes);
    int GetObjectSizes(DWORD dwObjTypes);

    void Reset();
    void Clear();
    void AddToHead(CObject *ppo);
    void AddToTail(CObject *ppo);
    void Remove(CObject *ppo);
    bool InsertBefore(CObject *poToAdd, CObject *poLoc);
    bool InsertAfter(CObject *poToAdd, CObject *poLoc);

	bool PersistTo(CFile *pfile);
	bool CreateFrom(CFile *pfile);
    void SetInsideOut(bool fInsideOut) {m_fInsideOut = fInsideOut; }
    bool IsInsideOut() {return m_fInsideOut;}
    bool InsertInside(CObject *poToAdd, CObject *poLoc)
    {
//        if (m_fInsideOut) return InsertAfter(poToAdd, poLoc);
  //      else return InsertBefore(poToAdd, poLoc);
        return InsertBefore(poToAdd, poLoc);
    }
    bool InsertOutside(CObject *poToAdd, CObject *poLoc)
    {
//        if (m_fInsideOut) return InsertBefore(poToAdd, poLoc);
//        else return InsertAfter(poToAdd, poLoc);
        return InsertAfter(poToAdd, poLoc);
    }
//private:
    bool m_fInsideOut;
    bool m_fModified;
    CObject *m_poHead;
    CObject *m_poTail;
    CObject *m_poCur;
};

class CObj_Security : public CObject
{
public:
    CObj_Security();
    eObjectType GetType() {return OBJ_SEC; }
};


class CObj_Bookend : public CObject
{
public:
    CObj_Bookend();
    eObjectType GetType() {return OBJ_BE; }
};

class CObj_Empty : public CObject
{
public:
    CObj_Empty(DWORD dwSize);
    eObjectType GetType() {return OBJ_EMPTY; }
};

#define VERSION_SIG "XBOX_DVD_LAYOUT_TOOL_SIG"

struct VERSION_INFO 
{
    BYTE rgbySig[32];
    BYTE rgbyLayoutVersion[8];
    BYTE rgbyPremasterVersion[8];
    BYTE rgPadding[2048-32-8-8];    // fill with zeros
};

class CObj_VolDesc : public CObject
{
public:
    CObj_VolDesc();
    eObjectType GetType() {return OBJ_VOLDESC; }
    GDF_VOLUME_DESCRIPTOR m_gdfvd;
    VERSION_INFO m_verinfo;
    DWORD m_dwUdfsOffset;
};


class CObj_File : public CObject
{
public:
    CObj_File(char *szFolder, char *szFilename, DWORD dwSizeHigh, DWORD dwSizeLow);
    eObjectType GetType() {return OBJ_FILE; }
};

// GDF_MAX_DIRECTORY_ENTRY  -- This structure is define in order to make
// handling the directory entries easier.
typedef struct {
    USHORT LeftEntryIndex;
    USHORT RightEntryIndex;
    ULONG FirstSector;
    ULONG FileSize;
    UCHAR FileAttributes;
    UCHAR FileNameLength;
    UCHAR FileName[255];
    USHORT OffsetFromStart;
} GDF_MAX_DIRECTORY_ENTRY;

// folder = file system directory
class CObj_Folder : public CObject
{
public:
    CObj_Folder(char *szFolder, char *szFilename);
    ~CObj_Folder();
    eObjectType GetType() {return OBJ_FOLDER; }
    DWORD m_dwUdfsOffset;
    GDF_MAX_DIRECTORY_ENTRY *m_prgGDFMDE;
    int m_cDirEntries;

    // Used for persistence
    DWORD m_dwFolderId;
};



// GROUPED OBJECT CODE
class CObjNode
{
public:
    CObjNode(CObject *pobj) {m_pobj = pobj; m_ponNext = m_ponPrev = NULL; }
    CObject  *m_pobj;
    CObjNode *m_ponNext;
    CObjNode *m_ponPrev;
};

class CObjNodeList
{
public:
    CObjNodeList()
    {
        m_ponCur = m_ponHead = m_ponTail = NULL;
        m_cItems = 0;
    }
    
    ~CObjNodeList()
    {
        while (m_ponHead)
        {
            CObjNode *ponNext = m_ponHead->m_ponNext;
            delete m_ponHead;
            m_ponHead = ponNext;
        }
    }

    CObjNode *GetObjectNode(CObject *pobj)
    {
        CObjNode *ponCur = m_ponHead;
        while (ponCur)
        {
            if (ponCur->m_pobj == pobj)
                break;
            ponCur = ponCur->m_ponNext;
        }
        return ponCur;
    }

    void Add(CObject *pobj)
    {
        CObjNode *ponNew = new CObjNode(pobj);
        if (!m_ponHead)
            m_ponHead = m_ponTail = ponNew;
        else
        {
            ponNew->m_ponPrev = m_ponTail;
            m_ponTail->m_ponNext = ponNew;
            m_ponTail = ponNew;
        }
        m_cItems++;
    }

    void PopulateArray(CObject *rgo[], int cItems)
    {
        assert (cItems <= NumItems());
        CObjNode *ponCur = m_ponHead;
        int iItem = 0;
        while (ponCur && cItems)
        {
            rgo[iItem++] = ponCur->m_pobj;
            ponCur = ponCur->m_ponNext;
            cItems--;
        }
    }

    void AddBefore(CObject *pobj, CObject *poLoc)
    {
        // Add 'pobj' before poLoc
        CObjNode *ponNew = new CObjNode(pobj);

        // Find poOutside
        CObjNode *pon = m_ponHead;
        while  (pon)
        {
            if (pon->m_pobj == poLoc)
            {
                // Found the object.  Insert pobj before it.
                if (pon->m_ponPrev)
                {
                    pon->m_ponPrev->m_ponNext = ponNew;
                    ponNew->m_ponPrev = pon->m_ponPrev;
                }
                else
                    m_ponHead = ponNew;

                pon->m_ponPrev = ponNew;
                ponNew->m_ponNext = pon;
                return;
            }
            pon = pon->m_ponNext;
        }
        // Shouldn't ever get here
        assert(false);
    }

    void AddAfter(CObject *pobj, CObject *poLoc)
    {
        // Add 'pobj' after 'poLoc'
        CObjNode *ponNew = new CObjNode(pobj);

        // Find poOutside
        CObjNode *pon = m_ponHead;
        while  (pon)
        {
            if (pon->m_pobj == poLoc)
            {
                // Found the object.  Insert pobj before it.
                if (pon->m_ponNext)
                {
                    pon->m_ponNext->m_ponPrev = ponNew;
                    ponNew->m_ponNext = pon->m_ponNext;
                }
                else
                    m_ponTail = ponNew;

                pon->m_ponNext = ponNew;
                ponNew->m_ponPrev = pon;
                return;
            }
            pon = pon->m_ponNext;
        }
        // Shouldn't ever get here
        assert(false);
    }

    void Remove(CObject *pobj)
    {
        // Find the node that contains the specified object
        CObjNode *pon = m_ponHead;
        while (pon)
        {
            CObjNode *ponNext = pon->m_ponNext;
            if (pon->m_pobj == pobj)
            {
                // found it.  remove it
                if (pon->m_ponPrev)
                    pon->m_ponPrev->m_ponNext = pon->m_ponNext;
                else
                    m_ponHead = pon->m_ponNext;
                if (pon->m_ponNext)
                    pon->m_ponNext->m_ponPrev = pon->m_ponPrev;
                else
                    m_ponTail = pon->m_ponPrev;
                delete pon;
                pobj->m_pog = NULL;
                m_cItems--;
                return;
            }
            pon = ponNext;
        }
        // if here, then the object wasn't in the list to begin with.
        assert(false);
    }

    void RemoveAll()
    {
        while (m_ponHead)
        {
            CObjNode *ponNext = m_ponHead->m_ponNext;
            m_ponHead->m_pobj->m_pog = NULL;
            delete m_ponHead;
            m_ponHead = ponNext;
        }
        m_ponTail = NULL;
        m_cItems = 0;
    }

    bool IsMember(CObject *pobj)
    {
        CObjNode *ponCur = m_ponHead;
        while (ponCur)
        {
            if (ponCur->m_pobj == pobj)
                return true;
            ponCur = ponCur->m_ponNext;
        }
        return false;
    }

    bool IsFirstMember(CObject *pobj)
    {
        if (!m_ponHead) return false;
        return (m_ponHead->m_pobj == pobj);
    }

    bool IsLastMember(CObject *pobj)
    {
        if (!m_ponTail) return false;
        return (m_ponTail->m_pobj == pobj);
    }

    CObject *Head() {m_ponCur = m_ponHead; if (m_ponCur) return m_ponCur->m_pobj; else return NULL; }
    CObject *Tail() {m_ponCur = m_ponTail; if (m_ponCur) return m_ponCur->m_pobj; else return NULL; }
    CObject *Next()
    {
        if (!m_ponCur) return NULL;
        m_ponCur = m_ponCur->m_ponNext;
        if (m_ponCur) return m_ponCur->m_pobj; else return NULL;
    }
    CObject *Prev()
    {
        if (!m_ponCur) return NULL;
        m_ponCur = m_ponCur->m_ponPrev;
        if (m_ponCur) return m_ponCur->m_pobj; else return NULL;
    }

    int NumItems() {return m_cItems; }
//private:
    CObjNode *m_ponCur;
    CObjNode *m_ponHead;
    CObjNode *m_ponTail;
    int m_cItems;
};


// group = collection of files.  
class CObj_Group : public CObject
{
public:
    CObj_Group();
    eObjectType GetType() {return OBJ_GROUP; }
    void InsertGroupedObject(CObject *pobj);
    void InsertGroupedObjectBeforeObject(CObject *pobj, CObject *poLoc);
    void InsertGroupedObjectAfterObject(CObject *pobj, CObject *poLoc);
    void RemoveGroupedObject(CObject *pobj);
    void RemoveAllGroupedObjects();

    int GetNumGroupedItems()
    {
        return m_gol.NumItems();
    }
    CObjNodeList m_gol;
    DWORD m_dwUdfsOffset;
    DWORD m_dwPersistId;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\CScratch.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      cScratch.h
// Contents:  
// Revisions: 14-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

class CScratch : public CInitedObject
{
public:
    CScratch(CWindow *pwindow);
    ~CScratch();
    HWND m_hwnd;

    void ToggleView();
    void AddObject(CObject *pobj);
    void Clear() {m_plistview->Clear();}
private:
    void StorePosition();
    void SetLastKnownPos();
    CWindow *m_pwindow;
    bool m_fVisible;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\CObject.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CObject.cpp
// Contents:  
// Revisions: 14-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"

bool g_fResizedVolDesc;


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CObject::CObject()
{
    m_poInner = m_poOuter = NULL;
//    m_poTreeParent = NULL;
  //  m_fTreeViewable = false;
    m_dwLSN = LSN_UNPLACED;
    m_pog = NULL;
    m_pol = NULL;
    m_fIgnoreNextUnselect = false;
    m_fWasSelected = false;
    m_pof = NULL;
    m_iFolderDirEntry = -1;
    m_fCMF_Present = true;
    m_fCMF_Resized = false;
}

DWORD BlockSize(ULONGLONG ullSize)
{
    DWORD dwSize = (DWORD)(ullSize / 2048 + ((ullSize % 2048) ? 1 : 0));
    if (dwSize == 0) dwSize = 1;
    return dwSize;
}

CObj_Bookend::CObj_Bookend() : CObject()
{
    m_uliSize.QuadPart = 0;
    m_dwBlockSize = BlockSize(m_uliSize.QuadPart);
    LoadString(g_hinst, IDS_OBJECT_BOOKEND, m_szName, MAX_PATH);
    strcpy(m_szFolder, "");
    sprintf(m_szFullFileName, "%s\\%s", m_szFolder, m_szName);

    SetInited(S_OK);
}

CObj_Empty::CObj_Empty(DWORD dwSize) : CObject()
{
    m_uliSize.QuadPart = dwSize;
    m_dwBlockSize = BlockSize(m_uliSize.QuadPart);
    LoadString(g_hinst, IDS_OBJECT_EMPTY, m_szName, MAX_PATH);
    strcpy(m_szFolder, "");
    sprintf(m_szFullFileName, "%s\\%s", m_szFolder, m_szName);

    SetInited(S_OK);
}

CObj_VolDesc::CObj_VolDesc() : CObject()
{
    m_uliSize.QuadPart = sizeof(GDF_VOLUME_DESCRIPTOR) + 2048;
    m_dwBlockSize = BlockSize(m_uliSize.QuadPart);
    LoadString(g_hinst, IDS_OBJECT_VOLDESC, m_szName, MAX_PATH);
    strcpy(m_szFolder, "");
    sprintf(m_szFullFileName, "%s\\%s", m_szFolder, m_szName);

    SetInited(S_OK);
}

CObj_Security::CObj_Security() : CObject()
{
    // We add two blocks to the 4096 size so that we can force the actual
    // placeholder to a two-sector boundary
    m_uliSize.QuadPart = 2048 * 4098;
    m_dwBlockSize = BlockSize(m_uliSize.QuadPart);
    LoadString(g_hinst, IDS_OBJECT_SECURITY, m_szName, MAX_PATH);
    strcpy(m_szFolder, "");
    sprintf(m_szFullFileName, "%s\\%s", m_szFolder, m_szName);
    SetInited(S_OK);
}

CObj_File::CObj_File(char *szFolder, char *szFilename, DWORD dwSizeHigh, DWORD dwSizeLow) : CObject()
{
    m_uliSize.HighPart = dwSizeHigh;
    m_uliSize.LowPart  = dwSizeLow;

    m_dwBlockSize = BlockSize(m_uliSize.QuadPart);
    strcpy(m_szName, szFilename);
    strcpy(m_szFolder, szFolder);
    sprintf(m_szFullFileName, "%s\\%s", m_szFolder, m_szName);

    SetInited(S_OK);
}

CObj_Folder::CObj_Folder(char *szFolder, char *szFilename) : CObject()
{
    strcpy(m_szName, szFilename);
    strcpy(m_szFolder, szFolder);
    sprintf(m_szFullFileName, "%s\\%s", m_szFolder, m_szName);

    m_uliSize.HighPart = 0;
    m_uliSize.LowPart  = 2;
    m_dwBlockSize = BlockSize(m_uliSize.QuadPart);

    m_prgGDFMDE = NULL;
    SetInited(S_OK);
}

CObj_Folder::~CObj_Folder()
{
    if (m_prgGDFMDE)
        delete[] m_prgGDFMDE;
}

CObj_Group::CObj_Group() : CObject()
{
    m_uliSize.QuadPart = 0;
    m_dwBlockSize = BlockSize(m_uliSize.QuadPart);
    strcpy(m_szName, "Group");
    strcpy(m_szFolder, "");
    sprintf(m_szFullFileName, "%s\\%s", m_szFolder, m_szName);

    SetInited(S_OK);
}
void CObject::SetGroup(CObj_Group *pog)
{
    // If we're already a member of a group, then remove ourself from it
    if (m_pog)
        m_pog->RemoveGroupedObject(this);
        
    // Add ourselves to the specified group
    if (pog)
        pog->InsertGroupedObject(this);
    
    // Track which group we're now in
    m_pog = pog;
}

void CObject::SetGroupBeforeObject(CObj_Group *pog, CObject *poOutside)
{
    // Add this object to the 'pog' group, inside of the object specified
    // in 'poOutside'

    // If we're already a member of a group, then remove ourself from it
    if (m_pog)
        m_pog->RemoveGroupedObject(this);
        
    // Add ourselves to the specified group
    if (pog)
        pog->InsertGroupedObjectBeforeObject(this, poOutside);
    
    // Track which group we're now in
    m_pog = pog;
}

void CObject::SetGroupAfterObject(CObj_Group *pog, CObject *poOutside)
{
    // If we're already a member of a group, then remove ourself from it
    if (m_pog)
        m_pog->RemoveGroupedObject(this);
        
    // Add ourselves to the specified group
    if (pog)
        pog->InsertGroupedObjectAfterObject(this, poOutside);
    
    // Track which group we're now in
    m_pog = pog;
}

void CObj_Group::RemoveGroupedObject(CObject *pobj)
{
    assert(pobj->m_pog == this);
    m_gol.Remove(pobj);
    m_dwBlockSize -= pobj->m_dwBlockSize;
}

void CObj_Group::RemoveAllGroupedObjects()
{
    m_gol.RemoveAll();
    m_dwBlockSize = 0;
}

void CObj_Group::InsertGroupedObject(CObject *pobj)
{
    assert(pobj->m_pog == NULL);

    // Add the object to the end of this group's list of grouped objects
    m_gol.Add(pobj);
    m_dwBlockSize += pobj->m_dwBlockSize;
}

void CObj_Group::InsertGroupedObjectBeforeObject(CObject *pobj, CObject *poOutside)
{
    assert(pobj->m_pog == NULL);

    // Find the object specified by 'poOutside'.  Insert this group 'inside' of it.
    m_gol.AddBefore(pobj, poOutside);
    
    m_dwBlockSize += pobj->m_dwBlockSize;
}
void CObj_Group::InsertGroupedObjectAfterObject(CObject *pobj, CObject *poOutside)
{
    assert(pobj->m_pog == NULL);

    m_gol.AddAfter(pobj, poOutside);
    
    m_dwBlockSize += pobj->m_dwBlockSize;
}


CObjList::CObjList()
{
    m_poHead = NULL;
    m_poTail = NULL;
    m_fInsideOut = false;
    m_fModified = false;
}

CObjList::~CObjList()
{
    // clear out contents
    Clear();
}

void CObjList::Reset()
{
    CObject *pobjNext;

    // Delete all entries
    while (m_poHead)
    {
        if (m_fInsideOut)
            pobjNext = m_poHead->m_poInner;
        else
            pobjNext = m_poHead->m_poOuter;
        delete m_poHead;
        m_poHead = pobjNext;
    }
    m_poTail = NULL;
    m_fModified = true;
}
void CObjList::Clear()
{
    while (m_poHead)
        m_poHead->RemoveFromList();

    m_poTail = NULL;
    m_fModified = true;
}

int CObjList::GetNumObjects(DWORD dwObjTypes)
{
    CObject *poCur;
    int cObjects = 0;

    if (m_fInsideOut)
        poCur = m_poTail;
    else
        poCur = m_poHead;

    while (poCur)
    {
        if (poCur->GetType() & dwObjTypes)
            cObjects++;
        poCur = poCur->m_poOuter;
    }
    return cObjects;
}

int CObjList::GetObjectSizes(DWORD dwObjTypes)
{
    CObject *poCur;
    DWORD dwSize = 0;

    if (m_fInsideOut)
        poCur = m_poTail;
    else
        poCur = m_poHead;

    while (poCur)
    {
        if (poCur->GetType() & dwObjTypes)
            dwSize+=poCur->m_dwBlockSize;
        poCur = poCur->m_poOuter;
    }
    return dwSize;
}


// Add to the tail, no questions asked
void CObjList::AddToTail(CObject *ppo)
{
    if (!m_poHead)
    {
        // First entry in list
        m_poHead = m_poTail = ppo;
    }
    else
    {
        if (m_fInsideOut)
        {
            m_poTail->m_poInner = ppo;
            ppo->m_poOuter = m_poTail;
            m_poTail = ppo;
        }
        else
        {
            m_poTail->m_poOuter = ppo;
            ppo->m_poInner = m_poTail;
            m_poTail = ppo;
        }
    }
    ppo->m_pol = this;
    m_fModified = true;
}

// Add to the head, no questions asked
void CObjList::AddToHead(CObject *ppo)
{
    if (!m_poHead)
    {
        // First entry in list
        m_poHead = m_poTail = ppo;
    }
    else
    {
        if (m_fInsideOut)
        {
            m_poHead->m_poOuter = ppo;
            ppo->m_poInner = m_poHead;
            m_poHead = ppo;
        }
        else
        {
            m_poHead->m_poInner = ppo;
            ppo->m_poOuter = m_poHead;
            m_poHead = ppo;
        }
    }
    ppo->m_pol = this;
    m_fModified = true;
}

void CObject::RemoveFromList()
{
    if (m_pol)
        m_pol->Remove(this);
}

void CObjList::Remove(CObject *ppo)
{
    if (m_poHead == ppo)
        m_poHead = m_poHead->m_poOuter;
    if (m_poTail == ppo)
        m_poTail = m_poTail->m_poInner;

    if (ppo->m_poInner)
        ppo->m_poInner->m_poOuter = ppo->m_poOuter;

    if (ppo->m_poOuter)
        ppo->m_poOuter->m_poInner = ppo->m_poInner;

    ppo->m_poInner = NULL;
    ppo->m_poOuter = NULL;
    ppo->m_pol = NULL;
    ppo->m_dwLSN = LSN_UNPLACED;
    m_fModified = true;
}

bool CObjList::InsertBefore(CObject *poToAdd, CObject *poLoc)
{
    if (!poLoc->m_poInner)
        m_poHead = poToAdd;
    else
        poLoc->m_poInner->m_poOuter = poToAdd;

    poToAdd->m_poInner = poLoc->m_poInner;
    poLoc->m_poInner = poToAdd;
    poToAdd->m_poOuter = poLoc;
    poToAdd->m_pol = this;

    m_fModified = true;
    return true;
}

bool CObjList::InsertAfter(CObject *poToAdd, CObject *poLoc)
{
    if (poLoc->m_poOuter == NULL)
        m_poTail = poToAdd;
    else
        poLoc->m_poOuter->m_poInner = poToAdd;
    poToAdd->m_poOuter = poLoc->m_poOuter;
    poLoc->m_poOuter = poToAdd;
    poToAdd->m_poInner = poLoc;
    poToAdd->m_pol = this;
    m_fModified = true;
    return true;
}

CObject *CObjList::FindObjectByFullFileName(char *szName)
{
    if (szName == NULL || *szName == '\0')
        return NULL;
	CObject *poCur = GetInside();
    while (poCur)
    {
        if (!lstrcmpi(szName, poCur->m_szFullFileName))
            return poCur;
        poCur = poCur->m_poOuter;
    }
    return NULL;
}

// save out contents to the specified file
bool CObjList::PersistTo(CFile *pfile)
{
	CObject *poCur = GetInside();
	
	// Force writing out NULL object at end
	while (poCur)
	{
		if (!poCur->PersistTo(pfile))
			return false;
		poCur = poCur->m_poOuter;
	}
	if (!pfile->WriteDWORD(OBJ_ENDOFLIST))
		return false;
	return true;
}

// a little more work than persist to since we need to determine the object types, put them
// in the list, etc
bool CObjList::CreateFrom(CFile *pfile)
{
	DWORD dwType, dwLSN, dwBlockSize, dwGroupId, dwFolderId, dwParentFolderId;
    bool  fWasSelected;
	ULARGE_INTEGER uliSize;
	char szName[MAX_PATH];
	char szFolder[MAX_PATH];

    CObjNodeList onlGroups;
    m_fModified = true;

	while (1)
	{
		// Get next object type
		if (!pfile->ReadDWORD(&dwType))
			return false;
        if (dwType == OBJ_ENDOFLIST)
            break;

		// read all fields to temp vars
		if (!pfile->ReadDWORD(&dwLSN))
			return false;
		if (!pfile->ReadDWORD(&dwBlockSize))
			return false;
		if (!pfile->ReadDWORD(&uliSize.LowPart))
			return false;
		if (!pfile->ReadDWORD(&uliSize.HighPart))
			return false;
		if (!pfile->ReadString(szName))
			return false;
		if (!pfile->ReadString(szFolder))
			return false;
        if (!pfile->ReadDWORD(&dwGroupId))
            return false;

        if (!pfile->ReadDWORD(&dwParentFolderId))
            return false;

		CObject *pobj;
		switch(dwType)
		{
		case OBJ_BE:
			pobj = new CObj_Bookend();
			break;
        case OBJ_VOLDESC:
			pobj = new CObj_VolDesc();

            // If the size *read* was one block, then we've just resized it to 2
            if (dwBlockSize == 1)
                g_fResizedVolDesc = true;
			break;
		case OBJ_SEC:
			pobj = new CObj_Security();
            // We force the file size to match what comes out of the file, not
            // how big we think it should be, so we can hit the placeholder
            // check code and resize if necessary
            pobj->m_uliSize = uliSize;
            pobj->m_dwBlockSize = dwBlockSize;
			break;
		case OBJ_GROUP:
			pobj = new CObj_Group();
			break;
		case OBJ_FILE:
			pobj = new CObj_File(szFolder, szName, uliSize.HighPart, uliSize.LowPart);
			break;
		case OBJ_FOLDER:
			pobj = new CObj_Folder(szFolder, szName);
            if (!pobj)
                FatalError(E_OUTOFMEMORY);

            // Also get and store the id for the folder -- this id is used to
            // map which files belong to this folder.
            if (!pfile->ReadDWORD(&dwFolderId))
                return false;
            ((CObj_Folder*)pobj)->m_dwFolderId = dwFolderId;
            pobj->m_uliSize.QuadPart = uliSize.QuadPart;
            pobj->m_dwBlockSize = dwBlockSize;
			break;
		}
        if (!pobj)
            FatalError(E_OUTOFMEMORY);

        // For memory snapshots, track selection state as well
        if (pfile->m_fMemoryFile)
        {
	        if (!pfile->ReadBYTE((BYTE*)&fWasSelected))
		        return false;
	        if (!pfile->ReadBYTE((BYTE*)&pobj->m_fCMF_Resized))
		        return false;
        }
        else
            fWasSelected = false;        

        pobj->m_dwLSN = dwLSN;
        pobj->m_fWasSelected = fWasSelected;
        pobj->m_dwParentFolderId = dwParentFolderId;
        
        // If the new object is a group, then as it to the list of groups so
        // that subsequently added objects that were initially members of the
        // group can be put back into the group.
        if (dwGroupId)
        {
            if (dwType == OBJ_GROUP)
            {
                // It's a group; add it to the list of groups
                ((CObj_Group*)pobj)->m_dwPersistId = dwGroupId;
                onlGroups.Add(pobj);
            }
            else
            {
                // It's an object that belongs in a group.  Map the group id to
                // the actual group object and add the object to it.  Note that
                // groups are always saved to file before the objects that it
                // contains, so we know that a groupid will match to an
                // existing group.
                CObject *poCur = onlGroups.Head();
                while (poCur)
                {
                    if (((CObj_Group*)poCur)->m_dwPersistId == dwGroupId)
                    {
                        // Found the group
                        pobj->SetGroup((CObj_Group*)poCur);
                        break;
                    }
                    poCur = onlGroups.Next();
                }
            }
        }
		// add new object to end of list
        if (m_fInsideOut)
    		AddToHead(pobj);
        else
    		AddToTail(pobj);
	}

    // In the second pass, map folder ids to folders
    // Create the list of folders (do this since normally far more files than
    // folders, and this allows us to skip unnecessarily searching through files
    // many times).
    CObjNodeList onlFolders;
    CObject *poCur = GetInside();
    while (poCur)
    {
        if (poCur->GetType() == OBJ_FOLDER)
            onlFolders.Add(poCur);
        poCur = poCur->m_poOuter;
    }

    poCur = GetInside();
    while (poCur)
    {
        if (poCur->GetType() == OBJ_FILE || poCur->GetType() == OBJ_FOLDER)
        {
            // Find the folder that maps to the current object's folder id
            CObject *poTest = onlFolders.Head();
            while (poTest)
            {
                if (poTest != poCur)
                {
                    if (poCur->m_dwParentFolderId == ((CObj_Folder*)poTest)->m_dwFolderId)
                    {
                        poCur->m_pof = (CObj_Folder*)poTest;
                        break;
                    }
                }
                poTest = onlFolders.Next();
            }
        }
        poCur = poCur->m_poOuter;
    }
    return true;
}

bool CObject::PersistTo(CFile *pfile)
{
	if (!pfile->WriteDWORD(GetType()))
		return false;
	if (!pfile->WriteDWORD(m_dwLSN))
		return false;
	if (!pfile->WriteDWORD(m_dwBlockSize))
		return false;
	if (!pfile->WriteDWORD(m_uliSize.LowPart))
		return false;
	if (!pfile->WriteDWORD(m_uliSize.HighPart))
		return false;
	if (!pfile->WriteString(m_szName))
		return false;
	if (!pfile->WriteString(m_szFolder))
		return false;

    // If this object is a member of a group, then write out an identifier so
    // that we can determine group containership on reload.  For this identifier,
    // we just use the actual CObj_Group object pointer - we don't use it as a
    // pointer on reload, but instead just as a unique id.
    // If this object is a group, then write out it's memory address instead so
    // that the loading code can map the group id to the group
    if (GetType() == OBJ_GROUP)
    {
        if (!pfile->WriteDWORD((DWORD)this))
            return false;
    }
    else
    {
        if (!pfile->WriteDWORD((DWORD)m_pog))
            return false;
    }

    // Similarly, write out the object's folder object as a unique identifier.
    // If this object is a folder itself, then also write out it's "id".
    if (!pfile->WriteDWORD((DWORD)m_pof))
        return false;
    if (GetType() == OBJ_FOLDER)
        if (!pfile->WriteDWORD((DWORD)this))
            return false;

    // For memory snapshots, track selection state as well
    if (pfile->m_fMemoryFile)
    {
	    if (!pfile->WriteBYTE(m_fWasSelected))
		    return false;
	    if (!pfile->WriteBYTE(m_fCMF_Resized))
		    return false;
    }

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\CObjList.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CObject.h
// Contents:  
// Revisions: 14-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

class CObjNode
{
public:
    CObject *m_pobj;
    CObjNode *m_ponNext;
    CObjNode *m_ponPrev;
};

// PlaceableObject list
class CObjList
{
public:
    CObjList();
    ~CObjList();
    CObjNode *GetObjNode(CObject *pobj);

    CObject *GetLast() { m_ponCur = m_ponTail; return GetCur(); }
    CObject *GetPrev() {if (m_ponCur != NULL) m_ponCur = m_ponCur->m_ponPrev; return GetCur();}
    CObject *GetFirst() { m_ponCur = m_ponHead; return GetCur(); }
    CObject *GetNext() {if (m_ponCur != NULL) m_ponCur = m_ponCur->m_ponNext; return GetCur();}
    CObject *GetCur() {if (m_ponCur == NULL) return NULL; else return m_ponCur->m_pobj; }
    void Reset();
    void Add(CObject *ppo);
    void Remove(CObject *ppo);
    bool InsertBefore(CObject *poToAdd, CObject *poLoc);
    bool InsertAfter(CObject *poToAdd, CObject *poLoc);

	bool PersistTo(HANDLE hfileFLD);
	bool CreateFrom(HANDLE hfileFLD);;
private:
    CObjNode *m_ponHead;
    CObjNode *m_ponTail;
    CObjNode *m_ponCur;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\CStatusBar.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      cstatusbar.h
// Contents:  
// Revisions: 14-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

class CStatusBar : public CInitedObject
{
public:
    bool Init(CWindow *pwindow);
    ~CStatusBar();

    void SetText(int iRegion, char *szText);
    void MoveTo(int nX, int nY, int nW, int nH);

    void SetNumParts(int nParts);

    HWND m_hwnd;

private:
    int m_nParts;
    int m_nW;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\CSplitter.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      csplitter.h
// Contents:  
// Revisions: 13-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

class CWindow;

class CSplitter
{
public:
    CSplitter(CWindow *pwindow, int nStartPos);
    void HandleMouseDown(int nClientX, int nClientY);
    void HandleMouseMove(int nClientX, int nClientY);
    void HandleMouseUp(int nClientX, int nClientY);
    int GetPos();

private:
    bool IsMouseOver(int nClientX, int nClientY);

    bool m_fDragging;
    int m_nPos;
    CWindow *m_pwindow;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\CStatusBar.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      cstatusbar.cpp
// Contents:  
// Revisions: 14-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStatusBar::CStatusBar
// Purpose:   
// Arguments: 
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CStatusBar::Init(CWindow *pwindow)
{
    m_nW = 100;
    // Create the status bar
    m_hwnd = CreateStatusWindow(WS_CHILD | WS_VISIBLE | CCS_BOTTOM | SBARS_SIZEGRIP, NULL,
                                pwindow->m_hwnd, 2);

    if (!m_hwnd)
        return false;

    SetNumParts(1);

    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStatusBar::~CStatusBar
// Purpose:   
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CStatusBar::~CStatusBar()
{
    if (m_hwnd)
        DestroyWindow(m_hwnd);
}

void CStatusBar::SetNumParts(int nParts)
{
    m_nParts = nParts;
    
    int rgn1[] = {-1};
    int rgn2[] = {m_nW/2-1, -1};
    if (nParts == 1)
        SendMessage(m_hwnd, SB_SETPARTS, nParts, (LPARAM) (LPINT) rgn1);
    else
        SendMessage(m_hwnd, SB_SETPARTS, nParts, (LPARAM) (LPINT) rgn2);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStatusBar::SetText
// Purpose:   
// Arguments: 
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CStatusBar::SetText(int iRegion, char *szText)
{
    SendMessage(m_hwnd, SB_SETTEXT, iRegion, (LPARAM) szText);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStatusBar::MoveTo
// Purpose:   
// Arguments: 
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CStatusBar::MoveTo(int nX, int nY, int nW, int nH)
{
    MoveWindow(m_hwnd, nX, nY, nW, nH, FALSE);

    m_nW = nW;
    // Set the size of the status bar areas
    int rgnRegionSizes[2];
    if (m_nParts == 1)
        rgnRegionSizes[0] = -1;
    else
    {
        rgnRegionSizes[0] = nW / 2-2;
        rgnRegionSizes[1] = -1;
    }
    SendMessage(m_hwnd, SB_SETPARTS, m_nParts, (LPARAM)rgnRegionSizes);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\CToolbar.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CToolbar.cpp
// Contents:  
// Revisions: 14-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"

DWORD g_rgdwTooltip[] = {IDS_TOOLBAR_NEW, IDS_TOOLBAR_OPEN, IDS_TOOLBAR_SAVE, 0,
                         0, IDS_TOOLBAR_GROUP, IDS_TOOLBAR_UNGROUP, 0,
                         IDS_TOOLBAR_EMULATE, IDS_TOOLBAR_PREMASTER,
                         IDS_TOOLBAR_BFE, 0, IDS_TOOLBAR_VIEW0, IDS_TOOLBAR_VIEW1,
                         IDS_TOOLBAR_VIEWBOTH, IDS_TOOLBAR_VIEWSCRATCH, 0, IDS_TOOLBAR_VIEWRESCAN};

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CToolBar::CToolBar
// Purpose:   
// Arguments: 
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CToolBar::Init(CWindow *pwindow)
{
    TBBUTTON rgtb[] =  {
        {STD_FILENEW, ID_FILE_NEW, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {STD_FILEOPEN, ID_FILE_OPEN, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {STD_FILESAVE, ID_FILE_SAVE, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {0, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},
        {0, ID_EDIT_GROUP, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {0, ID_EDIT_UNGROUP, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {0, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},
        {0, ID_VIEW_LAYER0, TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, 0L, 0},
        {0, ID_VIEW_LAYER1, TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, 0L, 0},
        {0, ID_VIEW_BOTHLAYERS, TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, 0L, 0},
        {0, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},
        {0, ID_VIEW_SCRATCHAREA, TBSTATE_ENABLED, TBSTYLE_CHECK, 0L, 0},
        {0, ID_VIEW_RESCANLAYOUT, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {0, 0, TBSTATE_ENABLED, TBSTYLE_SEP, 0L, 0},
        {0, ID_TOOLS_EMULATE, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        {0, ID_TOOLS_PREMASTERTAPE, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
    }; 

    // Create the Tool bar
    m_hwnd = CreateToolbarEx (pwindow->m_hwnd, WS_CHILD | WS_BORDER | WS_VISIBLE | TBSTYLE_TOOLTIPS |TBSTYLE_FLAT, 
                              1, 10, (HINSTANCE)HINST_COMMCTRL, IDB_STD_SMALL_COLOR, 
                              (LPCTBBUTTON)&rgtb, 4, 0, 0, 16, 16, sizeof (TBBUTTON));
    if (!m_hwnd)
        return false;

    // Add the non-standard buttons
    TBADDBITMAP tb;
    tb.hInst = pwindow->m_hinst;
    tb.nID = BMP_TOOLBAR;
    int iNewBmps = SendMessage (m_hwnd, TB_ADDBITMAP, 13, (LPARAM)&tb);

    rgtb[4].iBitmap = iNewBmps  + 0;
    rgtb[5].iBitmap = iNewBmps  + 1;
    rgtb[7].iBitmap = iNewBmps  + 2;
    rgtb[8].iBitmap = iNewBmps  + 3;
    rgtb[9].iBitmap = iNewBmps  + 4;
    rgtb[11].iBitmap = iNewBmps + 5;
    rgtb[12].iBitmap = iNewBmps + 6;
    rgtb[14].iBitmap = iNewBmps + 7;
    rgtb[15].iBitmap = iNewBmps + 8;

    SendMessage (m_hwnd, TB_ADDBUTTONS, 12, (LONG) &rgtb[4]);

    return true;
}

void CToolBar::CheckButton(int idButton, bool fDown)
{
    SendMessage(m_hwnd, TB_CHECKBUTTON, idButton, MAKELONG(fDown, 0));
}

void CToolBar::EnableButton(int idButton, bool fEnabled)
{
    SendMessage(m_hwnd, TB_SETSTATE, idButton, MAKELONG(fEnabled ? TBSTATE_ENABLED : 0, 0));
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CToolBar::~CToolBar
// Purpose:   
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CToolBar::~CToolBar()
{
    if (m_hwnd)
        DestroyWindow(m_hwnd);
}

void CToolBar::MoveTo(int nX, int nY, int nW, int nH)
{
    WINDOWPLACEMENT wp;
    wp.length = sizeof(wp);
    wp.rcNormalPosition.right = nW;
    SetWindowPlacement(m_hwnd, &wp);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\CWindow.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      cwindow.cpp
// Contents:  
// Revisions: 13-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ GLOBAL VARIABLES ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// g_pwindowTemp        -- Temporary pointer used to circumvent CreateWindow annoyances (see below).
CWindow *g_pwindowTemp = NULL;


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ LOCAL VARIABLES +++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

BOOL CALLBACK WndProc(HWND hwnd, UINT uMsg, WPARAM wparam, LPARAM lparam) ;


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWindow::InitInstance
// Purpose:   Register our class and then create and show our window.
// Arguments: hinst         -- The handle to this instance of the application
//            nCmdShow      -- Default visibility of the application (maximized, minimized, etc)
// Return:    true if successful.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CWindow::InitInstance(CWindow *pwindowParent)
{
    WNDCLASSEX wcex;
    // Register the class for the app's window.
    wcex.cbSize         = sizeof(WNDCLASSEX); 
    wcex.style          = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc    = (WNDPROC)::WndProc;
    wcex.hInstance      = m_hinst;
    wcex.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wcex.hbrBackground  = NULL;
    wcex.lpszClassName  = m_szName;
    wcex.lpszMenuName   = m_szMenuName;
    wcex.cbClsExtra     = 0;
    wcex.cbWndExtra     = 0;
    wcex.hIcon          = LoadIcon(m_hinst, "IDC_MAIN");
    wcex.hIconSm        = 0;
    if (!RegisterClassEx(&wcex))
        return NULL;

    // Create the app's window.
    m_hwnd = CreateWindow(m_szName, "", WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0,
                          CW_USEDEFAULT, 0,
                          pwindowParent ? pwindowParent->m_hwnd : NULL, NULL,
                          m_hinst, NULL);
    if (m_hwnd == NULL)
        return false;

    return true;
}

bool CWindow::GetRegValue(HKEY hkey, char *szValue, long *pn)
{
    char szFull[1000];
    DWORD dwSize = 4;

    // prepend the window's name to make it unique
    sprintf(szFull, "%s-%s",m_szName, szValue);
    return RegQueryValueEx(hkey, szFull, NULL, NULL, (BYTE*)pn, &dwSize) == ERROR_SUCCESS;
}

bool CWindow::SetRegValue(HKEY hkey, char *szValue, long n)
{
    char szFull[1000];
    BYTE *pby = (BYTE*)&n;

    // prepend the window's name to make it unique
    sprintf(szFull, "%s-%s",m_szName, szValue);

    return RegSetValueEx(hkey, szFull, 0, REG_DWORD, pby, 4) == ERROR_SUCCESS;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWindow::SetLastKnownPos
// Purpose:   Read the last known position out of the registry and set it
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CWindow::SetLastKnownPos()
{
    HKEY hkey;
    RECT rc;
    int nScreenWidth, nScreenHeight;

    // UNDONE: Verify that I should be creating my own key
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\XboxSDK\\xbLayout"), 0,
                     KEY_READ, &hkey) != ERROR_SUCCESS)
        return;
    
    if (!GetRegValue(hkey, "LastKnownX1", &rc.left))   return;
    if (!GetRegValue(hkey, "LastKnownY1", &rc.top))    return;
    if (!GetRegValue(hkey, "LastKnownX2", &rc.right))  return;
    if (!GetRegValue(hkey, "LastKnownY2", &rc.bottom)) return;
    RegCloseKey(hkey);

    // Verify the values place the window in a visible location
    HDC hdc = GetDC(m_hwnd);
    nScreenWidth  = GetDeviceCaps(hdc, HORZRES);
    nScreenHeight = GetDeviceCaps(hdc, VERTRES);
    ReleaseDC(m_hwnd, hdc);

    if (rc.left > nScreenWidth - 4 || rc.right < 4 || rc.bottom < 4 || rc.top > nScreenHeight + 4)
        return;

    MoveWindow(m_hwnd, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, TRUE);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWindow::StorePosition
// Purpose:   Stores the current position of the window in the registry
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CWindow::StorePosition()
{
    HKEY hkey;
    RECT rc;

    GetWindowRect(m_hwnd, &rc);

    if (rc.left == 0xcccccccc)
        DebugBreak();

    // Open/Create the key
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\XboxSDK\\xbLayout"), 0,
                 NULL, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE, NULL, &hkey, NULL) != ERROR_SUCCESS)
        return;

    if (!SetRegValue(hkey, "LastKnownX1", rc.left))   return;
    if (!SetRegValue(hkey, "LastKnownY1", rc.top))    return;
    if (!SetRegValue(hkey, "LastKnownX2", rc.right))  return;
    if (!SetRegValue(hkey, "LastKnownY2", rc.bottom)) return;
    RegCloseKey(hkey);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWindow::CWindow
// Purpose:   
// Arguments: 
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CWindow::CWindow(char *szName, DWORD dwWindowCreationFlags, HINSTANCE hinst)
{
    // Track this instance of the application
    m_hinst = hinst;

    // Store our name
    strcpy(m_szName, szName);
    m_dwWindowCreationFlags = dwWindowCreationFlags;
}

bool CWindow::Init(CWindow *pwindowParent)
{
    // No other window can be in the process of being created when this window is created, due to
    // the lack of reentrancy imposed by g_pwindowTemp.
    assert(g_pwindowTemp == NULL);

    // Set the global CWindow pointer to point at us so that ::WndProc can determine which CWindow
    // the current message belongs to.  This use of a global variable is necessary due to the
    // messages that the OS sends to ::WndProc before we can stuff a pointer to ourselves into the
    // window (see above).
    g_pwindowTemp = this;

    // Initialize our class and create our window
    if (!InitInstance(pwindowParent))
    {
        // A thoroughly unrecoverable (and unexpected) error occurred.  The user's machine is fubar
        MessageBox(NULL, "This application failed to initialize.  Please restart your computer and "\
                   "try again.", "Failed to start", MB_ICONEXCLAMATION | MB_APPLMODAL | MB_OK);
        return false;
    }

    // Tell the newly created Win32 window that it "belongs" to us.  This is necessary so that 
    // the static WndProc that Windows calls (::WndProc above) can determine that it came from us,
    // and call the WndProc of this instance of CWindow
    SetWindowLong(m_hwnd, GWL_USERDATA, (long)this);

    // Now that our pointer has been stuffed into the window, we can stop using the global var.
    g_pwindowTemp = NULL;

    // Initialize keyboard accelerators
    m_haccel = LoadAccelerators(m_hinst, (LPCTSTR)IDC_ACCEL);

    // Mark that we successfully initialized
    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWindow::~CWindow
// Purpose:   
// Arguments: 
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CWindow::~CWindow()
{
    // At this point, m_hwnd has *already* been destroyed, so don't do anything that uses it!
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWindow::Run
// Purpose:   
// Arguments: 
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
int CWindow::Run()
{
    MSG msg;

    // Just drop straight into a Win32 message loop.
    while (GetMessage(&msg, NULL, 0, 0)) 
    {
        if (!TranslateAccelerator(m_hwnd, m_haccel, &msg)) 
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    // When here, we have exited the application.
    return msg.wParam;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  WndProc
// Purpose:   This is the static callback for the CWindow class.  It receives all messages from the
//            OS (ie user input, callbacks, etc).  We simply take the message, determine which
//            window it actually belongs to, and pass it on to the appropriate CWindow object.
// Arguments: hwnd              -- The handle to the window that the message is intended for.
//            uMsg              -- The message being reported.
//            wparam            -- Parameter 1 (message-specific)
//            lparam            -- Parameter 2 (message-specific)
// Return:    Result of the message processing - depends on the message sent.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL CALLBACK WndProc(HWND hwnd, UINT uMsg, WPARAM wparam, LPARAM lparam) 
{
    CWindow *pwindow;

    // When a CWindow calls CreateWindow to create the Win32 windo, the OS sends a number of
    // messages to WndProc before the CreateWindow returns (WM_CREATE, WM_SIZE, etc).
    // Because we haven't returned from the CreateWindow call, we can't set which CWindow hwnd is
    // actually referring to.  Therefore, we need to use a temporary global variable to point at
    // the correct CWindow.  If that variable is non-NULL, then we know that we haven't returned from
    // the CreateWindow call, and that we should use it instead.  If the variable is NULL, then the
    // CWindow has had the opportunity to cram a pointer to itself into the window. This would
    // create issues if two windows are created at the exact same time, but we never do that here.
    if (g_pwindowTemp != NULL)
    {
        pwindow = g_pwindowTemp;

        // We haven't returned from CreateWindow yet, so we haven't set our hwnd.  Get around this
        // by placing the passed-in hwnd into the window's hwnd.
        pwindow->m_hwnd = hwnd;
    }
    else
    {
        // Determine which CWindow this message should be sent to.  We stored a pointer to the
        // window in the hwnd's 'user' area.  Extract it now.
        pwindow = (CWindow*)GetWindowLong(hwnd, GWL_USERDATA);
        if (!pwindow)
            return false;
    }    

    // Pass the message on to the appropriate CWindow and let it handle it.
    return pwindow->WndProc(uMsg, wparam, lparam);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWindow::WndProc
// Purpose:   This is the instance-specific window message handler.  There are some message that
//            we handle here (in the base class), while others are ignored (and handled by the OS).
// Arguments: uMsg              -- The message being reported.
//            wparam            -- Parameter 1 (message-specific)
//            lparam            -- Parameter 2 (message-specific)
// Return:    Result of the message processing - depends on the message sent.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL CWindow::WndProc(UINT uMsg, WPARAM wparam, LPARAM lparam) 
{
    switch (uMsg) 
    {
    case WM_CREATE:
        return 0;

  //  case WM_ERASEBKGND:
//        // Don't erase the background
    //    return 1;

    case WM_SIZE:
        OnSize();
        return 1;
        
    case WM_COMMAND:
        if (ButtonPressed(LOWORD(wparam)))
            return 0;
        break;

    case WM_NOTIFY:
        return OnNotify(wparam, lparam);
    }

    // Let derived class handle all unhandled messages
    return DerivedWndProc(uMsg, wparam, lparam);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWindow::GetCaption
// Purpose:   Generate and return a pointer to the current caption for the xbLayout window
// Arguments: None
// Return:    Pointer to the current caption.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CWindow::GetCaption(char *sz)
{
    GetWindowText(m_hwnd, sz, 1024);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWindow::SetCaption
// Purpose:   
// Arguments: None
// Return:    Pointer to the current caption.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CWindow::SetCaption(char *sz)
{
    SetWindowText(m_hwnd, sz);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWindow::GetChildControlRect
// Purpose:   Gets the rectangle for the specified control
// Arguments: 
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CWindow::GetChildControlRect(HWND hwndControl, RECT *prc)
{
    GetClientRect(hwndControl, prc);
    MapWindowPoints(hwndControl, m_hwnd, (LPPOINT)prc, 2);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\CToolbar.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      cToolbar.h
// Contents:  
// Revisions: 14-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

class CToolBar : public CInitedObject
{
public:
    bool Init(CWindow *pwindow);
    ~CToolBar();
    HWND m_hwnd;

    void CheckButton(int iButton, bool fDown);
    void EnableButton(int idButton, bool fEnabled);
    void MoveTo(int nX, int nY, int nW, int nH);
};

DWORD g_rgdwTooltip[];
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\CWindow_Main.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CWindow_Main.h
// Contents:  
// Revisions: 13-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#define LV_LAYER0  0
#define LV_LAYER1  1
#define LV_SCRATCH 2

class CWindow_Main : public CWindow
{
public:
    CWindow_Main(DWORD dwWindowCreationFlags, HINSTANCE hinst);
    BOOL DerivedWndProc(UINT uMsg, WPARAM wparam, LPARAM lparam);
    BOOL ButtonPressed(int idButton);
    bool Init();
    void Uninit();

    void OnSize();
    bool OnNotify(WPARAM wparam, LPARAM lparam);
    void SetCurLayer(int nLayer);

    CListView *m_rgplv[3];
	CListView *m_plvCur;
    CStatusBar *m_pstatusbar;
    CToolBar *m_ptoolbar;
    CWindow_Scratch *m_pscratch;
    CColorBar *m_pcolbarLeft, *m_pcolbarMid, *m_pcolbarRight;

    int GetFocusLayer();
    void FinishedDrag(CListView *plv, POINT pt);
    void DragMove(POINT pt);
    void EraseAllSelectionBars();

    void SetGroupable(bool fGroupable);
    void SetUngroupable(bool fUngroupable);
    void OnGroup();
    void OnUngroup();
    void UpdateStatusBar();
    //void UpdateScratch();

    int m_nCurLayerView;
    bool CheckModifiedFiles();

private:
    // Each window has exactly one workspace.
    CWorkspace *m_pws;

    CListView *GetLVFromHwnd(HWND hwnd);

    bool CMF_HandleFiles();
    bool m_fCMF_FilesInUnplaced;
    bool m_fCMF_FilesResized;

    bool m_fDefaultXbePresent;
    int WhichListViewUnderPt(POINT pt);
    bool BuildForEmulation();
    bool CheckNeedBuildForEmulation();
    char m_szWorkingDir[MAX_PATH];
    HWND m_hwndTip;
};

extern HINSTANCE g_hinst;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\CWindow.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      cwindow.hpp
// Contents:  
// Revisions: 13-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Window creation flags
#define FLAG_WINDOW_POS_LASTKNOWN 0x00000001

class CWindow
{
public:
    CWindow(char *szName, DWORD dwWindowCreationFlags, HINSTANCE hinst);
    virtual ~CWindow();
    virtual bool Init(CWindow *pwindowParent);
    virtual void Uninit() {}
    int Run();

    // WndProc          -- Main message handler.  Public since the static ::WndProc function needs
    //                     to call into it.
    BOOL WndProc(UINT uMsg, WPARAM wparam, LPARAM lparam);

    // m_hwnd           -- Handle to our Win32 windo.  Public since the static ::WndProc function
    //                     needs to reference it in calls to WndProc before our CreateWindow
    //                     function has completed.
    HWND m_hwnd;

    HINSTANCE m_hinst;

    bool GetRegValue(HKEY hkey, char *szValue, long *pn);
    bool SetRegValue(HKEY hkey, char *szValue, long n);

    virtual void OnSize() = NULL;
    virtual BOOL DerivedWndProc(UINT uMsg, WPARAM wparam, LPARAM lparam) {return DefWindowProc(m_hwnd, uMsg, wparam, lparam);}
    virtual BOOL ButtonPressed(int idButton) { return FALSE; }

   
    virtual bool OnNotify(WPARAM wparam, LPARAM lparam) {return 0;}

    virtual void FinishedDrag(CListView *plv, POINT pt) {}

    virtual void DragMove(POINT pt) {}
    virtual void EraseAllSelectionBars() {}
    virtual void SetGroupable(bool fGroupable) {}
    virtual void SetUngroupable(bool fUngroupable) {}

    RECT m_rc;
    void SetCaption(char *sz);

protected:

    void GetChildControlRect(HWND hwndControl, RECT *prc);

    void SetLastKnownPos();
    void StorePosition();

    void GetCaption(char *sz);
    char m_szName[256];
    char m_szMenuName[256];
    DWORD m_dwWindowCreationFlags;

private:
    bool InitInstance(CWindow *pwindowParent);
    HACCEL m_haccel;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\CWindow_Scratch.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CWindow_Scratch.h
// Contents:  
// Revisions: 14-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

class CWindow_Scratch : public CWindow
{
public:
    CWindow_Scratch(DWORD dwWindowCreationFlags, CWindow *pwindowParent);
    ~CWindow_Scratch();
    bool Init();
    void Uninit();

    void ToggleView();
    void AddObject(CObject *pobj);
    void OnSize();

    bool m_fVisible;
    void FinishedDrag(CListView *plv, POINT pt);
    void DragMove(POINT pt);
    void EraseAllSelectionBars();
    bool InsertObjectList(CObjList *pol);

    bool OnNotify(WPARAM wparam, LPARAM lparam);
    void Reset() {m_plistview->Clear(); }
    BOOL DerivedWndProc(UINT uMsg, WPARAM wparam, LPARAM lparam);
    
    bool PersistTo(CFile *pfile);
    bool CreateFrom(CFile *pfile);

    bool HandleFileRemoval(CObjList *pol);
    void SetGroupable(bool fGroupable);
    void SetUngroupable(bool fUngroupable);
    CObject *FindObjectByFullFileName(char *szName);

    friend class CWindow_Main;
    CListView *m_plistview;
private:
    CWindow *m_pwindowParent;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\CWindow_Main.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CWindow_Main.cpp
// Contents:  
// Revisions: 13-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"

// <xboxverp.h>     -- Contains Xbox build-environment versioning information
#include <xboxverp.h>
#include <direct.h>

extern DWORD BlockSize(ULONGLONG ullSize);


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ DEFINES  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// COLBAR_WIDTH -- Width of the left and right ColorBar objects
#define COLBAR_WIDTH 15


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ GLOBAL VARIABLES ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// AboutDlgProc -- Dialog procedure for the about box.
extern LRESULT CALLBACK AboutDlgProc(HWND hDlg, UINT message, WPARAM wParam,
                                     LPARAM lParam);

HINSTANCE g_hinst;


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWindow_Main::CWindow_Main
// Purpose:   CWindow_Main constructor.  Doesn't do anything except call the
//            base CWindow constructor.
// Arguments: dwWindowCreationFlags -- window creation flags
//            hinst                 -- Handle to the application instance.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CWindow_Main::CWindow_Main(DWORD dwWindowCreationFlags, HINSTANCE hinst) :
                            CWindow("Main", dwWindowCreationFlags, hinst)
{
    g_hinst = hinst;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWindow_Main::Init
// Purpose:   Initializes the window object.
// Arguments: None
// Return:    'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CWindow_Main::Init()
{
    srand(time(NULL));

    // Set our menu name (necessary for base class initialization)
    strcpy(m_szMenuName, "XBLAYOUT");

    // Track which directory we ran from (necessary for help functionality);
    _getcwd(m_szWorkingDir, MAX_PATH);

    // Do base class initialization
    if (!CWindow::Init(NULL))
        return false;

    m_hwndTip = CreateWindowEx(NULL, TOOLTIPS_CLASS, NULL,
                            WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP,
                            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                            CW_USEDEFAULT, m_hwnd, NULL, g_hinst, NULL);


    // The window has been created.  Add the various UI elements
    m_rgplv[LV_LAYER0]= new CListView();
    if (!m_rgplv[LV_LAYER0])
        FatalError(E_OUTOFMEMORY);
    if (!m_rgplv[LV_LAYER0]->Init(this, false, true))
        return false;

    m_rgplv[LV_LAYER1] = new CListView();
    if (!m_rgplv[LV_LAYER1])
        FatalError(E_OUTOFMEMORY);
    if (!m_rgplv[LV_LAYER1]->Init(this, true, true))
        return false;

    m_pstatusbar = new CStatusBar();
    if (!m_pstatusbar)
        FatalError(E_OUTOFMEMORY);
    if (!m_pstatusbar->Init(this))
        return false;
    
    m_ptoolbar   = new CToolBar();
    if (!m_ptoolbar)
        FatalError(E_OUTOFMEMORY);
    if (!m_ptoolbar->Init(this))
        return false;

    m_pscratch   = new CWindow_Scratch(FLAG_WINDOW_POS_LASTKNOWN, this);
    if (!m_pscratch)
        FatalError(E_OUTOFMEMORY);
    if (!m_pscratch->Init())
        return false;

    m_pcolbarLeft = new CColorBar();
    if (!m_pcolbarLeft)
        FatalError(E_OUTOFMEMORY);
    if (!m_pcolbarLeft->Init(this, RGB(255, 0, 0), RGB(0, 255, 0)))
        return false;

    m_pcolbarRight = new CColorBar();
    if (!m_pcolbarRight)
        FatalError(E_OUTOFMEMORY);
    if (!m_pcolbarRight->Init(this, RGB(0, 255, 0), RGB(255, 0, 0)))
        return false;

    m_pcolbarMid = new CColorBar();
    if (!m_pcolbarMid)
        FatalError(E_OUTOFMEMORY);
    if (!m_pcolbarMid->Init(this, RGB(212, 208, 200), RGB(212, 208, 200)))
        return false;

    // Keep a local pointer to the scratch window's listview control so that we
    // have a contiguous array of listviews for easy reference
    m_rgplv[LV_SCRATCH] = m_pscratch->m_plistview;

    m_rgplv[LV_LAYER0]->m_iLayer  = LV_LAYER0;
    m_rgplv[LV_LAYER1]->m_iLayer  = LV_LAYER1;
    m_rgplv[LV_SCRATCH]->m_iLayer = LV_SCRATCH;

    // At the start, grouping and ungrouping aren't possible (since nothing's
    // selected).
    SetGroupable(false);
    SetUngroupable(false);


    // Create our workspace.  It will automatically populate our controls
    m_pws = new CWorkspace(this);
    if (!m_pws)
        FatalError(E_OUTOFMEMORY);

    if (!m_pws->Init())
        return false;

	// Start out looking at the layer 0 listview
	SetCurLayer(0);

    // Set the caption of the whole window.
    char szCaption[1024];
    LoadString(m_hinst, IDS_WINDOW_CAPTION, szCaption, 1024);
    SetCaption(szCaption);


    // Set the window's initial size and positioned if it was previously known
    if (m_dwWindowCreationFlags & FLAG_WINDOW_POS_LASTKNOWN)
        SetLastKnownPos();
    
    // Finally make the window visible
    ShowWindow(m_hwnd, SW_SHOW);

    // Until something is loaded, we can't do certain tasks
    HMENU hmenu = GetMenu(m_hwnd);
    m_ptoolbar->EnableButton(ID_TOOLS_PREMASTERTAPE,     false);
    m_ptoolbar->EnableButton(ID_TOOLS_EMULATE,           false);
    m_ptoolbar->EnableButton(ID_TOOLS_BUILDFOREMULATION, false);
    m_ptoolbar->EnableButton(ID_FILE_SAVE, false);
    m_ptoolbar->EnableButton(ID_FILE_SAVEAS, false);
    m_ptoolbar->EnableButton(ID_VIEW_RESCANLAYOUT, false);
    EnableMenuItem(hmenu, ID_TOOLS_PREMASTERTAPE,     MF_GRAYED);
    EnableMenuItem(hmenu, ID_TOOLS_EMULATE,           MF_GRAYED);
    EnableMenuItem(hmenu, ID_TOOLS_BUILDFOREMULATION, MF_GRAYED);
    EnableMenuItem(hmenu, ID_FILE_SAVE,     MF_GRAYED);
    EnableMenuItem(hmenu, ID_FILE_SAVEAS,     MF_GRAYED);
    EnableMenuItem(hmenu, ID_VIEW_RESCANLAYOUT, MF_GRAYED);
    CheckMenuItem(hmenu, ID_VIEW_SCRATCHAREA, MF_UNCHECKED);

#ifdef _DEBUG
    // Force loading a particular root loc for debugging purposes UNDONE: Remove
    m_pws->SetDVDRoot("C:\\DemoUS", true);
    //m_pws->SetDVDRoot("C:\\d", true);
//    ListView_SetItemState(m_rgplv[LV_LAYER0]->GetHwnd(), 20, LVNI_SELECTED, LVNI_SELECTED);
#endif

    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWindow_Main::Uninit
// Purpose:   CWindow_Main uninitialization function.  Frees up all used memory
//            and prepares the CWindow_Main object for deallocation.
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CWindow_Main::Uninit()
{
    // Delete all allocated objects
    if (m_rgplv[LV_LAYER0]) delete m_rgplv[LV_LAYER0];
    if (m_rgplv[LV_LAYER1]) delete m_rgplv[LV_LAYER1];
    if (m_pstatusbar)    delete m_pstatusbar;
    if (m_ptoolbar)      delete m_ptoolbar;
    if (m_pcolbarLeft)   delete m_pcolbarLeft;
    if (m_pcolbarRight)  delete m_pcolbarRight;
    if (m_pcolbarMid)    delete m_pcolbarMid;
    if (m_pws)           delete m_pws;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWindow_Main::DerivedWndProc
// Purpose:   Handle messages that are specific to this derived window.  Most
//            common messages are already automatically sent to the appropriate
//            "OnFOO" functions.
// Arguments: uMsg              -- The message being reported.
//            wparam            -- Parameter 1 (message-specific)
//            lparam            -- Parameter 2 (message-specific)
// Return:    Result of the message processing - depends on the message sent.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL CWindow_Main::DerivedWndProc(UINT uMsg, WPARAM wparam, LPARAM lparam) 
{
    switch (uMsg) 
    {
    case WM_GETMINMAXINFO:
        // The window is being resized. Don't let its size drop below threshold
        ((MINMAXINFO*)lparam)->ptMinTrackSize.x = 240;
        ((MINMAXINFO*)lparam)->ptMinTrackSize.y = 95;
        return 0;

    case WM_DRAWITEM:
        // An item in one of the owner-draw listviews needs to be updated.
        return m_pws->HandleDrawItem(wparam, lparam);
    
    case WM_CLOSE:
        // User wants to close the application.  Verify they don't want to lose
        // modified data.
        if (!m_pws->Close())
        {
            // Return that we didn't handle the message, and that closing should
            // not actually happen.
            return 1;
        }

        // Store the last position of the window
        StorePosition();
        m_pscratch->StorePosition();

        // Prepare the window for destructions
        Uninit();

        // Tell the OS to destroy this window
        PostQuitMessage(0);

        // Return that we handled the message
        return 0;
    }

    // Let windows handle the rest of the messages
    return DefWindowProc(m_hwnd, uMsg, wparam, lparam);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWindow_Main::ButtonPressed
// Purpose:   This function is called when a button is pressed or a menu item
//            is selected.  Pass the message on to the appropriate function(s).
// Arguments: idButton      -- The resource identifier of the button pressed.
// Return:    'true' if button was handled, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL CWindow_Main::ButtonPressed(int idButton)
{
	PROCESS_INFORMATION pInfo;
	STARTUPINFO         sInfo;
    char sz[MAX_PATH + 30], sz2[MAX_PATH + 30];
    HMENU hmenu = GetMenu(m_hwnd);
    bool fRet;
    
    switch(idButton)
    {
    case ID_FILE_NEW:
        // Try to close the current workspace -- user given option of not
        // closing if modified.
        SendMessage(m_rgplv[LV_LAYER0]->GetHwnd(),   WM_SETREDRAW, 0, 0);
        SendMessage(m_rgplv[LV_LAYER1]->GetHwnd(),   WM_SETREDRAW, 0, 0);
        SendMessage(m_rgplv[LV_SCRATCH]->GetHwnd(),  WM_SETREDRAW, 0, 0);
        if (m_pws->Close())
            m_pws->New();
        SendMessage(m_rgplv[LV_LAYER0]->GetHwnd(),   WM_SETREDRAW, 1, 0);
        SendMessage(m_rgplv[LV_LAYER1]->GetHwnd(),   WM_SETREDRAW, 1, 0);
        SendMessage(m_rgplv[LV_SCRATCH]->GetHwnd(),  WM_SETREDRAW, 1, 0);
        m_ptoolbar->EnableButton(ID_TOOLS_PREMASTERTAPE,     true);
        m_ptoolbar->EnableButton(ID_TOOLS_EMULATE,           true);
        m_ptoolbar->EnableButton(ID_TOOLS_BUILDFOREMULATION, true);
        m_ptoolbar->EnableButton(ID_FILE_SAVE, true);
        m_ptoolbar->EnableButton(ID_FILE_SAVEAS, true);
        m_ptoolbar->EnableButton(ID_VIEW_RESCANLAYOUT, true);
        EnableMenuItem(hmenu, ID_TOOLS_PREMASTERTAPE,     MF_ENABLED);
        EnableMenuItem(hmenu, ID_TOOLS_EMULATE,           MF_ENABLED);
        EnableMenuItem(hmenu, ID_TOOLS_BUILDFOREMULATION, MF_ENABLED);
        EnableMenuItem(hmenu, ID_FILE_SAVE,     MF_ENABLED);
        EnableMenuItem(hmenu, ID_FILE_SAVEAS,     MF_ENABLED);
        EnableMenuItem(hmenu, ID_VIEW_RESCANLAYOUT,     MF_ENABLED);
        return TRUE;

    case ID_FILE_OPEN:
        // Try to close the current workspace -- user given option of not
        // closing if modified.
        SendMessage(m_rgplv[LV_LAYER0]->GetHwnd(),   WM_SETREDRAW, 0, 0);
        SendMessage(m_rgplv[LV_LAYER1]->GetHwnd(),   WM_SETREDRAW, 0, 0);
        SendMessage(m_rgplv[LV_SCRATCH]->GetHwnd(),  WM_SETREDRAW, 0, 0);
        if (m_pws->Close())
        {
            fRet = m_pws->Open();
            if (!fRet)
            {
                // Failed to open
                m_pws->Reset();
            }
        }
        else
            fRet = true;
        SendMessage(m_rgplv[LV_LAYER0]->GetHwnd(),   WM_SETREDRAW, 1, 0);
        SendMessage(m_rgplv[LV_LAYER1]->GetHwnd(),   WM_SETREDRAW, 1, 0);
        SendMessage(m_rgplv[LV_SCRATCH]->GetHwnd(),  WM_SETREDRAW, 1, 0);
        if (fRet)
        {
            m_ptoolbar->EnableButton(ID_TOOLS_PREMASTERTAPE,     true);
            m_ptoolbar->EnableButton(ID_TOOLS_EMULATE,           true);
            m_ptoolbar->EnableButton(ID_TOOLS_BUILDFOREMULATION, true);
            m_ptoolbar->EnableButton(ID_FILE_SAVE, true);
            m_ptoolbar->EnableButton(ID_FILE_SAVEAS, true);
            m_ptoolbar->EnableButton(ID_VIEW_RESCANLAYOUT, true);
            EnableMenuItem(hmenu, ID_TOOLS_PREMASTERTAPE,     MF_ENABLED);
            EnableMenuItem(hmenu, ID_TOOLS_EMULATE,           MF_ENABLED);
            EnableMenuItem(hmenu, ID_TOOLS_BUILDFOREMULATION, MF_ENABLED);
            EnableMenuItem(hmenu, ID_FILE_SAVE,     MF_ENABLED);
            EnableMenuItem(hmenu, ID_FILE_SAVEAS,     MF_ENABLED);
            EnableMenuItem(hmenu, ID_VIEW_RESCANLAYOUT,     MF_ENABLED);
        }
        else
        {
            m_ptoolbar->EnableButton(ID_TOOLS_PREMASTERTAPE,     false);
            m_ptoolbar->EnableButton(ID_TOOLS_EMULATE,           false);
            m_ptoolbar->EnableButton(ID_TOOLS_BUILDFOREMULATION, false);
            m_ptoolbar->EnableButton(ID_FILE_SAVE, false);
            m_ptoolbar->EnableButton(ID_FILE_SAVEAS, false);
            m_ptoolbar->EnableButton(ID_VIEW_RESCANLAYOUT, false);
            EnableMenuItem(hmenu, ID_TOOLS_PREMASTERTAPE,     MF_GRAYED);
            EnableMenuItem(hmenu, ID_TOOLS_EMULATE,           MF_GRAYED);
            EnableMenuItem(hmenu, ID_TOOLS_BUILDFOREMULATION, MF_GRAYED);
            EnableMenuItem(hmenu, ID_FILE_SAVE,     MF_GRAYED);
            EnableMenuItem(hmenu, ID_FILE_SAVEAS,     MF_GRAYED);
            EnableMenuItem(hmenu, ID_VIEW_RESCANLAYOUT,     MF_GRAYED);
        }
        return TRUE;

    case ID_FILE_SAVE:
        // Save the current workspace
        m_pws->Save();
        return TRUE;

    case ID_FILE_SAVEAS:
        // Query for a new name and save the current workspace
        m_pws->SaveAs();
        return TRUE;

    case ID_FILE_EXIT:
        // Exit the current workspace
        SendMessage(m_hwnd, WM_CLOSE, 0, 0);
        return TRUE;

    case ID_EDIT_SELECTALL:
        // Select all items in the current layer's listview
        m_plvCur->SelectAll();
        return TRUE;

    case ID_EDIT_GROUP:
        // Perform group functionality
        OnGroup();
        return TRUE;

    case ID_EDIT_UNGROUP:
        // Perform ungroup functionality
        OnUngroup();
        return TRUE;

	case ID_VIEW_LAYER0:
        // User wants to see layer 0
		SetCurLayer(0);
		return TRUE;

	case ID_VIEW_LAYER1:
        // User wants to see layer 1
		SetCurLayer(1);
		return TRUE;

	case ID_VIEW_BOTHLAYERS:
        // User wants to see both layers
		SetCurLayer(2);
		return TRUE;

    case ID_VIEW_SCRATCHAREA:
        // User toggled the 'view scratch area' button.
        m_pscratch->ToggleView();
        
        // Update the status of the 'view scratch area' toggle button.
        m_ptoolbar->CheckButton(ID_VIEW_SCRATCHAREA, m_pscratch->m_fVisible);
        CheckMenuItem(GetMenu(m_hwnd), ID_VIEW_SCRATCHAREA, m_pscratch->m_fVisible ? MF_CHECKED : MF_UNCHECKED);
        break;

    case ID_VIEW_RESCANLAYOUT:
        if (!CheckModifiedFiles())
            MessageBox(m_hwnd, "Files rescanned successfully.", "Rescan successful", MB_ICONINFORMATION | MB_OK);

        break;

    case ID_TOOLS_EMULATE:
        // User wants to spawn the dvd emulation tool

        // Force the user through save if they haven't yet saved.
        if (!lstrcmpi(m_pws->m_szName, ""))
            if (!m_pws->SaveAs())
            {
                MessageBoxResource(m_hwnd, IDS_ERR_MUSTSAVE_TEXT,
                                   IDS_ERR_MUSTSAVE_CAPTION,
                                   MB_ICONWARNING | MB_APPLMODAL | MB_OK);
                return TRUE;
            }
        if (m_pws->m_fModified)
            m_pws->Save();

        // Check if any of the files in the layout have changed or been removed,
        // or if any files have been added.  In either case, we need to update
        // the layout.
        if (CheckModifiedFiles())
            return TRUE;

        if (CheckNeedBuildForEmulation())
            if (!BuildForEmulation())
            {
                // Failed to build for emulation
                return TRUE;
            }

        // Generate the string used to spawn the emulator
        sprintf(sz, "dvdemuctrlgui.exe \"%s\\_amc\\%s.fst\"", g_szRootFolderName, strrchr(g_szRootFolderName, '\\')+1);

        ZeroMemory(&sInfo, sizeof(STARTUPINFO));
	    sInfo.cb = sizeof(STARTUPINFO);

        // Spawn the process
	    if (!CreateProcess(NULL, sz, NULL, NULL, TRUE,
				           NULL, NULL, NULL, &sInfo, &pInfo))
	    {
            MessageBoxResource(m_hwnd, IDS_ERR_LAUNCHDVDEMU_TEXT,
                               IDS_ERR_LAUNCHDVDEMU_CAPTION,
                               MB_ICONWARNING | MB_APPLMODAL | MB_OK);
	    }
        return TRUE;
        
    case ID_TOOLS_PREMASTERTAPE:
        // User wants to spawn the premastering tool.

        // Force the user through save if they haven't yet saved.
        if (!lstrcmpi(m_pws->m_szName, ""))
            if (!m_pws->SaveAs())
            {
                MessageBoxResource(m_hwnd, IDS_ERR_MUSTSAVE_TEXT,
                                   IDS_ERR_MUSTSAVE_CAPTION,
                                   MB_ICONWARNING | MB_APPLMODAL | MB_OK);
                return TRUE;
            }
        if (m_pws->m_fModified)
            m_pws->Save();

        // Check if any of the files in the layout have changed or been removed,
        // or if any files have been added.  In either case, we need to update
        // the layout.
        if (CheckModifiedFiles())
            return TRUE;
        
        if (CheckNeedBuildForEmulation())
            if (!BuildForEmulation())
            {
                // Failed to build for emulation
                return TRUE;
            }


	    ZeroMemory(&sInfo, sizeof(STARTUPINFO));
	    sInfo.cb = sizeof(STARTUPINFO);

        // Create the full command line to spawn.  This will tell xbPremaster
        // the name and location of the FLD file to source off of.
        sprintf(sz, "xbPremaster.exe \"%s\"", m_pws->m_szName);

        // Spawn the process
        if (!CreateProcess(NULL, sz, NULL, NULL, TRUE, NULL, NULL, NULL,
                           &sInfo, &pInfo))
	    {
            MessageBoxResource(m_hwnd, IDS_ERR_LAUNCHPREM_TEXT,
                               IDS_ERR_LAUNCHPREM_CAPTION,
                               MB_ICONWARNING | MB_APPLMODAL | MB_OK);
	    }
        return TRUE;

    case ID_HELP_CONTENTS:
        LoadString(m_hinst, IDS_HELP_FILE_NAME, sz, 256);
    
        // Generate the exe spawn name\parms.
        sprintf(sz2, "winhlp32.exe %s\\%s", m_szWorkingDir, sz);

        ZeroMemory(&sInfo, sizeof(STARTUPINFO));
        sInfo.cb = sizeof(STARTUPINFO);
        if (!CreateProcess(NULL, sz2, NULL, NULL, TRUE, NULL, NULL, NULL,
                            &sInfo, &pInfo))
        {
            MessageBoxResource(m_hwnd, IDS_ERR_LAUNCHHELP_TEXT,
                               IDS_ERR_LAUNCHHELP_CAPTION,
                               MB_ICONERROR | MB_APPLMODAL | MB_OK);
        }
        return TRUE;

    case ID_HELP_ABOUTXBOXDVDLAYOUTTOOL:
        // User wants to see the 'About' box.
        DialogBox(m_hinst, (LPCTSTR)IDD_ABOUTBOX, m_hwnd, (DLGPROC)AboutDlgProc);
        return TRUE;
    }
    
    // If here, then we didn't handle the message
    return FALSE;
}

bool CWindow_Main::CMF_HandleFiles()
{
    // Recursively scan the contents of every directory -
    // A. for each file or folder found, find it in the layout
    //   a. If the file does not exist in the layout, create a new object
    //      and place it in the unplaced files window
    //   b. If the file exists in the layout, mark it as 'present'
    //   c. If the file exists, but its size has changed, then remove it
    //      from the layout and place it in the unplaced files window

    WIN32_FIND_DATA wfd;
    char szSearch[MAX_PATH], szCurDir[MAX_PATH];
    CObject *poNew;

    GetCurrentDirectory(MAX_PATH, szCurDir);

    // Create the search string
    sprintf(szSearch, "%s\\*.*", szCurDir);

    HANDLE hff = FindFirstFile(szSearch, &wfd);
    if (hff == INVALID_HANDLE_VALUE)
        return false;
    do {
        if (!lstrcmpi(wfd.cFileName, ".") || !lstrcmpi(wfd.cFileName, "..") || !lstrcmpi(wfd.cFileName, "_amc"))
            continue;

        if (!lstrcmpi(wfd.cFileName, "default.xbe"))
            m_fDefaultXbePresent = true;

        sprintf(szSearch, "%s\\%s", szCurDir, wfd.cFileName);

        // Search for the object in the layout
        bool fScratch = false;
        CObject *po = m_pws->m_pdvd->m_rgpolLayer[0]->FindObjectByFullFileName(szSearch);
        if (!po) po = m_pws->m_pdvd->m_rgpolLayer[1]->FindObjectByFullFileName(szSearch);
        if (!po) {
            po = m_pscratch->FindObjectByFullFileName(szSearch);
            if (po) fScratch = true;
        }

        if (!po) {
            // Object doesn't exist in the layout.
            // Create a new object and add it to the unplaced files window
            if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                poNew = new CObj_Folder(szCurDir, wfd.cFileName);
            else
                poNew = new CObj_File(szCurDir, wfd.cFileName,
                                      wfd.nFileSizeHigh, wfd.nFileSizeLow);
            m_pscratch->AddObject(poNew);
            m_fCMF_FilesInUnplaced = true;
        }
        else
        {
            // Object exists.  Is it the same size?
            // Folders are handled by the call to refreshdirectoryentries at the end.
            if (!(wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                if (!fScratch && (wfd.nFileSizeHigh != po->m_uliSize.HighPart ||
                                  wfd.nFileSizeLow  != po->m_uliSize.LowPart)) {

                    // File size changed.
                    po->m_uliSize.HighPart = wfd.nFileSizeHigh;
                    po->m_uliSize.LowPart  = wfd.nFileSizeLow;
                    DWORD dwNewBlockSize = BlockSize(po->m_uliSize.QuadPart);
                    if (dwNewBlockSize != po->m_dwBlockSize) {
                        po->m_dwBlockSize = dwNewBlockSize;
                        po->m_fCMF_Resized  = true;
                        m_fCMF_FilesResized = true;
                    }
                }
            }
            po->m_fCMF_Present = true;
        }

        if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            SetCurrentDirectory(szSearch);
            if (!CMF_HandleFiles())
                return false;
            SetCurrentDirectory("..");
        }
    } while (FindNextFile(hff, &wfd));
    FindClose(hff);

    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWindow_Main::CheckModifiedFiles
// Purpose:   
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CWindow_Main::CheckModifiedFiles()
{
    // Check if any of the files or folders in the layout have been modified.
    // we need to do a relayout if any sizes have changed.

    // 1. Mark all objects in layout as 'not present'
    // 2. Recursively scan the contents of every directory -
    //    A. for each file or folder found, find it in the layout
    //      a. If the file does not exist in the layout, create a new object
    //         and place it in the unplaced files window
    //      b. If the file exists in the layout, mark it as 'present'
    //      c. If the file exists, but its size has changed, then remove it
    //         from the layout and place it in the unplaced files window
    // 3. Walk the layout -- if any files are marked as 'not present' then
    //    remove them from the layout
    // 4. The layout now contains only unmodified files that are still present,
    //    and holes where modified/removed files were. Compact each layer now.
    // 5. Refresh directory entries if any files were added or removed.  This
    //    may force files into the unplaced files window
    // 6. If any files were placed in the unplaced files window, then notify
    //    the user that the directory structure or files changed, and modified
    //    files have been placed in the unplaced files window

    bool fCMF_FileDeleted = false;
    m_fCMF_FilesInUnplaced = false;
    m_fCMF_FilesResized = false;
    m_fDefaultXbePresent = false;

    // 1. Mark all objects in layout as 'not present'
    for (int i = 0; i < 2; i++) {
        CObject *poCur = m_pws->m_pdvd->m_rgpolLayer[i]->GetInside();
        while (poCur) {
            if (poCur->GetType() == OBJ_FILE || poCur->GetType() == OBJ_FOLDER) {
                poCur->m_fCMF_Present = false;
                poCur->m_fCMF_Resized = false;
            }
            poCur = m_pws->m_pdvd->m_rgpolLayer[i]->GetNextOuter();
        }
    }
    int iItem = -1;
    while ((iItem = ListView_GetNextItem(m_pscratch->m_plistview->m_hwnd, iItem, 0)) != -1)
    {
        CObject *poCur = m_pscratch->m_plistview->GetObjectFromIndex(iItem);
        poCur->m_fCMF_Present = false;
    }

    // 2. Recursively scan the contents of every directory -
    //    A. for each file or folder found, find it in the layout
    //      a. If the file does not exist in the layout, create a new object
    //         and place it in the unplaced files window
    //      b. If the file exists in the layout, mark it as 'present'
    //      c. If the file exists, but its size has changed, then remove it
    //         from the layout and place it in the unplaced files window
    SetCurrentDirectory(g_szRootFolderName);
    CMF_HandleFiles();

    // 3. Walk the layout -- if any files are marked as 'not present' then
    //    remove them from the layout
    for (i = 0; i < 2; i++) {
        CObject *poCur = m_pws->m_pdvd->m_rgpolLayer[i]->GetInside();
        while (poCur) {
            CObject *poNext = m_pws->m_pdvd->m_rgpolLayer[i]->GetNextOuter();
            if (!poCur->m_fCMF_Present && lstrcmpi(g_szRootFolderName, poCur->m_szFullFileName)) {
                poCur->RemoveFromList();
                if (poCur->m_pog)
                    poCur->m_pog->RemoveGroupedObject(poCur);
                delete poCur;
                fCMF_FileDeleted = true;
            }

            poCur = poNext;
        }
    }

    // 3b. walk the scratch window as well
    iItem = -1;
    while ((iItem = ListView_GetNextItem(m_pscratch->m_plistview->m_hwnd, iItem, 0)) != -1)
    {
        CObject *poCur = m_pscratch->m_plistview->GetObjectFromIndex(iItem);
        if (!poCur->m_fCMF_Present && lstrcmpi(g_szRootFolderName, poCur->m_szFullFileName)) {
            poCur->RemoveFromList();
            if (poCur->m_pog)
                poCur->m_pog->RemoveGroupedObject(poCur);
            m_pscratch->m_plistview->RemoveObject(poCur);
            delete poCur;
            iItem = -1;
        }
    }

    if (m_fCMF_FilesResized) {
        // At least one file was resized.  Find the farthest out file on each
        // layer (if present) and remove\reinsert it
        for (i = 0; i < 2; i++) {
            CObject *poCur = m_pws->m_pdvd->m_rgpolLayer[i]->GetOutside();
            while (poCur) {
                if (poCur->m_fCMF_Resized) {
                    // Found it - poCur is the farthest out resized object on
                    // this layer.  Remove it and reinsert it - this will force
                    // reinsertion of all objects above it, and potentially
                    // move objects off of the layer.

                    // Track which object is immediately outside of the resized one.
                    CObject *poOuter = m_pws->m_pdvd->m_rgpolLayer[i]->GetNextOuter();
                    m_pws->QueueSnapspot();

                    // Remove the object
                    poCur->RemoveFromList();
                    if (poCur->m_pog)
                        poCur->m_pog->RemoveGroupedObject(poCur);

                    // We need the name of the object in case we need to dequeue
                    // the snapshot, which renders poCur invalid.
                    char szName[MAX_PATH];
                    strcpy(szName, poCur->m_szFullFileName);

                    // Reinsert that object 'inside of' the next outermost object
                    if (!m_pws->m_pdvd->Insert(m_pws->m_pdvd->m_rgpolLayer[i], poCur, poOuter))
                    {
                        // Failed to insert the object; restore the previous state
                        // and add it to the unplaced files window
                        m_pws->DequeueSnapspot();

                        // Refind the object (since the dequeue made poCur invalid)
                        poCur = m_pws->m_pdvd->m_rgpolLayer[i]->FindObjectByFullFileName(szName);
                        assert(poCur);
                        
                        poCur->RemoveFromList();
                        if (poCur->m_pog)
                            poCur->m_pog->RemoveGroupedObject(poCur);

                        m_pscratch->AddObject(poCur);
                        m_fCMF_FilesInUnplaced = true;

                        // Start again on the outside of the disc (since the
                        // dequeue made previous pointers invalid).
                        poCur = m_pws->m_pdvd->m_rgpolLayer[i]->GetOutside();
                        continue;
                    }

                    m_pws->CompactLayer(i);

                    // We're done with this layer, so break out of the loop.
                    break;
                }

                poCur = m_pws->m_pdvd->m_rgpolLayer[i]->GetNextInner();
            }
        }
    }

    // 4. Compact each layer now.
    m_pws->CompactLayer(0);
    m_pws->CompactLayer(1);

    // Reset the 'warned about too many files' flag so that, if there are *now*
    // too many directory entries, we warn the user (again, if appropriate).
    m_pws->m_pdvd->m_fWarnedTooManyFiles = false;

    // 5. Refresh directory entries if any files were added or removed.  This
    //    may force files into the unplaced files window
    m_pws->m_pdvd->RefreshPlaceholders();
    m_pws->m_pdvd->RefreshDirectoryEntries(m_pws, false);
    
    // Update the views that display the workspace's information
    m_pws->UpdateViews();

    if (!m_fDefaultXbePresent)
    {
        // No default.xbe present! warn user
        MessageBox(m_hwnd, "The specified directory does not contain " \
                   "default.xbe.\nDefault.xbe MUST be present or the application " \
                   "will fail to execute.", "Default.xbe not present",
                   MB_ICONWARNING | MB_OK);
    }

    // 6. If any files were placed in the unplaced files window, then notify
    //    the user that the directory structure or files changed, and modified
    //    files have been placed in the unplaced files window
    if (m_fCMF_FilesInUnplaced) {
        m_pws->SetModified();
        m_pws->UpdateWindowCaption();
        m_pws->m_pdvd->RefreshRelationships();
        if (!m_pscratch->m_fVisible)
            SendMessage(m_hwnd, WM_COMMAND, ID_VIEW_SCRATCHAREA, 0);

        MessageBox(m_hwnd, "Files and/or folders in the layout have been" \
                           " modified.  They have been added to the unplaced" \
                           " files window.  Please examine it and determine " \
                           " their final placement.", "Files Moved to Unplaced",
                           MB_ICONWARNING | MB_OK);
        return true;
    }
    else if (fCMF_FileDeleted) {
        m_pws->SetModified();
        m_pws->UpdateWindowCaption();
        m_pws->m_pdvd->RefreshRelationships();
        MessageBox(m_hwnd, "Files and/or folders in the layout have been"
                           " removed from the source directories.  The layout"
                           " has been updated to reflect this - please examine"
                           " it for correctness.", "Files Removed",
                           MB_ICONWARNING | MB_OK);
        return true;
    }
    else if (m_fCMF_FilesResized) {
        m_pws->SetModified();
        m_pws->UpdateWindowCaption();
        m_pws->m_pdvd->RefreshRelationships();
        MessageBox(m_hwnd, "Files and/or folders in the layout have changed"
                           " size.  The layout has been updated to reflect"
                           " this - please examine it for correctness.",
                           "Files Removed", MB_ICONWARNING | MB_OK);
        return true;
    }


    // Return that no files were placed in unplaced window, removed, or resized
    return false;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWindow_Main::CheckNeedBuildForEmulation
// Purpose:   Return 'true' if the FST and BIN files need to be regenerated for 
//            emulation.  We know this is the case if the FLD file's timestamp
//            is newer than the FST's timestamp.
// Arguments: None
// Return:    'true' if the FST and BIN need to be rebuilt
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CWindow_Main::CheckNeedBuildForEmulation()
{
    sFLDHeader fldhdr;
    char   szFST[MAX_PATH];
    bool   fRebuild = true;
    time_t timeFST;
    DWORD  dwTimeStampLoc;

    // Compare the 'FLD last saved' timestamps stored in the FLD and FST.
    // 1. If FLD is old-version FLD, then force rebuild
    // 2. If timestamps are different, then force rebuild
    // 3. If either file can't be found, then force rebuild

    sprintf(szFST, "%s\\_amc\\%s.fst", g_szRootFolderName,
                                       strrchr(g_szRootFolderName, '\\')+1);
    
    // Load the two files.
    CFile fileFST(szFST, FILE_READ | FILE_DISK);
    CFile fileFLD(m_pws->m_szName, FILE_READ | FILE_DISK);

    // Verify both files were successfully loaded.
    if (!fileFST.IsInited())
        goto done;
    if (!fileFLD.IsInited())
        goto done;

    // Get the FLD signature
    if (!fileFLD.ReadData(&fldhdr, sizeof fldhdr))
        goto done;
    
    // Verify it's a newer FLD file; if it's an older one, then force rebuild
    if (memcmp(fldhdr.szSig, FLD_SIG, FLD_SIG_SIZE))
        goto done;
    
    // Get the FST timestamp
    dwTimeStampLoc = sizeof(TFileHeader) + sizeof(TMediaHeader) + 2;
    if (!fileFST.SetPos(dwTimeStampLoc))
        goto done;
    if (!fileFST.ReadData(&timeFST, sizeof timeFST))
        goto done;

    // If times are different, force rebuild
    fRebuild = (fldhdr.timeSaved != timeFST);

done:

    return fRebuild;        
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWindow_Main::OnNotify
// Purpose:   Certain windows events are sent via 'notifications'.  We handle
//            those notifications here.
// Arguments: wparam            -- First param passed to WM_NOTIFY
//            lparam            -- Second param passed to WM_NOTIFY
// Return:    Ignored unless a particular notification specifies.  See MSDN
//            for more information.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CWindow_Main::OnNotify(WPARAM wparam, LPARAM lparam)
{
    NMLISTVIEW   *pnmlv = (NMLISTVIEW*)lparam;
    NMHDR        *pnmhdr = (NMHDR*)lparam;
    NMTTDISPINFO *pnmttdi = (LPNMTTDISPINFO)lparam;
    char         szTooltip[100];
    static bool  fChanging = false;
    CListView    *plvTemp;
    NMLVKEYDOWN  *pnmlvkd = (NMLVKEYDOWN*)lparam;
    bool         fRet;

    switch(pnmlv->hdr.code)
    {
    case LVN_BEGINDRAG:
        // User began a dragging session.
        m_plvCur->BeginDrag();
        break;

    case TTN_GETDISPINFO:
        // The OS is asking for tooltip text (the user paused over a toolbar
        // button).

        // Load the string resource for the moused-over tool
        LoadString(m_hinst, g_rgdwTooltip[pnmttdi->hdr.idFrom - 40001],
                   szTooltip, 100);

        // Store the appropriate text in the structure
        strcpy(pnmttdi->szText, szTooltip);

        // Don't ask for this again (since it never changes)
        pnmttdi->uFlags = TTF_DI_SETITEM;
        break;

    case LVN_ITEMCHANGING:
        // An item is changing focus or selection state
        if ((pnmlv->uNewState & LVIS_SELECTED) != (pnmlv->uOldState & LVIS_SELECTED))
        {
            // Annoyingly, Windows sends the itemchanging notification BEFORE it
            // sends the setfocus notification (sigh).  So check which listview
            // this is intended for via the hwnd passed in...
            plvTemp = GetLVFromHwnd(pnmhdr->hwndFrom);
#ifdef _DEBUG1
            {
                CObject *pobj = plvTemp->GetObjectFromIndex(pnmlv->iItem);
                DebugOutput("ItemChanging: %d (%s, %s) %s->%s", pnmlv->iItem, pobj->m_szName, pobj->m_fIgnoreNextUnselect ? "ignore next": "do next",
                    (pnmlv->uOldState & LVIS_SELECTED) ? "selected" : "unselected",
                    (pnmlv->uNewState & LVIS_SELECTED) ? "selected" : "unselected");
            }
#endif
            fRet = !plvTemp->CanItemChange(pnmlv->iItem, pnmlv->uOldState, pnmlv->uNewState);
#ifdef _DEBUG1
            DebugOutput("  (%s)\r\n", fRet ? "Denied" : "Accepted");
#endif
            return fRet;
        }
        return false;

    case LVN_ITEMCHANGED:
        // An item changed focus or selection state
        if (pnmlv->uChanged & LVIF_STATE)
        {
            // If the selection state changed, then notify the listview.
            if ((pnmlv->uNewState & LVIS_SELECTED) != (pnmlv->uOldState & LVIS_SELECTED))
            {
                // User clicked on one of our list views.  A different window may
                // have current focus (since LVN_ITEMCHANGED is sent before the
                // NM_SETFOCUS message).
                plvTemp = GetLVFromHwnd(pnmhdr->hwndFrom);

#ifdef _DEBUG1
                CObject *pobj = plvTemp->GetObjectFromIndex(pnmlv->iItem);
                DebugOutput("ItemChanged: %d (%s, %s) %s->%s\r\n", pnmlv->iItem, pobj->m_szName, pobj->m_fIgnoreNextUnselect ? "ignore next": "do next",
                    (pnmlv->uOldState & LVIS_SELECTED) ? "selected" : "unselected",
                    (pnmlv->uNewState & LVIS_SELECTED) ? "selected" : "unselected");
#endif
                plvTemp->ItemSelected(pnmlv->iItem, pnmlv->uNewState & LVIS_SELECTED ? true : false);

                // Update the status bar (which shows selected-item information).
                UpdateStatusBar();
            }
        }
        break;

    case NM_SETFOCUS:
        // User clicked on one of our list views.

        // Did they click on the one that already has the focus?
        if (pnmhdr->hwndFrom == m_plvCur->GetHwnd())
            break;

        // Remove focus from the 'old' current listview
        m_plvCur->SetFocus(false);
        
        // Determine which listview the use clicked on.
        m_plvCur = GetLVFromHwnd(pnmhdr->hwndFrom);

        // Set focus to the 'new' current listview
        m_plvCur->SetFocus(true);
        break;

    case LVN_KEYDOWN:
        // User pressed a key.  Check to see if the user can move to the
        // requested location in the current listview
        if (m_plvCur->MoveSelection(pnmlvkd->wVKey))
            break;

        // Otherwise, fall through and let the normal wndproc handle it

    default:
        return DerivedWndProc(WM_NOTIFY, wparam, lparam) ? TRUE: FALSE;

    }
    return TRUE;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWindow_Main::GetLVFromHwnd
// Purpose:   Determines which listview cooresponds to the specified hwnd
// Arguments: 
// Return:    Listview with the specified hwnd
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CListView *CWindow_Main::GetLVFromHwnd(HWND hwnd)
{
    if (hwnd == m_rgplv[LV_LAYER0]->m_hwnd)
        return m_rgplv[LV_LAYER0];
    else if (hwnd == m_rgplv[LV_LAYER1]->m_hwnd)
        return m_rgplv[LV_LAYER1];
    else
        return m_rgplv[LV_SCRATCH];
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWindow_Main::SetCurLayer
// Purpose:   Called when the user wants to see layer 0, 1, or both.
// Arguments: nLayer        -- The layer to show
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CWindow_Main::SetCurLayer(int nLayer)
{
	if (nLayer == LV_LAYER0 || nLayer == LV_LAYER1)
	{
        // User wants to see either layer 0 or layer 1
        m_plvCur = m_rgplv[nLayer];
        m_plvCur->SetVisible(true);
        m_ptoolbar->CheckButton(nLayer == LV_LAYER0 ? ID_VIEW_LAYER0 :
                                                      ID_VIEW_LAYER1, true);
	}
    else
    {
        // User wants to see both layer 0 and layer 1.  Leave the current view
        // focus on which view already had it.
        m_rgplv[LV_LAYER0]->SetVisible(true);
        m_rgplv[LV_LAYER1]->SetVisible(true);
        m_ptoolbar->CheckButton(ID_VIEW_BOTHLAYERS, true);
    }

    // Track which layer (or both) is currently visible
    m_nCurLayerView = nLayer;

    // Force a repaint since we changed the visible listviews
    OnSize();

    m_pws->UpdateWindowCaption();

    // Update the status bar (which shows layer-specific information).
    UpdateStatusBar();
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWindow_Main::GetFocusLayer
// Purpose:   Returns the number of the layer that currently has the focus
// Arguments: None
// Return:    The layer that currently has the focus
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
int CWindow_Main::GetFocusLayer()
{
    return (m_plvCur == m_rgplv[LV_LAYER0]) ? 0 : 1;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWindow_Main::UpdateStatusBar
// Purpose:   Updates the text in the status bar.
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CWindow_Main::UpdateStatusBar()
{
    char szText[256], szSelText[256], szNum[256];
    int nSelectedFiles, nSelectedSize;
    char szFormat[1024], szFormat2[1024];

    LoadString(m_hinst, IDS_STATUS, szFormat, 1024);
    LoadString(m_hinst, IDS_STATUS2, szFormat2, 1024);
        
    if (m_nCurLayerView == 2)
    {
        // Both layers are visible, so break the status bar into two parts
        m_pstatusbar->SetNumParts(2);

        // Generate the text for the first half of the status bar (layer 0)
        FormatByteString(m_pws->GetNumUsedSectors(0)*2048, szNum);
        sprintf(szText, szFormat, 0, m_pws->GetNumFiles(0), szNum);

        // Get information about the selected files on layer 0
        m_rgplv[LV_LAYER0]->GetSelectedFileCountAndSize(&nSelectedFiles, &nSelectedSize);
        if (nSelectedFiles)
        {
            FormatByteString(nSelectedSize, szNum);
            sprintf(szSelText, szFormat2, nSelectedFiles, szNum);
            strcat(szText, szSelText);
        }
        m_pstatusbar->SetText(0, szText);

        // Generate the text for the second half of the status bar (layer 1)
        FormatByteString(m_pws->GetNumUsedSectors(1)*2048, szNum);
        sprintf(szText, szFormat, 1, m_pws->GetNumFiles(1), szNum);

        // Get information about the selected files on layer 1
        m_rgplv[LV_LAYER1]->GetSelectedFileCountAndSize(&nSelectedFiles, &nSelectedSize);
        if (nSelectedFiles)
        {
            FormatByteString(nSelectedSize, szNum);
            sprintf(szSelText, szFormat2, nSelectedFiles, szNum);
            strcat(szText, szSelText);
        }
        m_pstatusbar->SetText(1, szText);
    }
    else
    {
        // Only one layer is currently visible, so we only need one part in the
        // status bar.
        m_pstatusbar->SetNumParts(1);

        // Generate the text that will get drawn into the status bar.
        FormatByteString(m_pws->GetNumUsedSectors(GetFocusLayer())*2048, szNum);
        sprintf(szText, szFormat, GetFocusLayer() == 0 ? 0 : 1,
                m_pws->GetNumFiles(GetFocusLayer()), szNum);

        // Get the selected-file information from the current layer.
        (GetFocusLayer() == 0 ? m_rgplv[LV_LAYER0] : m_rgplv[LV_LAYER1])->GetSelectedFileCountAndSize(&nSelectedFiles, &nSelectedSize);

        // If there are any selected files, then add their information to the
        // status bar text
        if (nSelectedFiles)
        {
            FormatByteString(nSelectedSize, szNum);
            sprintf(szSelText, szFormat2, nSelectedFiles, szNum);
            strcat(szText, szSelText);
        }

        // Set the text inside the status bar
        m_pstatusbar->SetText(0, szText);
    }
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWindow_Main::OnSize
// Purpose:   Called when the user resizes the window.  We resize the controls to fill the new
//            window size
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CWindow_Main::OnSize()
{
    RECT rcToolbar;
    RECT rcStatusbar;

    // Get the new dimensions of the window and various controls
    GetClientRect(m_hwnd, &m_rc);
    GetClientRect(m_ptoolbar->m_hwnd, &rcToolbar);
    GetClientRect(m_pstatusbar->m_hwnd, &rcStatusbar);

    // Calculate the height of the listview controls
    int nListHeight = (m_rc.bottom - m_rc.top) - rcToolbar.bottom -
                      (rcStatusbar.bottom - rcStatusbar.top) - 2;

    switch(m_nCurLayerView)
    {
    case 0:
        // Set the visibility of the different controls
        m_pcolbarLeft->SetVisible(true);
        m_pcolbarMid->SetVisible(false);
        m_pcolbarRight->SetVisible(false);
        m_rgplv[LV_LAYER0]->SetVisible(true);
        m_rgplv[LV_LAYER1]->SetVisible(false);

        // Move the layer 0 list control
        m_rgplv[LV_LAYER0]->MoveTo(COLBAR_WIDTH, rcToolbar.bottom + 2,
                                   (m_rc.right - m_rc.left) - COLBAR_WIDTH,
                                   nListHeight);

        // Make sure the left-side colorbar is in the right place
        m_pcolbarLeft->MoveTo(0, rcToolbar.bottom + 3, COLBAR_WIDTH, nListHeight-1);
        InvalidateRect(m_rgplv[LV_LAYER0]->m_hwnd, NULL, FALSE);
        break;

    case 1:
        // Set the visibility of the different controls
        m_pcolbarLeft->SetVisible(false);
        m_pcolbarMid->SetVisible(false);
        m_pcolbarRight->SetVisible(true);
        m_rgplv[LV_LAYER0]->SetVisible(false);
        m_rgplv[LV_LAYER1]->SetVisible(true);

        // Move the layer 1 list control
        m_rgplv[LV_LAYER1]->MoveTo(COLBAR_WIDTH, rcToolbar.bottom + 2,
                                   (m_rc.right - m_rc.left) - COLBAR_WIDTH,
                                   nListHeight);

        // Make sure the right-side colorbar is in the right place
        m_pcolbarRight->MoveTo(0, rcToolbar.bottom + 3, COLBAR_WIDTH, nListHeight-1);
        InvalidateRect(m_rgplv[LV_LAYER1]->m_hwnd, NULL, FALSE);
        break;

    case 2:
        // Set the visibility of the different controls
        m_pcolbarLeft->SetVisible(true);
        m_pcolbarMid->SetVisible(true);
        m_pcolbarRight->SetVisible(true);
        m_rgplv[LV_LAYER0]->SetVisible(true);
        m_rgplv[LV_LAYER1]->SetVisible(true);

        m_pcolbarLeft->MoveTo(0, rcToolbar.bottom + 3, COLBAR_WIDTH, nListHeight-1);
        m_rgplv[LV_LAYER0]->MoveTo(COLBAR_WIDTH, rcToolbar.bottom + 2,
                                   (m_rc.right - m_rc.left)/2 - COLBAR_WIDTH - 3, nListHeight);
        m_pcolbarMid->MoveTo((m_rc.right - m_rc.left)/2 - 3, rcToolbar.bottom + 3, 6, nListHeight-1);
        m_rgplv[LV_LAYER1]->MoveTo((m_rc.right - m_rc.left)/2 + 3, rcToolbar.bottom + 2,
                                   ((m_rc.right - m_rc.left) - COLBAR_WIDTH) - (rcToolbar.bottom + 2,
                                   (m_rc.right - m_rc.left)/2 + 3), nListHeight);
        m_pcolbarRight->MoveTo((m_rc.right - m_rc.left) - COLBAR_WIDTH,
                               rcToolbar.bottom + 3, COLBAR_WIDTH, nListHeight-1);
        InvalidateRect(m_rgplv[LV_LAYER0]->m_hwnd, NULL, FALSE);
        InvalidateRect(m_rgplv[LV_LAYER1]->m_hwnd, NULL, FALSE);
        break;
    }
    // Move the status bar into place.
    m_pstatusbar->MoveTo(0, (m_rc.bottom - m_rc.top) - rcToolbar.bottom,
                         (m_rc.right - m_rc.left), (m_rc.bottom - m_rc.top));
    m_ptoolbar->MoveTo(rcToolbar.left, rcToolbar.top, (m_rc.right - m_rc.left), rcToolbar.bottom - rcToolbar.top);

    // Update our tooltip's position
    TOOLINFO ti;
    ti.cbSize = sizeof(TOOLINFO);
    ti.uFlags = TTF_SUBCLASS;
    ti.hwnd = m_hwnd;
    ti.hinst = g_hinst;
    ti.uId = 0;
    ti.lpszText = MAKEINTRESOURCE(IDS_COLORBAR_TOOLTIP);
    ti.rect = m_rc;

    SendMessage(m_hwndTip, TTM_SETMAXTIPWIDTH, 0, 80);

 
    // Delete Previous tool (if any)
    SendMessage(m_hwndTip, TTM_DELTOOL, 0, (LPARAM) (LPTOOLINFO) &ti);

    // Send an ADDTOOL message to the tooltip control window
    SendMessage(m_hwndTip, TTM_ADDTOOL, 0, (LPARAM) (LPTOOLINFO) &ti);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  AboutDlgProc
// Purpose:   Message handler for About dialog. This function is automatically called by Windows
//            whenever a message needs to be sent to the dialog box (ie 'paint', 'move', etc).
// Arguments: hDlg          -- Handle to the Dialog box's window
//            message       -- The message sent to the dialog box
//            wParam        -- A message parameter.
//            lParam        -- Another message parameter
// Return:    nonzero if we processed the message
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LRESULT CALLBACK AboutDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    char szBuf[1024], szFormat[1024];

	switch (message)
	{
	case WM_INITDIALOG:
        // Get the build number from the resource file
        LoadString(g_hinst, IDS_ABOUT, szFormat, 1024);
        sprintf(szBuf, szFormat, VER_PRODUCTBUILD);
        SetDlgItemText(hDlg, IDC_ABOUTTEXT, szBuf);
		return true;

	case WM_COMMAND:
		EndDialog(hDlg, 0);
		return false;
	}
    return false;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWindow_Main::SetGroupable
// Purpose:   Set whether or not the group function is currently enabled.
// Arguments: fGroupable        -- Whether or not to enable 'group'.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CWindow_Main::SetGroupable(bool fGroupable)
{
    HMENU hmenu = GetMenu(m_hwnd);
    EnableMenuItem(hmenu, ID_EDIT_GROUP, fGroupable ? MF_ENABLED : MF_GRAYED);
    m_ptoolbar->EnableButton(ID_EDIT_GROUP, fGroupable);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWindow_Main::SetUngroupable
// Purpose:   Set whether or not the ungroup function is currently enabled.
// Arguments: fUngroupable      -- Whether or not to enable 'ungroup'.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CWindow_Main::SetUngroupable(bool fUngroupable)
{
    HMENU hmenu = GetMenu(m_hwnd);
    EnableMenuItem(hmenu, ID_EDIT_UNGROUP, fUngroupable ? MF_ENABLED : MF_GRAYED);
    m_ptoolbar->EnableButton(ID_EDIT_UNGROUP, fUngroupable);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWindow_Main::OnGroup
// Purpose:   Called when the user wants to group the currently selected items
//            We know if we got here that the items are groupable.
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CWindow_Main::OnGroup()
{
    CObject *poInsertAt;
    int     iAddAt;

    // Create the new group object that the files will go into.
    CObj_Group *pog = new CObj_Group;
    if (!pog)
        FatalError(E_OUTOFMEMORY);

    // Determine the object immediately before the first selected object.  That
    // is the point at which the group of objects will be reinserted
    if (m_plvCur->m_fInsideOut)
        poInsertAt = m_plvCur->GetLastSelectedObject();
    else
        poInsertAt = m_plvCur->GetFirstSelectedObject();

    if (m_plvCur == m_rgplv[LV_SCRATCH])
    {
        iAddAt = m_pscratch->m_plistview->GetIndexFromObject(poInsertAt);
    }
    else
    {
        // poInsertAt points at the first item we'll be adding to the group; step up
        // one so that we're pointing at the first item above the group...  After all
        // of the to-be-grouped items are removed from the list, we step the the next
        // farther out object, and that's our actual insertion point (since insertion
        // occurs 'before' the specified insertion point).
        poInsertAt = poInsertAt->m_poInner;
    }
    
    // Get the list of all selected objects.  This will also remove them from
    // their current layer (if they are in one) and the listview.
    CObjList olToMove;
    m_plvCur->GetListOfSelectedObjects(&olToMove);

    // Now that the to-be-grouped items are out of the layer, step out one to
    // get the actual insertion point.
    if (m_plvCur != m_rgplv[LV_SCRATCH])
        poInsertAt = poInsertAt->m_poOuter;

    // Add all of the selected objects to the new group
    CObject *poCur = olToMove.GetInside();
    while (poCur)
    {
        poCur->SetGroup(pog);
        poCur = olToMove.GetNextOuter();
    }

    // Add the group to the list of objects
    olToMove.AddToHead(pog);

    // And then add the whole list back into the layer.  We go through all of
    // this hassle in case the user grouped a collection of files that straddled
    // a placeholder -- we need to remove and reinsert the grouped files in order
    // to atomically place the group on either side of the placeholder.
    if (m_plvCur == m_rgplv[LV_LAYER0])
    {
        m_pws->m_pdvd->Insert(m_pws->m_pdvd->m_rgpolLayer[0], &olToMove, poInsertAt);
        m_pws->m_pdvd->CompactLayer(0);
    }
    else if (m_plvCur == m_rgplv[LV_LAYER1])
    {
        m_pws->m_pdvd->Insert(m_pws->m_pdvd->m_rgpolLayer[1], &olToMove, poInsertAt);
        m_pws->m_pdvd->CompactLayer(1);
    }
    else
    {
        // Grouping in the scratch window.  Just add the files directly into the list
        CObject *poCur = olToMove.GetOutside();
        while (poCur)
        {
            if (poCur->GetType() != OBJ_GROUP)
                m_pscratch->m_plistview->AddObjectAtIndex(poCur, iAddAt);
            poCur = olToMove.GetNextInner();
        }
    }

    // We've modified the layers in the CompactLayer calls without updating the
    // listviews accordingly.  Update the listviews now.
    m_pws->UpdateViews();
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWindow_Main::OnUngroup
// Purpose:   Called when the user wants to ungroup the currently selected items
//            We know if we got here that the items are ungroupable.
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CWindow_Main::OnUngroup()
{
    // Tell the current listview to ungroup its currently selected items.
    m_plvCur->UngroupSelectedItems(m_pws, (m_plvCur == m_rgplv[LV_LAYER0]) ? 0 : 1);

    m_pws->CompactLayer((m_plvCur == m_rgplv[LV_LAYER0]) ? 0 : 1);

    // Update the onscreen display of the listviews
    m_pws->UpdateViews();
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWindow_Main::BuildForEmulation
// Purpose:   Creates the .bin and .fst files necessary for emulation.
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CWindow_Main::BuildForEmulation()
{
    SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT)));

    // Create the .bin file
    bool fSuccess = m_pws->CreateBIN();
    if (!fSuccess)
        goto done;

    // Create the .fst file
    fSuccess = m_pws->CreateFST();    

done:

    SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW)));

    char szFormat[1024], szCaption[1024];
    LoadString(m_hinst, IDS_BFE_CAPTION, szCaption, 1024);
    if (!fSuccess)
    {
        char sz[1024];
        LoadString(m_hinst, IDS_BFE_SUCCESS, szFormat, 1024);
        sprintf(sz, szFormat, g_szRootFolderName,
                strrchr(g_szRootFolderName, '\\')+1);
        MessageBox(m_hwnd, sz, szCaption, MB_ICONINFORMATION | MB_APPLMODAL | MB_OK);
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\CWorkspace.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      cworkspace.cpp
// Contents:  
// Revisions: 13-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"
#include <commdlg.h>
#include <Shlobj.h>
#include <xboxverp.h>


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ GLOBAL VARIABLES ++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// gs_fPushedToScratch  -- 'true' if files were pushed to the scratch window
//                         during an 'AddFiles' call.
static bool gs_fPushedToScratch;
extern bool g_fResizedVolDesc;

time_t g_timeLastSaved = 0;

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWorkspace::CWorkspace
// Purpose:   
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CWorkspace::CWorkspace(CWindow_Main *pwindow)
{
    m_pwindow = pwindow;
    m_pdvd = new CDVD;
    if (!m_pdvd)
        FatalError(E_OUTOFMEMORY);

    strcpy(m_szName, "");
    m_fModified = false;
//    UpdateWindowCaption();

    for (int i = 0; i < MAX_UNDO_DEPTH; i++)
        m_rgpfileSnapshot[i] = NULL;
    
    SetInited(S_OK);
}

bool CWorkspace::Init()
{
    // Clear ourselves out.
    Reset();
    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWorkspace::~CWorkspace
// Purpose:   
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CWorkspace::~CWorkspace()
{
    delete m_pdvd;

    if (m_rgpfileSnapshot[0])
    {
        delete m_rgpfileSnapshot[0];
        m_rgpfileSnapshot[0] = NULL;
    }
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWorkspace::Close
// Purpose:   
// Arguments: 
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CWorkspace::Close()
{
    if (m_fModified)
    {
        // Verify with the user that they want to exit even though the
        // workspace has been modified
        if (MessageBoxResource(m_pwindow->m_hwnd, IDS_WS_MODIFIED_TEXT,
                               IDS_WS_MODIFIED_CAPTION,
                               MB_YESNO | MB_ICONQUESTION | MB_APPLMODAL) == IDYES)
        {
            return true;
        }
        return false;
    }

    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWorkspace::Reset
// Purpose:   
// Arguments: 
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CWorkspace::Reset()
{
    m_pwindow->m_rgplv[0]->Clear();
    m_pwindow->m_rgplv[1]->Clear();
    m_pwindow->m_rgplv[2]->Clear();
    // Reset the virtual dvd object.  This will empty its contents and fill it only with the
    // default security placeholders
    m_pdvd->Reset();
    
    // Clear the scratch area
    m_pwindow->m_pscratch->Reset();

    // Mark that we're in a completely clean (unmodified) state.
    m_fCleanSlate = true;

    // Update the views that display the workspace's information
    UpdateViews();
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWorkspace::Open
// Purpose:   
// Arguments: 
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CWorkspace::Open()
{
    OPENFILENAME ofn;
    char szFile[MAX_PATH];
    char szFilter[1024], szTitle[1024];

    LoadString(g_hinst, IDS_OPEN_FILTER, szFilter, 1024);
    char *szExt = szFilter + strlen(szFilter) + 1;
    strcpy(szExt, "*.FLD");
    szExt[6] = '\0';
    LoadString(g_hinst, IDS_OPEN_TITLE, szTitle, 1024);

    strcpy(szFile, "");

    // 1. Get the name of the FLD file to open.

    // Initialize the openfilename structure so that the GetOpenFileName function knows what
    // kind of files we want to allow.
    memset(&ofn, 0, sizeof(ofn));
    ofn.lStructSize       = sizeof(ofn);
    ofn.hwndOwner         = m_pwindow->m_hwnd;
    ofn.hInstance         = m_pwindow->m_hinst;
    ofn.lpstrFilter       = szFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter    = 0;
    ofn.nFilterIndex      = 1;
    ofn.lpstrFile         = szFile;
    ofn.nMaxFile          = MAX_PATH - 1;
    ofn.lpstrFileTitle    = ofn.lpstrFile;
    ofn.nMaxFileTitle     = ofn.nMaxFile;
    ofn.lpstrInitialDir   = "C:\\";
    ofn.nFileOffset       = 0;
    ofn.nFileExtension    = 0;
    ofn.lpstrDefExt       = "*.fld";
    ofn.lCustData         = 0;
    ofn.lpstrTitle        = szTitle;
    ofn.Flags             = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;

    // Pop up the common file open dialog
    if (!GetOpenFileName(&ofn))
    {
        // User clicked cancel or closed the dialog (or an error occurred).
        return false;
    }

    // If here, then a file name was chosen.

    // Create the FLD file
    CFile *pfile = new CFile(szFile, FILE_READ);
    if (!pfile)
        FatalError(E_OUTOFMEMORY);
    if (!pfile->IsInited())
    {
        MessageBoxResource(m_pwindow->m_hwnd, IDS_ERR_OPEN_TEXT,
                           IDS_ERR_OPEN_CAPTION, MB_APPLMODAL | MB_OK);
        if (pfile)
            delete pfile;
        return false;
    }

    DWORD dwMagicNumber;
    BYTE byMajorVersion, byMinorVersion;

    // Read the header information.
    pfile->ReadDWORD(&dwMagicNumber);

    // Is it an old FLD file?  If so, we load it like normal, but force
    // modified flag immediately (so that it will be saved out in new format
    // before emulation or premastering).
    if (dwMagicNumber == FLDFILE_MAGIC_NUMBER)
    {
        // This code will eventually deprecate away...
        // Verify we understand the version of the FLD file
        bool fVersionKnown = true;
        pfile->ReadBYTE(&byMajorVersion);
        pfile->ReadBYTE(&byMinorVersion);
        if (byMajorVersion != FLDFILE_MAJOR_VERSION || byMinorVersion != FLDFILE_MINOR_VERSION)
        {
            MessageBoxResource(m_pwindow->m_hwnd, IDS_ERR_INVALID_FILE_VER_TEXT,
                               IDS_ERR_INVALID_FILE_VER_CAPTION, MB_APPLMODAL | MB_OK);
            delete pfile;
            return false;
        }

        SetModified();
    }
    else
    {
        sFLDHeader fldhdr;
        
        // Read rest of sig
        memcpy(fldhdr.szSig, &dwMagicNumber, 4);
        pfile->ReadData(fldhdr.szSig + 4, (sizeof fldhdr) - 4);

        if (memcmp(fldhdr.szSig, FLD_SIG, FLD_SIG_SIZE))
        {
            // No idea what this is...
            MessageBoxResource(m_pwindow->m_hwnd, IDS_ERR_INVALID_FILE_TEXT,
                               IDS_ERR_INVALID_FILE_CAPTION, MB_APPLMODAL | MB_OK);
            delete pfile;
            return false;
        }
        g_timeLastSaved = fldhdr.timeSaved;

        // If here, it's a newer FLD file format.
        ClearModified();
    }

    g_fResizedVolDesc = false;

    if (!m_pdvd->CreateFrom(pfile))
    {
        delete pfile;
        return false;
    }

    m_pwindow->m_pscratch->Reset();
    m_pwindow->m_pscratch->CreateFrom(pfile);

    delete pfile;

    // Tell the DVD to refresh its list of security placeholders.  Tell it NOT
    // to validate the placeholders (we'll do it separately since we want to
    // special case it in the 'open' scenario).
    m_pdvd->RefreshPlaceholders(false);

    // Check if the placeholders are valid -- if not, then this was an older
    // FLD file with invalid placeholder generation.  We need to warn the user
    // and relayout the files now.  (pass false to specify that we don't want
    // the validate function to inform the user of the situation).
    if (!m_pdvd->ValidatePlaceholders(false))
    {
        // Yep, bogus.  Need to special case it.
        MessageBox(m_pwindow->m_hwnd, "An error in a previous version of xbLayout "
                   "caused invalid placeholder\nlocations to be generated.  As a "
                   "result, this FLD file needs to be laid\nout again.  It will now "
                   "be recreated.  We will maintain your original file\nordering, "
                   "however some files may be forced to the unplaced files window.",
                   "Invalid Placeholder Encountered", MB_ICONEXCLAMATION | MB_OK);

        try
        {
            // Create a new layout.  This will generate new placeholders
            bool fAddedToUnplaced = false;
            CDVD *pdvdNew = new CDVD;
            pdvdNew->Reset();

            // Copy the objects from m_pdvd to pdvdNew
            for (int nLayer = 0; nLayer <= 1; nLayer++)
            {
                // Start at the outside of the disc, and work inwards.
                CObject *poCur = m_pdvd->m_rgpolLayer[nLayer]->GetOutside();
                while (poCur)
                {
                    CObject *poNext = m_pdvd->m_rgpolLayer[nLayer]->GetNextInner();
                    if ((poCur->GetType() == OBJ_FOLDER || poCur->GetType() == OBJ_FILE ||
                        poCur->GetType() == OBJ_GROUP) && !poCur->m_pog)
                    {
                        poCur->RemoveFromList();
                        if (!pdvdNew->Insert(pdvdNew->m_rgpolLayer[nLayer], poCur, NULL))
                        {
                            // Couldn't fit on the layer -- add to unplaced files
                            m_pwindow->m_pscratch->AddObject(poCur);
                            if (poCur->m_pog)
                                poCur->m_pog->RemoveGroupedObject(poCur);
                            fAddedToUnplaced = true;
                        }
                    }
                    poCur = poNext;
                }
            }
            delete m_pdvd;
            m_pdvd = pdvdNew;
            m_pdvd->RefreshRelationships();

            if (fAddedToUnplaced && !m_pwindow->m_pscratch->m_fVisible)
            {
                m_pwindow->m_pscratch->ToggleView();
                MessageBox(m_pwindow->m_hwnd, "Some files could not be automatically"
                           " placed and have been moved\nto the unplaced files window."
                           "  Please move them to the appropriate positions.",
                           "Files Moved to Unplaced Files Window", MB_ICONWARNING | MB_OK);
            }
            SetModified();

            // Tell the DVD to refresh its list of security placeholders.
            m_pdvd->RefreshPlaceholders();
        }
        catch(...)
        {
            // unexpected error
            MessageBox(m_pwindow->m_hwnd, "The files could not be relaid out; please"
                       "recreate the layout from scratch.", "Cannot relayout files", MB_ICONEXCLAMATION | MB_OK);
            return false;
        }
    }
    else
    {
        // We changed the internal structure of the volume descriptor to be two
        // sectors in size (instead of one).  It's possible that the FLD that we
        // just opened was created in the older xbLayout, and that a file was sitting
        // in sector 33.  In that case we need to move the file to the scratch
        // area and warn the user.  We determine this by (a) finding the volume
        // descriptor, and (b) looking at the LSN of the file immediately following
        // it.  If it's 33, then we yank it.
        // Loop in case the user created a file called "volume descriptor".
        CObj_VolDesc *povd;
        do {
           povd = (CObj_VolDesc*)m_pdvd->m_rgpolLayer[0]->FindObjectByFullFileName(
                                                            "\\Volume Descriptor");
        } while (povd && povd->m_dwLSN != 32);
        assert(povd);

        // Get the object following the volume descriptor
        CObject *pobj = povd->m_poOuter;
        assert(pobj);
        if (pobj->m_dwLSN == 33)
        {
            // We need to yank the object
            m_pdvd->m_rgpolLayer[0]->Remove(pobj);
            m_pwindow->m_pscratch->AddObject(pobj);
            MessageBox(m_pwindow->m_hwnd, "A modification to xbLayout has caused " 
                       "the volume descriptor to grow slightly -- as a result, a "
                       "file has been pushed from layer 0 to the scratch window.  "
                       "The file was previously located at LSN 33 on layer 0 -- "
                       "you will need to determine the new location for the file.",
                       "File moved to scratch window", MB_ICONEXCLAMATION | MB_OK);
            SetModified();
        }
    
        // Track that we were modified if we resized the volume descriptor
        if (g_fResizedVolDesc)
            SetModified();
    }

    // After we've added all of the files, tell the DVD to refresh the folder
    // directory entry structures
    m_pdvd->RefreshDirectoryEntries(this, false);

    strcpy(m_szName, szFile);
    UpdateWindowCaption();

    // Check if any of the files have been modified since the layout was last
    // saved.
    m_pwindow->CheckModifiedFiles();
    
    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWorkspace::New
// Purpose:   
// Arguments: 
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CWorkspace::New()
{
    char       szDisplayName[MAX_PATH];
    char       szPath[MAX_PATH];
    char       szTitle[1024];
    BROWSEINFO bi;
    bool       fRet = false;
    IMalloc    *pmalloc;

    LoadString(g_hinst, IDS_NEW_TITLE, szTitle, 1024);

    // Get a pointer to the shell's allocator.  We'll need it to free up the pidl that's created.
    SHGetMalloc(&pmalloc);

getname:
    // Fill in the browse info structure.
    bi.pszDisplayName = szDisplayName;          // Buffer to hold display name
    bi.hwndOwner      = m_pwindow->m_hwnd;      // Owner window for the dialog
    bi.pidlRoot       = NULL;                   // Specify NULL for 'desktop'
    bi.lpszTitle      = szTitle;                // String to display at the top of the dialog
    bi.ulFlags        = BIF_RETURNONLYFSDIRS;   // Don't display control panel, etc
    bi.lpfn           = NULL;                   // No need for the callback
    bi.lParam         = 0;                      // unused.

    // Open up the dialog and have the user select the path.  The function is modal.
    LPITEMIDLIST pidl = SHBrowseForFolder(&bi);
    if (pidl == NULL)
    {
        // User cancelled out, so don't set anything.
        goto done;
    }
    
    // If here, then the user selected a path.  Extract it from the pidl and store it in the
    // buffer the caller specified.
    if (::SHGetPathFromIDList(pidl, szPath) == false)
    {
        // Malformed pidl, or other failure.  In any case, don't set the path
        goto done;
    }

    // We don't allow root drives to be dvd roots.
    if (szPath[3] == '\0')
    {
        MessageBox(m_pwindow->m_hwnd, "A drive root cannot be selected as the root DVD directory.",
                   "Invalid directory", MB_APPLMODAL | MB_ICONWARNING | MB_OK);
        goto getname;
    }


    // At this point, szPath contains the path the user chose.
    if (szPath[0] == '\0')
    {
        // SHGetPathFromIDList failed, or SHBrowseForFolder failed.
        goto done;
    }

    // Clear ourselves out.
    Reset();

    SetDVDRoot(szPath, true);
    
    // Tell the DVD to refresh its list of security placeholders.
    m_pdvd->RefreshPlaceholders();

    // After we've added all of the files, tell the DVD to refresh the folder
    // directory entry structures
    m_pdvd->RefreshDirectoryEntries(this, false);

    m_fModified = false;
    ClearModified();

    strcpy(m_szName, "");

    // If here, then we were successful
    fRet = true;

done:

    UpdateWindowCaption();
    return fRet;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWorkspace::UpdateWindowCaption
// Purpose:   
// Arguments: 
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CWorkspace::UpdateWindowCaption()
{
    char sz[MAX_PATH + 100];
    LoadString(g_hinst, IDS_WINDOW_CAPTION, sz, MAX_PATH);

    if (lstrcmpi(m_szName, ""))
    {
        strcat (sz, " - ");
        strcat (sz, m_szName);
    }

    if (m_pwindow->m_nCurLayerView == 0)
        strcat(sz, " [Layer 0]");
    else if (m_pwindow->m_nCurLayerView == 1)
        strcat(sz, " [Layer 1]");
    else
        strcat(sz, " [Layer 0 & 1]");
    if (m_fModified)
        strcat(sz, " *");
    m_pwindow->SetCaption(sz);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWorkspace::Save
// Purpose:   
// Arguments: 
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CWorkspace::Save()
{
    // If we haven't been named yet, then force saveas to get name
    if (!lstrcmpi(m_szName, ""))
        return SaveAs();

    // Create the FLD file
    return PersistTo(m_szName);
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWorkspace::PersistTo
// Purpose:   
// Arguments: 
// Return:    
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CWorkspace::PersistTo(char *szFLDName)
{
    sFLDHeader fldhdr;
    int nMajor, nMinor, nBuild, nQFE;

    CFile *pfile = new CFile(szFLDName, FILE_WRITE);
    if (!pfile)
        FatalError(E_OUTOFMEMORY);
    if (!pfile->IsInited())
    {
        MessageBoxResource(m_pwindow->m_hwnd, IDS_ERR_SAVE_TEXT,
                           IDS_ERR_SAVE_CAPTION, MB_APPLMODAL | MB_OK);
        if (pfile)
            delete pfile;
        return false;
    }

    SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT)));

    m_pdvd->ValidatePlaceholders();

    // Write out the header information

    // Keep global track of last time we saved so that we can verify the
    // FST/BIN files match the saved FLD file.
    g_timeLastSaved = time(NULL);

    memcpy(fldhdr.szSig, FLD_SIG, FLD_SIG_SIZE);
    fldhdr.timeSaved = g_timeLastSaved;
    sscanf(VER_PRODUCTVERSION_STR, "%d.%d.%d.%d", &nMajor, &nMinor, &nBuild,
                                                  &nQFE);
    fldhdr.version.wMajor = (WORD)nMajor;
    fldhdr.version.wMinor = (WORD)nMinor;
    fldhdr.version.wBuild = (WORD)nBuild;
    fldhdr.version.wQFE   = (WORD)nQFE;

    pfile->WriteData(&fldhdr, sizeof fldhdr);

    m_pdvd->PersistTo(pfile);
    m_pwindow->m_pscratch->PersistTo(pfile);
    delete pfile;

    ClearModified();
    UpdateWindowCaption();

    SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW)));

    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWorkspace::SaveAs
// Purpose:   
// Arguments: 
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CWorkspace::SaveAs()
{
    // Get the name of the FLD file to save to.
    // Create the FLD file
    OPENFILENAME ofn;
    char szFile[MAX_PATH];
    char szFilter[1024], szTitle[1024];

    LoadString(g_hinst, IDS_OPEN_FILTER, szFilter, 1024);
    char *szExt = szFilter + strlen(szFilter) + 1;
    strcpy(szExt, "*.FLD");
    szExt[6] = '\0';
    LoadString(g_hinst, IDS_SAVEAS_TITLE, szTitle, 1024);

    strcpy(szFile, "");

    // 1. Get the name of the FLD file to open.

    // Initialize the openfilename structure so that the GetOpenFileName function knows what
    // kind of files we want to allow.
    memset(&ofn, 0, sizeof(ofn));
    ofn.lStructSize       = sizeof(ofn);
    ofn.hwndOwner         = m_pwindow->m_hwnd;
    ofn.hInstance         = m_pwindow->m_hinst;
    ofn.lpstrFilter       = szFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nFilterIndex      = 1;
    ofn.lpstrFile         = szFile;
    ofn.nMaxFile          = MAX_PATH - 1;
    ofn.lpstrFileTitle    = ofn.lpstrFile;
    ofn.nMaxFileTitle     = ofn.nMaxFile;
    ofn.lpstrInitialDir   = "C:\\";
    ofn.lpstrDefExt       = "*.fld";
    ofn.lpstrTitle        = szTitle;
    ofn.Flags             = OFN_CREATEPROMPT | OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT;

    // Pop up the common file open dialog
    if (!GetSaveFileName(&ofn))
    {
        // User clicked cancel or closed the dialog (or an error occurred).
        return false;
    }

    if (!PersistTo(szFile))
        return false;

    strcpy(m_szName, szFile);

    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWorkspace::SetDVDRoot
// Purpose:   Called after the user has specified the new DVD root & the workspace has already been
//            Reset.  Populates the workspace with the files at the specified root.
// Arguments: 
// Return:    'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CWorkspace::SetDVDRoot(char *szRoot, bool fRecursive)
{
    // Must have reset before coming in here
    assert(m_fCleanSlate);

    // Save the path to the new dvd root
    strcpy(g_szRootFolderName, szRoot);
    
    SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT)));

    // Add the files in the specified root to our list of objects.
    gs_fPushedToScratch = false;
    m_fDefaultXbePresent = false;
    if (!AddFiles(szRoot, fRecursive))
    {
        SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW)));
        return false;
    }
    
    if (!m_fDefaultXbePresent)
    {
        // No default.xbe present! warn user
        MessageBox(m_pwindow->m_hwnd, "The specified directory does not contain " \
                   "default.xbe.\nDefault.xbe MUST be present or the application " \
                   "will fail to execute.", "Default.xbe not present",
                   MB_ICONWARNING | MB_OK);
    }

    if (gs_fPushedToScratch)
    {
        // Some files didn't fit, so they were pushed to the scratch window.  Warn
        // the user of this fact now.

        // Pop up the scratch window.
        if (!m_pwindow->m_pscratch->m_fVisible)
            SendMessage(m_pwindow->m_hwnd, WM_COMMAND, ID_VIEW_SCRATCHAREA, 0);
        
        MessageBoxResource(m_pwindow->m_hwnd, IDS_ERR_TOO_MANY_FILES_TEXT,
                           IDS_ERR_TOO_MANY_FILES_CAPTION, MB_APPLMODAL | MB_OK);
    }

    // setup the folder->child relationships.  We didn't do this during
    // AddFiles because of the way that folders are enumerated...
    m_pdvd->RefreshRelationships();    

    // After we've added all of the files, tell the DVD to refresh the folder
    // directory entry structures
    m_pdvd->RefreshDirectoryEntries(this, false);

    SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW)));

    m_fModified = false;

    // Update the views that display the workspace's information
    UpdateViews();

    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWorkspace::AddFiles
// Purpose:   Adds the files in the specified folder to the workspace.
// Arguments: 
// Return:    'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CWorkspace::AddFiles(char *szFolder, bool fRecursive)
{
    WIN32_FIND_DATA wfd;
    char szSearch[MAX_PATH];
    bool fRet;
    CObject *poNew;

    // Add all of the files in the folder 'szFolder'.  We don't do a straight recursion because
    // we need to add the folder itself after all of it's contents have been enumerated, but 
    // *before* any subdirectories are recursed into.  ie, Breadth-first, post insertion.  This
    // will create the default optimal object layout on the dvd.

    m_pdvd->ValidatePlaceholders();

    // Don't add the "_amc" directory. This is a support directory that we added
    // for layout purposes.
    if (!lstrcmpi(strrchr(szFolder, '\\') + 1, "_amc"))
        return true;

    // Create the search string
    sprintf(szSearch, "%s\\*.*", szFolder);

   
    // FIRST PASS -- ENUMERATE ALL CHILDREN, ADD ALL FILES, IGNORE FOLDERS


    // Find all files in the specified folder
    HANDLE hff = FindFirstFile(szSearch, &wfd);
    if (hff == INVALID_HANDLE_VALUE)
        return false;

    bool fFoundFile = false;

    do
    {
        if (!(wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            // Found a file.
            if (!lstrcmpi(wfd.cFileName, "default.xbe"))
                m_fDefaultXbePresent = true;

            poNew = new CObj_File(szFolder, wfd.cFileName, wfd.nFileSizeHigh, wfd.nFileSizeLow);
            if (!poNew)
                FatalError(E_OUTOFMEMORY);

            // Place the new object on the DVD.  Determine the new object's LSN automatically.
            if (!m_pdvd->InsertAtEnd(poNew))
            {
                gs_fPushedToScratch = true;
                m_pwindow->m_pscratch->AddObject(poNew);
            }

            // If this was the first file found, then make sure all of it's directory elements
            // are also added
            if (!fFoundFile)
            {
                fFoundFile = true;

                // Walk up the directory structure for the file, adding each element as we go
                char szCurPath[MAX_PATH];
                char szParentPath[MAX_PATH];
                strcpy(szCurPath, szFolder);
                strcpy(szParentPath, szFolder);
                *(strrchr(szParentPath, '\\')) = '\0';

                while (true)
                {
                    if (m_pdvd->FileExists(szCurPath))
                        break;

                    if (lstrcmpi(szCurPath, g_szRootFolderName) < 0)
                        break;

                    char *szName = szCurPath + strlen(szParentPath) + 1;
                    CObj_Folder *pofNew = new CObj_Folder(szParentPath, szName);
                    if (!pofNew)
                        FatalError(E_OUTOFMEMORY);

                    // Place the new folder object on the DVD.  Determine
                    // the new object's LSN automatically. (This will place
                    // it immediately inside the file we just placed).
                    if (!m_pdvd->InsertAtEnd(pofNew))
                    {
                        gs_fPushedToScratch = true;
                        m_pwindow->m_pscratch->AddObject(pofNew);
                    }

                    // Remove the deepest dir from the path
                    *(strrchr(szCurPath, '\\')) = '\0';
                    if (strrchr(szParentPath, '\\') == 0)
                        break;
                    *(strrchr(szParentPath, '\\')) = '\0';
                }
            }
        }
    } while (FindNextFile(hff, &wfd));
    FindClose(hff);

    // If no files were found in this folder, then explicitly add the empty
    // folder now.
    if (fFoundFile == false)
    {
        char szCurPath[MAX_PATH];
        char szParentPath[MAX_PATH];
        strcpy(szCurPath, szFolder);
        strcpy(szParentPath, szFolder);
        *(strrchr(szParentPath, '\\')) = '\0';
        char *szName = szCurPath + strlen(szParentPath) + 1;
        CObj_Folder *pofNew = new CObj_Folder(szParentPath, szName);
        if (!pofNew)
            FatalError(E_OUTOFMEMORY);

        // Place the new folder object on the DVD.  Determine
        // the new object's LSN automatically. (This will place
        // it immediately inside the file we just placed).
        if (!m_pdvd->InsertAtEnd(pofNew))
        {
            gs_fPushedToScratch = true;
            m_pwindow->m_pscratch->AddObject(pofNew);
        }
    }

    // SECOND PASS - ENUMERATE ALL CHILD FOLDERS AND RECURSE INTO THEM
    
    if (fRecursive)
    {
        hff = FindFirstFile(szSearch, &wfd);
        if (hff == INVALID_HANDLE_VALUE)
            return false;

        do
        {
            if (lstrcmpi(wfd.cFileName, ".") && lstrcmpi(wfd.cFileName, ".."))
            {
                if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                {
                    sprintf(szSearch, "%s\\%s", szFolder, wfd.cFileName);
                    if (!AddFiles(szSearch, fRecursive))
                    {
                        fRet = false;
                        goto done;
                    }
                }
            }
        } while (FindNextFile(hff, &wfd));
    }

    fRet = true;
done:
    
    FindClose(hff);

    return fRet;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWorkspace::UpdateViews
// Purpose:   Update the views onto our data.
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CWorkspace::UpdateViews()
{
    // Update the display of the DVD's data
    if (m_pwindow->m_rgplv[LV_LAYER0]->m_fModified || m_pdvd->m_rgpolLayer[0]->m_fModified)
        m_pdvd->PopulateToList(0, m_pwindow->m_rgplv[LV_LAYER0]);
    if (m_pwindow->m_rgplv[LV_LAYER1]->m_fModified || m_pdvd->m_rgpolLayer[1]->m_fModified)
        m_pdvd->PopulateToList(1, m_pwindow->m_rgplv[LV_LAYER1]);

    m_pwindow->m_rgplv[LV_LAYER0]->m_fModified = false;
    m_pwindow->m_rgplv[LV_LAYER1]->m_fModified = false;
    m_pdvd->m_rgpolLayer[0]->m_fModified = false;
    m_pdvd->m_rgpolLayer[1]->m_fModified = false;

    // Update the scratch area
    InvalidateRect(m_pwindow->m_pscratch->m_plistview->GetHwnd(), NULL, TRUE);
    
    m_pwindow->m_rgplv[LV_LAYER0]->Sort();
    m_pwindow->m_rgplv[LV_LAYER1]->Sort();

    m_pwindow->UpdateStatusBar();
}

int CWorkspace::GetNumFiles(int iLayer)
{
    return m_pdvd->GetNumFiles(iLayer);
}

int CWorkspace::GetNumEmptySectors(int iLayer)
{
    return m_pdvd->GetNumEmptySectors(iLayer);
}

int CWorkspace::GetNumUsedSectors(int iLayer)
{
    return m_pdvd->GetNumUsedSectors(iLayer);
}

bool CWorkspace::AddObjectsToLayer(CObjList *pol, int nLayer, CObject *pobjDropAt)
{
    return m_pdvd->InsertObjectList(pol, nLayer, pobjDropAt);
}

bool CWorkspace::RemoveObjectsFromLayer(CObjList *pol, int nLayer)
{
    return m_pdvd->RemoveObjectsFromLayer(pol, nLayer);
}

bool CWorkspace::RemoveObjectFromLayer(CObject *pobj, int nLayer)
{
    return m_pdvd->RemoveObjectFromLayer(pobj, nLayer);
}

// Remove all of the objects which belong to the folder, and add them to the
// list of objects to move.
bool CWorkspace::RemoveChildObjects(CObj_Folder* pof, CObjList *pol)
{
    return m_pdvd->RemoveChildObjects(pof, pol);
}

bool CWorkspace::CompactLayer(int nLayer)
{
    return m_pdvd->CompactLayer(nLayer);
}

bool CWorkspace::QueueSnapspot()
{
    // Create a snapshot of the workspace's current state and push it onto the
    // snapshot queue.
    // FUTURE: Not pushing onto a stack currently because we don't support undo/redo.

    m_pdvd->ValidatePlaceholders();

    // Use the same code that is used for saving to disk; however, we are instead
    // saving to a memory-mapped file.
    if (m_rgpfileSnapshot[0])
    {
        delete m_rgpfileSnapshot[0];
        m_rgpfileSnapshot[0] = NULL;
    }

    m_rgpfileSnapshot[0] = new CFile("snapshot.fld", FILE_MEMORY | FILE_WRITE);
    if (!m_rgpfileSnapshot[0])
        FatalError(E_OUTOFMEMORY);
    m_pdvd->PersistTo(m_rgpfileSnapshot[0]);
    m_pwindow->m_pscratch->PersistTo(m_rgpfileSnapshot[0]);
    return true;
}

bool CWorkspace::DequeueSnapspot()
{
    // Remove the 'latest' snapshot from the snapshot queue and set the workspace's
    // current state to match it.

    // FUTURE: Not using a queue yet since we don't support undo/redo.  Because
    //         of this, just grab the latest snapshot
    SendMessage(m_pwindow->m_rgplv[LV_LAYER0]->GetHwnd(),   WM_SETREDRAW, 0, 0);
    SendMessage(m_pwindow->m_rgplv[LV_LAYER1]->GetHwnd(),   WM_SETREDRAW, 0, 0);
    SendMessage(m_pwindow->m_rgplv[LV_SCRATCH]->GetHwnd(),  WM_SETREDRAW, 0, 0);

    Reset();
    m_rgpfileSnapshot[0]->SetPos(0);
    m_pdvd->CreateFrom(m_rgpfileSnapshot[0]);
    m_pwindow->m_pscratch->CreateFrom(m_rgpfileSnapshot[0]);
    m_pdvd->RefreshPlaceholders();
    UpdateViews();

    SendMessage(m_pwindow->m_rgplv[LV_LAYER0]->GetHwnd(),   WM_SETREDRAW, 1, 0);
    SendMessage(m_pwindow->m_rgplv[LV_LAYER1]->GetHwnd(),   WM_SETREDRAW, 1, 0);
    SendMessage(m_pwindow->m_rgplv[LV_SCRATCH]->GetHwnd(),  WM_SETREDRAW, 1, 0);
    return true;
}

bool CWorkspace::HandleDrawItem(WPARAM wparam, LPARAM lparam)
{
    CListView *plvDraw = (CListView*)wparam;
    return plvDraw->HandleDrawItem((LPDRAWITEMSTRUCT)lparam);
}

bool CWorkspace::CreateBIN()
{
    char szBINName[MAX_PATH];
    sprintf(szBINName, "%s\\_amc",g_szRootFolderName);
    CreateDirectory(szBINName, NULL);
    
    sprintf(szBINName, "%s\\_amc\\gdfs.bin", g_szRootFolderName);

    CFile *pfile = new CFile(szBINName, FILE_WRITE);
    if (!pfile)
        FatalError(E_OUTOFMEMORY);
    if (!pfile->IsInited())
    {
        MessageBoxResource(m_pwindow->m_hwnd, IDS_ERR_BINFILE, IDS_ERR_CANTCREATEFILE, MB_APPLMODAL | MB_OK);
        if (pfile)
            delete pfile;
        return false;
    }
    m_pdvd->PersistBIN(this, pfile);

    pfile->Close();
    delete pfile;

    return true;
}

bool CWorkspace::CreateFST()
{
    char szFSTName[MAX_PATH], szBINPath[MAX_PATH], szBINName[MAX_PATH];
    sprintf(szFSTName, "%s\\_amc",g_szRootFolderName);
    CreateDirectory(szFSTName, NULL);
    
    sprintf(szBINPath, "%s\\_amc",g_szRootFolderName);
    strcpy(szBINName, "gdfs.bin");

    sprintf(szFSTName, "%s\\_amc\\%s.fst", g_szRootFolderName, strrchr(g_szRootFolderName, '\\')+1);

    CFile *pfile = new CFile(szFSTName, FILE_WRITE);
    if (!pfile)
        FatalError(E_OUTOFMEMORY);
    if (!pfile->IsInited())
    {
        MessageBoxResource(m_pwindow->m_hwnd, IDS_ERR_FSTFILE, IDS_ERR_CANTCREATEFILE, MB_APPLMODAL | MB_OK);
        if (pfile)
            delete pfile;
        return false;
    }

    m_pdvd->PersistFST(szBINPath, szBINName, pfile);

    pfile->Close();
    delete pfile;

    return true;
}

void CWorkspace::SetModified()
{
    m_fModified = true;
//    HMENU hmenu= GetMenu(m_pwindow->m_hwnd);
    //EnableMenuItem(hmenu, ID_FILE_SAVE, MF_ENABLED);
}
void CWorkspace::ClearModified()
{
    m_fModified = false;
//    HMENU hmenu= GetMenu(m_pwindow->m_hwnd);
  //  EnableMenuItem(hmenu, ID_FILE_SAVE, MF_GRAYED);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\CWindow_Main_Drag.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CWindow_Main_Drag.cpp
// Contents:  
// Revisions: 12-Jul-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"

bool g_fDontWarnFolderMoveToScratch = false;

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  VerifyMoveFolderProc
// Purpose:   Message handler for 'Verify folder move' dialog. This function is
//            automatically called by Windows whenever a message needs to be
//            sent to the dialog box (ie 'paint', 'move', etc).
// Arguments: hDlg          -- Handle to the Dialog box's window
//            message       -- The message sent to the dialog box
//            wParam        -- A message parameter.
//            lParam        -- Another message parameter
// Return:    nonzero if we processed the message
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LRESULT CALLBACK VerifyMoveFolderProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
	case WM_INITDIALOG:
		return true;

	case WM_COMMAND:
        g_fDontWarnFolderMoveToScratch = (wParam == IDC_YESSTOPASKING);
		EndDialog(hDlg, wParam);
		return false;
	}
    return false;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWindow_Main::FinishedDrag
// Purpose:   The user finished a drag operation.  Move the selected objects.
// Arguments: plvSource     -- The list view that the drag operation began on.
//            pt            -- The point at which the mouse button was released
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CWindow_Main::FinishedDrag(CListView *plvSource, POINT pt)
{
    int nSrcListView;
    bool fInsertionSucceeded;
    CListView *plvDest;
    CObjList olToMove;
    CObject *poInsertAt;
    bool fWarned = false;

    // Determine which listview is the destination (could also be the scratch listview!)
    int nDestListView = WhichListViewUnderPt(pt);
    if (nDestListView == -1)
        return; // invalid drop spot; ignore

    switch(nDestListView)
    {
    case 0: plvDest = m_rgplv[LV_LAYER0];  break;
    case 1: plvDest = m_rgplv[LV_LAYER1];  break;
    case 2: plvDest = m_rgplv[LV_SCRATCH]; break;
    }

    if (plvSource == m_rgplv[LV_LAYER0])
        nSrcListView = 0;
    else if (plvSource == m_rgplv[LV_LAYER1])
        nSrcListView = 1;
    else
        nSrcListView = 2;

    // If drag/dropped to different lists, then clear out any previous selection
    // state in the destination list.
    if (plvDest != plvSource)
        plvDest->ClearSelected();

    // Did the user try to drop the selected files back onto themselves?  If so,
    // then don't do anything.
    if ((plvDest == plvSource) && plvDest->CheckDroppedOnSelf())
    {
        plvDest->ClearSelected();
        plvDest->ErasePreviousSelectionBar();
        return;
    }

    SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT)));

    // Disable updating in the lists until all the movement has been completed.
    SendMessage(plvDest->GetHwnd(),   WM_SETREDRAW, 0, 0);
    SendMessage(plvSource->GetHwnd(), WM_SETREDRAW, 0, 0);

    // Get the list of selected objects in the listview.  This is so that we
    // can be sure the objects remain selected after removal/re-insertion.
    m_rgplv[LV_LAYER0]->StoreSelectedObjList();
    m_rgplv[LV_LAYER1]->StoreSelectedObjList();
    m_rgplv[LV_SCRATCH]->StoreSelectedObjList();

    // Tell the destination listview that an object was dropped on it.  This will
    // let the listview determine what object the selection was dropped on.
    plvDest->ObjectDropped();

    // Take a snapshot of the workspace in case we abort part-way through the insert
    m_pws->QueueSnapspot();

    // Get the list of selected objects.  This will remove the objects from
    // the list and layer (if not in scratch window).  The objects in polToMove
    // will be in top-to-bottom order based on visibility in the listview. This
    // is so that insertion can be independent of the order of the source list.
    plvSource->GetListOfSelectedObjects(&olToMove);

    // If the destination is the scratch window, and the source isn't, then we
    // need to check if any folders are getting moved.  If they are, then we
    // need to warn the user that all of the folder's files will also be moved
    // (recursively).  Note that the files could be on a different layer than
    // the folder...
    if (nDestListView == 2 && nSrcListView != 2)
    {
        CObject *poCur = olToMove.GetInside();
        while (poCur)
        {
            if (poCur->GetType() == OBJ_FOLDER)
            {
                // Has the user already checked the "don't warn me again" checkbox?
                if (!g_fDontWarnFolderMoveToScratch && !fWarned)
                {
                    // Pop up the messagebox
                    if (DialogBox(m_hinst, (LPCTSTR)IDD_VERIFYMOVEFOLDER, m_hwnd, (DLGPROC)VerifyMoveFolderProc) == IDC_NO1)
                    {
                        // User cancelled out of the removal.
                        fInsertionSucceeded = false;
                        goto warned;
                    }
                    fWarned = true;
                }

                // Remove all of the objects which belong to this folder, and add
                // them to the list of objects to move.
                m_pws->RemoveChildObjects((CObj_Folder*)poCur, &olToMove);
            }

            // Note that the function above may have added folders to the list
            // of objects to remove.  The function was not recursive because
            // we will subsequently step over the folders as we continue
            // enumerating the list (which now includes the folders to search).
            poCur = poCur->m_poOuter;
        }
        m_pws->CompactLayer(0);
        m_pws->CompactLayer(1);
    }

    // If the source is the scratch window, and the destination isn't, then we
    // need to be sure that, for each file moved off of the scratch window, the
    // file's folder is also moved.
    if (nSrcListView == 2 && nDestListView != 2)
    {
        m_pscratch->HandleFileRemoval(&olToMove);
    }

    // If the insertion point is a security placeholder, then it's possible that
    // the upcoming compactlayer call will move an object PAST the placeholder,
    // thus screwing up our 'poInsertAt' pointer.  So, if it's a placeholder,
    // just step out to the next object.
    poInsertAt = plvDest->m_pobjDropAt;
    if (poInsertAt != (CObject*)INSERT_INSIDEEDGE && poInsertAt != (CObject*)INSERT_OUTSIDEEDGE)
        while (poInsertAt->GetType() == OBJ_SEC)
            poInsertAt = poInsertAt->m_poOuter;
            
    // After removing the selected objects from their source layer (if not scratch
    // window), we need to compact the layer towards the outside of the disk
    if (nSrcListView != 2)
        m_pws->CompactLayer(nSrcListView);
    
    if (nDestListView == 2)
    {
        // Add objects to scratch window
        fInsertionSucceeded = m_pscratch->InsertObjectList(&olToMove);
    }
    else
    {
        // Add the objects to the dvd on layer 'nDestListView' at the specified
        // location.
        fInsertionSucceeded = m_pws->AddObjectsToLayer(&olToMove, nDestListView, poInsertAt);
        if (fInsertionSucceeded)
            fInsertionSucceeded = m_pws->CompactLayer(nDestListView);
    }

    if (fInsertionSucceeded)
    {
        // The insertion succeeded, so update the window caption bar appropriately.
        m_pws->SetModified();
        m_pws->UpdateWindowCaption();
    }
    else
    {
        // Warn the user that the move couldn't be performed
        MessageBoxResource(m_hwnd, IDS_ERR_MOVE, IDS_ERR_MOVE_CAPTION, MB_ICONWARNING | MB_APPLMODAL | MB_OK);
    }

warned:

    // Restore the snapshot if we failed the insertion
    if (!fInsertionSucceeded)
        m_pws->DequeueSnapspot();

    // Now that we've moved the objects, update the views onto the layers.
    m_pws->UpdateViews();

    SendMessage(plvDest->GetHwnd(),   WM_SETREDRAW, 1, 0);
    SendMessage(plvSource->GetHwnd(), WM_SETREDRAW, 1, 0);

    // Clear out the selected object list information we stored previously.
    // This function also updates the scroll position to its previous location.
    m_rgplv[LV_LAYER0]->ClearSelectedObjList();
    m_rgplv[LV_LAYER1]->ClearSelectedObjList();
    m_rgplv[LV_SCRATCH]->ClearSelectedObjList();

    SetFocus(plvDest->GetHwnd());

    // Tell the listviews that they should go ahead and refresh themselves now.
 //   SendMessage(plvDest->GetHwnd(),   WM_SETREDRAW, 1, 0);
   // SendMessage(plvSource->GetHwnd(), WM_SETREDRAW, 1, 0);

    SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW)));
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  Window_Main::WhichListViewUnderPt
// Purpose:   Returns which listview (if any) is under the specified point.
// Arguments: pt            -- The point at which the cursor is currently
//                             located.  Specified in our coordinate system.
// Return: 0 = listview0, 1 = listview1, 2 = scratch window's listview, -1 = no listview   
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
int CWindow_Main::WhichListViewUnderPt(POINT pt)
{
    RECT rc;

    // Check if the specified point is over the scratch window's listview control
    if (m_pscratch->m_fVisible)
    {
        // Convert point from our coordinates to the scratch window's
        POINT ptScratch = pt;
        MapWindowPoints(m_hwnd, m_pscratch->m_hwnd, &ptScratch, 1);
        m_pscratch->GetChildControlRect(m_rgplv[LV_SCRATCH]->m_hwnd, &rc);
        if (PtInRect(&rc, ptScratch))
            return 2;
    }

    if (m_nCurLayerView != 1)
    {
        GetChildControlRect(m_rgplv[LV_LAYER0]->m_hwnd, &rc);
        if (PtInRect(&rc, pt))
            return 0;
    }

    if (m_nCurLayerView != 0)
    {
        GetChildControlRect(m_rgplv[LV_LAYER1]->m_hwnd, &rc);
        if (PtInRect(&rc, pt))
            return 1;
    }
    return -1;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWindow_Main::DragMove
// Purpose:   Called in the middle of a drag operation.  Updates the selection
//            bar in the appropriate list control(s).
// Arguments: pt            -- The point at which the cursor is currently
//                             located.  Specified in our coordinate system.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CWindow_Main::DragMove(POINT pt)
{
    POINT ptScratch;

    // Check if the specified point is over one of our listview controls
    switch(WhichListViewUnderPt(pt))
    {
    case 0:
        // Dragging over listview 0
        m_rgplv[LV_LAYER0]->DrawInsertionBar(pt);
        m_rgplv[LV_LAYER1]->ErasePreviousSelectionBar();
        m_rgplv[LV_SCRATCH]->ErasePreviousSelectionBar();

        SetCursor(LoadCursor(m_hinst, MAKEINTRESOURCE(IDC_MOVECURSOR)));
        break;

    case 1:
        // Dragging over listview 1
        m_rgplv[LV_LAYER1]->DrawInsertionBar(pt);
        m_rgplv[LV_LAYER0]->ErasePreviousSelectionBar();
        m_rgplv[LV_SCRATCH]->ErasePreviousSelectionBar();
        SetCursor(LoadCursor(m_hinst, MAKEINTRESOURCE(IDC_MOVECURSOR)));
        break;

    case 2:
        // Dragging over scratch window's list view
        m_rgplv[LV_LAYER0]->ErasePreviousSelectionBar();
        m_rgplv[LV_LAYER1]->ErasePreviousSelectionBar();

        // Convert point from our coordinates to the scratch window's
        ptScratch = pt;
        MapWindowPoints(m_hwnd, m_pscratch->m_hwnd, &ptScratch, 1);
        m_rgplv[LV_SCRATCH]->DrawInsertionBar(ptScratch);
        SetCursor(LoadCursor(m_hinst, MAKEINTRESOURCE(IDC_MOVECURSOR)));
        break;

    case -1:
        // Otherwise, set the cursor to 'nodrop'
        m_rgplv[LV_LAYER0]->ErasePreviousSelectionBar();
        m_rgplv[LV_LAYER1]->ErasePreviousSelectionBar();
        m_rgplv[LV_SCRATCH]->ErasePreviousSelectionBar();
        SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_NO)));
        break;
    }
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWindow_Main::EraseAllSelectionBars
// Purpose:   Erases the selection bars in all of the listview controls.
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CWindow_Main::EraseAllSelectionBars()
{
    m_rgplv[LV_LAYER0]->ErasePreviousSelectionBar();
    m_rgplv[LV_LAYER1]->ErasePreviousSelectionBar();
    m_rgplv[LV_SCRATCH]->ErasePreviousSelectionBar();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\CWorkspace.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      cworkspace.h
// Contents:  
// Revisions: 13-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

class CWindow_Main;
class CDVD;

#define MAX_UNDO_DEPTH 100

class CWorkspace : public CInitedObject
{
public:
    CWorkspace(CWindow_Main *pwindow);
    ~CWorkspace();
    bool Init();

    bool Close();
    void Reset();
    bool Open();
    bool Save();
    bool SaveAs();
    bool New();

    bool PersistTo(char *szFLDName);

    // Sets the path to the source files that represents the root of the dvd.
    bool SetDVDRoot(char *szRoot, bool fRecursive);

    int GetNumFiles(int iLayer);
    int GetNumEmptySectors(int iLayer);
    int GetNumUsedSectors(int iLayer);
 //   bool MoveSelectedObjectsToScratch(int nLayer, CWindow_Scratch *pscratch);
   // bool MoveSelectedObjectsFromScratch(int nLayer, CWindow_Scratch *pscratch);

    bool AddObjectsToLayer(CObjList *pol, int nLayer, CObject *pobjDropAt);
    bool RemoveObjectsFromLayer(CObjList *pol, int nLayer);
    bool RemoveObjectFromLayer(CObject *pobj, int nLayer);
    bool QueueSnapspot();
    bool DequeueSnapspot();

    void UpdateWindowCaption();
    void SetModified();
    void ClearModified();

    // Updates the views onto the workspace's data
    void UpdateViews();

    bool CompactLayer(int nLayer);

    bool HandleDrawItem(WPARAM wparam, LPARAM lparam);

    bool CreateBIN();
    bool CreateFST();

    bool RemoveChildObjects(CObj_Folder* pof, CObjList *pol);

//private:

    CFile *m_rgpfileSnapshot[MAX_UNDO_DEPTH];
    bool m_fModified;

    // Our virtual DVD object.
    CDVD *m_pdvd;

    // Adds the files in the specified folder to our DVD.
    bool AddFiles(char *szFolder, bool fRecursive);

    // A pointer to the window that contains the UI elements allowing interaction with the workspace
    CWindow_Main *m_pwindow;

    // if true, then *no* modifications have been made since NEW or OPEN occurred.
    bool m_fCleanSlate;

    bool m_fDefaultXbePresent;
    char m_szName[MAX_PATH];
};

typedef struct
{
    WORD wMajor;
    WORD wMinor;
    WORD wBuild;
    WORD wQFE;
} sVersion;

#define FLD_SIG "XBOXFLDFILE"
#define FLD_SIG_SIZE sizeof(FLD_SIG)

typedef struct
{
    BYTE  szSig[FLD_SIG_SIZE];
    time_t timeSaved;
    sVersion version;
} sFLDHeader;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\CWindow_Scratch.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CScratch.cpp
// Contents:  
// Revisions: 14-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CWindow_Scratch::CWindow_Scratch(DWORD dwWindowCreationFlags, CWindow *pwindowParent) : CWindow("Scratch", dwWindowCreationFlags, pwindowParent->m_hinst)
{
    m_pwindowParent = pwindowParent;
}

bool CWindow_Scratch::Init()
{
    // Set our menu name (necessary for base class initialization)
    strcpy(m_szMenuName, "");

    // Do base class initialization
    if(!CWindow::Init(m_pwindowParent))
        return false;

    // Create our listview
    m_plistview = new CListView();
    if (!m_plistview)
        FatalError(E_OUTOFMEMORY);
    if (!m_plistview->Init(this, false, false))
        return false;

    // Set the window's initial size and positioned if it was previously known
    if (m_dwWindowCreationFlags & FLAG_WINDOW_POS_LASTKNOWN)
        SetLastKnownPos();
   
    SetCaption("Unplaced files");

    m_fVisible = false; 

    return true;
}

CWindow_Scratch::~CWindow_Scratch()
{
    DestroyWindow(m_hwnd);
}

void CWindow_Scratch::Uninit()
{
    delete m_plistview;
}

// save out contents to the specified file
bool CWindow_Scratch::PersistTo(CFile *pfile)
{
    CObjList olTemp;
    CObj_Group *pogPrev = NULL;
    
    // Copy our contents to the temporary object list
    int iItem = -1;
    while ((iItem = ListView_GetNextItem(m_plistview->m_hwnd, iItem, 0)) != -1)
    {
        CObject *poCur = m_plistview->GetObjectFromIndex(iItem);
        poCur->RemoveFromList();

        if (poCur->m_pog && poCur->m_pog != pogPrev)
        {
            poCur->m_pog->RemoveFromList();
            olTemp.AddToTail(poCur->m_pog);
            pogPrev = poCur->m_pog;
        }

        olTemp.AddToTail(poCur);
    }

    // Persist the temporary object list
    olTemp.PersistTo(pfile);

    olTemp.Clear();
	return true;
}

CObject *CWindow_Scratch::FindObjectByFullFileName(char *szName)
{
    int iItem = -1;
    while ((iItem = ListView_GetNextItem(m_plistview->m_hwnd, iItem, 0)) != -1)
    {
        CObject *poCur = m_plistview->GetObjectFromIndex(iItem);

        if (!lstrcmpi(szName, poCur->m_szFullFileName))
            return poCur;
    }

	return NULL;
}


bool CWindow_Scratch::CreateFrom(CFile *pfile)
{
    // Create and populate a temporary list with the objects from the file
    CObjList olTemp;
    olTemp.CreateFrom(pfile);

    // Populate our list with the objects in the temporary list
    CObject *poCur;
    while ((poCur = olTemp.GetOutside()) != NULL)
    {
        poCur->RemoveFromList();
        m_plistview->AddObject(poCur);
    }

	return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWindow_Scratch::DerivedWndProc
// Purpose:   Handle messages that are specific to this derived window.  Most common messages are
//            already automatically sent to the appropriate "OnFOO" functions.
// Arguments: uMsg              -- The message being reported.
//            wparam            -- Parameter 1 (message-specific)
//            lparam            -- Parameter 2 (message-specific)
// Return:    Result of the message processing - depends on the message sent.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL CWindow_Scratch::DerivedWndProc(UINT uMsg, WPARAM wparam, LPARAM lparam) 
{
    switch (uMsg) 
    {
    case WM_DRAWITEM:
        return m_plistview->HandleDrawItem((LPDRAWITEMSTRUCT)lparam);

    case WM_CLOSE:
        // User clicked on the 'close' button on the scratch window.  Tell the
        // main window to hide us
        SendMessage(m_pwindowParent->m_hwnd, WM_COMMAND, ID_VIEW_SCRATCHAREA, 0);

        // Return zero so that we tell the OS "we handled the message; DON'T
        // close the window"
        return 0;
    }

    // Let windows handle the rest
    return DefWindowProc(m_hwnd, uMsg, wparam, lparam);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CWindow_Scratch::OnSize
// Purpose:   Called when the user resizes the window.  We resize the controls to fill the new
//            window size
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CWindow_Scratch::OnSize()
{
    // Get the new dimensions of the window
    GetClientRect(m_hwnd, &m_rc);

    // Resize the list control to fit the window
    m_plistview->MoveTo(0, 0, (m_rc.right - m_rc.left), m_rc.bottom - m_rc.top);
}

void CWindow_Scratch::ToggleView()
{
    m_fVisible = !m_fVisible;
    ShowWindow(m_hwnd, m_fVisible ? SW_SHOW : SW_HIDE);
}

void CWindow_Scratch::AddObject(CObject *pobj)
{
    m_plistview->AddObject(pobj);
}

void CWindow_Scratch::FinishedDrag(CListView *plvSource, POINT pt)
{
    // let the main window handle this
    MapWindowPoints(m_hwnd, m_pwindowParent->m_hwnd, &pt, 1);
    m_pwindowParent->FinishedDrag(plvSource, pt);
}

void CWindow_Scratch::DragMove(POINT pt)
{
    // Let the main window handle this.  'pt' is in terms of our coordinates,
    // so first convert to the main window's coordinates
    MapWindowPoints(m_hwnd, m_pwindowParent->m_hwnd, &pt, 1);
    m_pwindowParent->DragMove(pt);
}

void CWindow_Scratch::EraseAllSelectionBars()
{
    m_pwindowParent->EraseAllSelectionBars();
}

bool CWindow_Scratch::HandleFileRemoval(CObjList *pol)
{
    // for each file moved off of the scratch window, the file's folder is also
    // moved.  This is done without warning the user.
    CObject *poCur = pol->GetInside();
    while (poCur)
    {
        // Ensure the current object's parent folder is not in the listview.
        // If it is, then remove it from the listview and add it to the list of
        // objects to move (immediately after poCur, so that the folder is then
        // subsequently checked, gauranteeing recursiveness).
        int iFolder = m_plistview->GetIndexFromObject(poCur->m_pof);
        if (iFolder != -1)
        {
            // Folder is in the listview.  remove it.
            poCur->m_pof->RemoveFromList();
            m_plistview->RemoveObject(poCur->m_pof);
            pol->InsertAfter(poCur->m_pof, poCur);
        }
        poCur = poCur->m_poOuter;
    }
    return true;
}  
void CWindow_Scratch::SetGroupable(bool fGroupable)
{
    // We don't allow grouping or ungrouping in the scratch window
    m_pwindowParent->SetGroupable(fGroupable);
}

void CWindow_Scratch::SetUngroupable(bool fUngroupable)
{
    // We don't allow grouping or ungrouping in the scratch window
    m_pwindowParent->SetUngroupable(fUngroupable);
}


bool CWindow_Scratch::InsertObjectList(CObjList *polToInsert)
{
    int iObject = m_plistview->m_iDropPoint;
    CObject *poToInsert = polToInsert->GetInside();
    while (poToInsert)
    {
        CObject *poNext = polToInsert->GetNextOuter();
        polToInsert->Remove(poToInsert);
        if (poToInsert->GetType() != OBJ_GROUP)
        {
            m_plistview->AddObjectAtIndex(poToInsert, iObject);
            iObject++;
        }
        poToInsert = poNext;
    }
    return true;
}

bool CWindow_Scratch::OnNotify(WPARAM wparam, LPARAM lparam)
{
    return m_pwindowParent->OnNotify(wparam, lparam);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\FLDVersion.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      FLDVersion.h
// Contents:  Contains versioning numbers for FLD file support
// Revisions: 17-Jul-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// FLDFILE_MAGIC_NUMBER     -- Used to identify an fld file.  Arbitrarily chosen
#define FLDFILE_MAGIC_NUMBER  0x31415169
#define FLDFILE_MAJOR_VERSION 0x01
#define FLDFILE_MINOR_VERSION 0x02

#define FLDFILE_AMC_MAGIC_NUMBER  0xCC
#define FLDFILE_AMC_MAJOR_VERSION 0x01
#define FLDFILE_AMC_MINOR_VERSION 0x03
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\ifld.h ===
/* IFld.h -*- C++ -*- */

//******************************************************************************
//
// COPYRIGHT (C) 2000 APPLIED MICROSYSTEMS CORPORATION.  ALL RIGHTS RESERVED.
// UNPUBLISHED -- RIGHTS RESERVED UNDER THE COPYRIGHT LAWS OF THE UNITED
// STATES.  USE OF A COPYRIGHT NOTICE IS PRECAUTIONARY ONLY AND DOES NOT
// IMPLY PUBLICATION OR DISCLOSURE.
//
// THIS SOFTWARE CONTAINS CONFIDENTIAL INFORMATION AND TRADE SECRETS OF
// APPLIED MICROSYSTEMS CORPORATION.  USE, DISCLOSURE, OR REPRODUCTION IS
// PROHIBITED WITHOUT THE PRIOR EXPRESS WRITTEN PERMISSION OF APPLIED
// MICROSYSTEMS CORPORATION.
//
//                 RESTRICTED RIGHTS LEGEND
//
// Use, duplication, or disclosure by the Government is subject to
// restrictions as set forth in subparagraph (c)(1)(ii) of the Rights
// in Technical Data and Computer Software clause at DFARS 252.227-7013
// or subparagraphs (c)(1) and (2) of Commercial Computer Software --
// Restricted Rights at 48 CFR 52.227-19, as applicable.
//
// Applied Microsystems Corporation
// 5020 148th Ave NE
// Redmond, WA 98052
//
//******************************************************************************
//
// Contents:
//
//      Interface to access the FLD files.
//
// Main authors:
//
//      03/14/01,pwl - initial version
//
// Target restrictions:
//
//      Identify target builds not supported by this header file.
//
// Tool restrictions:
//
//      Identify build tool limitations for this header file.
//
// Things to do:
//
//      Identify must-do, should-do, and wish-list items.
//
//******************************************************************************

#ifndef IFLD_H
#define IFLD_H

#if defined(_MSC_VER) && (_MSC_VER > 1000)
#pragma once
#endif

#if defined (WIN32)
#pragma warning (disable : 4251) // X needs to have dll-interface to be used by client
#endif  // WIN32

// Uses other components
class IDiscLayout;  // from "IDiscLayout.h"

// Uses windows libraries
#include <windows.h>

// Uses standard libraries
#include <wchar.h>
#include <string>

#ifdef _MSC_VER
#ifdef LAYOUTENGINE_EXPORTS
#define LAYOUTENGINE_API __declspec(dllexport)
#else
#define LAYOUTENGINE_API __declspec(dllimport)
#endif
#else
#define LAYOUTENGINE_API
#endif

class CFldImpl;

/* ********************************************************** */
class LAYOUTENGINE_API IFld 
{
// --- public interface
public:
    typedef unsigned long tNodeIdx;

    friend class CFldImpl;

    enum EMaxErrorLength
    {
        MAX_LENGTH = 255
    };

    // Create, Open and Close a File Layout Descriptor file 
    // (new binary format only)
    bool IsFileReadOnly( const TCHAR * fname );
    bool CreateFld( const char* fname );
    bool CreateFld( const wchar_t* fname );
    bool OpenFld( const char* fname, bool bReadOnly=true );
    bool OpenFld( const wchar_t* fname, bool bReadOnly=true );
    void CloseFld();

    // Save and Load of disc layout specified by IDiscLayout
    bool SaveDiscLayout( const IDiscLayout& discLayout );
    bool LoadDiscLayout( IDiscLayout& discLayout );

    // General information
    bool GetVolName( const char** name );
    bool GetVolSetName( const char** name );
    bool SetVolName( const char* name );
    bool SetVolSetName( const char* name );
    bool GetVolName( const wchar_t** name );
    bool GetVolSetName( const wchar_t** name );
    bool SetVolName( const wchar_t* name );
    bool SetVolSetName( const wchar_t* name );

    // Error Handling
    const wchar_t * const GetLastErrorString( void )
    {
        return m_wszErrorMessage.c_str();
    }

    // file tree API
    tNodeIdx GetNumElem();
    tNodeIdx GetRootDir();
    tNodeIdx GetParentDir( tNodeIdx idx );
    tNodeIdx GetFirstElemInDir( tNodeIdx idx );
    tNodeIdx GetNextSiblingElem( tNodeIdx idx );
    
    // node info API - the life time of the retrun
    // strings are only between calls to another
    // call that returns strings.
    bool GetName( tNodeIdx idx, const char** name );
    bool GetName( tNodeIdx idx, const wchar_t** name );
    bool GetPath( tNodeIdx idx, const char** name );
    bool GetPath( tNodeIdx idx, const wchar_t** name );
    bool GetSrcPath( tNodeIdx idx, const char** name );
    bool GetSrcPath( tNodeIdx idx, const wchar_t** name );
    bool GetSize(    tNodeIdx idx,   unsigned long& size );
    bool GetLayer(   tNodeIdx idx,   unsigned int&  layer );
    bool GetBlockSize( tNodeIdx idx, unsigned long& blocks );
    bool GetStartLsn(  tNodeIdx idx, unsigned long& lsn );
    bool SetLayer(     tNodeIdx idx, unsigned int   layer );
    bool SetBlockSize( tNodeIdx idx, unsigned long  blocks );
    bool SetStartLsn(  tNodeIdx idx, unsigned long  lsn );
    bool IsDirectory(   tNodeIdx idx );
    bool IsFile(   tNodeIdx idx );
    bool IsPlaceHolder( tNodeIdx idx );
    bool IsXbe( tNodeIdx idx );
    bool IsEmpty( tNodeIdx idx );

    // Data blocks API
    unsigned long GetNumDataBlock();
    tNodeIdx GetDataBlockIndex( int placement );

// --- class specfic
public: IFld();
public: ~IFld();
// compiler generated...
private: IFld(const IFld& rhs); 
private: IFld& operator=(const IFld& rhs);
private: IFld* operator&();
private: const IFld* operator&() const;
    
// --- private data members
private:
    CFldImpl *mImpl;


// --- Private methods
private:
    void SetFileErrorMessage( DWORD nMessageId, bool bPrintStrerror = false );
    void SetNoArgErrorMessage( DWORD nMessageId );

    // For error messages only!!   
    std::wstring m_wszErrorMessage;
    std::wstring m_wszFileName;
};


#endif // IFLD_H
/* **************************** End of File ******************************* */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\Profiler.cpp ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Module Name:

    Profiler.c

Abstract:

    Profiling code

-------------------------------------------------------------------*/

// ++++ Include Files +++++++++++++++++++++++++++++++++++++++++++++++
#include "stdafx.h"

#ifdef DO_PROFILE

long *pOutputBuffer;
long *pOutputCursor;
long tagReturnTag[4096];
short tagReturnThread[4096];
long resourceStart[4096];
int tagType[4096];
typeProfileInfo g_rgprofinfo[MAX_PROFILE_EVENTS];

DWORD g_dwTickStart;
int   g_iCurProfEvent = 0;
DWORD g_dwPerfFreq;

__inline DWORD GetTick()
{
    LARGE_INTEGER li;
    QueryPerformanceCounter(&li);
    return li.LowPart;
}

void AppendEntry(int nType, int nStart, int nEnd)
{
    *pOutputCursor++ = nType;
    *pOutputCursor++ = (long)((float)(nStart - g_dwTickStart) / 397.f * 500000.f * 10000.f / (float)g_dwPerfFreq);
    *pOutputCursor++ = (long)((float)(nEnd - g_dwTickStart) / 397.f * 500000.f  * 10000.f / (float)g_dwPerfFreq);
}

int g_cProfileMappings;
char g_rgszProfileMappings[100][200];
int g_cPredefinedMappings;
void InitProfile()
{
    LARGE_INTEGER li;
    QueryPerformanceFrequency(&li);
    g_dwPerfFreq = li.LowPart;

    g_dwTickStart = GetTick();
    g_iCurProfEvent = 0;

    // Create the pre-defined mappings
    g_cProfileMappings = 0;

    char *rgszPredefinedMappings[] = {
        "Profile End",
        "CDVD::Reset",
        "CDVD::PopulateToList",
        "CDVD::CompactLayer",
        "CDVD::RefreshRelationships",
        "CDVD::PopulateDirEntries",
        "CDVD::RefreshFolderDirectoryEntry",
        "CDVD::RefreshDirectoryEntries",
        "CDVD::Insert",
        "CDVD::ValidatePlaceholders",
        "CDVD::CheckValidPlaceholderLSN",
        "CDVD::RefreshPlaceholders",
        "CDVD::PersistTo",
        "CDVD::CreateFrom",
        "CDVD::PersistFST",
        "CDVD::PersistBIN",
        0
    };

    while (rgszPredefinedMappings[g_cProfileMappings])
    {
        strcpy(g_rgszProfileMappings[g_cProfileMappings], rgszPredefinedMappings[g_cProfileMappings]);
        g_cProfileMappings++;
    }
    g_cPredefinedMappings = g_cProfileMappings - 1;
}

DWORD MapProfile(char *szName)
{
    strcpy(g_rgszProfileMappings[g_cProfileMappings++], szName);
    return g_cProfileMappings - 1;
}

void StartProfile(DWORD nType)
{
    // Store the info in memory - we'll parse it at the end
    g_rgprofinfo[g_iCurProfEvent].dwTick = GetTick();
    g_rgprofinfo[g_iCurProfEvent].nType = nType;
    g_iCurProfEvent++;
}

void EndProfile(DWORD nType)
{
    // Store the info in memory - we'll parse it at the end
    g_rgprofinfo[g_iCurProfEvent].dwTick = GetTick();
    g_rgprofinfo[g_iCurProfEvent].nType = nType | END_EVENT;
    g_iCurProfEvent++;
}

void DumpProfile()
{
	char szTemp[512];
	HANDLE hfile;
	long tag;
	int funcTag;
	int funcStart;
    unsigned long tmpVal;
    int i;
	DWORD dwWritten;

    // **************************************
    // Create the tags.log file.  Hack one up
    // **************************************

    // Create the tags file
	hfile = CreateFile(TEXT("\\tags.log"), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	sprintf( szTemp, "tagtype,tag,subtag,description,datadesc1,datadesc2\r\n");
	WriteFile(hfile, szTemp, strlen(szTemp), &dwWritten, NULL); 
    // Write TAG_RANGE_START(TAG_RANGE_DDHAL	, "DDHAL / D3DHAL" )
	sprintf( szTemp, "%d,%d,%d,%s,%s,%s\r\n", 0, 0, 0, "xbGameDisc", "", "");
	WriteFile(hfile, szTemp, strlen(szTemp), &dwWritten, NULL); 
	sprintf( szTemp, "%d,%d,%d,%s,%s,%s\r\n", 1, 1, 0, "xbGameDisc", "", "");
	WriteFile(hfile, szTemp, strlen(szTemp), &dwWritten, NULL); 

    // Write out each of the tags
    for (i = 0; i < g_cProfileMappings; i++)
    {
	    sprintf( szTemp, "%d,%d,%d,%s,%s,%s\r\n", 10, i+2, 0, g_rgszProfileMappings[i], "", "");
	    WriteFile(hfile, szTemp, strlen(szTemp), &dwWritten, NULL); 
    }

    // We're done with the tags file - close it.
	CloseHandle(hfile);

    // **************************************
    // Now write out the events to events.log
    // **************************************

	pOutputBuffer = (long *)malloc(2000000);
	assert (pOutputBuffer);
	pOutputCursor = pOutputBuffer;

	for( tag=0; tag<4096; tag++ )
	{
		tagType[tag] = -1;
		tagReturnTag[tag] = -1;
		tagReturnThread[tag] = -1;
		resourceStart[tag] = -1;
	}
	funcTag = -1;


    for (i = 0; i < g_iCurProfEvent; i++)
    {
		tag = g_rgprofinfo[i].nType;
		if (tag & END_EVENT)
		{
			// Exit function
			AppendEntry(((tag & 0x7FFFFFFF)+2)<<4, funcStart, g_rgprofinfo[i].dwTick );
            funcStart = g_rgprofinfo[i].dwTick;
			funcTag   = tagReturnTag[(tag & 0x7FFFFFFF)];
			tagReturnTag[(tag & 0x7FFFFFFF)] = -1;
		}
		else
		{
			// Enter function
			if(funcTag != -1 ) // already in a function - this will go one deeper
				AppendEntry((funcTag+2)<<4, funcStart, g_rgprofinfo[i].dwTick );
			tagReturnTag[tag] = funcTag;
			funcTag           = tag;
			funcStart         = g_rgprofinfo[i].dwTick;
		}
    }

	// For now, we copy all data... later we may only copy up to the timelog of the last entry
	hfile = CreateFile("\\Events.log", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	tmpVal = ((unsigned long) pOutputCursor - (unsigned long) pOutputBuffer)>>2;

	WriteFile(hfile, &tmpVal, 4, &dwWritten, NULL);
	WriteFile(hfile, pOutputBuffer, (unsigned long)pOutputCursor - (unsigned long)pOutputBuffer, &dwWritten, NULL);
	FlushFileBuffers(hfile);
    CloseHandle(hfile);

	free((void *)pOutputBuffer);
}
#else
DWORD MapProfile(char *szName)
{
    return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#pragma warning(disable:4530)
#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <commctrl.h>
#include <gdformat.h>
#include <limits.h>
#include <stdlib.h>
#include <time.h>

#include "resource.h"
#include "FLDVersion.h"
#include "Profiler.h"
#include "CInitedObject.h"
#include "Util.h"
#include "CFile.h"
#include "CObject.h"
#include "CListView.h"
#include "CStatusBar.h"
#include "CColorBar.h"
#include "CToolbar.h"
#include "CWorkspace.h"
#include "CWindow.h"
#include "CWindow_Scratch.h"

#include "CWindow_Main.h"
#include "CDVD.h"

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\Profiler.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     Profiler.hpp
// Contents: This file includes profiling-related defines and function declarations.
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ DEFINES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// DO_PROFILE -- define this if you want to enable profiling.  Warning - this causes things to run
//               slower, so never ship with this enabled!
//#define DO_PROFILE


// Various things that we profile:
enum {
    PROFILE_END,
    PROFILE_RESET,
    PROFILE_POPULATETOLIST,
    PROFILE_COMPACTLAYER,
    PROFILE_REFRESHRELATIONSHIPS,
    PROFILE_POPULATEDIRENTRIES,
    PROFILE_REFRESHFOLDERDIRECTORYENTRY,
    PROFILE_REFRESHDIRECTORYENTRIES,
    PROFILE_INSERT,
    PROFILE_VALIDATEPLACEHOLDERS,
    PROFILE_CHECKVALIDPLACEHOLDERLSN,
    PROFILE_REFRESHPLACEHOLDERS,
    PROFILE_PERSISTTO,
    PROFILE_CREATEFROM,
    PROFILE_PERSISTFST,
    PROFILE_PERSISTBIN,
};

#ifdef DO_PROFILE

#define END_EVENT 0x80000000
#define MAX_TAGS 2000

typedef struct tagProfileInfo
{
    DWORD dwTick;
    int   nType;
} typeProfileInfo;

#define MAX_PROFILE_EVENTS 1000000    // 1,000,000 events max
extern void StartProfile(DWORD dw);
extern void EndProfile(DWORD dw);
extern void DumpProfile();
extern void InitProfile();

#else
__inline void InitProfile() {}
__inline void StartProfile(DWORD dw) {}
__inline void EndProfile(DWORD dw) {}
__inline void DumpProfile() {}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by xbLayout.rc
//
#define IDS_COLUMN_NAME                 1
#define IDS_COLUMN_FOLDER               2
#define IDS_COLUMN_SIZE                 3
#define IDS_COLUMN_LSN                  4
#define IDS_ERR_DIRGROW_TEXT            5
#define IDS_ERR_DIRGROW_CAPTION         6
#define IDS_ERR_DIRGROW2_TEXT           7
#define IDS_ERR_DIRGROW2_CAPTION        8
#define IDS_ERR_OPENAMCFLD_TEXT         9
#define IDS_ERR_OPENAMCFLD_CAPTION      10
#define IDS_ERR_AMCFLDVER_TEXT          11
#define IDS_ERR_AMCFLDVER_CAPTION       12
#define IDS_IMPORT_CAPTION              13
#define IDS_IMPORT_TEXT                 14
#define IDS_OBJECT_BOOKEND              15
#define IDS_OBJECT_VOLDESC              16
#define IDS_OBJECT_SECURITY             17
#define IDS_OBJECT_EMPTY                18
#define IDS_TOOLBAR_NEW                 19
#define IDS_TOOLBAR_OPEN                20
#define IDS_TOOLBAR_SAVE                21
#define IDS_TOOLBAR_GROUP               22
#define IDS_TOOLBAR_UNGROUP             23
#define IDS_TOOLBAR_EMULATE             24
#define IDS_TOOLBAR_PREMASTER           25
#define IDS_TOOLBAR_BFE                 26
#define IDS_TOOLBAR_VIEW0               27
#define IDS_TOOLBAR_VIEW1               28
#define IDS_TOOLBAR_VIEWBOTH            29
#define IDS_TOOLBAR_VIEWSCRATCH         30
#define IDS_WINDOW_CAPTION              31
#define IDS_ERR_LAUNCHDVDEMU_TEXT       32
#define IDS_ERR_LAUNCHDVDEMU_CAPTION    33
#define IDS_ERR_LAUNCHPREM_CAPTION      34
#define IDS_ERR_LAUNCHPREM_TEXT         35
#define IDS_STATUS                      36
#define IDS_STATUS2                     37
#define IDS_ABOUT                       38
#define IDS_BFE_SUCCESS                 39
#define IDS_BFE_CAPTION                 40
#define IDS_BFE_FAILURE                 41
#define IDS_ERR_MOVE                    42
#define IDS_ERR_MOVE_CAPTION            43
#define IDS_WS_MODIFIED_TEXT            44
#define IDS_WS_MODIFIED_CAPTION         45
#define IDS_OPEN_FILTER                 46
#define IDS_OPEN_TITLE                  47
#define IDS_ERR_OPEN_TEXT               48
#define IDS_ERR_OPEN_CAPTION            49
#define IDS_ERR_INVALID_FILE_TEXT       50
#define IDS_ERR_INVALID_FILE_CAPTION    51
#define IDS_ERR_INVALID_FILE_VER_TEXT   52
#define IDS_ERR_INVALID_FILE_VER_CAPTION 53
#define IDS_ERR_CANTIMPORT_TEXT         54
#define IDS_ERR_CANTIMPORT_CAPTION      55
#define IDS_NEW_TITLE                   56
#define IDS_ERR_SAVE_TEXT               57
#define IDS_ERR_SAVE_CAPTION            58
#define IDS_SAVEAS_TITLE                59
#define IDS_ERR_TOO_MANY_FILES_TEXT     61
#define IDS_ERR_TOO_MANY_FILES_CAPTION  62
#define IDS_ERR_BINFILE                 63
#define IDS_ERR_FSTFILE                 64
#define IDS_ERR_CANTCREATEFILE          65
#define IDS_HELP_FILE_NAME              66
#define IDS_ERR_LAUNCHHELP_TEXT         67
#define IDS_ERR_LAUNCHHELP_CAPTION      68
#define IDS_ERR_MUSTSAVE_TEXT           69
#define IDS_ERR_MUSTSAVE_CAPTION        70
#define IDS_TOOLBAR_VIEWRESCAN          71
#define IDR_MENU1                       101
#define IDD_MAIN                        102
#define IDC_ACCEL                       103
#define IDD_DIALOG1                     106
#define BMP_TOOLBAR                     107
#define IDD_ABOUTBOX                    108
#define IDB_ABOUT                       110
#define IDC_MOVECURSOR                  113
#define IDD_ENTRY                       114
#define IDD_VERIFYMOVEFOLDER            115
#define IDC_BUTTON1                     1000
#define IDC_LIST1                       1001
#define IDC_TREE1                       1002
#define IDC_EDIT1                       1003
#define IDC_MYICON                      1004
#define IDC_ABOUTTEXT                   1005
#define IDC_ENTRY_OPENEXISTING          1009
#define IDC_ENTRY_CREATENEW             1010
#define IDC_ENTRY_QUIT                  1011
#define IDC_NO1                         1012
#define IDC_YES                         1014
#define IDC_YESSTOPASKING               1015
#define ID_FILE_NEW                     40001
#define ID_FILE_OPEN                    40002
#define ID_FILE_SAVE                    40003
#define ID_FILE_SAVEAS                  40004
#define ID_FILE_EXIT                    40005
#define ID_EDIT_GROUP                   40006
#define ID_EDIT_UNGROUP                 40007
#define ID_EDIT_SELECTALL               40008
#define ID_TOOLS_EMULATE                40009
#define ID_TOOLS_PREMASTERTAPE          40010
#define ID_TOOLS_BUILDFOREMULATION      40011
#define ID_HELP_ABOUTXBOXDVDLAYOUTTOOL  40012
#define ID_VIEW_LAYER0                  40013
#define ID_VIEW_LAYER1                  40014
#define ID_VIEW_BOTHLAYERS              40015
#define ID_VIEW_SCRATCHAREA             40016
#define ID_HELP_CONTENTS                40017
#define ID_VIEW_RESCANLAYOUT            40018
#define IDS_COLORBAR_TOOLTIP            40019
#define IDC_STATIC                      -1
#define IDB_FOLDER                      1016
#define IDB_FOLDERSEL                      1017
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        116
#define _APS_NEXT_COMMAND_VALUE         40020
#define _APS_NEXT_CONTROL_VALUE         1018
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	xbLayout.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\Util.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      util.cpp
// Contents:  
// Revisions: 7-Jul-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  DumpLayer
// Purpose:   Temp debug function
// Arguments: pol           -- List to dump
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void DumpLayer(CObjList *pol)
{
#ifdef _DEBUG1
    char *rgszType[] = {"Sec", "BE", "VolDesc", "File", "Folder", "Group"};
    CObject *poCur = pol->GetOutside();
    int iLayer = 0;
    while (poCur)
    {
        char sz[1024];
        if (!(iLayer%4))
            OutputDebugString("\r\n");
        iLayer++;
        sprintf(sz, "[%s] '%s' =%d=", rgszType[poCur->GetType()],
                poCur->m_szName, poCur->m_dwLSN);
        if (poCur->m_pog)
            strcat(sz, " {g}");
        strcat(sz, " -->  ");
        OutputDebugString(sz);
        poCur = poCur->m_poInner;
    }
    OutputDebugString("NULL\r\n"); 
#endif
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  DebugOutput
// Purpose:   Outputs a variable-argument string to the debugger.  Used like
//            printf.
// Arguments: sz            -- Format to use (ie the first parm to printf() )
//            ...           -- [optional] Variable number of arguments.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void DebugOutput(char *sz, ...)
{
#ifdef _DEBUG
    char szOut[255];
    va_list args;
    va_start(args, sz);

    vsprintf(szOut, sz, args);
    OutputDebugString(szOut);
    va_end(args);
#endif
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  FormatByteString
// Purpose:   
// Arguments: 
// Return:   None 
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void FormatByteString(DWORD dwVal, char *szDest)
{
    // Set nPrecision to the number of digits after the decimal point you want.
    int nPrecision = 2;
    float r = (float)dwVal;
	char *rgsz[] = {"Bytes", "KB", "MB", "GB"};
	int iName = 0;

	while(r > 1024.0f && iName < 3)
	{
        r /= 1024.0f; iName++;
	}

    if (r - (float)((int)r) == 0.0f)
        sprintf(szDest, "%d %s", (int)r, rgsz[iName]);
    else
        sprintf(szDest, "%0.*f %s", nPrecision, r, rgsz[iName]);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  FatalError
// Purpose:   Called when an unrecoverable error has occurred.  Forces exit
//            after notification
// Arguments: dwErr         -- The error that occurred
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void FatalError(DWORD dwErr)
{
    char szError[1024], szCaption[1024];

    switch(dwErr)
    {
    case E_OUTOFMEMORY:
        sprintf(szError, "There is not enough memory available to complete the action.\n"\
                         "xbLayout will now close.  Please close other open applications"\
                         " and try again.");
        sprintf(szCaption, "Unrecoverable Error: Out of Memory");
        break;
    default:
        assert(false);
        break;
    }

    MessageBox(NULL, szError, szCaption,  MB_ICONEXCLAMATION | MB_OK);
    exit(-1);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  MessageBoxResource
// Purpose:   Display a messagebox using string resources
// Arguments: hwnd        -- Handle to the window 'owning' the messagebox
//            dwTextId    -- String resource id of the text string
//            dwCaptionId -- String resource id of the caption string
//            dwFlags     -- Flags for the messagebox
// Return:    Button pressed
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
DWORD MessageBoxResource(HWND hwnd, DWORD dwTextId, DWORD dwCaptionId, DWORD dwFlags)
{
    char szText[2048], szCaption[256];
    LoadString(g_hinst, dwTextId,    szText,    2048);
    LoadString(g_hinst, dwCaptionId, szCaption, 256);
    return MessageBox(hwnd, szText, szCaption, dwFlags);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  MessageBoxResourceParam
// Purpose:   Display a messagebox using string resources.  Expects one string
//            param for the text string.
// Arguments: hwnd        -- Handle to the window 'owning' the messagebox
//            dwTextId    -- String resource id of the text string
//            szParam     -- String param for text string.
//            dwCaptionId -- String resource id of the caption string
//            dwFlags     -- Flags for the messagebox
// Return:    Button pressed
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
DWORD MessageBoxResourceParam(HWND hwnd, DWORD dwTextId, char *szParam, DWORD dwCaptionId, DWORD dwFlags)
{
    char szText[2048], szText2[2048], szCaption[256];
    LoadString(g_hinst, dwTextId,    szText,    2048);
    LoadString(g_hinst, dwCaptionId, szCaption, 256);
    sprintf(szText2, szText, szParam);
    return MessageBox(hwnd, szText2, szCaption, dwFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\Util.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      util.h
// Contents:  
// Revisions: 7-Jul-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

class CObjList;

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  DebugOutput
// Purpose:   Outputs a variable-argument string to the debugger.  Used like
//            printf.
// Arguments: sz            -- Format to use (ie the first parm to printf() )
//            ...           -- [optional] Variable number of arguments.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void DebugOutput(char *sz, ...);

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  DumpLayer
// Purpose:   Temp debug function
// Arguments: pol           -- List to dump
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void DumpLayer(CObjList *pol);

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  FormatByteString
// Purpose:   
// Arguments: 
// Return:   None 
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void FormatByteString(DWORD dwVal, char *szDest);

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  FatalError
// Purpose:   Called when an unrecoverable error has occurred.  Forces exit
//            after notification
// Arguments: dwErr         -- The error that occurred
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void FatalError(DWORD dwErr);

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  MessageBoxResource
// Purpose:   Display a messagebox using string resources
// Arguments: hwnd        -- Handle to the window 'owning' the messagebox
//            dwTextId    -- String resource id of the text string
//            dwCaptionId -- String resource id of the caption string
//            dwFlags     -- Flags for the messagebox
// Return:    Button pressed
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
DWORD MessageBoxResource(HWND hwnd, DWORD dwTextId, DWORD dwCaptionId,
                        DWORD dwFlags);

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  MessageBoxResourceParam
// Purpose:   Display a messagebox using string resources.  Expects one string
//            param for the text string.
// Arguments: hwnd        -- Handle to the window 'owning' the messagebox
//            dwTextId    -- String resource id of the text string
//            szParam     -- String param for text string.
//            dwCaptionId -- String resource id of the caption string
//            dwFlags     -- Flags for the messagebox
// Return:    Button pressed
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
DWORD MessageBoxResourceParam(HWND hwnd, DWORD dwTextId, char *szParam,
                             DWORD dwCaptionId, DWORD dwFlags);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xblayout\xbLayout.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      xbLayout.cpp
// Contents:  
// Revisions: 13-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  WinMain
// Purpose:   This is the default entry point into a Windows application.  When
//            the application is started, Windows calls into this function -
//            when this function exits, the application ends.  This function
//            creates the Win32 class that represents this application, sets up
//            the Win32 Window in which the shell will be rendered, and then
//            goes into the Win32 message loop that drives the application.
// Arguments: hinst         -- The handle to this instance of the application
//            hinstPrev     -- Obsolete; throwback to Win16 -- ignore
//            szCmdLine     -- Contains the parameter list passed to this app
//            nCmdShow      -- Default visibility of the application
// Return:    Value app returns to the OS specifying result of execution.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
int APIENTRY WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR szCmdLine,
                     int nCmdShow)
{
    InitProfile();

    // Ensure that the common control DLL is loaded. 
    InitCommonControls(); 

    // Create our Window
    CWindow_Main *pwindow = new CWindow_Main(FLAG_WINDOW_POS_LASTKNOWN, hinst);
    if (!pwindow)
        FatalError(E_OUTOFMEMORY);
    if (!pwindow->Init())
    {
        // Failed to initialize the window for some reason.  The user has
        // already been informed of the problem, so just return the error code
        return -1;
    }
    
    // Run the window.  Control remains within this function until the user
    // exits the app
    int nExitVal = pwindow->Run();

    DumpProfile();
    
    // At this point, the app has finished shutting down.
    delete pwindow;

    return nExitVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xbpremaster\CFile.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CFile.cpp
// Contents:  Specialized file class for xbPremaster.
// Revisions: 2-Jun-2001: Created (jeffsim)
// Notes:     * This is a very specialized file class for the xbPremaster app.  It is not
//              recommended that this class be used for other applications.
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"

extern CCheckSum g_xsum;
extern bool g_fInPlaceholder, g_fInXbe, g_fInMedia;

class CMyFileStm : public CFileStmRand
{
    friend class CFile;
public:
    virtual BOOL FIsOpen(void)
    {
        return m_pfile && m_pfile->IsInited();
    }
    virtual DWORD CbRead(DWORD cb, PBYTE pbBuf)
    {
        int cbRead;
        if(!m_pfile)
            return 0;
        if(FAILED(m_pfile->Read(pbBuf, cb, &cbRead)))
            return 0;
        return cbRead;
    }
    virtual DWORD CbWrite(DWORD cb, const BYTE *pbBuf)
    {
        if(!m_pfile)
            return 0;
        return SUCCEEDED(m_pfile->Write((PBYTE)pbBuf, cb)) ? cb : 0;
    }
    
    virtual BOOL FSeek(LARGE_INTEGER li)
    {
        return SUCCEEDED(m_pfile->SeekTo(li));
    }
    virtual BOOL FSeek(LONG l)
    {
        LARGE_INTEGER li;
        li.QuadPart = l;
        return SUCCEEDED(m_pfile->SeekTo(li));
    }

    virtual BOOL FCopyToStm(CFileStmSeq *pstm, CCheckSum *) { return FALSE; }
    virtual ~CMyFileStm()
    {
        if(m_pfile)
            m_pfile->m_pstm = NULL;
    }

private:
    CMyFileStm(CFile *pfile) : m_pfile(pfile) {}
    CFile *m_pfile;
};


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ DEFINES  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// BATCH_SIZE       -- Number of bytes to copy at a time when copying a file.  Included for better
//                     performance.

#define BATCH_SIZE 32768


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CFile::CFile
// Purpose:   Constructor for the CFile class.  Opens the specified file in preparation for READING
//            This will only be called on disk sources.
// Arguments: pdlg              -- The dialog that will handle informing the user of errors.
//            pstep             -- The step that created this file.
//            szFilename        -- name of the file to open
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CFile::CFile(CDlg *pdlg, CStep_Progress *pstep, char *szFilename) : m_pstm(NULL)
{
    // Validate parameters
    if (pdlg == NULL || szFilename == NULL)
    {
        SetInited(E_INVALIDARG);
        return;
    }

    // Track the dialog and step that this file was created in
    m_pdlg  = pdlg;
    m_pstep = pstep;

    // Track which media this file exists on.
    m_media = MEDIA_DISK;

    // Track the name of our file.
    strcpy(m_szFilename, szFilename);
    
    // Track the last action performed
    m_taskLast = TASK_OPEN;

    // Open the file for READ-ONLY access.  The file must exist or we fail.
    m_hFile = CreateFile(szFilename, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
    if (m_hFile == INVALID_HANDLE_VALUE)
    {
        // NOTE: Non-OLE compatible error code.  Acceptable here ONLY because I catch it elsewhere
        // (see note at top of this file).  Difficult to use OLE for errors here since it doesn't
        // have a lot of errors we need to catch (ie file not found).
        SetInited(GetLastError());
        return;
    }

    SetInited(S_OK);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CFile::CFile
// Purpose:   Opens the specified file for read or write access.  This can be called on disk or
//            tape sources.
// Arguments: pdlg              -- The dialog that will handle informing the user of errors.
//            pstep             -- The step that created this file.
//            media             -- Type of media the file exists on (tape, disk)
//            szPath            -- Path the file exists in.  Ignored if media = tape
//            szFilename        -- name of the file to open (without path).
//            fInput            -- 'true' if open for read, 'false' if open for write
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CFile::CFile(CDlg *pdlg, CStep_Progress *pstep, eMedia media, char *szPath, char *szFilename,
             bool fInput) : m_pstm(NULL)
{
    // Validate parameters
    if (pdlg == NULL || szFilename == NULL)
    {
        SetInited(E_INVALIDARG);
        return;
    }

    // Track the dialog and step that this file was created in
    m_pdlg  = pdlg;
    m_pstep = pstep;

    // Track which media this file exists on.
    m_media = media;
    
    // Track the last action performed
    m_taskLast = TASK_OPEN;

    // Open the file
    if (media == MEDIA_DISK)
    {
        sprintf(m_szFilename, "%s\\%s", szPath, szFilename);
        if (fInput)
            m_hFile = CreateFile(m_szFilename, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                                 FILE_ATTRIBUTE_NORMAL, 0);
        else
            m_hFile = CreateFile(m_szFilename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL, 0);
        if (m_hFile == INVALID_HANDLE_VALUE)
        {
            // NOTE: Non-OLE compatible error code.  Acceptable here ONLY because I catch it elsewhere
            // (see note at top of this file).  Difficult to use OLE for errors here since it doesn't
            // have a lot of errors we need to catch (ie file not found).
            SetInited(GetLastError());
            return;
        }
    }
    else
    {
        DWORD dw1,dw2;
        BOOL fOpened;

        strcpy(m_szFilename, szFilename);
        SetCursor(LoadCursor(NULL, IDC_WAIT));
        if (fInput)
            fOpened = pstep->m_td.FReadFile(szFilename, &dw1,&dw2);
        else
            fOpened = pstep->m_td.FWriteFile(szFilename);
        SetCursor(LoadCursor(NULL, IDC_ARROW));
        if (!fOpened)
        {
            // Generic error since CTapeDevice doesn't provide more detailed error information.
            SetInited(ERROR_ACCESS_DENIED);
            return;
        }
    }

    SetInited(S_OK);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CFile::~CFile
// Purpose:   CFile destructor.  Close the handle to our file and cleanup after ourselves.
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CFile::~CFile()
{
    Close();
    if(m_pstm)
        delete m_pstm;
}

DWORD g_cbyTotalWritten = 0;

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CFile::Write
// Purpose:   Write the specified buffer of bytes out to our file
// Arguments: pby           -- Buffer containing bytes to write
//            cBytes        -- Number of bytes to write
// Return:    Error code, or S_OK if written successfully
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CFile::Write(BYTE *pby, UINT cBytes)
{
    DWORD dwWritten;

    if (!IsInited())
        return E_FAIL;

    // Track the last action performed
    m_taskLast = TASK_WRITE;

    if (m_media == MEDIA_DISK)
    {
        if (!::WriteFile(m_hFile, pby, cBytes, &dwWritten, 0) || dwWritten != cBytes)
        {
            // Failed to write the whole buffer.
            return(GetLastError());
        }
    }
    else
    {
        dwWritten = m_pstep->m_td.CbWrite(cBytes, pby);
        if (dwWritten == 0)
        {
            // An error occurred; we can't tell what the error is since CTapeDevice doesn't have
            // more robust error reporting.
            return E_FAIL;
        }
    }

    // Update the Submission checksum.  The Black XCheck checksum is calculated elsewhere
    if (!g_fInPlaceholder && !g_fInXbe && g_fInMedia)
        g_xsum.SumBytes(pby, cBytes);
    g_cbyTotalWritten += cBytes;

    return S_OK;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CFile::SeekTo
// Purpose:   Seeks to the specified position in the file (from the beginning of the file)
//            This is only called on disk sources.
// Arguments: liDist        -- Number of bytes to seek forward
// Return:    Error code, or S_OK if successful.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CFile::SeekTo(LARGE_INTEGER liDist)
{
    if (!IsInited())
        return E_FAIL;
    
    // Track the last action performed
    m_taskLast = TASK_SEEK;

    assert (m_media == MEDIA_DISK);

    if (SetFilePointer(m_hFile, liDist.LowPart, &liDist.HighPart, FILE_BEGIN) == 0xFFFFFFFF)
    {
        // Since 0xffffffff could be a valid low value, we need to check getlasterror as well
        DWORD dw = GetLastError();
        if (dw != NO_ERROR)
            return dw;

        // Otherwise, it was a valid value
    }

    return S_OK;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CFile::Read
// Purpose:   Reads the specified number of bytes from our file.
// Arguments: pby           -- Buffer containing bytes to read
//            cBytes        -- Number of bytes to read
//            pnRead        -- Will contain the actual number of bytes read.  Can be 'NULL'.
// Return:    Error code, or S_OK if successful
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CFile::Read(BYTE *pby, UINT cBytes, int *pnRead)
{
    DWORD dwRead;

    if (!IsInited())
        return GetInitCode();

    // Track the last action performed
    m_taskLast = TASK_READ;

    if (m_media == MEDIA_DISK)
    {
        if (!ReadFile(m_hFile, pby, cBytes, &dwRead, 0))
        {
            // Failed to read the whole buffer.
            if (pnRead)
                *pnRead = dwRead;
            return (GetLastError());
        }
    }
    else
    {
        dwRead = m_pstep->m_td.CbRead(cBytes, pby);
        if (dwRead == 0)
        {
            // An error occurred; we can't tell what the error is since CTapeDevice doesn't have
            // more robust error reporting.
            return E_FAIL;
        }
    }
    if (pnRead)
        *pnRead = dwRead;

    return S_OK;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CFile::GetSize
// Purpose:   Gets the size of our file
//            Only called on disk sources
// Arguments: puliSize       -- Variable to contain the size of our file
// Return:    Error code, or S_OK if successful
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CFile::GetSize(ULARGE_INTEGER *puliSize)
{
    assert (m_media == MEDIA_DISK);

    // Track the last action performed
    m_taskLast = TASK_GETSIZE;

    // Get the size of the file
    puliSize->LowPart = GetFileSize(m_hFile, &puliSize->HighPart);
    if (puliSize->LowPart != INVALID_FILE_SIZE)
        return S_OK;
    else
        return GetLastError();
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CFile::InformError
// Purpose:   
// Arguments: 
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CFile::InformError(HWND hwnd, HRESULT hrError, char *szFilename)
{
    char szCaption[MAX_PATH + 200];
    char szText[100];
    
    // UNDONE: Mixing OLE and non-ole error codes here.  It's okay because none of them conflict,
    // but this should be resolved if this class is ever extended to work with other apps.
    switch(hrError)
    {
    case ERROR_FILE_NOT_FOUND:
    case ERROR_PATH_NOT_FOUND:
        // Failed to find the specified file
        sprintf(szText, "Failed to find the file '%s'", szFilename);
        sprintf(szCaption, "File not found");
        break;

    case ERROR_DISK_CORRUPT:
    case ERROR_ACCESS_DENIED:
    case ERROR_FILE_INVALID:
        sprintf(szText, "Cannot access the file '%s'.  Please verify that the file is not currently"\
                        " opened by another appliation", szFilename);
        sprintf(szCaption, "Cannot access file");
        break;
        
    case ERROR_DISK_FULL:
        sprintf(szText, "The drive '%c:' is full; xbPremaster cannot continue writing data.",
                szFilename[0]);
        sprintf(szCaption, "Not enough space on drive");
        break;

    default:
        // What was the last action performed?
        switch(m_taskLast)
        {
        case TASK_WRITE:
            sprintf(szText, "An error occurred while writing the file '%s'.  Please verify the " \
                            "output media is valid.", szFilename);
            sprintf(szCaption, "Error writing file");
            break;

        case TASK_READ:
            sprintf(szText, "An error occurred while reading the file '%s'.  Please verify the " \
                            "input media is valid.", szFilename);
            sprintf(szCaption, "Error reading file");
            break;

        case TASK_OPEN:
            sprintf(szText, "An error occurred while opening the file '%s'.", szFilename);
            sprintf(szCaption, "Error opening file");
            break;

        case TASK_CLOSE:
            sprintf(szText, "An error occurred while closing the file '%s'.", szFilename);
            sprintf(szCaption, "Error closing file");
            break;

        case TASK_SEEK:
            sprintf(szText, "An error occurred while seeking in the file '%s'.", szFilename);
            sprintf(szCaption, "Error seeking in file");
            break;

        default:
            sprintf(szText, "An error occurred accessing the file '%s'.  Please verify it is a " \
                            "valid filename", szFilename);
            sprintf(szCaption, "Error accessing file");
            break;
        }
        break;
        
    }

    // Display the error message to the user
    MessageBox(hwnd, szText, szCaption, MB_ICONEXCLAMATION | MB_OK | MB_APPLMODAL);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CFile::Close
// Purpose:   Closes our file
// Arguments: None
// Return:    Error code, or S_OK if successful
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CFile::Close()
{
    // Track the last action performed
    m_taskLast = TASK_CLOSE;

    // Close the handle to our file (if it was successfully opened in the first place).
    if (m_media == MEDIA_DISK)
    {
        if (m_hFile)
        {
            CloseHandle(m_hFile);
            m_hFile = NULL;
        }
    }
    else
    {
        if (m_pstep->m_td.FIsOpen())
            if (!m_pstep->m_td.FCloseFile())
                return E_FAIL;
    }

    return S_OK;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CFile::CopyFileBytes
// Purpose:   Copy the requested number of bytes from the current location of the source file
// Arguments: pfileSrc          -- File to copy from
//            nBytesLeft        -- Number of bytes to copy
//            pnWritten         -- Will contain the number of bytes written
//            phr               -- result of the copy (S_OK if cancel)
// Return:    'true' to continue; 'false' if error or user cancelled
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CFile::CopyFileBytes(CFile *pfileSrc, int nBytesLeft, int *pnWritten, HRESULT *phr)
{
    // Batch into blocks of BATCH_SIZE for perf
    BYTE rgbyBuffer[BATCH_SIZE];
    int  nRead, nToRead;
    
    // Start out with no bytes written.
    *pnWritten = 0;
    
    do
    {
        // Read in the next batch from the source file
        nToRead = min(nBytesLeft, BATCH_SIZE);
        *phr = pfileSrc->Read(rgbyBuffer, nToRead, &nRead);
        if (*phr != S_OK)
            return false;

        if(nRead != nToRead)
            memset(rgbyBuffer + nRead, 0, nToRead - nRead);
        
        // Check if the user clicked 'cancel'
        if (m_pstep->CheckCancelled())
            return false;

        // Write out the latest batch to this file
        *phr = Write(rgbyBuffer, nToRead);
        if (*phr != S_OK)
            return false;
            
        // Keep track of the total number of bytes read and written.
        nBytesLeft -= nToRead;
        *pnWritten += nToRead;
    }
    while (nBytesLeft);

    // If here, then the bytes were successfully copied.
    return true;
}

HRESULT CFile::CreateFileStm(CFileStmRand **ppstm)
{
    if(!m_pstm)
        m_pstm = new CMyFileStm(this);
    *ppstm = m_pstm;
    return m_pstm ? S_OK : E_FAIL;
}

HRESULT CFile::ReadBYTE(BYTE *pbyData, int *pnRead)
{
    return Read(pbyData, 1, pnRead);
}

HRESULT CFile::ReadWORD(WORD *pwData, int *pnRead)
{
    return Read((BYTE*)pwData, 2, pnRead);
}

HRESULT CFile::ReadDWORD(DWORD *pdwData, int *pnRead)
{
    return Read((BYTE*)pdwData, 4, pnRead);
}

HRESULT CFile::ReadString(char *sz, int *pnRead)
{
    DWORD dwStrlen;
    int   nRead;
    HRESULT hr = ReadDWORD(&dwStrlen, &nRead);
    if (FAILED(hr))
        return hr;
    
    hr = Read((BYTE*)sz, dwStrlen, &nRead);
    if (FAILED(hr))
        return hr;
    if (nRead != (int)dwStrlen)
        return E_FAIL;
    
    sz[dwStrlen] = '\0';
    if (pnRead)
        *pnRead = nRead + 4;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xbpremaster\CFile.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CFile.h
// Contents:  Handles File input/output.
// Revisions: 31-May-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ CLASSES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Forward Class declarations
class CStep_Progress;

typedef enum eTask {TASK_OPEN, TASK_WRITE, TASK_READ, TASK_SEEK, TASK_GETSIZE, TASK_CLOSE};


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class:   CFile
// Purpose: Handles File input/output.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class CFile : public CInitedObject
{
public:

    // ++++ CONSTRUCTION-RELATED FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    // CFile            -- This constructor is only called for read files
    CFile(CDlg *pdlg, CStep_Progress *pstep, char *szFilename);
    
    // CFile            -- This constructor could be called for read or write files
    CFile(CDlg *pdlg, CStep_Progress *pstep, eMedia media, char *szPath, char *szFilename, bool fInput);

    // ~CFile           -- CFile destructor
    virtual ~CFile();

    // ++++ INPUT/OUTPUT-RELATED FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    
    // Read             -- Reads a set of bytes from the file
    HRESULT Read(BYTE *pby, UINT cBytes, int *pnRead = NULL);

    HRESULT ReadBYTE(BYTE *pbyData, int *pnRead = NULL);
    HRESULT ReadWORD(WORD *pwData, int *pnRead = NULL);
    HRESULT ReadDWORD(DWORD *pdwData, int *pnRead = NULL);
    HRESULT ReadString(char *sz, int *pnRead = NULL);

    // Write            -- Writes a set of bytes to the file
    HRESULT Write(BYTE *pby, UINT cBytes);

    // CopyFileBytes    -- Copies a set of bytes from another file to this file.
    bool CopyFileBytes(CFile *pfileSrc, int nBytesLeft, int *pnWritten, HRESULT *phr);


    // ++++ MEMBER-ACCESS FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    // GetSize          -- Returns the size of the file
    HRESULT GetSize(ULARGE_INTEGER *puliSize);

    // GetFilename      -- Returns the name of the file
    char *GetFilename() {return m_szFilename; }


    // ++++ MISCELLANEOUS FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    // InformError      -- Informs the user that an error has occurred
    void InformError(HWND hwnd, HRESULT hrError, char *szFilename);

    // Close            -- Closes the file
    HRESULT Close();

    // SeekTo           -- Sets the file's current file pointer to the specified location.
    HRESULT SeekTo(LARGE_INTEGER liDist);
    
    HRESULT CreateFileStm(CFileStmRand **ppstm);

    
private:

    // m_hFile          -- Handle to the Win32 file object that we encapsulate
    HANDLE m_hFile;

    // m_pstep          -- The step that this file was created in.
    CStep_Progress *m_pstep;

    // m_pdlg           -- The dialog that this file was created in.
    CDlg *m_pdlg;
    
    // m_media          -- The media the file exists on.
    eMedia m_media;

    // m_taskLast      -- The last task performed on this file
    eTask m_taskLast;

    class CMyFileStm *m_pstm;
    
protected:

    // m_szFilename     -- name of this file.
    char m_szFilename[MAX_PATH];

    friend class CMyFileStm;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xbpremaster\CFLD.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CFLD.h
// Contents:  FLD file wrapper.
// Revisions: 7-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ CLASSES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class:   CFLD
// Purpose: Encapsulates an FLD file.  Provides accessors to the various entries in the FLD file.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class CFLD : public CFile
{
public:

    // ++++ CONSTRUCTION-RELATED FUNCTIONS ++++++++++++++++++++++++++++++++++++

    // CFLD         -- CFLD Constructor
    CFLD(CDlg *pdlg, CStep_Progress *pstep, char *szFilename);


    // ++++ MEMBER-ACCESS FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++

    bool IsWrongVersion() { return m_fWrongVersion; }

    bool ReadNextObjectInfo(DWORD *pdwType, DWORD *pdwLSN, DWORD *pdwBlockSize, char *szName);

    char m_szDVDRoot[MAX_PATH];

private:
    
    bool m_fWrongVersion;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xbpremaster\CFST.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CFST.cpp
// Contents:  FST file wrapper.  The FST file format is defined by the AMC tools.
// Revisions: 7-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"

// Taken from AMC's file "MediaBase.h"
struct TFileHeader
{
    char m_szFileType[32]; // FST? Error Map?
    char m_szMediaType[32]; // DVD, CD, etc
};

struct TMediaHeader
{
    DWORD uNumSectorsLayer0;
    DWORD uNumSectorsLayer1;
    BYTE m_ImpUseArea[120];       // total = 128 bytes
};

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CFST::CFST
// Purpose:   Opens the specified FST file and reads the header information from it.
// Arguments: pdlg          -- Dialog to handle error messages
//            pstep         -- Step that this FST was created in.
//            szFilename    -- Name of the fst file to open.
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CFST::CFST(CDlg *pdlg, CStep_Progress *pstep, char *szFilename) : CFile(pdlg, pstep, szFilename)
{
    WORD  wByteOrder;
    DWORD dwTimestamp;
    int   cSectors;
    
    // Check to see if the file was successfully opened
    if (!IsInited())
        return;

    // Read the various necessary values out of the FST file's header block

    // The Byte order of the FST file can be big or little endian.  We only support one method
    // here.  If the FST file format changes, then we need to handle that here.
    if (Read((BYTE*)&wByteOrder, 2) != S_OK)
        return;

    assert (wByteOrder != 0xCDAB);

    if (wByteOrder != 0xABCD)
    {
        // This is a new format FST file (AMC changed their format)

        // Read in the AMC Header information
        TFileHeader tfh;
        TMediaHeader tmh;

        if (Read(((BYTE*)&tfh) + 2, sizeof(tfh) - 2) != S_OK)
            return;
        
        if (Read((BYTE*)&tmh, sizeof(tmh)) != S_OK)
            return;

        // Read the byte order
        if (Read((BYTE*)&wByteOrder, 2) != S_OK)
            return;

        assert (wByteOrder == 0xABCD);
    }

    // The timestamp is ignored here
    if (Read((BYTE*)&dwTimestamp, 4) != S_OK)
        return;

    // The number of sectors is also ignored (we know it to be a fixed size)
    if (Read((BYTE*)&cSectors, 4) != S_OK)
        return;

    if (cSectors != 1715632*2)
    {
        // This is a new format FST file (AMC changed their format to remove
        // the sector count).  In that case, we just read the number of entries
        m_cEntries = cSectors;

        // Force the number of sectors to a known value.  This will eventually
        // change when different sectors counts are possible
        cSectors = 1715632*2;
    }
    else
    {
        // Old format FST file
        // Read the number of files referenced in this FST file.
        if (Read((BYTE*)&m_cEntries, 4) != S_OK)
            return;
    }

    // Read the full size of the string table.  The string table contains all of the filenames.
    if (Read((BYTE*)&m_cbyStringTableSize, 4) != S_OK)
        return;
    
    // Allocate space for our string and entry tables
    m_ptes = new sTableEntry[m_cEntries];
    if (m_ptes == NULL)
        ReportError(ERROR_OUTOFMEM);
    m_pchStringTable = new char[m_cbyStringTableSize];
    if (m_pchStringTable == NULL)
        ReportError(ERROR_OUTOFMEM);

    // Read in the entire entry and string tables
    if (Read((BYTE*)m_ptes, m_cEntries * sizeof(sTableEntry)) != S_OK)
        return;
    if (Read((BYTE*)m_pchStringTable, m_cbyStringTableSize) != S_OK)
        return;

    // Determine the first entry on layer 1
    for (int i = 0; i < m_cEntries; i++)
    {
        if (m_ptes[i].m_dwStart >= NUM_XDATA_SECTORS)
        {
            m_iFirstLayer1Entry = i;
            break;
        }
    }
    if (i == m_cEntries)
    {
        // No entries on layer 1!
        m_iFirstLayer1Entry = m_cEntries;
    }

    SetInited(S_OK);
    return;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CFST::~CFST
// Purpose:   CFST destructor.  Clean up after ourselves.
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CFST::~CFST()
{
    // Delete our string and entry tables
    if (m_pchStringTable)
        delete[] m_pchStringTable;

    if (m_ptes)
        delete[] m_ptes; 
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CFST::GetEntry
// Purpose:   
// Arguments: nLayer        -- Layer of the entry (0 or 1)
//            iEntry        -- Index of the entry to read (0 == first)
//            szName        -- Will be filled with the full path\filename of the entry
//            pnStartPSN    -- Will be filled with the start PSN of the entry
//            pnEndPSN      -- Will be filled with the end PSN of the entry
//            pdwOffset     -- Will be filled with the offset into the source file.
// Return:    'true' if successfully obtained.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CFST::GetEntry(int nLayer, int iEntry, char szName[MAX_PATH],
                    int *pnStartPSN, int *pnEndPSN, DWORD *pdwOffset,
                    BOOL fPackage, char szPackageDVDRoot[MAX_PATH])
{
    // If this is layer 1 and there are no entries in layer 1, return the requested entry doesn't
    // exist
    if (nLayer == 1 && m_iFirstLayer1Entry == (DWORD)m_cEntries)
        return false;

    // Offset entries in layer 1 to point at the first entry in the table
    if (nLayer == 1)
        iEntry += m_iFirstLayer1Entry;

    // If requested entry > than # of entries in the FST file, then return that the entry doesn't
    // exist
    if ((nLayer == 0 && iEntry >= (int)m_iFirstLayer1Entry) ||
        (nLayer == 1 && iEntry >= m_cEntries))
        return false;

    // Get a pointer to the requested entry in our entry table
    sTableEntry *pst = &m_ptes[iEntry];

    // Fill in the caller-requested information
    if (fPackage)
    {
        // Need to replace the root in the FST file with the temporary root
        // that we extracted all of the files to.
        char *szRelDir = &m_pchStringTable[pst->m_iDir] +
                         strlen(szPackageDVDRoot) - 1;

        // We know this FST exists in <temproot>\_amc\main.fst, so use that.
        strcpy(szName, m_szFilename);

        // Replace "\_amc\main.fst" with the relative directory & filename
        sprintf(szName + strlen(szName) - 13, "%s%s%s",szRelDir,
                (*szRelDir == '\0') ? "" :  "\\",
                &m_pchStringTable[pst->m_iName]);
    }
    else
    {
        sprintf(szName, "%c:%s/%s", m_szFilename[0], &m_pchStringTable[pst->m_iDir],
                &m_pchStringTable[pst->m_iName]);
    }
    *pnStartPSN = pst->m_dwStart;
    *pnEndPSN   = pst->m_dwStop;
    *pdwOffset  = pst->m_dwOffset;

    // Offset the layer one PSNs to be base-zero.
    if (nLayer == 1)
    {
        *pnStartPSN -= NUM_XDATA_SECTORS;
        *pnEndPSN -= NUM_XDATA_SECTORS;
    }

    // Return that the returned values are valid.
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xbpremaster\CDlg.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CDlg.h
// Contents:  Encapsulates the UI for the steps that appear in this application
// Revisions: 31-May-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ DEFINES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// MAX_VISIBLE_CONTROLS     -- Maximum number of controls visible on the dialog at one time.
#define MAX_VISIBLE_CONTROLS 100

#define MAX_OVERLOADED_HWNDS 10


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ CLASSES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Forward Class declarations
class CStep;

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class:   CDlg
// Purpose: Encapsulates the UI for the steps that appear in this application.  
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class CDlg : public CInitedObject
{
public:

    // ++++ CONSTRUCTION-RELATED FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    // CDlg             -- CDlg constructor
    CDlg(HINSTANCE hinstApp);
    
    // ~CDlg            -- CDlg destructor
    ~CDlg();


    // ++++ CONTROL-RELATED FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    // DisplayControl   -- Displays the control with the specified resource id
    HRESULT DisplayControl(int nControl);

    // HideAllControls  -- Hides and disables all currently visible controls on the dialog box.
    HRESULT HideAllControls();

    // SetControlEnable -- Enables or disables the specified control
    HRESULT SetControlEnable(int nControl, bool fEnabled);

    // SetControlState  -- Sets the checked/unchecked-pressed/unpressed state of a control
    HRESULT SetControlState(int nControl, bool fChecked);

    // SetControlText   -- Sets the text that appears in/on the specified control
    HRESULT SetControlText(int nControl, char *szText);

    // GetControlText   -- Gets the text that appears in/on the specified control
    HRESULT GetControlText(int nControl, char *szText, int cbyBufLen);

    // SetCurControl    -- Sets the current keyboard focus to the specified control
    HRESULT SetCurControl(int nControl);

    // SetProgressPos   -- Sets the position of the specified progress bar
    HRESULT SetProgressPos(int nControl, int nPos);

    // SetProgressRange -- Sets the range of the specified progress bar
    HRESULT SetProgressRange(int nControl, int nStart, int nEnd);

    // SetControlFont   -- Sets the font of the control
    HRESULT SetControlFont(int nControl, int nHeight, char *szFace, int nWeight);

    HRESULT OverloadBkColor(int nControl);

    HRESULT AddToComboBox(int nControl, char *szString);

    HRESULT ClearComboBox(int nControl);

    HRESULT GetComboSel(int nControl, char *szBuffer);
    

    // ++++ EXECUTION FLOW-RELATED FUNCTION +++++++++++++++++++++++++++++++++++++++++++++++++++++++

    // Run              -- Runs the specified step.
    CStep *Run(CStep *pstepCur);

    // DlgProc          -- The main message-handling procedure for the dialog
    BOOL DlgProc(UINT uMsg, WPARAM wparam, LPARAM lparam);

    // SetNextStep      -- Sets the next step be performed by the dialog.  Also marks that the
    //                     current step has ended.
    void SetNextStep(CStep *pstepNext);

    
    // ++++ MISCELLANEOUS FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    // GetPathNameCommon -- Opens up the Win32 common directory dialog and obtains a directory name
    bool GetPathNameCommon(char *szTitle, char *szPath);

    // GetFileNameCommon -- Opens up the Win32 common file dialog and obtains a filename.
    bool GetFileNameCommon(char *szTitle, char *szExt, char *szFilter, char *szFile, bool fOpen);

    // GetHwnd          -- Returns the handle of this dialog.
    HWND GetHwnd() {return m_hdlg; }

    // SetCaption       -- Sets the text that appears at the top of the dialog
    void SetCaption(char *szCaption);

    // GetInst          -- Returns the Win32 instance of this application
    HINSTANCE GetInst() {return m_hinst; }

    // m_pstepCur       -- The Step currently being executed
    CStep *m_pstepCur;

private:

    // OverloadedBkColor    -- Determines if the specified control was overridden to display a
    //                         white background instead of the default grey
    bool OverloadedBkColor(HWND hwndControl);

    // m_hdlg           -- Handle to the Win32 dialog that this object encapsulates
    HWND m_hdlg;

    // m_rgnVisibleControl  -- The list of currently visible controls
    int m_rgnVisibleControl[MAX_VISIBLE_CONTROLS];

    // m_cVisibleControls   -- The number of currently visible controls
    int m_cVisibleControls;

    HWND m_rghwndOverload[MAX_OVERLOADED_HWNDS];
    
    int m_cOverloadBkColor;

    // m_fStepEnded     -- Tracks if the current step has already ended.
    bool m_fStepEnded;

    // m_pstepNext      -- The next Step to execute.
    CStep *m_pstepNext;

    // m_hinst          -- Win32 instance of this application.
    HINSTANCE m_hinst;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xbpremaster\CDlg.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CDlg.cpp
// Contents:  Main dialog class.  This object contains the UI handling for the Steps in this app.
// Revisions: 31-May-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"
#include <commdlg.h>


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ LOCAL VARIABLES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// gs_pdlgTemp      -- Temporary pointer used to circumvent CreateDialog annoyances (see below).
static CDlg *gs_pdlgTemp = NULL;


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  DlgProc
// Purpose:   This is the static callback for the CDlg dialog.  It receives all messages from the
//            OS (ie user input, callbacks, etc).  We simply take the message, determine which
//            dialog box it actually belongs to, and pass it on to the appropriate CDlg object.
// Arguments: hwndDlg           -- The handle to the dialog that the message is intended for.
//            uMsg              -- The message being reported.
//            wparam            -- Parameter 1 (message-specific)
//            lparam            -- Parameter 2 (message-specific)
// Return:    TRUE if the message was handled; FALSE otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL CALLBACK DlgProc(HWND hwndDlg, UINT uMsg, WPARAM wparam, LPARAM lparam) 
{
    CDlg *pdlg;

    // When a CDlg calls CreateDialog to create the Win32 dialog, the OS sends a number of messages
    // to DlgProc before the CreateDialog returns (WM_INITDIALOG, WM_WINDOWPOSCHANGING, etc).
    // Because we haven't returned from the CreateDialog call, we can't set which CDlg hwndDlg is
    // actually referring to.  Therefore, we need to use a temporary global variable to point at
    // the correct CDlg.  If that variable is non-NULL, then we know that we haven't returned from
    // the CreateDialog call, and that we should use it instead.  If the variable is NULL, then the
    // CDlg has had the opportunity to cram a pointer to itself into the window.
    if (gs_pdlgTemp != NULL)
    {
        pdlg = gs_pdlgTemp;
    }
    else
    {
        // Determine which CDlg this message should be sent to.  We stored a pointer to the dialog
        // in the hwnd's 'user' area.  Extract it now.
        pdlg = (CDlg*)GetWindowLong(hwndDlg, DWL_USER);
        if (!pdlg)
            return false;
    }    

    // Pass the message on to the appropriate CDlg and let it handle it.
    return pdlg->DlgProc(uMsg, wparam, lparam);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDlg::OverloadedBkColor
// Purpose:   Determines if the specified control was overridden to display a white background.
// Arguments: hwndControl       -- The control to examine
// Return:    'true' if the control's background was overloaded
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CDlg::OverloadedBkColor(HWND hwndControl)
{
    // Check if we overrode the specified control's background color
    for (int i = 0; i < m_cOverloadBkColor; i++)
        if (m_rghwndOverload[i] == hwndControl)
            return true;
    return false;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDlg::OverloadBkColor
// Purpose:   Overloads a control to display it's background color as white instead of the default
//            light grey.
// Arguments: nControl          -- Resource id of the control to overload
// Return:    S_OK if successful, OLE-compatible error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CDlg::OverloadBkColor(int nControl)
{
    // Get a handle to the control with the specified resource id.
    HWND hwndControl = GetDlgItem(m_hdlg, nControl);
    if (hwndControl == NULL)
        return E_INVALIDARG;

    m_rghwndOverload[m_cOverloadBkColor] = hwndControl;
    m_cOverloadBkColor++;

    return S_OK;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDlg::DlgProc
// Purpose:   This is the instance-specific dialog message handler.  There are some message that
//            we handle here (in the base class), while others are ignored (and handled by the OS).
// Arguments: uMsg              -- The message being reported.
//            wparam            -- Parameter 1 (message-specific)
//            lparam            -- Parameter 2 (message-specific)
// Return:    TRUE if the message was handled; FALSE otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL CDlg::DlgProc(UINT uMsg, WPARAM wparam, LPARAM lparam) 
{
    switch(uMsg)
    {
    case WM_INITDIALOG:
        // Return that we were successfully initialized
        return TRUE;
        
    case WM_COMMAND:
        // We only need to support button presses here -- pass the button press on to the current
        // step and let it handle it.
        m_pstepCur->HandleButtonPress(LOWORD(wparam));
        return TRUE;

    case WM_CTLCOLORSTATIC:
        // If we asked that the specified control hwnd (passed-in in lparam) be filled w/
        // background white, then do so now
        if (OverloadedBkColor((HWND)lparam))
        {
            SetBkColor((HDC)wparam, RGB(255,255,255));
            return (BOOL)GetStockObject(WHITE_BRUSH);
        }
        return FALSE;
    }
    
    // If the message wasn't handled above, then return FALSE to tell the OS to handle it.
    return FALSE;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDlg::CDlg
// Purpose:   CDlg constructor.  Creates the modeless Win32 dialog box that contains the
//            application's UI.  We use a dialog box (instead of a plain window) to enable
//            easy resources (buttons, text, progress bars, etc).
// Arguments: hinstApp          -- The instance of the application
// Notes:     * This function is not reentrant due to the use of the global gs_pdlgTemp variable.
//              Doesn't affect this app, but future users of the CDlg object should be aware of it.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CDlg::CDlg(HINSTANCE hinstApp)
{
    // Set the global CDlg pointer to point at us so that ::DlgProc can determine which CDlg the
    // current message belongs to.  This use of a global variable is necessary due to the messages
    // that the OS sends to ::DlgProc before we can stuff a pointer to ourselves into the window
    // (see above)
    gs_pdlgTemp = this;

    // Create the modeless (ie non-blocking) Win32 dialog that will contain our UI.  We pass a
    // pointer to the static DlgProc (::DlgProc) because we can't point windows at our instance-
    // specific DlgProc. ::DlgProc will take care of determining which CDlg->DlgProc to forward to.
    m_hdlg = CreateDialog(hinstApp, MAKEINTRESOURCE(IDD_MAIN), NULL, ::DlgProc);
    if (m_hdlg == NULL)
    {
        SetInited(E_FAIL);
        return;
    }

    // Set the dialog's icon.
    HICON hicon = LoadIcon(hinstApp, "IDC_MAIN");
    SetClassLong(m_hdlg, GCL_HICON, (LONG)hicon);

    // Tell the newly created Win32 dialog box that it "belongs" to us.  This is necessary so that 
    // the static DlgProc that Windows calls (::DlgProc above) can determine that it came from us,
    // and call the DlgProc of this instance of CDlg
    SetWindowLong(m_hdlg, DWL_USER, (long)this);

    // Now that our pointer has been stuffed into the window, we can stop using the global var.
    gs_pdlgTemp = NULL;

    // Make the window visible.
    ShowWindow(m_hdlg, SW_SHOW);

    // Track the instance of the application
    m_hinst = hinstApp;

    // No visible controls at the start
    m_cVisibleControls = 0;

    // Start out without any overloaded colors
    m_cOverloadBkColor = 0;

    // Mark that we were successfully initialized
    SetInited(S_OK);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDlg::~CDlg
// Purpose:   CDlg destructor.  Destroys the Win32 dialog box (if it was successfully created).
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CDlg::~CDlg()
{
    if (m_hdlg)
        DestroyWindow(m_hdlg);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDlg::Run
// Purpose:   Runs the current step.  Enters into the Win32 message loop and doesn't exit until the
//            user has specified that he wants to move on to a different step.
// Arguments: pstepCur      -- The step to run.
// Return:    Pointer to the next step to perform
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CStep *CDlg::Run(CStep *pstepCur)
{
    MSG msg;

    // Track our current step
    m_pstepCur = pstepCur;

    // Track that we don't know the next step yet.
    m_pstepNext = NULL;

    // We haven't finished the current step yet
    m_fStepEnded = false;

    // Give the step itself a chance to handle the processing; if it doesn't, then we'll do it
    // ourselves.  This allows both modal and modeless steps.
    if (!pstepCur->DoModal())
    {
        // The step is a modeless step; handle the message loop here.

        // Enter into the Win32 message loop.  We'll stay there until the Step signals that it has
        // finished processing (by setting the m_fStepEnded var).
        while (GetMessage(&msg, NULL, 0,0) && !m_fStepEnded)
        {
            if (!IsDialogMessage(m_hdlg, &msg))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }

    // Return to the caller a pointer to the next step to perform
    return m_pstepNext;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDlg::SetCaption
// Purpose:   Sets the caption of the dialog box
// Arguments: szCaption     -- Caption of the dialog box.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CDlg::SetCaption(char *szCaption)
{
    SetWindowText(m_hdlg, szCaption);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDlg::SetNextStep
// Purpose:   Sets the next step to be performed.  Setting this forces the current step to be
//            stopped at the next available time (in CDlg::Run or CStep::DoModal).
// Arguments: pstepNext             -- The next step to perform.  'NULL' to exit the app.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CDlg::SetNextStep(CStep *pstepNext)
{
    // Track which step should be performed next
    m_pstepNext = pstepNext;

    // Track that the current step has ended
    m_fStepEnded = true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDlg::SetControlEnable
// Purpose:   Enables or disables the specified control.
// Arguments: nControl          -- Resource Id of the control to set
//            fEnabled          -- whether or not the control is to be enabled or disabled.
// Return:    S_OK if successful, OLE-compatible error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CDlg::SetControlEnable(int nControl, bool fEnabled)
{
    // Get a handle to the control with the specified resource id.
    HWND hwndControl = GetDlgItem(m_hdlg, nControl);
    if (hwndControl == NULL)
        return E_INVALIDARG;
    
    // Enable/Disable the specified control
    EnableWindow(hwndControl, fEnabled);

    // Return that everything went fine.
    return S_OK;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDlg::SetControlState
// Purpose:   Sets the specified controls state.  Should only be applied to buttons, checkboxes, etc.
// Arguments: nControl          -- Resource Id of the control to set
//            fChecked          -- whether or not the control is to be set or cleared.
// Return:    S_OK if successful, OLE-compatible error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CDlg::SetControlState(int nControl, bool fChecked)
{
    // Set the specified control's state.
    bool fSuccess = CheckDlgButton(m_hdlg, nControl, fChecked) ? true : false;

    return fSuccess ? S_OK : E_FAIL;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDlg::SetControlText
// Purpose:   Sets the control's text to the specified string.
// Arguments: nControl          -- Resource Id of the control to set
//            szText            -- Buffer to hold the contents of the control's text
// Return:    S_OK if successful, OLE-compatible error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CDlg::SetControlText(int nControl, char *szText)
{
    // Get a handle to the control with the specified resource id.
    HWND hwndControl = GetDlgItem(m_hdlg, nControl);
    if (hwndControl == NULL)
        return E_INVALIDARG;
    
    // Store the specified text in the control
    bool fSuccess = SetWindowText(hwndControl, szText) ? true : false;;

    return fSuccess ? S_OK : E_FAIL;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDlg::GetControlText
// Purpose:   Gets the specified control's text
// Arguments: nControl          -- Resource Id of the control to read
//            szText            -- Buffer to hold the contents of the control's text
//            cbyBufLen         -- Maximum length of the buffer.  Only up to this many bytes will
//                                 be written.
// Return:    S_OK if successful, OLE-compatible error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CDlg::GetControlText(int nControl, char *szText, int cbyBufLen)
{
    // Get a handle to the control with the specified resource id.
    HWND hwndControl = GetDlgItem(m_hdlg, nControl);
    if (hwndControl == NULL)
        return E_INVALIDARG;
    
    // Store the specified text in the control
    GetWindowText(hwndControl, szText, cbyBufLen);

    // Return that everything went fine.
    return S_OK;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDlg::DisplayControl
// Purpose:   Makes the specified control visible to the user.
// Arguments: nControl          -- The control to make visible
// Return:    S_OK if successful, OLE-compatible error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CDlg::DisplayControl(int nControl)
{
    // Add the control to the list of visible controls.  This will allow us to hide the control
    // when switching steps.
    m_rgnVisibleControl[m_cVisibleControls++] = nControl;

    // Get a handle to the control with the specified resource id.
    HWND hwndControl = GetDlgItem(m_hdlg, nControl);
    if (hwndControl == NULL)
        return E_INVALIDARG;

    // Make the control visible
    ShowWindow(hwndControl, SW_SHOW);

    return S_OK;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDlg::HideAllControls
// Purpose:   Makes all of the controls in the dialog invisible.  This is used as an initialization
//            step for CStep objects to insure that only their controls are visible.
// Arguments: None
// Return:    S_OK if successful, OLE-compatible error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CDlg::HideAllControls()
{
    // Make all of the currently visible controls hidden
    for (int i = 0; i < m_cVisibleControls; i++)
        ShowWindow(GetDlgItem(m_hdlg, m_rgnVisibleControl[i]), SW_HIDE);

    m_cVisibleControls = 0;
    m_cOverloadBkColor = 0;

    return S_OK;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDlg::SetCurControl
// Purpose:   Gives keyboard focus to the control with the specified resource id.
// Arguments: nControl          -- The control to make visible
// Return:    S_OK if successful, OLE-compatible error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CDlg::SetCurControl(int nControl)
{
    // Get a handle to the control with the specified resource id.
    HWND hwndControl = GetDlgItem(m_hdlg, nControl);
    if (hwndControl == NULL)
        return E_INVALIDARG;
    
    // Set the current input focus to the specified control
    SetFocus(hwndControl);

    // Return that everything went fine.
    return S_OK;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDlg::SetProgressPos
// Purpose:   Sets the position of the specified progress bar
// Arguments: nControl          -- The progress bar to modify
// Return:    S_OK if successful, OLE-compatible error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CDlg::SetProgressPos(int nControl, int nPos)
{
    // Get a handle to the control with the specified resource id.
    HWND hwndControl = GetDlgItem(m_hdlg, nControl);
    if (hwndControl == NULL)
        return E_INVALIDARG;
    
    // Set the progress pos
    SendMessage(hwndControl, PBM_SETPOS, nPos, 0);

    // Return that everything went fine.
    return S_OK;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDlg::SetProgressRange
// Purpose:   Sets the range of the specified progress bar
// Arguments: nControl          -- The progress bar to modify
// Return:    S_OK if successful, OLE-compatible error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CDlg::SetProgressRange(int nControl, int nStart, int nEnd)
{
    // Get a handle to the control with the specified resource id.
    HWND hwndControl = GetDlgItem(m_hdlg, nControl);
    if (hwndControl == NULL)
        return E_INVALIDARG;
    
    // Set the progress range
    SendMessage(hwndControl, PBM_SETRANGE32, nStart, nEnd);
    SendMessage(hwndControl, PBM_SETRANGE32, nStart, nEnd);

    // Return that everything went fine.
    return S_OK;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDlg::AddToComboBox
// Purpose:   Add the specified string to the specified control.  Control must be a combo box.
// Arguments: nControl          -- The combo box to add a string to
//            szString          -- The string to add
// Return:    S_OK if successful, OLE-compatible error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CDlg::AddToComboBox(int nControl, char *szString)
{
    // Get a handle to the control with the specified resource id.
    HWND hwndControl = GetDlgItem(m_hdlg, nControl);
    if (hwndControl == NULL)
        return E_INVALIDARG;

    SendMessage(hwndControl, CB_ADDSTRING, 0, (LPARAM)szString);
    SendMessage(hwndControl, CB_SETCURSEL, 0, 0);

    // size the combobox's dropdown
    RECT rc;
    GetWindowRect(hwndControl, &rc);
    POINT pt = {rc.left, rc.top};
    ScreenToClient(m_hdlg, &pt);
    MoveWindow(hwndControl, pt.x, pt.y, (rc.right - rc.left), 100, TRUE);
    return S_OK;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDlg::ClearComboBox
// Purpose:   Clears the contents of the specified combo box
// Arguments: nControl          -- The combo box to clear
// Return:    S_OK if successful, OLE-compatible error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CDlg::ClearComboBox(int nControl)
{
    // Get a handle to the control with the specified resource id.
    HWND hwndControl = GetDlgItem(m_hdlg, nControl);
    if (hwndControl == NULL)
        return E_INVALIDARG;

    SendMessage(hwndControl, CB_RESETCONTENT, 0, 0);

    return S_OK;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDlg::GetComboSel
// Purpose:   Get the text of the currently selected item in the combo box
// Arguments: nControl          -- The combo box to get the currently selection of.
//            szBuffer          -- Buffer to hold the text contents of the combo box's current
//                                 selection
// Return:    S_OK if successful, OLE-compatible error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CDlg::GetComboSel(int nControl, char *szBuffer)
{
    // Get a handle to the control with the specified resource id.
    HWND hwndControl = GetDlgItem(m_hdlg, nControl);
    if (hwndControl == NULL)
        return E_INVALIDARG;

    // Get the currently selected item in the combo box
    int iCurSel = SendMessage(hwndControl, CB_GETCURSEL, 0, 0);

    // Get the text of the currently selected item in the combo box
    SendMessage(hwndControl, CB_GETLBTEXT, iCurSel, (LPARAM)szBuffer);

    return S_OK;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDlg::GetPathNameCommon
// Purpose:   Opens the common directory-selection dialog and allows the user to select a path.
// Arguments: szTitle           -- Title to display at the top of the dialog
//            szPath            -- The buffer to hold the new path (if one is selected).
// Return:    'true' if user selected a path; 'false' if they cancelled out
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CDlg::GetPathNameCommon(char *szTitle, char *szPath)
{
    char       szDisplayName[MAX_PATH];
    BROWSEINFO bi;
    bool       fRet = false;
    IMalloc    *pmalloc;
        
    // Validate parameters
    if (szPath == NULL)
        return false;
    
    // Get a pointer to the shell's allocator.  We'll need it to free up the pidl that's created.
    SHGetMalloc(&pmalloc);

    // Fill in the browse info structure.
    bi.pszDisplayName = szDisplayName;          // Buffer to hold display name
    bi.hwndOwner      = m_hdlg;                 // Owner window for the dialog
    bi.pidlRoot       = NULL;                   // Specify NULL for 'desktop'
    bi.lpszTitle      = szTitle;                // String to display at the top of the dialog
    bi.ulFlags        = BIF_RETURNONLYFSDIRS;   // Don't display control panel, etc
    bi.lpfn           = NULL;                   // No need for the callback
    bi.lParam         = 0;                      // unused.

    // Open up the dialog and have the user select the path.  The function is modal.
    LPITEMIDLIST pidl = SHBrowseForFolder(&bi);
    if (pidl == NULL)
    {
        // User cancelled out, so don't set anything.
        goto done;
    }
    
    // If here, then the user selected a path.  Extract it from the pidl and store it in the
    // buffer the caller specified.
    if (::SHGetPathFromIDList(pidl, szPath) == false)
    {
        // Malformed pidl, or other failure.  In any case, don't set the path
        goto done;
    }

    // At this point, szPath contains the path the user chose.
    if (szPath[0] == '\0')
    {
        // SHGetPathFromIDList failed, or SHBrowseForFolder failed.
        goto done;
    }

    // if here, then we succeeded!
    fRet = true;

done:
    if (pidl)
        pmalloc->Free(pidl);
    pmalloc->Release();      

    return fRet;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDlg::GetFileNameCommon
// Purpose:   Opens the common file-selection dialog and allows the user to select a file.
// Arguments: szTitle           -- Title to display at the top of the dialog
//            szExt             -- The default extension
//            szFilter          -- The filter string to display in the dialog
//            szFile            -- The buffer to hold the new filename (if one is selected).
//            fOpen             -- 'true' if the file is being opened, 'false' if its being saved
// Return:    'true' if user selected a file; 'false' if they cancelled out
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CDlg::GetFileNameCommon(char *szTitle, char *szExt, char *szFilter, char *szFile, bool fOpen)
{
    OPENFILENAME ofn;

    // Validate parameters
    if (szTitle == NULL || szFile == NULL)
        return false;

    // Initialize the default filename to empty
    strcpy(szFile, "");

    // Initialize the openfilename structure so that the GetOpenFileName function knows what
    // kind of files we want to allow.
    memset(&ofn, 0, sizeof(ofn));
    ofn.lStructSize         = sizeof(ofn);
    ofn.hwndOwner           = m_hdlg;
    ofn.hInstance           = m_hinst;
    ofn.lpstrCustomFilter   = NULL;
    ofn.nMaxCustFilter      = 0;
    ofn.nFilterIndex        = 1;
    ofn.lpstrFile           = szFile;
    ofn.nMaxFile            = MAX_PATH - 1;
    ofn.lpstrFileTitle      = ofn.lpstrFile;
    ofn.nMaxFileTitle       = ofn.nMaxFile;
    ofn.lpstrInitialDir     = "C:\\";
    ofn.nFileOffset         = 0;
    ofn.nFileExtension      = 0;
    ofn.lpstrDefExt         = szExt;
    ofn.lpstrFilter         = szFilter;
    ofn.lCustData           = 0;
    ofn.lpstrTitle          = szTitle;
    if (fOpen)
    {
        ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;

        // Pop up the common file open dialog
        if (!GetOpenFileName(&ofn))
        {
            // User clicked cancel or closed the dialog (or an error occurred).
            return false;
        }
    }
    else
    {
        ofn.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT;

        if (!GetSaveFileName(&ofn))
        {
            // User clicked cancel or closed the dialog (or an error occurred).
            return false;
        }
    }

    // If here, then the file was stored.
    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CDlg::SetControlFont
// Purpose:   Sets the font of the control
// Arguments: nControl              -- The control whose font we'll set
//            nHeight               -- Height of the font
//            szFace                -- Face of the font ("Arial", "Courier", etc)
//            nWeight               -- Normal (0) or Bold (FW_BOLD)
// Return:    S_OK if successful, OLE-compatible error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CDlg::SetControlFont(int nControl, int nHeight, char *szFace, int nWeight)
{
    LOGFONT lf;

    // Get a handle to the control with the specified resource id.
    HWND hwndControl = GetDlgItem(m_hdlg, nControl);
    if (hwndControl == NULL)
        return E_INVALIDARG;

    // Create the GDI font object
    memset(&lf, 0, sizeof(lf));
    lf.lfHeight = nHeight;
    lf.lfWeight = nWeight;
    strcpy(lf.lfFaceName, szFace);
    HFONT hfont = CreateFontIndirect(&lf);
    
    // Set the control's current font to the newly created font
    SendMessage(hwndControl, WM_SETFONT, (WPARAM)hfont, TRUE);
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xbpremaster\CFLD.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CFLD.cpp
// Contents:  FLD file wrapper.
// Revisions: 7-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"

#include "..\\xbLayout\\FLDVersion.h"

typedef struct
{
    WORD wMajor;
    WORD wMinor;
    WORD wBuild;
    WORD wQFE;
} sVersion;

#define FLD_SIG "XBOXFLDFILE"
#define FLD_SIG_SIZE sizeof(FLD_SIG)

typedef struct
{
    BYTE  szSig[FLD_SIG_SIZE];
    time_t timeSaved;
    sVersion version;
} sFLDHeader;

// Taken from AMC's file "MediaBase.h"
struct TFileHeader
{
    char m_szFileType[32]; // FST? Error Map?
    char m_szMediaType[32]; // DVD, CD, etc
};

struct TMediaHeader
{
    DWORD uNumSectorsLayer0;
    DWORD uNumSectorsLayer1;
    BYTE m_ImpUseArea[120];       // total = 128 bytes
};

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CFLD::CFLD
// Purpose:   Opens the specified FLD file and reads the header information from it.
// Arguments: pdlg          -- Dialog to handle error messages
//            pstep         -- Step that this FLD was created in.
//            szFilename    -- Name of the FLD file to open.
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CFLD::CFLD(CDlg *pdlg, CStep_Progress *pstep, char *szFilename) : CFile(pdlg, pstep, szFilename)
{
    sFLDHeader fldhdr;
    
    // Check to see if the file was successfully opened
    if (!IsInited())
        return;

    m_fWrongVersion = false;

    // Read the header (to skip it)
    Read((BYTE*)&fldhdr, sizeof fldhdr, NULL);

    // Save the dvd root since we need it for electronic submission
    ReadString(m_szDVDRoot);

    SetInited(S_OK);
}

#define OBJ_FOLDER    0x0010
#define OBJ_ENDOFLIST 0x0080

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  
// Purpose:   
// Arguments: 
// Return:    'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CFLD::ReadNextObjectInfo(DWORD *pdwType, DWORD *pdwLSN, DWORD *pdwBlockSize, char *szName)
{
	DWORD dwDummy;
	char  szDummy[MAX_PATH];

    // Get next object type
	if (FAILED(ReadDWORD(pdwType)))
		return false;
    if (*pdwType == OBJ_ENDOFLIST)
        return true;

	// Read the object-specified data from the file; ignore some of it.
	if (FAILED(ReadDWORD(pdwLSN)))       return false;
	if (FAILED(ReadDWORD(pdwBlockSize))) return false;
    if (FAILED(ReadDWORD(&dwDummy)))     return false;
    if (FAILED(ReadDWORD(&dwDummy)))     return false;
	if (FAILED(ReadString(szName)))      return false;
	if (FAILED(ReadString(szDummy)))     return false;
    if (FAILED(ReadDWORD(&dwDummy)))     return false;
    if (FAILED(ReadDWORD(&dwDummy)))     return false;

    // Skip past folder id if the object read was a folder
    if (*pdwType == OBJ_FOLDER && FAILED(ReadDWORD(&dwDummy)))
        return false;

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xbpremaster\CFST.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CFST.h
// Contents:  FST file wrapper.  The FST file format is defined by the AMC tools.
// Revisions: 7-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ CLASSES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class:   CFST
// Purpose: Encapsulates an FST file.  Provides accessors to the various entries in the FST file.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class CFST : public CFile
{
public:

    // ++++ CONSTRUCTION-RELATED FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    // CFST         -- CFST Constructor
    CFST(CDlg *pdlg, CStep_Progress *pstep, char *szFilename);

    // ~CFST        -- CFST Destructor
    ~CFST();


    // ++++ MEMBER-ACCESS FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    // GetEntry     -- Gets the information about a particular entry in the FST file
    bool GetEntry(int nLayer, int iEntry, char szName[MAX_PATH],
                  int *pnStartPSN, int *pnEndPSN, DWORD *pdwOffset,
                  BOOL fPackage = false, char szPackageDVDRoot[MAX_PATH] = NULL);


private:

    // m_cEntries   -- The number of entries in the FST file
    int m_cEntries;

    // m_pchStringTable     -- The string table containing the entries' names
    char *m_pchStringTable;

    // m_cbyStringTableSize -- The size of the string table containing the entries' names
    int m_cbyStringTableSize;

    // sTableEntry  -- Contains information about a particular entry in the FST file
    struct sTableEntry
    {
        // m_dwStart    -- LSN that the entry starts on
        DWORD m_dwStart;
        
        // m_dwStop     -- LSN that the entry stops on
        DWORD m_dwStop;

        // m_iDir       -- String table index for the name of the directory for the entry 
        DWORD m_iDir;

        // m_iName      -- String table index for the name of the file for the entry
        DWORD m_iName;

        // m_dwOffset   -- Offset into the entry at which to begin reading data
        DWORD m_dwOffset;
    };

    // m_ptes       -- The list of entrys
    sTableEntry *m_ptes;

    // m_iFirstLayer1Entry  -- Tracks which entry is the first one found on layer 1.
    DWORD m_iFirstLayer1Entry;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xbpremaster\CInitedObject.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     CInitedObject.h
// Contents: Contains the declaration of the CInitedObject object class.
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ CLASSES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class:   CInitedObject
// Purpose: Tracks initialization state of an object.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class CInitedObject
{
public:

    // ++++ CONSTRUCTION-RELATED FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    // CInitedObject        -- Standard constructor
    CInitedObject()
    {
        m_hrInit = E_FAIL;
    }


    // ++++ ACCESSOR FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    // GetInitCode          -- Returns the result of initialization
    HRESULT GetInitCode()
    {
        try
        {
            if (this == NULL)
                return E_FAIL;
            return m_hrInit;
        }
        catch(...)
        {
            // Something unexpected happened - most likely we were passed an invalid 'this' pointer
            return E_FAIL;
        }
    }

    // IsInited             -- Returns 'true' if the object was successfully initialized
    bool IsInited()
    {
        return GetInitCode() == S_OK;
    }


protected:

    // ++++ ACCESSOR FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    // SetInited            -- Allows a derived class to clear or set the initialized state to track
    //                         the derived class' initialization success.
    void SetInited(HRESULT hrInit)
    {
        m_hrInit = hrInit;
    }

private:

    // m_hrInit             -- Tracks the result of object initialization.
    HRESULT m_hrInit;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xbpremaster\CreateDx2mlFile.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CreateDx2mlFile.cpp
// Contents:  Creates the Dx2ml*.xml files.
// Revisions: 6-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ LOCAL VARIABLES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Start of valid data on layer 0 and 1.  Taken from Appendix B of the DVD-X2 Tape format spec V1.0
DWORD g_rgdwLayerMainBandStart[] = { 0x060600,  // Layer 0
                                     0xDFCC50}; // Layer 1


bool g_fOutOfMemory = false;


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStep_Progress::AddMedia
// Purpose:   Adds the 'media' element to an XML tree.
// Arguments: pxnInput          -- The '<Input>' element node to add the media subtree to.
// Return:    S_OK if successful, OLE-compatible error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CStep_Progress::AddMedia(DXML *pdxml)
{
    // We don't need to check for Out of Memory errors since all allocations simply set a global
    // flag and throw an exception that is caught and reported above.  Saves us from a lot of
    // NULL checks...

    // TODO: distinguish tape from disk files

    // Add the XControl.dat file
    pdxml->dxiXControl.szNameOnTape = _strdup("XCONTROL.DAT");
    pdxml->dxiXControl.szRefName = _strdup("XLeadout");
    pdxml->dxiXControl.fUsedLyr0 = TRUE;

    // Add the layer 0 Xbox input stream
    pdxml->rgdxi[2].szNameOnTape = _strdup("XIMAGE0.DAT");
    pdxml->rgdxi[2].szRefName = _strdup("XboxLayer0Data");
    pdxml->rgdxi[2].dwImageSize = NUM_XDATA_SECTORS;
    pdxml->rgdxi[2].fUsedLyr0 = TRUE;

    // Add the layer 1 Xbox input stream
    pdxml->rgdxi[3].szNameOnTape = _strdup("XIMAGE1.DAT");
    pdxml->rgdxi[3].szRefName = _strdup("XboxLayer1Data");
    pdxml->rgdxi[3].dwImageSize = NUM_XDATA_SECTORS;
    pdxml->rgdxi[3].fUsedLyr0 = TRUE;

    return S_OK;
} 

#define OBJ_SEC  0x0001
#define OBJ_FILE 0x0008
#define OBJ_ENDOFLIST 0x0080

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStep_Progress::AddLayer
// Purpose:   Adds a <layer> subtree to the specified XML tree.
// Arguments: 
// Return:    S_OK if successful, OLE-compatible error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CStep_Progress::AddLayer(CFLD *pfld, DXML *pdxml, int nLayer)
{
    DXL *pdxl;
    ULONG lsnCur = 0;

    // We don't need to check for Out of Memory errors since all allocations simply set a global
    // flag and throw an exception that is caught and reported above.  Saves us from a lot of
    // NULL checks...

    pdxl = &pdxml->rgdxl[nLayer];
    pdxl->dxrXData.idxiImage = 2 + nLayer;

    // Define where the main band starts on the disc (PSN).  This number is constant across all DVDs
    pdxl->psnStart = pdxl->dxrXData.psnStart = g_rgdwLayerMainBandStart[nLayer];
    pdxl->dxrXData.cpsnSize = NUM_XDATA_SECTORS;

#if 1 // new xbLayout FLD file format support
	DWORD dwType, dwLSN, dwBlockSize;
	char  szName[MAX_PATH];
    int   cxbi;
    XBI   *pxbiBase;

	while (1) {
        // Read information about the next object in the fld file
        pfld->ReadNextObjectInfo(&dwType, &dwLSN, &dwBlockSize, szName);
        if (dwType == OBJ_ENDOFLIST)
            break;

        // Does the object belong on the current layer we're working on?
        if (nLayer == (int)(dwLSN / 1715632)) {
		    if (dwType == OBJ_SEC) {
                /* If this placeholder starts on an odd block, we need to
                 * advance by one, and if it's not the right size, we're in
                 * big trouble */
                if(dwLSN & 1) {
                    if(dwBlockSize < 4098)
                        return E_FAIL;
                    ++dwLSN;
                }
                cxbi        = pdxl->cxph++;
                pxbiBase    = (XBI *)pdxl->rgxph;
                dwBlockSize = XPH::phNone;
            } else if (dwType == OBJ_FILE) {
                // Is the file an xbe file?  If not, ignore it
                if (!lstrcmpi(szName + strlen(szName) - 4, ".xbe")) {
                    cxbi = pdxl->ixbiMac++;
                    if(cxbi >= pdxl->ixbiMax) {
                        XBI *pxbiPrev = pdxl->pxbi;

                        pdxl->pxbi = new XBI[pdxl->ixbiMax += 32];
                        if(pxbiPrev) {
                            memcpy(pdxl->pxbi, pxbiPrev, cxbi * sizeof(XBI));
                            delete pxbiPrev;
                        }
                    }
                    pxbiBase = pdxl->pxbi;
                }
                else
                    continue;
            }
            else
                continue;

            // The stored LSN needs to be relative to the start of the layer
            if (nLayer == 1)
                dwLSN -= 1715632;

            int ixbi = cxbi;
            if(ixbi > 0 && dwLSN < pxbiBase[ixbi-1].lsnStart) {
                /* Somehow we're seeing these blocks out of order.
                 * We need to insert this one in the right spot */
                for(ixbi = 0; ixbi < cxbi; ++ixbi) {
                    if(dwLSN < pxbiBase[ixbi].lsnStart)
                        break;
                }
                memmove(&pxbiBase[ixbi+1], &pxbiBase[ixbi],
                    (cxbi - ixbi) * sizeof(XBI));
            }

            pxbiBase[ixbi].lsnStart = dwLSN;
            pxbiBase[ixbi].cpsnSize = dwBlockSize;
        }
    }

#else // old AMC-based approach - retained for comparison purposes.
    // Now add the data to the X-Data region.  Each data block in the FLD describes a placeholder,
    // XBE file, or block of data.  Iterate over each of the blocks adding the ones that belong
    // to this layer.
    int nElement = pfld->GetNumDataBlock();

    // Iterate over each data block in the FLD file, adding all of the ones that belong to the
    // current layer.
    for (int i = 0; i < nElement; i++)
    {
        DWORD dwBlocks;
        UINT  nBlockLayer;
        IFld::tNodeIdx nodeId = pfld->GetDataBlockIndex(i);
        ULONG lsn;

        // Determine which layer the current data block belongs on.  If it's not the current layer,
        // then skip it.
        pfld->GetLayer(nodeId, nBlockLayer);
        if (nBlockLayer == nLayer)
        {
            int ixbi;
            int cxbi;
            XBI *pxbiBase;

            pfld->GetStartLsn(nodeId, lsn);
            /* Only certain files contain their actual LSN; we need to guess
             * the rest */
            if(lsn == 0)
                lsn = lsnCur;
            else
                lsnCur = lsn;
            pfld->GetBlockSize(nodeId, dwBlocks);
            lsnCur += dwBlocks;

            /* Keep LSNs relative to this layer's data */
            if(nLayer)
                lsn -= NUM_XDATA_SECTORS;

            /* If this is a placeholder, we add it to the placeholder table.
             * If this is an XBE, we'll add it to the image table */
            if(pfld->IsPlaceHolder(nodeId)) {
                if(pdxl->cxph >= MAX_PLACEHOLDER_PER_LAYER)
                    /* Somehow we have too many placeholders on this layer.
                     * We'll just treat this like normal data */
                    continue;
                cxbi = pdxl->cxph++;
                pxbiBase = (XBI *)pdxl->rgxph;
                dwBlocks = XPH::phNone;
            } else if(pfld->IsXbe(nodeId)) {
                
                cxbi = pdxl->ixbiMac++;
                if(cxbi >= pdxl->ixbiMax) {
                    XBI *pxbiPrev = pdxl->pxbi;

                    pdxl->pxbi = new XBI[pdxl->ixbiMax += 32];
                    if(pxbiPrev) {
                        memcpy(pdxl->pxbi, pxbiPrev, cxbi * sizeof(XBI));
                        delete pxbiPrev;
                    }
                }
                pxbiBase = pdxl->pxbi;
            } else
                /* Data file, no need to track it */
                continue;

            ixbi = cxbi;
            if(ixbi > 0 && lsn < pxbiBase[ixbi-1].lsnStart) {
                /* Somehow we're seeing these blocks out of order.
                 * We need to insert this one in the right spot */
                for(ixbi = 0; ixbi < cxbi; ++ixbi) {
                    if(lsn < pxbiBase[ixbi].lsnStart)
                        break;
                }
                memmove(&pxbiBase[ixbi+1], &pxbiBase[ixbi],
                    (cxbi - ixbi) * sizeof(XBI));
            }

            pxbiBase[ixbi].lsnStart = lsn;
            pxbiBase[ixbi].cpsnSize = dwBlocks;
        }
    }
#endif
    return S_OK;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStep_Progress::CreateDx2mlFile
// Purpose:   Creates either dx2ml0.xml or dx2ml1.xml depending on the specified layer.
// Arguments: 
// Return:    S_OK if successful, OLE-compatible error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CStep_Progress::CreateDx2mlFile(CFLD *pfldfile, CDX2MLFile *pxml)
{
    HRESULT hr;
    CFileStmRand *pstm;

    // We don't need to check for Out of Memory errors since all allocations simply set a global
    // flag and throw an exception that is caught and reported above.  Saves us from a lot of
    // NULL checks...

    // Create the output file.  The path and filename are separated in case the destination
    // is tape media.
    CFile outfile(m_pdlg, this, m_media, m_szDestPath, "DX2ML.XML", false);
    if (!outfile.IsInited())
    {
        // Failed to create the file.  Inform the user
        outfile.InformError(m_pdlg->GetHwnd(), outfile.GetInitCode(), outfile.GetFilename());
        return E_FAIL;
    }

    try
    {
        pxml->PdxmlGet()->fLayoutTape = TRUE;
        // Add the media tag(s) -- this tells the mastering tool where the files (dx2ml.xml, etc) exist
        hr = AddMedia(pxml->PdxmlGet());
        if (hr != S_OK)
            return hr;

        // Add the two layers to the side
        if(FAILED(AddLayer(pfldfile, pxml->PdxmlGet(), 0)) ||
            FAILED(AddLayer(pfldfile, pxml->PdxmlGet(), 1)) ||
            !pxml->FValidatePlaceholderLocations(FALSE, FALSE, FALSE))
        {
            MessageBox(NULL, "Invalid placeholders encountered.  Please reopen your FLD file in "
                             "xbLayout to resolve this issue.",
                             "Invalid Placeholder information",
                             MB_ICONEXCLAMATION | MB_APPLMODAL | MB_OK);
            return E_FAIL;
        }

        // Output the xml tree to the outfile.
        hr = outfile.CreateFileStm(&pstm);
        if(hr == S_OK && !pxml->FWriteFile(pstm))
            hr = GetLastError();
        if (hr != S_OK)
        {
            // Failed to output the XML file.  Inform the user
            outfile.InformError(m_pdlg->GetHwnd(), hr, outfile.GetFilename());
            return E_FAIL;
        }

        // We're done writing the file.
        outfile.Close();
    }
    catch(...)
    {
        if (g_fOutOfMemory)
            ReportError(ERROR_OUTOFMEM);
        else
            ReportError(ERROR_UNEXPECTED);
    }

    // Return that the file was successfully generated
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xbpremaster\CreateXControlFile.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CreateXControlFile.cpp
// Contents:  Creates the XControl.dat file
// Revisions: 6-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  GetGUID
// Purpose:   Gets the TapeMastering GUID out of the registry and stores it in the specified buffer
// Arguments: pby           -- Buffer to contain the contents of the GUID.
// Return:    'true' if key successfully obtained
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
static bool GetGUID(BYTE *pby)
{
    // Length of GUID + NULL terminator == 39
    DWORD cbGUIDLen = 39;
    BYTE  rgbyGUID[255];
	HKEY  Key;
	DWORD dwType;
    GUID guid;

    // Get the mastering guid out of the registry
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\XboxSDK\\", 0, KEY_QUERY_VALUE | KEY_SET_VALUE,
                     &Key) != ERROR_SUCCESS)
        return false;

    if (RegQueryValueEx(Key,"TapeMastering", 0,&dwType, rgbyGUID,
        &cbGUIDLen) != ERROR_SUCCESS || dwType != REG_SZ ||
        RPC_S_OK != UuidFromString(rgbyGUID, &guid))
    {
        // Failed to read the tapemastering key out of the registry.  Create the GUID and put it
        // there ourselves.

        // Create the GUID
        if (CoCreateGuid(&guid) != S_OK)
        {
            RegCloseKey(Key);
            return false;
        }

        // Convert the GUID to string format
        BYTE *rgbyTemp;
        UuidToString(&guid, &rgbyTemp);

        // Write the string GUID to the registry
        if (RegSetValueEx(Key, "TapeMastering", 0, REG_SZ, rgbyTemp, strlen((char*)rgbyTemp)) != ERROR_SUCCESS)
        {
            RegCloseKey(Key);
            return false;
        }

        // We no longer need the allocated string so free it
        RpcStringFree(&rgbyTemp);

        // Reread the value from the registry.  If it fails this time, then we're screwed.
        if (RegQueryValueEx(Key,"TapeMastering", 0,&dwType, rgbyGUID, &cbGUIDLen) != ERROR_SUCCESS)
        {
            RegCloseKey(Key);
            return false;
        }
    }

    // We no longer need the registry key.
    RegCloseKey(Key);

    // copy the guid into the user buffer
    memcpy(pby, &guid, sizeof guid);

    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CreateXcontrolFile
// Purpose:   Creates the xcontrol.dat file from the information in the specified fld file.
// Arguments: None
// Return:    S_OK if successful, OLE-compatible error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CStep_Progress::CreateXcontrolFile()
{
    FILETIME fileTime;
    BYTE     rgbyXControl[32*2048];

    // XControl.dat format:
    //  30x2048 bytes of zero
    //  Xbox Control Data Frame
    //    CONTENT                           SIZE    DEFAULT VALUE
    //    Disc category and version #       1       0xD1
    //    Disc size and max transfer rate   1       0x0F
    //    Disc structure                    1       0x31
    //    Recording density                 1       0x10
    //    Reserved                          1       0x00
    //    First Xbox Physical Sector #      3       
    //    Reserved                          1       0x00
    //    Last Xbox Physical Sector #       3
    //    Reserved                          1       0x00
    //    Last Layer 0 Xbox Physical Sector 3       
    //    BCA descriptor                    1
    //    Reserved                          1038    0x00
    //    Content Source Time Stamp         8
    //    Reserved                          20      0x00
    //    Content Source Identifier         16
    //    Reserved                          949     0x00
    //  2048 bytes of zero

    // Because so much of the Data file is zero, we preinit the whole buffer to zero and fill in
    // the rest manually.
    memset(rgbyXControl, 0, sizeof(rgbyXControl));

    // Fill in the default values as described above
    rgbyXControl[30*2048 + 0] = 0xD1;
    rgbyXControl[30*2048 + 1] = 0x0F;
    rgbyXControl[30*2048 + 2] = 0x31;
    rgbyXControl[30*2048 + 3] = 0x10;

    // Add the first xbox physical sector # (on layer 0)
    rgbyXControl[30*2048 + 5] = 0x06;
    rgbyXControl[30*2048 + 6] = 0x06;
    rgbyXControl[30*2048 + 7] = 0x00;

    // Add the last xbox physical sector # (on layer 1)
    rgbyXControl[30*2048 +  9] = 0xF9;
    rgbyXControl[30*2048 + 10] = 0xF9;
    rgbyXControl[30*2048 + 11] = 0xFF;

    // Add the last Xbox physical sector # on Layer 0
    rgbyXControl[30*2048 + 13] = 0x20;
    rgbyXControl[30*2048 + 14] = 0x33;
    rgbyXControl[30*2048 + 15] = 0xAF;

    // Add the BCA descriptor.
    rgbyXControl[30*2048 + 16] = 0x00;

    // Get the current time
	CoFileTimeNow(&fileTime);
    
    // Add the file time
    memcpy(&rgbyXControl[30*2048 + 1055], &fileTime, sizeof fileTime);

	// Add the Content source identifier (GUID that represents the specific content provider that
    // create the IP contained on this disc). The GUID is provided by Microsoft and setup during
    // installation.  The key is stored in "Software\\Microsoft\\XboxSDK\\TapeMastering".
    if (GetGUID(&rgbyXControl[30*2048 + 1083]) == false)
    {
        // Failed to get the GUID from the registry.  Could be bad installation
        MessageBox(m_pdlg->GetHwnd(), "Failed to read the TapeMastering GUID from the Xbox SDK " \
                   "registry key.  Please verify that you have a valid XDK installation.",
                   "Failed to obtain GUID", MB_ICONEXCLAMATION | MB_OK | MB_APPLMODAL);
        return E_FAIL;
    }

    // Create the output file.  The path and filename are separated in case the destination
    // is tape media.
    CFile outfile(m_pdlg, this, m_media, m_szDestPath, "XCONTROL.DAT", false);
    if (!outfile.IsInited())
    {
        // Failed to create the file.  Inform the user
        outfile.InformError(m_pdlg->GetHwnd(), outfile.GetInitCode(), outfile.GetFilename());
        return E_FAIL;
    }

    // Finally, write the buffer to the file.
    HRESULT hr = outfile.Write(rgbyXControl, sizeof(rgbyXControl));
    if (hr != S_OK)
    {
        outfile.Close();
        outfile.InformError(m_pdlg->GetHwnd(), hr, outfile.GetFilename());
        return hr;
    }

    // We're done writing the file.
    hr = outfile.Close();
    if (hr != S_OK)
    {
        outfile.InformError(m_pdlg->GetHwnd(), hr, outfile.GetFilename());
        return hr;
    }

    // Return that the file was successfully generated
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xbpremaster\CStep.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CStep.h
// Contents:  Contains declarations of base CStep class and derived steps
// Revisions: 31-May-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ CLASSES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// CStep         -- Defines the base Step class.  A Step is exposed to the user as a dialog box
//                  with options that control which step to move to next.  Note that all steps
//                  use the same dialog box.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class CStep : public CInitedObject
{
public:
    CStep(CDlg *pdlg);
    virtual ~CStep();

    virtual bool DoModal() { return false; }    // by default steps are modeless. override this function to make a modal step
    virtual void HandleButtonPress(int nButtonId) = NULL;

protected:
    CDlg *m_pdlg;
};

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// CStep_UserAction  -- This is the first step that the user performs.  It prompts them with the
//                     desired action (write or verify).
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class CStep_UserAction : public CStep
{
public:
    CStep_UserAction(CDlg *pdlg);
    void HandleButtonPress(int nButtonId);
};

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// CStep_DestSource  -- This step walks the user through the process of setting us the destination
//                     (if action == 'write') or source (if action == 'verify') path and media
//                     (disk or tape).
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class CStep_DestSource : public CStep
{
public:
    CStep_DestSource(CDlg *pdlg);
    void HandleButtonPress(int nButtonId);
    bool DoModal();

private:

    void SetMedia(eMedia media);
    void SetSource(eSource source);
    HRESULT GetPathNameCommon();
    bool ValidatePath();
    bool ValidateFiles();
    bool FLDAndFSTInSync(char *szFLDName, char *szFSTName);

    void UpdateAvailableTapeDrives();

    bool m_fAllowReadFromPackage, m_fAllowToDisk;
    int m_cTapeDrives;
    eMedia m_media;
    eSource m_source;
};

#define BATCH 10
struct sString
{
    char sz[MAX_PATH];
};
extern sString *g_rgstrInvalidXbeName;
extern int g_cInvalidXbes;
extern int g_cMaxInvalidXbes;

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// CStep_Progress    -- This step displays the progress of the current action.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class CStep_Progress : public CStep
{
public:
    CStep_Progress(CDlg *pdlg, eSource source, eMedia media, char szDestPath[MAX_PATH],
                   char szFLDFile[MAX_PATH]);
    void HandleButtonPress(int nButtonId);

    // Override the virtual 'DoModal' function so that we can create a modal step.
    bool DoModal();
    bool CheckCancelled();

    CTapeDevice m_td;

private:
    DWORD WriteFiles();

    HRESULT PackageFiles(CFST *pfst, char *szRoot, char *szFLDName, char *szFSTName, char *szBinName);
    HRESULT ExtractPackagedFiles(char *szPackageName);

    bool GetFSTFileSizes(CFST *pfst, ULARGE_INTEGER *puliSize);

    HRESULT CreateXcontrolFile();
    HRESULT CreateDx2mlFile(CFLD *pfldfile, CDX2MLFile *pxml);
    HRESULT CreateXImageFile(int nLayer, CFST *pfst, CDX2MLFile *pxml);

    HRESULT AddMedia(DXML *pdxml);
    HRESULT AddLayer(CFLD *pfld, DXML *pdxml, int nLayer);

    HRESULT FillRandomBlocks(CFile *pfileOut, int nBlocks);
    HRESULT FillRandomBytes(CFile *pfileOut, int nBytes);
    bool IncProgressBar(int nBlocksWritten);

    void CheckInPlaceholder(CFile *pfile);
    void ClearInPlaceholder();

    eSource m_source;
    eMedia m_media;
    char m_szDestPath[MAX_PATH];
    char m_szSourceFile[MAX_PATH];
    HANDLE m_hthreadAction;
    bool m_fCancelled;
    DWORD m_rgdwPH[9];
    int m_iCurPH;
    int m_cBlocksWritten;
    char m_szPackageExtractFolder[MAX_PATH];
    char m_szPackageDVDRoot[MAX_PATH];
};

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// CStep_Completion  -- This step displays the results of the action (success or failure) and 
//                      presents the user with the option to verify (if action == write), perform
//                      a new action, or exit.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class CStep_Completion : public CStep
{
public:
    CStep_Completion(CDlg *pdlg, eSource source, eMedia media, char szPath[MAX_PATH],
                      char szFLDFile[MAX_PATH], char szResult[1024]);
    void HandleButtonPress(int nButtonId);
private:

    void SaveLogFile(char *szText, char *szFile);

    eSource m_source;
    eMedia m_media;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xbpremaster\CStep_Completion.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CStep_Completion.cpp
// Contents:  Final step of the xbPremaster wizard.  This step displays the results of the action
//            to the user.
// Revisions: 31-May-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"
#include <commdlg.h>
extern CCheckSum g_xsum;
extern int g_nMinAppLevel;

extern DWORD g_dwTapeChecksum;
extern DWORD g_dwPackageChecksum;
extern char g_szDefaultOutputFile[MAX_PATH];

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void CStep_Completion::SaveLogFile(char *szText, char *szFile)
{
    OPENFILENAME ofn;
    static TCHAR szTitleName[MAX_PATH], szFileName[MAX_PATH];
    static TCHAR szFilter[] = TEXT("Txt Files (*.TXT)\0*.txt\0") \
                              TEXT("All Files (*.*)\0*.*\0\0");
    char *szName;

    // The user could have specified the log filename on the command line
    if (lstrcmpi(g_szDefaultOutputFile, ""))
        szName = g_szDefaultOutputFile;
    else
    {
Save:
        // Initialize the common save-file dialog box structure
        memset(&ofn, 0, sizeof(ofn));
        ofn.lStructSize    = sizeof(OPENFILENAME);
        ofn.lpstrFilter    = szFilter;
        ofn.nMaxFile       = MAX_PATH;
        ofn.nMaxFileTitle  = MAX_PATH;
        ofn.lpstrDefExt    = TEXT("txt");
        ofn.hwndOwner      = m_pdlg->GetHwnd();
        ofn.lpstrFile      = szFileName;
        ofn.lpstrFileTitle = szTitleName;
        ofn.lpstrTitle     = "Save Premaster Log File (required action)";
        ofn.Flags          = OFN_OVERWRITEPROMPT;

        // Pop up the common save-file dialog box.
        if (!GetSaveFileName(&ofn))
        {
            // Nope, you're GOING to save it
            MessageBox(m_pdlg->GetHwnd(), "The xbpremaster log file contains important CRC information that "\
                             "cannot\nbe regenerated.  As a result, it is required that the file "\
                             "be saved.", "File must be saved.", MB_ICONEXCLAMATION | MB_OK);
            goto Save;
        }
        szName = ofn.lpstrFile;
    }

    HANDLE hfile = CreateFile(szName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hfile == INVALID_HANDLE_VALUE)
    {
        // Figure out why we died
        DWORD dwErr = GetLastError();
        switch(dwErr)
        {
        case ERROR_ALREADY_EXISTS:
            // Already prompted (automatically) for this in the GetSaveFileName dialog.  Fall
            // out of error handling
            break;

        case ERROR_DISK_FULL:
            MessageBox(m_pdlg->GetHwnd(), "The specified drive is full.  Please free some space on it or select another drive, and try again.",
                       "Insufficient disk space", MB_ICONWARNING | MB_OK);
            goto Save;

        case ERROR_ACCESS_DENIED:
            MessageBox(m_pdlg->GetHwnd(), "The specified file cannot be overwritten.  Please ensure the file isn't in use and try again.",
                       "Cannot overwrite file", MB_ICONWARNING | MB_OK);
            goto Save;

        default:
            MessageBox(m_pdlg->GetHwnd(), "xbPremaster cannot save the log to the specified location.  Please check the device and try again.",
                       "Cannot save file", MB_ICONWARNING | MB_OK);
            goto Save;
        }
    }

    // Write the log file
    DWORD dwToWrite = strlen(szText), dwWritten;

    if (!WriteFile(hfile, szText, dwToWrite, &dwWritten, NULL) || dwWritten != dwToWrite)
    {
        MessageBox(m_pdlg->GetHwnd(), "Failed to write log file to specified location.  Please try again.",
            "Invalid location", MB_ICONWARNING | MB_OK);
        goto Save;
    }

    // File successfully written
    CloseHandle(hfile);

    strcpy(szFile, szName);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStep_Completion::CStep_Completion
// Purpose:   CStep_Completion constructor.
// Arguments: pdlg          -- The dialog in which the step will appear.
//            action        -- The action performed (write, verity, etc)
//            media         -- The media the action was performed on (tape, disk)
//            szPath        -- The location in which files were created.  Ignored if media == tape.
//            szFLDFile     -- The location of the source FLD file.  Used if the user goes straight
//                             to 'verify' from here.
//            szResult      -- The result of the action.  Determined by the previous CStep
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CStep_Completion::CStep_Completion(CDlg *pdlg, eSource source, eMedia media, 
                                   char szPath[MAX_PATH], char szFLDFile[MAX_PATH],
                                   char szResult[MAX_PATH]) : CStep(pdlg)
{
    bool fSuccessful;
    char szFile[MAX_PATH];

    // Track the action and media that the user selected
    m_source = source;
    m_media  = media;
        
    if (!lstrcmpi(szResult, "The operation completed successfully"))
        fSuccessful = true;
    else
        fSuccessful = false;

    // Set the result text
    char szOutput[4000];
    char szTemp[MAX_PATH];

    // Add the result string
    sprintf(szOutput, "Source FLD File: %s\r\n\r\nResult: %s", szFLDFile, szResult);

    // Add the list of invalid xbes (if any)
    if (g_cInvalidXbes)
    {
        strcat(szOutput, "\r\n\r\nThe following XBE files are linked to " \
                        "unapproved libraries, and may not be approved:");
        for (int i = 0; i < g_cInvalidXbes; i++)
        {
            strcat(szOutput, "\r\n    ");
            strcat(szOutput, g_rgstrInvalidXbeName[i].sz);
        }
    }

    // Add the checksum (if successful)
    if (fSuccessful && (media == MEDIA_TAPE))
    {
        sprintf(szTemp, "\r\n\r\nSubmission CRC: 0x%08X\r\n\r\nMedia CRC: 0x%08X",
                 g_dwTapeChecksum, g_xsum.DwFinalSum());
        strcat(szOutput, szTemp);
        if (source == SOURCE_PACKAGE)
        {
            sprintf(szTemp, "\r\n\r\nPackage CRC: 0x%08X", g_dwPackageChecksum);
            strcat(szOutput, szTemp);
        }
    }
    if (fSuccessful && (media == MEDIA_ELECSUB))
    {
        sprintf(szTemp, "\r\n\r\nSubmission CRC: 0x%08X", g_dwPackageChecksum);
        strcat(szOutput, szTemp);
        sprintf(szTemp, "\r\n\r\nPackage file saved as '%s'.", szPath);
        strcat(szOutput, szTemp);
    }

    if (g_nMinAppLevel == 0)
    {
        // Total failure! We will refuse to accept the app.  Inform the user
        MessageBox(pdlg->GetHwnd(), "Your image contains one or more " \
                   "libraries which are unapproved.\nThe image will not be " \
                   "accepted for certification", "Invalid image", MB_ICONEXCLAMATION | MB_OK);
    }
    else if (g_nMinAppLevel == 1)
    {
        // Potential failure.  We may refuse to accept the app.
        MessageBox(pdlg->GetHwnd(), "Your image contains one or more " \
                   "libraries which may not be approved.\nThe image may or " \
                   "may not be accepted for certification", "Invalid image",
                   MB_ICONEXCLAMATION | MB_OK);
    }

    if (fSuccessful && (media == MEDIA_TAPE))
    {
        // **FORCE** the user to save the log file.
        SaveLogFile(szOutput, szFile);
        sprintf(szTemp, "\r\n\r\nResult log saved to file '%s'.", szFile);
        strcat(szOutput, szTemp);
    }

    if (fSuccessful && (media == MEDIA_ELECSUB))
    {
        // **FORCE** the user to save the log file.
        SaveLogFile(szOutput, szFile);
        sprintf(szTemp, "\r\n\r\nResult log saved to file '%s'.", szFile);
        strcat(szOutput, szTemp);
    }

    // Make all of our controls visible
    m_pdlg->DisplayControl(IDC_COMPLETION_STATIC3);
    m_pdlg->DisplayControl(IDC_COMPLETION_TEXT_TITLE);
    m_pdlg->DisplayControl(IDC_COMPLETION_TEXT_BODY);
    m_pdlg->DisplayControl(IDC_COMPLETION_BTN_FINISH);
    m_pdlg->DisplayControl(IDC_BTN_PREV);
    m_pdlg->DisplayControl(IDC_BTN_EXIT);
    m_pdlg->DisplayControl(IDC_COMPLETION_STATIC);
    m_pdlg->DisplayControl(IDC_COMPLETION_STATIC2);
    m_pdlg->DisplayControl(IDC_COMPLETION_TEXT_TOCLOSE);
    m_pdlg->SetControlEnable(IDC_BTN_PREV, false);
    m_pdlg->SetControlEnable(IDC_BTN_EXIT, false);

    // Overload the background colors of some controls to white
    m_pdlg->OverloadBkColor(IDC_COMPLETION_TEXT_TITLE);
    m_pdlg->OverloadBkColor(IDC_COMPLETION_TEXT_BODY);
    m_pdlg->OverloadBkColor(IDC_COMPLETION_TEXT_TOCLOSE);

    if (m_media == MEDIA_TAPE)
        m_pdlg->DisplayControl(IDC_COMPLETION_BTN_EJECT);

    m_pdlg->SetControlText(IDC_COMPLETION_TEXT_BODY, szOutput);
    m_pdlg->SetControlFont(IDC_COMPLETION_TEXT_TITLE, -18, "Arial", 0);

    // Set the exit button as the default control
    m_pdlg->SetCurControl(IDC_BTN_EXIT);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStep_Completion::HandleButtonPress
// Purpose:   This function is called when the user presses a button.
// Arguments: nButtonId         -- the resource identifier of the button pressed.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CStep_Completion::HandleButtonPress(int nButtonId)
{
    switch (nButtonId)
    {
    case IDC_COMPLETION_BTN_FINISH:
    case ID_ESCAPE_KEY:
        // User wants to exit the application.  Inform the dialog that there is no 'next' step.
        m_pdlg->SetNextStep(NULL);
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xbpremaster\CreateXImageFile.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CreateXImageFile.cpp
// Contents:  Contains code to create the Ximage*.dat files.
// Revisions: 6-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"
#include <xboxverp.h>

struct VERSION_INFO 
{
    BYTE rgbySig[32];
    BYTE rgbyLayoutVersion[8];
    BYTE rgbyPremasterVersion[8];
    BYTE rgPadding[2048-32-8-8];    // fill with zeros
};
#define VERSION_SIG "XBOX_DVD_LAYOUT_TOOL_SIG"


CCheckSum g_xsum;
bool g_fInPlaceholder = false, g_fInXbe = false, g_fInMedia = false;
int g_nMinAppLevel = 255;

bool g_fDontWarnInvalidXBE = false;

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ DEFINES  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ONE_BLOCK        -- Number of bytes in one block.
#define ONE_BLOCK 2048

// QUEUE            -- Number of blocks to queue up for the write for performance
#define QUEUE 16


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  DebugOutput
// Purpose:   Debugging aid.  Outputs the specified vararg string to the debugger
// Arguments: lpszFormat        -- Format of the string to output
//            ...               -- Optional variables for the format string.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void DebugOutput(LPCTSTR lpszFormat, ...)
{
#ifdef _DEBUG
    va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	TCHAR szBuffer[512];

	nBuf = vsprintf(szBuffer, lpszFormat, args);

    OutputDebugString(szBuffer);

	va_end(args);
#endif
}

extern DWORD g_cbyTotalWritten;

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStep_Progress::CheckInPlaceholder
// Purpose:   
// Arguments: 
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CStep_Progress::CheckInPlaceholder(CFile *pfileXImage)
{
    // Look at how many blocks have been written; are we currently in a placeholder?

    // Convert the location to block number
    DWORD dwCurBlock = g_cbyTotalWritten / 2048;

    // Compare the block number against the next placeholder block to see
    // if the block number is inside (or past) it.
CheckPH:
    if (dwCurBlock >= m_rgdwPH[m_iCurPH])
    {
        if (dwCurBlock >= m_rgdwPH[m_iCurPH] + 4096)
        {
            m_iCurPH++;
            goto CheckPH;
        }
        g_fInPlaceholder = true;
    }
    else
        g_fInPlaceholder = false;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStep_Progress::ClearInPlaceholder
// Purpose:   
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CStep_Progress::ClearInPlaceholder()
{
    g_fInPlaceholder = false;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStep_Progress::FillRandomBlocks
// Purpose:   Writes out the specified number of blocks to the specified file.  Filled with psuedo-
//            random data.  Each block is 2048 bytes.
// Arguments: pfileOut          -- The file to write the random blocks to.
//            nBlocks           -- The number of blocks to write.
// Return:    S_OK on success, E_FAIL on failure (or cancellation)
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CStep_Progress::FillRandomBlocks(CFile *pfileOut, int nBlocks)
{
    HRESULT hr;
    BYTE by[ONE_BLOCK];

    DebugOutput("Filling %d random blocks.  Total written: %d blocks\r\n", nBlocks, m_cBlocksWritten + nBlocks);

    for (int i = 0; i < nBlocks; i++)
    {
        // Fill the buffer with random data.
        g_rand.RandBytes(by, ONE_BLOCK);

        // If the current block is in a placeholder, then we need to be sure that
        // these random bytes are not added to the checksum (calculated in Write)
        CheckInPlaceholder(pfileOut);

        // Write the next block of random data
        hr = pfileOut->Write((BYTE*)by, ONE_BLOCK);
        if (hr != S_OK)
        {
            pfileOut->InformError(m_pdlg->GetHwnd(), hr, pfileOut->GetFilename());
            goto done;
        }

        if (IncProgressBar(1) == true)
        {
            hr = E_FAIL;
            goto done;
        }
    }

    // If here, then we were successful
    hr = S_OK;
    
done:

    ClearInPlaceholder();

    return hr;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStep_Progress::FillRandomBytes
// Purpose:   Writes out the specified number of bytes to the specified file.  Filled with psuedo-
//            random data.
// Arguments: pfileOut          -- The file to write the random bytes to.
//            nBytes            -- The number of bytes to write
// Return:    S_OK on success, error code otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CStep_Progress::FillRandomBytes(CFile *pfileOut, int nBytes)
{
    BYTE by[ONE_BLOCK];
    HRESULT hr;

    // Batch blocks together for performance.
    if (nBytes > ONE_BLOCK)
    {
        hr = FillRandomBlocks(pfileOut, nBytes / ONE_BLOCK);
        if (hr != S_OK)
            goto done;
        
        nBytes %= ONE_BLOCK;
    }

    if (nBytes)
    {
        DebugOutput("Filling %d random BYTES.\r\n", nBytes);

        // Fill the buffer with random data.
        g_rand.RandBytes(by, nBytes);

        // If the current block is in a placeholder, then we need to be sure that
        // these random bytes are not added to the checksum (calculated in Write)
        CheckInPlaceholder(pfileOut);

        hr = pfileOut->Write((BYTE*)by, nBytes);
        if (hr != S_OK)
        {
            pfileOut->InformError(m_pdlg->GetHwnd(), hr, pfileOut->GetFilename());
            goto done;
        }
    }

    // If here, then we were successful
    hr = S_OK;

done:

    ClearInPlaceholder();

    return S_OK;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStep_Progress::IncProgressBar
// Purpose:   Increase the number of blocks written and update the progress bar.  Also checks to
//            see if the user has pressed the cancel button.
// Arguments: nBlocksWritten        -- The number of blocks written since the last call to
//            IncProgressBar.
// Return:    'true' if the user cancelled
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CStep_Progress::IncProgressBar(int nBlocksWritten)
{
    m_cBlocksWritten += nBlocksWritten;

    // Update the progress bar
    m_pdlg->SetProgressPos(IDC_PROGRESS_PROGRESSBAR, m_cBlocksWritten);

//    sprintf(sz, "%d %% (%d blocks written)", m_cBlocksWritten * 100 / NUM_XDATA_SECTORS, m_cBlocksWritten);
  //  m_pdlg->SetControlText(IDC_PROGRESS_TEXT_PROGRESS, sz);

    // Check if we should cancel
    return CheckCancelled();
}

sString *g_rgstrInvalidXbeName;
int g_cInvalidXbes;
int g_cMaxInvalidXbes;
int g_nInvalidXbeLevel;

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  InvalidXbeProc
// Purpose:   Message handler for InvalidXBE dialog. This function is automatically called by Windows
//            whenever a message needs to be sent to the dialog box (ie 'paint', 'move', etc).
// Arguments: hDlg          -- Handle to the Dialog box's window
//            message       -- The message sent to the dialog box
//            wParam        -- A message parameter.
//            lParam        -- Another message parameter
// Return:    nonzero if we processed the message
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LRESULT CALLBACK InvalidXbeProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    char szBuf[1024];

	switch (message)
	{
	case WM_INITDIALOG:
        if (g_nInvalidXbeLevel == 0)
            sprintf(szBuf, "The XBE file '%s' is linked with unapproved " \
                           "libraries, and will not be accepted for "\
                           "certification", g_rgstrInvalidXbeName[g_cInvalidXbes].sz);
        else
            sprintf(szBuf, "The XBE file '%s' is linked with potentially " \
                           "unapproved libraries, and may not be accepted for",
                           " certification", g_rgstrInvalidXbeName[g_cInvalidXbes].sz);

        SetDlgItemText(hDlg, IDC_TEXT, szBuf);
		return true;

	case WM_COMMAND:
        if (wParam == ID_OK)
        {
            // Did the user check the 'go away' checkbox?
            g_fDontWarnInvalidXBE = IsDlgButtonChecked(hDlg, IDC_DONTTELL) ? true : false;
		    EndDialog(hDlg, 0);
        }
		return false;
	}
    return false;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStep_Progress::CreateXImageFile
// Purpose:   Creates the ximage*.dat files.
// Arguments: nLayer                -- Layer (0 or 1) to create
//            pfst                  -- Pointer to the object that contains the list of files to add
// Return:    S_OK if successful, OLE-compatible error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CStep_Progress::CreateXImageFile(int nLayer, CFST *pfst, CDX2MLFile *pxml)
{    
    char szName[MAX_PATH];
    int nWritten;
    HRESULT hr;

    // Clear the "we're currently in a placeholder" flag.  This flag is used to
    // determine whether or not a particular block being written out needs to
    // be added to the submission checksum
    ClearInPlaceholder();
    g_fInXbe = false;
    g_fInMedia = true;
    g_cbyTotalWritten = 0;

    // Walk the specifed xml object to determine where the placeholders are.
    DXML *pdxml = pxml->PdxmlGet();
    for (int i = 0; i < 8; i++)
        m_rgdwPH[i] = pdxml->rgdxl[nLayer].rgxph[i].lsnStart;
    m_rgdwPH[8] = (DWORD)-1;
    m_iCurPH = 0;

    // Create the name of this ximage*.dat file.
    sprintf(szName, "XIMAGE%d.DAT", nLayer);

    // Create the output file.  The path and filename are separated in case the destination is tape
    CFile outfile(m_pdlg, this, m_media, m_szDestPath, szName, false);
    if (!outfile.IsInited())
    {
        // Failed to create the file.  Inform the user
        outfile.InformError(m_pdlg->GetHwnd(), outfile.GetInitCode(), outfile.GetFilename());
        return outfile.GetInitCode();
    }

    // Keep track of how many blocks we've written so far (used for updating the progress bar)
    if (nLayer == 0) m_cBlocksWritten = 0;

    int nPrevLSN = 0;
    int iObject  = 0;

    // Repeat until we've reached the end of the XDATA region
    while (nPrevLSN < NUM_XDATA_SECTORS)
    {
        int nStartLSN, nEndLSN, nSectorsToWrite;
        DWORD dwOffset;
        char szName[MAX_PATH];

        g_fInXbe = false;

        // Get the next object in the FST.
        if (!pfst->GetEntry(nLayer, iObject, szName, &nStartLSN, &nEndLSN,
                   &dwOffset, m_source == SOURCE_PACKAGE, m_szPackageDVDRoot))
        {
            // There are no more objects in the FST.  Fill the rest of the sectors with random.
            DebugOutput("No more objects in FST. Filling remaining %d blocks with random\r\n",
                        NUM_XDATA_SECTORS - nPrevLSN);
            hr = FillRandomBlocks(&outfile, NUM_XDATA_SECTORS - nPrevLSN);
            if (hr != S_OK)
                goto done;

            nEndLSN = NUM_XDATA_SECTORS;
        }
        else
        {
            // Found another object in the FST.
            DebugOutput("File '%s' found in FST at LSN %d.\r\n",szName, nStartLSN);
            if (nStartLSN > nPrevLSN)
            {
                // Fill in the blocks between the current object and the previous object with random data
                DebugOutput("  Filling previous blocks [%d-%d] with random data \r\n", nPrevLSN,
                            nStartLSN - 1);
                hr = FillRandomBlocks(&outfile, nStartLSN - nPrevLSN);
                if (hr != S_OK)
                    goto done;
            }

            // Calculate how many sectors are used up by this FST entry
            nSectorsToWrite = nEndLSN - nStartLSN + 1;

            DebugOutput("   Preparing to fill blocks [%d-%d] with file data \r\n", nStartLSN, nEndLSN);

            // Write out the new object to the outfile

            // Load the FST object (file)
            CFile *pfileNext = new CFile(m_pdlg, this, szName);
            if (!pfileNext->IsInited())
            {
                // Failed to load the specified FST object
                hr = pfileNext->GetInitCode();
                pfileNext->InformError(m_pdlg->GetHwnd(), hr, pfileNext->GetFilename());
                goto done;
            }
            
            // Is the object an xbe file?  If so, we need to update the black
            // xcheck checksum, and check the xbe's library validation state
            if (!lstrcmpi(szName + strlen(szName) - 4, ".xbe"))
            {
               // Create a new CXBEFile to point at the file
                CFileStmRand *pstm;
                pfileNext->CreateFileStm(&pstm);
                CXBEFile xf(pstm);
                xf.FCalcChecksums(&g_xsum, NULL, NULL);
                int nLibApprovalLevel = xf.GetLibApprovalLevel();
                g_nMinAppLevel = min(g_nMinAppLevel, nLibApprovalLevel);

                if (nLibApprovalLevel <= 1)
                {
                    // uh oh, we don't support it.  Warn the user

                    // Need to allocate more space for the list of invalid
                    // xbe names?
                    if (g_cInvalidXbes == g_cMaxInvalidXbes)
                    {
                        g_cMaxInvalidXbes += BATCH;
                        g_rgstrInvalidXbeName = (sString*)realloc(
                                        g_rgstrInvalidXbeName,
                                        g_cMaxInvalidXbes*sizeof(sString));
                    }

                    strcpy(g_rgstrInvalidXbeName[g_cInvalidXbes].sz, szName);

                    // Pop up the modal dialog to warn the user
                    if (!g_fDontWarnInvalidXBE)
                    {
                        g_nInvalidXbeLevel = nLibApprovalLevel;
#if 1
                        // Just add the information to the dialog so that the
                        // user can see that something bad happened
                        char sz[MAX_PATH + 50];
                        sprintf(sz, "Warning: Invalid xbe encountered (%s)",
                                szName);
                        m_pdlg->SetControlText(IDC_PROGRESS_BADXBE, sz);
#else
                        // Do a modal dialog to force user intervention
                        DialogBox(m_pdlg->GetInst(), (LPCTSTR)IDD_INVALIDXBE,
                                  m_pdlg->GetHwnd(), (DLGPROC)InvalidXbeProc);
#endif
                    }
                    g_cInvalidXbes++;
                }

                delete pstm;
                g_fInXbe = true;
            }

            // Seek to the specified offset within the file.
            LARGE_INTEGER liDist;
            liDist.QuadPart = dwOffset;
            DebugOutput("   Seeking to %d\r\n", liDist.LowPart);
            hr = pfileNext->SeekTo(liDist);
            if (hr != S_OK)
            {
                pfileNext->InformError(m_pdlg->GetHwnd(), hr, pfileNext->GetFilename());
                pfileNext->Close();
                goto done;
            }

            DebugOutput("   Copying %d File BYTEs\r\n", nSectorsToWrite * 2048);
            
            // Is the object the volume descriptor?  If so, special case it so
            // that we can inject our version information.  If the volume
            // descriptor is only 1 sector long, then the FLD came from an
            // old version of xbLayout and should be relaid out.
            if (nStartLSN == 32)
            {
                if (nSectorsToWrite == 1)
                {
                    MessageBox(m_pdlg->GetHwnd(), "The specified FLD file was generated in an obsolete version\n"
                               "of xbLayout.  Please reload your FLD file in the latest version of\nxbLayout and "
                               "click 'Premaster' again to generate updated FST and BIN files.",
                               "Obsolete layout encountered", MB_ICONEXCLAMATION | MB_OK);
                    pfileNext->Close();
                    hr = E_FAIL;
                    goto done;
                }
                BYTE rgby[4096];
                int nRead;
                hr = pfileNext->Read(rgby, 4096, &nRead);
                if (!SUCCEEDED(hr) || nRead != 4096)
                {
                    outfile.InformError(m_pdlg->GetHwnd(), hr, pfileNext->GetFilename());
                    pfileNext->Close();
                    goto done;
                }

                if (memcmp(rgby+2048, VERSION_SIG, strlen(VERSION_SIG)))
                {
                    MessageBox(m_pdlg->GetHwnd(), "An invalid version signature was encountered.",
                               "Invalid layout encountered", MB_ICONEXCLAMATION | MB_OK);
                    pfileNext->Close();
                    hr = E_FAIL;
                    goto done;
                }
                
                // Inject our version number
                VERSION_INFO *pverinfo = (VERSION_INFO*)&rgby[2048];
                int nMajor, nMinor, nBuild, nQFE;
                sscanf(VER_PRODUCTVERSION_STR, "%d.%d.%d.%d", &nMajor, &nMinor, &nBuild,
                                                              &nQFE);
                *(WORD*)(&pverinfo->rgbyPremasterVersion[0]) = (WORD)nMajor;
                *(WORD*)(&pverinfo->rgbyPremasterVersion[2]) = (WORD)nMinor;
                *(WORD*)(&pverinfo->rgbyPremasterVersion[4]) = (WORD)nBuild;
                *(WORD*)(&pverinfo->rgbyPremasterVersion[6]) = (WORD)nQFE;

                // Write the bytes to the destination
                hr = outfile.Write(rgby, 4096);
                if (!SUCCEEDED(hr))
                {
                    outfile.InformError(m_pdlg->GetHwnd(), hr, outfile.GetFilename());
                    pfileNext->Close();
                    goto done;
                }
                nWritten = 4096;
            }
            else
            {
                // Write the specified number of bytes ((end - start + 1) * sector size) of the file to
                // the outfile.  The CopyFileBytes will copy from the current location of the source
                // file, and will copy the requested number of bytes;  it will return the number of
                // bytes written.
                if (!outfile.CopyFileBytes(pfileNext, nSectorsToWrite * 2048, &nWritten, &hr))
                {
                    // An error occurred or the user cancelled.  Only report error if not cancelled
                    if (hr != S_OK)
                        outfile.InformError(m_pdlg->GetHwnd(), hr, outfile.GetFilename());
                    pfileNext->Close();
                    goto done;
                }
            }

            // If the file is smaller than the requested number of sectors then we need to (a)
            // calculate how many bytes were not written, and (b) fill them with random data.

            // Calculate the number of bytes remaining (if any)
            int nRemaining = (nSectorsToWrite * 2048 - nWritten);
            if (nRemaining)
            {
                // The file size wasn't exactly divisible by the sector size.  Fill the remaining
                // bytes with random data.
                DebugOutput("   Filling %d remaining random BYTEs\r\n", nRemaining);
                hr = FillRandomBytes(&outfile, nRemaining);
                if (hr != S_OK)
                {
                    pfileNext->Close();
                    goto done;
                }
            }

            // Increment the progress bar and check if the user clicked 'cancel'
            if (IncProgressBar(nSectorsToWrite) == true)
            {
                // User cancelled
                pfileNext->Close();
                goto done;
            }
            
            DebugOutput("   %d total sectors written out so far\r\n", m_cBlocksWritten);

            // We're done with this FST file object
            hr = pfileNext->Close();
            if (hr != S_OK)
                goto done;

            delete pfileNext;
            iObject++;
        }
        nPrevLSN = nEndLSN + 1;
    }

    // If here, then file was successfully created
    hr = S_OK;

done:

    // We're done writing the file.
    outfile.Close();

    g_fInMedia = false;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xbpremaster\CStep.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CStep.cpp
// Contents:  Base Step class.  This represents a single step in a wizard-like application.  The
//            application will create a series of CStep-derived classes that walk the user through
//            the desired action(s).
// Revisions: 31-May-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStep::CStep
// Purpose:   CStep constructor
// Arguments: pdlg          -- Dialog that this step will be displayed in.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CStep::CStep(CDlg *pdlg)
{
    // Track which dialog we're appearing in.
    m_pdlg = pdlg;

    // Validate parameters
    if (pdlg == NULL)
    {
        SetInited(E_INVALIDARG);
        return;
    }

    // Hide all previously visible controls in the dialog (from the previous step)
    pdlg->HideAllControls();

    pdlg->m_pstepCur = this;
    
    // Mark that we were successfully initialized
    SetInited(S_OK);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStep::~CStep
// Purpose:   CStep destructor
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CStep::~CStep()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xbpremaster\CStep_DestSource.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CStep_DestSource.cpp
// Contents:  In this step, the user enters the source and destination paths for the desired action
// Revisions: 31-May-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ GLOBAL VARIABLES ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

extern char g_szDefaultFLD[MAX_PATH], g_szDefaultPKG[MAX_PATH], g_szDefaultOutputFile[MAX_PATH];
extern int g_iDefaultTapeDrive;

extern bool VerifyPackageFile(char *szPKGFile);

// Structures and defines for timestamp verification
typedef struct
{
    WORD wMajor;
    WORD wMinor;
    WORD wBuild;
    WORD wQFE;
} sVersion;

#define FLD_SIG "XBOXFLDFILE"
#define FLD_SIG_SIZE sizeof(FLD_SIG)

typedef struct
{
    BYTE  szSig[FLD_SIG_SIZE];
    time_t timeSaved;
    sVersion version;
} sFLDHeader;

// Taken from AMC's file "MediaBase.h"
struct TFileHeader
{
    char m_szFileType[32]; // FST? Error Map?
    char m_szMediaType[32]; // DVD, CD, etc
};

struct TMediaHeader
{
    DWORD uNumSectorsLayer0;
    DWORD uNumSectorsLayer1;
    BYTE m_ImpUseArea[120];       // total = 128 bytes
};


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStep_DestSource::CStep_DestSource
// Purpose:   CStep_DestSource constructor.
// Arguments: pdlg          -- The dialog in which the step will appear.
//            action        -- The action to perform (write, verity, etc)
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CStep_DestSource::CStep_DestSource(CDlg *pdlg) : CStep(pdlg)
{
    // When run internally, we allow an option which sources off of a premaster
    // "package" file.  This is allowed if a particular regkey is present
    HKEY hkey;
    if ((RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                      TEXT("SOFTWARE\\Microsoft\\XboxSDK\\xbPremaster"), 0,
                      KEY_READ, &hkey) == ERROR_SUCCESS))
    {
        m_fAllowReadFromPackage = RegQueryValueEx(hkey, "ReadFromPackage",
                                      NULL, NULL, NULL, NULL) == ERROR_SUCCESS;
        m_fAllowToDisk          = RegQueryValueEx(hkey, "RenderToDisk",
                                      NULL, NULL, NULL, NULL) == ERROR_SUCCESS;
        RegCloseKey(hkey);
    }
    else
    {
        m_fAllowReadFromPackage = false;
        m_fAllowToDisk          = false;
    }

    m_pdlg->DisplayControl(IDC_DESTSOURCE_RBTN_TAPE);
    m_pdlg->DisplayControl(IDC_DESTSOURCE_TEXT_SETDEST);
    m_pdlg->DisplayControl(IDC_DESTSOURCE_RBTN_ELEC);
    m_pdlg->DisplayControl(IDC_DESTSOURCE_TEXT_TITLE);
    m_pdlg->DisplayControl(IDC_DESTSOURCE_STATIC);
    m_pdlg->DisplayControl(IDC_DESTSOURCE_STATIC2);
    m_pdlg->DisplayControl(IDC_DESTSOURCE_LINE);
    m_pdlg->DisplayControl(IDC_STATIC3);
    m_pdlg->DisplayControl(IDC_STATIC4);

    if (m_fAllowReadFromPackage)
    {
        m_pdlg->DisplayControl(IDC_DESTSOURCE_TEXT_SETFLDPATH2);
        m_pdlg->DisplayControl(IDC_DESTSOURCE_EDIT_SETFLDPATH2);
        m_pdlg->DisplayControl(IDC_DESTSOURCE_BTN_FLDPATH2);
        m_pdlg->DisplayControl(IDC_DESTSOURCE_RBTN_PACKAGE);
        m_pdlg->DisplayControl(IDC_DESTSOURCE_RBTN_FLD);
        
        if (lstrcmpi(g_szDefaultPKG, ""))
            SetSource(SOURCE_PACKAGE);
        else
            SetSource(SOURCE_FLD);

        m_pdlg->SetControlText(IDC_DESTSOURCE_EDIT_SETFLDPATH2, g_szDefaultPKG);        

        // Also allow render to disk for testing purposes
        if (m_fAllowToDisk)
            m_pdlg->DisplayControl(IDC_DESTSOURCE_RBTN_DISK);
    }
    else
        m_pdlg->DisplayControl(IDC_DESTSOURCE_TEXT_SETFLDPATH);

    m_pdlg->DisplayControl(IDC_DESTSOURCE_BTN_FILEPATH);
    m_pdlg->DisplayControl(IDC_DESTSOURCE_EDIT_SETDISKPATH);
    m_pdlg->DisplayControl(IDC_DESTSOURCE_EDIT_SETFLDPATH);
    m_pdlg->DisplayControl(IDC_DESTSOURCE_BTN_FLDPATH);
    m_pdlg->DisplayControl(IDC_DESTSOURCE_COMBO_TAPEDRIVES);
    m_pdlg->DisplayControl(IDC_BTN_PREV);
    m_pdlg->DisplayControl(IDC_BTN_NEXT);
    m_pdlg->DisplayControl(IDC_BTN_EXIT);
    m_pdlg->SetControlEnable(IDC_BTN_PREV, true);

    // By default the user starts with 'tape' as the media, so set the appropriate media controls.
    SetMedia(MEDIA_TAPE);
    
    // Overload the background colors of some controls to white
    m_pdlg->OverloadBkColor(IDC_DESTSOURCE_TEXT_TITLE);

    m_pdlg->SetControlFont(IDC_DESTSOURCE_TEXT_TITLE, -11, "Arial", FW_BOLD);

    // Set the FLD path text control as the default control
    m_pdlg->SetCurControl(IDC_DESTSOURCE_EDIT_SETFLDPATH);

    m_pdlg->SetControlText(IDC_DESTSOURCE_EDIT_SETFLDPATH, g_szDefaultFLD);
    m_pdlg->SetControlText(IDC_DESTSOURCE_EDIT_SETDISKPATH, "");

#ifdef _DEBUG1
    m_pdlg->SetControlText(IDC_DESTSOURCE_EDIT_SETDISKPATH, "C:\\jeff.pkg");
#endif
    
    // Update the list of available tape drives (in case the media is disk)
    UpdateAvailableTapeDrives();
}

bool CStep_DestSource::DoModal()
{
    // If the user specified the necessary information on the command line,
    // then go straight into the progress step
    if (g_iDefaultTapeDrive != -1)
    {
        HandleButtonPress(IDC_BTN_NEXT);
        return true;
    }
            
    return false;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStep_DestSource::SetSource
// Purpose:   
// Arguments: source        -- The new source medium
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CStep_DestSource::SetSource(eSource source)
{
    m_source = source;
    switch(source)
    {
    case SOURCE_FLD:
        m_pdlg->SetControlState(IDC_DESTSOURCE_RBTN_FLD, true);
        m_pdlg->SetControlState(IDC_DESTSOURCE_RBTN_PACKAGE, false);
        m_pdlg->SetControlEnable(IDC_DESTSOURCE_EDIT_SETFLDPATH, true);
        m_pdlg->SetControlEnable(IDC_DESTSOURCE_EDIT_SETFLDPATH2, false);
        m_pdlg->SetControlEnable(IDC_DESTSOURCE_BTN_FLDPATH, true);
        m_pdlg->SetControlEnable(IDC_DESTSOURCE_BTN_FLDPATH2, false);
        m_pdlg->SetControlEnable(IDC_DESTSOURCE_RBTN_ELEC, true);
        break;

    case SOURCE_PACKAGE:
        m_pdlg->SetControlState(IDC_DESTSOURCE_RBTN_FLD, false);
        m_pdlg->SetControlState(IDC_DESTSOURCE_RBTN_PACKAGE, true);
        m_pdlg->SetControlEnable(IDC_DESTSOURCE_EDIT_SETFLDPATH, false);
        m_pdlg->SetControlEnable(IDC_DESTSOURCE_EDIT_SETFLDPATH2, true);
        m_pdlg->SetControlEnable(IDC_DESTSOURCE_BTN_FLDPATH, false);
        m_pdlg->SetControlEnable(IDC_DESTSOURCE_BTN_FLDPATH2, true);
        m_pdlg->SetControlEnable(IDC_DESTSOURCE_RBTN_ELEC, false);
        if (m_media == MEDIA_ELECSUB)
            SetMedia(MEDIA_TAPE);
        break;
    }
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStep_DestSource::SetMedia
// Purpose:   Modifies the UI to indicate what selected media type is currently selected.
// Arguments: media         -- The media (disk, tape, ...) to use.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CStep_DestSource::SetMedia(eMedia media)
{
    // Track what the currently selected media is
    m_media = media;
    
    // Update the controls accordingly
    switch(media)
    {
    case MEDIA_ELECSUB:
        m_pdlg->SetControlEnable(IDC_DESTSOURCE_EDIT_SETDISKPATH, true);
        m_pdlg->SetControlEnable(IDC_DESTSOURCE_BTN_FILEPATH, true);
        m_pdlg->SetControlEnable(IDC_DESTSOURCE_COMBO_TAPEDRIVES, false);
        m_pdlg->SetControlState(IDC_DESTSOURCE_RBTN_ELEC, true);
        m_pdlg->SetControlState(IDC_DESTSOURCE_RBTN_DISK, false);
        m_pdlg->SetControlState(IDC_DESTSOURCE_RBTN_TAPE, false);
        m_pdlg->SetControlEnable(IDC_BTN_NEXT, true);
        break;

    case MEDIA_TAPE:
        m_pdlg->SetControlEnable(IDC_DESTSOURCE_BTN_FILEPATH, false);
        m_pdlg->SetControlEnable(IDC_DESTSOURCE_COMBO_TAPEDRIVES, true);
        m_pdlg->SetControlEnable(IDC_DESTSOURCE_EDIT_SETDISKPATH, false);
        m_pdlg->SetControlState(IDC_DESTSOURCE_RBTN_ELEC, false);
        m_pdlg->SetControlState(IDC_DESTSOURCE_RBTN_DISK, false);
        m_pdlg->SetControlState(IDC_DESTSOURCE_RBTN_TAPE, true);

        // Update the list of available tape drives
        UpdateAvailableTapeDrives();

        // Don't allow the user to click 'next' if there aren't any tape drives
        m_pdlg->SetControlEnable(IDC_BTN_NEXT, (m_cTapeDrives > 0) ? true : false);

        break;

    case MEDIA_DISK:
        m_pdlg->SetControlEnable(IDC_DESTSOURCE_EDIT_SETDISKPATH, false);
        m_pdlg->SetControlEnable(IDC_DESTSOURCE_BTN_FILEPATH, false);
        m_pdlg->SetControlEnable(IDC_DESTSOURCE_COMBO_TAPEDRIVES, false);
        m_pdlg->SetControlState(IDC_DESTSOURCE_RBTN_ELEC, false);
        m_pdlg->SetControlState(IDC_DESTSOURCE_RBTN_DISK, true);
        m_pdlg->SetControlState(IDC_DESTSOURCE_RBTN_TAPE, false);
        m_pdlg->SetControlEnable(IDC_BTN_NEXT, true);
        break;
    }
}

#define MAX_TAPE_DRIVES 100

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStep_DestSource::UpdateAvailableTapeDrives
// Purpose:   Enumerates the list of available scsi tape drives and adds them to the combobox.
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CStep_DestSource::UpdateAvailableTapeDrives()
{
    // Remove the previous list of tape drives
    m_pdlg->ClearComboBox(IDC_DESTSOURCE_COMBO_TAPEDRIVES);

    // Enumerate the list of scsi tape drives, adding each of them to the tape drive dropdown box
    for (int i = 0; i < MAX_TAPE_DRIVES; i++)
    {
        char szTapeDrive[20];
        sprintf(szTapeDrive, "\\\\.\\TAPE%d", i);

        // Try to open the 'ith' tape drive for querying.
        HANDLE hDrive = CreateFile(szTapeDrive, 0, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
        if (hDrive == INVALID_HANDLE_VALUE)
        {
            // The tape drive doesn't exist - we've reached the end of the installed drives
            break;
        }

        // The tape drive exists!  Add it to the combo box
        char sz[100];
        sprintf(sz, "Tape Drive %d", i);
        m_pdlg->AddToComboBox(IDC_DESTSOURCE_COMBO_TAPEDRIVES, sz);
    }

    // Did the user specify (on the command-line) a tape drive which isn't
    // present?
    if (g_iDefaultTapeDrive != -1 && g_iDefaultTapeDrive > i - 1)
    {
        MessageBox(m_pdlg->GetHwnd(), "Non-present tape drive specified on "
                                      "command line.", "Invalid tape drive",
                                      MB_ICONEXCLAMATION | MB_OK);
        g_iDefaultTapeDrive = -1;
    }

    if (i == 0)
    {
        // There are no tape drives currently accessible
        m_pdlg->AddToComboBox(IDC_DESTSOURCE_COMBO_TAPEDRIVES, "No Tape Drives Found");
    }

    // Keep track of how many tape drives there are
    m_cTapeDrives = i;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStep_DestSource::HandleButtonPress
// Purpose:   This function is called when the user presses a button.
// Arguments: nButtonId         -- the resource identifier of the button pressed.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CStep_DestSource::HandleButtonPress(int nButtonId)
{
    // pstepNext        -- The next step to perform
    CStep *pstepNext;

    // szSourceFile        -- Path\filename of the source (FLD, Package) file the user chose.
    char szSourceFile[MAX_PATH];

    // szDestPath       -- Pathname of the folder in which generated files should be placed.
    char szDestPath[MAX_PATH];

    switch (nButtonId)
    {
    case IDC_BTN_EXIT:
    case ID_ESCAPE_KEY:
        // User wants to exit the application.  Inform the dialog that there is no 'next' step.
        m_pdlg->SetNextStep(NULL);
        break;

    case IDC_BTN_NEXT:
        // If the source is 'package' then we need to verify it's a valid file
        if (m_source == SOURCE_PACKAGE)
        {
            // Verify the file exists
            m_pdlg->GetControlText(IDC_DESTSOURCE_EDIT_SETFLDPATH2, szSourceFile, MAX_PATH);
            if ((GetFileAttributes(szSourceFile) == 0xffffffff))
            {
                // nonexistant PKG source file specified.  Warn the user and stay in this step
                MessageBox(m_pdlg->GetHwnd(), "Please specify a valid PKG source file",
                           "Nonexistant PKG source file specified", MB_ICONEXCLAMATION | MB_OK | MB_APPLMODAL);
                break;
            }

            // Is the specified file a valid PKG file?
            if (!VerifyPackageFile(szSourceFile))
            {
                // nonexistant PKG source file specified.  Warn the user and stay in this step
                MessageBox(m_pdlg->GetHwnd(), "The specified source file is not a valid PKG file",
                           "Invalid PKG source file specified", MB_ICONEXCLAMATION | MB_OK | MB_APPLMODAL);
                break;
            }
        }
        else
        {
            // Verify that a FLD file, like-named FST file, and gdfs.bin all exist in the specified
            // location
            if (!ValidateFiles())
            {
                // User did not enter a valid path.  Remain in this step.
                m_pdlg->SetCurControl(IDC_DESTSOURCE_EDIT_SETFLDPATH);
                break;
            }

            // Grab the FLD path from the appropriate text control
            m_pdlg->GetControlText(IDC_DESTSOURCE_EDIT_SETFLDPATH, szSourceFile, MAX_PATH);
        }

        // If the media is 'Electronic Submission', then we need to verify its
        // a valid path.
        if (m_media == MEDIA_ELECSUB)
        {
            if (!ValidatePath())
            {
                // User did not enter a valid path (and didn't select create or
                // we couldn't create it).  Break out and continue running in
                // this step.
                m_pdlg->SetCurControl(IDC_DESTSOURCE_EDIT_SETDISKPATH);
                break;
            }

            // Grab the path from the appropriate control
            m_pdlg->GetControlText(IDC_DESTSOURCE_EDIT_SETDISKPATH, szDestPath, MAX_PATH);
        }
        else if (m_media == MEDIA_DISK)
        {
            // This code is *only* for testing purposes, so it can point at an arbitrary
            // fixed path (and not check for creation privileges or sufficent
            // disk space.
            HKEY hkey;
            sprintf(szDestPath, "C:\\test");

            // Allow override via regkey
            if ((RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              TEXT("SOFTWARE\\Microsoft\\XboxSDK\\xbPremaster"), 0,
                              KEY_READ, &hkey) == ERROR_SUCCESS))
            {
                DWORD dwSize = MAX_PATH;
                RegQueryValueEx(hkey, "RenderDest", NULL, NULL,
                                    (BYTE*)szDestPath, &dwSize);
                RegCloseKey(hkey);
            }

            CreateDirectory(szDestPath, NULL);
        }
        else // MEDIA_TAPE
        {
            // Grab the name of the tape drive from the combo box
            if (g_iDefaultTapeDrive == -1)
            {
                char szDrive[100];
                m_pdlg->GetComboSel(IDC_DESTSOURCE_COMBO_TAPEDRIVES, szDrive);
                sprintf(szDestPath, "\\\\.\\Tape%s", szDrive + 11);
            }
            else
                sprintf(szDestPath, "\\\\.\\Tape%d", g_iDefaultTapeDrive);
        }

        // Move on to the progress step.  szDestPath is ignored if the media is MEDIA_TAPE.
        pstepNext = new CStep_Progress(m_pdlg, m_source, m_media, szDestPath, szSourceFile);
        if (pstepNext == NULL)
            ReportError(ERROR_OUTOFMEM);

        m_pdlg->SetNextStep(pstepNext);
        break;

    case IDC_DESTSOURCE_BTN_FILEPATH:
        // User wants to open the common directory dialog to obtain the path.
        if (m_pdlg->GetFileNameCommon(TEXT("Select Filename"), "*.pkg", "PKG Files\0*.PKG\0", szDestPath, false) == true)
        {
            // user selected a path.  Copy it into our text control
            m_pdlg->SetControlText(IDC_DESTSOURCE_EDIT_SETDISKPATH, szDestPath);
        }
        break;

    case IDC_DESTSOURCE_RBTN_FLD:
        SetSource(SOURCE_FLD);
        break;

    case IDC_DESTSOURCE_RBTN_PACKAGE:
        SetSource(SOURCE_PACKAGE);
        break;

    case IDC_DESTSOURCE_BTN_FLDPATH:
        // User wants to open the common file dialog to obtain the file/pathname.
        if (m_pdlg->GetFileNameCommon(TEXT("Select FLD file"), "*.fld", "FLD Files\0*.FLD\0", szSourceFile, true) == true)
        {
            // user selected a file.  Copy it into our text control
            m_pdlg->SetControlText(IDC_DESTSOURCE_EDIT_SETFLDPATH, szSourceFile);
        }
        break;

    case IDC_DESTSOURCE_BTN_FLDPATH2:
        // User wants to open the common file dialog to obtain the file/pathname for the package
        if (m_pdlg->GetFileNameCommon(TEXT("Select Package file"), "*.pkg", "PKG Files\0*.PKG\0", szSourceFile, true) == true)
        {
            // user selected a file.  Copy it into our text control
            m_pdlg->SetControlText(IDC_DESTSOURCE_EDIT_SETFLDPATH2, szSourceFile);
        }
        break;

    case IDC_BTN_PREV:
        // user wants to go to previous step
        pstepNext = new CStep_UserAction(m_pdlg);
        if (pstepNext == NULL)
            ReportError(ERROR_OUTOFMEM);

        m_pdlg->SetNextStep(pstepNext);
        break;
        
    case IDC_DESTSOURCE_RBTN_TAPE:
        // User has selected the tape as the media.  Update the appropriate controls
        SetMedia(MEDIA_TAPE);
        break;

    case IDC_DESTSOURCE_RBTN_ELEC:
        // User has selected the electronic submission type.  Update the appropriate controls
        SetMedia(MEDIA_ELECSUB);
        break;

    case IDC_DESTSOURCE_RBTN_DISK:
        // User has selected the tape type.  Update the appropriate controls
        SetMedia(MEDIA_DISK);
        break;
    }
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  GetFSTandBINFromFLD
// Purpose:   Given a valid (existing) FLD file/pathname, generates the associated FST file/path
//            and gdfs.bin path strings.
// Arguments: 
// Return:    'true' if the necessary files exist alongside the FLD file.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool GetFSTandBINFromFLD(CDlg *pdlg, CStep *pstep, char *szFLDFilePathName, char *szFSTName, char *szBINName)
{
    char szProjName[MAX_PATH];
    char *pszSlash;
    DWORD dwStrLen;
    DWORD nRead;
    sFLDHeader fldhdr;
    
    // Open the file for READ-ONLY access.  The file must exist or we fail.
    HANDLE hFile = CreateFile(szFLDFilePathName, GENERIC_READ, 0, NULL,
                              OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
    if (hFile == INVALID_HANDLE_VALUE)
        return false;

    // Is it an old or new FLD file format?  We fail on old formats...
    if (!ReadFile(hFile, &fldhdr, sizeof fldhdr, &nRead, NULL) ||
        nRead != sizeof fldhdr)
    {
        CloseHandle(hFile);
        return false;
    }

    if (memcmp(fldhdr.szSig, FLD_SIG, FLD_SIG_SIZE))
    {
        // Not a new version FLD file.
        CloseHandle(hFile);
        return false;
    }

    if (!ReadFile(hFile, &dwStrLen, 4, &nRead, NULL) || nRead != 4)
    {
        CloseHandle(hFile);
        return false;
    }

    if (!ReadFile(hFile, szFSTName, dwStrLen, &nRead, NULL) || dwStrLen != nRead)
    {
        CloseHandle(hFile);
        return false;
    }
    CloseHandle(hFile);


    szFSTName[dwStrLen] = '\0';
   
    pszSlash = strrchr(szFSTName, '/');
    if (!pszSlash)
    {
        // Try forward slash
        pszSlash = strrchr(szFSTName, '\\');
        if (!pszSlash)
            return false;
    }
    strcpy(szProjName, pszSlash);
    strcat(szFSTName, "\\_amc");
    strcpy(szBINName, szFSTName);
    strcat(szFSTName, szProjName);
    strcat(szFSTName, ".fst");
    strcat(szBINName, "\\gdfs.bin");
    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStep_DestSource::ValidateFiles
// Purpose:   Validates the current path in the FLD text control is a valid path, and that the
//            necessary FLD file exists in the directory.  Also verifies that a like-named FST file
//            and gdfs.bin exist in the same path.  No validation is done on the actual files
//            (they are validated in the next CStep).
// Arguments: None
// Return:    'true' if the path is valid and the required files exist in the path.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CStep_DestSource::ValidateFiles()
{
    char szFLDName[MAX_PATH];
    char szFSTName[MAX_PATH];
    char szBINName[MAX_PATH];
    char szTemp[MAX_PATH + 100];
    bool fMissingFiles;
    
    // Get the path string from the FLD text control.
    m_pdlg->GetControlText(IDC_DESTSOURCE_EDIT_SETFLDPATH, szFLDName, MAX_PATH);

    // Verify the user specified a path
    if (!strcmp(szFLDName, ""))
    {
        MessageBox(m_pdlg->GetHwnd(), "Please specify a path for the source files",
                   "Path required", MB_ICONEXCLAMATION | MB_OK | MB_APPLMODAL);
        return false;
    }

    // Verify it's not a local path
    strcpy(szTemp, szFLDName);
    char *pszSlash = strtok(szTemp, "\\/");
    if (!pszSlash)
    {
        sprintf(szTemp, "Please specify the full pathname to the FLD file");
        MessageBox(m_pdlg->GetHwnd(), szTemp, "Local path not allowed", MB_ICONEXCLAMATION |
                   MB_OK | MB_APPLMODAL);
        return false;
    }

    // Verify the name of the file was also included (ie not just the dir)
    pszSlash = szFLDName + strlen(szFLDName) - 4;
    if (lstrcmpi(szFLDName + strlen(szFLDName) - 4, ".fld"))
    {
        sprintf(szTemp, "Please specify the filename of the FLD file, not just the path");
        MessageBox(m_pdlg->GetHwnd(), szTemp, "Filename not specified", MB_ICONEXCLAMATION |
                   MB_OK | MB_APPLMODAL);
        return false;
    }

    // Verify the path exists
    bool fExists = (GetFileAttributes(szFLDName) != 0xffffffff);

    // If the file doesn't exists then return failure
    if (!fExists)
    {
        sprintf(szTemp, "The FLD file '%s' does not exist.  Please specify an existing file.", szFLDName);
        MessageBox(m_pdlg->GetHwnd(), szTemp, "FLD file not found", MB_ICONEXCLAMATION | MB_OK |
                   MB_APPLMODAL);
        return false;
    }

    // If here, then the path exists and there's an FLD file in it.  Check if there's a like-named
    // FST file and 'gdfs.bin' there as well.
    if (!GetFSTandBINFromFLD(m_pdlg, this, szFLDName, szFSTName, szBINName))
        fMissingFiles = true;
    else
    {
        // The filenames were successfully generated - do the files actually exist?
        fMissingFiles = (GetFileAttributes(szFSTName) == 0xffffffff) ||
                        (GetFileAttributes(szBINName) == 0xffffffff);
    }

    if (fMissingFiles)
    {
        pszSlash = strrchr(szFSTName, '/');
        if (!pszSlash)
            pszSlash = strrchr(szFSTName, '\\');
        sprintf(szTemp, "'%s' is out of date.  Please rerun xbLayout and click 'Premaster' to update this file.",
                pszSlash + 1);
        MessageBox(m_pdlg->GetHwnd(), szTemp, "File out of date", MB_ICONEXCLAMATION |
                   MB_OK| MB_APPLMODAL);
        return false;
    }

    // Verify that the FLD and FST files are in sync
    if (!FLDAndFSTInSync(szFLDName, szFSTName))
    {
        MessageBox(m_pdlg->GetHwnd(), "The FLD is newer than the concordant"
                   " FST file.  Please run xbLayout and click 'Premaster' "
                   "to generate an new FST file.", "FST file not updated",
                   MB_ICONEXCLAMATION | MB_OK | MB_APPLMODAL);
        return false;
    }

    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStep_DestSource::FLDAndFSTInSync
// Purpose:   Return 'true' if the FST and BIN files are in sync.
// Arguments: None
// Return:    'true' if the FST and BIN are in sync
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CStep_DestSource::FLDAndFSTInSync(char *szFLDName, char *szFSTName)
{
    sFLDHeader fldhdr;
    bool   fInSync = false;
    time_t timeFST;
    DWORD  dwTimeStampLoc, dwRead;
    HANDLE hfileFST = NULL, hfileFLD = NULL;

    // Compare the 'FLD last saved' timestamps stored in the FLD and FST.
    // 1. If FLD is old-version FLD, then force rebuild
    // 2. If timestamps are different, then force rebuild
    // 3. If either file can't be found, then force rebuild
   
    // Load the two files.
    hfileFLD = CreateFile(szFLDName, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                 FILE_ATTRIBUTE_NORMAL, 0);
    hfileFST = CreateFile(szFSTName, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL, 0);
    if (hfileFLD == INVALID_HANDLE_VALUE)
        goto done;
    if (hfileFST == INVALID_HANDLE_VALUE)
        goto done;

    // Get the FLD signature
    if ((!ReadFile(hfileFLD, &fldhdr, sizeof fldhdr, &dwRead, 0) ||
        dwRead != sizeof fldhdr))
        goto done;
    
    // Verify it's a newer FLD file; if it's an older one, then force rebuild
    if (memcmp(fldhdr.szSig, FLD_SIG, FLD_SIG_SIZE))
        goto done;
    
    // Get the FST timestamp
    dwTimeStampLoc = sizeof(TFileHeader) + sizeof(TMediaHeader) + 2;
    SetFilePointer(hfileFST, dwTimeStampLoc, NULL, FILE_BEGIN);
    if ((!ReadFile(hfileFST, &timeFST, sizeof timeFST, &dwRead, 0) ||
        dwRead != sizeof timeFST))
        goto done;

    // If times are different, we're not in sync
    fInSync = (fldhdr.timeSaved == timeFST);

done:

    if (hfileFLD)
        CloseHandle(hfileFLD);
    if (hfileFST)
        CloseHandle(hfileFST);
    
    return fInSync;        
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStep_DestSource::ValidatePath
// Purpose:   Validates the current path in the path text control.  If the path doesn't exist, then
//            queries the user if they would like for it to be created automatically.
// Arguments: None
// Return:    'true' if the path is valid after processing.  If the user selected to not create the
//            path, or an error occurred during path creation, then 'false'.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CStep_DestSource::ValidatePath()
{
    char szPath[MAX_PATH], szFilePath[MAX_PATH];
    char szNew[MAX_PATH];
    char szTemp[MAX_PATH + 100];

    // Get the path string from the text control.
    if (m_pdlg->GetControlText(IDC_DESTSOURCE_EDIT_SETDISKPATH, szFilePath, MAX_PATH) != S_OK)
    {
        // An unexpected error has occurred.  Report fatal error and exit.
        ReportError(ERROR_UNEXPECTED);
    }
    
    // Separate the path alone (ie ignore the filename for now) since that's
    // what we want to verify/create if necessary
    strcpy(szPath, szFilePath);
    char *pszSlash = strrchr(szPath, '/');
    if (!pszSlash)
    {
        pszSlash = strrchr(szPath, '\\');
        if (!pszSlash)
        {
            // Totally invalid filename
            MessageBox(m_pdlg->GetHwnd(), "You need to specify a full destination path (including drive letter).  Please check "\
                       "the path and try again.", "Invalid destination path specified",
                       MB_ICONEXCLAMATION | MB_OK | MB_APPLMODAL);
            return false;
        }
    }
    if (pszSlash == szPath + 2)
        *(pszSlash + 1) = '\0';
    else
        *pszSlash = '\0';

    // First, check if the string is a properly formed directory (regardless of if the directory
    // doesn't exist).  A properly formed dir must begin with '*:\"
    if (szPath[1] != ':' || szPath[2] != '\\')
    {
        // User forgot the drive letter (ie "\foo\bar") or something
        // completely random.  Don't allow it.
        MessageBox(m_pdlg->GetHwnd(), "You need to specify a full destination path (including drive letter).  Please check "\
                   "the path and try again.", "Invalid destination path specified",
                   MB_ICONEXCLAMATION | MB_OK | MB_APPLMODAL);
        return false;
    }

    // Did the user specify a PKG file extension?
    if (lstrcmpi(szFilePath + strlen(szFilePath) - 4, ".pkg"))
    {
        MessageBox(m_pdlg->GetHwnd(), "You need to specify a filename ending in '.pkg'.  Please check "\
                   "the path/file and try again.", "Invalid package filename specified",
                   MB_ICONEXCLAMATION | MB_OK | MB_APPLMODAL);
        return false;
    }

    // Does the path exist?
    DWORD dwAttr = GetFileAttributes(szPath);
    bool fExists = (dwAttr != 0xffffffff);

    // If the path exists, then the great - get out of here!
    if (fExists)
        return true;
    
    // If here, then the directory doesn't exist. Query the user if they would
    // like the path to be created.
    sprintf(szTemp, "The directory '%s' does not exist.  Would you like for it to be created?", szPath);
    if (MessageBox(m_pdlg->GetHwnd(), szTemp, "Create Directory?", MB_ICONQUESTION | MB_YESNO | MB_APPLMODAL) == IDNO)
        return false;

    // The user wants the directory to be created.  We may need to create parent directories as
    // well.  Walk up the string, creating the directories as we go.

    // szNew will contain the full path to the current depth, while szCur will contain the name of
    // just the current directory; it will get repeatedly appended onto szNew to iteratively create
    // the entire directory chain.

    char *szCur = strtok(szPath, "\\/");

    // Start out with just the drive name (ie "C:") in szNew.
    strcpy(szNew, szCur);

    // Skip once to get past the drive letter -- we don't need to create "C:\" for instance.
    szCur = strtok(NULL, "\\/");

    // Loop until we've reached the end of the directory string.
    while (szCur)
    {
        // Append the current directory onto the full-path string.
        strcat(szNew, "\\");
        strcat(szNew, szCur);
        
        // Try to create the full path to the current depth.
        if (CreateDirectory(szNew, NULL) == false)
        {
            switch (GetLastError())
            {
            case ERROR_ALREADY_EXISTS:
                // Ignore - just means that the current path already exists.
                break;
            
            case ERROR_ACCESS_DENIED:
                // We can't write to the specified destination (ie user pointed at read-only media)
                // fall through...

            case ERROR_PATH_NOT_FOUND:
                // User specified a drive that isn't mapped
                MessageBox(m_pdlg->GetHwnd(), "The specified directory cannot be created.  Please"\
                           " specify a different path", "Cannot create directory",
                           MB_ICONEXCLAMATION | MB_OK | MB_APPLMODAL);
                return false;
            }
        }
        
        // Get the name of the next-depth directory.
        szCur = strtok(NULL, "\\/");
    }
    
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xbpremaster\ifld.h ===
/* IFld.h -*- C++ -*- */

//******************************************************************************
//
// COPYRIGHT (C) 2000 APPLIED MICROSYSTEMS CORPORATION.  ALL RIGHTS RESERVED.
// UNPUBLISHED -- RIGHTS RESERVED UNDER THE COPYRIGHT LAWS OF THE UNITED
// STATES.  USE OF A COPYRIGHT NOTICE IS PRECAUTIONARY ONLY AND DOES NOT
// IMPLY PUBLICATION OR DISCLOSURE.
//
// THIS SOFTWARE CONTAINS CONFIDENTIAL INFORMATION AND TRADE SECRETS OF
// APPLIED MICROSYSTEMS CORPORATION.  USE, DISCLOSURE, OR REPRODUCTION IS
// PROHIBITED WITHOUT THE PRIOR EXPRESS WRITTEN PERMISSION OF APPLIED
// MICROSYSTEMS CORPORATION.
//
//                 RESTRICTED RIGHTS LEGEND
//
// Use, duplication, or disclosure by the Government is subject to
// restrictions as set forth in subparagraph (c)(1)(ii) of the Rights
// in Technical Data and Computer Software clause at DFARS 252.227-7013
// or subparagraphs (c)(1) and (2) of Commercial Computer Software --
// Restricted Rights at 48 CFR 52.227-19, as applicable.
//
// Applied Microsystems Corporation
// 5020 148th Ave NE
// Redmond, WA 98052
//
//******************************************************************************
//
// Contents:
//
//      Interface to access the FLD files.
//
// Main authors:
//
//      03/14/01,pwl - initial version
//
// Target restrictions:
//
//      Identify target builds not supported by this header file.
//
// Tool restrictions:
//
//      Identify build tool limitations for this header file.
//
// Things to do:
//
//      Identify must-do, should-do, and wish-list items.
//
//******************************************************************************

#ifndef IFLD_H
#define IFLD_H

#if defined(_MSC_VER) && (_MSC_VER > 1000)
#pragma once
#endif

#if defined (WIN32)
#pragma warning (disable : 4251) // X needs to have dll-interface to be used by client
#endif  // WIN32

// Uses other components
class IDiscLayout;  // from "IDiscLayout.h"

// Uses windows libraries
#include <windows.h>

// Uses standard libraries
#include <wchar.h>
#include <string>

#ifdef _MSC_VER
#ifdef LAYOUTENGINE_EXPORTS
#define LAYOUTENGINE_API __declspec(dllexport)
#else
#define LAYOUTENGINE_API __declspec(dllimport)
#endif
#else
#define LAYOUTENGINE_API
#endif

class CFldImpl;

/* ********************************************************** */
class LAYOUTENGINE_API IFld 
{
// --- public interface
public:
    typedef unsigned long tNodeIdx;

    friend class CFldImpl;

    enum EMaxErrorLength
    {
        MAX_LENGTH = 255
    };

    // Create, Open and Close a File Layout Descriptor file 
    // (new binary format only)
    bool IsFileReadOnly( const TCHAR * fname );
    bool CreateFld( const char* fname );
    bool CreateFld( const wchar_t* fname );
    bool OpenFld( const char* fname, bool bReadOnly=true );
    bool OpenFld( const wchar_t* fname, bool bReadOnly=true );
    void CloseFld();

    // Save and Load of disc layout specified by IDiscLayout
    bool SaveDiscLayout( const IDiscLayout& discLayout );
    bool LoadDiscLayout( IDiscLayout& discLayout );

    // General information
    bool GetVolName( const char** name );
    bool GetVolSetName( const char** name );
    bool SetVolName( const char* name );
    bool SetVolSetName( const char* name );
    bool GetVolName( const wchar_t** name );
    bool GetVolSetName( const wchar_t** name );
    bool SetVolName( const wchar_t* name );
    bool SetVolSetName( const wchar_t* name );

    // Error Handling
    const wchar_t * const GetLastErrorString( void )
    {
        return m_wszErrorMessage.c_str();
    }

    // file tree API
    tNodeIdx GetNumElem();
    tNodeIdx GetRootDir();
    tNodeIdx GetParentDir( tNodeIdx idx );
    tNodeIdx GetFirstElemInDir( tNodeIdx idx );
    tNodeIdx GetNextSiblingElem( tNodeIdx idx );
    
    // node info API - the life time of the retrun
    // strings are only between calls to another
    // call that returns strings.
    bool GetName( tNodeIdx idx, const char** name );
    bool GetName( tNodeIdx idx, const wchar_t** name );
    bool GetPath( tNodeIdx idx, const char** name );
    bool GetPath( tNodeIdx idx, const wchar_t** name );
    bool GetSrcPath( tNodeIdx idx, const char** name );
    bool GetSrcPath( tNodeIdx idx, const wchar_t** name );
    bool GetSize(    tNodeIdx idx,   unsigned long& size );
    bool GetLayer(   tNodeIdx idx,   unsigned int&  layer );
    bool GetBlockSize( tNodeIdx idx, unsigned long& blocks );
    bool GetStartLsn(  tNodeIdx idx, unsigned long& lsn );
    bool SetLayer(     tNodeIdx idx, unsigned int   layer );
    bool SetBlockSize( tNodeIdx idx, unsigned long  blocks );
    bool SetStartLsn(  tNodeIdx idx, unsigned long  lsn );
    bool IsDirectory(   tNodeIdx idx );
    bool IsFile(   tNodeIdx idx );
    bool IsPlaceHolder( tNodeIdx idx );
    bool IsXbe( tNodeIdx idx );
    bool IsEmpty( tNodeIdx idx );

    // Data blocks API
    unsigned long GetNumDataBlock();
    tNodeIdx GetDataBlockIndex( int placement );

// --- class specfic
public: IFld();
public: ~IFld();
// compiler generated...
private: IFld(const IFld& rhs); 
private: IFld& operator=(const IFld& rhs);
private: IFld* operator&();
private: const IFld* operator&() const;
    
// --- private data members
private:
    CFldImpl *mImpl;


// --- Private methods
private:
    void SetFileErrorMessage( DWORD nMessageId, bool bPrintStrerror = false );
    void SetNoArgErrorMessage( DWORD nMessageId );

    // For error messages only!!   
    std::wstring m_wszErrorMessage;
    std::wstring m_wszFileName;
};


#endif // IFLD_H
/* **************************** End of File ******************************* */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xbpremaster\CStep_Progress.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CStep_Progress.cpp
// Contents:  The 'meat' of xbPremaster.  Displays a constantly updating progress bar as it
//            performs the requested action.
// Revisions: 31-May-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"
#include <time.h>


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStep_Progress::CStep_Progress
// Purpose:   CStep_Progress constructor.
// Arguments: pdlg          -- The dialog in which the step will appear.
//            source        -- The source from which the files originate.
//            media         -- The media the action was performed on (tape, disk)
//            szPath        -- The location in which files were created.  Ignored if media == tape.
//            szSourceFile     -- The location of the source file.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CStep_Progress::CStep_Progress(CDlg *pdlg, eSource source, eMedia media, 
                               char szDestPath[MAX_PATH], char szSourceFile[MAX_PATH]) : CStep(pdlg)
{
    // Track the media and action that the user had previously selected.
    m_media  = media;
    m_source = source;

    // Start out in 'noncancelled' state.
    m_fCancelled = false;

    // Track the destination path that the action is being performed in.
    if (m_media == MEDIA_ELECSUB || m_media == MEDIA_DISK)
        strcpy(m_szDestPath, szDestPath);

    // Track the Source filepath and name
    strcpy(m_szSourceFile, szSourceFile);

    // Make all of our controls visible
    m_pdlg->DisplayControl(IDC_PROGRESS_STATIC);
    m_pdlg->DisplayControl(IDC_PROGRESS_BADXBE);
    m_pdlg->SetControlFont(IDC_PROGRESS_BADXBE, -18, "Arial", 0);
    m_pdlg->SetControlText(IDC_PROGRESS_BADXBE, "");

    m_pdlg->DisplayControl(IDC_PROGRESS_TEXT_TITLE);
    m_pdlg->DisplayControl(IDC_PROGRESS_STATIC2);
    m_pdlg->DisplayControl(IDC_PROGRESS_PROGRESSBAR);
    m_pdlg->DisplayControl(IDC_PROGRESS_TEXT_PROGRESS);
    m_pdlg->DisplayControl(IDC_BTN_PREV);
    m_pdlg->DisplayControl(IDC_BTN_NEXT);
    m_pdlg->DisplayControl(IDC_BTN_EXIT);
    m_pdlg->DisplayControl(IDC_PROGRESS_STATIC3);
    m_pdlg->DisplayControl(IDC_PROGRESS_STATIC4);
    m_pdlg->SetControlEnable(IDC_BTN_PREV, false);
    m_pdlg->SetControlEnable(IDC_BTN_NEXT, false);

    // Set the cancel button as the default control
    m_pdlg->SetCurControl(IDC_BTN_EXIT);

    // Overload the background colors of some controls to white
    m_pdlg->OverloadBkColor(IDC_PROGRESS_TEXT_TITLE);

    if (m_media != MEDIA_ELECSUB)
    {
        // Set the default range and position of the progress bar (this will
        // be set elsewhere for the 'elecsub' case)
        m_pdlg->SetProgressRange(IDC_PROGRESS_PROGRESSBAR, 0, NUM_XDATA_SECTORS * 2);
        m_pdlg->SetProgressPos(IDC_PROGRESS_PROGRESSBAR, 0);
    }

    if (m_media == MEDIA_TAPE)
    {
        // Mount the tape drive for writing
mount:
        SetCursor(LoadCursor(NULL, IDC_WAIT));
        if (!m_td.FMount(szDestPath, true))
        {
            // Failed to mount the volume.  Either there is no tape in the drive,
            // or there is a bad tape.  Warn the user and let them insert a new
            // tape.
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            if (MessageBox(m_pdlg->GetHwnd(), "There does not appear to be a " \
                           "valid tape in the drive.\nPlease insert a tape and " \
                           "press 'Ok' to continue.", "Invalid or Missing Tape",
                           MB_ICONQUESTION | MB_OKCANCEL| MB_APPLMODAL) == IDOK)
            {
                // User wants to try again.
                m_td.FUnmount();
                goto mount;
            }
            else
            {
                // User wants to cancel
                m_fCancelled = true;
                return;
            }
        }
        
        /* Make sure the XML file will get padded with whitespace when we
         * write it */
        m_td.SetWritePadByte('\n');
        SetCursor(LoadCursor(NULL, IDC_ARROW));
    }

    // Set the random number generator
    srand(time(NULL));
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStep_Progress::CheckCancelled
// Purpose:   Handle any pending windows messages.  If the user presses the 'cancel' button, then
//            it will get handled elsewhere; by the time we exit the PeekMessage loop, the
//            'm_fCancelled' variable will be set appropraite.
// Arguments: None
// Return:    'true' if the step should exit; 'false' if the step should continue
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CStep_Progress::CheckCancelled()
{
    MSG msg;
    
    // Check if there are any windows message waiting that need to be handled
    while (PeekMessage(&msg, NULL, 0,0, PM_REMOVE))
    {
        if (msg.message == WM_QUIT)
            return true;

        if (!IsDialogMessage(m_pdlg->GetHwnd(), &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    // If the user clicked 'cancel', then the HandleButtonPress function already set m_fCancelled
    // appropriately.
    return m_fCancelled;
}

// Recursively delete a directory and all of it's subdirectories
void RecursiveRemoveDirectory(char *szFolder)
{
    if (SetCurrentDirectory(szFolder))
    {
        WIN32_FIND_DATA wfd;
        HANDLE hfile = FindFirstFile("*.*", &wfd);
        while (hfile != INVALID_HANDLE_VALUE)
        {
            char *szFile = wfd.cFileName;
            if (strcmp(szFile, ".") && strcmp(szFile, ".."))
            {
                // It's neither '.' nor '..' - remove it!
                // if it's a file, delete it; if it's a directory, then recurse down into it
                if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    RecursiveRemoveDirectory(szFile);
                else
                    DeleteFile(szFile);
            }

            if (!FindNextFile(hfile, &wfd))
                break;
        }
        FindClose(hfile);

        // Set our current directory back to the original directory so that we can remove 'this' directory
        SetCurrentDirectory("..");

        // Finally, remove the directory itself
        RemoveDirectory(szFolder);
    }
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStep_Progress::DoModal
// Purpose:   CSteps that want to perform a block of contiguous functionality should create a modal
//            step that handles message loops (to allow cancellation, etc).  To do this, they
//            override the DoModal function.  In this case, the function calls directly into the
//            appropriate function for handling of data (writing, verifying, etc).
// Arguments: None.
// Return:    'true' to specify that the step has overridden the 'DoModal' function.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CStep_Progress::DoModal()
{
    // If we're reading from a package file, then extract the files first
    if (m_source == SOURCE_PACKAGE)
    {
        m_pdlg->SetControlText(IDC_PROGRESS_TEXT_PROGRESS, "Progress (extraction):");
        ExtractPackagedFiles(m_szSourceFile);
        
        // m_szSourceFile now contains the path to the source FLD file.

        if (!m_fCancelled)
        {
            m_pdlg->SetControlText(IDC_PROGRESS_TEXT_PROGRESS, "Progress (media creation):");

            // Get the DVD root from the source FLD file; we'll need it to
            // convert the addresses in the FST file to our temporary directory
            CFLD fld(m_pdlg, this, m_szSourceFile);
            strcpy(m_szPackageDVDRoot, fld.m_szDVDRoot);
        }
    }

    if (!m_fCancelled)
    {
        // After extracting the packaged files, we need to update the progress range
        // for actual creation of the data.
        m_pdlg->SetProgressRange(IDC_PROGRESS_PROGRESSBAR, 0, NUM_XDATA_SECTORS * 2);

        // Do the actual work of writing the files out.  Note: by the time WriteFiles returns, the next
        // step has already been created...
        WriteFiles();
    }
    
    if (m_source == SOURCE_PACKAGE)
    {
        // Only delete the temporary directory if the 'rendertodisk' key is not present
        HKEY hkey;
        if ((RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          TEXT("SOFTWARE\\Microsoft\\XboxSDK\\xbPremaster"), 0,
                          KEY_READ, &hkey) == ERROR_SUCCESS))
        {
            if (RegQueryValueEx(hkey, "RenderToDisk", NULL, NULL, NULL, NULL)
                            != ERROR_SUCCESS)
            {
                // Delete the temporary directory that we created
                if (m_szPackageExtractFolder[0] != '\0')
                    RecursiveRemoveDirectory(m_szPackageExtractFolder);
            }
            RegCloseKey(hkey);
        }
    }

    // At this point, this step has completed.  We could do cleanup here, but there is none needed.
    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStep_Progress::HandleButtonPress
// Purpose:   This function is called when the user presses a button.
// Arguments: nButtonId         -- the resource identifier of the button pressed.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CStep_Progress::HandleButtonPress(int nButtonId)
{
    switch (nButtonId)
    {
    case IDC_BTN_EXIT:
    case ID_ESCAPE_KEY:
        // User wants to cancel the current operation.  Pop up the verification dialog to ensure
        // that the user actually wants to cancel.
        if (!m_fCancelled)
        {
            if (MessageBox(m_pdlg->GetHwnd(), "Are you sure you want to cancel the operation?",
                           "Cancel operation?", MB_ICONQUESTION | MB_YESNO | MB_APPLMODAL) == IDYES)
            {
                // Yep, user wants to cancel the operation.  Set m_fCancelled = true so that the
                // DoModal function can tell that it should exit.
                m_fCancelled = true;
            }
        }
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xbpremaster\CXmlNode.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CXmlNode.h
// Contents:  Simple XML generation class
// Revisions: 4-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ DEFINES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// MAX_XML_ATTRIBUTES       -- Maximum number of attributes in an XML node.
#define MAX_XML_ATTRIBUTES 10


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ CLASSES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Forward Class declarations
class CFile;

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class:   CXmlNode
// Purpose: A single node in an XML tree.  Can be root, middle, or leaf node.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class CXmlNode
{
public:

    // ++++ CONSTRUCTION-RELATED FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    
    // CXmlNode     -- CXmlNode Constructor
    CXmlNode(char *szName);

    // ~CXmlNode    -- CXmlNode Destructor
    ~CXmlNode();


    // ++++ MISCELLANEOUS FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    // AddElement   -- Creates a new CXmlNode and adds it to our list of child ndoes
    CXmlNode *AddElement(char *szName);

    // AddAttr      -- Adds a new attribute to this node
    void AddAttr(char *szName, char *szValue);

    // WriteToFile  -- Dumps this node's XML tree to the specified file in human-readable format.
    HRESULT WriteToFile(CDlg *pdlg, CFile *poutfile, int nDepth);


private:

    // m_rgpxnChildren  -- The list this node's of child nodes.
    CXmlNode **m_rgpxnChildren;

    // m_cpxnAlloc      -- The maximum size of the m_rgpxnChildren array
    int m_cpxnAlloc;

    // m_cChildren      -- The number of child nodes.
    int m_cChildren;

    // m_rgszAttrName   -- The list of attribute names.
    char m_rgszAttrName[MAX_XML_ATTRIBUTES][100];

    // m_rgszAttrValue  -- The list of attribute values.
    char m_rgszAttrValue[MAX_XML_ATTRIBUTES][100];

    // m_cAttrs         -- The number of attributes this node has
    int m_cAttrs;

    // m_szName         -- This node's name
    char m_szName[100];
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xbpremaster\CStep_UserAction.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      cstep_useraction.cpp
// Contents:  The first step in the xbPremaster process.  Allows the user to select the basic
//            action to be performed in this session.
// Revisions: 31-May-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStep_UserAction::CStep_UserAction
// Purpose:   CStep_UserAction constructor.
// Arguments: pdlg          -- Dialog that this step will be displayed in.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CStep_UserAction::CStep_UserAction(CDlg *pdlg) : CStep(pdlg)
{
    // Make all of our controls visible
    m_pdlg->DisplayControl(IDC_USERACTION_STATIC2);
    m_pdlg->DisplayControl(IDC_USERACTION_TEXT_TITLE);
    m_pdlg->DisplayControl(IDC_USERACTION_TEXT_BODY);
    m_pdlg->DisplayControl(IDC_BTN_PREV);
    m_pdlg->DisplayControl(IDC_BTN_NEXT);
    m_pdlg->DisplayControl(IDC_BTN_EXIT);
    m_pdlg->DisplayControl(IDC_USERACTION_STATIC);
    m_pdlg->DisplayControl(IDC_USERACTION_STATIC3);
    m_pdlg->SetControlEnable(IDC_BTN_PREV, false);
    m_pdlg->SetControlEnable(IDC_BTN_NEXT, true);

    // Set the font for the text title
    m_pdlg->SetControlFont(IDC_USERACTION_TEXT_TITLE, -18, "Arial", 0);

    // Overload the background colors of some controls to white
    m_pdlg->OverloadBkColor(IDC_USERACTION_TEXT_TITLE);
    m_pdlg->OverloadBkColor(IDC_USERACTION_TEXT_BODY);
    
    // Set the Write button as the default control
    m_pdlg->SetCurControl(IDC_BTN_NEXT);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStep_UserAction::HandleButtonPress
// Purpose:   This function is called when the user presses a button.
// Arguments: nButtonId         -- the resource identifier of the button pressed.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CStep_UserAction::HandleButtonPress(int nButtonId)
{
    CStep *pstepNext;
    
    switch (nButtonId)
    {
    case IDC_BTN_NEXT:
        // User wants to write the files out.
        pstepNext = new CStep_DestSource(m_pdlg);
        m_pdlg->SetNextStep(pstepNext);
        break;

    case IDC_BTN_EXIT:
    case ID_ESCAPE_KEY:
        // User wants to exit the application.  Inform the dialog that there is no 'next' step.
        m_pdlg->SetNextStep(NULL);
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xbpremaster\CXml.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      CXml.cpp
// Contents:  Simple XML generation class.
// Revisions: 4-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ EXTERNAL VARIABLE DECLARATIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// g_fOutOfMemory   -- Set if the application runs out of allocatable memory.  Caught by caller.
extern bool g_fOutOfMemory;


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXmlNode::CXmlNode
// Purpose:   Constructor for a node in an xml tree.
// Arguments: szName        -- Name of the node
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CXmlNode::CXmlNode(char *szName)
{
    strcpy(m_szName, szName);
    m_rgpxnChildren = NULL;
    m_cpxnAlloc = 0;
    m_cChildren = 0;
    m_cAttrs = 0;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXmlNode::~CXmlNode
// Purpose:   Destructor for CXmlNode.  Frees it's allocated children (recursively).
// Arguments: None
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CXmlNode::~CXmlNode()
{
    // Free up all of our child nodes
    for (int i = 0; i < m_cChildren; i++)
        delete m_rgpxnChildren[i];
    free(m_rgpxnChildren);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXmlNode::AddElement
// Purpose:   Creates a new node with the specified name and adds it to our list of child nodes
// Arguments: szName            -- name of the newly created node
// Return:    A pointer to the newly created node.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CXmlNode *CXmlNode::AddElement(char *szName)
{
    /* Make sure we have room for another node */
    if(m_cChildren == m_cpxnAlloc) {
        CXmlNode **rgpxnOld = m_rgpxnChildren;
        m_rgpxnChildren = (CXmlNode **)malloc((m_cpxnAlloc += 100) *
            sizeof(CXmlNode *));
        if(rgpxnOld) {
            memcpy(m_rgpxnChildren, rgpxnOld, m_cChildren * sizeof(CXmlNode *));
            free(rgpxnOld);
        }
    }

    // Create the new node and add it to our list of children
    CXmlNode *pxmlNew = new CXmlNode(szName);
    if (pxmlNew == NULL)
    {
        // We're out of memory.  Mark that that is what happened, and throw an exception (which
        // will be caught by the caller)
        g_fOutOfMemory = true;
        throw;
    }

    m_rgpxnChildren[m_cChildren++] = pxmlNew;

    // Return a pointer to the newly created node
    return pxmlNew;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXmlNode::AddAttr
// Purpose:   Adds a new attribute to this node
// Arguments: szName            -- Name of the attribute to add
//            szValue           -- Value of the newly added attribute
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CXmlNode::AddAttr(char *szName, char *szValue)
{
    // This very simple XML tree object only supports a fixed number of attributes per node.  This
    // is to avoid the hassle of generating and freeing up linked lists.  The same is done for
    // child nodes above.  While a linked list would be minimal effort to add, it's not worth the
    // potential for added bugs when we know we'll never need it.
    assert (m_cAttrs < MAX_XML_ATTRIBUTES);

    // Track the attribute's name and value.
    strcpy(m_rgszAttrName[m_cAttrs], szName);
    strcpy(m_rgszAttrValue[m_cAttrs], szValue);
    m_cAttrs++;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CXmlNode::WriteToFile
// Purpose:   Recursively dump this XmlNode's structure to the specified file.
// Arguments: pdlg              -- Dialog that will handle error I/O
//            poutfile          -- File to dump to.
//            nDepth            -- Depth of the tree; used for indenting (ease of reading)
// Return:    
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CXmlNode::WriteToFile(CDlg *pdlg, CFile *poutfile, int nDepth)
{
    char sz[1024], szIndent[100], sz2[1024];
    HRESULT hr;

    // Create the indentation string.  Included just for ease of reading the generated XML file.
    memset(szIndent, ' ', nDepth * 4);
    szIndent[nDepth * 4] = '\0';

    // Output this node's tag.  Special case the schema.
    if (nDepth == 0)
        sprintf(sz, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n%s<%s", szIndent, m_szName);
    else
        sprintf(sz, "%s<%s", szIndent, m_szName);

    // Output this node's attributes.
    for (int i = 0; i < m_cAttrs; i++)
    {
        sprintf(sz2, " %s=\"%s\"", m_rgszAttrName[i], m_rgszAttrValue[i]);
        strcat(sz, sz2);
    }

    // Close off this node's attributes
    if (m_cChildren == 0)
        strcat(sz, "/");
    strcat(sz, ">\r\n");

    // Dump this node's contents to the file, and then each of it's children
    hr = poutfile->Write((BYTE*)sz, strlen(sz));
    if (hr != S_OK)
    {
        poutfile->InformError(pdlg->GetHwnd(), hr, poutfile->GetFilename());
        return hr;
    }

    // Iterate over each child
    for (i = 0; i < m_cChildren; i++)
    {
        hr = m_rgpxnChildren[i]->WriteToFile(pdlg, poutfile, nDepth + 1);
        if (hr != S_OK)
        {
            // The child's function already called InformError, so just exit
            return hr;
        }
    }

    // If there were any children, then we need to close off the tag.
    if (m_cChildren)
    {
        // Dump the closing tag (ie "</REGION>")
        sprintf(sz, "%s</%s>\r\n", szIndent, m_szName);
        poutfile->Write((BYTE*)sz, strlen(sz));
        if (hr != S_OK)
        {
            poutfile->InformError(pdlg->GetHwnd(), hr, poutfile->GetFilename());
            return hr;
        }
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xbpremaster\lzss.h ===
#pragma once

#define N		 4096	// size of ring buffer
#define F		   18	// upper limit for match_length
#define THRESHOLD	2   // encode string into position and length if match_length is greater than this
#define NIL			N	// index for root of binary search trees
#define SPACE	' '


class CLZSS
{
public:
	CLZSS();

	virtual int ReadByte() = 0; // return EOF (-1) at end
	virtual void WriteByte(BYTE b) = 0;

	void Decode();

#ifndef _LZSS_NO_ENCODER
	void Encode();
#endif

private:
	BYTE text_buf [N + F - 1];

#ifndef _LZSS_NO_ENCODER
	void InitTree();
	void InsertNode(int r);
	void DeleteNode(int p);

	UINT textsize;
	UINT codesize;

	int match_position;
	int match_length;

	int lson [N + 1];
	int rson [N + 257];
	int dad [N + 1];
#endif
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xbpremaster\lzss.cpp ===
#include <stdafx.h>
#include "lzss.h"

/*
This scheme is initiated by Ziv and Lempel [1].  A slightly modified
version is described by Storer and Szymanski [2].  An implementation
using a binary tree is proposed by Bell [3].  The algorithm is quite
simple: Keep a ring buffer, which initially contains "space" characters
only.  Read several letters from the file to the buffer.  Then search
the buffer for the longest string that matches the letters just read,
and send its length and position in the buffer.

If the buffer size is 4096 bytes, the position can be encoded in 12
bits.  If we represent the match length in four bits, the <position,
length> pair is two bytes long.  If the longest match is no more than
two characters, then we send just one character without encoding, and
restart the process with the next letter.  We must send one extra bit
each time to tell the decoder whether we are sending a <position,
length> pair or an unencoded character.
*/

CLZSS::CLZSS()
{
	textsize = 0;
	codesize = 0;
}

#ifndef _LZSS_NO_ENCODER
void CLZSS::InitTree()
{
	// For i = 0 to N - 1, rson[i] and lson[i] will be the right and
	// left children of node i.  These nodes need not be initialized.
	// Also, dad[i] is the parent of node i.  These are initialized to
	// NIL (= N), which stands for 'not used.'
	// For i = 0 to 255, rson[N + i + 1] is the root of the tree
	// for strings that begin with character i.  These are initialized
	// to NIL.  Note there are 256 trees.

	int  i;

	for (i = N + 1; i <= N + 256; i += 1)
		rson[i] = NIL;

	for (i = 0; i < N; i += 1)
		dad[i] = NIL;
}

void CLZSS::InsertNode(int r)
{
	// Inserts string of length F, text_buf[r..r+F-1], into one of the
	// trees (text_buf[r]'th tree) and returns the longest-match position
	// and length via the global variables match_position and match_length.
	// If match_length = F, then removes the old node in favor of the new
	// one, because the old one will be deleted sooner.
	// Note r plays double role, as tree node and position in buffer.

	int i, p, cmp;
	BYTE* key;

	cmp = 1;
	key = &text_buf[r];
	p = N + 1 + key[0];
	rson[r] = lson[r] = NIL;
	match_length = 0;

	for (;;)
	{
		if (cmp >= 0)
		{
			if (rson[p] != NIL)
			{
				p = rson[p];
			}
			else
			{
				rson[p] = r;
				dad[r] = p;
				return;
			}
		}
		else
		{
			if (lson[p] != NIL)
			{
				p = lson[p];
			}
			else
			{
				lson[p] = r;
				dad[r] = p;
				return;
			}
		}

		for (i = 1; i < F; i++)
		{
			cmp = key[i] - text_buf[p + i];
			if (cmp != 0)
				break;
		}
		
		if (i > match_length)
		{
			match_position = p;
			if ((match_length = i) >= F)
				break;
		}
	}

	dad[r] = dad[p];
	lson[r] = lson[p];
	rson[r] = rson[p];
	dad[lson[p]] = r;
	dad[rson[p]] = r;

	if (rson[dad[p]] == p)
		rson[dad[p]] = r;
	else
		lson[dad[p]] = r;

	dad[p] = NIL;
}

void CLZSS::DeleteNode(int p)
{
	int  q;
	
	if (dad[p] == NIL)
		return;

	if (rson[p] == NIL)
	{
		q = lson[p];
	}
	else if (lson[p] == NIL)
	{
		q = rson[p];
	}
	else
	{
		q = lson[p];
		if (rson[q] != NIL)
		{
			do
			{
				q = rson[q];
			}
			while (rson[q] != NIL);

			rson[dad[q]] = lson[q];
			dad[lson[q]] = dad[q];
			lson[q] = lson[p];
			dad[lson[p]] = q;
		}

		rson[q] = rson[p];
		dad[rson[p]] = q;
	}

	dad[q] = dad[p];
	if (rson[dad[p]] == p)
		rson[dad[p]] = q;
	else
		lson[dad[p]] = q;
	dad[p] = NIL;
}

void CLZSS::Encode()
{
	int i, c, len, r, s, last_match_length, code_buf_ptr;
	BYTE code_buf [17], mask;
	
	InitTree();  /* initialize trees */
	code_buf[0] = 0;  /* code_buf[1..16] saves eight units of code, and
		code_buf[0] works as eight flags, "1" representing that the unit
		is an unencoded letter (1 byte), "0" a position-and-length pair
		(2 bytes).  Thus, eight units require at most 16 bytes of code. */
	code_buf_ptr = mask = 1;
	s = 0;
	r = N - F;
	for (i = s; i < r; i += 1)
		text_buf[i] = SPACE;  // Clear the buffer with any character that will appear often.
	for (len = 0; len < F && (c = ReadByte()) != -1; len += 1)
		text_buf[r + len] = (BYTE)c;  // Read F bytes into the last F bytes of the buffer

	textsize = len;
	if (len == 0)
		return;

	// Insert the F strings, each of which begins with one or more 'space' characters.
	// Note the order in which these strings are inserted.  This way, degenerate trees
	// will be less likely to occur.
	for (i = 1; i <= F; i++)
		InsertNode(r - i);

	// Finally, insert the whole string just read.  The variables match_length and match_position are set.
	InsertNode(r);
	
	do
	{
		if (match_length > len)
			match_length = len;  // match_length may be spuriously long near the end of text.

		if (match_length <= THRESHOLD)
		{
			match_length = 1;  // Not long enough match.  Send one byte.
			code_buf[0] |= mask;  // 'send one byte' flag
			code_buf[code_buf_ptr++] = text_buf[r];  // Send uncoded.
		}
		else
		{
			// Send position and length pair. Note match_length > THRESHOLD.
			code_buf[code_buf_ptr++] = (BYTE)match_position;
			code_buf[code_buf_ptr++] = (BYTE)(((match_position >> 4) & 0xf0) | (match_length - (THRESHOLD + 1)));
		}

		if ((mask <<= 1) == 0)
		{
			// Shift mask left one bit.
			for (i = 0; i < code_buf_ptr; i++)  // Send at most 8 units of code together
				WriteByte(code_buf[i]);

			codesize += code_buf_ptr;
			code_buf[0] = 0;
			code_buf_ptr = mask = 1;
		}

		last_match_length = match_length;
		for (i = 0; i < last_match_length && (c = ReadByte()) != -1; i += 1)
		{
			DeleteNode(s);
			text_buf[s] = (BYTE)c;
			if (s < F - 1)
				text_buf[s + N] = (BYTE)c;
			s = (s + 1) & (N - 1);
			r = (r + 1) & (N - 1);
			InsertNode(r);
		}

		while (i++ < last_match_length)
		{
			DeleteNode(s);
			s = (s + 1) & (N - 1);
			r = (r + 1) & (N - 1);
			len -= 1;
			if (len != 0)
				InsertNode(r);
		}
	}
	while (len > 0);
	
	if (code_buf_ptr > 1)
	{
		// Send remaining code.
		for (i = 0; i < code_buf_ptr; i += 1)
			WriteByte(code_buf[i]);
		codesize += code_buf_ptr;
	}
}
#endif

void CLZSS::Decode()
{
	int i, j, k, r, c;
	UINT flags;
	
	for (i = 0; i < N - F; i++)
		text_buf[i] = SPACE;

	r = N - F;
	flags = 0;
	for (;;)
	{
		if (((flags >>= 1) & 256) == 0)
		{
			if ((c = ReadByte()) == -1)
				break;

			flags = c | 0xff00;
		}
		
		if (flags & 1)
		{
			if ((c = ReadByte()) == -1)
				break;

			WriteByte((BYTE)c);
			text_buf[r++] = (BYTE)c;
			r &= (N - 1);
		}
		else
		{
			if ((i = ReadByte()) == -1)
				break;
			if ((j = ReadByte()) == -1)
				break;

			i |= ((j & 0xf0) << 4);
			j = (j & 0x0f) + THRESHOLD;
			for (k = 0; k <= j; k++)
			{
				c = text_buf[(i + k) & (N - 1)];
				WriteByte((BYTE)c);
				text_buf[r++] = (BYTE)c;
				r &= (N - 1);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xbpremaster\StdAfx.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      StdAfx.cpp
// Contents:  Source file that includes just the standard includes
//	          xbPremaster.pch will be the pre-compiled header
//	          StdAfx.obj will contain the pre-compiled type information
// Revisions: 1-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xbpremaster\PackageFiles.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      PackageFiles.cpp
// Contents:  Contains code related to creation and expansion of Package files.
// Revisions: 6-Sep-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"

// xboxverp.h       -- Necessary to get xbPremaster version stamp.
#include <xboxverp.h>

extern int g_nMinAppLevel;

extern "C"
{
#include <lci.h>
#include <ldi.h>
}
#include "xcrypt.h"
#include "xsum.h"

//
// Constants for LZX compression
//

#define LZX_WINDOW_SIZE     (128*1024)
#define LZX_CHUNK_SIZE      (32*1024)
#define LZX_WORKSPACE       (256*1024)

//
// This structure is the header for each compression block
//
typedef struct _LZXBOX_BLOCK
{
    USHORT  CompressedSize;
    USHORT  UncompressedSize;

} LZXBOX_BLOCK, *PLZXBOX_BLOCK;


DWORD g_dwPackageChecksum;
extern char g_szPackageExtractFolder[MAX_PATH];


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ DEFINES, ENUMS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// BUFFER_SIZE      -- Size of read and write buffers for compression/expansion
#define BUFFER_SIZE 32768

// eFileType        -- The different types of files that can be added to a
//                     Package.  Necessary since FLD and FST files require
//                     special handling.
typedef enum eFileType {FILE_FLD, FILE_FST, FILE_OTHER};

#define PACKAGE_SIG     "XBOX_PACKAGE_FILE"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ STRUCTURES, CLASSES +++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// sPackageHeader   -- Header structure for Package files
struct sPackageHeader
{
    // rgbySig              -- Signature specifying that its a package file
    BYTE rgbySignature[17];
    
    // rgbyPremasterVersion -- Contains version of xbPremaster used to generate
    //                         the package.
    BYTE rgbyPremasterVersion[8];

    // dwChecksum           -- Checksums the uncompressed data placed in the 
    //                         package
    DWORD dwChecksum;
};

// sPackageFileHeader -- Header structure for each file in a Package file.
struct sPackageFileHeader
{
    // szFilePathAndName    -- Relative path/file name of the file
    char szFilePathAndName[MAX_PATH];

    // uliFileSize          -- Size of the file (compressed) in the Package.
    ULARGE_INTEGER uliFileSize;
};

class CPackage
{
public:
    // CPackage         -- CPackage constructor
    CPackage(CStep_Progress *pstep, CDlg *pdlg, char *szFilePathName,
             bool fOpenForExpand);

    // Close            -- Closes the package file
    void Close();

    // Add              -- Adds (and compresses) a new file to the package
    HRESULT Add(char *szName, char *szRoot, eFileType filetype = FILE_OTHER);

    // DecodeNextFile   -- Decodes (and writes out) the next file in the package
    bool DecodeNextFile(char *szExtractDir, HRESULT *phr);

    // WriteChecksum    -- Writes the checksum value to the package header.
    HRESULT WriteChecksum();

    // m_hrInit         -- Result of the initialization
    HRESULT m_hrInit;

    // m_hPackageFile   -- Handle to the package file itself.
    HANDLE m_hPackageFile;

    // m_xsum           -- The checksum of all data (in uncompressed form) read
    //                     or written so far.
    CCheckSum m_xsum;

    // m_pp            -- The package header for this package
    sPackageHeader m_ph;

    int CPackage::CompressionCallback(void *pfol, unsigned char *compressed_data,
                                      long compressed_size, long uncompressed_size);

    ULARGE_INTEGER m_uliBytesRead;
    CDlg *m_pdlg;
    CStep_Progress *m_pstep;

private:

    sPackageFileHeader m_pfh;

    char m_szName[MAX_PATH];
    char m_szCurFile[MAX_PATH];

    bool m_fOpenForExpand;
};

CPackage *g_ppkgCur;

LONG CompressedSize, UncompressedSize;
int __cdecl CompressionCallback(void * pfol, unsigned char * compressed_data,
                        long compressed_size, long uncompressed_size)
{
    return g_ppkgCur->CompressionCallback(pfol, compressed_data,
                                           compressed_size, uncompressed_size);
}


int CPackage::CompressionCallback(void *pfol, unsigned char *compressed_data,
                                  long compressed_size, long uncompressed_size)
{
    LZXBOX_BLOCK Block;

    //
    // Write block header
    //

    Block.CompressedSize = (USHORT)compressed_size;
    Block.UncompressedSize = (USHORT)uncompressed_size;

    CompressedSize += sizeof Block + compressed_size;
    UncompressedSize += uncompressed_size;

    ULONG BytesWritten;
    if (!WriteFile(m_hPackageFile, &Block, sizeof(Block), &BytesWritten, NULL)) {
        return -1;
    }

    //
    // Write compressed data
    //

    if (!WriteFile(m_hPackageFile, compressed_data, compressed_size, &BytesWritten, NULL)) {
        return -1;
    }

    // Update the progress bar
    m_uliBytesRead.QuadPart += uncompressed_size;
    m_pdlg->SetProgressPos(IDC_PROGRESS_PROGRESSBAR, (int)(m_uliBytesRead.QuadPart / 1024));

    m_pfh.uliFileSize.QuadPart += uncompressed_size;
    // Check if we should cancel
    if (m_pstep->CheckCancelled())
        return -1;

    return 0;
}

MI_MEMORY
DIAMONDAPI
LzxAlloc(
    ULONG cb
    )
{
    return LocalAlloc( LPTR, cb );
}

VOID
DIAMONDAPI
LzxFree(
    MI_MEMORY pv
    )
{
    LocalFree( pv );
}

DWORD CompressFile(HANDLE hfileSrc, SIZE_T sizeCurFile, CCheckSum *pxsum)
{
    UINT DestSize;
    int LciReturn;
    UINT SourceSize;
    ULONG_PTR Source;
    DWORD dw;
    LZXCONFIGURATION cfg;
    LCI_CONTEXT_HANDLE Handle;
    SIZE_T BytesRead, BytesRemaining;
    SIZE_T BytesCompressed;

    SourceSize = LZX_CHUNK_SIZE;
    cfg.WindowSize = LZX_WINDOW_SIZE;
    cfg.SecondPartitionSize = 64 * 1024;

    LciReturn = LCICreateCompression(&SourceSize, &cfg, LzxAlloc, LzxFree,
                                      &DestSize, &Handle, CompressionCallback,
                                      NULL);

    if (LciReturn != MCI_ERROR_NO_ERROR) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    BytesRemaining = sizeCurFile;
    DWORD dwSourceSize = 32768;
    Source = (ULONG_PTR)malloc(dwSourceSize);
    BytesRead = (BytesRemaining > SourceSize) ? SourceSize : BytesRemaining;

    while (BytesRemaining) {
        if (BytesRead > dwSourceSize)
        {
            dwSourceSize = BytesRead;
            Source = (ULONG_PTR)realloc((void*)Source, dwSourceSize);
        }
        // Read the next block from the source file
        if (!ReadFile(hfileSrc, (void*)Source, BytesRead, &dw, NULL))
            return ERROR_GEN_FAILURE;
        LciReturn = LCICompress(Handle, (PVOID)Source, BytesRead, NULL,
                                 DestSize, &BytesCompressed);

        pxsum->SumBytes((BYTE*)Source, BytesRead);

        if (LciReturn != MCI_ERROR_NO_ERROR)
            return ERROR_GEN_FAILURE;

        BytesRemaining -= BytesRead;
        BytesRead = (BytesRemaining > SourceSize) ? SourceSize : BytesRemaining;
    }

    LCIFlushCompressorOutput(Handle);
    LCIDestroyCompression(Handle);

    free((void*)Source);

    return BytesRemaining ? ERROR_GEN_FAILURE : ERROR_SUCCESS;
}

DWORD DecompressFile(HANDLE hfileDest, ULARGE_INTEGER uliOutputFileSize, HANDLE hfileSrc)
{
    UINT DestSize;
    UINT SourceSize;
    ULONG_PTR Source;
    ULONG_PTR Dest;
    DWORD dw;
    LZXDECOMPRESS Decomp;
    LCI_CONTEXT_HANDLE Handle;
    UINT BytesDecompressed;
    LZXBOX_BLOCK Block;

    SourceSize = LZX_CHUNK_SIZE;
    Decomp.fCPUtype = LDI_CPU_80386;
    Decomp.WindowSize = LZX_WINDOW_SIZE;

    if (LDICreateDecompression(&SourceSize, &Decomp, LzxAlloc, LzxFree, &DestSize,
        &Handle, NULL,NULL,NULL,NULL,NULL) != MDI_ERROR_NO_ERROR)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    DWORD dwSrcSize = 32768;
    DWORD dwDestSize = 32768;
    Source = (ULONG_PTR)malloc(dwSrcSize);
    Dest = (ULONG_PTR)malloc(dwDestSize);

    while (uliOutputFileSize.QuadPart)
    {
        // Read the compression block
        if (!ReadFile(hfileSrc, (void*)&Block, sizeof(LZXBOX_BLOCK), &dw, NULL))
            return ERROR_GEN_FAILURE;

        if (Block.CompressedSize > dwSrcSize)
        {
            dwSrcSize = Block.CompressedSize;
            Source = (ULONG_PTR)realloc((void*)Source, dwSrcSize);
        }
        if (Block.UncompressedSize > dwDestSize)
        {
            dwDestSize = Block.UncompressedSize;
            Dest = (ULONG_PTR)realloc((void*)Dest, dwDestSize);
        }

        // read the compressed data
        if (!ReadFile(hfileSrc, (void*)Source, Block.CompressedSize, &dw, NULL))
            return ERROR_GEN_FAILURE;

        // Perform decompression
        BytesDecompressed = Block.UncompressedSize;
        if (LDIDecompress(Handle, (PVOID)Source, Block.CompressedSize, (PVOID)Dest,
            &BytesDecompressed) != MDI_ERROR_NO_ERROR)
        {
            LDIDestroyDecompression(Handle);
            return ERROR_GEN_FAILURE;
        }

        // output the decompressed data
        if (!WriteFile(hfileDest, (void*)Dest, BytesDecompressed, &dw, NULL))
            return ERROR_GEN_FAILURE;

        // update the checksum
        g_ppkgCur->m_xsum.SumBytes((BYTE*)Dest, BytesDecompressed);

        // Update the progress bar
        g_ppkgCur->m_uliBytesRead.QuadPart += BytesDecompressed;
        g_ppkgCur->m_pdlg->SetProgressPos(IDC_PROGRESS_PROGRESSBAR,
                             (int)(g_ppkgCur->m_uliBytesRead.QuadPart / 1024));

        // Check if we should cancel
        if (g_ppkgCur->m_pstep->CheckCancelled())
        {
            LDIDestroyDecompression(Handle);
            return ERROR_GEN_FAILURE;
        }
        
        
        //
        // Advance the pointers
        //
        uliOutputFileSize.QuadPart -= (__int64)BytesDecompressed;
    }

    LDIDestroyDecompression(Handle);

    free((void*)Source);
    free((void*)Dest);

    return uliOutputFileSize.QuadPart ? ERROR_GEN_FAILURE : ERROR_SUCCESS;
}


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CPackage::CPackage
// Purpose:   
// Arguments: 
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CPackage::CPackage(CStep_Progress *pstep, CDlg *pdlg, char *szFilePathName, bool fOpenForExpand)
{
    m_hrInit = E_FAIL;
    m_pdlg = pdlg;
    m_pstep = pstep;

    // Track why this package was opened (expanding or compacting)
    m_fOpenForExpand = fOpenForExpand;

    strcpy(m_szName, szFilePathName);

    // Create the file that will contain all of the compressed files
    if (fOpenForExpand)
        m_hPackageFile = CreateFile(szFilePathName, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL, 0);
    else
        m_hPackageFile = CreateFile(szFilePathName, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL, 0);
    if (m_hPackageFile == INVALID_HANDLE_VALUE)
    {
        // Failed to create the file for some reason.
        // Figure out why we died
        DWORD dwErr = GetLastError();
        switch(dwErr)
        {
        case ERROR_DISK_FULL:
            MessageBox(m_pdlg->GetHwnd(), "The specified drive is full.  "
                       "Please free some space on it or select another drive, "
                       "and try again.", "Insufficient disk space",
                       MB_ICONWARNING | MB_APPLMODAL | MB_OK);
            return;

        case ERROR_FILE_NOT_FOUND:
            MessageBox(m_pdlg->GetHwnd(), "The specified package could not "
                       "be found.", "Package not found",
                       MB_ICONWARNING | MB_APPLMODAL | MB_OK);
            return;

        case ERROR_ACCESS_DENIED:
            MessageBox(m_pdlg->GetHwnd(), "Cannot access Package.  Please ensure it is not in use.", "Package not accessible",
                       MB_ICONWARNING | MB_APPLMODAL | MB_OK);
            return;

        default:
            MessageBox(m_pdlg->GetHwnd(), "xbPremaster cannot create the "
                       "package at the specified location.  Please check the "
                       "device and try again.", "Cannot create package",
                       MB_ICONWARNING | MB_APPLMODAL | MB_OK);
            return;
        }
    }

    if (fOpenForExpand)
    {
        // Verify it's a valid package file
        DWORD dwRead;
        if (!ReadFile(m_hPackageFile, &m_ph, sizeof m_ph, &dwRead, 0))
            return;

        if (memcmp((char*)m_ph.rgbySignature, PACKAGE_SIG, strlen(PACKAGE_SIG)))
        {
            MessageBox(m_pdlg->GetHwnd(), "Invalid Package file specified",
                       "Not a package file",
                       MB_ICONWARNING | MB_APPLMODAL | MB_OK);
            return;
        }
    }
    else
    {
        sPackageHeader ph;
        DWORD dwWritten;
        
        // Add package header information
        memcpy(ph.rgbySignature, PACKAGE_SIG, strlen(PACKAGE_SIG));
            
        int nMajor, nMinor, nBuild, nQFE;
        sscanf(VER_PRODUCTVERSION_STR, "%d.%d.%d.%d", &nMajor, &nMinor,
                                                      &nBuild, &nQFE);
        *(WORD*)(&ph.rgbyPremasterVersion[0]) = (WORD)nMajor;
        *(WORD*)(&ph.rgbyPremasterVersion[2]) = (WORD)nMinor;
        *(WORD*)(&ph.rgbyPremasterVersion[4]) = (WORD)nBuild;
        *(WORD*)(&ph.rgbyPremasterVersion[6]) = (WORD)nQFE;

        if (!WriteFile(m_hPackageFile, &ph, sizeof ph, &dwWritten, 0))
            return;
    }

    // Need to keep track of the total number of bytes read so that we can
    // update the progress bar accordingly.
    m_uliBytesRead.QuadPart = 0;

    // If here, then the file was successfully created
    m_hrInit = S_OK;
}

void CPackage::Close()
{
    if (m_hPackageFile)
        CloseHandle(m_hPackageFile);
}

void GetFilePointer(HANDLE hfile, LARGE_INTEGER *puliPos)
{
    puliPos->QuadPart = 0;
    puliPos->LowPart = SetFilePointer(hfile, 0, (long*)&puliPos->HighPart, FILE_CURRENT);
}
void SetFilePointer(HANDLE hfile, LARGE_INTEGER *puliPos)
{
    ::SetFilePointer(hfile, puliPos->LowPart, (long*)&puliPos->HighPart, FILE_BEGIN);
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CPackage::DecodeNextFile
// Purpose:   
// Arguments: 
// Return:    'false' of eof, 'true' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CPackage::DecodeNextFile(char *szExtractDir, HRESULT *phr)
{
    char sz[MAX_PATH];
    DWORD dwRead;

    assert(m_hPackageFile);

    // Get the next file header
    if (!ReadFile(m_hPackageFile, &m_pfh, sizeof m_pfh, &dwRead, 0))
    {
        *phr = E_FAIL;
        return false;
    }
    if (dwRead == 0)
    {
        *phr = S_OK;
        return false;
    }

    // Change dir to the root extraction dir
    SetCurrentDirectory(szExtractDir);

    // Create the directory(s) necessary to place the file
    strcpy(sz, m_pfh.szFilePathAndName);
    char *pch = strtok(sz, "\\/");
    char *pchFileName = strrchr(m_pfh.szFilePathAndName, '/');
    if (!pchFileName)
        pchFileName = strrchr(m_pfh.szFilePathAndName, '\\');
    if (!pchFileName)
    {
        // File's in the root
        pchFileName = m_pfh.szFilePathAndName;
    }
    else
    {
        pchFileName++; // Skip the slash
        while(pch && strcmp(pch, pchFileName))
        {
            if (!CreateDirectory(pch, 0))
            {
                // It's valid for createdirectory to fail if the dir was already there;
                // however, it could be that we're out of space...
                if (GetLastError() == ERROR_DISK_FULL)
                {
                    MessageBox(m_pdlg->GetHwnd(), "Not enough disk space on system drive to expand package",
                               "Not enough space", MB_ICONWARNING | MB_APPLMODAL | MB_OK);
                    *phr = E_FAIL;
                    return true;
                }
            }
            SetCurrentDirectory(pch);
            // Get next token
            pch = strtok(NULL, "\\/");
        }
    }

    // Create the to-be-decompressed file
    HANDLE hCurFile = CreateFile(pchFileName, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL, 0);
    if (hCurFile == INVALID_HANDLE_VALUE)
    {
        // Failed to create the file for some reason.
        // Figure out why we died
        DWORD dwErr = GetLastError();
        switch(dwErr)
        {
        case ERROR_DISK_FULL:
            MessageBox(m_pdlg->GetHwnd(), "The specified drive is full.  "
                       "Please free some space on it or select another drive, "
                       "and try again.", "Insufficient disk space",
                       MB_ICONWARNING | MB_APPLMODAL | MB_OK);
            *phr = E_FAIL;
            return true;

        case ERROR_ACCESS_DENIED:
            MessageBox(m_pdlg->GetHwnd(), "Cannot access file.  Please ensure it is not in use.", "File not accessible",
                       MB_ICONWARNING | MB_APPLMODAL | MB_OK);
            *phr = E_FAIL;
            return true;

        default:
            MessageBox(m_pdlg->GetHwnd(), "xbPremaster cannot decompress the "
                       "package.  Please check the "
                       "package and try again.", "Cannot create package",
                       MB_ICONWARNING | MB_APPLMODAL | MB_OK);
            *phr = E_FAIL;
            return true;
        }
    }

    *phr = DecompressFile(hCurFile, m_pfh.uliFileSize, m_hPackageFile);

    // We're now done with the file
    CloseHandle(hCurFile);
    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CPackage::WriteChecksum
// Purpose:   Writes the uncompressed-data checksum value to the package file.
// Arguments: None
// Return:    S_OK if successful, OLE-compatible error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CPackage::WriteChecksum()
{ 
    sPackageHeader ph;
    DWORD          dwChecksum = m_xsum.DwFinalSum(); 
    LARGE_INTEGER uli;
    DWORD dwWritten;

    // Calculate offset to the checksum data in the package header
     uli.QuadPart = (BYTE*)&ph.dwChecksum - (BYTE*)&ph;
 
     SetFilePointer(m_hPackageFile, &uli);
     if (!WriteFile(m_hPackageFile, (BYTE*)&dwChecksum, 4, &dwWritten , 0))
         return E_FAIL;

    g_dwPackageChecksum = dwChecksum;
    return S_OK;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CPackage::Add
// Purpose:   
// Arguments: 
// Return:    S_OK if successful, OLE-compatible error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CPackage::Add(char *szName, char *szRoot, eFileType filetype)
{
    char sz[MAX_PATH + 200];
    DWORD error;
    HRESULT hr = E_FAIL;
    HANDLE hCurFile;
    strcpy(m_szCurFile, szName);

    // Verify that any xbes attached are linked only to approved libraries
    if (!lstrcmpi(szName + strlen(szName) - 4, ".xbe"))
    {
       // Create a new CXBEFile to point at the file
        CFileStmRand *pstm;
        CFile *pfileNext = new CFile(m_pdlg, m_pstep, szName);
        if (!pfileNext->IsInited())
        {
            // Failed to load the specified FST object
            hr = pfileNext->GetInitCode();
            pfileNext->InformError(m_pdlg->GetHwnd(), hr, pfileNext->GetFilename());
            if (pfileNext)
                delete pfileNext;
            goto done;
        }
        pfileNext->CreateFileStm(&pstm);
        CXBEFile xf(pstm);
        int nLibApprovalLevel = xf.GetLibApprovalLevel();
        g_nMinAppLevel = min(g_nMinAppLevel, nLibApprovalLevel);

        if (nLibApprovalLevel <= 1)
        {
            // uh oh, we don't support it.  Warn the user

            // Need to allocate more space for the list of invalid
            // xbe names?
            if (g_cInvalidXbes == g_cMaxInvalidXbes)
            {
                g_cMaxInvalidXbes += BATCH;
                g_rgstrInvalidXbeName = (sString*)realloc(
                                g_rgstrInvalidXbeName,
                                g_cMaxInvalidXbes*sizeof(sString));
            }

            strcpy(g_rgstrInvalidXbeName[g_cInvalidXbes].sz, szName);
            sprintf(sz, "Warning: Invalid xbe encountered (%s)", szName);
            m_pdlg->SetControlText(IDC_PROGRESS_BADXBE, sz);
            g_cInvalidXbes++;
        }

        delete pstm;
        delete pfileNext;
    }
    
    // Open the file handle so that we can read from it for the encoding
    hCurFile = CreateFile(szName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL, 0);
    if (hCurFile == INVALID_HANDLE_VALUE)
    {
        // Failed to open the file for some reason. Figure out why we died
        DWORD dwErr = GetLastError();
        switch(dwErr)
        {
        case ERROR_ACCESS_DENIED:
            sprintf(sz, "xbPremaster cannot access the file '%s'.  Please"
                       " ensure the file isn't in use and try again.", szName);
            MessageBox(m_pdlg->GetHwnd(), sz, "Cannot create package",
                       MB_ICONWARNING | MB_APPLMODAL | MB_OK);
            return E_FAIL;

        default:
            sprintf(sz, "xbPremaster cannot open the file '%s'.  Please check the "
                       "device and try again.", szName);
            MessageBox(m_pdlg->GetHwnd(), sz, "Cannot create package",
                       MB_ICONWARNING | MB_APPLMODAL | MB_OK);
            return E_FAIL;
        }
    }

    ULARGE_INTEGER uliSize;
    uliSize.LowPart = GetFileSize(hCurFile, &uliSize.HighPart);

    memset(&m_pfh, 0, sizeof(m_pfh));

    // We only want to store relative paths, so ignore the root
    switch(filetype)
    {
    case FILE_FLD:
        // Place FLD file in root (relative)
        strcpy(m_pfh.szFilePathAndName, "main.fld");
        break;
    case FILE_FST:
        // Place FST in _amc dir
        strcpy(m_pfh.szFilePathAndName, "_amc\\main.fst");
        break;
    case FILE_OTHER:
        strcpy(m_pfh.szFilePathAndName, szName + strlen(szRoot) + 1);
        break;
    }
    
    // Save the current file position so that we can restore it
    LARGE_INTEGER uliCurFilePos;
    LARGE_INTEGER uliCurFilePos2;
    DWORD dwWritten;
    
    GetFilePointer(m_hPackageFile, &uliCurFilePos);
    if (!WriteFile(m_hPackageFile, &m_pfh, sizeof(m_pfh), &dwWritten, 0))
        goto done;

    UncompressedSize = 0;
    error = CompressFile(hCurFile, uliSize.LowPart, &m_xsum);
    if (error != ERROR_SUCCESS)
        goto done;

    if(UncompressedSize != (long)uliSize.LowPart)
        goto done;

    // Write out the file header
    GetFilePointer(m_hPackageFile, &uliCurFilePos2);
    SetFilePointer(m_hPackageFile, &uliCurFilePos);
    if (!WriteFile(m_hPackageFile, &m_pfh, sizeof(m_pfh), &dwWritten, 0))
        goto done;
    SetFilePointer(m_hPackageFile, &uliCurFilePos2);

    hr = S_OK;

done:

    // We're now done with the file
    CloseHandle(hCurFile);

    // Return if a failure occurred -- the user has already been notified
    return hr;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStep_Progress::GetFSTFileSizes
// Purpose:   Gets size of all files in the specified FST object.  This is
//            necessary to properly update the progress bar.
// Arguments: 
// Return:    'true' if successful, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool CStep_Progress::GetFSTFileSizes(CFST *pfst, ULARGE_INTEGER *puliSize)
{
    bool fHitGdfs = false;
    
    // Step over each file in the FST and calculate its size
    for (int iLayer = 0; iLayer <= 1; iLayer++)
    {
        int   nStartLSN, nEndLSN;
        DWORD dwOffset;
        char  szName[MAX_PATH];
        int   iObject = 0;

        while (true)
        {
            // Get the next object in the FST.
            if (!pfst->GetEntry(iLayer, iObject, szName, &nStartLSN, &nEndLSN, &dwOffset))
            {
                // no more objects on the current layer
                break;
            }

            // Only add first gdfs.bin here
            if (strlen(szName) > 8)
            {
                if (!lstrcmpi(szName + strlen(szName) - 8, "gdfs.bin"))
                    if (fHitGdfs)
                    {
                        iObject++;
                        continue;
                    }
                    else
                        fHitGdfs = true;
            }

            // At this point, szName contains the entire path to the file
            WIN32_FILE_ATTRIBUTE_DATA wfad;
            if (!GetFileAttributesEx(szName, GetFileExInfoStandard, &wfad))
                return false;

            ULARGE_INTEGER uli;
            uli.HighPart = wfad.nFileSizeHigh;
            uli.LowPart = wfad.nFileSizeLow;
            puliSize->QuadPart += uli.QuadPart;
            
            iObject++;
        }
    }
    return true;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStep_Progress::ExtractPackagedFiles
// Purpose:   
// Arguments: 
// Return:    S_OK if successful, OLE-compatible error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CStep_Progress::ExtractPackagedFiles(char *szPackageName)
{
    HRESULT hr;
    char szTempDir[MAX_PATH], szTemp[400];
    ULARGE_INTEGER uliSize;

    // Create a temporary directory to hold the files.

    // Allow override via regkey.  Used for internal testing purposes only
    HKEY hkey;
    bool fGotTemp = false;

    if (g_szPackageExtractFolder[0])
    {
        strcpy(m_szPackageExtractFolder, g_szPackageExtractFolder);
        fGotTemp = true;
    }
    if (!fGotTemp)
    {
        if ((RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          TEXT("SOFTWARE\\Microsoft\\XboxSDK\\xbPremaster"), 0,
                          KEY_READ, &hkey) == ERROR_SUCCESS))
        {
            DWORD dwSize = sizeof m_szPackageExtractFolder;
            if (RegQueryValueEx(hkey, "RenderTemp", NULL, NULL,
                                (BYTE*)m_szPackageExtractFolder, &dwSize) ==
                                ERROR_SUCCESS)
                fGotTemp = true;
            RegCloseKey(hkey);
        }
    }
    if (!fGotTemp)
    {
        GetTempPath(MAX_PATH, szTempDir);
        if (GetTempFileName(szTempDir, "xbp", 0, m_szPackageExtractFolder) == 0)
        {
            // Couldn't create the temporary directory
            sprintf(szTemp, "Failed to create temp directory for extraction of package"
                        " files.  Ensure your system drive ('%c':\\) has enough "
                        "free space available and that you have the appropriate "
                        "administrative permissions.", szTempDir[0]);
            MessageBox(m_pdlg->GetHwnd(), szTemp, "Could not extract package",
                       MB_ICONWARNING | MB_APPLMODAL | MB_OK);
            strcpy(m_szPackageExtractFolder, "");
            m_fCancelled = true;
            return E_FAIL;
        }

        // GetTempFileName forces creation of a file with the temporary name; we
        // want a directory, so delete the created file and create a directory.
        DeleteFile(m_szPackageExtractFolder);
    }
    
    CreateDirectory(m_szPackageExtractFolder, 0);
    
    // Create the package from which all of the layout files will be created
    CPackage pkg(this, m_pdlg, m_szSourceFile, true);
    if (!SUCCEEDED(pkg.m_hrInit))
    {
        m_fCancelled = true;
        return pkg.m_hrInit;
    }

    // We track decompression progress by current position in the package file.
    uliSize.LowPart = GetFileSize(pkg.m_hPackageFile, &uliSize.HighPart);
    m_pdlg->SetProgressRange(IDC_PROGRESS_PROGRESSBAR, 0, (int)(uliSize.QuadPart / 1024));


    g_ppkgCur = &pkg;
    // Iterate the files in the package file and extract them to the temporary
    // directory.
    do
    {
        if (!pkg.DecodeNextFile(m_szPackageExtractFolder,&hr))
            break;
    } while (SUCCEEDED(hr) && !m_fCancelled);

    // Store the path\name of the extracted FLD file
    strcpy(m_szSourceFile, m_szPackageExtractFolder);
    strcat(m_szSourceFile, "\\main.fld");

    if (SUCCEEDED(hr))
    {
        // Compare the checksum stored in the package with the calculated checksum
        if (pkg.m_xsum.DwFinalSum() != pkg.m_ph.dwChecksum)
        {
            MessageBox(m_pdlg->GetHwnd(), "ERROR: Checksum does not match!",
                                          "Invalid Checksum", MB_ICONEXCLAMATION |
                                          MB_APPLMODAL | MB_OK);
            m_fCancelled = true;
            hr = E_FAIL;                                        
        }
        else
            g_dwPackageChecksum = pkg.m_ph.dwChecksum;
    }

    if (FAILED(hr))
    {
        CStep *pstepNext = new CStep_Completion(m_pdlg, m_source, m_media, m_szDestPath, m_szSourceFile,
                                                "Failed during package extraction");
        m_pdlg->SetNextStep(pstepNext);
    }

    return hr;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStep_Progress::PackageFiles
// Purpose:   Packages up all of the files in the layout for future premastering
// Arguments: 
// Return:    S_OK if successful, OLE-compatible error code otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CStep_Progress::PackageFiles(CFST *pfst, char *szRoot, char *szFLDName,
                                     char *szFSTName, char *szBinName)
{
    WIN32_FILE_ATTRIBUTE_DATA wfad;
    ULARGE_INTEGER uliTotalSourceBytes;
    HRESULT hr;
    int iLayer;

    assert(pfst);
    assert(szBinName);

    // First, determine the total size of all files so that we can update the
    // progress bar accordingly
    uliTotalSourceBytes.QuadPart = 0;
    if (!GetFSTFileSizes(pfst, &uliTotalSourceBytes))
    {
        MessageBox(m_pdlg->GetHwnd(), "xbPremaster failed while writing the "
                                      "package file", "Cannot save file",
                    MB_ICONWARNING | MB_APPLMODAL | MB_OK);
        m_fCancelled = true;
        return E_FAIL;
    }

    // Add size of FLD file
    if (!GetFileAttributesEx(szFLDName, GetFileExInfoStandard, &wfad))
        return false;
    uliTotalSourceBytes.HighPart += wfad.nFileSizeHigh;
    uliTotalSourceBytes.LowPart  += wfad.nFileSizeLow;

    g_nMinAppLevel = 255;
    g_cInvalidXbes = 0;
    g_cMaxInvalidXbes = 0;
    g_rgstrInvalidXbeName = NULL;

    m_pdlg->SetProgressRange(IDC_PROGRESS_PROGRESSBAR, 0,
                             (int)(uliTotalSourceBytes.QuadPart / 1024));

    // Create the package to which all of the layout files will be added
    CPackage pkg(this, m_pdlg, m_szDestPath, false);
    if (!SUCCEEDED(pkg.m_hrInit))
    {
        m_fCancelled = true;
        return pkg.m_hrInit;
    }

    // Necessary for lzx compression callback function
    g_ppkgCur = &pkg;
    
    // Add the FLD to the package
    hr = pkg.Add(szFLDName, NULL, FILE_FLD);
    if (FAILED(hr) || m_fCancelled)
        goto Failure;

    // Add the BIN to the package
    hr = pkg.Add(szBinName, szRoot);
    if (FAILED(hr) || m_fCancelled)
        goto Failure;

    // Step over each file in the FST and add it to the package
    for (iLayer = 0; iLayer <= 1; iLayer++)
    {
        int   nStartLSN, nEndLSN;
        DWORD dwOffset;
        char  szName[MAX_PATH];
        int   iObject = 0;

        while (true)
        {
            // Get the next object in the FST.
            if (!pfst->GetEntry(iLayer, iObject, szName, &nStartLSN, &nEndLSN,
                                &dwOffset))
            {
                // no more objects on the current layer
                break;
            }
            iObject++;

            // Don't add gdfs.bin here
            if (strlen(szName) > 8 && !lstrcmpi(szName + strlen(szName) - 8,
                                                "gdfs.bin"))
                continue;

            // At this point, szName contains the entire path to the file
            hr = pkg.Add(szName, szRoot);
            if (FAILED(hr) || m_fCancelled)
                goto Failure;
        }
    }

    // Now that we're done with the FST, we can delete the pfst object so that
    // the file is unlocked so that we can add it to the package
    delete pfst;

    // Add the FST file to the package
    hr = pkg.Add(szFSTName, NULL, FILE_FST);
    if (FAILED(hr) || m_fCancelled)
        goto Failure;

    // Place the uncompressed-data checksum in the package's header
    hr = pkg.WriteChecksum();
    if (FAILED(hr) || m_fCancelled)
        goto Failure;

    // Success!
    goto done;

Failure:

    // Something failed - delete the package and inform caller that we're done.
    DeleteFile(m_szDestPath);
    m_fCancelled = true;

done:

    // All done!
    pkg.Close();

    return hr;
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  VerifyPackageFile
// Purpose:   
// Arguments: 
// Return:    'true' if valid, 'false' otherwise
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool VerifyPackageFile(char *szPKGFile)
{
    DWORD dwRead;
    sPackageHeader ph;

    // Open the specified package file
    HANDLE hfile = CreateFile(szPKGFile, GENERIC_READ, 0, NULL,
                             OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
    if (hfile == INVALID_HANDLE_VALUE)
        return false;

    // Get package header information
    if (!ReadFile(hfile, &ph, sizeof(ph), &dwRead, 0) || dwRead != sizeof(ph))
    {
        // Failed to read the header.
        CloseHandle(hfile);
        return false;
    }

    // Verify its a valid package file
    if (memcmp((char*)ph.rgbySignature, PACKAGE_SIG, strlen(PACKAGE_SIG)))
    {
        CloseHandle(hfile);
        return false;
    }

    CloseHandle(hfile);
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xbpremaster\Util.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      util.cpp
// Contents:  Simple utilities for the xbPremaster application.
// Revisions: 31-May-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ReportError
// Purpose:   Display appropriate error message to user
// Arguments: error         -- The error message to report
// Return:    None - the application will exit at the end of the function.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void ReportError(eError error)
{
    switch(error)
    {
    case ERROR_INIT:
        MessageBox(NULL, "The application failed to properly initialize.  Please restart your" \
                         " computer and try again.", "Failed to initialize",
                         MB_OK | MB_TASKMODAL | MB_ICONEXCLAMATION);
        break;
        
    case ERROR_OUTOFMEM:
        MessageBox(NULL, "Not enough memory to continue the operation.  xbPremaster will now exit",
                   "Out of memory", MB_OK | MB_TASKMODAL | MB_ICONEXCLAMATION);
        break;
        
    default:
    case ERROR_UNEXPECTED:
        MessageBox(NULL, "An unexpected error has occurred in the application.  Please restart it" \
                         " and try again.", "Unexpected error occurred", MB_OK | MB_TASKMODAL |
                         MB_ICONEXCLAMATION);
        break;
    }    
    exit(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xbpremaster\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by xbPremaster.rc
//
#define IDC_DONTTELL                    1
#define ID_ESCAPE_KEY                   2
#define IDC_TEXT                        2
#define ID_OK                           3
#define IDD_USERACTION                  101
#define IDD_MAIN                        102
#define IDD_PROGRESS                    103
#define IDD_DESTSOURCE                  104
#define IDD_COMPLETION                  105
#define IDB_BITMAP1                     106
#define IDB_BITMAP2                     109
#define IDB_BITMAP3                     110
#define IDD_INVALIDXBE                  111
#define ID_EXIT                         1000
#define IDC_VERIFY                      1002
#define IDC_USERACTION_BTN_VERIFY       1003
#define ID_WRITE                        1004
#define IDC_USERACTION_BTN_WRITE        1005
#define IDC_USERACTION_TEXT_WELCOME     1006
#define IDC_USERACTION_TEXT_BODY        1007
#define IDC_USERACTION_TEXT_WHATDO      1008
#define IDC_DESTSOURCE_TEXT_SETDEST     1015
#define IDC_DESTSOURCE_TEXT_SETSOURCE   1016
#define IDC_DESTSOURCE_RBTN_DISK        1077
#define IDC_DESTSOURCE_RBTN_TAPE        1018
#define IDC_DESTSOURCE_BTN_OK           1019
#define IDC_DESTSOURCE_RBTN_ELEC        1019
#define IDC_DESTSOURCE_EDIT_SETDISKPATH 1020
#define IDC_PROGRESS_TEXT_WRITING       1021
#define IDC_PROGRESS_TEXT_TITLE         1023
#define IDC_PROGRESS_TEXT_VERIFYING     1024
#define IDC_PROGRESS_PROGRESSBAR        1025
#define IDC_PROGRESS_TEXT_PROGRESS      1026
#define IDC_COMPLETION_TEXT_WRITING     1027
#define IDC_COMPLETION_TEXT_VERIFY      1029
#define IDC_COMPLETION_ERRORREPORT      1030
#define IDC_COMPLETION_BTN_EJECT        1031
#define IDC_COMPLETION_BTN_VERIFY       1033
#define IDC_COMPLETION_TXT_RECOMMEND    1034
#define IDC_COMPLETION_TEXT_RECOMMEND   1035
#define IDC_DESTSOURCE_BTN_FILEPATH     1036
#define IDC_DESTSOURCE_LINE             1037
#define IDC_DESTSOURCE_BTN_FLDPATH      1038
#define IDC_DESTSOURCE_TEXT_SETFLDPATH  1039
#define IDC_DESTSOURCE_EDIT_SETFLDPATH  1040
#define IDC_DESTSOURCE_TEXT_SETFLDPATH2 1041
#define IDC_DESTSOURCE_EDIT_SETFLDPATH2 1042
#define IDC_DESTSOURCE_TEXT_TITLE       1043
#define IDC_DESTSOURCE_BTN_FLDPATH2     1044
#define IDC_COMPLETION_BTN_FINISH       1049
#define IDC_COMPLETION_TEXT_TITLE       1050
#define IDC_COMPLETION_TEXT_BODY        1051
#define IDC_USERACTION_STATIC           1052
#define IDC_USERACTION_STATIC2          1053
#define IDC_USERACTION_TEXT_TITLE       1054
#define IDC_USERACTION_STATIC3          1055
#define IDC_DESTSOURCE_STATIC           1056
#define IDC_DESTSOURCE_STATIC2          1057
#define IDC_PROGRESS_STATIC             1058
#define IDC_PROGRESS_STATIC2            1059
#define IDC_PROGRESS_STATIC3            1060
#define IDC_PROGRESS_STATIC4            1061
#define IDC_COMPLETION_STATIC           1062
#define IDC_COMPLETION_STATIC2          1063
#define IDC_COMPLETION_TEXT_TOCLOSE     1064
#define IDC_COMPLETION_STATIC3          1065
#define IDC_STATIC3                     1066
#define IDC_STATIC4                     1067
#define IDC_STATIC5                     1068
#define IDC_DESTSOURCE_COMBO_TAPEDRIVES 1069
#define IDC_BTN_PREV                    1070
#define IDC_BTN_NEXT                    1071
#define IDC_BTN_EXIT                    1072
#define IDC_DESTSOURCE_TEXT_SETDEST2    1073
#define IDC_DESTSOURCE_RBTN_FLD         1075
#define IDC_DESTSOURCE_RBTN_PACKAGE     1076
#define IDC_STATIC                      -1
#define IDC_PROGRESS_BADXBE             -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        113
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1076
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xbpremaster\StdAfx.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      stdafx.h
// Contents:  Precompiled header file.  All commonly used header files should appear in here.
// Revisions: 31-May-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#pragma warning(disable:4530)

#include <windows.h>
#include <process.h>
#include <assert.h>
#include <Shlobj.h>
#include <stdio.h>

#define NUM_XDATA_SECTORS 1715632

#include "xsum.h"
#include "filestm.h"
#include "Tape.h"
#include "dx2ml.h"
#include "xbefile.h"
#include "randm.h"

#include "CInitedObject.h"
#include "Resource.h"
#include "Util.h"
#include "CDlg.h"
#include "CFile.h"
#include "CFST.h"
#include "CFLD.h"
#include "CStep.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xbpremaster\Util.h ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      Util.h
// Contents:  Simple utilities for the xbPremaster application.
// Revisions: 31-May-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ ENUMERATIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// eError   -- Application-specific error codes.
typedef enum eError
{
    ERROR_INIT,

    ERROR_UNEXPECTED,

    ERROR_OUTOFMEM,
};

// eMedia           -- The options the user has for write/verify media.
typedef enum eMedia
{
    MEDIA_DISK,
        
    // MEDIA_TAPE       -- Tape drive.
    MEDIA_TAPE,

    // MEDIA_ELECSUB    -- Electronic submission
    MEDIA_ELECSUB,
};

// eSource          -- The different sources which premaster can source off of.
typedef enum eSource
{
    // Source file is and FLD
    SOURCE_FLD,

    // Source file is a package file.
    SOURCE_PACKAGE,
};

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ GLOBAL FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ReportError
// Purpose:   Display appropriate error message to user
// Arguments: error         -- The error message to report
// Return:    None - the application will exit at the end of the function.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
extern void ReportError(eError error);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xbpremaster\WriteThread.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      WriteThread.cpp
// Contents:  This file contains the code related to writing the premastered files out.
// Revisions: 1-Jun-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"

DWORD g_dwTapeChecksum = 0;
extern char g_szDefaultOutputFile[MAX_PATH];

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ EXTERNAL FUNCTIONS ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// GetFSTandBINFromFLD -- Given an FLD file/path, generates the FST and BIN file/path names.
extern bool GetFSTandBINFromFLD(CDlg *pdlg, CStep *pstep, char *szFLDFilePathName, char *szFSTName, char *szBINName);


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  CStep_Progress::WriteFiles
// Purpose:   Handles writing out the files
// Arguments: None
// Returns:   '0' if successfully written; '-1' otherwise.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
DWORD CStep_Progress::WriteFiles()
{
    char szResult[200];
    int  nResult = -1;
    char szFSTName[MAX_PATH];
    char szBinName[MAX_PATH];
    CFST *pfst = NULL;
    CFLD *pfld = NULL;
    CDX2MLFile *pxml = NULL;
    if (m_fCancelled)
    {
        strcpy(szResult, "User cancelled operation.");
        goto NextStep;
    }

    // Coming into here, we are assured that:
    //  1. The destination directory is valid and created.
    //  2. We have pointers to valid a fld file.

    // Get the name of the FST file.
    if (m_source == SOURCE_PACKAGE)
    {
        strcpy(szFSTName, m_szSourceFile);
        char *szFLDName = strrchr(szFSTName, '\\');
        if (!szFLDName)
            szFLDName = strrchr(szFSTName, '/');
        if (!szFLDName)
            return -1;
        strcpy(szFLDName, "\\_amc\\main.fst");
        strcpy(szBinName, szFSTName);
        strcpy(&szBinName[strlen(szBinName)-8], "gdfs.bin");
    }
    else
    {
        if (!GetFSTandBINFromFLD(m_pdlg, this, m_szSourceFile, szFSTName, szBinName))
            return -1;
    }

    // Create the FST object.  This object contains full source file information for the ximage*
    // files.
    pfst = new CFST(m_pdlg, this, szFSTName);
    if (!pfst->IsInited())
    {
        // Failed to load the fst file
        sprintf(szResult, "Failed to open the FST file '%s'.  Please verify that it is a valid "\
                "Win32 file, and that it is not currently opened by any other applications.",
                szFSTName);

        MessageBox(m_pdlg->GetHwnd(), szResult, "Failed to open FST file", MB_ICONEXCLAMATION | MB_OK);

        // Set the result string and go to the completion step
        strcpy(szResult, "Failed to load FST file");
        goto NextStep;
    }

    // Create the FLD object.  This object will contain all layout information necessary for the
    // dx2ml*.xml files (placeholder information, etc).
    pfld = new CFLD(m_pdlg, this, m_szSourceFile);
    if (!pfld->IsInited())
    {
        // Failed to load the FLD file for some reason.
        if (pfld->IsWrongVersion())
        {
            sprintf(szResult, "The FLD file '%s' is in an obsolete format.  Please rerun xbLayout "\
                    "and save the FLD file again.", m_szSourceFile);
        }
        else
        {
            sprintf(szResult, "Failed to open the FLD file '%s'.  Please verify that it is a valid "\
                    "Win32 file, and that it is not currently opened by any other applications.",
                    m_szSourceFile);
        }
        MessageBox(m_pdlg->GetHwnd(), szResult, "Failed to open FLD file", MB_ICONEXCLAMATION | MB_OK);

        // Set the result string and go to the completion step
        strcpy(szResult, "Failed to open FLD file");
        goto NextStep;
    }

    // If the output media type is 'electronic submission', then zip up all the
    // appropriate files for future premastering.  Otherwise create the xml
    // files (et al)
    if (m_media == MEDIA_ELECSUB)
    {
        char szRoot[MAX_PATH];
        sprintf(szRoot, pfld->m_szDVDRoot);

        // We no longer need the FLD object, and need to release our lock on the
        // FLD file since we'll want to package it up with the other files.
        delete pfld;
        pfld = NULL;

        // Package the files for future premastering.
        // WARNING: PackageFiles will delete the pfst object!
        if ((PackageFiles(pfst, szRoot, m_szSourceFile, szFSTName, szBinName) != S_OK) || (m_fCancelled == true))
        {
            // Failed to package the files!  The function has already informed the user of the problem
            strcpy(szResult, "Failed to create electronic submission package");
            pfst = NULL;
            goto NextStep;
        }
        pfst = NULL;
    }
    else
    {
        // Create xml object
        pxml = new CDX2MLFile;
        if (pxml == NULL)
            ReportError(ERROR_OUTOFMEM);

        // Create the dx2ml.xml file
        if (CreateDx2mlFile(pfld, pxml) != S_OK)
        {
            // Failed to create the file!  The function has already informed the user of the problem
            strcpy(szResult, "Failed to create file \"dx2ml.xml\"");
            goto NextStep;
        }

        // Create the xcontrol.xml file
        if (CreateXcontrolFile() != S_OK)
        {
            // Failed to create the file!  The function has already informed the user of the problem
            strcpy(szResult, "Failed to create file \"xcontrol.dat\"");
            goto NextStep;
        }

        g_cInvalidXbes = 0;
        g_cMaxInvalidXbes = BATCH;
        g_rgstrInvalidXbeName = (sString*)malloc(g_cMaxInvalidXbes*sizeof(sString));

        // Create the ximage0.dat file.
        if (CreateXImageFile(0, pfst, pxml) != S_OK)
        {
            // Failed to create the file!  The function has already informed the user of the problem
            strcpy(szResult, "Failed to create file \"ximage0.dat\"");
            goto NextStep;
        }

        // Create the ximage1.dat file
        if (CreateXImageFile(1, pfst, pxml) != S_OK)
        {
            // Failed to create the file!  The function has already informed the user of the problem
            strcpy(szResult, "Failed to create file \"ximage1.dat\"");
            goto NextStep;
        }
    }

    // The files were successfully written.  Move on to the next step (the 'completion' step).
    strcpy(szResult, "The operation completed successfully");
    nResult = 0;

NextStep:

    g_dwTapeChecksum = m_td.DwCheckSum();

    if (pfst)
        delete pfst;
    if (pfld)
        delete pfld;
    if (pxml)
        delete pxml;

    CStep *pstepNext = new CStep_Completion(m_pdlg, m_source, m_media, m_szDestPath, m_szSourceFile,
                                            szResult);
    if (pstepNext == NULL)
        ReportError(ERROR_OUTOFMEM);

    // If we were command-line driven & successful, then exit now.
    if (nResult == 0 && lstrcmpi(g_szDefaultOutputFile, ""))
        pstepNext = NULL;

    m_pdlg->SetNextStep(pstepNext);

    return nResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\amc\AmcMsEmuApi.h ===
#if !defined(AMC_MS_EMU_API__H)
#define AMC_MS_EMU_API__H


#include <WINDOWS.H>
#include "AmcMsEmuApiError.h"
#define _NTSCSI_USER_MODE_
//#include <SCSI.H>   // Get CDB decleared

// LOG:PL 10/18/01
// 1. Added TimeStamp member variable.

typedef struct _ATAPI_TRANSACTION {
    union {
        CDB Cdb;
        UCHAR CommandData[12];
    } CommandBlock;
    ULARGE_INTEGER TimeStamp;
    PUCHAR Data;
    ULONG DataSize;
    PUCHAR Response;
    ULONG ResponseSize;
    ULARGE_INTEGER ResponseDelay;
    HANDLE ResponseEvent;
} ATAPI_TRANSACTION, *PATAPI_TRANSACTION;

#define HANDLER_RETURN_DATA 1
#define HANDLER_RETURN_ERROR 2

// LOG:PL 10/29/01
// 1. Added IDE_IDENTITY_DATA 

typedef union _IDE_IDENTITY_DATA {
    USHORT IdentityData[256];
    struct {
        USHORT Config;             // word 0
        USHORT Reserved1;          // word 1
        USHORT UniqueConfig;       // word 2
        USHORT Reserved3[7];       // word 3-9
        UCHAR  Serial[20];         // word 10-19
        USHORT Reserved20[3];      // word 20-22
        UCHAR  FirmwareRev[8];     // word 23-26
        UCHAR  ModelNumber[40];    // word 27-46
        USHORT Reserved47[2];      // word 47-48
        USHORT Capabilities;       // word 49
        USHORT Reserved50;         // word 50
        USHORT Obsolete[2];        // word 51-52
        USHORT Reserved53;         // word 53
        USHORT Reserved54[9];      // word 54-62
        USHORT MultiwordDma;       // word 63
        USHORT AdvancedPio;        // word 64
        USHORT CycleTimeDma;       // word 65
        USHORT CycleTimeMultiword; // word 66
        USHORT CycleTimePioNoIordy;// word 67
        USHORT CycleTimePioIordy;  // word 68
        USHORT Reserved69[2];      // word 69-70
        USHORT PacketTime;         // word 71
        USHORT ServiceTime;        // word 72
        USHORT Reserved73[2];      // word 73-74
        USHORT QueueDepth;         // word 75
        USHORT Reserved76[4];      // word 76-79
        USHORT MajorVersion;       // word 80
        USHORT MinorVersion;       // word 81
        USHORT CmdSetsSupported[3];// word 82-84
        USHORT CmdSetsEnabled[3];  // word 85-87
        USHORT UltraDma;           // word 88
        USHORT Reserved89[4];      // word 89-92
        USHORT ResetResult;        // word 93
        USHORT Reserved94[32];     // word 94-125
        USHORT ByteCount0Behavior; // word 126
        USHORT MsnSupport;         // word 127
        USHORT Security;           // word 128
        USHORT Vendor[31];         // word 129-159
        USHORT Reserved160[16];    // word 160-175
        USHORT Reserved176[79];    // word 176-254
        USHORT Integirty;          // word 255
    } PacketDeviceIdentity;
} IDE_IDENTITY_DATA, *PIDE_IDENTITY_DATA;

// LOG:PL 10/30/01
// 1. Added OnEjectButton()
// 2. Renamed ATA_HANDLERS to EMU_HANDLERS

typedef struct _EMU_HANDLERS {
    void  (__stdcall *OnEjectButton)(void);
    void  (__stdcall *OnBusReset)(void);
    ULONG (__stdcall *OnDeviceReset)(void);
    ULONG (__stdcall *OnIdentifyDevice)(PIDE_IDENTIFY_DATA);
    ULONG (__stdcall *OnATAPIPacket)(PATAPI_TRANSACTION);
} EMU_HANDLERS, *PEMU_HANDLERS;


// LOG:PL 10/31/01
// Added new type for states within the libaray

typedef struct _EMU_STATES {
    UCHAR TrayState;
    BOOL  ActivityState;
    BOOL  DmaEnabled;
    UCHAR DmaMode;
} EMU_STATES, *PEMU_STATES;

// LOG:PL 10/24/01
// Added SetDeviceActivityState()

// LOG:PL 10/31/01
// Added GetDeviceState()

HRESULT __stdcall StartEmulationConversation(PEMU_HANDLERS HandlingFunctions);
HRESULT __stdcall SetDeviceTrayState(UCHAR TrayState);
HRESULT __stdcall SetDeviceActivityState(BOOL ActivityState);
HRESULT __stdcall GetDeviceStates(PEMU_STATES DeviceStates);
HRESULT __stdcall EndEmulationConversation(void);

#endif // !AMC_MS_EMU_API__H
// ---------------------- End Of File ---------------------
// --------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\amc\AmcMsEmuApiError.h ===
#if !defined(AMC_MS_EMU_API_ERROR__H)
#define AMC_MS_EMU_API_ERROR__H


#include <WINERROR.H>


// Define a few custom error codes following WINERRORS.H:
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
#define MAKE_EMU_ERROR( code )    _HRESULT_TYPEDEF_( 0xE0000000L | code )
#define MAKE_EMU_WARNING( code )  _HRESULT_TYPEDEF_( 0xA0000000L | code )

#define EMU_NO_ERROR 0

// Use as close as possible to windows error codes. If nothing is close use
// codes between 0x8000 to 0x80ff.

// Warning: unexpected error druning EndEmulationConversation()
#define EMU_WARNING_ERROR_WHILE_ENDING_EMULATION  MAKE_EMU_WARNING(0x8000)

// This libray only suppose to work in Windows 2000
// environment.
#define EMU_ERR_BAD_WIN_VERSION   MAKE_EMU_ERROR(ERROR_OLD_WIN_VERSION)

// Invalid handle possible: 
// 1. driver not installed, 
// 2. another application is using the library
#define EMU_ERR_INVALID_HANDLE    MAKE_EMU_ERROR(ERROR_INVALID_HANDLE)

// Error in getting resources for the library.
#define EMU_ERR_NO_RESOURCES      MAKE_EMU_ERROR(ERROR_NO_SYSTEM_RESOURCES)

// Unexpected error response from driver.
#define EMU_ERR_DRIVER_ERROR      MAKE_EMU_ERROR(0x8001)

// Unexpected error response from hardware.
#define EMU_ERR_HARDWARE          MAKE_EMU_ERROR(0x8002)

// DVD is not responding possible cable disconnect or power to the Xbox is off
#define EMU_ERR_NO_DVD            MAKE_EMU_ERROR(0x8003)

// Unsupported hardware dectected
#define EMU_ERR_OUTDATED_HARDWARE MAKE_EMU_ERROR(0x8004)

// Request an operation when emulation has not started 
#define EMU_ERR_NOT_EMULATING     MAKE_EMU_ERROR(0x8005)

// Invalid parameter
#define EMU_ERR_INVALID_PARAMETER MAKE_EMU_ERROR(ERROR_INVALID_PARAMETER)


#endif // !AMC_MS_EMU_API_ERROR__H
// ---------------------- End Of File ---------------------
// --------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\emucore\emup.h ===
#include <windows.h>
#define DEVICE_TYPE ULONG
#include <inc\scsi.h>
#pragma warning(disable:4200)
#include <inc\ntdddisk.h>
#include <inc\ntddcdvd.h>
#include <AmcMsEmuApi.h>
#include <AmcMsEmuApiError.h>
#include <emucore.h>
#include <dvdx2.h>
#include "emudev.h"

#define DVDEMU_ADSENSE_READ_ERROR 0x11
#define DVDEMU_ADSENSE_PARAMETER_LIST_LENGTH 0x1A
#define DVDEMU_ADSENSE_INVALID_PARAMETER_FIELD 0x26
#define DVDEMU_ADSENSE_SAVING_NOT_SUPPORTED 0x39
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\emucore\emudev.h ===
/*
*/

#ifndef _EMUDEVICE_H
#define _EMUDEVICE_H

// Device functions
ULONG DeviceReadData(ULONG cblk, ULONG lba, PUCHAR pbData, PULARGE_INTEGER
    pluDelay);
BOOL DeviceReadCapacity(ULONG *plbaEnd, ULONG *pcbBlk);
BOOL DeviceReadControlData(BOOL fXControl, PUCHAR pb, ULONG cb,
	PULARGE_INTEGER pluDelay);
void DeviceReset(void);
void DeviceEject(void);
void DeviceSetSpindleSpeed(UCHAR n);
USHORT DeviceSelectPage(ULONG cb, PUCHAR pbData, PULARGE_INTEGER pluDelay);
USHORT DeviceSensePage(UCHAR bPage, ULONG cb, PUCHAR pbData,
    PULARGE_INTEGER pluDelay);

// Error reporting
void SetErrorSense(UCHAR b0, UCHAR b1, UCHAR b2);

// IDE
HRESULT StartIDE(void);
void StopIDE(void);

#endif // _EMUDEVICE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\dvdutil\xbpremaster\xbPremaster.cpp ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:      xbpremaster.cpp
// Contents:  Main entry point for the xbPremaster application
// Revisions: 31-May-2001: Created (jeffsim)
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// "stdafx.h"       -- Precompiled header file
#include "stdafx.h"


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ GLOBAL VARIABLES ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

char g_szDefaultFLD[MAX_PATH], g_szDefaultPKG[MAX_PATH], g_szDefaultOutputFile[MAX_PATH];
int g_iDefaultTapeDrive;
char g_szPackageExtractFolder[MAX_PATH];


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ FUNCTIONS +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  ParseCommandLine
// Purpose:   Determine what, if anything, the user specified on the command
//            line.
// Arguments: szCmdLine     -- The command line string.
// Return:    None
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void ParseCommandLine(char *szCmdLine)
{
    char *szToken;

    // Set defaults
    strcpy(g_szDefaultFLD, "");
    strcpy(g_szDefaultPKG, "");
    strcpy(g_szDefaultOutputFile, "");
    strcpy(g_szPackageExtractFolder, "");
    g_iDefaultTapeDrive = -1;

    // Create local copy so that the strtok doesn't destroy the passed-in string
    char szCmd[MAX_PATH * 2 + 10];
    strncpy(szCmd, szCmdLine, min(strlen(szCmdLine)+1, sizeof(szCmd)));

    if (*szCmd == '"')
        szToken = strtok(szCmd, "\"");
    else
        szToken = strtok(szCmd, " ");
    if (!szToken)
        return;

    char *szFileExt = szToken + strlen(szToken) - 4;
    if (!lstrcmpi(szFileExt, ".fld"))
        strcpy(g_szDefaultFLD, szToken);
    else if (!lstrcmpi(szFileExt, ".pkg"))
    {
        strcpy(g_szDefaultPKG, szToken);

        // If a PKG was specified, then a tape drive must have been specified, and
        // an output file may have been specified
        szToken = strtok(NULL, " ");
        if (!szToken)
            goto dumpusage;
        g_iDefaultTapeDrive = atoi(szToken);

        // User could have specified a default output log file
        szToken = strtok(NULL, " ");
        if (szToken)
        {
            strcpy(g_szDefaultOutputFile, szToken);

            // User could have specified a tempdir
            szToken = strtok(NULL, " ");
            if (szToken)
                strcpy(g_szPackageExtractFolder, szToken);
        }
    }
    else
    {
dumpusage:
        MessageBox(NULL, "xbPremaster Command Line options:\nxbPremaster.exe "
                         "[source fld or pkg file] [outputtape] [output "
                         "logfile] [tempdir]\n* If fld file is specified, outputtape, "
                         "logfile, and tempdir are ignored\n* If pkg file specified, "
                         "outputtape is mandatory, while logfile and tempdir are optional.\n"
                         "NOTE: Order must match above.",
                         "Invalid Command Line", MB_ICONEXCLAMATION | MB_OK);
        exit(-1);
    }
}

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  WinMain
// Purpose:   This is the default entry point into a Windows application.  When the application is
//            started, Windows calls into this function - when this function exits, the application
//            ends.  This function creates the Win32 class that represents this application, sets
//            up the Win32 Window in which the shell will be rendered, and then goes into the Win32
//            message loop that drives the application.
// Arguments: hinst         -- The handle to this instance of the application
//            hinstPrev     -- Obsolete; throwback to Win16 -- ignore
//            szCmdLine     -- Contains the parameter list passed to this application
//            nCmdShow      -- Default visibility of the application (maximized, minimized, etc)
// Return:    Value application returns to the operating system specifying result of execution.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
int APIENTRY WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR szCmdLine, int nCmdShow)
{
    // In this wizard-like application, program flow is contained in and controlled by objects
    // called 'steps'.  Each step represents a state of the program; the program can only be on
    // one step at any time.  A CStep contains the UI and processing code for the step.  The CStep
    // also determines which step should follow it.  The CDlg is the object which the step displays
    // it's UI on.

#ifndef _DEBUG   // Don't do exception handling on debug builds so that we can debug exceptions
    try
#endif
    {
        // Check if the user specified a source fld or pkg, and tape drive and output
        ParseCommandLine(szCmdLine);

        // Create the dialog box in which the steps will be displayed.
        CDlg *pdlg = new CDlg(hinst);
        if (!pdlg->IsInited())
            ReportError(ERROR_INIT);

        // Create the first step that the user will perform.
        CStep *pstepCur;
        if (g_iDefaultTapeDrive == -1)
            pstepCur = new CStep_UserAction(pdlg);
        else
            pstepCur = new CStep_DestSource(pdlg);

        if (!pstepCur->IsInited())
            ReportError(ERROR_INIT);

        // Loop over steps until the user chooses to exit the application or an error occurs
        while (pstepCur)
        {
            // Run the current step.  This will display its interface and handle user input and
            // processing.  The return value is the pointer to the next step to perform.  The
            // pointer will be NULL if there are no more steps to perform (ie the user exited the
            // app or an unrecoverable error happened in the CDlg::Run call)
            CStep *pstepNext = pdlg->Run(pstepCur);

            // Delete the current step and point to the next one
            delete pstepCur;
            pstepCur = pstepNext;
        }
    }
#ifndef _DEBUG
    catch(...)
    {
        // An unexpected error has occurred.  Report it to the user and exit
        ReportError(ERROR_UNEXPECTED);
    }
#endif

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\emucore\ide.cpp ===
/*
 *
 * ide.c
 *
 * IDE channel emulation
 *
 */

#include "emup.h"
#include <stdio.h>

static HANDLE hthrIDEWorker;
static HANDLE hevtIDEWorker;
static BOOL fTerminateIDE;
static BOOL fEmulationStarted;
static BOOL fEmulating;

typedef struct _ATAPKT {
    ULONG cbSize;
    HANDLE hevtDone;
    struct _ATAPKT *ppktNextFree;
} ATAPKT, *PATAPKT;

static PATAPKT ppktGlobal;
static PATAPKT ppktFree;
static CRITICAL_SECTION csFreeList;
static ULONG cpktsOutstanding;
static UCHAR rgbSenseData[4];

/* Standard packet responses */
static const UCHAR rgbReadTOC[] = {
	1, 1,
	0, 20, 1, 0, 0, 0, 2, 0,
	0, 20, 0xaa, 0, 0, 99, 59, 74
};

__inline __declspec(naked) static USHORT __fastcall SwapUshort(PUSHORT pus)
{
    _asm {
        xor eax, eax
        mov al, BYTE PTR [ecx + 1]
        mov ah, BYTE PTR [ecx]
        ret
    }
}

__inline __declspec(naked) static ULONG __fastcall SwapUlong(PULONG pul)
{
    _asm {
        xor eax, eax
        mov al, BYTE PTR [ecx + 1]
        mov ah, BYTE PTR [ecx]
        shl eax, 16
        mov al, BYTE PTR [ecx + 3]
        mov ah, BYTE PTR [ecx + 2]
        ret
    }
}


static void QueueForFree(PATAPKT ppkt)
{
    if(ppkt) {
        /* Put this packet on the free list */
        EnterCriticalSection(&csFreeList);
        ppkt->ppktNextFree = ppktFree;
        ppktFree = ppkt;
        LeaveCriticalSection(&csFreeList);

        /* Make sure the worker thread knows that there's work to do */
        SetEvent(hevtIDEWorker);
    }
}

static PATAPKT PpktAcquirePacket(ULONG cb)
{
    PATAPKT ppkt;

    /* If we have a global packet that's not in use, we'll use it */
    ppkt = (PATAPKT)InterlockedExchange((PLONG)&ppktGlobal, NULL);
    if(ppkt) {
        if(WaitForSingleObject(ppkt->hevtDone, 0) == WAIT_TIMEOUT) {
            /* In use.  Queue it for free and get a new packet */
            QueueForFree(ppkt);
            ppkt = NULL;
        } else if(cb > ppkt->cbSize) {
            /* Too small.  Free it and get a new packet */
            CloseHandle(ppkt->hevtDone);
            LocalFree(ppkt);
            InterlockedDecrement((PLONG)&cpktsOutstanding);
            ppkt = NULL;
        }
    }

    if(!ppkt) {
        /* No good packet so far.  Allocate a new one, unless we've been told
         * to stop allocating */
        if(!fEmulating)
            return NULL;
        ppkt = (PATAPKT)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
			cb + sizeof *ppkt);
        if(!ppkt)
            return NULL;
        ppkt->hevtDone = CreateEvent(NULL, FALSE, FALSE, NULL);
        if(!ppkt) {
            LocalFree(ppkt);
            return NULL;
        }
        ppkt->cbSize = cb;
        InterlockedIncrement((PLONG)&cpktsOutstanding);
    }

    /* This packet is acceptable.  Make it global and send back the data
     * pointer */
    QueueForFree((PATAPKT)InterlockedExchange((PLONG)&ppktGlobal, (LONG)ppkt));
    return ppkt;
}

static PVOID PvFromPpkt(PATAPKT ppkt)
{
    return ppkt + 1;
}

void SetErrorSense(UCHAR b0, UCHAR b1, UCHAR b2)
{
    rgbSenseData[0] = b0;
    rgbSenseData[1] = b1;
    rgbSenseData[2] = b2;
    rgbSenseData[3] = 0;
}

static void SetUnexpectedErrorSense(void)
{
    SetErrorSense(SCSI_SENSE_HARDWARE_ERROR, 0, 0);
}

static void SetTransactionResponse(PATAPI_TRANSACTION ptrans, PATAPKT ppkt)
{
    ptrans->Response = (PUCHAR)PvFromPpkt(ppkt);
    ptrans->ResponseEvent = ppkt->hevtDone;
    SetErrorSense(0, 0, 0);
}

static void PrepareStockResponse(PATAPI_TRANSACTION ptrans, const UCHAR *pbResp,
	ULONG cb)
{
	PUCHAR pb;
	PATAPKT ppkt;
	USHORT us;

	ppkt = PpktAcquirePacket(cb + 2);
	pb = (PUCHAR)PvFromPpkt(ppkt);
	if(pbResp)
		memcpy(pb + 2, pbResp, cb);
	else
		memset(pb + 2, 0, cb);
	us = (USHORT)cb;
	us = SwapUshort(&us);
	memcpy(pb, &us, sizeof us);
	ptrans->ResponseSize = cb + 2;
	SetTransactionResponse(ptrans, ppkt);
}

static ULONG HandleATAPIPacket(PATAPI_TRANSACTION ptrans)
{
    PATAPKT ppkt;
    PMODE_PARAMETER_HEADER10 ph10;
    PDVDX2_ADVANCED_DRIVE_CONTROL_PAGE padcp;
    PSENSE_DATA psense;
    PREAD_CAPACITY_DATA pcap;
    int cblk;
    DWORD cb;
    USHORT us;
    PUCHAR pb;
	BOOL fXControl;

    ptrans->ResponseDelay.QuadPart = 0;
    switch(ptrans->CommandBlock.Cdb.CDB6GENERIC.OperationCode) {
    case SCSIOP_MODE_SENSE10:
        /* We only support a PC of 0 */
        if(ptrans->CommandBlock.Cdb.MODE_SENSE10.Pc != 0) {
            SetErrorSense(SCSI_SENSE_ILLEGAL_REQUEST,
                DVDEMU_ADSENSE_SAVING_NOT_SUPPORTED, 0);
            return HANDLER_RETURN_ERROR;
        }

        /* Figure out how much data we're expected to return and make sure
         * it's enough to at least include the parameter header */
        ptrans->ResponseSize =
            SwapUshort((PUSHORT)ptrans->CommandBlock.Cdb.MODE_SENSE10.AllocationLength);
        if(ptrans->ResponseSize < sizeof *ph10) {
            SetErrorSense(SCSI_SENSE_ILLEGAL_REQUEST,
                DVDEMU_ADSENSE_PARAMETER_LIST_LENGTH, 0);
            return HANDLER_RETURN_ERROR;
        }

        /* Get a buffer */
        ppkt = PpktAcquirePacket(ptrans->ResponseSize);

        /* Fill in the mode page data */
        ph10 = (PMODE_PARAMETER_HEADER10)PvFromPpkt(ppkt);
        memset(ph10, 0, sizeof *ph10);
        us = DeviceSensePage(ptrans->CommandBlock.Cdb.MODE_SENSE10.PageCode,
            ptrans->ResponseSize - sizeof *ph10, (PUCHAR)(ph10 + 1),
            &ptrans->ResponseDelay);

        /* Send back the data we have */
        if(us) {
            us += sizeof *ph10 - 2;
            us = SwapUshort(&us);
            memcpy(ph10->ModeDataLength, &us, sizeof us);
            SetTransactionResponse(ptrans, ppkt);
            return HANDLER_RETURN_DATA;
        }

        /* No data, so return an error */
        SetEvent(ppkt->hevtDone);
        return HANDLER_RETURN_ERROR;

    case SCSIOP_MODE_SELECT10:
        /* Make sure we have enough data */
        us = SwapUshort((PUSHORT)&ptrans->CommandBlock.Cdb.MODE_SELECT10.ParameterListLength);
        if(ptrans->DataSize < us || us < sizeof *ph10) {
            SetErrorSense(SCSI_SENSE_ILLEGAL_REQUEST,
                DVDEMU_ADSENSE_PARAMETER_LIST_LENGTH, 0);
            return HANDLER_RETURN_ERROR;
        }

        /* Find the mode parameter header and make sure we have as much
         * data as it demands */
        ph10 = (PMODE_PARAMETER_HEADER10)ptrans->Data;
        cb = SwapUshort((PUSHORT)ph10->ModeDataLength);
        if(us < cb) {
            SetErrorSense(SCSI_SENSE_ILLEGAL_REQUEST,
                DVDEMU_ADSENSE_PARAMETER_LIST_LENGTH, 0);
            return HANDLER_RETURN_ERROR;
        }
        cb -= sizeof *ph10 - 2;
        pb = (PUCHAR)(ph10 + 1);

        /* Now loop over all of the mode pages present and satisfy as many
         * as we can */
        while(cb) {
            /* Require PS to be 0 */
            if(*pb & 0xC0) {
                SetErrorSense(SCSI_SENSE_ILLEGAL_REQUEST,
                    DVDEMU_ADSENSE_SAVING_NOT_SUPPORTED, 0);
                return HANDLER_RETURN_ERROR;
            }

            us = DeviceSelectPage(cb, pb, &ptrans->ResponseDelay);
            if(!us)
                /* We got an error of some sort, so bail */
                return HANDLER_RETURN_ERROR;

            /* Devour the page data and move on */
            cb -= us;
            pb += us;
        }
        return 0;

    case SCSIOP_REQUEST_SENSE:
        ppkt = PpktAcquirePacket(sizeof(SENSE_DATA));
        if(!ppkt) {
            SetUnexpectedErrorSense();
            return HANDLER_RETURN_ERROR;
        }
        psense = (PSENSE_DATA)PvFromPpkt(ppkt);
        memset(psense, 0, sizeof *psense);

        /* Fill in the sense data we have */
        psense->SenseKey = rgbSenseData[0];
        psense->AdditionalSenseCode = rgbSenseData[1];
        psense->AdditionalSenseCodeQualifier = rgbSenseData[2];
        if(rgbSenseData[3])
            psense->IncorrectLength = -1;

        /* Send it back */
        ptrans->ResponseSize = sizeof *psense;
        SetTransactionResponse(ptrans, ppkt);
        return HANDLER_RETURN_DATA;

    case SCSIOP_READ:
        /* Assume that we need a packet big enough to return the requested
         * data */
        cblk = SwapUshort((PUSHORT)&ptrans->CommandBlock.Cdb.CDB10.TransferBlocks);
        ppkt = PpktAcquirePacket(2048 * cblk);
        if(!ppkt) {
            SetUnexpectedErrorSense();
            return HANDLER_RETURN_ERROR;
        }

        /* Now ask the device to satisfy the request.  If it encounters an
         * error, it will set the sense data */
        ptrans->ResponseSize = DeviceReadData(cblk,
            SwapUlong(&ptrans->CommandBlock.Cdb.CDB10.LogicalBlock),
            (PUCHAR)PvFromPpkt(ppkt), &ptrans->ResponseDelay);
        if(ptrans->ResponseSize) {
            /* We got back data, so return it */
            SetTransactionResponse(ptrans, ppkt);
            return HANDLER_RETURN_DATA;
        }

        /* If we got here, there was an error.  We need to release the packet
         * and signal the error */
        SetEvent(ppkt->hevtDone);
        return HANDLER_RETURN_ERROR;

    case SCSIOP_READ_CD:
        /* We don't support CD data */
        SetErrorSense(SCSI_SENSE_ILLEGAL_REQUEST,
            SCSI_ADSENSE_INVALID_MEDIA, SCSI_SENSEQ_INCOMPATIBLE_FORMAT);
        return HANDLER_RETURN_ERROR;

    case SCSIOP_READ_DVD_STRUCTURE:
		switch(ptrans->CommandBlock.Cdb.READ_DVD_STRUCTURE.Format) {
		case 0:
			/* Physical data.  Get either the control or xcontrol frame */
			cblk = SwapUlong((PULONG)ptrans->CommandBlock.Cdb.READ_DVD_STRUCTURE.RMDBlockNumber);
	        if((ptrans->CommandBlock.Cdb.READ_DVD_STRUCTURE.Control & 0xC0) ==
				0xC0 && (UCHAR)ptrans->CommandBlock.Cdb.READ_DVD_STRUCTURE.LayerNumber ==
				(UCHAR)~DVDX2_CONTROL_DATA_LAYER && cblk ==
				~DVDX2_CONTROL_DATA_BLOCK_NUMBER)
			{
				fXControl = TRUE;
			} else if((UCHAR)ptrans->CommandBlock.Cdb.READ_DVD_STRUCTURE.LayerNumber ==
				0 && cblk == 0)
			{
				fXControl = FALSE;
			} else {
				SetErrorSense(SCSI_SENSE_ILLEGAL_REQUEST,
					SCSI_ADSENSE_INVALID_CDB, 0);
	            return HANDLER_RETURN_ERROR;
			}

			/* Allocate a packet for the control data frame */
			us = SwapUshort((PUSHORT)ptrans->CommandBlock.Cdb.READ_DVD_STRUCTURE.AllocationLength);
			ppkt = PpktAcquirePacket(us);
			pb = (PUCHAR)PvFromPpkt(ppkt);
			memset(pb, 0, 4);
		
			/* Fill in the control data */
			if(DeviceReadControlData(fXControl, pb + 4, us - 4,
				&ptrans->ResponseDelay))
			{
				/* Send back the data */
				ptrans->ResponseSize = us;
				SetTransactionResponse(ptrans, ppkt);
				us -= 2;
				us = SwapUshort(&us);
				memcpy(ptrans->Response, &us, 2);
				return HANDLER_RETURN_DATA;
			}

			/* If we got here, there was an error.  We need to release the
			 * packet */
			SetEvent(ppkt->hevtDone);

			break;

		case 1:
			/* Read copyright info */
			PrepareStockResponse(ptrans, NULL, 6);
			return HANDLER_RETURN_DATA;

		default:
			/* Unknown request */
			SetErrorSense(SCSI_SENSE_ILLEGAL_REQUEST,
				SCSI_ADSENSE_INVALID_CDB, 0);
			break;
		}

		return HANDLER_RETURN_ERROR;

    case SCSIOP_READ_TOC:
		PrepareStockResponse(ptrans, rgbReadTOC, sizeof rgbReadTOC);
        return HANDLER_RETURN_DATA;

    case SCSIOP_TEST_UNIT_READY:
        SetErrorSense(0, 0, 0);
        return 0;

    case SCSIOP_READ_CAPACITY:
        /* First assume we have to return some data */
        ppkt = PpktAcquirePacket(sizeof(READ_CAPACITY_DATA));
        if(!ppkt) {
            SetUnexpectedErrorSense();
            return HANDLER_RETURN_ERROR;
        }
        pcap = (PREAD_CAPACITY_DATA)PvFromPpkt(ppkt);
        /* Ask the device how many blocks it has.  If no media is present,
         * the device will indicate an error */
        if(DeviceReadCapacity(&pcap->LogicalBlockAddress,
            &pcap->BytesPerBlock))
        {
            pcap->LogicalBlockAddress = SwapUlong(&pcap->LogicalBlockAddress);
            pcap->BytesPerBlock = SwapUlong(&pcap->BytesPerBlock);
            ptrans->ResponseSize = sizeof *pcap;
            SetTransactionResponse(ptrans, ppkt);
            return HANDLER_RETURN_DATA;
        }

        /* We've had an error, so clean up */
        SetEvent(ppkt->hevtDone);
        return HANDLER_RETURN_ERROR;

    case SCSIOP_REPORT_KEY:
		/* Always return an AGID of zero */
		PrepareStockResponse(ptrans, NULL, 6);
		return HANDLER_RETURN_DATA;

    case SCSIOP_SEND_KEY:
		/* Accept everything */
		SetErrorSense(0, 0, 0);
		return 0;

    default:
        SetErrorSense(SCSI_SENSE_ILLEGAL_REQUEST,
            SCSI_ADSENSE_ILLEGAL_COMMAND, 0);
        return HANDLER_RETURN_ERROR;
    }
}

static void HandleBusReset(void)
{
    DeviceReset();
}

static ULONG HandleDeviceReset(void)
{
    HandleBusReset();
    return 0;
}

static ULONG HandleIdentifyDevice(PIDE_IDENTIFY_DATA pidd)
{
    /* TODO: IdentifyDevice */
    memset(pidd, 0, sizeof *pidd);
    return HANDLER_RETURN_DATA;
}

static DWORD WINAPI IDEWorkerThread(LPVOID unused)
{
    HANDLE rghevt[MAXIMUM_WAIT_OBJECTS];
    PATAPKT rgppkt[MAXIMUM_WAIT_OBJECTS - 1];
    int cpkt;
    PATAPKT ppkt;
    int ihevt;

    rghevt[0] = hevtIDEWorker;
    cpkt = 0;

    while(!fTerminateIDE || cpktsOutstanding) {
        /* Wait for something to do */
        ihevt = WaitForMultipleObjects(cpkt + 1, rghevt, FALSE, INFINITE) -
            WAIT_OBJECT_0;
        if(ihevt == 0) {
            /* We've got work to do.  Walk the free list and add everything on
             * it to the work list.  If we're terminating, make sure the
             * active packet shows up on the free list */
            EnterCriticalSection(&csFreeList);
            if(!fEmulating)
                QueueForFree((PATAPKT)InterlockedExchange((PLONG)&ppktGlobal,
                    NULL));
            ppkt = ppktFree;
            while(ppkt && cpkt < MAXIMUM_WAIT_OBJECTS - 1) {
                rgppkt[cpkt] = ppkt;
                rghevt[++cpkt] = ppkt->hevtDone;
                ppkt = ppkt->ppktNextFree;
            }
            ppktFree = ppkt;
            LeaveCriticalSection(&csFreeList);
        } else {
            /* One of our packets is no longer in use.  Free it */
            CloseHandle(rghevt[ihevt]);
            rghevt[ihevt--] = rghevt[cpkt--];
            LocalFree(rgppkt[ihevt]);
            rgppkt[ihevt] = rgppkt[cpkt];
            InterlockedDecrement((PLONG)&cpktsOutstanding);
        }
    }

    return 0;
}

static EMU_HANDLERS Handlers = {
    DeviceEject,
    HandleBusReset,
    HandleDeviceReset,
    HandleIdentifyDevice,
    HandleATAPIPacket
};

void StopIDEWorker(void)
{
    /* Callers should make sure we actually have a valid, active worker
     * thread */
    fTerminateIDE = TRUE;
    SetEvent(hevtIDEWorker);
    WaitForSingleObject(hthrIDEWorker, INFINITE);
    CloseHandle(hevtIDEWorker);
    CloseHandle(hthrIDEWorker);
    DeleteCriticalSection(&csFreeList);
}

HRESULT StartIDE(void)
{
    HRESULT hr;

    for(;;) {
        if(!InterlockedExchange((PLONG)&fEmulationStarted, TRUE)) {
            /* Spin up a worker thread */
            fTerminateIDE = FALSE;
            InitializeCriticalSection(&csFreeList);
            hevtIDEWorker = CreateEvent(NULL, FALSE, FALSE, NULL);
            if(!hevtIDEWorker) {
                hr = E_OUTOFMEMORY;
                break;
            }
            hthrIDEWorker = CreateThread(NULL, 0, IDEWorkerThread, NULL, 0,
                NULL);
            if(!hthrIDEWorker) {
                hr = E_OUTOFMEMORY;
                break;
            }
            /* Try to start the IDE emulator */
            hr = StartEmulationConversation(&Handlers);
            if(FAILED(hr)) {
                StopIDEWorker();
                fEmulationStarted = FALSE;
                return hr;
            }
            fEmulating = TRUE;
            return S_OK;
        } else {
            /* Somebody else started emulation already.  If it's already
             * running, we return that it's already running.  If not, we
             * wait until either it's running or the previous start attempt
             * is complete */
            if(fEmulating)
                return E_INVALIDARG;
            Sleep(100);
        }
    }

    /* We failed to start.  Clean up */
    if(hevtIDEWorker)
        CloseHandle(hevtIDEWorker);
    DeleteCriticalSection(&csFreeList);
    fEmulationStarted = FALSE;
    return hr;
}

void StopIDE(void)
{
    if(InterlockedExchange((PLONG)&fEmulating, FALSE)) {
        EndEmulationConversation();
        StopIDEWorker();
        fEmulationStarted = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\gamedisc\emucore\device.cpp ===
/*
 *
 * device.cpp
 *
 * Device emulation
 *
 */

#include "emup.h"
#include <stdio.h>

enum {
    TRAYSTATE_CLOSED,
    TRAYSTATE_OPEN,
    TRAYSTATE_UNLOADING,
    TRAYSTATE_OPENING,
    TRAYSTATE_NOMEDIA,
    TRAYSTATE_CLOSING,
    TRAYSTATE_DETECT,
    TRAYSTATE_RESET
};

// Traystate Request Queue
typedef struct _TRQ {
    struct _TRQ *ptrqNext;
    int nTrayState;
    CEmulationFilesystem *pfsys;
    HANDLE hevt;
    HRESULT hr;
} TRQ, *PTRQ;

// Global details
static CEmulationFilesystem *g_pfsys, *g_pfsysDiscInsert;
static BOOL fStartedEmulation, fEmulationRunning, fTerminate;
static HANDLE hthrTray;
static HANDLE hevtTrayQ;
static HANDLE hevtEject;
static HANDLE hevtTrayTimer;
static HANDLE hevtTerminateEmulation;
static int nTrayState;
static CRITICAL_SECTION csFsys, csTray;
static BOOL fHaveCSTray;
static PTRQ ptrqHead, *pptrqTail;
static UCHAR nSpindleSpeed;

// Filesystem data
static PHYSICAL_GEOMETRY geom;
static DVDX2_AUTHENTICATION_PAGE dvdx2page;

static ULONG PsnFromLba(ULONG lba)
{
    ULONG psn;

    EnterCriticalSection(&csFsys);
    if(g_pfsys) {
        if(lba < geom.Layer0SectorCount)
            psn = geom.Layer0StartPSN + lba;
        else {
            lba -= geom.Layer0SectorCount;
            if(lba < geom.Layer1SectorCount)
                psn = 0x1000000 - geom.Layer0SectorCount -
                    geom.Layer0StartPSN + lba;
            else
                psn = 0;
        }
    } else
        psn = 0;
    LeaveCriticalSection(&csFsys);

    return psn;
}

void AccumulateSeekDelay(ULONG psn, PULARGE_INTEGER pluDelay)
{
    pluDelay->QuadPart = 0;
}

BOOL DefaultControlData(PUCHAR pb, ULONG cb, PULARGE_INTEGER pluDelay)
{
	return FALSE;
}

BOOL DefaultChallengeResponse(UCHAR id, PULONG pluChallenge,
    PULONG pluResponse, PULARGE_INTEGER pluDelay)
{
    pluDelay->QuadPart = 0;
    return FALSE;
}

static void NoMediaError(void)
{
    switch(nTrayState) {
    case TRAYSTATE_DETECT:
        SetErrorSense(SCSI_SENSE_NOT_READY,
            SCSI_ADSENSE_NO_MEDIA_IN_DEVICE, 0);
        break;
    default:
        SetErrorSense(SCSI_SENSE_NOT_READY, SCSI_ADSENSE_LUN_NOT_READY, 0);
        break;
    }
}

BOOL DeviceReadCapacity(ULONG *plbaEnd, ULONG *pcbBlk)
{
    BOOL fRet;

    EnterCriticalSection(&csFsys);
    if(g_pfsys) {
        *plbaEnd = geom.Layer0SectorCount + geom.Layer1SectorCount;
        *pcbBlk = 2048;
        fRet = TRUE;
    } else {
        NoMediaError();
        fRet = FALSE;
    }
    LeaveCriticalSection(&csFsys);
    return fRet;
}

ULONG DeviceReadData(ULONG cblk, ULONG lba, PUCHAR pbData, PULARGE_INTEGER
    pluDelay)
{
    ULONG psn;
    int err;
    ULONG cbRet = 0;
    ULARGE_INTEGER luDelay;
    ULONG iblk;

    pluDelay->QuadPart = 0;
    EnterCriticalSection(&csFsys);
    if(g_pfsys) {
        /* Make sure we're looking at the right partition.  If we're emulating
         * X2 and we haven't switched partitions yet, then we'll return
         * LBA out of range if the filesystem doesn't contain the standard
		 * video partition */
        if(dvdx2page.CDFValid && !dvdx2page.PartitionArea &&
			!geom.SupportsMultiplePartitions)
		{
            err = EMU_ERR_INVALID_LSN;
        } else {
            /* Loop over the PSNs of this request and accumulate read delay
             * times.  As we hit every PSN, we'll also check for placeholder
             * or out-of-bounds reads */
#if 0
            err = nSpindleSpeed < 2 ? EMU_ERR_SUCCESS :
                EMU_ERR_UNEXPECTED_ERROR;
#endif
            err = EMU_ERR_SUCCESS;
            for(iblk = 0; iblk < cblk; ++iblk) {
                psn = PsnFromLba(lba + iblk);
                if(psn == 0)
                    err = EMU_ERR_INVALID_LSN;
                else // placholders NYI
                {
                    AccumulateSeekDelay(psn, &luDelay);
                    pluDelay->QuadPart += luDelay.QuadPart;
                }
                if(err != EMU_ERR_SUCCESS)
                    break;
            }
        }

        /* If all is successful so far, we issue the read request to the
         * filesystem */
        if(err == EMU_ERR_SUCCESS)
            err = g_pfsys->GetSectorData(lba, cblk, pbData);
        if(err == EMU_ERR_SUCCESS)
            cbRet = cblk * 2048;
        else {
            cbRet = 0;
            switch(err) {
            case EMU_ERR_UNEXPECTED_ERROR:
                /* 2-sec read error, then fail */
                pluDelay->QuadPart = 2 * 1000 * 10000;
                SetErrorSense(SCSI_SENSE_MEDIUM_ERROR,
                    DVDX2_ADSENSE_GENERAL_READ_ERROR, 0);
                break;
            case EMU_ERR_PLACEHOLDER:
                pluDelay->QuadPart = 0;    
                SetErrorSense(SCSI_SENSE_ILLEGAL_REQUEST,
                    DVDX2_ADSENSE_COMMAND_ERROR, 0);
                break;
            case EMU_ERR_INVALID_LSN:
                pluDelay->QuadPart = 0;    
                SetErrorSense(SCSI_SENSE_ILLEGAL_REQUEST,
                    SCSI_ADSENSE_ILLEGAL_BLOCK, 0);
                break;
            }
        }
    } else {
        NoMediaError();
        cbRet = 0;
    }
    LeaveCriticalSection(&csFsys);

    return cbRet;
}

BOOL DeviceReadControlData(BOOL fXControl, PUCHAR pb, ULONG cb,
	PULARGE_INTEGER pluDelay)
{
	BOOL fRet = FALSE;

	EnterCriticalSection(&csFsys);
	if(g_pfsys) {
		if(geom.IsX2Disc) {
			if(g_pfsys->GetControlData(fXControl, pb, cb, pluDelay))
				fRet = TRUE;
			else {
				SetErrorSense(SCSI_SENSE_MEDIUM_ERROR,
					DVDEMU_ADSENSE_READ_ERROR, 0);
			}
		} else {
			SetErrorSense(SCSI_SENSE_ILLEGAL_REQUEST,
				SCSI_ADSENSE_INVALID_MEDIA, SCSI_SENSEQ_INCOMPATIBLE_FORMAT);
		}
	} else
		NoMediaError();
	LeaveCriticalSection(&csFsys);

	return fRet;
}

static void SetTrayState(int nState)
{
    if(fEmulationRunning) {
        SetDeviceTrayState((UCHAR)nState);
		nTrayState = nState;
	}
}

static void FinishMediaDetect(void)
{
    /* Reset to the fast spindle speed */
    nSpindleSpeed = 2;

    /* Build up the DVDX2 authentication page */
    memset(&dvdx2page, 0, sizeof dvdx2page);
    dvdx2page.PageCode = DVDX2_MODE_PAGE_AUTHENTICATION;
    dvdx2page.PageLength = sizeof dvdx2page - 2;
    dvdx2page.DrivePhaseLevel = 1;

    if(g_pfsys) {
        g_pfsys->GetPhysicalGeometry(&geom, FALSE);
        dvdx2page.DiscCategoryAndVersion = 0xD1;
        if(geom.IsX2Disc)
            dvdx2page.CDFValid = TRUE;
    }
}

USHORT DeviceSelectPage(ULONG cb, PUCHAR pbData, PULARGE_INTEGER pluDelay)
{
    USHORT cbRet = 0;
    DVDX2_AUTHENTICATION_PAGE dvdx2pageSelect;

    switch(*pbData & 0x3F) {
    case DVDX2_MODE_PAGE_AUTHENTICATION:
        EnterCriticalSection(&csFsys);
        if(g_pfsys) {
            /* Make sure we've got enough data here */
            if(pbData[1] + 2 < sizeof dvdx2pageSelect) {
                SetErrorSense(SCSI_SENSE_ILLEGAL_REQUEST,
                    DVDEMU_ADSENSE_PARAMETER_LIST_LENGTH, 0);
			} else if(!geom.IsX2Disc) {
				SetErrorSense(SCSI_SENSE_ILLEGAL_REQUEST,
					SCSI_ADSENSE_INVALID_MEDIA,
					SCSI_SENSEQ_INCOMPATIBLE_FORMAT);
            } else {
                memcpy(&dvdx2pageSelect, pbData, sizeof dvdx2pageSelect);
                /* Attempt to do a challenge */
                if(dvdx2page.PartitionArea) {
                    /* We've already switched to the Xbox partition, so no
                     * further authentication is permitted */
                    SetErrorSense(SCSI_SENSE_ILLEGAL_REQUEST,
                        DVDX2_ADSENSE_COPY_PROTECTION_FAILURE, 2);
                } else {
                    cbRet = pbData[1] + 2;
                    /* Either this is simply a request to change to the Xbox
                     * partition or we're actually going to do a challenge */
                    if(!dvdx2pageSelect.PartitionArea &&
                        !g_pfsys->DiscChallengeResponse(dvdx2pageSelect.ChallengeID,
                        &dvdx2pageSelect.ChallengeValue,
                        &dvdx2page.ResponseValue, pluDelay))
                    {
                        SetErrorSense(SCSI_SENSE_ILLEGAL_REQUEST,
                            DVDX2_ADSENSE_COPY_PROTECTION_FAILURE, 3);
                        cbRet = 0;
                    }

                    /* If we didn't fail the authentication, then we copy the
                     * authentication and partition flags to the global page */
                    if(cbRet) {
                        dvdx2page.Authentication =
                            dvdx2pageSelect.Authentication;
						if(geom.SupportsMultiplePartitions &&
							dvdx2page.PartitionArea !=
							dvdx2pageSelect.PartitionArea)
						{
							/* We're switching partitions on a multi-partition
							 * filesystem, so we need to process the geometry
							 * for the new partition */
							g_pfsys->GetPhysicalGeometry(&geom,
								dvdx2pageSelect.PartitionArea);
	                        dvdx2page.PartitionArea =
		                        dvdx2pageSelect.PartitionArea;
						}
                    }
                }
            }
        } else
            /* Return no media */
            NoMediaError();
        LeaveCriticalSection(&csFsys);
        break;

    case DVDX2_MODE_PAGE_ADVANCED_DRIVE_CONTROL:
        if(pbData[1] < 10 || cb < 12) {
            /* Not enough data */
            SetErrorSense(SCSI_SENSE_ILLEGAL_REQUEST,
                DVDEMU_ADSENSE_PARAMETER_LIST_LENGTH, 0);
        } else if(pbData[2] > 2) {
            /* Invalid spindle speed */
            SetErrorSense(SCSI_SENSE_ILLEGAL_REQUEST,
                DVDEMU_ADSENSE_INVALID_PARAMETER_FIELD, 0);
        } else {
            nSpindleSpeed = pbData[2];
            cbRet = pbData[1] + 2;
        }
        break;

    default:
        /* Not a page we recognize, so return an error */
        SetErrorSense(SCSI_SENSE_ILLEGAL_REQUEST,
            DVDEMU_ADSENSE_INVALID_PARAMETER_FIELD, 0);
        break;

    }

    return cbRet;
}

USHORT DeviceSensePage(UCHAR bPage, ULONG cb, PUCHAR pbData,
    PULARGE_INTEGER pluDelay)
{
    USHORT cbRet = 0;

    switch(bPage) {
    case DVDX2_MODE_PAGE_AUTHENTICATION:

        EnterCriticalSection(&csFsys);
        if(g_pfsys) {
            /* Make sure we have enough space for the data returned */
            if(cb < sizeof dvdx2page) {
                SetErrorSense(SCSI_SENSE_ILLEGAL_REQUEST,
                    DVDEMU_ADSENSE_PARAMETER_LIST_LENGTH, 0);
            } else {
                /* Copy the mode page data */
                memcpy(pbData, &dvdx2page, sizeof dvdx2page);
                cbRet = sizeof dvdx2page;
            }
        } else
            /* Return no media */
            NoMediaError();
        LeaveCriticalSection(&csFsys);
        break;

    default:
        /* Not a page we recognize, so return an error */
        SetErrorSense(SCSI_SENSE_ILLEGAL_REQUEST,
            DVDEMU_ADSENSE_INVALID_PARAMETER_FIELD, 0);
        break;

    }

    return cbRet;
}

void DeviceReset(void)
{

}

void DeviceEject(void)
{
    EnterCriticalSection(&csTray);
    if(fEmulationRunning)
        SetEvent(hevtEject);
    LeaveCriticalSection(&csTray);
}

static void ChangeTrayState(int nState)
{
    DWORD tickStart;
    DWORD dtickDelay;
	LARGE_INTEGER liTimer;

    /* Change the tray state and invoke the appropriate timer */
    tickStart = GetTickCount();

    switch(nState) {
    case TRAYSTATE_OPEN:
        /* We're going to open the tray.  If we have media loaded, unload it
         * first, otherwise open the tray immediately */
        EnterCriticalSection(&csFsys);
        if(g_pfsys) {
            g_pfsys->MountUnmount(FALSE);
            g_pfsys = NULL;
            nState = TRAYSTATE_UNLOADING;
        } else
            nState = TRAYSTATE_OPENING;
        LeaveCriticalSection(&csFsys);
        break;

    case TRAYSTATE_CLOSED:
        /* We're going to close the tray, so begin the close */
        nState = TRAYSTATE_CLOSING;
        break;

    case -1:
        /* We're going to follow the complete state machine */
        switch(nTrayState) {
        case TRAYSTATE_OPENING:
            nState = TRAYSTATE_OPEN;
            break;

        case TRAYSTATE_CLOSING:
            nState = TRAYSTATE_CLOSED;
            break;

        case TRAYSTATE_UNLOADING:
            nState = TRAYSTATE_OPENING;
            break;

        case TRAYSTATE_CLOSED:
            /* Check to see whether we have media and signal appropriately */
            if(g_pfsysDiscInsert) {
                nState = TRAYSTATE_DETECT;
                EnterCriticalSection(&csFsys);
                g_pfsys = g_pfsysDiscInsert;
                g_pfsys->MountUnmount(TRUE);
                FinishMediaDetect();
                LeaveCriticalSection(&csFsys);
            } else
                nState = TRAYSTATE_NOMEDIA;
            break;
        }
        break;

    default:
        /* No other state changes are acceptable */
        nState = -1;
        break;
    }

    if(nState >= 0) {
        /* Switch to the new state and set a timer to force another state
         * change later if necessary */
        switch(nState) {
        case TRAYSTATE_OPENING:
        case TRAYSTATE_CLOSING:
            /* One second tray motion */
            dtickDelay = 1000;
            break;
        case TRAYSTATE_UNLOADING:
            /* Half-second unload time */
            dtickDelay = 500;
            break;
        case TRAYSTATE_CLOSED:
            /* Four seconds for media detect */
            dtickDelay = 4000;
            break;
        default:
            /* No more changes for other states */
            dtickDelay = 0;
            break;
        }
        CancelWaitableTimer(hevtTrayTimer);
        ResetEvent(hevtTrayTimer);
        if(dtickDelay) {
			liTimer.QuadPart = dtickDelay;
			liTimer.QuadPart *= -10000;
            SetWaitableTimer(hevtTrayTimer, &liTimer, 0, NULL, NULL, TRUE);
        }
        SetTrayState(nState);

        /* After any state change, if there's a tray request in the queue,
         * we need to try to process it */
        if(ptrqHead)
            SetEvent(hevtTrayQ);
    }
}

static void SatisfyTrq(PTRQ ptrq, HRESULT hr)
{
    if(ptrq->hevt) {
        ptrq->hr = hr;
        SetEvent(ptrq->hevt);
    } else
        LocalFree(ptrq);
}

static DWORD WINAPI TrayStateThread(LPVOID unused)
{
    int ievt;
    HANDLE rgh[4];
    CEmulationFilesystem *pfsysDetect;
    BOOL fTrayOpen;
    PTRQ ptrq;
    HRESULT hr;

    rgh[0] = hevtTerminateEmulation;
    rgh[1] = hevtEject;
    rgh[2] = hevtTrayQ;
    rgh[3] = hevtTrayTimer;

    /* We need to avoid blocking on csTray in this function or we could
     * deadlock */
    for(;;) {
        ievt = fTerminate ? WAIT_OBJECT_0 : WaitForMultipleObjects(4, rgh,
            FALSE, INFINITE);
        switch(ievt) {
        case WAIT_OBJECT_0 + 1:
            /* Eject button got pressed */
            switch(nTrayState) {
            case TRAYSTATE_OPENING:
            case TRAYSTATE_OPEN:
                ChangeTrayState(TRAYSTATE_CLOSED);
                break;
            default:
                ChangeTrayState(TRAYSTATE_OPEN);
                break;
            }
            break;

        case WAIT_OBJECT_0 + 2:
            /* There's a tray request in the queue.  Process it if the
             * tray is not in transit */
            switch(nTrayState) {
            case TRAYSTATE_OPENING:
            case TRAYSTATE_CLOSING:
            case TRAYSTATE_UNLOADING:
           