DEFINE_MOCK_METHOD(OnNewView)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pView);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCODEWINDOWMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsCombinedBrowseComponentSet.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCOMBINEDBROWSECOMPONENTSET_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCOMBINEDBROWSECOMPONENTSET_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsCombinedBrowseComponentSetNotImpl :
	public IVsCombinedBrowseComponentSet
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCombinedBrowseComponentSetNotImpl)

public:

	typedef IVsCombinedBrowseComponentSet Interface;

	STDMETHOD(AddSet)(
		/*[in]*/ IVsSimpleBrowseComponentSet* /*pSet*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSetCount)(
		/*[in]*/ ULONG* /*pulCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSetAt)(
		/*[in]*/ ULONG /*ulIndex*/,
		/*[out,retval]*/ IVsSimpleBrowseComponentSet** /*ppSet*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveSetAt)(
		/*[in]*/ ULONG /*ulIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveAllSets)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveOwnerSets)(
		/*[in]*/ IUnknown* /*pOwner*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_ComponentsListOptions)(
		/*[in]*/ BROWSE_COMPONENT_SET_OPTIONS /*dwOptions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ComponentsListOptions)(
		/*[out,retval]*/ BROWSE_COMPONENT_SET_OPTIONS* /*pdwOptions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_ChildListOptions)(
		/*[in]*/ BROWSE_COMPONENT_SET_OPTIONS /*dwOptions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ChildListOptions)(
		/*[out,retval]*/ BROWSE_COMPONENT_SET_OPTIONS* /*pdwOptions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetList2)(
		/*[in]*/ LIB_LISTTYPE2 /*ListType*/,
		/*[in]*/ LIB_LISTFLAGS /*Flags*/,
		/*[in]*/ VSOBSEARCHCRITERIA2* /*pobSrch*/,
		/*[in]*/ IVsObjectList2* /*pExtraListToCombineWith*/,
		/*[out,retval]*/ IVsObjectList2** /*ppIVsObjectList2*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSupportedCategoryFields2)(
		/*[in]*/ LIB_CATEGORY2 /*Category*/,
		/*[out,retval]*/ DWORD* /*pgrfCatField*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateNavInfo)(
		/*[in]*/ REFGUID /*guidLib*/,
		/*[in,size_is(ulcNodes)]*/ SYMBOL_DESCRIPTION_NODE[] /*rgSymbolNodes*/,
		/*[in]*/ ULONG /*ulcNodes*/,
		/*[out,retval]*/ IVsNavInfo** /*ppNavInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateCounter)(
		/*[out]*/ ULONG* /*pCurUpdate*/)VSL_STDMETHOD_NOTIMPL
};

class IVsCombinedBrowseComponentSetMockImpl :
	public IVsCombinedBrowseComponentSet,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCombinedBrowseComponentSetMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsCombinedBrowseComponentSetMockImpl)

	typedef IVsCombinedBrowseComponentSet Interface;
	struct AddSetValidValues
	{
		/*[in]*/ IVsSimpleBrowseComponentSet* pSet;
		HRESULT retValue;
	};

	STDMETHOD(AddSet)(
		/*[in]*/ IVsSimpleBrowseComponentSet* pSet)
	{
		VSL_DEFINE_MOCK_METHOD(AddSet)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSet);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSetCountValidValues
	{
		/*[in]*/ ULONG* pulCount;
		HRESULT retValue;
	};

	STDMETHOD(GetSetCount)(
		/*[in]*/ ULONG* pulCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetSetCount)

		VSL_CHECK_VALIDVALUE_POINTER(pulCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSetAtValidValues
	{
		/*[in]*/ ULONG ulIndex;
		/*[out,retval]*/ IVsSimpleBrowseComponentSet** ppSet;
		HRESULT retValue;
	};

	STDMETHOD(GetSetAt)(
		/*[in]*/ ULONG ulIndex,
		/*[out,retval]*/ IVsSimpleBrowseComponentSet** ppSet)
	{
		VSL_DEFINE_MOCK_METHOD(GetSetAt)

		VSL_CHECK_VALIDVALUE(ulIndex);

		VSL_SET_VALIDVALUE_INTERFACE(ppSet);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveSetAtValidValues
	{
		/*[in]*/ ULONG ulIndex;
		HRESULT retValue;
	};

	STDMETHOD(RemoveSetAt)(
		/*[in]*/ ULONG ulIndex)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveSetAt)

		VSL_CHECK_VALIDVALUE(ulIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveAllSetsValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(RemoveAllSets)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(RemoveAllSets)

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveOwnerSetsValidValues
	{
		/*[in]*/ IUnknown* pOwner;
		HRESULT retValue;
	};

	STDMETHOD(RemoveOwnerSets)(
		/*[in]*/ IUnknown* pOwner)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveOwnerSets)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pOwner);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_ComponentsListOptionsValidValues
	{
		/*[in]*/ BROWSE_COMPONENT_SET_OPTIONS dwOptions;
		HRESULT retValue;
	};

	STDMETHOD(put_ComponentsListOptions)(
		/*[in]*/ BROWSE_COMPONENT_SET_OPTIONS dwOptions)
	{
		VSL_DEFINE_MOCK_METHOD(put_ComponentsListOptions)

		VSL_CHECK_VALIDVALUE(dwOptions);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ComponentsListOptionsValidValues
	{
		/*[out,retval]*/ BROWSE_COMPONENT_SET_OPTIONS* pdwOptions;
		HRESULT retValue;
	};

	STDMETHOD(get_ComponentsListOptions)(
		/*[out,retval]*/ BROWSE_COMPONENT_SET_OPTIONS* pdwOptions)
	{
		VSL_DEFINE_MOCK_METHOD(get_ComponentsListOptions)

		VSL_SET_VALIDVALUE(pdwOptions);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_ChildListOptionsValidValues
	{
		/*[in]*/ BROWSE_COMPONENT_SET_OPTIONS dwOptions;
		HRESULT retValue;
	};

	STDMETHOD(put_ChildListOptions)(
		/*[in]*/ BROWSE_COMPONENT_SET_OPTIONS dwOptions)
	{
		VSL_DEFINE_MOCK_METHOD(put_ChildListOptions)

		VSL_CHECK_VALIDVALUE(dwOptions);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ChildListOptionsValidValues
	{
		/*[out,retval]*/ BROWSE_COMPONENT_SET_OPTIONS* pdwOptions;
		HRESULT retValue;
	};

	STDMETHOD(get_ChildListOptions)(
		/*[out,retval]*/ BROWSE_COMPONENT_SET_OPTIONS* pdwOptions)
	{
		VSL_DEFINE_MOCK_METHOD(get_ChildListOptions)

		VSL_SET_VALIDVALUE(pdwOptions);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetList2ValidValues
	{
		/*[in]*/ LIB_LISTTYPE2 ListType;
		/*[in]*/ LIB_LISTFLAGS Flags;
		/*[in]*/ VSOBSEARCHCRITERIA2* pobSrch;
		/*[in]*/ IVsObjectList2* pExtraListToCombineWith;
		/*[out,retval]*/ IVsObjectList2** ppIVsObjectList2;
		HRESULT retValue;
	};

	STDMETHOD(GetList2)(
		/*[in]*/ LIB_LISTTYPE2 ListType,
		/*[in]*/ LIB_LISTFLAGS Flags,
		/*[in]*/ VSOBSEARCHCRITERIA2* pobSrch,
		/*[in]*/ IVsObjectList2* pExtraListToCombineWith,
		/*[out,retval]*/ IVsObjectList2** ppIVsObjectList2)
	{
		VSL_DEFINE_MOCK_METHOD(GetList2)

		VSL_CHECK_VALIDVALUE(ListType);

		VSL_CHECK_VALIDVALUE(Flags);

		VSL_CHECK_VALIDVALUE_POINTER(pobSrch);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pExtraListToCombineWith);

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsObjectList2);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSupportedCategoryFields2ValidValues
	{
		/*[in]*/ LIB_CATEGORY2 Category;
		/*[out,retval]*/ DWORD* pgrfCatField;
		HRESULT retValue;
	};

	STDMETHOD(GetSupportedCategoryFields2)(
		/*[in]*/ LIB_CATEGORY2 Category,
		/*[out,retval]*/ DWORD* pgrfCatField)
	{
		VSL_DEFINE_MOCK_METHOD(GetSupportedCategoryFields2)

		VSL_CHECK_VALIDVALUE(Category);

		VSL_SET_VALIDVALUE(pgrfCatField);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateNavInfoValidValues
	{
		/*[in]*/ REFGUID guidLib;
		/*[in,size_is(ulcNodes)]*/ SYMBOL_DESCRIPTION_NODE* rgSymbolNodes;
		/*[in]*/ ULONG ulcNodes;
		/*[out,retval]*/ IVsNavInfo** ppNavInfo;
		HRESULT retValue;
	};

	STDMETHOD(CreateNavInfo)(
		/*[in]*/ REFGUID guidLib,
		/*[in,size_is(ulcNodes)]*/ SYMBOL_DESCRIPTION_NODE rgSymbolNodes[],
		/*[in]*/ ULONG ulcNodes,
		/*[out,retval]*/ IVsNavInfo** ppNavInfo)
	{
		VSL_DEFINE_MOCK_METHOD(CreateNavInfo)

		VSL_CHECK_VALIDVALUE(guidLib);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgSymbolNodes, ulcNodes*sizeof(rgSymbolNodes[0]), validValues.ulcNodes*sizeof(validValues.rgSymbolNodes[0]));

		VSL_CHECK_VALIDVALUE(ulcNodes);

		VSL_SET_VALIDVALUE_INTERFACE(ppNavInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateCounterValidValues
	{
		/*[out]*/ ULONG* pCurUpdate;
		HRESULT retValue;
	};

	STDMETHOD(UpdateCounter)(
		/*[out]*/ ULONG* pCurUpdate)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateCounter)

		VSL_SET_VALIDVALUE(pCurUpdate);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCOMBINEDBROWSECOMPONENTSET_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsCommandWindow.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCOMMANDWINDOW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCOMMANDWINDOW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsCommandWindowNotImpl :
	public IVsCommandWindow
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCommandWindowNotImpl)

public:

	typedef IVsCommandWindow Interface;

	STDMETHOD(ExecuteCommand)(
		/*[in,ref]*/ LPCOLESTR /*szCommand*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(PrepareCommand)(
		/*[in,ref]*/ LPCOLESTR /*szCommand*/,
		/*[out]*/ GUID* /*pguidCmdGroup*/,
		/*[out]*/ DWORD* /*pdwCmdId*/,
		/*[out]*/ VARIANT** /*ppvaCmdArg*/,
		/*[out,retval]*/ PREPARECOMMANDRESULT* /*pResult*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Create)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Show)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Print)(
		/*[in,ref]*/ LPCOLESTR /*szTextToPrint*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EchoCommand)(
		/*[in,ref]*/ LPCOLESTR /*szCommand*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetMode)(
		/*[in]*/ COMMANDWINDOWMODE /*mode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LogToFile)(
		/*[in,ref]*/ LPCOLESTR /*szLogFile*/,
		/*[in]*/ LOGTOFILEOPTIONS /*grfFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(StopLogging)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetCurrentLanguageService)(
		/*[in]*/ REFGUID /*rguidLanguageService*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RunningCommandWindowCommand)(
		/*[out,retval]*/ BOOL* /*pfCmdWin*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(PrintNoShow)(
		/*[in,ref]*/ LPCOLESTR /*szTextToPrint*/)VSL_STDMETHOD_NOTIMPL
};

class IVsCommandWindowMockImpl :
	public IVsCommandWindow,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCommandWindowMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsCommandWindowMockImpl)

	typedef IVsCommandWindow Interface;
	struct ExecuteCommandValidValues
	{
		/*[in,ref]*/ LPCOLESTR szCommand;
		HRESULT retValue;
	};

	STDMETHOD(ExecuteCommand)(
		/*[in,ref]*/ LPCOLESTR szCommand)
	{
		VSL_DEFINE_MOCK_METHOD(ExecuteCommand)

		VSL_CHECK_VALIDVALUE_STRINGW(szCommand);

		VSL_RETURN_VALIDVALUES();
	}
	struct PrepareCommandValidValues
	{
		/*[in,ref]*/ LPCOLESTR szCommand;
		/*[out]*/ GUID* pguidCmdGroup;
		/*[out]*/ DWORD* pdwCmdId;
		/*[out]*/ VARIANT** ppvaCmdArg;
		/*[out,retval]*/ PREPARECOMMANDRESULT* pResult;
		HRESULT retValue;
	};

	STDMETHOD(PrepareCommand)(
		/*[in,ref]*/ LPCOLESTR szCommand,
		/*[out]*/ GUID* pguidCmdGroup,
		/*[out]*/ DWORD* pdwCmdId,
		/*[out]*/ VARIANT** ppvaCmdArg,
		/*[out,retval]*/ PREPARECOMMANDRESULT* pResult)
	{
		VSL_DEFINE_MOCK_METHOD(PrepareCommand)

		VSL_CHECK_VALIDVALUE_STRINGW(szCommand);

		VSL_SET_VALIDVALUE(pguidCmdGroup);

		VSL_SET_VALIDVALUE(pdwCmdId);

		VSL_SET_VALIDVALUE(ppvaCmdArg);

		VSL_SET_VALIDVALUE(pResult);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Create)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Create)

		VSL_RETURN_VALIDVALUES();
	}
	struct ShowValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Show)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Show)

		VSL_RETURN_VALIDVALUES();
	}
	struct PrintValidValues
	{
		/*[in,ref]*/ LPCOLESTR szTextToPrint;
		HRESULT retValue;
	};

	STDMETHOD(Print)(
		/*[in,ref]*/ LPCOLESTR szTextToPrint)
	{
		VSL_DEFINE_MOCK_METHOD(Print)

		VSL_CHECK_VALIDVALUE_STRINGW(szTextToPrint);

		VSL_RETURN_VALIDVALUES();
	}
	struct EchoCommandValidValues
	{
		/*[in,ref]*/ LPCOLESTR szCommand;
		HRESULT retValue;
	};

	STDMETHOD(EchoCommand)(
		/*[in,ref]*/ LPCOLESTR szCommand)
	{
		VSL_DEFINE_MOCK_METHOD(EchoCommand)

		VSL_CHECK_VALIDVALUE_STRINGW(szCommand);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetModeValidValues
	{
		/*[in]*/ COMMANDWINDOWMODE mode;
		HRESULT retValue;
	};

	STDMETHOD(SetMode)(
		/*[in]*/ COMMANDWINDOWMODE mode)
	{
		VSL_DEFINE_MOCK_METHOD(SetMode)

		VSL_CHECK_VALIDVALUE(mode);

		VSL_RETURN_VALIDVALUES();
	}
	struct LogToFileValidValues
	{
		/*[in,ref]*/ LPCOLESTR szLogFile;
		/*[in]*/ LOGTOFILEOPTIONS grfFlags;
		HRESULT retValue;
	};

	STDMETHOD(LogToFile)(
		/*[in,ref]*/ LPCOLESTR szLogFile,
		/*[in]*/ LOGTOFILEOPTIONS grfFlags)
	{
		VSL_DEFINE_MOCK_METHOD(LogToFile)

		VSL_CHECK_VALIDVALUE_STRINGW(szLogFile);

		VSL_CHECK_VALIDVALUE(grfFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct StopLoggingValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(StopLogging)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(StopLogging)

		VSL_RETURN_VALIDVALUES();
	}
	struct SetCurrentLanguageServiceValidValues
	{
		/*[in]*/ REFGUID rguidLanguageService;
		HRESULT retValue;
	};

	STDMETHOD(SetCurrentLanguageService)(
		/*[in]*/ REFGUID rguidLanguageService)
	{
		VSL_DEFINE_MOCK_METHOD(SetCurrentLanguageService)

		VSL_CHECK_VALIDVALUE(rguidLanguageService);

		VSL_RETURN_VALIDVALUES();
	}
	struct RunningCommandWindowCommandValidValues
	{
		/*[out,retval]*/ BOOL* pfCmdWin;
		HRESULT retValue;
	};

	STDMETHOD(RunningCommandWindowCommand)(
		/*[out,retval]*/ BOOL* pfCmdWin)
	{
		VSL_DEFINE_MOCK_METHOD(RunningCommandWindowCommand)

		VSL_SET_VALIDVALUE(pfCmdWin);

		VSL_RETURN_VALIDVALUES();
	}
	struct PrintNoShowValidValues
	{
		/*[in,ref]*/ LPCOLESTR szTextToPrint;
		HRESULT retValue;
	};

	STDMETHOD(PrintNoShow)(
		/*[in,ref]*/ LPCOLESTR szTextToPrint)
	{
		VSL_DEFINE_MOCK_METHOD(PrintNoShow)

		VSL_CHECK_VALIDVALUE_STRINGW(szTextToPrint);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCOMMANDWINDOW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsCommandWindowsCollection.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCOMMANDWINDOWSCOLLECTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCOMMANDWINDOWSCOLLECTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsCommandWindowsCollectionNotImpl :
	public IVsCommandWindowsCollection
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCommandWindowsCollectionNotImpl)

public:

	typedef IVsCommandWindowsCollection Interface;

	STDMETHOD(Create)(
		/*[in]*/ COMMANDWINDOWMODE2 /*mode*/,
		/*[in]*/ DWORD /*dwToolWindowId*/,
		/*[in]*/ BOOL /*fShow*/,
		/*[out]*/ UINT* /*puCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OpenExistingOrCreateNewCommandWindow)(
		/*[in]*/ COMMANDWINDOWMODE2 /*mode*/,
		/*[in]*/ BOOL /*fShow*/,
		/*[out]*/ UINT* /*puCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCommandWindowFromCookie)(
		/*[in]*/ UINT /*uCookie*/,
		/*[out]*/ IUnknown** /*ppunkCmdWindow*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCommandWindowFromMode)(
		/*[in]*/ COMMANDWINDOWMODE2 /*mode*/,
		/*[out]*/ IUnknown** /*ppunkCmdWindow*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetRunningCommandWindowCommand)(
		/*[in]*/ UINT /*uCookie*/,
		/*[in]*/ BOOL /*fCmdWin*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsOutputWaiting)(
		/*[in]*/ UINT /*uCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Close)(
		/*[in]*/ UINT /*uCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CloseAllCommandWindows)()VSL_STDMETHOD_NOTIMPL
};

class IVsCommandWindowsCollectionMockImpl :
	public IVsCommandWindowsCollection,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCommandWindowsCollectionMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsCommandWindowsCollectionMockImpl)

	typedef IVsCommandWindowsCollection Interface;
	struct CreateValidValues
	{
		/*[in]*/ COMMANDWINDOWMODE2 mode;
		/*[in]*/ DWORD dwToolWindowId;
		/*[in]*/ BOOL fShow;
		/*[out]*/ UINT* puCookie;
		HRESULT retValue;
	};

	STDMETHOD(Create)(
		/*[in]*/ COMMANDWINDOWMODE2 mode,
		/*[in]*/ DWORD dwToolWindowId,
		/*[in]*/ BOOL fShow,
		/*[out]*/ UINT* puCookie)
	{
		VSL_DEFINE_MOCK_METHOD(Create)

		VSL_CHECK_VALIDVALUE(mode);

		VSL_CHECK_VALIDVALUE(dwToolWindowId);

		VSL_CHECK_VALIDVALUE(fShow);

		VSL_SET_VALIDVALUE(puCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct OpenExistingOrCreateNewCommandWindowValidValues
	{
		/*[in]*/ COMMANDWINDOWMODE2 mode;
		/*[in]*/ BOOL fShow;
		/*[out]*/ UINT* puCookie;
		HRESULT retValue;
	};

	STDMETHOD(OpenExistingOrCreateNewCommandWindow)(
		/*[in]*/ COMMANDWINDOWMODE2 mode,
		/*[in]*/ BOOL fShow,
		/*[out]*/ UINT* puCookie)
	{
		VSL_DEFINE_MOCK_METHOD(OpenExistingOrCreateNewCommandWindow)

		VSL_CHECK_VALIDVALUE(mode);

		VSL_CHECK_VALIDVALUE(fShow);

		VSL_SET_VALIDVALUE(puCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCommandWindowFromCookieValidValues
	{
		/*[in]*/ UINT uCookie;
		/*[out]*/ IUnknown** ppunkCmdWindow;
		HRESULT retValue;
	};

	STDMETHOD(GetCommandWindowFromCookie)(
		/*[in]*/ UINT uCookie,
		/*[out]*/ IUnknown** ppunkCmdWindow)
	{
		VSL_DEFINE_MOCK_METHOD(GetCommandWindowFromCookie)

		VSL_CHECK_VALIDVALUE(uCookie);

		VSL_SET_VALIDVALUE_INTERFACE(ppunkCmdWindow);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCommandWindowFromModeValidValues
	{
		/*[in]*/ COMMANDWINDOWMODE2 mode;
		/*[out]*/ IUnknown** ppunkCmdWindow;
		HRESULT retValue;
	};

	STDMETHOD(GetCommandWindowFromMode)(
		/*[in]*/ COMMANDWINDOWMODE2 mode,
		/*[out]*/ IUnknown** ppunkCmdWindow)
	{
		VSL_DEFINE_MOCK_METHOD(GetCommandWindowFromMode)

		VSL_CHECK_VALIDVALUE(mode);

		VSL_SET_VALIDVALUE_INTERFACE(ppunkCmdWindow);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetRunningCommandWindowCommandValidValues
	{
		/*[in]*/ UINT uCookie;
		/*[in]*/ BOOL fCmdWin;
		HRESULT retValue;
	};

	STDMETHOD(SetRunningCommandWindowCommand)(
		/*[in]*/ UINT uCookie,
		/*[in]*/ BOOL fCmdWin)
	{
		VSL_DEFINE_MOCK_METHOD(SetRunningCommandWindowCommand)

		VSL_CHECK_VALIDVALUE(uCookie);

		VSL_CHECK_VALIDVALUE(fCmdWin);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsOutputWaitingValidValues
	{
		/*[in]*/ UINT uCookie;
		HRESULT retValue;
	};

	STDMETHOD(IsOutputWaiting)(
		/*[in]*/ UINT uCookie)
	{
		VSL_DEFINE_MOCK_METHOD(IsOutputWaiting)

		VSL_CHECK_VALIDVALUE(uCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct CloseValidValues
	{
		/*[in]*/ UINT uCookie;
		HRESULT retValue;
	};

	STDMETHOD(Close)(
		/*[in]*/ UINT uCookie)
	{
		VSL_DEFINE_MOCK_METHOD(Close)

		VSL_CHECK_VALIDVALUE(uCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct CloseAllCommandWindowsValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CloseAllCommandWindows)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CloseAllCommandWindows)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCOMMANDWINDOWSCOLLECTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsCommandWindowCompletion.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCOMMANDWINDOWCOMPLETION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCOMMANDWINDOWCOMPLETION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "completion.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsCommandWindowCompletionNotImpl :
	public IVsCommandWindowCompletion
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCommandWindowCompletionNotImpl)

public:

	typedef IVsCommandWindowCompletion Interface;

	STDMETHOD(SetCompletionContext)(
		/*[in]*/ LPCOLESTR /*pszFilePath*/,
		/*[in]*/ IVsTextLines* /*pBuffer*/,
		/*[in]*/ const TextSpan* /*ptsCurStatement*/,
		/*[in]*/ IUnknown* /*punkContext*/)VSL_STDMETHOD_NOTIMPL
};

class IVsCommandWindowCompletionMockImpl :
	public IVsCommandWindowCompletion,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCommandWindowCompletionMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsCommandWindowCompletionMockImpl)

	typedef IVsCommandWindowCompletion Interface;
	struct SetCompletionContextValidValues
	{
		/*[in]*/ LPCOLESTR pszFilePath;
		/*[in]*/ IVsTextLines* pBuffer;
		/*[in]*/ TextSpan* ptsCurStatement;
		/*[in]*/ IUnknown* punkContext;
		HRESULT retValue;
	};

	STDMETHOD(SetCompletionContext)(
		/*[in]*/ LPCOLESTR pszFilePath,
		/*[in]*/ IVsTextLines* pBuffer,
		/*[in]*/ const TextSpan* ptsCurStatement,
		/*[in]*/ IUnknown* punkContext)
	{
		VSL_DEFINE_MOCK_METHOD(SetCompletionContext)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFilePath);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_CHECK_VALIDVALUE_POINTER(ptsCurStatement);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkContext);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCOMMANDWINDOWCOMPLETION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsCommentTaskInfo.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCOMMENTTASKINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCOMMENTTASKINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsCommentTaskInfoNotImpl :
	public IVsCommentTaskInfo
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCommentTaskInfoNotImpl)

public:

	typedef IVsCommentTaskInfo Interface;

	STDMETHOD(get_DefaultToken)(
		/*[out,retval]*/ IVsCommentTaskToken** /*ppToken*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_EnumTokens)(
		/*[out,retval]*/ IVsEnumCommentTaskTokens** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_TokenCount)(
		/*[out,retval]*/ long* /*pCount*/)VSL_STDMETHOD_NOTIMPL
};

class IVsCommentTaskInfoMockImpl :
	public IVsCommentTaskInfo,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCommentTaskInfoMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsCommentTaskInfoMockImpl)

	typedef IVsCommentTaskInfo Interface;
	struct get_DefaultTokenValidValues
	{
		/*[out,retval]*/ IVsCommentTaskToken** ppToken;
		HRESULT retValue;
	};

	STDMETHOD(get_DefaultToken)(
		/*[out,retval]*/ IVsCommentTaskToken** ppToken)
	{
		VSL_DEFINE_MOCK_METHOD(get_DefaultToken)

		VSL_SET_VALIDVALUE_INTERFACE(ppToken);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_EnumTokensValidValues
	{
		/*[out,retval]*/ IVsEnumCommentTaskTokens** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(get_EnumTokens)(
		/*[out,retval]*/ IVsEnumCommentTaskTokens** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(get_EnumTokens)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_TokenCountValidValues
	{
		/*[out,retval]*/ long* pCount;
		HRESULT retValue;
	};

	STDMETHOD(get_TokenCount)(
		/*[out,retval]*/ long* pCount)
	{
		VSL_DEFINE_MOCK_METHOD(get_TokenCount)

		VSL_SET_VALIDVALUE(pCount);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCOMMENTTASKINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsCommandArgInfo.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCOMMANDARGINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCOMMANDARGINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsCommandArgInfoNotImpl :
	public IVsCommandArgInfo
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCommandArgInfoNotImpl)

public:

	typedef IVsCommandArgInfo Interface;

	STDMETHOD(QueryCommandArgAvailable)(
		/*[out]*/ BOOL* /*pfCmdArgAvailable*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCommandArg)(
		/*[out]*/ BSTR* /*pbstrCmdArg*/)VSL_STDMETHOD_NOTIMPL
};

class IVsCommandArgInfoMockImpl :
	public IVsCommandArgInfo,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCommandArgInfoMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsCommandArgInfoMockImpl)

	typedef IVsCommandArgInfo Interface;
	struct QueryCommandArgAvailableValidValues
	{
		/*[out]*/ BOOL* pfCmdArgAvailable;
		HRESULT retValue;
	};

	STDMETHOD(QueryCommandArgAvailable)(
		/*[out]*/ BOOL* pfCmdArgAvailable)
	{
		VSL_DEFINE_MOCK_METHOD(QueryCommandArgAvailable)

		VSL_SET_VALIDVALUE(pfCmdArgAvailable);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCommandArgValidValues
	{
		/*[out]*/ BSTR* pbstrCmdArg;
		HRESULT retValue;
	};

	STDMETHOD(GetCommandArg)(
		/*[out]*/ BSTR* pbstrCmdArg)
	{
		VSL_DEFINE_MOCK_METHOD(GetCommandArg)

		VSL_SET_VALIDVALUE_BSTR(pbstrCmdArg);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCOMMANDARGINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsCommentTaskToken.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCOMMENTTASKTOKEN_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCOMMENTTASKTOKEN_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsCommentTaskTokenNotImpl :
	public IVsCommentTaskToken
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCommentTaskTokenNotImpl)

public:

	typedef IVsCommentTaskToken Interface;

	STDMETHOD(get_Text)(
		/*[out,retval]*/ BSTR* /*pbstrText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Priority)(
		/*[out,retval]*/ VSTASKPRIORITY* /*ptpPriority*/)VSL_STDMETHOD_NOTIMPL
};

class IVsCommentTaskTokenMockImpl :
	public IVsCommentTaskToken,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCommentTaskTokenMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsCommentTaskTokenMockImpl)

	typedef IVsCommentTaskToken Interface;
	struct get_TextValidValues
	{
		/*[out,retval]*/ BSTR* pbstrText;
		HRESULT retValue;
	};

	STDMETHOD(get_Text)(
		/*[out,retval]*/ BSTR* pbstrText)
	{
		VSL_DEFINE_MOCK_METHOD(get_Text)

		VSL_SET_VALIDVALUE_BSTR(pbstrText);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_PriorityValidValues
	{
		/*[out,retval]*/ VSTASKPRIORITY* ptpPriority;
		HRESULT retValue;
	};

	STDMETHOD(get_Priority)(
		/*[out,retval]*/ VSTASKPRIORITY* ptpPriority)
	{
		VSL_DEFINE_MOCK_METHOD(get_Priority)

		VSL_SET_VALIDVALUE(ptpPriority);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCOMMENTTASKTOKEN_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsCommandWindow2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCOMMANDWINDOW2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCOMMANDWINDOW2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsCommandWindow2NotImpl :
	public IVsCommandWindow2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCommandWindow2NotImpl)

public:

	typedef IVsCommandWindow2 Interface;

	STDMETHOD(SetMode)(
		/*[in]*/ COMMANDWINDOWMODE2 /*mode*/)VSL_STDMETHOD_NOTIMPL
};

class IVsCommandWindow2MockImpl :
	public IVsCommandWindow2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCommandWindow2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsCommandWindow2MockImpl)

	typedef IVsCommandWindow2 Interface;
	struct SetModeValidValues
	{
		/*[in]*/ COMMANDWINDOWMODE2 mode;
		HRESULT retValue;
	};

	STDMETHOD(SetMode)(
		/*[in]*/ COMMANDWINDOWMODE2 mode)
	{
		VSL_DEFINE_MOCK_METHOD(SetMode)

		VSL_CHECK_VALIDVALUE(mode);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCOMMANDWINDOW2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsCompletionSetBuilder.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCOMPLETIONSETBUILDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCOMPLETIONSETBUILDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsCompletionSetBuilderNotImpl :
	public IVsCompletionSetBuilder
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCompletionSetBuilderNotImpl)

public:

	typedef IVsCompletionSetBuilder Interface;

	STDMETHOD(GetBuilderCount)(
		/*[in]*/ long* /*piCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBuilderDisplayText)(
		/*[in]*/ long /*iIndex*/,
		/*[out]*/ BSTR* /*pbstrText*/,
		/*[out,optional]*/ long* /*piGlyph*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBuilderDescriptionText)(
		/*[in]*/ long /*iIndex*/,
		/*[out]*/ BSTR* /*pbstrDescription*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBuilderImageList)(
		/*[out]*/ HANDLE* /*phImages*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnBuilderCommit)(
		/*[in]*/ long /*iIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBuilderItemColor)(
		/*[in]*/ long /*iIndex*/,
		/*[out]*/ COLORREF* /*dwFGColor*/,
		/*[out]*/ COLORREF* /*dwBGColor*/)VSL_STDMETHOD_NOTIMPL
};

class IVsCompletionSetBuilderMockImpl :
	public IVsCompletionSetBuilder,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCompletionSetBuilderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsCompletionSetBuilderMockImpl)

	typedef IVsCompletionSetBuilder Interface;
	struct GetBuilderCountValidValues
	{
		/*[in]*/ long* piCount;
		HRESULT retValue;
	};

	STDMETHOD(GetBuilderCount)(
		/*[in]*/ long* piCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetBuilderCount)

		VSL_CHECK_VALIDVALUE_POINTER(piCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBuilderDisplayTextValidValues
	{
		/*[in]*/ long iIndex;
		/*[out]*/ BSTR* pbstrText;
		/*[out,optional]*/ long* piGlyph;
		HRESULT retValue;
	};

	STDMETHOD(GetBuilderDisplayText)(
		/*[in]*/ long iIndex,
		/*[out]*/ BSTR* pbstrText,
		/*[out,optional]*/ long* piGlyph)
	{
		VSL_DEFINE_MOCK_METHOD(GetBuilderDisplayText)

		VSL_CHECK_VALIDVALUE(iIndex);

		VSL_SET_VALIDVALUE_BSTR(pbstrText);

		VSL_SET_VALIDVALUE(piGlyph);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBuilderDescriptionTextValidValues
	{
		/*[in]*/ long iIndex;
		/*[out]*/ BSTR* pbstrDescription;
		HRESULT retValue;
	};

	STDMETHOD(GetBuilderDescriptionText)(
		/*[in]*/ long iIndex,
		/*[out]*/ BSTR* pbstrDescription)
	{
		VSL_DEFINE_MOCK_METHOD(GetBuilderDescriptionText)

		VSL_CHECK_VALIDVALUE(iIndex);

		VSL_SET_VALIDVALUE_BSTR(pbstrDescription);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBuilderImageListValidValues
	{
		/*[out]*/ HANDLE* phImages;
		HRESULT retValue;
	};

	STDMETHOD(GetBuilderImageList)(
		/*[out]*/ HANDLE* phImages)
	{
		VSL_DEFINE_MOCK_METHOD(GetBuilderImageList)

		VSL_SET_VALIDVALUE(phImages);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnBuilderCommitValidValues
	{
		/*[in]*/ long iIndex;
		HRESULT retValue;
	};

	STDMETHOD(OnBuilderCommit)(
		/*[in]*/ long iIndex)
	{
		VSL_DEFINE_MOCK_METHOD(OnBuilderCommit)

		VSL_CHECK_VALIDVALUE(iIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBuilderItemColorValidValues
	{
		/*[in]*/ long iIndex;
		/*[out]*/ COLORREF* dwFGColor;
		/*[out]*/ COLORREF* dwBGColor;
		HRESULT retValue;
	};

	STDMETHOD(GetBuilderItemColor)(
		/*[in]*/ long iIndex,
		/*[out]*/ COLORREF* dwFGColor,
		/*[out]*/ COLORREF* dwBGColor)
	{
		VSL_DEFINE_MOCK_METHOD(GetBuilderItemColor)

		VSL_CHECK_VALIDVALUE(iIndex);

		VSL_SET_VALIDVALUE(dwFGColor);

		VSL_SET_VALIDVALUE(dwBGColor);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCOMPLETIONSETBUILDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsComponentEnumeratorFactory.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCOMPONENTENUMERATORFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCOMPONENTENUMERATORFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "compsvcspkg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsComponentEnumeratorFactoryNotImpl :
	public IVsComponentEnumeratorFactory
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsComponentEnumeratorFactoryNotImpl)

public:

	typedef IVsComponentEnumeratorFactory Interface;

	STDMETHOD(GetComponents)(
		/*[in]*/ BSTR /*bstrMachineName*/,
		/*[in]*/ LONG /*lEnumType*/,
		/*[in]*/ BOOL /*bForceRefresh*/,
		/*[out]*/ IEnumComponents** /*pEnumerator*/)VSL_STDMETHOD_NOTIMPL
};

class IVsComponentEnumeratorFactoryMockImpl :
	public IVsComponentEnumeratorFactory,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsComponentEnumeratorFactoryMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsComponentEnumeratorFactoryMockImpl)

	typedef IVsComponentEnumeratorFactory Interface;
	struct GetComponentsValidValues
	{
		/*[in]*/ BSTR bstrMachineName;
		/*[in]*/ LONG lEnumType;
		/*[in]*/ BOOL bForceRefresh;
		/*[out]*/ IEnumComponents** pEnumerator;
		HRESULT retValue;
	};

	STDMETHOD(GetComponents)(
		/*[in]*/ BSTR bstrMachineName,
		/*[in]*/ LONG lEnumType,
		/*[in]*/ BOOL bForceRefresh,
		/*[out]*/ IEnumComponents** pEnumerator)
	{
		VSL_DEFINE_MOCK_METHOD(GetComponents)

		VSL_CHECK_VALIDVALUE_BSTR(bstrMachineName);

		VSL_CHECK_VALIDVALUE(lEnumType);

		VSL_CHECK_VALIDVALUE(bForceRefresh);

		VSL_SET_VALIDVALUE_INTERFACE(pEnumerator);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCOMPONENTENUMERATORFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsCompletionSetEx.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCOMPLETIONSETEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCOMPLETIONSETEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsCompletionSetExNotImpl :
	public IVsCompletionSetEx
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCompletionSetExNotImpl)

public:

	typedef IVsCompletionSetEx Interface;

	STDMETHOD(GetCompletionItemColor)(
		/*[in]*/ long /*iIndex*/,
		/*[out]*/ COLORREF* /*dwFGColor*/,
		/*[out]*/ COLORREF* /*dwBGColor*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFilterLevel)(
		/*[out]*/ long* /*iFilterLevel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IncreaseFilterLevel)(
		/*[in]*/ long /*iSelectedItem*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DecreaseFilterLevel)(
		/*[in]*/ long /*iSelectedItem*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CompareItems)(
		/*[in]*/ const BSTR /*bstrSoFar*/,
		/*[in]*/ const BSTR /*bstrOther*/,
		/*[in]*/ long /*lCharactersToCompare*/,
		/*[out]*/ long* /*plResult*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnCommitComplete)()VSL_STDMETHOD_NOTIMPL
};

class IVsCompletionSetExMockImpl :
	public IVsCompletionSetEx,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCompletionSetExMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsCompletionSetExMockImpl)

	typedef IVsCompletionSetEx Interface;
	struct GetCompletionItemColorValidValues
	{
		/*[in]*/ long iIndex;
		/*[out]*/ COLORREF* dwFGColor;
		/*[out]*/ COLORREF* dwBGColor;
		HRESULT retValue;
	};

	STDMETHOD(GetCompletionItemColor)(
		/*[in]*/ long iIndex,
		/*[out]*/ COLORREF* dwFGColor,
		/*[out]*/ COLORREF* dwBGColor)
	{
		VSL_DEFINE_MOCK_METHOD(GetCompletionItemColor)

		VSL_CHECK_VALIDVALUE(iIndex);

		VSL_SET_VALIDVALUE(dwFGColor);

		VSL_SET_VALIDVALUE(dwBGColor);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFilterLevelValidValues
	{
		/*[out]*/ long* iFilterLevel;
		HRESULT retValue;
	};

	STDMETHOD(GetFilterLevel)(
		/*[out]*/ long* iFilterLevel)
	{
		VSL_DEFINE_MOCK_METHOD(GetFilterLevel)

		VSL_SET_VALIDVALUE(iFilterLevel);

		VSL_RETURN_VALIDVALUES();
	}
	struct IncreaseFilterLevelValidValues
	{
		/*[in]*/ long iSelectedItem;
		HRESULT retValue;
	};

	STDMETHOD(IncreaseFilterLevel)(
		/*[in]*/ long iSelectedItem)
	{
		VSL_DEFINE_MOCK_METHOD(IncreaseFilterLevel)

		VSL_CHECK_VALIDVALUE(iSelectedItem);

		VSL_RETURN_VALIDVALUES();
	}
	struct DecreaseFilterLevelValidValues
	{
		/*[in]*/ long iSelectedItem;
		HRESULT retValue;
	};

	STDMETHOD(DecreaseFilterLevel)(
		/*[in]*/ long iSelectedItem)
	{
		VSL_DEFINE_MOCK_METHOD(DecreaseFilterLevel)

		VSL_CHECK_VALIDVALUE(iSelectedItem);

		VSL_RETURN_VALIDVALUES();
	}
	struct CompareItemsValidValues
	{
		/*[in]*/ BSTR bstrSoFar;
		/*[in]*/ BSTR bstrOther;
		/*[in]*/ long lCharactersToCompare;
		/*[out]*/ long* plResult;
		HRESULT retValue;
	};

	STDMETHOD(CompareItems)(
		/*[in]*/ const BSTR bstrSoFar,
		/*[in]*/ const BSTR bstrOther,
		/*[in]*/ long lCharactersToCompare,
		/*[out]*/ long* plResult)
	{
		VSL_DEFINE_MOCK_METHOD(CompareItems)

		VSL_CHECK_VALIDVALUE_BSTR(bstrSoFar);

		VSL_CHECK_VALIDVALUE_BSTR(bstrOther);

		VSL_CHECK_VALIDVALUE(lCharactersToCompare);

		VSL_SET_VALIDVALUE(plResult);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnCommitCompleteValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnCommitComplete)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnCommitComplete)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCOMPLETIONSETEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsComponentEnumeratorFactory2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCOMPONENTENUMERATORFACTORY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCOMPONENTENUMERATORFACTORY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "compsvcspkg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsComponentEnumeratorFactory2NotImpl :
	public IVsComponentEnumeratorFactory2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsComponentEnumeratorFactory2NotImpl)

public:

	typedef IVsComponentEnumeratorFactory2 Interface;

	STDMETHOD(GetComponentsOfPath)(
		/*[in]*/ BSTR /*bstrMachineName*/,
		/*[in]*/ LONG /*lEnumType*/,
		/*[in]*/ BOOL /*bForceRefresh*/,
		/*[in]*/ BSTR /*bstrPath*/,
		/*[out]*/ IEnumComponents** /*pEnumerator*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetComponents)(
		/*[in]*/ BSTR /*bstrMachineName*/,
		/*[in]*/ LONG /*lEnumType*/,
		/*[in]*/ BOOL /*bForceRefresh*/,
		/*[out]*/ IEnumComponents** /*pEnumerator*/)VSL_STDMETHOD_NOTIMPL
};

class IVsComponentEnumeratorFactory2MockImpl :
	public IVsComponentEnumeratorFactory2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsComponentEnumeratorFactory2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsComponentEnumeratorFactory2MockImpl)

	typedef IVsComponentEnumeratorFactory2 Interface;
	struct GetComponentsOfPathValidValues
	{
		/*[in]*/ BSTR bstrMachineName;
		/*[in]*/ LONG lEnumType;
		/*[in]*/ BOOL bForceRefresh;
		/*[in]*/ BSTR bstrPath;
		/*[out]*/ IEnumComponents** pEnumerator;
		HRESULT retValue;
	};

	STDMETHOD(GetComponentsOfPath)(
		/*[in]*/ BSTR bstrMachineName,
		/*[in]*/ LONG lEnumType,
		/*[in]*/ BOOL bForceRefresh,
		/*[in]*/ BSTR bstrPath,
		/*[out]*/ IEnumComponents** pEnumerator)
	{
		VSL_DEFINE_MOCK_METHOD(GetComponentsOfPath)

		VSL_CHECK_VALIDVALUE_BSTR(bstrMachineName);

		VSL_CHECK_VALIDVALUE(lEnumType);

		VSL_CHECK_VALIDVALUE(bForceRefresh);

		VSL_CHECK_VALIDVALUE_BSTR(bstrPath);

		VSL_SET_VALIDVALUE_INTERFACE(pEnumerator);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetComponentsValidValues
	{
		/*[in]*/ BSTR bstrMachineName;
		/*[in]*/ LONG lEnumType;
		/*[in]*/ BOOL bForceRefresh;
		/*[out]*/ IEnumComponents** pEnumerator;
		HRESULT retValue;
	};

	STDMETHOD(GetComponents)(
		/*[in]*/ BSTR bstrMachineName,
		/*[in]*/ LONG lEnumType,
		/*[in]*/ BOOL bForceRefresh,
		/*[out]*/ IEnumComponents** pEnumerator)
	{
		VSL_DEFINE_MOCK_METHOD(GetComponents)

		VSL_CHECK_VALIDVALUE_BSTR(bstrMachineName);

		VSL_CHECK_VALIDVALUE(lEnumType);

		VSL_CHECK_VALIDVALUE(bForceRefresh);

		VSL_SET_VALIDVALUE_INTERFACE(pEnumerator);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCOMPONENTENUMERATORFACTORY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsComponentSelectorData.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCOMPONENTSELECTORDATA_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCOMPONENTSELECTORDATA_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "compsvcspkg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsComponentSelectorDataNotImpl :
	public IVsComponentSelectorData
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsComponentSelectorDataNotImpl)

public:

	typedef IVsComponentSelectorData Interface;

	STDMETHOD(GetData)(
		/*[out]*/ VSCOMPONENTSELECTORDATA* /*pData*/)VSL_STDMETHOD_NOTIMPL
};

class IVsComponentSelectorDataMockImpl :
	public IVsComponentSelectorData,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsComponentSelectorDataMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsComponentSelectorDataMockImpl)

	typedef IVsComponentSelectorData Interface;
	struct GetDataValidValues
	{
		/*[out]*/ VSCOMPONENTSELECTORDATA* pData;
		HRESULT retValue;
	};

	STDMETHOD(GetData)(
		/*[out]*/ VSCOMPONENTSELECTORDATA* pData)
	{
		VSL_DEFINE_MOCK_METHOD(GetData)

		VSL_SET_VALIDVALUE(pData);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCOMPONENTSELECTORDATA_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsComponentEnumeratorFactory3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCOMPONENTENUMERATORFACTORY3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCOMPONENTENUMERATORFACTORY3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "compsvcspkg80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsComponentEnumeratorFactory3NotImpl :
	public IVsComponentEnumeratorFactory3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsComponentEnumeratorFactory3NotImpl)

public:

	typedef IVsComponentEnumeratorFactory3 Interface;

	STDMETHOD(GetComponentsOfPathEx)(
		/*[in]*/ BSTR /*bstrMachineName*/,
		/*[in]*/ LONG /*lEnumType*/,
		/*[in]*/ BOOL /*bForceRefresh*/,
		/*[in]*/ VSCOMPENUMEXFLAGS /*grfFlags*/,
		/*[in]*/ BSTR /*bstrPath*/,
		/*[out]*/ IEnumComponents** /*pEnumerator*/)VSL_STDMETHOD_NOTIMPL
};

class IVsComponentEnumeratorFactory3MockImpl :
	public IVsComponentEnumeratorFactory3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsComponentEnumeratorFactory3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsComponentEnumeratorFactory3MockImpl)

	typedef IVsComponentEnumeratorFactory3 Interface;
	struct GetComponentsOfPathExValidValues
	{
		/*[in]*/ BSTR bstrMachineName;
		/*[in]*/ LONG lEnumType;
		/*[in]*/ BOOL bForceRefresh;
		/*[in]*/ VSCOMPENUMEXFLAGS grfFlags;
		/*[in]*/ BSTR bstrPath;
		/*[out]*/ IEnumComponents** pEnumerator;
		HRESULT retValue;
	};

	STDMETHOD(GetComponentsOfPathEx)(
		/*[in]*/ BSTR bstrMachineName,
		/*[in]*/ LONG lEnumType,
		/*[in]*/ BOOL bForceRefresh,
		/*[in]*/ VSCOMPENUMEXFLAGS grfFlags,
		/*[in]*/ BSTR bstrPath,
		/*[out]*/ IEnumComponents** pEnumerator)
	{
		VSL_DEFINE_MOCK_METHOD(GetComponentsOfPathEx)

		VSL_CHECK_VALIDVALUE_BSTR(bstrMachineName);

		VSL_CHECK_VALIDVALUE(lEnumType);

		VSL_CHECK_VALIDVALUE(bForceRefresh);

		VSL_CHECK_VALIDVALUE(grfFlags);

		VSL_CHECK_VALIDVALUE_BSTR(bstrPath);

		VSL_SET_VALIDVALUE_INTERFACE(pEnumerator);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCOMPONENTENUMERATORFACTORY3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsComponentSelectorDlg2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCOMPONENTSELECTORDLG2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCOMPONENTSELECTORDLG2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsComponentSelectorDlg2NotImpl :
	public IVsComponentSelectorDlg2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsComponentSelectorDlg2NotImpl)

public:

	typedef IVsComponentSelectorDlg2 Interface;

	STDMETHOD(ComponentSelectorDlg2)(
		/*[in]*/ VSCOMPSELFLAGS2 /*grfFlags*/,
		/*[in]*/ IVsComponentUser* /*pUser*/,
		/*[in]*/ ULONG /*cComponents*/,
		/*[in,size_is(cComponents)]*/ PVSCOMPONENTSELECTORDATA[] /*rgpcsdComponents*/,
		/*[in]*/ LPCOLESTR /*lpszDlgTitle*/,
		/*[in]*/ LPCOLESTR /*lpszHelpTopic*/,
		/*[in,out]*/ ULONG* /*pxDlgSize*/,
		/*[in,out]*/ ULONG* /*pyDlgSize*/,
		/*[in]*/ ULONG /*cTabInitializers*/,
		/*[in,size_is(cTabInitializers)]*/ VSCOMPONENTSELECTORTABINIT[] /*rgcstiTabInitializers*/,
		/*[in,out]*/ GUID* /*pguidStartOnThisTab*/,
		/*[in]*/ LPCOLESTR /*pszBrowseFilters*/,
		/*[in,out]*/ BSTR* /*pbstrBrowseLocation*/)VSL_STDMETHOD_NOTIMPL
};

class IVsComponentSelectorDlg2MockImpl :
	public IVsComponentSelectorDlg2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsComponentSelectorDlg2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsComponentSelectorDlg2MockImpl)

	typedef IVsComponentSelectorDlg2 Interface;
	struct ComponentSelectorDlg2ValidValues
	{
		/*[in]*/ VSCOMPSELFLAGS2 grfFlags;
		/*[in]*/ IVsComponentUser* pUser;
		/*[in]*/ ULONG cComponents;
		/*[in,size_is(cComponents)]*/ PVSCOMPONENTSELECTORDATA* rgpcsdComponents;
		/*[in]*/ LPCOLESTR lpszDlgTitle;
		/*[in]*/ LPCOLESTR lpszHelpTopic;
		/*[in,out]*/ ULONG* pxDlgSize;
		/*[in,out]*/ ULONG* pyDlgSize;
		/*[in]*/ ULONG cTabInitializers;
		/*[in,size_is(cTabInitializers)]*/ VSCOMPONENTSELECTORTABINIT* rgcstiTabInitializers;
		/*[in,out]*/ GUID* pguidStartOnThisTab;
		/*[in]*/ LPCOLESTR pszBrowseFilters;
		/*[in,out]*/ BSTR* pbstrBrowseLocation;
		HRESULT retValue;
	};

	STDMETHOD(ComponentSelectorDlg2)(
		/*[in]*/ VSCOMPSELFLAGS2 grfFlags,
		/*[in]*/ IVsComponentUser* pUser,
		/*[in]*/ ULONG cComponents,
		/*[in,size_is(cComponents)]*/ PVSCOMPONENTSELECTORDATA rgpcsdComponents[],
		/*[in]*/ LPCOLESTR lpszDlgTitle,
		/*[in]*/ LPCOLESTR lpszHelpTopic,
		/*[in,out]*/ ULONG* pxDlgSize,
		/*[in,out]*/ ULONG* pyDlgSize,
		/*[in]*/ ULONG cTabInitializers,
		/*[in,size_is(cTabInitializers)]*/ VSCOMPONENTSELECTORTABINIT rgcstiTabInitializers[],
		/*[in,out]*/ GUID* pguidStartOnThisTab,
		/*[in]*/ LPCOLESTR pszBrowseFilters,
		/*[in,out]*/ BSTR* pbstrBrowseLocation)
	{
		VSL_DEFINE_MOCK_METHOD(ComponentSelectorDlg2)

		VSL_CHECK_VALIDVALUE(grfFlags);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUser);

		VSL_CHECK_VALIDVALUE(cComponents);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpcsdComponents, cComponents*sizeof(rgpcsdComponents[0]), validValues.cComponents*sizeof(validValues.rgpcsdComponents[0]));

		VSL_CHECK_VALIDVALUE_STRINGW(lpszDlgTitle);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszHelpTopic);

		VSL_SET_VALIDVALUE(pxDlgSize);

		VSL_SET_VALIDVALUE(pyDlgSize);

		VSL_CHECK_VALIDVALUE(cTabInitializers);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgcstiTabInitializers, cTabInitializers*sizeof(rgcstiTabInitializers[0]), validValues.cTabInitializers*sizeof(validValues.rgcstiTabInitializers[0]));

		VSL_SET_VALIDVALUE(pguidStartOnThisTab);

		VSL_CHECK_VALIDVALUE_STRINGW(pszBrowseFilters);

		VSL_SET_VALIDVALUE_BSTR(pbstrBrowseLocation);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCOMPONENTSELECTORDLG2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsComponentSelectorDlg.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCOMPONENTSELECTORDLG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCOMPONENTSELECTORDLG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsComponentSelectorDlgNotImpl :
	public IVsComponentSelectorDlg
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsComponentSelectorDlgNotImpl)

public:

	typedef IVsComponentSelectorDlg Interface;

	STDMETHOD(ComponentSelectorDlg)(
		/*[in]*/ VSCOMPSELFLAGS /*grfFlags*/,
		/*[in]*/ IVsComponentUser* /*pUser*/,
		/*[in]*/ LPCOLESTR /*lpszDlgTitle*/,
		/*[in]*/ LPCOLESTR /*lpszHelpTopic*/,
		/*[in]*/ REFGUID /*rguidShowOnlyThisTab*/,
		/*[in]*/ REFGUID /*rguidStartOnThisTab*/,
		/*[in]*/ LPCOLESTR /*pszMachineName*/,
		/*[in]*/ ULONG /*cTabInitializers*/,
		/*[in]*/ VSCOMPONENTSELECTORTABINIT* /*prgcstiTabInitializers*/,
		/*[in]*/ LPCOLESTR /*pszBrowseFilters*/,
		/*[in,out]*/ BSTR* /*pbstrBrowseLocation*/)VSL_STDMETHOD_NOTIMPL
};

class IVsComponentSelectorDlgMockImpl :
	public IVsComponentSelectorDlg,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsComponentSelectorDlgMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsComponentSelectorDlgMockImpl)

	typedef IVsComponentSelectorDlg Interface;
	struct ComponentSelectorDlgValidValues
	{
		/*[in]*/ VSCOMPSELFLAGS grfFlags;
		/*[in]*/ IVsComponentUser* pUser;
		/*[in]*/ LPCOLESTR lpszDlgTitle;
		/*[in]*/ LPCOLESTR lpszHelpTopic;
		/*[in]*/ REFGUID rguidShowOnlyThisTab;
		/*[in]*/ REFGUID rguidStartOnThisTab;
		/*[in]*/ LPCOLESTR pszMachineName;
		/*[in]*/ ULONG cTabInitializers;
		/*[in]*/ VSCOMPONENTSELECTORTABINIT* prgcstiTabInitializers;
		/*[in]*/ LPCOLESTR pszBrowseFilters;
		/*[in,out]*/ BSTR* pbstrBrowseLocation;
		HRESULT retValue;
	};

	STDMETHOD(ComponentSelectorDlg)(
		/*[in]*/ VSCOMPSELFLAGS grfFlags,
		/*[in]*/ IVsComponentUser* pUser,
		/*[in]*/ LPCOLESTR lpszDlgTitle,
		/*[in]*/ LPCOLESTR lpszHelpTopic,
		/*[in]*/ REFGUID rguidShowOnlyThisTab,
		/*[in]*/ REFGUID rguidStartOnThisTab,
		/*[in]*/ LPCOLESTR pszMachineName,
		/*[in]*/ ULONG cTabInitializers,
		/*[in]*/ VSCOMPONENTSELECTORTABINIT* prgcstiTabInitializers,
		/*[in]*/ LPCOLESTR pszBrowseFilters,
		/*[in,out]*/ BSTR* pbstrBrowseLocation)
	{
		VSL_DEFINE_MOCK_METHOD(ComponentSelectorDlg)

		VSL_CHECK_VALIDVALUE(grfFlags);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUser);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszDlgTitle);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszHelpTopic);

		VSL_CHECK_VALIDVALUE(rguidShowOnlyThisTab);

		VSL_CHECK_VALIDVALUE(rguidStartOnThisTab);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMachineName);

		VSL_CHECK_VALIDVALUE(cTabInitializers);

		VSL_CHECK_VALIDVALUE_POINTER(prgcstiTabInitializers);

		VSL_CHECK_VALIDVALUE_STRINGW(pszBrowseFilters);

		VSL_SET_VALIDVALUE_BSTR(pbstrBrowseLocation);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCOMPONENTSELECTORDLG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsComponentSelectorProvider.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCOMPONENTSELECTORPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCOMPONENTSELECTORPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsComponentSelectorProviderNotImpl :
	public IVsComponentSelectorProvider
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsComponentSelectorProviderNotImpl)

public:

	typedef IVsComponentSelectorProvider Interface;

	STDMETHOD(GetComponentSelectorPage)(
		/*[in]*/ REFGUID /*rguidPage*/,
		/*[in,out]*/ VSPROPSHEETPAGE* /*pPage*/)VSL_STDMETHOD_NOTIMPL
};

class IVsComponentSelectorProviderMockImpl :
	public IVsComponentSelectorProvider,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsComponentSelectorProviderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsComponentSelectorProviderMockImpl)

	typedef IVsComponentSelectorProvider Interface;
	struct GetComponentSelectorPageValidValues
	{
		/*[in]*/ REFGUID rguidPage;
		/*[in,out]*/ VSPROPSHEETPAGE* pPage;
		HRESULT retValue;
	};

	STDMETHOD(GetComponentSelectorPage)(
		/*[in]*/ REFGUID rguidPage,
		/*[in,out]*/ VSPROPSHEETPAGE* pPage)
	{
		VSL_DEFINE_MOCK_METHOD(GetComponentSelectorPage)

		VSL_CHECK_VALIDVALUE(rguidPage);

		VSL_SET_VALIDVALUE(pPage);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCOMPONENTSELECTORPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsCompoundAction.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCOMPOUNDACTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCOMPOUNDACTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsCompoundActionNotImpl :
	public IVsCompoundAction
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCompoundActionNotImpl)

public:

	typedef IVsCompoundAction Interface;

	STDMETHOD(OpenCompoundAction)(
		/*[in]*/ const WCHAR* /*pszDescription*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AbortCompoundAction)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CloseCompoundAction)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FlushEditActions)()VSL_STDMETHOD_NOTIMPL
};

class IVsCompoundActionMockImpl :
	public IVsCompoundAction,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCompoundActionMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsCompoundActionMockImpl)

	typedef IVsCompoundAction Interface;
	struct OpenCompoundActionValidValues
	{
		/*[in]*/ WCHAR* pszDescription;
		HRESULT retValue;
	};

	STDMETHOD(OpenCompoundAction)(
		/*[in]*/ const WCHAR* pszDescription)
	{
		VSL_DEFINE_MOCK_METHOD(OpenCompoundAction)

		VSL_CHECK_VALIDVALUE_STRINGW(pszDescription);

		VSL_RETURN_VALIDVALUES();
	}
	struct AbortCompoundActionValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(AbortCompoundAction)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(AbortCompoundAction)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloseCompoundActionValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CloseCompoundAction)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CloseCompoundAction)

		VSL_RETURN_VALIDVALUES();
	}
	struct FlushEditActionsValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(FlushEditActions)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(FlushEditActions)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCOMPOUNDACTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsComponentUser.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCOMPONENTUSER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCOMPONENTUSER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsComponentUserNotImpl :
	public IVsComponentUser
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsComponentUserNotImpl)

public:

	typedef IVsComponentUser Interface;

	STDMETHOD(AddComponent)(
		/*[in]*/ VSADDCOMPOPERATION /*dwAddCompOperation*/,
		/*[in]*/ ULONG /*cComponents*/,
		/*[in,size_is(cComponents)]*/ PVSCOMPONENTSELECTORDATA[] /*rgpcsdComponents*/,
		/*[in]*/ HWND /*hwndPickerDlg*/,
		/*[out,retval]*/ VSADDCOMPRESULT* /*pResult*/)VSL_STDMETHOD_NOTIMPL
};

class IVsComponentUserMockImpl :
	public IVsComponentUser,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsComponentUserMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsComponentUserMockImpl)

	typedef IVsComponentUser Interface;
	struct AddComponentValidValues
	{
		/*[in]*/ VSADDCOMPOPERATION dwAddCompOperation;
		/*[in]*/ ULONG cComponents;
		/*[in,size_is(cComponents)]*/ PVSCOMPONENTSELECTORDATA* rgpcsdComponents;
		/*[in]*/ HWND hwndPickerDlg;
		/*[out,retval]*/ VSADDCOMPRESULT* pResult;
		HRESULT retValue;
	};

	STDMETHOD(AddComponent)(
		/*[in]*/ VSADDCOMPOPERATION dwAddCompOperation,
		/*[in]*/ ULONG cComponents,
		/*[in,size_is(cComponents)]*/ PVSCOMPONENTSELECTORDATA rgpcsdComponents[],
		/*[in]*/ HWND hwndPickerDlg,
		/*[out,retval]*/ VSADDCOMPRESULT* pResult)
	{
		VSL_DEFINE_MOCK_METHOD(AddComponent)

		VSL_CHECK_VALIDVALUE(dwAddCompOperation);

		VSL_CHECK_VALIDVALUE(cComponents);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpcsdComponents, cComponents*sizeof(rgpcsdComponents[0]), validValues.cComponents*sizeof(validValues.rgpcsdComponents[0]));

		VSL_CHECK_VALIDVALUE(hwndPickerDlg);

		VSL_SET_VALIDVALUE(pResult);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCOMPONENTUSER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsCompoundViewChange.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCOMPOUNDVIEWCHANGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCOMPOUNDVIEWCHANGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsCompoundViewChangeNotImpl :
	public IVsCompoundViewChange
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCompoundViewChangeNotImpl)

public:

	typedef IVsCompoundViewChange Interface;

	STDMETHOD(OpenCompoundViewChange)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CloseCompoundViewChange)()VSL_STDMETHOD_NOTIMPL
};

class IVsCompoundViewChangeMockImpl :
	public IVsCompoundViewChange,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCompoundViewChangeMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsCompoundViewChangeMockImpl)

	typedef IVsCompoundViewChange Interface;
	struct OpenCompoundViewChangeValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OpenCompoundViewChange)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OpenCompoundViewChange)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloseCompoundViewChangeValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CloseCompoundViewChange)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CloseCompoundViewChange)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCOMPOUNDVIEWCHANGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsConfigurationManagerDlg.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCONFIGURATIONMANAGERDLG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCONFIGURATIONMANAGERDLG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsConfigurationManagerDlgNotImpl :
	public IVsConfigurationManagerDlg
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsConfigurationManagerDlgNotImpl)

public:

	typedef IVsConfigurationManagerDlg Interface;

	STDMETHOD(ShowConfigurationManagerDlg)()VSL_STDMETHOD_NOTIMPL
};

class IVsConfigurationManagerDlgMockImpl :
	public IVsConfigurationManagerDlg,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsConfigurationManagerDlgMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsConfigurationManagerDlgMockImpl)

	typedef IVsConfigurationManagerDlg Interface;
	struct ShowConfigurationManagerDlgValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ShowConfigurationManagerDlg)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ShowConfigurationManagerDlg)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCONFIGURATIONMANAGERDLG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsComReferenceDlgEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCOMREFERENCEDLGEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCOMREFERENCEDLGEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsComReferenceDlgEventsNotImpl :
	public IVsComReferenceDlgEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsComReferenceDlgEventsNotImpl)

public:

	typedef IVsComReferenceDlgEvents Interface;

	STDMETHOD(OnQueryChecked)(
		/*[in]*/ PCOMREFERENCEINFO /*pItem*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnQueryUnchecked)(
		/*[in]*/ PCOMREFERENCEINFO /*pItem*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnWarnMissingTypelibs)(
		/*[in]*/ UINT /*cCnt*/,
		/*[in,size_is(cCnt)]*/ PCOMREFERENCEINFO* /*rgpItems*/)VSL_STDMETHOD_NOTIMPL
};

class IVsComReferenceDlgEventsMockImpl :
	public IVsComReferenceDlgEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsComReferenceDlgEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsComReferenceDlgEventsMockImpl)

	typedef IVsComReferenceDlgEvents Interface;
	struct OnQueryCheckedValidValues
	{
		/*[in]*/ PCOMREFERENCEINFO pItem;
		HRESULT retValue;
	};

	STDMETHOD(OnQueryChecked)(
		/*[in]*/ PCOMREFERENCEINFO pItem)
	{
		VSL_DEFINE_MOCK_METHOD(OnQueryChecked)

		VSL_CHECK_VALIDVALUE(pItem);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnQueryUncheckedValidValues
	{
		/*[in]*/ PCOMREFERENCEINFO pItem;
		HRESULT retValue;
	};

	STDMETHOD(OnQueryUnchecked)(
		/*[in]*/ PCOMREFERENCEINFO pItem)
	{
		VSL_DEFINE_MOCK_METHOD(OnQueryUnchecked)

		VSL_CHECK_VALIDVALUE(pItem);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnWarnMissingTypelibsValidValues
	{
		/*[in]*/ UINT cCnt;
		/*[in,size_is(cCnt)]*/ PCOMREFERENCEINFO* rgpItems;
		HRESULT retValue;
	};

	STDMETHOD(OnWarnMissingTypelibs)(
		/*[in]*/ UINT cCnt,
		/*[in,size_is(cCnt)]*/ PCOMREFERENCEINFO* rgpItems)
	{
		VSL_DEFINE_MOCK_METHOD(OnWarnMissingTypelibs)

		VSL_CHECK_VALIDVALUE(cCnt);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpItems, cCnt*sizeof(rgpItems[0]), validValues.cCnt*sizeof(validValues.rgpItems[0]));

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCOMREFERENCEDLGEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsComReferenceDlg.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCOMREFERENCEDLG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCOMREFERENCEDLG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsComReferenceDlgNotImpl :
	public IVsComReferenceDlg
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsComReferenceDlgNotImpl)

public:

	typedef IVsComReferenceDlg Interface;

	STDMETHOD(AddReferences)(
		/*[in]*/ UINT /*cRefs*/,
		/*[in]*/ PCOMREFERENCEINFO /*rgNewRefs*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetCheckedReferences)(
		/*[in]*/ UINT /*cRefs*/,
		/*[in]*/ PCOMREFERENCE /*rgRefs*/,
		/*[in]*/ UINT /*cLockedRefs*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AdviseReferenceEvents)(
		/*[in]*/ IVsComReferenceDlgEvents* /*pEvents*/,
		/*[out]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseReferenceEvents)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ShowReferencesDialog)(
		/*[in]*/ REFSHOWFLAGS /*dwReserved*/,
		/*[in]*/ LPOLESTR /*pszReserved*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumReferences)(
		/*[out]*/ IEnumComReferences** /*ppenum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumCheckedReferences)(
		/*[out]*/ IEnumComReferences** /*ppenum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumRemovedReferences)(
		/*[out]*/ IEnumComReferences** /*ppenum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetReferenceInfo)(
		/*[in]*/ REFGUID /*guidTypelib*/,
		/*[in]*/ WORD /*wVerMajor*/,
		/*[in]*/ WORD /*wVerMinor*/,
		/*[out]*/ PCOMREFERENCEINFO* /*ppRefInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FreeReferenceInfo)(
		/*[in]*/ PCOMREFERENCEINFO /*pRefInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPropertyPage)(
		/*[out]*/ DWORD_PTR* /*phPage*/,
		/*[in]*/ LPCOLESTR /*pszReserved*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetDisplayInfo)(
		/*[in]*/ REFSHOWFLAGS /*dwShow*/,
		/*[in]*/ LPOLESTR /*pszHelpFile*/,
		/*[in]*/ DWORD /*dwHelpContextId*/,
		/*[in]*/ LPOLESTR /*pszTitles*/)VSL_STDMETHOD_NOTIMPL
};

class IVsComReferenceDlgMockImpl :
	public IVsComReferenceDlg,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsComReferenceDlgMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsComReferenceDlgMockImpl)

	typedef IVsComReferenceDlg Interface;
	struct AddReferencesValidValues
	{
		/*[in]*/ UINT cRefs;
		/*[in]*/ PCOMREFERENCEINFO rgNewRefs;
		HRESULT retValue;
	};

	STDMETHOD(AddReferences)(
		/*[in]*/ UINT cRefs,
		/*[in]*/ PCOMREFERENCEINFO rgNewRefs)
	{
		VSL_DEFINE_MOCK_METHOD(AddReferences)

		VSL_CHECK_VALIDVALUE(cRefs);

		VSL_CHECK_VALIDVALUE(rgNewRefs);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetCheckedReferencesValidValues
	{
		/*[in]*/ UINT cRefs;
		/*[in]*/ PCOMREFERENCE rgRefs;
		/*[in]*/ UINT cLockedRefs;
		HRESULT retValue;
	};

	STDMETHOD(SetCheckedReferences)(
		/*[in]*/ UINT cRefs,
		/*[in]*/ PCOMREFERENCE rgRefs,
		/*[in]*/ UINT cLockedRefs)
	{
		VSL_DEFINE_MOCK_METHOD(SetCheckedReferences)

		VSL_CHECK_VALIDVALUE(cRefs);

		VSL_CHECK_VALIDVALUE(rgRefs);

		VSL_CHECK_VALIDVALUE(cLockedRefs);

		VSL_RETURN_VALIDVALUES();
	}
	struct AdviseReferenceEventsValidValues
	{
		/*[in]*/ IVsComReferenceDlgEvents* pEvents;
		/*[out]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(AdviseReferenceEvents)(
		/*[in]*/ IVsComReferenceDlgEvents* pEvents,
		/*[out]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(AdviseReferenceEvents)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pEvents);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseReferenceEventsValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnadviseReferenceEvents)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnadviseReferenceEvents)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct ShowReferencesDialogValidValues
	{
		/*[in]*/ REFSHOWFLAGS dwReserved;
		/*[in]*/ LPOLESTR pszReserved;
		HRESULT retValue;
	};

	STDMETHOD(ShowReferencesDialog)(
		/*[in]*/ REFSHOWFLAGS dwReserved,
		/*[in]*/ LPOLESTR pszReserved)
	{
		VSL_DEFINE_MOCK_METHOD(ShowReferencesDialog)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_CHECK_VALIDVALUE_STRINGW(pszReserved);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumReferencesValidValues
	{
		/*[out]*/ IEnumComReferences** ppenum;
		HRESULT retValue;
	};

	STDMETHOD(EnumReferences)(
		/*[out]*/ IEnumComReferences** ppenum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumReferences)

		VSL_SET_VALIDVALUE_INTERFACE(ppenum);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumCheckedReferencesValidValues
	{
		/*[out]*/ IEnumComReferences** ppenum;
		HRESULT retValue;
	};

	STDMETHOD(EnumCheckedReferences)(
		/*[out]*/ IEnumComReferences** ppenum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumCheckedReferences)

		VSL_SET_VALIDVALUE_INTERFACE(ppenum);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumRemovedReferencesValidValues
	{
		/*[out]*/ IEnumComReferences** ppenum;
		HRESULT retValue;
	};

	STDMETHOD(EnumRemovedReferences)(
		/*[out]*/ IEnumComReferences** ppenum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumRemovedReferences)

		VSL_SET_VALIDVALUE_INTERFACE(ppenum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetReferenceInfoValidValues
	{
		/*[in]*/ REFGUID guidTypelib;
		/*[in]*/ WORD wVerMajor;
		/*[in]*/ WORD wVerMinor;
		/*[out]*/ PCOMREFERENCEINFO* ppRefInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetReferenceInfo)(
		/*[in]*/ REFGUID guidTypelib,
		/*[in]*/ WORD wVerMajor,
		/*[in]*/ WORD wVerMinor,
		/*[out]*/ PCOMREFERENCEINFO* ppRefInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetReferenceInfo)

		VSL_CHECK_VALIDVALUE(guidTypelib);

		VSL_CHECK_VALIDVALUE(wVerMajor);

		VSL_CHECK_VALIDVALUE(wVerMinor);

		VSL_SET_VALIDVALUE(ppRefInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct FreeReferenceInfoValidValues
	{
		/*[in]*/ PCOMREFERENCEINFO pRefInfo;
		HRESULT retValue;
	};

	STDMETHOD(FreeReferenceInfo)(
		/*[in]*/ PCOMREFERENCEINFO pRefInfo)
	{
		VSL_DEFINE_MOCK_METHOD(FreeReferenceInfo)

		VSL_CHECK_VALIDVALUE(pRefInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPropertyPageValidValues
	{
		/*[out]*/ DWORD_PTR* phPage;
		/*[in]*/ LPCOLESTR pszReserved;
		HRESULT retValue;
	};

	STDMETHOD(GetPropertyPage)(
		/*[out]*/ DWORD_PTR* phPage,
		/*[in]*/ LPCOLESTR pszReserved)
	{
		VSL_DEFINE_MOCK_METHOD(GetPropertyPage)

		VSL_SET_VALIDVALUE(phPage);

		VSL_CHECK_VALIDVALUE_STRINGW(pszReserved);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetDisplayInfoValidValues
	{
		/*[in]*/ REFSHOWFLAGS dwShow;
		/*[in]*/ LPOLESTR pszHelpFile;
		/*[in]*/ DWORD dwHelpContextId;
		/*[in]*/ LPOLESTR pszTitles;
		HRESULT retValue;
	};

	STDMETHOD(SetDisplayInfo)(
		/*[in]*/ REFSHOWFLAGS dwShow,
		/*[in]*/ LPOLESTR pszHelpFile,
		/*[in]*/ DWORD dwHelpContextId,
		/*[in]*/ LPOLESTR pszTitles)
	{
		VSL_DEFINE_MOCK_METHOD(SetDisplayInfo)

		VSL_CHECK_VALIDVALUE(dwShow);

		VSL_CHECK_VALIDVALUE_STRINGW(pszHelpFile);

		VSL_CHECK_VALIDVALUE(dwHelpContextId);

		VSL_CHECK_VALIDVALUE_STRINGW(pszTitles);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCOMREFERENCEDLG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsContainedCode.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCONTAINEDCODE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCONTAINEDCODE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "singlefileeditor.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsContainedCodeNotImpl :
	public IVsContainedCode
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsContainedCodeNotImpl)

public:

	typedef IVsContainedCode Interface;

	STDMETHOD(EnumOriginalCodeBlocks)(
		/*[out]*/ IVsEnumCodeBlocks** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(HostSpansUpdated)()VSL_STDMETHOD_NOTIMPL
};

class IVsContainedCodeMockImpl :
	public IVsContainedCode,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsContainedCodeMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsContainedCodeMockImpl)

	typedef IVsContainedCode Interface;
	struct EnumOriginalCodeBlocksValidValues
	{
		/*[out]*/ IVsEnumCodeBlocks** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumOriginalCodeBlocks)(
		/*[out]*/ IVsEnumCodeBlocks** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumOriginalCodeBlocks)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct HostSpansUpdatedValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(HostSpansUpdated)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(HostSpansUpdated)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCONTAINEDCODE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsContainedLanguage.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCONTAINEDLANGUAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCONTAINEDLANGUAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "singlefileeditor.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsContainedLanguageNotImpl :
	public IVsContainedLanguage
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsContainedLanguageNotImpl)

public:

	typedef IVsContainedLanguage Interface;

	STDMETHOD(SetHost)(
		/*[in]*/ IVsContainedLanguageHost* /*pHost*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetColorizer)(
		/*[out,retval]*/ IVsColorizer** /*ppColorizer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTextViewFilter)(
		/*[in]*/ IVsIntellisenseHost* /*pISenseHost*/,
		/*[in]*/ IOleCommandTarget* /*pNextCmdTarget*/,
		/*[out,retval]*/ IVsTextViewFilter** /*pTextViewFilter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLanguageServiceID)(
		/*[out]*/ GUID* /*pguidLangService*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetBufferCoordinator)(
		/*[in]*/ IVsTextBufferCoordinator* /*pBC*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Refresh)(
		/*[in]*/ DWORD /*dwRefreshMode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(WaitForReadyState)()VSL_STDMETHOD_NOTIMPL
};

class IVsContainedLanguageMockImpl :
	public IVsContainedLanguage,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsContainedLanguageMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsContainedLanguageMockImpl)

	typedef IVsContainedLanguage Interface;
	struct SetHostValidValues
	{
		/*[in]*/ IVsContainedLanguageHost* pHost;
		HRESULT retValue;
	};

	STDMETHOD(SetHost)(
		/*[in]*/ IVsContainedLanguageHost* pHost)
	{
		VSL_DEFINE_MOCK_METHOD(SetHost)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHost);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetColorizerValidValues
	{
		/*[out,retval]*/ IVsColorizer** ppColorizer;
		HRESULT retValue;
	};

	STDMETHOD(GetColorizer)(
		/*[out,retval]*/ IVsColorizer** ppColorizer)
	{
		VSL_DEFINE_MOCK_METHOD(GetColorizer)

		VSL_SET_VALIDVALUE_INTERFACE(ppColorizer);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTextViewFilterValidValues
	{
		/*[in]*/ IVsIntellisenseHost* pISenseHost;
		/*[in]*/ IOleCommandTarget* pNextCmdTarget;
		/*[out,retval]*/ IVsTextViewFilter** pTextViewFilter;
		HRESULT retValue;
	};

	STDMETHOD(GetTextViewFilter)(
		/*[in]*/ IVsIntellisenseHost* pISenseHost,
		/*[in]*/ IOleCommandTarget* pNextCmdTarget,
		/*[out,retval]*/ IVsTextViewFilter** pTextViewFilter)
	{
		VSL_DEFINE_MOCK_METHOD(GetTextViewFilter)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pISenseHost);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pNextCmdTarget);

		VSL_SET_VALIDVALUE_INTERFACE(pTextViewFilter);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLanguageServiceIDValidValues
	{
		/*[out]*/ GUID* pguidLangService;
		HRESULT retValue;
	};

	STDMETHOD(GetLanguageServiceID)(
		/*[out]*/ GUID* pguidLangService)
	{
		VSL_DEFINE_MOCK_METHOD(GetLanguageServiceID)

		VSL_SET_VALIDVALUE(pguidLangService);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetBufferCoordinatorValidValues
	{
		/*[in]*/ IVsTextBufferCoordinator* pBC;
		HRESULT retValue;
	};

	STDMETHOD(SetBufferCoordinator)(
		/*[in]*/ IVsTextBufferCoordinator* pBC)
	{
		VSL_DEFINE_MOCK_METHOD(SetBufferCoordinator)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBC);

		VSL_RETURN_VALIDVALUES();
	}
	struct RefreshValidValues
	{
		/*[in]*/ DWORD dwRefreshMode;
		HRESULT retValue;
	};

	STDMETHOD(Refresh)(
		/*[in]*/ DWORD dwRefreshMode)
	{
		VSL_DEFINE_MOCK_METHOD(Refresh)

		VSL_CHECK_VALIDVALUE(dwRefreshMode);

		VSL_RETURN_VALIDVALUES();
	}
	struct WaitForReadyStateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(WaitForReadyState)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(WaitForReadyState)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCONTAINEDLANGUAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsContainedLanguageCodeSupport.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCONTAINEDLANGUAGECODESUPPORT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCONTAINEDLANGUAGECODESUPPORT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "singlefileeditor.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsContainedLanguageCodeSupportNotImpl :
	public IVsContainedLanguageCodeSupport
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsContainedLanguageCodeSupportNotImpl)

public:

	typedef IVsContainedLanguageCodeSupport Interface;

	STDMETHOD(CreateUniqueEventName)(
		/*[in]*/ LPCWSTR /*pszClassName*/,
		/*[in]*/ LPCWSTR /*pszObjectName*/,
		/*[in]*/ LPCWSTR /*pszNameOfEvent*/,
		/*[out]*/ BSTR* /*pbstrEventHandlerName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnsureEventHandler)(
		/*[in]*/ LPCWSTR /*pszClassName*/,
		/*[in]*/ LPCWSTR /*pszObjectTypeName*/,
		/*[in]*/ LPCWSTR /*pszNameOfEvent*/,
		/*[in]*/ LPCWSTR /*pszEventHandlerName*/,
		/*[in]*/ VSITEMID /*itemidInsertionPoint*/,
		/*[out]*/ BSTR* /*pbstrUniqueMemberID*/,
		/*[out]*/ BSTR* /*pbstrEventBody*/,
		/*[out]*/ TextSpan* /*pSpanInsertionPoint*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMemberNavigationPoint)(
		/*[in]*/ LPCWSTR /*pszClassName*/,
		/*[in]*/ LPCWSTR /*pszUniqueMemberID*/,
		/*[out]*/ TextSpan* /*pSpanNavPoint*/,
		/*[out]*/ VSITEMID* /*pItemID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMembers)(
		/*[in]*/ LPCWSTR /*pszClassName*/,
		/*[in]*/ DWORD /*dwFlags*/,
		/*[out]*/ int* /*pcMembers*/,
		/*[out]*/ BSTR** /*ppbstrDisplayNames*/,
		/*[out]*/ BSTR** /*ppbstrMemberIDs*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnRenamed)(
		/*[in]*/ ContainedLanguageRenameType /*clrt*/,
		/*[in]*/ BSTR /*bstrOldID*/,
		/*[in]*/ BSTR /*bstrNewID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsValidID)(
		/*[in]*/ BSTR /*bstrID*/,
		/*[out]*/ VARIANT_BOOL* /*pfIsValidID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBaseClassName)(
		/*[in]*/ LPCWSTR /*pszClassName*/,
		/*[out]*/ BSTR* /*pbstrBaseClassName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEventHandlerMemberID)(
		/*[in]*/ LPCWSTR /*pszClassName*/,
		/*[in]*/ LPCWSTR /*pszObjectTypeName*/,
		/*[in]*/ LPCWSTR /*pszNameOfEvent*/,
		/*[in]*/ LPCWSTR /*pszEventHandlerName*/,
		/*[out]*/ BSTR* /*pbstrUniqueMemberID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCompatibleEventHandlers)(
		/*[in]*/ LPCWSTR /*pszClassName*/,
		/*[in]*/ LPCWSTR /*pszObjectTypeName*/,
		/*[in]*/ LPCWSTR /*pszNameOfEvent*/,
		/*[out]*/ int* /*pcMembers*/,
		/*[out]*/ BSTR** /*ppbstrEventHandlerNames*/,
		/*[out]*/ BSTR** /*ppbstrMemberIDs*/)VSL_STDMETHOD_NOTIMPL
};

class IVsContainedLanguageCodeSupportMockImpl :
	public IVsContainedLanguageCodeSupport,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsContainedLanguageCodeSupportMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsContainedLanguageCodeSupportMockImpl)

	typedef IVsContainedLanguageCodeSupport Interface;
	struct CreateUniqueEventNameValidValues
	{
		/*[in]*/ LPCWSTR pszClassName;
		/*[in]*/ LPCWSTR pszObjectName;
		/*[in]*/ LPCWSTR pszNameOfEvent;
		/*[out]*/ BSTR* pbstrEventHandlerName;
		HRESULT retValue;
	};

	STDMETHOD(CreateUniqueEventName)(
		/*[in]*/ LPCWSTR pszClassName,
		/*[in]*/ LPCWSTR pszObjectName,
		/*[in]*/ LPCWSTR pszNameOfEvent,
		/*[out]*/ BSTR* pbstrEventHandlerName)
	{
		VSL_DEFINE_MOCK_METHOD(CreateUniqueEventName)

		VSL_CHECK_VALIDVALUE_STRINGW(pszClassName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszObjectName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszNameOfEvent);

		VSL_SET_VALIDVALUE_BSTR(pbstrEventHandlerName);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnsureEventHandlerValidValues
	{
		/*[in]*/ LPCWSTR pszClassName;
		/*[in]*/ LPCWSTR pszObjectTypeName;
		/*[in]*/ LPCWSTR pszNameOfEvent;
		/*[in]*/ LPCWSTR pszEventHandlerName;
		/*[in]*/ VSITEMID itemidInsertionPoint;
		/*[out]*/ BSTR* pbstrUniqueMemberID;
		/*[out]*/ BSTR* pbstrEventBody;
		/*[out]*/ TextSpan* pSpanInsertionPoint;
		HRESULT retValue;
	};

	STDMETHOD(EnsureEventHandler)(
		/*[in]*/ LPCWSTR pszClassName,
		/*[in]*/ LPCWSTR pszObjectTypeName,
		/*[in]*/ LPCWSTR pszNameOfEvent,
		/*[in]*/ LPCWSTR pszEventHandlerName,
		/*[in]*/ VSITEMID itemidInsertionPoint,
		/*[out]*/ BSTR* pbstrUniqueMemberID,
		/*[out]*/ BSTR* pbstrEventBody,
		/*[out]*/ TextSpan* pSpanInsertionPoint)
	{
		VSL_DEFINE_MOCK_METHOD(EnsureEventHandler)

		VSL_CHECK_VALIDVALUE_STRINGW(pszClassName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszObjectTypeName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszNameOfEvent);

		VSL_CHECK_VALIDVALUE_STRINGW(pszEventHandlerName);

		VSL_CHECK_VALIDVALUE(itemidInsertionPoint);

		VSL_SET_VALIDVALUE_BSTR(pbstrUniqueMemberID);

		VSL_SET_VALIDVALUE_BSTR(pbstrEventBody);

		VSL_SET_VALIDVALUE(pSpanInsertionPoint);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMemberNavigationPointValidValues
	{
		/*[in]*/ LPCWSTR pszClassName;
		/*[in]*/ LPCWSTR pszUniqueMemberID;
		/*[out]*/ TextSpan* pSpanNavPoint;
		/*[out]*/ VSITEMID* pItemID;
		HRESULT retValue;
	};

	STDMETHOD(GetMemberNavigationPoint)(
		/*[in]*/ LPCWSTR pszClassName,
		/*[in]*/ LPCWSTR pszUniqueMemberID,
		/*[out]*/ TextSpan* pSpanNavPoint,
		/*[out]*/ VSITEMID* pItemID)
	{
		VSL_DEFINE_MOCK_METHOD(GetMemberNavigationPoint)

		VSL_CHECK_VALIDVALUE_STRINGW(pszClassName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszUniqueMemberID);

		VSL_SET_VALIDVALUE(pSpanNavPoint);

		VSL_SET_VALIDVALUE(pItemID);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMembersValidValues
	{
		/*[in]*/ LPCWSTR pszClassName;
		/*[in]*/ DWORD dwFlags;
		/*[out]*/ int* pcMembers;
		/*[out]*/ BSTR** ppbstrDisplayNames;
		/*[out]*/ BSTR** ppbstrMemberIDs;
		HRESULT retValue;
	};

	STDMETHOD(GetMembers)(
		/*[in]*/ LPCWSTR pszClassName,
		/*[in]*/ DWORD dwFlags,
		/*[out]*/ int* pcMembers,
		/*[out]*/ BSTR** ppbstrDisplayNames,
		/*[out]*/ BSTR** ppbstrMemberIDs)
	{
		VSL_DEFINE_MOCK_METHOD(GetMembers)

		VSL_CHECK_VALIDVALUE_STRINGW(pszClassName);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_SET_VALIDVALUE(pcMembers);

		VSL_SET_VALIDVALUE(ppbstrDisplayNames);

		VSL_SET_VALIDVALUE(ppbstrMemberIDs);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnRenamedValidValues
	{
		/*[in]*/ ContainedLanguageRenameType clrt;
		/*[in]*/ BSTR bstrOldID;
		/*[in]*/ BSTR bstrNewID;
		HRESULT retValue;
	};

	STDMETHOD(OnRenamed)(
		/*[in]*/ ContainedLanguageRenameType clrt,
		/*[in]*/ BSTR bstrOldID,
		/*[in]*/ BSTR bstrNewID)
	{
		VSL_DEFINE_MOCK_METHOD(OnRenamed)

		VSL_CHECK_VALIDVALUE(clrt);

		VSL_CHECK_VALIDVALUE_BSTR(bstrOldID);

		VSL_CHECK_VALIDVALUE_BSTR(bstrNewID);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsValidIDValidValues
	{
		/*[in]*/ BSTR bstrID;
		/*[out]*/ VARIANT_BOOL* pfIsValidID;
		HRESULT retValue;
	};

	STDMETHOD(IsValidID)(
		/*[in]*/ BSTR bstrID,
		/*[out]*/ VARIANT_BOOL* pfIsValidID)
	{
		VSL_DEFINE_MOCK_METHOD(IsValidID)

		VSL_CHECK_VALIDVALUE_BSTR(bstrID);

		VSL_SET_VALIDVALUE(pfIsValidID);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBaseClassNameValidValues
	{
		/*[in]*/ LPCWSTR pszClassName;
		/*[out]*/ BSTR* pbstrBaseClassName;
		HRESULT retValue;
	};

	STDMETHOD(GetBaseClassName)(
		/*[in]*/ LPCWSTR pszClassName,
		/*[out]*/ BSTR* pbstrBaseClassName)
	{
		VSL_DEFINE_MOCK_METHOD(GetBaseClassName)

		VSL_CHECK_VALIDVALUE_STRINGW(pszClassName);

		VSL_SET_VALIDVALUE_BSTR(pbstrBaseClassName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEventHandlerMemberIDValidValues
	{
		/*[in]*/ LPCWSTR pszClassName;
		/*[in]*/ LPCWSTR pszObjectTypeName;
		/*[in]*/ LPCWSTR pszNameOfEvent;
		/*[in]*/ LPCWSTR pszEventHandlerName;
		/*[out]*/ BSTR* pbstrUniqueMemberID;
		HRESULT retValue;
	};

	STDMETHOD(GetEventHandlerMemberID)(
		/*[in]*/ LPCWSTR pszClassName,
		/*[in]*/ LPCWSTR pszObjectTypeName,
		/*[in]*/ LPCWSTR pszNameOfEvent,
		/*[in]*/ LPCWSTR pszEventHandlerName,
		/*[out]*/ BSTR* pbstrUniqueMemberID)
	{
		VSL_DEFINE_MOCK_METHOD(GetEventHandlerMemberID)

		VSL_CHECK_VALIDVALUE_STRINGW(pszClassName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszObjectTypeName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszNameOfEvent);

		VSL_CHECK_VALIDVALUE_STRINGW(pszEventHandlerName);

		VSL_SET_VALIDVALUE_BSTR(pbstrUniqueMemberID);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCompatibleEventHandlersValidValues
	{
		/*[in]*/ LPCWSTR pszClassName;
		/*[in]*/ LPCWSTR pszObjectTypeName;
		/*[in]*/ LPCWSTR pszNameOfEvent;
		/*[out]*/ int* pcMembers;
		/*[out]*/ BSTR** ppbstrEventHandlerNames;
		/*[out]*/ BSTR** ppbstrMemberIDs;
		HRESULT retValue;
	};

	STDMETHOD(GetCompatibleEventHandlers)(
		/*[in]*/ LPCWSTR pszClassName,
		/*[in]*/ LPCWSTR pszObjectTypeName,
		/*[in]*/ LPCWSTR pszNameOfEvent,
		/*[out]*/ int* pcMembers,
		/*[out]*/ BSTR** ppbstrEventHandlerNames,
		/*[out]*/ BSTR** ppbstrMemberIDs)
	{
		VSL_DEFINE_MOCK_METHOD(GetCompatibleEventHandlers)

		VSL_CHECK_VALIDVALUE_STRINGW(pszClassName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszObjectTypeName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszNameOfEvent);

		VSL_SET_VALIDVALUE(pcMembers);

		VSL_SET_VALIDVALUE(ppbstrEventHandlerNames);

		VSL_SET_VALIDVALUE(ppbstrMemberIDs);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCONTAINEDLANGUAGECODESUPPORT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsContainedLanguageColorizer.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCONTAINEDLANGUAGECOLORIZER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCONTAINEDLANGUAGECOLORIZER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "singlefileeditor.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsContainedLanguageColorizerNotImpl :
	public IVsContainedLanguageColorizer
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsContainedLanguageColorizerNotImpl)

public:

	typedef IVsContainedLanguageColorizer Interface;

	STDMETHOD(ColorizeLineFragment)(
		/*[in]*/ long /*iLine*/,
		/*[in]*/ long /*iIndex*/,
		/*[in]*/ long /*iLength*/,
		/*[in]*/ const WCHAR* /*pszText*/,
		/*[in]*/ long /*iState*/,
		/*[out]*/ ULONG* /*pAttributes*/,
		/*[out]*/ long* /*piNewState*/)VSL_STDMETHOD_NOTIMPL
};

class IVsContainedLanguageColorizerMockImpl :
	public IVsContainedLanguageColorizer,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsContainedLanguageColorizerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsContainedLanguageColorizerMockImpl)

	typedef IVsContainedLanguageColorizer Interface;
	struct ColorizeLineFragmentValidValues
	{
		/*[in]*/ long iLine;
		/*[in]*/ long iIndex;
		/*[in]*/ long iLength;
		/*[in]*/ WCHAR* pszText;
		/*[in]*/ long iState;
		/*[out]*/ ULONG* pAttributes;
		/*[out]*/ long* piNewState;
		HRESULT retValue;
	};

	STDMETHOD(ColorizeLineFragment)(
		/*[in]*/ long iLine,
		/*[in]*/ long iIndex,
		/*[in]*/ long iLength,
		/*[in]*/ const WCHAR* pszText,
		/*[in]*/ long iState,
		/*[out]*/ ULONG* pAttributes,
		/*[out]*/ long* piNewState)
	{
		VSL_DEFINE_MOCK_METHOD(ColorizeLineFragment)

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_CHECK_VALIDVALUE(iIndex);

		VSL_CHECK_VALIDVALUE(iLength);

		VSL_CHECK_VALIDVALUE_STRINGW(pszText);

		VSL_CHECK_VALIDVALUE(iState);

		VSL_SET_VALIDVALUE(pAttributes);

		VSL_SET_VALIDVALUE(piNewState);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCONTAINEDLANGUAGECOLORIZER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsContainedLanguageHost.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCONTAINEDLANGUAGEHOST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCONTAINEDLANGUAGEHOST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "singlefileeditor.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsContainedLanguageHostNotImpl :
	public IVsContainedLanguageHost
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsContainedLanguageHostNotImpl)

public:

	typedef IVsContainedLanguageHost Interface;

	STDMETHOD(Advise)(
		/*[in]*/ IVsContainedLanguageHostEvents* /*pHost*/,
		/*[out]*/ VSCOOKIE* /*pvsCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Unadvise)(
		/*[in]*/ VSCOOKIE /*vsCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLineIndent)(
		/*[in]*/ long /*lLineNumber*/,
		/*[out]*/ BSTR* /*pbstrIndentString*/,
		/*[out]*/ long* /*plParentIndentLevel*/,
		/*[out]*/ long* /*plIndentSize*/,
		/*[out]*/ BOOL* /*pfTabs*/,
		/*[out]*/ long* /*plTabSize*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanReformatCode)(
		/*[out]*/ BOOL* /*pfCanReformat*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetNearestVisibleToken)(
		/*[in]*/ TextSpan /*tsSecondaryToken*/,
		/*[out]*/ TextSpan* /*ptsPrimaryToken*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnsureSpanVisible)(
		/*[in]*/ TextSpan /*tsPrimary*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryEditFile)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnRenamed)(
		/*[in]*/ ContainedLanguageRenameType /*clrt*/,
		/*[in]*/ BSTR /*bstrOldID*/,
		/*[in]*/ BSTR /*bstrNewID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(InsertControl)(
		/*[in]*/ const WCHAR* /*pwcFullType*/,
		/*[in]*/ const WCHAR* /*pwcID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(InsertReference)(
		/*[in]*/ const WCHAR* /*param1*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetVSHierarchy)(
		/*[out]*/ IVsHierarchy** /*ppVsHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetErrorProviderInformation)(
		/*[out]*/ BSTR* /*pbstrTaskProviderName*/,
		/*[out]*/ GUID* /*pguidTaskProviderGuid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(InsertImportsDirective)(
		/*[in]*/ const WCHAR* /*param1*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnContainedLanguageEditorSettingsChange)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnsureSecondaryBufferReady)()VSL_STDMETHOD_NOTIMPL
};

class IVsContainedLanguageHostMockImpl :
	public IVsContainedLanguageHost,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsContainedLanguageHostMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsContainedLanguageHostMockImpl)

	typedef IVsContainedLanguageHost Interface;
	struct AdviseValidValues
	{
		/*[in]*/ IVsContainedLanguageHostEvents* pHost;
		/*[out]*/ VSCOOKIE* pvsCookie;
		HRESULT retValue;
	};

	STDMETHOD(Advise)(
		/*[in]*/ IVsContainedLanguageHostEvents* pHost,
		/*[out]*/ VSCOOKIE* pvsCookie)
	{
		VSL_DEFINE_MOCK_METHOD(Advise)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHost);

		VSL_SET_VALIDVALUE(pvsCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseValidValues
	{
		/*[in]*/ VSCOOKIE vsCookie;
		HRESULT retValue;
	};

	STDMETHOD(Unadvise)(
		/*[in]*/ VSCOOKIE vsCookie)
	{
		VSL_DEFINE_MOCK_METHOD(Unadvise)

		VSL_CHECK_VALIDVALUE(vsCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLineIndentValidValues
	{
		/*[in]*/ long lLineNumber;
		/*[out]*/ BSTR* pbstrIndentString;
		/*[out]*/ long* plParentIndentLevel;
		/*[out]*/ long* plIndentSize;
		/*[out]*/ BOOL* pfTabs;
		/*[out]*/ long* plTabSize;
		HRESULT retValue;
	};

	STDMETHOD(GetLineIndent)(
		/*[in]*/ long lLineNumber,
		/*[out]*/ BSTR* pbstrIndentString,
		/*[out]*/ long* plParentIndentLevel,
		/*[out]*/ long* plIndentSize,
		/*[out]*/ BOOL* pfTabs,
		/*[out]*/ long* plTabSize)
	{
		VSL_DEFINE_MOCK_METHOD(GetLineIndent)

		VSL_CHECK_VALIDVALUE(lLineNumber);

		VSL_SET_VALIDVALUE_BSTR(pbstrIndentString);

		VSL_SET_VALIDVALUE(plParentIndentLevel);

		VSL_SET_VALIDVALUE(plIndentSize);

		VSL_SET_VALIDVALUE(pfTabs);

		VSL_SET_VALIDVALUE(plTabSize);

		VSL_RETURN_VALIDVALUES();
	}
	struct CanReformatCodeValidValues
	{
		/*[out]*/ BOOL* pfCanReformat;
		HRESULT retValue;
	};

	STDMETHOD(CanReformatCode)(
		/*[out]*/ BOOL* pfCanReformat)
	{
		VSL_DEFINE_MOCK_METHOD(CanReformatCode)

		VSL_SET_VALIDVALUE(pfCanReformat);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNearestVisibleTokenValidValues
	{
		/*[in]*/ TextSpan tsSecondaryToken;
		/*[out]*/ TextSpan* ptsPrimaryToken;
		HRESULT retValue;
	};

	STDMETHOD(GetNearestVisibleToken)(
		/*[in]*/ TextSpan tsSecondaryToken,
		/*[out]*/ TextSpan* ptsPrimaryToken)
	{
		VSL_DEFINE_MOCK_METHOD(GetNearestVisibleToken)

		VSL_CHECK_VALIDVALUE(tsSecondaryToken);

		VSL_SET_VALIDVALUE(ptsPrimaryToken);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnsureSpanVisibleValidValues
	{
		/*[in]*/ TextSpan tsPrimary;
		HRESULT retValue;
	};

	STDMETHOD(EnsureSpanVisible)(
		/*[in]*/ TextSpan tsPrimary)
	{
		VSL_DEFINE_MOCK_METHOD(EnsureSpanVisible)

		VSL_CHECK_VALIDVALUE(tsPrimary);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryEditFileValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(QueryEditFile)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(QueryEditFile)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnRenamedValidValues
	{
		/*[in]*/ ContainedLanguageRenameType clrt;
		/*[in]*/ BSTR bstrOldID;
		/*[in]*/ BSTR bstrNewID;
		HRESULT retValue;
	};

	STDMETHOD(OnRenamed)(
		/*[in]*/ ContainedLanguageRenameType clrt,
		/*[in]*/ BSTR bstrOldID,
		/*[in]*/ BSTR bstrNewID)
	{
		VSL_DEFINE_MOCK_METHOD(OnRenamed)

		VSL_CHECK_VALIDVALUE(clrt);

		VSL_CHECK_VALIDVALUE_BSTR(bstrOldID);

		VSL_CHECK_VALIDVALUE_BSTR(bstrNewID);

		VSL_RETURN_VALIDVALUES();
	}
	struct InsertControlValidValues
	{
		/*[in]*/ WCHAR* pwcFullType;
		/*[in]*/ WCHAR* pwcID;
		HRESULT retValue;
	};

	STDMETHOD(InsertControl)(
		/*[in]*/ const WCHAR* pwcFullType,
		/*[in]*/ const WCHAR* pwcID)
	{
		VSL_DEFINE_MOCK_METHOD(InsertControl)

		VSL_CHECK_VALIDVALUE_STRINGW(pwcFullType);

		VSL_CHECK_VALIDVALUE_STRINGW(pwcID);

		VSL_RETURN_VALIDVALUES();
	}
	struct InsertReferenceValidValues
	{
		/*[in]*/ WCHAR* param1;
		HRESULT retValue;
	};

	STDMETHOD(InsertReference)(
		/*[in]*/ const WCHAR* param1)
	{
		VSL_DEFINE_MOCK_METHOD(InsertReference)

		VSL_CHECK_VALIDVALUE_STRINGW(param1);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetVSHierarchyValidValues
	{
		/*[out]*/ IVsHierarchy** ppVsHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(GetVSHierarchy)(
		/*[out]*/ IVsHierarchy** ppVsHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(GetVSHierarchy)

		VSL_SET_VALIDVALUE_INTERFACE(ppVsHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetErrorProviderInformationValidValues
	{
		/*[out]*/ BSTR* pbstrTaskProviderName;
		/*[out]*/ GUID* pguidTaskProviderGuid;
		HRESULT retValue;
	};

	STDMETHOD(GetErrorProviderInformation)(
		/*[out]*/ BSTR* pbstrTaskProviderName,
		/*[out]*/ GUID* pguidTaskProviderGuid)
	{
		VSL_DEFINE_MOCK_METHOD(GetErrorProviderInformation)

		VSL_SET_VALIDVALUE_BSTR(pbstrTaskProviderName);

		VSL_SET_VALIDVALUE(pguidTaskProviderGuid);

		VSL_RETURN_VALIDVALUES();
	}
	struct InsertImportsDirectiveValidValues
	{
		/*[in]*/ WCHAR* param1;
		HRESULT retValue;
	};

	STDMETHOD(InsertImportsDirective)(
		/*[in]*/ const WCHAR* param1)
	{
		VSL_DEFINE_MOCK_METHOD(InsertImportsDirective)

		VSL_CHECK_VALIDVALUE_STRINGW(param1);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnContainedLanguageEditorSettingsChangeValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnContainedLanguageEditorSettingsChange)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnContainedLanguageEditorSettingsChange)

		VSL_RETURN_VALIDVALUES();
	}
	struct EnsureSecondaryBufferReadyValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(EnsureSecondaryBufferReady)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(EnsureSecondaryBufferReady)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCONTAINEDLANGUAGEHOST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsContainedLanguageFactory.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCONTAINEDLANGUAGEFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCONTAINEDLANGUAGEFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "singlefileeditor.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsContainedLanguageFactoryNotImpl :
	public IVsContainedLanguageFactory
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsContainedLanguageFactoryNotImpl)

public:

	typedef IVsContainedLanguageFactory Interface;

	STDMETHOD(GetLanguage)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ IVsTextBufferCoordinator* /*pBufferCoordinator*/,
		/*[out,retval]*/ IVsContainedLanguage** /*ppLanguage*/)VSL_STDMETHOD_NOTIMPL
};

class IVsContainedLanguageFactoryMockImpl :
	public IVsContainedLanguageFactory,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsContainedLanguageFactoryMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsContainedLanguageFactoryMockImpl)

	typedef IVsContainedLanguageFactory Interface;
	struct GetLanguageValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ IVsTextBufferCoordinator* pBufferCoordinator;
		/*[out,retval]*/ IVsContainedLanguage** ppLanguage;
		HRESULT retValue;
	};

	STDMETHOD(GetLanguage)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ IVsTextBufferCoordinator* pBufferCoordinator,
		/*[out,retval]*/ IVsContainedLanguage** ppLanguage)
	{
		VSL_DEFINE_MOCK_METHOD(GetLanguage)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBufferCoordinator);

		VSL_SET_VALIDVALUE_INTERFACE(ppLanguage);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCONTAINEDLANGUAGEFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsContainedLanguageHostEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCONTAINEDLANGUAGEHOSTEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCONTAINEDLANGUAGEHOSTEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "singlefileeditor.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsContainedLanguageHostEventsNotImpl :
	public IVsContainedLanguageHostEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsContainedLanguageHostEventsNotImpl)

public:

	typedef IVsContainedLanguageHostEvents Interface;

	STDMETHOD(OnViewChange)(
		/*[in]*/ BOOL /*fTextView*/)VSL_STDMETHOD_NOTIMPL
};

class IVsContainedLanguageHostEventsMockImpl :
	public IVsContainedLanguageHostEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsContainedLanguageHostEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsContainedLanguageHostEventsMockImpl)

	typedef IVsContainedLanguageHostEvents Interface;
	struct OnViewChangeValidValues
	{
		/*[in]*/ BOOL fTextView;
		HRESULT retValue;
	};

	STDMETHOD(OnViewChange)(
		/*[in]*/ BOOL fTextView)
	{
		VSL_DEFINE_MOCK_METHOD(OnViewChange)

		VSL_CHECK_VALIDVALUE(fTextView);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCONTAINEDLANGUAGEHOSTEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsContainedLanguageProjectNameProvider.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCONTAINEDLANGUAGEPROJECTNAMEPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCONTAINEDLANGUAGEPROJECTNAMEPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "singlefileeditor.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsContainedLanguageProjectNameProviderNotImpl :
	public IVsContainedLanguageProjectNameProvider
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsContainedLanguageProjectNameProviderNotImpl)

public:

	typedef IVsContainedLanguageProjectNameProvider Interface;

	STDMETHOD(GetProjectName)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[out,retval]*/ BSTR* /*pbstrProjectName*/)VSL_STDMETHOD_NOTIMPL
};

class IVsContainedLanguageProjectNameProviderMockImpl :
	public IVsContainedLanguageProjectNameProvider,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsContainedLanguageProjectNameProviderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsContainedLanguageProjectNameProviderMockImpl)

	typedef IVsContainedLanguageProjectNameProvider Interface;
	struct GetProjectNameValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[out,retval]*/ BSTR* pbstrProjectName;
		HRESULT retValue;
	};

	STDMETHOD(GetProjectName)(
		/*[in]*/ VSITEMID itemid,
		/*[out,retval]*/ BSTR* pbstrProjectName)
	{
		VSL_DEFINE_MOCK_METHOD(GetProjectName)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_SET_VALIDVALUE_BSTR(pbstrProjectName);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCONTAINEDLANGUAGEPROJECTNAMEPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsContainedLanguageStaticEventBinding.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCONTAINEDLANGUAGESTATICEVENTBINDING_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCONTAINEDLANGUAGESTATICEVENTBINDING_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "singlefileeditor.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsContainedLanguageStaticEventBindingNotImpl :
	public IVsContainedLanguageStaticEventBinding
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsContainedLanguageStaticEventBindingNotImpl)

public:

	typedef IVsContainedLanguageStaticEventBinding Interface;

	STDMETHOD(GetStaticEventBindingsForObject)(
		/*[in]*/ LPCWSTR /*pszClassName*/,
		/*[in]*/ LPCWSTR /*pszObjectName*/,
		/*[out]*/ int* /*pcMembers*/,
		/*[out]*/ BSTR** /*ppbstrEventNames*/,
		/*[out]*/ BSTR** /*ppbstrDisplayNames*/,
		/*[out]*/ BSTR** /*ppbstrMemberIDs*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveStaticEventBinding)(
		/*[in]*/ LPCWSTR /*pszClassName*/,
		/*[in]*/ LPCWSTR /*pszUniqueMemberID*/,
		/*[in]*/ LPCWSTR /*pszObjectName*/,
		/*[in]*/ LPCWSTR /*pszNameOfEvent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddStaticEventBinding)(
		/*[in]*/ LPCWSTR /*pszClassName*/,
		/*[in]*/ LPCWSTR /*pszUniqueMemberID*/,
		/*[in]*/ LPCWSTR /*pszObjectName*/,
		/*[in]*/ LPCWSTR /*pszNameOfEvent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnsureStaticEventHandler)(
		/*[in]*/ LPCWSTR /*pszClassName*/,
		/*[in]*/ LPCWSTR /*pszObjectTypeName*/,
		/*[in]*/ LPCWSTR /*pszObjectName*/,
		/*[in]*/ LPCWSTR /*pszNameOfEvent*/,
		/*[in]*/ LPCWSTR /*pszEventHandlerName*/,
		/*[in]*/ VSITEMID /*itemidInsertionPoint*/,
		/*[out]*/ BSTR* /*pbstrUniqueMemberID*/,
		/*[out]*/ BSTR* /*pbstrEventBody*/,
		/*[out]*/ TextSpan* /*pSpanInsertionPoint*/)VSL_STDMETHOD_NOTIMPL
};

class IVsContainedLanguageStaticEventBindingMockImpl :
	public IVsContainedLanguageStaticEventBinding,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsContainedLanguageStaticEventBindingMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsContainedLanguageStaticEventBindingMockImpl)

	typedef IVsContainedLanguageStaticEventBinding Interface;
	struct GetStaticEventBindingsForObjectValidValues
	{
		/*[in]*/ LPCWSTR pszClassName;
		/*[in]*/ LPCWSTR pszObjectName;
		/*[out]*/ int* pcMembers;
		/*[out]*/ BSTR** ppbstrEventNames;
		/*[out]*/ BSTR** ppbstrDisplayNames;
		/*[out]*/ BSTR** ppbstrMemberIDs;
		HRESULT retValue;
	};

	STDMETHOD(GetStaticEventBindingsForObject)(
		/*[in]*/ LPCWSTR pszClassName,
		/*[in]*/ LPCWSTR pszObjectName,
		/*[out]*/ int* pcMembers,
		/*[out]*/ BSTR** ppbstrEventNames,
		/*[out]*/ BSTR** ppbstrDisplayNames,
		/*[out]*/ BSTR** ppbstrMemberIDs)
	{
		VSL_DEFINE_MOCK_METHOD(GetStaticEventBindingsForObject)

		VSL_CHECK_VALIDVALUE_STRINGW(pszClassName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszObjectName);

		VSL_SET_VALIDVALUE(pcMembers);

		VSL_SET_VALIDVALUE(ppbstrEventNames);

		VSL_SET_VALIDVALUE(ppbstrDisplayNames);

		VSL_SET_VALIDVALUE(ppbstrMemberIDs);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveStaticEventBindingValidValues
	{
		/*[in]*/ LPCWSTR pszClassName;
		/*[in]*/ LPCWSTR pszUniqueMemberID;
		/*[in]*/ LPCWSTR pszObjectName;
		/*[in]*/ LPCWSTR pszNameOfEvent;
		HRESULT retValue;
	};

	STDMETHOD(RemoveStaticEventBinding)(
		/*[in]*/ LPCWSTR pszClassName,
		/*[in]*/ LPCWSTR pszUniqueMemberID,
		/*[in]*/ LPCWSTR pszObjectName,
		/*[in]*/ LPCWSTR pszNameOfEvent)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveStaticEventBinding)

		VSL_CHECK_VALIDVALUE_STRINGW(pszClassName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszUniqueMemberID);

		VSL_CHECK_VALIDVALUE_STRINGW(pszObjectName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszNameOfEvent);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddStaticEventBindingValidValues
	{
		/*[in]*/ LPCWSTR pszClassName;
		/*[in]*/ LPCWSTR pszUniqueMemberID;
		/*[in]*/ LPCWSTR pszObjectName;
		/*[in]*/ LPCWSTR pszNameOfEvent;
		HRESULT retValue;
	};

	STDMETHOD(AddStaticEventBinding)(
		/*[in]*/ LPCWSTR pszClassName,
		/*[in]*/ LPCWSTR pszUniqueMemberID,
		/*[in]*/ LPCWSTR pszObjectName,
		/*[in]*/ LPCWSTR pszNameOfEvent)
	{
		VSL_DEFINE_MOCK_METHOD(AddStaticEventBinding)

		VSL_CHECK_VALIDVALUE_STRINGW(pszClassName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszUniqueMemberID);

		VSL_CHECK_VALIDVALUE_STRINGW(pszObjectName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszNameOfEvent);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnsureStaticEventHandlerValidValues
	{
		/*[in]*/ LPCWSTR pszClassName;
		/*[in]*/ LPCWSTR pszObjectTypeName;
		/*[in]*/ LPCWSTR pszObjectName;
		/*[in]*/ LPCWSTR pszNameOfEvent;
		/*[in]*/ LPCWSTR pszEventHandlerName;
		/*[in]*/ VSITEMID itemidInsertionPoint;
		/*[out]*/ BSTR* pbstrUniqueMemberID;
		/*[out]*/ BSTR* pbstrEventBody;
		/*[out]*/ TextSpan* pSpanInsertionPoint;
		HRESULT retValue;
	};

	STDMETHOD(EnsureStaticEventHandler)(
		/*[in]*/ LPCWSTR pszClassName,
		/*[in]*/ LPCWSTR pszObjectTypeName,
		/*[in]*/ LPCWSTR pszObjectName,
		/*[in]*/ LPCWSTR pszNameOfEvent,
		/*[in]*/ LPCWSTR pszEventHandlerName,
		/*[in]*/ VSITEMID itemidInsertionPoint,
		/*[out]*/ BSTR* pbstrUniqueMemberID,
		/*[out]*/ BSTR* pbstrEventBody,
		/*[out]*/ TextSpan* pSpanInsertionPoint)
	{
		VSL_DEFINE_MOCK_METHOD(EnsureStaticEventHandler)

		VSL_CHECK_VALIDVALUE_STRINGW(pszClassName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszObjectTypeName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszObjectName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszNameOfEvent);

		VSL_CHECK_VALIDVALUE_STRINGW(pszEventHandlerName);

		VSL_CHECK_VALIDVALUE(itemidInsertionPoint);

		VSL_SET_VALIDVALUE_BSTR(pbstrUniqueMemberID);

		VSL_SET_VALIDVALUE_BSTR(pbstrEventBody);

		VSL_SET_VALIDVALUE(pSpanInsertionPoint);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCONTAINEDLANGUAGESTATICEVENTBINDING_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsCustomFindScopeNotify.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCUSTOMFINDSCOPENOTIFY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCUSTOMFINDSCOPENOTIFY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "customfind.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsCustomFindScopeNotifyNotImpl :
	public IVsCustomFindScopeNotify
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCustomFindScopeNotifyNotImpl)

public:

	typedef IVsCustomFindScopeNotify Interface;

	STDMETHOD(Notify)(
		/*[in]*/ VSCUSTOMFINDSTATUS /*grfStatus*/)VSL_STDMETHOD_NOTIMPL
};

class IVsCustomFindScopeNotifyMockImpl :
	public IVsCustomFindScopeNotify,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCustomFindScopeNotifyMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsCustomFindScopeNotifyMockImpl)

	typedef IVsCustomFindScopeNotify Interface;
	struct NotifyValidValues
	{
		/*[in]*/ VSCUSTOMFINDSTATUS grfStatus;
		HRESULT retValue;
	};

	STDMETHOD(Notify)(
		/*[in]*/ VSCUSTOMFINDSTATUS grfStatus)
	{
		VSL_DEFINE_MOCK_METHOD(Notify)

		VSL_CHECK_VALIDVALUE(grfStatus);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCUSTOMFINDSCOPENOTIFY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsCustomFindScopeSearch.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCUSTOMFINDSCOPESEARCH_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCUSTOMFINDSCOPESEARCH_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "customfind.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsCustomFindScopeSearchNotImpl :
	public IVsCustomFindScopeSearch
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCustomFindScopeSearchNotImpl)

public:

	typedef IVsCustomFindScopeSearch Interface;

	STDMETHOD(Find)(
		/*[in]*/ VSBROWSESCOPEW /*VsBrowseScope*/,
		/*[in]*/ LPCOLESTR /*pszFind*/,
		/*[in]*/ LPCOLESTR /*pszFilter*/,
		/*[in]*/ VSFINDOPTIONS /*grfOptions*/,
		/*[in]*/ IVsCustomFindScopeNotify* /*pBatchFindNotify*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Replace)(
		/*[in]*/ VSBROWSESCOPEW /*VsBrowseScope*/,
		/*[in]*/ LPCOLESTR /*pszFind*/,
		/*[in]*/ LPCOLESTR /*pszReplace*/,
		/*[in]*/ LPCOLESTR /*pszFilter*/,
		/*[in]*/ VSFINDOPTIONS /*grfOptions*/,
		/*[in]*/ IVsCustomFindScopeNotify* /*pBatchFindNotify*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetStatus)(
		/*[out]*/ BSTR* /*pbstrStatus*/,
		/*[out,retval]*/ VSCUSTOMFINDSTATUS* /*pdwStatus*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Cancel)()VSL_STDMETHOD_NOTIMPL
};

class IVsCustomFindScopeSearchMockImpl :
	public IVsCustomFindScopeSearch,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCustomFindScopeSearchMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsCustomFindScopeSearchMockImpl)

	typedef IVsCustomFindScopeSearch Interface;
	struct FindValidValues
	{
		/*[in]*/ VSBROWSESCOPEW VsBrowseScope;
		/*[in]*/ LPCOLESTR pszFind;
		/*[in]*/ LPCOLESTR pszFilter;
		/*[in]*/ VSFINDOPTIONS grfOptions;
		/*[in]*/ IVsCustomFindScopeNotify* pBatchFindNotify;
		HRESULT retValue;
	};

	STDMETHOD(Find)(
		/*[in]*/ VSBROWSESCOPEW VsBrowseScope,
		/*[in]*/ LPCOLESTR pszFind,
		/*[in]*/ LPCOLESTR pszFilter,
		/*[in]*/ VSFINDOPTIONS grfOptions,
		/*[in]*/ IVsCustomFindScopeNotify* pBatchFindNotify)
	{
		VSL_DEFINE_MOCK_METHOD(Find)

		VSL_CHECK_VALIDVALUE(VsBrowseScope);

		VSL_CHECK_VALIDVALUE_STRINGW(pszFind);

		VSL_CHECK_VALIDVALUE_STRINGW(pszFilter);

		VSL_CHECK_VALIDVALUE(grfOptions);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBatchFindNotify);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReplaceValidValues
	{
		/*[in]*/ VSBROWSESCOPEW VsBrowseScope;
		/*[in]*/ LPCOLESTR pszFind;
		/*[in]*/ LPCOLESTR pszReplace;
		/*[in]*/ LPCOLESTR pszFilter;
		/*[in]*/ VSFINDOPTIONS grfOptions;
		/*[in]*/ IVsCustomFindScopeNotify* pBatchFindNotify;
		HRESULT retValue;
	};

	STDMETHOD(Replace)(
		/*[in]*/ VSBROWSESCOPEW VsBrowseScope,
		/*[in]*/ LPCOLESTR pszFind,
		/*[in]*/ LPCOLESTR pszReplace,
		/*[in]*/ LPCOLESTR pszFilter,
		/*[in]*/ VSFINDOPTIONS grfOptions,
		/*[in]*/ IVsCustomFindScopeNotify* pBatchFindNotify)
	{
		VSL_DEFINE_MOCK_METHOD(Replace)

		VSL_CHECK_VALIDVALUE(VsBrowseScope);

		VSL_CHECK_VALIDVALUE_STRINGW(pszFind);

		VSL_CHECK_VALIDVALUE_STRINGW(pszReplace);

		VSL_CHECK_VALIDVALUE_STRINGW(pszFilter);

		VSL_CHECK_VALIDVALUE(grfOptions);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBatchFindNotify);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetStatusValidValues
	{
		/*[out]*/ BSTR* pbstrStatus;
		/*[out,retval]*/ VSCUSTOMFINDSTATUS* pdwStatus;
		HRESULT retValue;
	};

	STDMETHOD(GetStatus)(
		/*[out]*/ BSTR* pbstrStatus,
		/*[out,retval]*/ VSCUSTOMFINDSTATUS* pdwStatus)
	{
		VSL_DEFINE_MOCK_METHOD(GetStatus)

		VSL_SET_VALIDVALUE_BSTR(pbstrStatus);

		VSL_SET_VALIDVALUE(pdwStatus);

		VSL_RETURN_VALIDVALUES();
	}
	struct CancelValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Cancel)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Cancel)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCUSTOMFINDSCOPESEARCH_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsCustomFindScope.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCUSTOMFINDSCOPE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCUSTOMFINDSCOPE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "customfind.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsCustomFindScopeNotImpl :
	public IVsCustomFindScope
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCustomFindScopeNotImpl)

public:

	typedef IVsCustomFindScope Interface;

	STDMETHOD(GetCustomFindScopeLookIn)(
		/*[out,retval]*/ IVsCustomFindScopeLookIn** /*ppFindLookIn*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCustomFindScopeSearch)(
		/*[out,retval]*/ IVsCustomFindScopeSearch** /*ppBatchFind*/)VSL_STDMETHOD_NOTIMPL
};

class IVsCustomFindScopeMockImpl :
	public IVsCustomFindScope,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCustomFindScopeMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsCustomFindScopeMockImpl)

	typedef IVsCustomFindScope Interface;
	struct GetCustomFindScopeLookInValidValues
	{
		/*[out,retval]*/ IVsCustomFindScopeLookIn** ppFindLookIn;
		HRESULT retValue;
	};

	STDMETHOD(GetCustomFindScopeLookIn)(
		/*[out,retval]*/ IVsCustomFindScopeLookIn** ppFindLookIn)
	{
		VSL_DEFINE_MOCK_METHOD(GetCustomFindScopeLookIn)

		VSL_SET_VALIDVALUE_INTERFACE(ppFindLookIn);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCustomFindScopeSearchValidValues
	{
		/*[out,retval]*/ IVsCustomFindScopeSearch** ppBatchFind;
		HRESULT retValue;
	};

	STDMETHOD(GetCustomFindScopeSearch)(
		/*[out,retval]*/ IVsCustomFindScopeSearch** ppBatchFind)
	{
		VSL_DEFINE_MOCK_METHOD(GetCustomFindScopeSearch)

		VSL_SET_VALIDVALUE_INTERFACE(ppBatchFind);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCUSTOMFINDSCOPE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsContextualIntellisenseFilterProvider.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCONTEXTUALINTELLISENSEFILTERPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCONTEXTUALINTELLISENSEFILTERPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsContextualIntellisenseFilterProviderNotImpl :
	public IVsContextualIntellisenseFilterProvider
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsContextualIntellisenseFilterProviderNotImpl)

public:

	typedef IVsContextualIntellisenseFilterProvider Interface;

	STDMETHOD(GetFilter)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[out]*/ IVsContextualIntellisenseFilter** /*ppFilter*/)VSL_STDMETHOD_NOTIMPL
};

class IVsContextualIntellisenseFilterProviderMockImpl :
	public IVsContextualIntellisenseFilterProvider,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsContextualIntellisenseFilterProviderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsContextualIntellisenseFilterProviderMockImpl)

	typedef IVsContextualIntellisenseFilterProvider Interface;
	struct GetFilterValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[out]*/ IVsContextualIntellisenseFilter** ppFilter;
		HRESULT retValue;
	};

	STDMETHOD(GetFilter)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[out]*/ IVsContextualIntellisenseFilter** ppFilter)
	{
		VSL_DEFINE_MOCK_METHOD(GetFilter)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_SET_VALIDVALUE_INTERFACE(ppFilter);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCONTEXTUALINTELLISENSEFILTERPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsCreateAggregateProject.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCREATEAGGREGATEPROJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCREATEAGGREGATEPROJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsCreateAggregateProjectNotImpl :
	public IVsCreateAggregateProject
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCreateAggregateProjectNotImpl)

public:

	typedef IVsCreateAggregateProject Interface;

	STDMETHOD(CreateAggregateProject)(
		/*[in]*/ LPCOLESTR /*pszProjectTypeGuids*/,
		/*[in]*/ LPCOLESTR /*pszFilename*/,
		/*[in]*/ LPCOLESTR /*pszLocation*/,
		/*[in]*/ LPCOLESTR /*pszName*/,
		/*[in]*/ VSCREATEPROJFLAGS /*grfCreateFlags*/,
		/*[in]*/ REFIID /*iidProject*/,
		/*[out,iid_is(iidProject)]*/ void** /*ppvProject*/)VSL_STDMETHOD_NOTIMPL
};

class IVsCreateAggregateProjectMockImpl :
	public IVsCreateAggregateProject,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCreateAggregateProjectMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsCreateAggregateProjectMockImpl)

	typedef IVsCreateAggregateProject Interface;
	struct CreateAggregateProjectValidValues
	{
		/*[in]*/ LPCOLESTR pszProjectTypeGuids;
		/*[in]*/ LPCOLESTR pszFilename;
		/*[in]*/ LPCOLESTR pszLocation;
		/*[in]*/ LPCOLESTR pszName;
		/*[in]*/ VSCREATEPROJFLAGS grfCreateFlags;
		/*[in]*/ REFIID iidProject;
		/*[out,iid_is(iidProject)]*/ void** ppvProject;
		HRESULT retValue;
	};

	STDMETHOD(CreateAggregateProject)(
		/*[in]*/ LPCOLESTR pszProjectTypeGuids,
		/*[in]*/ LPCOLESTR pszFilename,
		/*[in]*/ LPCOLESTR pszLocation,
		/*[in]*/ LPCOLESTR pszName,
		/*[in]*/ VSCREATEPROJFLAGS grfCreateFlags,
		/*[in]*/ REFIID iidProject,
		/*[out,iid_is(iidProject)]*/ void** ppvProject)
	{
		VSL_DEFINE_MOCK_METHOD(CreateAggregateProject)

		VSL_CHECK_VALIDVALUE_STRINGW(pszProjectTypeGuids);

		VSL_CHECK_VALIDVALUE_STRINGW(pszFilename);

		VSL_CHECK_VALIDVALUE_STRINGW(pszLocation);

		VSL_CHECK_VALIDVALUE_STRINGW(pszName);

		VSL_CHECK_VALIDVALUE(grfCreateFlags);

		VSL_CHECK_VALIDVALUE(iidProject);

		VSL_SET_VALIDVALUE(ppvProject);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCREATEAGGREGATEPROJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsCustomFindScopeLookIn.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCUSTOMFINDSCOPELOOKIN_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCUSTOMFINDSCOPELOOKIN_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "customfind.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsCustomFindScopeLookInNotImpl :
	public IVsCustomFindScopeLookIn
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCustomFindScopeLookInNotImpl)

public:

	typedef IVsCustomFindScopeLookIn Interface;

	STDMETHOD(Browse)(
		/*[in,out]*/ PVSBROWSESCOPEW /*pBrowseScope*/)VSL_STDMETHOD_NOTIMPL
};

class IVsCustomFindScopeLookInMockImpl :
	public IVsCustomFindScopeLookIn,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsCustomFindScopeLookInMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsCustomFindScopeLookInMockImpl)

	typedef IVsCustomFindScopeLookIn Interface;
	struct BrowseValidValues
	{
		/*[in,out]*/ PVSBROWSESCOPEW pBrowseScope;
		HRESULT retValue;
	};

	STDMETHOD(Browse)(
		/*[in,out]*/ PVSBROWSESCOPEW pBrowseScope)
	{
		VSL_DEFINE_MOCK_METHOD(Browse)

		VSL_SET_VALIDVALUE(pBrowseScope);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCUSTOMFINDSCOPELOOKIN_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsContextualIntellisenseFilter.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSCONTEXTUALINTELLISENSEFILTER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSCONTEXTUALINTELLISENSEFILTER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsContextualIntellisenseFilterNotImpl :
	public IVsContextualIntellisenseFilter
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsContextualIntellisenseFilterNotImpl)

public:

	typedef IVsContextualIntellisenseFilter Interface;

	STDMETHOD(Initialize)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsTypeVisible)(
		/*[in]*/ LPCOLESTR /*szTypeName*/,
		/*[out]*/ BOOL* /*pfVisible*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsMemberVisible)(
		/*[in]*/ LPCOLESTR /*szMemberSignature*/,
		/*[out]*/ BOOL* /*pfVisible*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Close)()VSL_STDMETHOD_NOTIMPL
};

class IVsContextualIntellisenseFilterMockImpl :
	public IVsContextualIntellisenseFilter,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsContextualIntellisenseFilterMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsContextualIntellisenseFilterMockImpl)

	typedef IVsContextualIntellisenseFilter Interface;
	struct InitializeValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(Initialize)(
		/*[in]*/ IVsHierarchy* pHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(Initialize)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsTypeVisibleValidValues
	{
		/*[in]*/ LPCOLESTR szTypeName;
		/*[out]*/ BOOL* pfVisible;
		HRESULT retValue;
	};

	STDMETHOD(IsTypeVisible)(
		/*[in]*/ LPCOLESTR szTypeName,
		/*[out]*/ BOOL* pfVisible)
	{
		VSL_DEFINE_MOCK_METHOD(IsTypeVisible)

		VSL_CHECK_VALIDVALUE_STRINGW(szTypeName);

		VSL_SET_VALIDVALUE(pfVisible);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsMemberVisibleValidValues
	{
		/*[in]*/ LPCOLESTR szMemberSignature;
		/*[out]*/ BOOL* pfVisible;
		HRESULT retValue;
	};

	STDMETHOD(IsMemberVisible)(
		/*[in]*/ LPCOLESTR szMemberSignature,
		/*[out]*/ BOOL* pfVisible)
	{
		VSL_DEFINE_MOCK_METHOD(IsMemberVisible)

		VSL_CHECK_VALIDVALUE_STRINGW(szMemberSignature);

		VSL_SET_VALIDVALUE(pfVisible);

		VSL_RETURN_VALIDVALUES();
	}
	struct CloseValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Close)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Close)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSCONTEXTUALINTELLISENSEFILTER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsDataEnvironment.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSDATAENVIRONMENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSDATAENVIRONMENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "containedlanguage.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsDataEnvironmentNotImpl :
	public IVsDataEnvironment
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDataEnvironmentNotImpl)

public:

	typedef IVsDataEnvironment Interface;

	STDMETHOD(Initialize)(
		/*[in]*/ IServiceProvider* /*pServiceProvider*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Dispose)()VSL_STDMETHOD_NOTIMPL
};

class IVsDataEnvironmentMockImpl :
	public IVsDataEnvironment,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDataEnvironmentMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsDataEnvironmentMockImpl)

	typedef IVsDataEnvironment Interface;
	struct InitializeValidValues
	{
		/*[in]*/ IServiceProvider* pServiceProvider;
		HRESULT retValue;
	};

	STDMETHOD(Initialize)(
		/*[in]*/ IServiceProvider* pServiceProvider)
	{
		VSL_DEFINE_MOCK_METHOD(Initialize)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pServiceProvider);

		VSL_RETURN_VALIDVALUES();
	}
	struct DisposeValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Dispose)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Dispose)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSDATAENVIRONMENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsDebuggableProjectCfg.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSDEBUGGABLEPROJECTCFG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSDEBUGGABLEPROJECTCFG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsDebuggableProjectCfgNotImpl :
	public IVsDebuggableProjectCfg
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDebuggableProjectCfgNotImpl)

public:

	typedef IVsDebuggableProjectCfg Interface;

	STDMETHOD(DebugLaunch)(
		/*[in]*/ VSDBGLAUNCHFLAGS /*grfLaunch*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryDebugLaunch)(
		/*[in]*/ VSDBGLAUNCHFLAGS /*grfLaunch*/,
		/*[out]*/ BOOL* /*pfCanLaunch*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumOutputs)(
		/*[out]*/ IVsEnumOutputs** /*ppIVsEnumOutputs*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OpenOutput)(
		/*[in]*/ LPCOLESTR /*szOutputCanonicalName*/,
		/*[out]*/ IVsOutput** /*ppIVsOutput*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ProjectCfgProvider)(
		/*[out]*/ IVsProjectCfgProvider** /*ppIVsProjectCfgProvider*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_BuildableProjectCfg)(
		/*[out]*/ IVsBuildableProjectCfg** /*ppIVsBuildableProjectCfg*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CanonicalName)(
		/*[out]*/ BSTR* /*pbstrCanonicalName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Platform)(
		/*[out]*/ GUID* /*pguidPlatform*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IsPackaged)(
		/*[out]*/ BOOL* /*pfIsPackaged*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IsSpecifyingOutputSupported)(
		/*[out]*/ BOOL* /*pfIsSpecifyingOutputSupported*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_TargetCodePage)(
		/*[out]*/ UINT* /*puiTargetCodePage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_UpdateSequenceNumber)(
		/*[out]*/ ULARGE_INTEGER* /*puliUSN*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RootURL)(
		/*[out]*/ BSTR* /*pbstrRootURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DisplayName)(
		/*[out]*/ BSTR* /*pbstrDisplayName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IsDebugOnly)(
		/*[out]*/ BOOL* /*pfIsDebugOnly*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IsReleaseOnly)(
		/*[out]*/ BOOL* /*pfIsReleaseOnly*/)VSL_STDMETHOD_NOTIMPL
};

class IVsDebuggableProjectCfgMockImpl :
	public IVsDebuggableProjectCfg,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDebuggableProjectCfgMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsDebuggableProjectCfgMockImpl)

	typedef IVsDebuggableProjectCfg Interface;
	struct DebugLaunchValidValues
	{
		/*[in]*/ VSDBGLAUNCHFLAGS grfLaunch;
		HRESULT retValue;
	};

	STDMETHOD(DebugLaunch)(
		/*[in]*/ VSDBGLAUNCHFLAGS grfLaunch)
	{
		VSL_DEFINE_MOCK_METHOD(DebugLaunch)

		VSL_CHECK_VALIDVALUE(grfLaunch);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryDebugLaunchValidValues
	{
		/*[in]*/ VSDBGLAUNCHFLAGS grfLaunch;
		/*[out]*/ BOOL* pfCanLaunch;
		HRESULT retValue;
	};

	STDMETHOD(QueryDebugLaunch)(
		/*[in]*/ VSDBGLAUNCHFLAGS grfLaunch,
		/*[out]*/ BOOL* pfCanLaunch)
	{
		VSL_DEFINE_MOCK_METHOD(QueryDebugLaunch)

		VSL_CHECK_VALIDVALUE(grfLaunch);

		VSL_SET_VALIDVALUE(pfCanLaunch);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumOutputsValidValues
	{
		/*[out]*/ IVsEnumOutputs** ppIVsEnumOutputs;
		HRESULT retValue;
	};

	STDMETHOD(EnumOutputs)(
		/*[out]*/ IVsEnumOutputs** ppIVsEnumOutputs)
	{
		VSL_DEFINE_MOCK_METHOD(EnumOutputs)

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsEnumOutputs);

		VSL_RETURN_VALIDVALUES();
	}
	struct OpenOutputValidValues
	{
		/*[in]*/ LPCOLESTR szOutputCanonicalName;
		/*[out]*/ IVsOutput** ppIVsOutput;
		HRESULT retValue;
	};

	STDMETHOD(OpenOutput)(
		/*[in]*/ LPCOLESTR szOutputCanonicalName,
		/*[out]*/ IVsOutput** ppIVsOutput)
	{
		VSL_DEFINE_MOCK_METHOD(OpenOutput)

		VSL_CHECK_VALIDVALUE_STRINGW(szOutputCanonicalName);

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsOutput);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ProjectCfgProviderValidValues
	{
		/*[out]*/ IVsProjectCfgProvider** ppIVsProjectCfgProvider;
		HRESULT retValue;
	};

	STDMETHOD(get_ProjectCfgProvider)(
		/*[out]*/ IVsProjectCfgProvider** ppIVsProjectCfgProvider)
	{
		VSL_DEFINE_MOCK_METHOD(get_ProjectCfgProvider)

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsProjectCfgProvider);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_BuildableProjectCfgValidValues
	{
		/*[out]*/ IVsBuildableProjectCfg** ppIVsBuildableProjectCfg;
		HRESULT retValue;
	};

	STDMETHOD(get_BuildableProjectCfg)(
		/*[out]*/ IVsBuildableProjectCfg** ppIVsBuildableProjectCfg)
	{
		VSL_DEFINE_MOCK_METHOD(get_BuildableProjectCfg)

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsBuildableProjectCfg);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CanonicalNameValidValues
	{
		/*[out]*/ BSTR* pbstrCanonicalName;
		HRESULT retValue;
	};

	STDMETHOD(get_CanonicalName)(
		/*[out]*/ BSTR* pbstrCanonicalName)
	{
		VSL_DEFINE_MOCK_METHOD(get_CanonicalName)

		VSL_SET_VALIDVALUE_BSTR(pbstrCanonicalName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_PlatformValidValues
	{
		/*[out]*/ GUID* pguidPlatform;
		HRESULT retValue;
	};

	STDMETHOD(get_Platform)(
		/*[out]*/ GUID* pguidPlatform)
	{
		VSL_DEFINE_MOCK_METHOD(get_Platform)

		VSL_SET_VALIDVALUE(pguidPlatform);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IsPackagedValidValues
	{
		/*[out]*/ BOOL* pfIsPackaged;
		HRESULT retValue;
	};

	STDMETHOD(get_IsPackaged)(
		/*[out]*/ BOOL* pfIsPackaged)
	{
		VSL_DEFINE_MOCK_METHOD(get_IsPackaged)

		VSL_SET_VALIDVALUE(pfIsPackaged);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IsSpecifyingOutputSupportedValidValues
	{
		/*[out]*/ BOOL* pfIsSpecifyingOutputSupported;
		HRESULT retValue;
	};

	STDMETHOD(get_IsSpecifyingOutputSupported)(
		/*[out]*/ BOOL* pfIsSpecifyingOutputSupported)
	{
		VSL_DEFINE_MOCK_METHOD(get_IsSpecifyingOutputSupported)

		VSL_SET_VALIDVALUE(pfIsSpecifyingOutputSupported);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_TargetCodePageValidValues
	{
		/*[out]*/ UINT* puiTargetCodePage;
		HRESULT retValue;
	};

	STDMETHOD(get_TargetCodePage)(
		/*[out]*/ UINT* puiTargetCodePage)
	{
		VSL_DEFINE_MOCK_METHOD(get_TargetCodePage)

		VSL_SET_VALIDVALUE(puiTargetCodePage);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_UpdateSequenceNumberValidValues
	{
		/*[out]*/ ULARGE_INTEGER* puliUSN;
		HRESULT retValue;
	};

	STDMETHOD(get_UpdateSequenceNumber)(
		/*[out]*/ ULARGE_INTEGER* puliUSN)
	{
		VSL_DEFINE_MOCK_METHOD(get_UpdateSequenceNumber)

		VSL_SET_VALIDVALUE(puliUSN);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RootURLValidValues
	{
		/*[out]*/ BSTR* pbstrRootURL;
		HRESULT retValue;
	};

	STDMETHOD(get_RootURL)(
		/*[out]*/ BSTR* pbstrRootURL)
	{
		VSL_DEFINE_MOCK_METHOD(get_RootURL)

		VSL_SET_VALIDVALUE_BSTR(pbstrRootURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DisplayNameValidValues
	{
		/*[out]*/ BSTR* pbstrDisplayName;
		HRESULT retValue;
	};

	STDMETHOD(get_DisplayName)(
		/*[out]*/ BSTR* pbstrDisplayName)
	{
		VSL_DEFINE_MOCK_METHOD(get_DisplayName)

		VSL_SET_VALIDVALUE_BSTR(pbstrDisplayName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IsDebugOnlyValidValues
	{
		/*[out]*/ BOOL* pfIsDebugOnly;
		HRESULT retValue;
	};

	STDMETHOD(get_IsDebugOnly)(
		/*[out]*/ BOOL* pfIsDebugOnly)
	{
		VSL_DEFINE_MOCK_METHOD(get_IsDebugOnly)

		VSL_SET_VALIDVALUE(pfIsDebugOnly);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IsReleaseOnlyValidValues
	{
		/*[out]*/ BOOL* pfIsReleaseOnly;
		HRESULT retValue;
	};

	STDMETHOD(get_IsReleaseOnly)(
		/*[out]*/ BOOL* pfIsReleaseOnly)
	{
		VSL_DEFINE_MOCK_METHOD(get_IsReleaseOnly)

		VSL_SET_VALIDVALUE(pfIsReleaseOnly);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSDEBUGGABLEPROJECTCFG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsDebuggableProtocol.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSDEBUGGABLEPROTOCOL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSDEBUGGABLEPROTOCOL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsDebuggableProtocolNotImpl :
	public IVsDebuggableProtocol
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDebuggableProtocolNotImpl)

public:

	typedef IVsDebuggableProtocol Interface;

	STDMETHOD(AddDebuggableProtocol)(
		/*[in]*/ LPOLESTR /*bstrProtocol*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveDebuggableProtocol)(
		/*[in]*/ LPOLESTR /*bstrProtocol*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsProtocolDebuggable)(
		/*[in]*/ LPOLESTR /*bstrProtocol*/)VSL_STDMETHOD_NOTIMPL
};

class IVsDebuggableProtocolMockImpl :
	public IVsDebuggableProtocol,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDebuggableProtocolMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsDebuggableProtocolMockImpl)

	typedef IVsDebuggableProtocol Interface;
	struct AddDebuggableProtocolValidValues
	{
		/*[in]*/ LPOLESTR bstrProtocol;
		HRESULT retValue;
	};

	STDMETHOD(AddDebuggableProtocol)(
		/*[in]*/ LPOLESTR bstrProtocol)
	{
		VSL_DEFINE_MOCK_METHOD(AddDebuggableProtocol)

		VSL_CHECK_VALIDVALUE_STRINGW(bstrProtocol);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveDebuggableProtocolValidValues
	{
		/*[in]*/ LPOLESTR bstrProtocol;
		HRESULT retValue;
	};

	STDMETHOD(RemoveDebuggableProtocol)(
		/*[in]*/ LPOLESTR bstrProtocol)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveDebuggableProtocol)

		VSL_CHECK_VALIDVALUE_STRINGW(bstrProtocol);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsProtocolDebuggableValidValues
	{
		/*[in]*/ LPOLESTR bstrProtocol;
		HRESULT retValue;
	};

	STDMETHOD(IsProtocolDebuggable)(
		/*[in]*/ LPOLESTR bstrProtocol)
	{
		VSL_DEFINE_MOCK_METHOD(IsProtocolDebuggable)

		VSL_CHECK_VALIDVALUE_STRINGW(bstrProtocol);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSDEBUGGABLEPROTOCOL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsDebugLaunch.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSDEBUGLAUNCH_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSDEBUGLAUNCH_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsDebugLaunchNotImpl :
	public IVsDebugLaunch
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDebugLaunchNotImpl)

public:

	typedef IVsDebugLaunch Interface;

	STDMETHOD(DebugLaunch)(
		/*[in]*/ VSDBGLAUNCHFLAGS /*grfLaunch*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryDebugLaunch)(
		/*[in]*/ VSDBGLAUNCHFLAGS /*grfLaunch*/,
		/*[out]*/ BOOL* /*pfCanLaunch*/)VSL_STDMETHOD_NOTIMPL
};

class IVsDebugLaunchMockImpl :
	public IVsDebugLaunch,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDebugLaunchMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsDebugLaunchMockImpl)

	typedef IVsDebugLaunch Interface;
	struct DebugLaunchValidValues
	{
		/*[in]*/ VSDBGLAUNCHFLAGS grfLaunch;
		HRESULT retValue;
	};

	STDMETHOD(DebugLaunch)(
		/*[in]*/ VSDBGLAUNCHFLAGS grfLaunch)
	{
		VSL_DEFINE_MOCK_METHOD(DebugLaunch)

		VSL_CHECK_VALIDVALUE(grfLaunch);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryDebugLaunchValidValues
	{
		/*[in]*/ VSDBGLAUNCHFLAGS grfLaunch;
		/*[out]*/ BOOL* pfCanLaunch;
		HRESULT retValue;
	};

	STDMETHOD(QueryDebugLaunch)(
		/*[in]*/ VSDBGLAUNCHFLAGS grfLaunch,
		/*[out]*/ BOOL* pfCanLaunch)
	{
		VSL_DEFINE_MOCK_METHOD(QueryDebugLaunch)

		VSL_CHECK_VALIDVALUE(grfLaunch);

		VSL_SET_VALIDVALUE(pfCanLaunch);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSDEBUGLAUNCH_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsDebugger.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSDEBUGGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSDEBUGGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsDebuggerNotImpl :
	public IVsDebugger
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDebuggerNotImpl)

public:

	typedef IVsDebugger Interface;

	STDMETHOD(GetMode)(
		/*[out]*/ DBGMODE* /*pdbgmode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AdviseDebuggerEvents)(
		/*[in]*/ IVsDebuggerEvents* /*psink*/,
		/*[out]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseDebuggerEvents)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDataTipValue)(
		/*[in]*/ IVsTextLines* /*pTextBuf*/,
		/*[in]*/ const TextSpan* /*pTS*/,
		/*[in]*/ WCHAR* /*pszExpression*/,
		/*[out]*/ BSTR* /*pbstrValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryStatusForTextPos)(
		/*[in]*/ VsTextPos* /*pTextPos*/,
		/*[unique,in]*/ const GUID* /*pguidCmdGroup*/,
		/*[in]*/ ULONG /*cCmds*/,
		/*[out,in,size_is(cCmds)]*/ OLECMD[] /*prgCmds*/,
		/*[unique,out,in]*/ OLECMDTEXT* /*pCmdText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ExecCmdForTextPos)(
		/*[in]*/ VsTextPos* /*pTextPos*/,
		/*[unique,in]*/ const GUID* /*pguidCmdGroup*/,
		/*[in]*/ DWORD /*nCmdID*/,
		/*[in]*/ DWORD /*nCmdexecopt*/,
		/*[unique,in]*/ VARIANT* /*pvaIn*/,
		/*[unique,out,in]*/ VARIANT* /*pvaOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AdviseDebugEventCallback)(
		/*[in]*/ IUnknown* /*punkDebuggerEvents*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseDebugEventCallback)(
		/*[in]*/ IUnknown* /*punkDebuggerEvents*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LaunchDebugTargets)(
		/*[in]*/ ULONG /*cTargets*/,
		/*[in,out,size_is(cTargets)]*/ VsDebugTargetInfo* /*rgDebugTargetInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(InsertBreakpointByName)(
		/*[in]*/ REFGUID /*guidLanguage*/,
		/*[in]*/ LPCOLESTR /*pszCodeLocationText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveBreakpointsByName)(
		/*[in]*/ REFGUID /*guidLanguage*/,
		/*[in]*/ LPCOLESTR /*pszCodeLocationText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ToggleBreakpointByName)(
		/*[in]*/ REFGUID /*guidLanguage*/,
		/*[in]*/ LPCOLESTR /*pszCodeLocationText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsBreakpointOnName)(
		/*[in]*/ REFGUID /*guidLanguage*/,
		/*[in]*/ LPCOLESTR /*pszCodeLocationText*/,
		/*[out]*/ BOOL* /*pfIsBreakpoint*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ParseFileRedirection)(
		/*[in]*/ LPOLESTR /*pszArgs*/,
		/*[out]*/ BSTR* /*pbstrArgsProcessed*/,
		/*[out]*/ HANDLE* /*phStdInput*/,
		/*[out]*/ HANDLE* /*phStdOutput*/,
		/*[out]*/ HANDLE* /*phStdError*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetENCUpdate)(
		/*[out]*/ IUnknown** /*ppUpdate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AllowEditsWhileDebugging)(
		/*[in]*/ REFGUID /*guidLanguageService*/)VSL_STDMETHOD_NOTIMPL
};

class IVsDebuggerMockImpl :
	public IVsDebugger,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDebuggerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsDebuggerMockImpl)

	typedef IVsDebugger Interface;
	struct GetModeValidValues
	{
		/*[out]*/ DBGMODE* pdbgmode;
		HRESULT retValue;
	};

	STDMETHOD(GetMode)(
		/*[out]*/ DBGMODE* pdbgmode)
	{
		VSL_DEFINE_MOCK_METHOD(GetMode)

		VSL_SET_VALIDVALUE(pdbgmode);

		VSL_RETURN_VALIDVALUES();
	}
	struct AdviseDebuggerEventsValidValues
	{
		/*[in]*/ IVsDebuggerEvents* psink;
		/*[out]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(AdviseDebuggerEvents)(
		/*[in]*/ IVsDebuggerEvents* psink,
		/*[out]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(AdviseDebuggerEvents)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(psink);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseDebuggerEventsValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnadviseDebuggerEvents)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnadviseDebuggerEvents)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDataTipValueValidValues
	{
		/*[in]*/ IVsTextLines* pTextBuf;
		/*[in]*/ TextSpan* pTS;
		/*[in]*/ WCHAR* pszExpression;
		/*[out]*/ BSTR* pbstrValue;
		HRESULT retValue;
	};

	STDMETHOD(GetDataTipValue)(
		/*[in]*/ IVsTextLines* pTextBuf,
		/*[in]*/ const TextSpan* pTS,
		/*[in]*/ WCHAR* pszExpression,
		/*[out]*/ BSTR* pbstrValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetDataTipValue)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pTextBuf);

		VSL_CHECK_VALIDVALUE_POINTER(pTS);

		VSL_CHECK_VALIDVALUE_STRINGW(pszExpression);

		VSL_SET_VALIDVALUE_BSTR(pbstrValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryStatusForTextPosValidValues
	{
		/*[in]*/ VsTextPos* pTextPos;
		/*[unique,in]*/ GUID* pguidCmdGroup;
		/*[in]*/ ULONG cCmds;
		/*[out,in,size_is(cCmds)]*/ OLECMD* prgCmds;
		/*[unique,out,in]*/ OLECMDTEXT* pCmdText;
		HRESULT retValue;
	};

	STDMETHOD(QueryStatusForTextPos)(
		/*[in]*/ VsTextPos* pTextPos,
		/*[unique,in]*/ const GUID* pguidCmdGroup,
		/*[in]*/ ULONG cCmds,
		/*[out,in,size_is(cCmds)]*/ OLECMD prgCmds[],
		/*[unique,out,in]*/ OLECMDTEXT* pCmdText)
	{
		VSL_DEFINE_MOCK_METHOD(QueryStatusForTextPos)

		VSL_CHECK_VALIDVALUE_POINTER(pTextPos);

		VSL_CHECK_VALIDVALUE_POINTER(pguidCmdGroup);

		VSL_CHECK_VALIDVALUE(cCmds);

		VSL_SET_VALIDVALUE_MEMCPY(prgCmds, cCmds*sizeof(prgCmds[0]), validValues.cCmds*sizeof(validValues.prgCmds[0]));

		VSL_SET_VALIDVALUE(pCmdText);

		VSL_RETURN_VALIDVALUES();
	}
	struct ExecCmdForTextPosValidValues
	{
		/*[in]*/ VsTextPos* pTextPos;
		/*[unique,in]*/ GUID* pguidCmdGroup;
		/*[in]*/ DWORD nCmdID;
		/*[in]*/ DWORD nCmdexecopt;
		/*[unique,in]*/ VARIANT* pvaIn;
		/*[unique,out,in]*/ VARIANT* pvaOut;
		HRESULT retValue;
	};

	STDMETHOD(ExecCmdForTextPos)(
		/*[in]*/ VsTextPos* pTextPos,
		/*[unique,in]*/ const GUID* pguidCmdGroup,
		/*[in]*/ DWORD nCmdID,
		/*[in]*/ DWORD nCmdexecopt,
		/*[unique,in]*/ VARIANT* pvaIn,
		/*[unique,out,in]*/ VARIANT* pvaOut)
	{
		VSL_DEFINE_MOCK_METHOD(ExecCmdForTextPos)

		VSL_CHECK_VALIDVALUE_POINTER(pTextPos);

		VSL_CHECK_VALIDVALUE_POINTER(pguidCmdGroup);

		VSL_CHECK_VALIDVALUE(nCmdID);

		VSL_CHECK_VALIDVALUE(nCmdexecopt);

		VSL_CHECK_VALIDVALUE_POINTER(pvaIn);

		VSL_SET_VALIDVALUE_VARIANT(pvaOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct AdviseDebugEventCallbackValidValues
	{
		/*[in]*/ IUnknown* punkDebuggerEvents;
		HRESULT retValue;
	};

	STDMETHOD(AdviseDebugEventCallback)(
		/*[in]*/ IUnknown* punkDebuggerEvents)
	{
		VSL_DEFINE_MOCK_METHOD(AdviseDebugEventCallback)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkDebuggerEvents);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseDebugEventCallbackValidValues
	{
		/*[in]*/ IUnknown* punkDebuggerEvents;
		HRESULT retValue;
	};

	STDMETHOD(UnadviseDebugEventCallback)(
		/*[in]*/ IUnknown* punkDebuggerEvents)
	{
		VSL_DEFINE_MOCK_METHOD(UnadviseDebugEventCallback)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkDebuggerEvents);

		VSL_RETURN_VALIDVALUES();
	}
	struct LaunchDebugTargetsValidValues
	{
		/*[in]*/ ULONG cTargets;
		/*[in,out,size_is(cTargets)]*/ VsDebugTargetInfo* rgDebugTargetInfo;
		HRESULT retValue;
	};

	STDMETHOD(LaunchDebugTargets)(
		/*[in]*/ ULONG cTargets,
		/*[in,out,size_is(cTargets)]*/ VsDebugTargetInfo* rgDebugTargetInfo)
	{
		VSL_DEFINE_MOCK_METHOD(LaunchDebugTargets)

		VSL_CHECK_VALIDVALUE(cTargets);

		VSL_SET_VALIDVALUE_MEMCPY(rgDebugTargetInfo, cTargets*sizeof(rgDebugTargetInfo[0]), validValues.cTargets*sizeof(validValues.rgDebugTargetInfo[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InsertBreakpointByNameValidValues
	{
		/*[in]*/ REFGUID guidLanguage;
		/*[in]*/ LPCOLESTR pszCodeLocationText;
		HRESULT retValue;
	};

	STDMETHOD(InsertBreakpointByName)(
		/*[in]*/ REFGUID guidLanguage,
		/*[in]*/ LPCOLESTR pszCodeLocationText)
	{
		VSL_DEFINE_MOCK_METHOD(InsertBreakpointByName)

		VSL_CHECK_VALIDVALUE(guidLanguage);

		VSL_CHECK_VALIDVALUE_STRINGW(pszCodeLocationText);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveBreakpointsByNameValidValues
	{
		/*[in]*/ REFGUID guidLanguage;
		/*[in]*/ LPCOLESTR pszCodeLocationText;
		HRESULT retValue;
	};

	STDMETHOD(RemoveBreakpointsByName)(
		/*[in]*/ REFGUID guidLanguage,
		/*[in]*/ LPCOLESTR pszCodeLocationText)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveBreakpointsByName)

		VSL_CHECK_VALIDVALUE(guidLanguage);

		VSL_CHECK_VALIDVALUE_STRINGW(pszCodeLocationText);

		VSL_RETURN_VALIDVALUES();
	}
	struct ToggleBreakpointByNameValidValues
	{
		/*[in]*/ REFGUID guidLanguage;
		/*[in]*/ LPCOLESTR pszCodeLocationText;
		HRESULT retValue;
	};

	STDMETHOD(ToggleBreakpointByName)(
		/*[in]*/ REFGUID guidLanguage,
		/*[in]*/ LPCOLESTR pszCodeLocationText)
	{
		VSL_DEFINE_MOCK_METHOD(ToggleBreakpointByName)

		VSL_CHECK_VALIDVALUE(guidLanguage);

		VSL_CHECK_VALIDVALUE_STRINGW(pszCodeLocationText);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsBreakpointOnNameValidValues
	{
		/*[in]*/ REFGUID guidLanguage;
		/*[in]*/ LPCOLESTR pszCodeLocationText;
		/*[out]*/ BOOL* pfIsBreakpoint;
		HRESULT retValue;
	};

	STDMETHOD(IsBreakpointOnName)(
		/*[in]*/ REFGUID guidLanguage,
		/*[in]*/ LPCOLESTR pszCodeLocationText,
		/*[out]*/ BOOL* pfIsBreakpoint)
	{
		VSL_DEFINE_MOCK_METHOD(IsBreakpointOnName)

		VSL_CHECK_VALIDVALUE(guidLanguage);

		VSL_CHECK_VALIDVALUE_STRINGW(pszCodeLocationText);

		VSL_SET_VALIDVALUE(pfIsBreakpoint);

		VSL_RETURN_VALIDVALUES();
	}
	struct ParseFileRedirectionValidValues
	{
		/*[in]*/ LPOLESTR pszArgs;
		/*[out]*/ BSTR* pbstrArgsProcessed;
		/*[out]*/ HANDLE* phStdInput;
		/*[out]*/ HANDLE* phStdOutput;
		/*[out]*/ HANDLE* phStdError;
		HRESULT retValue;
	};

	STDMETHOD(ParseFileRedirection)(
		/*[in]*/ LPOLESTR pszArgs,
		/*[out]*/ BSTR* pbstrArgsProcessed,
		/*[out]*/ HANDLE* phStdInput,
		/*[out]*/ HANDLE* phStdOutput,
		/*[out]*/ HANDLE* phStdError)
	{
		VSL_DEFINE_MOCK_METHOD(ParseFileRedirection)

		VSL_CHECK_VALIDVALUE_STRINGW(pszArgs);

		VSL_SET_VALIDVALUE_BSTR(pbstrArgsProcessed);

		VSL_SET_VALIDVALUE(phStdInput);

		VSL_SET_VALIDVALUE(phStdOutput);

		VSL_SET_VALIDVALUE(phStdError);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetENCUpdateValidValues
	{
		/*[out]*/ IUnknown** ppUpdate;
		HRESULT retValue;
	};

	STDMETHOD(GetENCUpdate)(
		/*[out]*/ IUnknown** ppUpdate)
	{
		VSL_DEFINE_MOCK_METHOD(GetENCUpdate)

		VSL_SET_VALIDVALUE_INTERFACE(ppUpdate);

		VSL_RETURN_VALIDVALUES();
	}
	struct AllowEditsWhileDebuggingValidValues
	{
		/*[in]*/ REFGUID guidLanguageService;
		HRESULT retValue;
	};

	STDMETHOD(AllowEditsWhileDebugging)(
		/*[in]*/ REFGUID guidLanguageService)
	{
		VSL_DEFINE_MOCK_METHOD(AllowEditsWhileDebugging)

		VSL_CHECK_VALIDVALUE(guidLanguageService);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSDEBUGGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsDebuggerEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSDEBUGGEREVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSDEBUGGEREVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsDebuggerEventsNotImpl :
	public IVsDebuggerEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDebuggerEventsNotImpl)

public:

	typedef IVsDebuggerEvents Interface;

	STDMETHOD(OnModeChange)(
		/*[in]*/ DBGMODE /*dbgmodeNew*/)VSL_STDMETHOD_NOTIMPL
};

class IVsDebuggerEventsMockImpl :
	public IVsDebuggerEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDebuggerEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsDebuggerEventsMockImpl)

	typedef IVsDebuggerEvents Interface;
	struct OnModeChangeValidValues
	{
		/*[in]*/ DBGMODE dbgmodeNew;
		HRESULT retValue;
	};

	STDMETHOD(OnModeChange)(
		/*[in]*/ DBGMODE dbgmodeNew)
	{
		VSL_DEFINE_MOCK_METHOD(OnModeChange)

		VSL_CHECK_VALIDVALUE(dbgmodeNew);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSDEBUGGEREVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsDebugger2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSDEBUGGER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSDEBUGGER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsDebugger2NotImpl :
	public IVsDebugger2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDebugger2NotImpl)

public:

	typedef IVsDebugger2 Interface;

	STDMETHOD(LaunchDebugTargets2)(
		/*[in]*/ ULONG /*DebugTargetCount*/,
		/*[in,out,size_is(DebugTargetCount)]*/ VsDebugTargetInfo2* /*pDebugTargets*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ConfirmStopDebugging)(
		/*[in]*/ LPCOLESTR /*pszMessage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumDebugEngines)(
		/*[out]*/ IVsEnumGUID** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEngineName)(
		/*[in]*/ REFGUID /*guidEngine*/,
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsEngineCompatible)(
		/*[in]*/ REFGUID /*guidEngine*/,
		/*[in]*/ ULONG /*EngineCount*/,
		/*[in,size_is(EngineCount)]*/ GUID* /*pEngineGUIDs*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetConsoleHandlesForProcess)(
		/*[in]*/ DWORD /*dwPid*/,
		/*[out]*/ ULONG64* /*pdwStdInput*/,
		/*[out]*/ ULONG64* /*pdwStdOutput*/,
		/*[out]*/ ULONG64* /*pdwStdError*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ShowSource)(
		/*[in]*/ IUnknown* /*pUnkDebugDocContext*/,
		/*[in]*/ BOOL /*fMakeActive*/,
		/*[in]*/ BOOL /*fAlwaysMoveCaret*/,
		/*[in]*/ BOOL /*fPromptToFindSource*/,
		/*[in]*/ BOOL /*fIgnoreIfNotFound*/,
		/*[out]*/ IVsTextView** /*ppTextView*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateDataTip)(
		/*[in]*/ BSTR /*bstrExpression*/,
		/*[in]*/ VSEDT_STYLE /*dwStyle*/,
		/*[out]*/ IVsEnhancedDataTip** /*ppDataTip*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSymbolPath)(
		/*[out]*/ BSTR* /*pbstrSymbolPath*/,
		/*[out]*/ BSTR* /*pbstrSymbolCachePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetOutputHandleForProcess)(
		/*[in]*/ DWORD /*dwPid*/,
		/*[out]*/ ULONG64* /*pOutputHandle*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(InsertBreakpointByName)(
		/*[in]*/ REFGUID /*guidLanguage*/,
		/*[in]*/ LPCOLESTR /*pszCodeLocationText*/,
		/*[in]*/ BOOL /*bUseIntellisense*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ToggleUseQuickConsoleOption)(
		/*[in]*/ BOOL /*fOnOff*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetUseQuickConsoleOptionSetting)(
		/*[out]*/ BOOL* /*pfValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetInternalDebugMode)(
		/*[out]*/ DBGMODE* /*pdbgmode*/)VSL_STDMETHOD_NOTIMPL
};

class IVsDebugger2MockImpl :
	public IVsDebugger2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDebugger2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsDebugger2MockImpl)

	typedef IVsDebugger2 Interface;
	struct LaunchDebugTargets2ValidValues
	{
		/*[in]*/ ULONG DebugTargetCount;
		/*[in,out,size_is(DebugTargetCount)]*/ VsDebugTargetInfo2* pDebugTargets;
		HRESULT retValue;
	};

	STDMETHOD(LaunchDebugTargets2)(
		/*[in]*/ ULONG DebugTargetCount,
		/*[in,out,size_is(DebugTargetCount)]*/ VsDebugTargetInfo2* pDebugTargets)
	{
		VSL_DEFINE_MOCK_METHOD(LaunchDebugTargets2)

		VSL_CHECK_VALIDVALUE(DebugTargetCount);

		VSL_SET_VALIDVALUE_MEMCPY(pDebugTargets, DebugTargetCount*sizeof(pDebugTargets[0]), validValues.DebugTargetCount*sizeof(validValues.pDebugTargets[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct ConfirmStopDebuggingValidValues
	{
		/*[in]*/ LPCOLESTR pszMessage;
		HRESULT retValue;
	};

	STDMETHOD(ConfirmStopDebugging)(
		/*[in]*/ LPCOLESTR pszMessage)
	{
		VSL_DEFINE_MOCK_METHOD(ConfirmStopDebugging)

		VSL_CHECK_VALIDVALUE_STRINGW(pszMessage);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumDebugEnginesValidValues
	{
		/*[out]*/ IVsEnumGUID** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumDebugEngines)(
		/*[out]*/ IVsEnumGUID** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumDebugEngines)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEngineNameValidValues
	{
		/*[in]*/ REFGUID guidEngine;
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetEngineName)(
		/*[in]*/ REFGUID guidEngine,
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetEngineName)

		VSL_CHECK_VALIDVALUE(guidEngine);

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsEngineCompatibleValidValues
	{
		/*[in]*/ REFGUID guidEngine;
		/*[in]*/ ULONG EngineCount;
		/*[in,size_is(EngineCount)]*/ GUID* pEngineGUIDs;
		HRESULT retValue;
	};

	STDMETHOD(IsEngineCompatible)(
		/*[in]*/ REFGUID guidEngine,
		/*[in]*/ ULONG EngineCount,
		/*[in,size_is(EngineCount)]*/ GUID* pEngineGUIDs)
	{
		VSL_DEFINE_MOCK_METHOD(IsEngineCompatible)

		VSL_CHECK_VALIDVALUE(guidEngine);

		VSL_CHECK_VALIDVALUE(EngineCount);

		VSL_CHECK_VALIDVALUE_MEMCMP(pEngineGUIDs, EngineCount*sizeof(pEngineGUIDs[0]), validValues.EngineCount*sizeof(validValues.pEngineGUIDs[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct GetConsoleHandlesForProcessValidValues
	{
		/*[in]*/ DWORD dwPid;
		/*[out]*/ ULONG64* pdwStdInput;
		/*[out]*/ ULONG64* pdwStdOutput;
		/*[out]*/ ULONG64* pdwStdError;
		HRESULT retValue;
	};

	STDMETHOD(GetConsoleHandlesForProcess)(
		/*[in]*/ DWORD dwPid,
		/*[out]*/ ULONG64* pdwStdInput,
		/*[out]*/ ULONG64* pdwStdOutput,
		/*[out]*/ ULONG64* pdwStdError)
	{
		VSL_DEFINE_MOCK_METHOD(GetConsoleHandlesForProcess)

		VSL_CHECK_VALIDVALUE(dwPid);

		VSL_SET_VALIDVALUE(pdwStdInput);

		VSL_SET_VALIDVALUE(pdwStdOutput);

		VSL_SET_VALIDVALUE(pdwStdError);

		VSL_RETURN_VALIDVALUES();
	}
	struct ShowSourceValidValues
	{
		/*[in]*/ IUnknown* pUnkDebugDocContext;
		/*[in]*/ BOOL fMakeActive;
		/*[in]*/ BOOL fAlwaysMoveCaret;
		/*[in]*/ BOOL fPromptToFindSource;
		/*[in]*/ BOOL fIgnoreIfNotFound;
		/*[out]*/ IVsTextView** ppTextView;
		HRESULT retValue;
	};

	STDMETHOD(ShowSource)(
		/*[in]*/ IUnknown* pUnkDebugDocContext,
		/*[in]*/ BOOL fMakeActive,
		/*[in]*/ BOOL fAlwaysMoveCaret,
		/*[in]*/ BOOL fPromptToFindSource,
		/*[in]*/ BOOL fIgnoreIfNotFound,
		/*[out]*/ IVsTextView** ppTextView)
	{
		VSL_DEFINE_MOCK_METHOD(ShowSource)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnkDebugDocContext);

		VSL_CHECK_VALIDVALUE(fMakeActive);

		VSL_CHECK_VALIDVALUE(fAlwaysMoveCaret);

		VSL_CHECK_VALIDVALUE(fPromptToFindSource);

		VSL_CHECK_VALIDVALUE(fIgnoreIfNotFound);

		VSL_SET_VALIDVALUE_INTERFACE(ppTextView);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateDataTipValidValues
	{
		/*[in]*/ BSTR bstrExpression;
		/*[in]*/ VSEDT_STYLE dwStyle;
		/*[out]*/ IVsEnhancedDataTip** ppDataTip;
		HRESULT retValue;
	};

	STDMETHOD(CreateDataTip)(
		/*[in]*/ BSTR bstrExpression,
		/*[in]*/ VSEDT_STYLE dwStyle,
		/*[out]*/ IVsEnhancedDataTip** ppDataTip)
	{
		VSL_DEFINE_MOCK_METHOD(CreateDataTip)

		VSL_CHECK_VALIDVALUE_BSTR(bstrExpression);

		VSL_CHECK_VALIDVALUE(dwStyle);

		VSL_SET_VALIDVALUE_INTERFACE(ppDataTip);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSymbolPathValidValues
	{
		/*[out]*/ BSTR* pbstrSymbolPath;
		/*[out]*/ BSTR* pbstrSymbolCachePath;
		HRESULT retValue;
	};

	STDMETHOD(GetSymbolPath)(
		/*[out]*/ BSTR* pbstrSymbolPath,
		/*[out]*/ BSTR* pbstrSymbolCachePath)
	{
		VSL_DEFINE_MOCK_METHOD(GetSymbolPath)

		VSL_SET_VALIDVALUE_BSTR(pbstrSymbolPath);

		VSL_SET_VALIDVALUE_BSTR(pbstrSymbolCachePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetOutputHandleForProcessValidValues
	{
		/*[in]*/ DWORD dwPid;
		/*[out]*/ ULONG64* pOutputHandle;
		HRESULT retValue;
	};

	STDMETHOD(GetOutputHandleForProcess)(
		/*[in]*/ DWORD dwPid,
		/*[out]*/ ULONG64* pOutputHandle)
	{
		VSL_DEFINE_MOCK_METHOD(GetOutputHandleForProcess)

		VSL_CHECK_VALIDVALUE(dwPid);

		VSL_SET_VALIDVALUE(pOutputHandle);

		VSL_RETURN_VALIDVALUES();
	}
	struct InsertBreakpointByNameValidValues
	{
		/*[in]*/ REFGUID guidLanguage;
		/*[in]*/ LPCOLESTR pszCodeLocationText;
		/*[in]*/ BOOL bUseIntellisense;
		HRESULT retValue;
	};

	STDMETHOD(InsertBreakpointByName)(
		/*[in]*/ REFGUID guidLanguage,
		/*[in]*/ LPCOLESTR pszCodeLocationText,
		/*[in]*/ BOOL bUseIntellisense)
	{
		VSL_DEFINE_MOCK_METHOD(InsertBreakpointByName)

		VSL_CHECK_VALIDVALUE(guidLanguage);

		VSL_CHECK_VALIDVALUE_STRINGW(pszCodeLocationText);

		VSL_CHECK_VALIDVALUE(bUseIntellisense);

		VSL_RETURN_VALIDVALUES();
	}
	struct ToggleUseQuickConsoleOptionValidValues
	{
		/*[in]*/ BOOL fOnOff;
		HRESULT retValue;
	};

	STDMETHOD(ToggleUseQuickConsoleOption)(
		/*[in]*/ BOOL fOnOff)
	{
		VSL_DEFINE_MOCK_METHOD(ToggleUseQuickConsoleOption)

		VSL_CHECK_VALIDVALUE(fOnOff);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetUseQuickConsoleOptionSettingValidValues
	{
		/*[out]*/ BOOL* pfValue;
		HRESULT retValue;
	};

	STDMETHOD(GetUseQuickConsoleOptionSetting)(
		/*[out]*/ BOOL* pfValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetUseQuickConsoleOptionSetting)

		VSL_SET_VALIDVALUE(pfValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetInternalDebugModeValidValues
	{
		/*[out]*/ DBGMODE* pdbgmode;
		HRESULT retValue;
	};

	STDMETHOD(GetInternalDebugMode)(
		/*[out]*/ DBGMODE* pdbgmode)
	{
		VSL_DEFINE_MOCK_METHOD(GetInternalDebugMode)

		VSL_SET_VALIDVALUE(pdbgmode);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSDEBUGGER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsDebugName.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSDEBUGNAME_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSDEBUGNAME_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsDebugNameNotImpl :
	public IVsDebugName
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDebugNameNotImpl)

public:

	typedef IVsDebugName Interface;

	STDMETHOD(GetName)(
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLocation)(
		/*[out]*/ BSTR* /*pbstrMkDoc*/,
		/*[out]*/ TextSpan* /*pspanLocation*/)VSL_STDMETHOD_NOTIMPL
};

class IVsDebugNameMockImpl :
	public IVsDebugName,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDebugNameMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsDebugNameMockImpl)

	typedef IVsDebugName Interface;
	struct GetNameValidValues
	{
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetName)(
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLocationValidValues
	{
		/*[out]*/ BSTR* pbstrMkDoc;
		/*[out]*/ TextSpan* pspanLocation;
		HRESULT retValue;
	};

	STDMETHOD(GetLocation)(
		/*[out]*/ BSTR* pbstrMkDoc,
		/*[out]*/ TextSpan* pspanLocation)
	{
		VSL_DEFINE_MOCK_METHOD(GetLocation)

		VSL_SET_VALIDVALUE_BSTR(pbstrMkDoc);

		VSL_SET_VALIDVALUE(pspanLocation);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSDEBUGNAME_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsDebuggableProjectCfg2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSDEBUGGABLEPROJECTCFG2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSDEBUGGABLEPROJECTCFG2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsDebuggableProjectCfg2NotImpl :
	public IVsDebuggableProjectCfg2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDebuggableProjectCfg2NotImpl)

public:

	typedef IVsDebuggableProjectCfg2 Interface;

	STDMETHOD(OnBeforeDebugLaunch)(
		/*[in]*/ VSDBGLAUNCHFLAGS /*grfLaunch*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DebugLaunch)(
		/*[in]*/ VSDBGLAUNCHFLAGS /*grfLaunch*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryDebugLaunch)(
		/*[in]*/ VSDBGLAUNCHFLAGS /*grfLaunch*/,
		/*[out]*/ BOOL* /*pfCanLaunch*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumOutputs)(
		/*[out]*/ IVsEnumOutputs** /*ppIVsEnumOutputs*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OpenOutput)(
		/*[in]*/ LPCOLESTR /*szOutputCanonicalName*/,
		/*[out]*/ IVsOutput** /*ppIVsOutput*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ProjectCfgProvider)(
		/*[out]*/ IVsProjectCfgProvider** /*ppIVsProjectCfgProvider*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_BuildableProjectCfg)(
		/*[out]*/ IVsBuildableProjectCfg** /*ppIVsBuildableProjectCfg*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CanonicalName)(
		/*[out]*/ BSTR* /*pbstrCanonicalName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Platform)(
		/*[out]*/ GUID* /*pguidPlatform*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IsPackaged)(
		/*[out]*/ BOOL* /*pfIsPackaged*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IsSpecifyingOutputSupported)(
		/*[out]*/ BOOL* /*pfIsSpecifyingOutputSupported*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_TargetCodePage)(
		/*[out]*/ UINT* /*puiTargetCodePage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_UpdateSequenceNumber)(
		/*[out]*/ ULARGE_INTEGER* /*puliUSN*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RootURL)(
		/*[out]*/ BSTR* /*pbstrRootURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DisplayName)(
		/*[out]*/ BSTR* /*pbstrDisplayName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IsDebugOnly)(
		/*[out]*/ BOOL* /*pfIsDebugOnly*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IsReleaseOnly)(
		/*[out]*/ BOOL* /*pfIsReleaseOnly*/)VSL_STDMETHOD_NOTIMPL
};

class IVsDebuggableProjectCfg2MockImpl :
	public IVsDebuggableProjectCfg2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDebuggableProjectCfg2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsDebuggableProjectCfg2MockImpl)

	typedef IVsDebuggableProjectCfg2 Interface;
	struct OnBeforeDebugLaunchValidValues
	{
		/*[in]*/ VSDBGLAUNCHFLAGS grfLaunch;
		HRESULT retValue;
	};

	STDMETHOD(OnBeforeDebugLaunch)(
		/*[in]*/ VSDBGLAUNCHFLAGS grfLaunch)
	{
		VSL_DEFINE_MOCK_METHOD(OnBeforeDebugLaunch)

		VSL_CHECK_VALIDVALUE(grfLaunch);

		VSL_RETURN_VALIDVALUES();
	}
	struct DebugLaunchValidValues
	{
		/*[in]*/ VSDBGLAUNCHFLAGS grfLaunch;
		HRESULT retValue;
	};

	STDMETHOD(DebugLaunch)(
		/*[in]*/ VSDBGLAUNCHFLAGS grfLaunch)
	{
		VSL_DEFINE_MOCK_METHOD(DebugLaunch)

		VSL_CHECK_VALIDVALUE(grfLaunch);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryDebugLaunchValidValues
	{
		/*[in]*/ VSDBGLAUNCHFLAGS grfLaunch;
		/*[out]*/ BOOL* pfCanLaunch;
		HRESULT retValue;
	};

	STDMETHOD(QueryDebugLaunch)(
		/*[in]*/ VSDBGLAUNCHFLAGS grfLaunch,
		/*[out]*/ BOOL* pfCanLaunch)
	{
		VSL_DEFINE_MOCK_METHOD(QueryDebugLaunch)

		VSL_CHECK_VALIDVALUE(grfLaunch);

		VSL_SET_VALIDVALUE(pfCanLaunch);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumOutputsValidValues
	{
		/*[out]*/ IVsEnumOutputs** ppIVsEnumOutputs;
		HRESULT retValue;
	};

	STDMETHOD(EnumOutputs)(
		/*[out]*/ IVsEnumOutputs** ppIVsEnumOutputs)
	{
		VSL_DEFINE_MOCK_METHOD(EnumOutputs)

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsEnumOutputs);

		VSL_RETURN_VALIDVALUES();
	}
	struct OpenOutputValidValues
	{
		/*[in]*/ LPCOLESTR szOutputCanonicalName;
		/*[out]*/ IVsOutput** ppIVsOutput;
		HRESULT retValue;
	};

	STDMETHOD(OpenOutput)(
		/*[in]*/ LPCOLESTR szOutputCanonicalName,
		/*[out]*/ IVsOutput** ppIVsOutput)
	{
		VSL_DEFINE_MOCK_METHOD(OpenOutput)

		VSL_CHECK_VALIDVALUE_STRINGW(szOutputCanonicalName);

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsOutput);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ProjectCfgProviderValidValues
	{
		/*[out]*/ IVsProjectCfgProvider** ppIVsProjectCfgProvider;
		HRESULT retValue;
	};

	STDMETHOD(get_ProjectCfgProvider)(
		/*[out]*/ IVsProjectCfgProvider** ppIVsProjectCfgProvider)
	{
		VSL_DEFINE_MOCK_METHOD(get_ProjectCfgProvider)

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsProjectCfgProvider);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_BuildableProjectCfgValidValues
	{
		/*[out]*/ IVsBuildableProjectCfg** ppIVsBuildableProjectCfg;
		HRESULT retValue;
	};

	STDMETHOD(get_BuildableProjectCfg)(
		/*[out]*/ IVsBuildableProjectCfg** ppIVsBuildableProjectCfg)
	{
		VSL_DEFINE_MOCK_METHOD(get_BuildableProjectCfg)

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsBuildableProjectCfg);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CanonicalNameValidValues
	{
		/*[out]*/ BSTR* pbstrCanonicalName;
		HRESULT retValue;
	};

	STDMETHOD(get_CanonicalName)(
		/*[out]*/ BSTR* pbstrCanonicalName)
	{
		VSL_DEFINE_MOCK_METHOD(get_CanonicalName)

		VSL_SET_VALIDVALUE_BSTR(pbstrCanonicalName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_PlatformValidValues
	{
		/*[out]*/ GUID* pguidPlatform;
		HRESULT retValue;
	};

	STDMETHOD(get_Platform)(
		/*[out]*/ GUID* pguidPlatform)
	{
		VSL_DEFINE_MOCK_METHOD(get_Platform)

		VSL_SET_VALIDVALUE(pguidPlatform);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IsPackagedValidValues
	{
		/*[out]*/ BOOL* pfIsPackaged;
		HRESULT retValue;
	};

	STDMETHOD(get_IsPackaged)(
		/*[out]*/ BOOL* pfIsPackaged)
	{
		VSL_DEFINE_MOCK_METHOD(get_IsPackaged)

		VSL_SET_VALIDVALUE(pfIsPackaged);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IsSpecifyingOutputSupportedValidValues
	{
		/*[out]*/ BOOL* pfIsSpecifyingOutputSupported;
		HRESULT retValue;
	};

	STDMETHOD(get_IsSpecifyingOutputSupported)(
		/*[out]*/ BOOL* pfIsSpecifyingOutputSupported)
	{
		VSL_DEFINE_MOCK_METHOD(get_IsSpecifyingOutputSupported)

		VSL_SET_VALIDVALUE(pfIsSpecifyingOutputSupported);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_TargetCodePageValidValues
	{
		/*[out]*/ UINT* puiTargetCodePage;
		HRESULT retValue;
	};

	STDMETHOD(get_TargetCodePage)(
		/*[out]*/ UINT* puiTargetCodePage)
	{
		VSL_DEFINE_MOCK_METHOD(get_TargetCodePage)

		VSL_SET_VALIDVALUE(puiTargetCodePage);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_UpdateSequenceNumberValidValues
	{
		/*[out]*/ ULARGE_INTEGER* puliUSN;
		HRESULT retValue;
	};

	STDMETHOD(get_UpdateSequenceNumber)(
		/*[out]*/ ULARGE_INTEGER* puliUSN)
	{
		VSL_DEFINE_MOCK_METHOD(get_UpdateSequenceNumber)

		VSL_SET_VALIDVALUE(puliUSN);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RootURLValidValues
	{
		/*[out]*/ BSTR* pbstrRootURL;
		HRESULT retValue;
	};

	STDMETHOD(get_RootURL)(
		/*[out]*/ BSTR* pbstrRootURL)
	{
		VSL_DEFINE_MOCK_METHOD(get_RootURL)

		VSL_SET_VALIDVALUE_BSTR(pbstrRootURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DisplayNameValidValues
	{
		/*[out]*/ BSTR* pbstrDisplayName;
		HRESULT retValue;
	};

	STDMETHOD(get_DisplayName)(
		/*[out]*/ BSTR* pbstrDisplayName)
	{
		VSL_DEFINE_MOCK_METHOD(get_DisplayName)

		VSL_SET_VALIDVALUE_BSTR(pbstrDisplayName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IsDebugOnlyValidValues
	{
		/*[out]*/ BOOL* pfIsDebugOnly;
		HRESULT retValue;
	};

	STDMETHOD(get_IsDebugOnly)(
		/*[out]*/ BOOL* pfIsDebugOnly)
	{
		VSL_DEFINE_MOCK_METHOD(get_IsDebugOnly)

		VSL_SET_VALIDVALUE(pfIsDebugOnly);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IsReleaseOnlyValidValues
	{
		/*[out]*/ BOOL* pfIsReleaseOnly;
		HRESULT retValue;
	};

	STDMETHOD(get_IsReleaseOnly)(
		/*[out]*/ BOOL* pfIsReleaseOnly)
	{
		VSL_DEFINE_MOCK_METHOD(get_IsReleaseOnly)

		VSL_SET_VALIDVALUE(pfIsReleaseOnly);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSDEBUGGABLEPROJECTCFG2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsDefaultToolboxTabState.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSDEFAULTTOOLBOXTABSTATE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSDEFAULTTOOLBOXTABSTATE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsDefaultToolboxTabStateNotImpl :
	public IVsDefaultToolboxTabState
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDefaultToolboxTabStateNotImpl)

public:

	typedef IVsDefaultToolboxTabState Interface;

	STDMETHOD(GetDefaultTabExpansion)(
		/*[in]*/ LPCOLESTR /*pszTabID*/,
		/*[out]*/ BOOL* /*pfExpanded*/)VSL_STDMETHOD_NOTIMPL
};

class IVsDefaultToolboxTabStateMockImpl :
	public IVsDefaultToolboxTabState,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDefaultToolboxTabStateMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsDefaultToolboxTabStateMockImpl)

	typedef IVsDefaultToolboxTabState Interface;
	struct GetDefaultTabExpansionValidValues
	{
		/*[in]*/ LPCOLESTR pszTabID;
		/*[out]*/ BOOL* pfExpanded;
		HRESULT retValue;
	};

	STDMETHOD(GetDefaultTabExpansion)(
		/*[in]*/ LPCOLESTR pszTabID,
		/*[out]*/ BOOL* pfExpanded)
	{
		VSL_DEFINE_MOCK_METHOD(GetDefaultTabExpansion)

		VSL_CHECK_VALIDVALUE_STRINGW(pszTabID);

		VSL_SET_VALIDVALUE(pfExpanded);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSDEFAULTTOOLBOXTABSTATE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsDeferredSaveProject.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSDEFERREDSAVEPROJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSDEFERREDSAVEPROJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsDeferredSaveProjectNotImpl :
	public IVsDeferredSaveProject
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDeferredSaveProjectNotImpl)

public:

	typedef IVsDeferredSaveProject Interface;

	STDMETHOD(SaveProjectToLocation)(
		/*[in]*/ LPCOLESTR /*pszProjectFilename*/)VSL_STDMETHOD_NOTIMPL
};

class IVsDeferredSaveProjectMockImpl :
	public IVsDeferredSaveProject,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDeferredSaveProjectMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsDeferredSaveProjectMockImpl)

	typedef IVsDeferredSaveProject Interface;
	struct SaveProjectToLocationValidValues
	{
		/*[in]*/ LPCOLESTR pszProjectFilename;
		HRESULT retValue;
	};

	STDMETHOD(SaveProjectToLocation)(
		/*[in]*/ LPCOLESTR pszProjectFilename)
	{
		VSL_DEFINE_MOCK_METHOD(SaveProjectToLocation)

		VSL_CHECK_VALIDVALUE_STRINGW(pszProjectFilename);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSDEFERREDSAVEPROJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsDeferredDocView.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSDEFERREDDOCVIEW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSDEFERREDDOCVIEW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsDeferredDocViewNotImpl :
	public IVsDeferredDocView
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDeferredDocViewNotImpl)

public:

	typedef IVsDeferredDocView Interface;

	STDMETHOD(get_DocView)(
		/*[out]*/ IUnknown** /*ppUnkDocView*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CmdUIGuid)(
		/*[out]*/ GUID* /*pGuidCmdId*/)VSL_STDMETHOD_NOTIMPL
};

class IVsDeferredDocViewMockImpl :
	public IVsDeferredDocView,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDeferredDocViewMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsDeferredDocViewMockImpl)

	typedef IVsDeferredDocView Interface;
	struct get_DocViewValidValues
	{
		/*[out]*/ IUnknown** ppUnkDocView;
		HRESULT retValue;
	};

	STDMETHOD(get_DocView)(
		/*[out]*/ IUnknown** ppUnkDocView)
	{
		VSL_DEFINE_MOCK_METHOD(get_DocView)

		VSL_SET_VALIDVALUE_INTERFACE(ppUnkDocView);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CmdUIGuidValidValues
	{
		/*[out]*/ GUID* pGuidCmdId;
		HRESULT retValue;
	};

	STDMETHOD(get_CmdUIGuid)(
		/*[out]*/ GUID* pGuidCmdId)
	{
		VSL_DEFINE_MOCK_METHOD(get_CmdUIGuid)

		VSL_SET_VALIDVALUE(pGuidCmdId);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSDEFERREDDOCVIEW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsDebugProcessNotify.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSDEBUGPROCESSNOTIFY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSDEBUGPROCESSNOTIFY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsDebugProcessNotifyNotImpl :
	public IVsDebugProcessNotify
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDebugProcessNotifyNotImpl)

public:

	typedef IVsDebugProcessNotify Interface;

	STDMETHOD(BeforeStopDebuggingProcess)(
		/*[in]*/ STOP_DEBUGGING_PROCESS_REASON /*Reason*/)VSL_STDMETHOD_NOTIMPL
};

class IVsDebugProcessNotifyMockImpl :
	public IVsDebugProcessNotify,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDebugProcessNotifyMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsDebugProcessNotifyMockImpl)

	typedef IVsDebugProcessNotify Interface;
	struct BeforeStopDebuggingProcessValidValues
	{
		/*[in]*/ STOP_DEBUGGING_PROCESS_REASON Reason;
		HRESULT retValue;
	};

	STDMETHOD(BeforeStopDebuggingProcess)(
		/*[in]*/ STOP_DEBUGGING_PROCESS_REASON Reason)
	{
		VSL_DEFINE_MOCK_METHOD(BeforeStopDebuggingProcess)

		VSL_CHECK_VALIDVALUE(Reason);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSDEBUGPROCESSNOTIFY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsDefaultButtonBarImages.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSDEFAULTBUTTONBARIMAGES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSDEFAULTBUTTONBARIMAGES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsDefaultButtonBarImagesNotImpl :
	public IVsDefaultButtonBarImages
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDefaultButtonBarImagesNotImpl)

public:

	typedef IVsDefaultButtonBarImages Interface;

	STDMETHOD(GetButtonCount)(
		/*[out]*/ long* /*pcButtons*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetImageList)(
		/*[out]*/ HANDLE* /*phImageList*/)VSL_STDMETHOD_NOTIMPL
};

class IVsDefaultButtonBarImagesMockImpl :
	public IVsDefaultButtonBarImages,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDefaultButtonBarImagesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsDefaultButtonBarImagesMockImpl)

	typedef IVsDefaultButtonBarImages Interface;
	struct GetButtonCountValidValues
	{
		/*[out]*/ long* pcButtons;
		HRESULT retValue;
	};

	STDMETHOD(GetButtonCount)(
		/*[out]*/ long* pcButtons)
	{
		VSL_DEFINE_MOCK_METHOD(GetButtonCount)

		VSL_SET_VALIDVALUE(pcButtons);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetImageListValidValues
	{
		/*[out]*/ HANDLE* phImageList;
		HRESULT retValue;
	};

	STDMETHOD(GetImageList)(
		/*[out]*/ HANDLE* phImageList)
	{
		VSL_DEFINE_MOCK_METHOD(GetImageList)

		VSL_SET_VALIDVALUE(phImageList);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSDEFAULTBUTTONBARIMAGES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsDependency.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSDEPENDENCY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSDEPENDENCY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsDependencyNotImpl :
	public IVsDependency
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDependencyNotImpl)

public:

	typedef IVsDependency Interface;

	STDMETHOD(get_CanonicalName)(
		/*[out]*/ BSTR* /*pbstrCanonicalName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Type)(
		/*[out]*/ GUID* /*pguidType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Description)(
		/*[out]*/ BSTR* /*pbstrDescription*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_HelpContext)(
		/*[out]*/ DWORD* /*pdwHelpContext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_HelpFile)(
		/*[out]*/ BSTR* /*pbstrHelpFile*/)VSL_STDMETHOD_NOTIMPL
};

class IVsDependencyMockImpl :
	public IVsDependency,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDependencyMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsDependencyMockImpl)

	typedef IVsDependency Interface;
	struct get_CanonicalNameValidValues
	{
		/*[out]*/ BSTR* pbstrCanonicalName;
		HRESULT retValue;
	};

	STDMETHOD(get_CanonicalName)(
		/*[out]*/ BSTR* pbstrCanonicalName)
	{
		VSL_DEFINE_MOCK_METHOD(get_CanonicalName)

		VSL_SET_VALIDVALUE_BSTR(pbstrCanonicalName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_TypeValidValues
	{
		/*[out]*/ GUID* pguidType;
		HRESULT retValue;
	};

	STDMETHOD(get_Type)(
		/*[out]*/ GUID* pguidType)
	{
		VSL_DEFINE_MOCK_METHOD(get_Type)

		VSL_SET_VALIDVALUE(pguidType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DescriptionValidValues
	{
		/*[out]*/ BSTR* pbstrDescription;
		HRESULT retValue;
	};

	STDMETHOD(get_Description)(
		/*[out]*/ BSTR* pbstrDescription)
	{
		VSL_DEFINE_MOCK_METHOD(get_Description)

		VSL_SET_VALIDVALUE_BSTR(pbstrDescription);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_HelpContextValidValues
	{
		/*[out]*/ DWORD* pdwHelpContext;
		HRESULT retValue;
	};

	STDMETHOD(get_HelpContext)(
		/*[out]*/ DWORD* pdwHelpContext)
	{
		VSL_DEFINE_MOCK_METHOD(get_HelpContext)

		VSL_SET_VALIDVALUE(pdwHelpContext);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_HelpFileValidValues
	{
		/*[out]*/ BSTR* pbstrHelpFile;
		HRESULT retValue;
	};

	STDMETHOD(get_HelpFile)(
		/*[out]*/ BSTR* pbstrHelpFile)
	{
		VSL_DEFINE_MOCK_METHOD(get_HelpFile)

		VSL_SET_VALIDVALUE_BSTR(pbstrHelpFile);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSDEPENDENCY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsDependencyProvider.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSDEPENDENCYPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSDEPENDENCYPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsDependencyProviderNotImpl :
	public IVsDependencyProvider
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDependencyProviderNotImpl)

public:

	typedef IVsDependencyProvider Interface;

	STDMETHOD(EnumDependencies)(
		/*[out]*/ IVsEnumDependencies** /*ppIVsEnumDependencies*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OpenDependency)(
		/*[in]*/ LPCOLESTR /*szDependencyCanonicalName*/,
		/*[out]*/ IVsDependency** /*ppIVsDependency*/)VSL_STDMETHOD_NOTIMPL
};

class IVsDependencyProviderMockImpl :
	public IVsDependencyProvider,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDependencyProviderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsDependencyProviderMockImpl)

	typedef IVsDependencyProvider Interface;
	struct EnumDependenciesValidValues
	{
		/*[out]*/ IVsEnumDependencies** ppIVsEnumDependencies;
		HRESULT retValue;
	};

	STDMETHOD(EnumDependencies)(
		/*[out]*/ IVsEnumDependencies** ppIVsEnumDependencies)
	{
		VSL_DEFINE_MOCK_METHOD(EnumDependencies)

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsEnumDependencies);

		VSL_RETURN_VALIDVALUES();
	}
	struct OpenDependencyValidValues
	{
		/*[in]*/ LPCOLESTR szDependencyCanonicalName;
		/*[out]*/ IVsDependency** ppIVsDependency;
		HRESULT retValue;
	};

	STDMETHOD(OpenDependency)(
		/*[in]*/ LPCOLESTR szDependencyCanonicalName,
		/*[out]*/ IVsDependency** ppIVsDependency)
	{
		VSL_DEFINE_MOCK_METHOD(OpenDependency)

		VSL_CHECK_VALIDVALUE_STRINGW(szDependencyCanonicalName);

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsDependency);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSDEPENDENCYPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsDeployDependency2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSDEPLOYDEPENDENCY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSDEPLOYDEPENDENCY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsDeployDependency2NotImpl :
	public IVsDeployDependency2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDeployDependency2NotImpl)

public:

	typedef IVsDeployDependency2 Interface;

	STDMETHOD(get_Property)(
		/*[in]*/ LPCOLESTR /*szProperty*/,
		/*[out]*/ VARIANT* /*pvar*/)VSL_STDMETHOD_NOTIMPL
};

class IVsDeployDependency2MockImpl :
	public IVsDeployDependency2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDeployDependency2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsDeployDependency2MockImpl)

	typedef IVsDeployDependency2 Interface;
	struct get_PropertyValidValues
	{
		/*[in]*/ LPCOLESTR szProperty;
		/*[out]*/ VARIANT* pvar;
		HRESULT retValue;
	};

	STDMETHOD(get_Property)(
		/*[in]*/ LPCOLESTR szProperty,
		/*[out]*/ VARIANT* pvar)
	{
		VSL_DEFINE_MOCK_METHOD(get_Property)

		VSL_CHECK_VALIDVALUE_STRINGW(szProperty);

		VSL_SET_VALIDVALUE_VARIANT(pvar);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSDEPLOYDEPENDENCY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsDeployStatusCallback.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSDEPLOYSTATUSCALLBACK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSDEPLOYSTATUSCALLBACK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsDeployStatusCallbackNotImpl :
	public IVsDeployStatusCallback
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDeployStatusCallbackNotImpl)

public:

	typedef IVsDeployStatusCallback Interface;

	STDMETHOD(OnStartDeploy)(
		/*[in,out]*/ BOOL* /*pfContinue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnEndDeploy)(
		/*[in]*/ BOOL /*fSuccessful*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnQueryContinueDeploy)(
		/*[in,out]*/ BOOL* /*pfContinue*/)VSL_STDMETHOD_NOTIMPL
};

class IVsDeployStatusCallbackMockImpl :
	public IVsDeployStatusCallback,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDeployStatusCallbackMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsDeployStatusCallbackMockImpl)

	typedef IVsDeployStatusCallback Interface;
	struct OnStartDeployValidValues
	{
		/*[in,out]*/ BOOL* pfContinue;
		HRESULT retValue;
	};

	STDMETHOD(OnStartDeploy)(
		/*[in,out]*/ BOOL* pfContinue)
	{
		VSL_DEFINE_MOCK_METHOD(OnStartDeploy)

		VSL_SET_VALIDVALUE(pfContinue);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnEndDeployValidValues
	{
		/*[in]*/ BOOL fSuccessful;
		HRESULT retValue;
	};

	STDMETHOD(OnEndDeploy)(
		/*[in]*/ BOOL fSuccessful)
	{
		VSL_DEFINE_MOCK_METHOD(OnEndDeploy)

		VSL_CHECK_VALIDVALUE(fSuccessful);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnQueryContinueDeployValidValues
	{
		/*[in,out]*/ BOOL* pfContinue;
		HRESULT retValue;
	};

	STDMETHOD(OnQueryContinueDeploy)(
		/*[in,out]*/ BOOL* pfContinue)
	{
		VSL_DEFINE_MOCK_METHOD(OnQueryContinueDeploy)

		VSL_SET_VALIDVALUE(pfContinue);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSDEPLOYSTATUSCALLBACK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsDeployableProjectCfg.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSDEPLOYABLEPROJECTCFG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSDEPLOYABLEPROJECTCFG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsDeployableProjectCfgNotImpl :
	public IVsDeployableProjectCfg
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDeployableProjectCfgNotImpl)

public:

	typedef IVsDeployableProjectCfg Interface;

	STDMETHOD(AdviseDeployStatusCallback)(
		/*[in]*/ IVsDeployStatusCallback* /*pIVsDeployStatusCallback*/,
		/*[out]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseDeployStatusCallback)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(StartDeploy)(
		/*[in]*/ IVsOutputWindowPane* /*pIVsOutputWindowPane*/,
		/*[in]*/ DWORD /*dwOptions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryStatusDeploy)(
		/*[out]*/ BOOL* /*pfDeployDone*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(StopDeploy)(
		/*[in]*/ BOOL /*fSync*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(WaitDeploy)(
		/*[in]*/ DWORD /*dwMilliseconds*/,
		/*[in]*/ BOOL /*fTickWhenMessageQNotEmpty*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryStartDeploy)(
		/*[in]*/ DWORD /*dwOptions*/,
		/*[out,optional]*/ BOOL* /*pfSupported*/,
		/*[out,optional]*/ BOOL* /*pfReady*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Commit)(
		/*[in]*/ DWORD /*dwReserved*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Rollback)(
		/*[in]*/ DWORD /*dwReserved*/)VSL_STDMETHOD_NOTIMPL
};

class IVsDeployableProjectCfgMockImpl :
	public IVsDeployableProjectCfg,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDeployableProjectCfgMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsDeployableProjectCfgMockImpl)

	typedef IVsDeployableProjectCfg Interface;
	struct AdviseDeployStatusCallbackValidValues
	{
		/*[in]*/ IVsDeployStatusCallback* pIVsDeployStatusCallback;
		/*[out]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(AdviseDeployStatusCallback)(
		/*[in]*/ IVsDeployStatusCallback* pIVsDeployStatusCallback,
		/*[out]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(AdviseDeployStatusCallback)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsDeployStatusCallback);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseDeployStatusCallbackValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnadviseDeployStatusCallback)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnadviseDeployStatusCallback)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct StartDeployValidValues
	{
		/*[in]*/ IVsOutputWindowPane* pIVsOutputWindowPane;
		/*[in]*/ DWORD dwOptions;
		HRESULT retValue;
	};

	STDMETHOD(StartDeploy)(
		/*[in]*/ IVsOutputWindowPane* pIVsOutputWindowPane,
		/*[in]*/ DWORD dwOptions)
	{
		VSL_DEFINE_MOCK_METHOD(StartDeploy)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsOutputWindowPane);

		VSL_CHECK_VALIDVALUE(dwOptions);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryStatusDeployValidValues
	{
		/*[out]*/ BOOL* pfDeployDone;
		HRESULT retValue;
	};

	STDMETHOD(QueryStatusDeploy)(
		/*[out]*/ BOOL* pfDeployDone)
	{
		VSL_DEFINE_MOCK_METHOD(QueryStatusDeploy)

		VSL_SET_VALIDVALUE(pfDeployDone);

		VSL_RETURN_VALIDVALUES();
	}
	struct StopDeployValidValues
	{
		/*[in]*/ BOOL fSync;
		HRESULT retValue;
	};

	STDMETHOD(StopDeploy)(
		/*[in]*/ BOOL fSync)
	{
		VSL_DEFINE_MOCK_METHOD(StopDeploy)

		VSL_CHECK_VALIDVALUE(fSync);

		VSL_RETURN_VALIDVALUES();
	}
	struct WaitDeployValidValues
	{
		/*[in]*/ DWORD dwMilliseconds;
		/*[in]*/ BOOL fTickWhenMessageQNotEmpty;
		HRESULT retValue;
	};

	STDMETHOD(WaitDeploy)(
		/*[in]*/ DWORD dwMilliseconds,
		/*[in]*/ BOOL fTickWhenMessageQNotEmpty)
	{
		VSL_DEFINE_MOCK_METHOD(WaitDeploy)

		VSL_CHECK_VALIDVALUE(dwMilliseconds);

		VSL_CHECK_VALIDVALUE(fTickWhenMessageQNotEmpty);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryStartDeployValidValues
	{
		/*[in]*/ DWORD dwOptions;
		/*[out,optional]*/ BOOL* pfSupported;
		/*[out,optional]*/ BOOL* pfReady;
		HRESULT retValue;
	};

	STDMETHOD(QueryStartDeploy)(
		/*[in]*/ DWORD dwOptions,
		/*[out,optional]*/ BOOL* pfSupported,
		/*[out,optional]*/ BOOL* pfReady)
	{
		VSL_DEFINE_MOCK_METHOD(QueryStartDeploy)

		VSL_CHECK_VALIDVALUE(dwOptions);

		VSL_SET_VALIDVALUE(pfSupported);

		VSL_SET_VALIDVALUE(pfReady);

		VSL_RETURN_VALIDVALUES();
	}
	struct CommitValidValues
	{
		/*[in]*/ DWORD dwReserved;
		HRESULT retValue;
	};

	STDMETHOD(Commit)(
		/*[in]*/ DWORD dwReserved)
	{
		VSL_DEFINE_MOCK_METHOD(Commit)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_RETURN_VALIDVALUES();
	}
	struct RollbackValidValues
	{
		/*[in]*/ DWORD dwReserved;
		HRESULT retValue;
	};

	STDMETHOD(Rollback)(
		/*[in]*/ DWORD dwReserved)
	{
		VSL_DEFINE_MOCK_METHOD(Rollback)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSDEPLOYABLEPROJECTCFG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsDeployableProjectCfg2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSDEPLOYABLEPROJECTCFG2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSDEPLOYABLEPROJECTCFG2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsDeployableProjectCfg2NotImpl :
	public IVsDeployableProjectCfg2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDeployableProjectCfg2NotImpl)

public:

	typedef IVsDeployableProjectCfg2 Interface;

	STDMETHOD(StartCleanDeploy)(
		/*[in]*/ IVsOutputWindowPane* /*pIVsOutputWindowPane*/,
		/*[in]*/ DWORD /*dwOptions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AdviseDeployStatusCallback)(
		/*[in]*/ IVsDeployStatusCallback* /*pIVsDeployStatusCallback*/,
		/*[out]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseDeployStatusCallback)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(StartDeploy)(
		/*[in]*/ IVsOutputWindowPane* /*pIVsOutputWindowPane*/,
		/*[in]*/ DWORD /*dwOptions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryStatusDeploy)(
		/*[out]*/ BOOL* /*pfDeployDone*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(StopDeploy)(
		/*[in]*/ BOOL /*fSync*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(WaitDeploy)(
		/*[in]*/ DWORD /*dwMilliseconds*/,
		/*[in]*/ BOOL /*fTickWhenMessageQNotEmpty*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryStartDeploy)(
		/*[in]*/ DWORD /*dwOptions*/,
		/*[out,optional]*/ BOOL* /*pfSupported*/,
		/*[out,optional]*/ BOOL* /*pfReady*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Commit)(
		/*[in]*/ DWORD /*dwReserved*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Rollback)(
		/*[in]*/ DWORD /*dwReserved*/)VSL_STDMETHOD_NOTIMPL
};

class IVsDeployableProjectCfg2MockImpl :
	public IVsDeployableProjectCfg2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDeployableProjectCfg2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsDeployableProjectCfg2MockImpl)

	typedef IVsDeployableProjectCfg2 Interface;
	struct StartCleanDeployValidValues
	{
		/*[in]*/ IVsOutputWindowPane* pIVsOutputWindowPane;
		/*[in]*/ DWORD dwOptions;
		HRESULT retValue;
	};

	STDMETHOD(StartCleanDeploy)(
		/*[in]*/ IVsOutputWindowPane* pIVsOutputWindowPane,
		/*[in]*/ DWORD dwOptions)
	{
		VSL_DEFINE_MOCK_METHOD(StartCleanDeploy)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsOutputWindowPane);

		VSL_CHECK_VALIDVALUE(dwOptions);

		VSL_RETURN_VALIDVALUES();
	}
	struct AdviseDeployStatusCallbackValidValues
	{
		/*[in]*/ IVsDeployStatusCallback* pIVsDeployStatusCallback;
		/*[out]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(AdviseDeployStatusCallback)(
		/*[in]*/ IVsDeployStatusCallback* pIVsDeployStatusCallback,
		/*[out]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(AdviseDeployStatusCallback)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsDeployStatusCallback);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseDeployStatusCallbackValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnadviseDeployStatusCallback)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnadviseDeployStatusCallback)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct StartDeployValidValues
	{
		/*[in]*/ IVsOutputWindowPane* pIVsOutputWindowPane;
		/*[in]*/ DWORD dwOptions;
		HRESULT retValue;
	};

	STDMETHOD(StartDeploy)(
		/*[in]*/ IVsOutputWindowPane* pIVsOutputWindowPane,
		/*[in]*/ DWORD dwOptions)
	{
		VSL_DEFINE_MOCK_METHOD(StartDeploy)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsOutputWindowPane);

		VSL_CHECK_VALIDVALUE(dwOptions);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryStatusDeployValidValues
	{
		/*[out]*/ BOOL* pfDeployDone;
		HRESULT retValue;
	};

	STDMETHOD(QueryStatusDeploy)(
		/*[out]*/ BOOL* pfDeployDone)
	{
		VSL_DEFINE_MOCK_METHOD(QueryStatusDeploy)

		VSL_SET_VALIDVALUE(pfDeployDone);

		VSL_RETURN_VALIDVALUES();
	}
	struct StopDeployValidValues
	{
		/*[in]*/ BOOL fSync;
		HRESULT retValue;
	};

	STDMETHOD(StopDeploy)(
		/*[in]*/ BOOL fSync)
	{
		VSL_DEFINE_MOCK_METHOD(StopDeploy)

		VSL_CHECK_VALIDVALUE(fSync);

		VSL_RETURN_VALIDVALUES();
	}
	struct WaitDeployValidValues
	{
		/*[in]*/ DWORD dwMilliseconds;
		/*[in]*/ BOOL fTickWhenMessageQNotEmpty;
		HRESULT retValue;
	};

	STDMETHOD(WaitDeploy)(
		/*[in]*/ DWORD dwMilliseconds,
		/*[in]*/ BOOL fTickWhenMessageQNotEmpty)
	{
		VSL_DEFINE_MOCK_METHOD(WaitDeploy)

		VSL_CHECK_VALIDVALUE(dwMilliseconds);

		VSL_CHECK_VALIDVALUE(fTickWhenMessageQNotEmpty);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryStartDeployValidValues
	{
		/*[in]*/ DWORD dwOptions;
		/*[out,optional]*/ BOOL* pfSupported;
		/*[out,optional]*/ BOOL* pfReady;
		HRESULT retValue;
	};

	STDMETHOD(QueryStartDeploy)(
		/*[in]*/ DWORD dwOptions,
		/*[out,optional]*/ BOOL* pfSupported,
		/*[out,optional]*/ BOOL* pfReady)
	{
		VSL_DEFINE_MOCK_METHOD(QueryStartDeploy)

		VSL_CHECK_VALIDVALUE(dwOptions);

		VSL_SET_VALIDVALUE(pfSupported);

		VSL_SET_VALIDVALUE(pfReady);

		VSL_RETURN_VALIDVALUES();
	}
	struct CommitValidValues
	{
		/*[in]*/ DWORD dwReserved;
		HRESULT retValue;
	};

	STDMETHOD(Commit)(
		/*[in]*/ DWORD dwReserved)
	{
		VSL_DEFINE_MOCK_METHOD(Commit)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_RETURN_VALIDVALUES();
	}
	struct RollbackValidValues
	{
		/*[in]*/ DWORD dwReserved;
		HRESULT retValue;
	};

	STDMETHOD(Rollback)(
		/*[in]*/ DWORD dwReserved)
	{
		VSL_DEFINE_MOCK_METHOD(Rollback)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSDEPLOYABLEPROJECTCFG2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsDeployDependency.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSDEPLOYDEPENDENCY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSDEPLOYDEPENDENCY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsDeployDependencyNotImpl :
	public IVsDeployDependency
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDeployDependencyNotImpl)

public:

	typedef IVsDeployDependency Interface;

	STDMETHOD(get_DeployDependencyURL)(
		/*[out]*/ BSTR* /*pbstrURL*/)VSL_STDMETHOD_NOTIMPL
};

class IVsDeployDependencyMockImpl :
	public IVsDeployDependency,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDeployDependencyMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsDeployDependencyMockImpl)

	typedef IVsDeployDependency Interface;
	struct get_DeployDependencyURLValidValues
	{
		/*[out]*/ BSTR* pbstrURL;
		HRESULT retValue;
	};

	STDMETHOD(get_DeployDependencyURL)(
		/*[out]*/ BSTR* pbstrURL)
	{
		VSL_DEFINE_MOCK_METHOD(get_DeployDependencyURL)

		VSL_SET_VALIDVALUE_BSTR(pbstrURL);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSDEPLOYDEPENDENCY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsDetermineWizardTrust.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSDETERMINEWIZARDTRUST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSDETERMINEWIZARDTRUST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsDetermineWizardTrustNotImpl :
	public IVsDetermineWizardTrust
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDetermineWizardTrustNotImpl)

public:

	typedef IVsDetermineWizardTrust Interface;

	STDMETHOD(OnWizardInitiated)(
		/*[in]*/ LPCOLESTR /*pszTemplateFilename*/,
		/*[in]*/ REFGUID /*guidProjectType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnWizardCompleted)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsWizardRunning)(
		/*[out]*/ BOOL* /*pfWizardRunning*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetRunningWizardTemplateName)(
		/*[out]*/ BSTR* /*pbstrRunningTemplate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetWizardTrustLevel)(
		/*[out]*/ VSWIZARDTRUSTLEVEL* /*pdwWizardTrustLevel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetWizardTrustLevel)(
		/*[in]*/ VSWIZARDTRUSTLEVEL /*dwWizardTrustLevel*/)VSL_STDMETHOD_NOTIMPL
};

class IVsDetermineWizardTrustMockImpl :
	public IVsDetermineWizardTrust,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDetermineWizardTrustMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsDetermineWizardTrustMockImpl)

	typedef IVsDetermineWizardTrust Interface;
	struct OnWizardInitiatedValidValues
	{
		/*[in]*/ LPCOLESTR pszTemplateFilename;
		/*[in]*/ REFGUID guidProjectType;
		HRESULT retValue;
	};

	STDMETHOD(OnWizardInitiated)(
		/*[in]*/ LPCOLESTR pszTemplateFilename,
		/*[in]*/ REFGUID guidProjectType)
	{
		VSL_DEFINE_MOCK_METHOD(OnWizardInitiated)

		VSL_CHECK_VALIDVALUE_STRINGW(pszTemplateFilename);

		VSL_CHECK_VALIDVALUE(guidProjectType);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnWizardCompletedValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnWizardCompleted)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnWizardCompleted)

		VSL_RETURN_VALIDVALUES();
	}
	struct IsWizardRunningValidValues
	{
		/*[out]*/ BOOL* pfWizardRunning;
		HRESULT retValue;
	};

	STDMETHOD(IsWizardRunning)(
		/*[out]*/ BOOL* pfWizardRunning)
	{
		VSL_DEFINE_MOCK_METHOD(IsWizardRunning)

		VSL_SET_VALIDVALUE(pfWizardRunning);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetRunningWizardTemplateNameValidValues
	{
		/*[out]*/ BSTR* pbstrRunningTemplate;
		HRESULT retValue;
	};

	STDMETHOD(GetRunningWizardTemplateName)(
		/*[out]*/ BSTR* pbstrRunningTemplate)
	{
		VSL_DEFINE_MOCK_METHOD(GetRunningWizardTemplateName)

		VSL_SET_VALIDVALUE_BSTR(pbstrRunningTemplate);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetWizardTrustLevelValidValues
	{
		/*[out]*/ VSWIZARDTRUSTLEVEL* pdwWizardTrustLevel;
		HRESULT retValue;
	};

	STDMETHOD(GetWizardTrustLevel)(
		/*[out]*/ VSWIZARDTRUSTLEVEL* pdwWizardTrustLevel)
	{
		VSL_DEFINE_MOCK_METHOD(GetWizardTrustLevel)

		VSL_SET_VALIDVALUE(pdwWizardTrustLevel);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetWizardTrustLevelValidValues
	{
		/*[in]*/ VSWIZARDTRUSTLEVEL dwWizardTrustLevel;
		HRESULT retValue;
	};

	STDMETHOD(SetWizardTrustLevel)(
		/*[in]*/ VSWIZARDTRUSTLEVEL dwWizardTrustLevel)
	{
		VSL_DEFINE_MOCK_METHOD(SetWizardTrustLevel)

		VSL_CHECK_VALIDVALUE(dwWizardTrustLevel);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSDETERMINEWIZARDTRUST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsDiscoveryService.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSDISCOVERYSERVICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSDISCOVERYSERVICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "DiscoveryService.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsDiscoveryServiceNotImpl :
	public IVsDiscoveryService
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDiscoveryServiceNotImpl)

public:

	typedef IVsDiscoveryService Interface;

	STDMETHOD(CreateDiscoverySession)(
		/*[out,retval]*/ IDiscoverySession** /*pSessionObject*/)VSL_STDMETHOD_NOTIMPL
};

class IVsDiscoveryServiceMockImpl :
	public IVsDiscoveryService,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDiscoveryServiceMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsDiscoveryServiceMockImpl)

	typedef IVsDiscoveryService Interface;
	struct CreateDiscoverySessionValidValues
	{
		/*[out,retval]*/ IDiscoverySession** pSessionObject;
		HRESULT retValue;
	};

	STDMETHOD(CreateDiscoverySession)(
		/*[out,retval]*/ IDiscoverySession** pSessionObject)
	{
		VSL_DEFINE_MOCK_METHOD(CreateDiscoverySession)

		VSL_SET_VALIDVALUE_INTERFACE(pSessionObject);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSDISCOVERYSERVICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsDispatch.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSDISPATCH_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSDISPATCH_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsdisp.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsDispatchNotImpl :
	public IVsDispatch
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDispatchNotImpl)

public:

	typedef IVsDispatch Interface;

	STDMETHOD(Do)(
		/*[in]*/ VSDISPID /*vsdispid*/,
		/*[in]*/ long /*celIn*/,
		/*[in,size_is(celIn)]*/ VARIANT* /*rgvaIn*/,
		/*[in]*/ long /*celOut*/,
		/*[in,out,size_is(celOut)]*/ VARIANT* /*rgvaOut*/)VSL_STDMETHOD_NOTIMPL
};

class IVsDispatchMockImpl :
	public IVsDispatch,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDispatchMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsDispatchMockImpl)

	typedef IVsDispatch Interface;
	struct DoValidValues
	{
		/*[in]*/ VSDISPID vsdispid;
		/*[in]*/ long celIn;
		/*[in,size_is(celIn)]*/ VARIANT* rgvaIn;
		/*[in]*/ long celOut;
		/*[in,out,size_is(celOut)]*/ VARIANT* rgvaOut;
		HRESULT retValue;
	};

	STDMETHOD(Do)(
		/*[in]*/ VSDISPID vsdispid,
		/*[in]*/ long celIn,
		/*[in,size_is(celIn)]*/ VARIANT* rgvaIn,
		/*[in]*/ long celOut,
		/*[in,out,size_is(celOut)]*/ VARIANT* rgvaOut)
	{
		VSL_DEFINE_MOCK_METHOD(Do)

		VSL_CHECK_VALIDVALUE(vsdispid);

		VSL_CHECK_VALIDVALUE(celIn);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgvaIn, celIn*sizeof(rgvaIn[0]), validValues.celIn*sizeof(validValues.rgvaIn[0]));

		VSL_CHECK_VALIDVALUE(celOut);

		VSL_SET_VALIDVALUE_MEMCPY(rgvaOut, celOut*sizeof(rgvaOut[0]), validValues.celOut*sizeof(validValues.rgvaOut[0]));

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSDISPATCH_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsDocOutlineProvider2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSDOCOUTLINEPROVIDER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSDOCOUTLINEPROVIDER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsDocOutlineProvider2NotImpl :
	public IVsDocOutlineProvider2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDocOutlineProvider2NotImpl)

public:

	typedef IVsDocOutlineProvider2 Interface;

	STDMETHOD(TranslateAccelerator)(
		/*[in]*/ LPMSG /*lpMsg*/)VSL_STDMETHOD_NOTIMPL
};

class IVsDocOutlineProvider2MockImpl :
	public IVsDocOutlineProvider2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDocOutlineProvider2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsDocOutlineProvider2MockImpl)

	typedef IVsDocOutlineProvider2 Interface;
	struct TranslateAcceleratorValidValues
	{
		/*[in]*/ LPMSG lpMsg;
		HRESULT retValue;
	};

	STDMETHOD(TranslateAccelerator)(
		/*[in]*/ LPMSG lpMsg)
	{
		VSL_DEFINE_MOCK_METHOD(TranslateAccelerator)

		VSL_CHECK_VALIDVALUE(lpMsg);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSDOCOUTLINEPROVIDER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsDropdownBarClient.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSDROPDOWNBARCLIENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSDROPDOWNBARCLIENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsDropdownBarClientNotImpl :
	public IVsDropdownBarClient
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDropdownBarClientNotImpl)

public:

	typedef IVsDropdownBarClient Interface;

	STDMETHOD(SetDropdownBar)(
		/*[in]*/ IVsDropdownBar* /*pDropdownBar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetComboAttributes)(
		/*[in]*/ long /*iCombo*/,
		/*[out]*/ ULONG* /*pcEntries*/,
		/*[out]*/ ULONG* /*puEntryType*/,
		/*[out]*/ HANDLE* /*phImageList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEntryText)(
		/*[in]*/ long /*iCombo*/,
		/*[in]*/ long /*iIndex*/,
		/*[out]*/ WCHAR** /*ppszText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEntryAttributes)(
		/*[in]*/ long /*iCombo*/,
		/*[in]*/ long /*iIndex*/,
		/*[out]*/ ULONG* /*pAttr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEntryImage)(
		/*[in]*/ long /*iCombo*/,
		/*[in]*/ long /*iIndex*/,
		/*[out]*/ long* /*piImageIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnItemSelected)(
		/*[in]*/ long /*iCombo*/,
		/*[in]*/ long /*iIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnItemChosen)(
		/*[in]*/ long /*iCombo*/,
		/*[in]*/ long /*iIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnComboGetFocus)(
		/*[in]*/ long /*iCombo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetComboTipText)(
		/*[in]*/ long /*iCombo*/,
		/*[out]*/ BSTR* /*pbstrText*/)VSL_STDMETHOD_NOTIMPL
};

class IVsDropdownBarClientMockImpl :
	public IVsDropdownBarClient,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDropdownBarClientMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsDropdownBarClientMockImpl)

	typedef IVsDropdownBarClient Interface;
	struct SetDropdownBarValidValues
	{
		/*[in]*/ IVsDropdownBar* pDropdownBar;
		HRESULT retValue;
	};

	STDMETHOD(SetDropdownBar)(
		/*[in]*/ IVsDropdownBar* pDropdownBar)
	{
		VSL_DEFINE_MOCK_METHOD(SetDropdownBar)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDropdownBar);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetComboAttributesValidValues
	{
		/*[in]*/ long iCombo;
		/*[out]*/ ULONG* pcEntries;
		/*[out]*/ ULONG* puEntryType;
		/*[out]*/ HANDLE* phImageList;
		HRESULT retValue;
	};

	STDMETHOD(GetComboAttributes)(
		/*[in]*/ long iCombo,
		/*[out]*/ ULONG* pcEntries,
		/*[out]*/ ULONG* puEntryType,
		/*[out]*/ HANDLE* phImageList)
	{
		VSL_DEFINE_MOCK_METHOD(GetComboAttributes)

		VSL_CHECK_VALIDVALUE(iCombo);

		VSL_SET_VALIDVALUE(pcEntries);

		VSL_SET_VALIDVALUE(puEntryType);

		VSL_SET_VALIDVALUE(phImageList);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEntryTextValidValues
	{
		/*[in]*/ long iCombo;
		/*[in]*/ long iIndex;
		/*[out]*/ WCHAR** ppszText;
		HRESULT retValue;
	};

	STDMETHOD(GetEntryText)(
		/*[in]*/ long iCombo,
		/*[in]*/ long iIndex,
		/*[out]*/ WCHAR** ppszText)
	{
		VSL_DEFINE_MOCK_METHOD(GetEntryText)

		VSL_CHECK_VALIDVALUE(iCombo);

		VSL_CHECK_VALIDVALUE(iIndex);

		VSL_SET_VALIDVALUE(ppszText);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEntryAttributesValidValues
	{
		/*[in]*/ long iCombo;
		/*[in]*/ long iIndex;
		/*[out]*/ ULONG* pAttr;
		HRESULT retValue;
	};

	STDMETHOD(GetEntryAttributes)(
		/*[in]*/ long iCombo,
		/*[in]*/ long iIndex,
		/*[out]*/ ULONG* pAttr)
	{
		VSL_DEFINE_MOCK_METHOD(GetEntryAttributes)

		VSL_CHECK_VALIDVALUE(iCombo);

		VSL_CHECK_VALIDVALUE(iIndex);

		VSL_SET_VALIDVALUE(pAttr);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEntryImageValidValues
	{
		/*[in]*/ long iCombo;
		/*[in]*/ long iIndex;
		/*[out]*/ long* piImageIndex;
		HRESULT retValue;
	};

	STDMETHOD(GetEntryImage)(
		/*[in]*/ long iCombo,
		/*[in]*/ long iIndex,
		/*[out]*/ long* piImageIndex)
	{
		VSL_DEFINE_MOCK_METHOD(GetEntryImage)

		VSL_CHECK_VALIDVALUE(iCombo);

		VSL_CHECK_VALIDVALUE(iIndex);

		VSL_SET_VALIDVALUE(piImageIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnItemSelectedValidValues
	{
		/*[in]*/ long iCombo;
		/*[in]*/ long iIndex;
		HRESULT retValue;
	};

	STDMETHOD(OnItemSelected)(
		/*[in]*/ long iCombo,
		/*[in]*/ long iIndex)
	{
		VSL_DEFINE_MOCK_METHOD(OnItemSelected)

		VSL_CHECK_VALIDVALUE(iCombo);

		VSL_CHECK_VALIDVALUE(iIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnItemChosenValidValues
	{
		/*[in]*/ long iCombo;
		/*[in]*/ long iIndex;
		HRESULT retValue;
	};

	STDMETHOD(OnItemChosen)(
		/*[in]*/ long iCombo,
		/*[in]*/ long iIndex)
	{
		VSL_DEFINE_MOCK_METHOD(OnItemChosen)

		VSL_CHECK_VALIDVALUE(iCombo);

		VSL_CHECK_VALIDVALUE(iIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnComboGetFocusValidValues
	{
		/*[in]*/ long iCombo;
		HRESULT retValue;
	};

	STDMETHOD(OnComboGetFocus)(
		/*[in]*/ long iCombo)
	{
		VSL_DEFINE_MOCK_METHOD(OnComboGetFocus)

		VSL_CHECK_VALIDVALUE(iCombo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetComboTipTextValidValues
	{
		/*[in]*/ long iCombo;
		/*[out]*/ BSTR* pbstrText;
		HRESULT retValue;
	};

	STDMETHOD(GetComboTipText)(
		/*[in]*/ long iCombo,
		/*[out]*/ BSTR* pbstrText)
	{
		VSL_DEFINE_MOCK_METHOD(GetComboTipText)

		VSL_CHECK_VALIDVALUE(iCombo);

		VSL_SET_VALIDVALUE_BSTR(pbstrText);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSDROPDOWNBARCLIENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsDocDataFileChangeControl.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSDOCDATAFILECHANGECONTROL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSDOCDATAFILECHANGECONTROL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsDocDataFileChangeControlNotImpl :
	public IVsDocDataFileChangeControl
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDocDataFileChangeControlNotImpl)

public:

	typedef IVsDocDataFileChangeControl Interface;

	STDMETHOD(IgnoreFileChanges)(
		/*[in]*/ BOOL /*fIgnore*/)VSL_STDMETHOD_NOTIMPL
};

class IVsDocDataFileChangeControlMockImpl :
	public IVsDocDataFileChangeControl,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDocDataFileChangeControlMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsDocDataFileChangeControlMockImpl)

	typedef IVsDocDataFileChangeControl Interface;
	struct IgnoreFileChangesValidValues
	{
		/*[in]*/ BOOL fIgnore;
		HRESULT retValue;
	};

	STDMETHOD(IgnoreFileChanges)(
		/*[in]*/ BOOL fIgnore)
	{
		VSL_DEFINE_MOCK_METHOD(IgnoreFileChanges)

		VSL_CHECK_VALIDVALUE(fIgnore);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSDOCDATAFILECHANGECONTROL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsDocOutlineProvider.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSDOCOUTLINEPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSDOCOUTLINEPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsDocOutlineProviderNotImpl :
	public IVsDocOutlineProvider
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDocOutlineProviderNotImpl)

public:

	typedef IVsDocOutlineProvider Interface;

	STDMETHOD(GetOutlineCaption)(
		/*[in]*/ VSOUTLINECAPTION /*nCaptionType*/,
		/*[out]*/ BSTR* /*pbstrCaption*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetOutline)(
		/*[out]*/ HWND* /*phwnd*/,
		/*[out]*/ IOleCommandTarget** /*ppCmdTarget*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReleaseOutline)(
		/*[in]*/ HWND /*hwnd*/,
		/*[in]*/ IOleCommandTarget* /*pCmdTarget*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnOutlineStateChange)(
		/*[in]*/ VSOUTLINESTATES /*dwMask*/,
		/*[in]*/ VSOUTLINESTATES /*dwState*/)VSL_STDMETHOD_NOTIMPL
};

class IVsDocOutlineProviderMockImpl :
	public IVsDocOutlineProvider,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDocOutlineProviderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsDocOutlineProviderMockImpl)

	typedef IVsDocOutlineProvider Interface;
	struct GetOutlineCaptionValidValues
	{
		/*[in]*/ VSOUTLINECAPTION nCaptionType;
		/*[out]*/ BSTR* pbstrCaption;
		HRESULT retValue;
	};

	STDMETHOD(GetOutlineCaption)(
		/*[in]*/ VSOUTLINECAPTION nCaptionType,
		/*[out]*/ BSTR* pbstrCaption)
	{
		VSL_DEFINE_MOCK_METHOD(GetOutlineCaption)

		VSL_CHECK_VALIDVALUE(nCaptionType);

		VSL_SET_VALIDVALUE_BSTR(pbstrCaption);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetOutlineValidValues
	{
		/*[out]*/ HWND* phwnd;
		/*[out]*/ IOleCommandTarget** ppCmdTarget;
		HRESULT retValue;
	};

	STDMETHOD(GetOutline)(
		/*[out]*/ HWND* phwnd,
		/*[out]*/ IOleCommandTarget** ppCmdTarget)
	{
		VSL_DEFINE_MOCK_METHOD(GetOutline)

		VSL_SET_VALIDVALUE(phwnd);

		VSL_SET_VALIDVALUE_INTERFACE(ppCmdTarget);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReleaseOutlineValidValues
	{
		/*[in]*/ HWND hwnd;
		/*[in]*/ IOleCommandTarget* pCmdTarget;
		HRESULT retValue;
	};

	STDMETHOD(ReleaseOutline)(
		/*[in]*/ HWND hwnd,
		/*[in]*/ IOleCommandTarget* pCmdTarget)
	{
		VSL_DEFINE_MOCK_METHOD(ReleaseOutline)

		VSL_CHECK_VALIDVALUE(hwnd);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCmdTarget);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnOutlineStateChangeValidValues
	{
		/*[in]*/ VSOUTLINESTATES dwMask;
		/*[in]*/ VSOUTLINESTATES dwState;
		HRESULT retValue;
	};

	STDMETHOD(OnOutlineStateChange)(
		/*[in]*/ VSOUTLINESTATES dwMask,
		/*[in]*/ VSOUTLINESTATES dwState)
	{
		VSL_DEFINE_MOCK_METHOD(OnOutlineStateChange)

		VSL_CHECK_VALIDVALUE(dwMask);

		VSL_CHECK_VALIDVALUE(dwState);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSDOCOUTLINEPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsDocumentLockHolder.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSDOCUMENTLOCKHOLDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSDOCUMENTLOCKHOLDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsDocumentLockHolderNotImpl :
	public IVsDocumentLockHolder
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDocumentLockHolderNotImpl)

public:

	typedef IVsDocumentLockHolder Interface;

	STDMETHOD(ShowDocumentHolder)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CloseDocumentHolder)(
		/*[in]*/ FRAMECLOSE /*dwSaveOptions*/)VSL_STDMETHOD_NOTIMPL
};

class IVsDocumentLockHolderMockImpl :
	public IVsDocumentLockHolder,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDocumentLockHolderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsDocumentLockHolderMockImpl)

	typedef IVsDocumentLockHolder Interface;
	struct ShowDocumentHolderValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ShowDocumentHolder)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ShowDocumentHolder)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloseDocumentHolderValidValues
	{
		/*[in]*/ FRAMECLOSE dwSaveOptions;
		HRESULT retValue;
	};

	STDMETHOD(CloseDocumentHolder)(
		/*[in]*/ FRAMECLOSE dwSaveOptions)
	{
		VSL_DEFINE_MOCK_METHOD(CloseDocumentHolder)

		VSL_CHECK_VALIDVALUE(dwSaveOptions);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSDOCUMENTLOCKHOLDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsDropdownBarClientEx.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSDROPDOWNBARCLIENTEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSDROPDOWNBARCLIENTEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsDropdownBarClientExNotImpl :
	public IVsDropdownBarClientEx
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDropdownBarClientExNotImpl)

public:

	typedef IVsDropdownBarClientEx Interface;

	STDMETHOD(GetEntryIndent)(
		/*[in]*/ long /*iCombo*/,
		/*[in]*/ long /*iIndex*/,
		/*[out]*/ ULONG* /*pIndent*/)VSL_STDMETHOD_NOTIMPL
};

class IVsDropdownBarClientExMockImpl :
	public IVsDropdownBarClientEx,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDropdownBarClientExMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsDropdownBarClientExMockImpl)

	typedef IVsDropdownBarClientEx Interface;
	struct GetEntryIndentValidValues
	{
		/*[in]*/ long iCombo;
		/*[in]*/ long iIndex;
		/*[out]*/ ULONG* pIndent;
		HRESULT retValue;
	};

	STDMETHOD(GetEntryIndent)(
		/*[in]*/ long iCombo,
		/*[in]*/ long iIndex,
		/*[out]*/ ULONG* pIndent)
	{
		VSL_DEFINE_MOCK_METHOD(GetEntryIndent)

		VSL_CHECK_VALIDVALUE(iCombo);

		VSL_CHECK_VALIDVALUE(iIndex);

		VSL_SET_VALIDVALUE(pIndent);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSDROPDOWNBARCLIENTEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsDropdownBarManager.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSDROPDOWNBARMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSDROPDOWNBARMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsDropdownBarManagerNotImpl :
	public IVsDropdownBarManager
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDropdownBarManagerNotImpl)

public:

	typedef IVsDropdownBarManager Interface;

	STDMETHOD(AddDropdownBar)(
		/*[in]*/ long /*cCombos*/,
		/*[in]*/ IVsDropdownBarClient* /*pClient*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDropdownBar)(
		/*[out]*/ IVsDropdownBar** /*ppDropdownBar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveDropdownBar)()VSL_STDMETHOD_NOTIMPL
};

class IVsDropdownBarManagerMockImpl :
	public IVsDropdownBarManager,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDropdownBarManagerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsDropdownBarManagerMockImpl)

	typedef IVsDropdownBarManager Interface;
	struct AddDropdownBarValidValues
	{
		/*[in]*/ long cCombos;
		/*[in]*/ IVsDropdownBarClient* pClient;
		HRESULT retValue;
	};

	STDMETHOD(AddDropdownBar)(
		/*[in]*/ long cCombos,
		/*[in]*/ IVsDropdownBarClient* pClient)
	{
		VSL_DEFINE_MOCK_METHOD(AddDropdownBar)

		VSL_CHECK_VALIDVALUE(cCombos);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pClient);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDropdownBarValidValues
	{
		/*[out]*/ IVsDropdownBar** ppDropdownBar;
		HRESULT retValue;
	};

	STDMETHOD(GetDropdownBar)(
		/*[out]*/ IVsDropdownBar** ppDropdownBar)
	{
		VSL_DEFINE_MOCK_METHOD(GetDropdownBar)

		VSL_SET_VALIDVALUE_INTERFACE(ppDropdownBar);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveDropdownBarValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(RemoveDropdownBar)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(RemoveDropdownBar)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSDROPDOWNBARMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsEditorGoBackLocations.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSEDITORGOBACKLOCATIONS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSEDITORGOBACKLOCATIONS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsEditorGoBackLocationsNotImpl :
	public IVsEditorGoBackLocations
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEditorGoBackLocationsNotImpl)

public:

	typedef IVsEditorGoBackLocations Interface;

	STDMETHOD(SetNonMergeableGoBackLocation)(
		/*[in]*/ BOOL /*fCurrentCaretPos*/,
		/*[in]*/ long /*iBaseLine*/,
		/*[in]*/ long /*iBaseCol*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetMergeableGoBackLocation)(
		/*[in]*/ BOOL /*fCurrentCaretPos*/,
		/*[in]*/ long /*iBaseLine*/,
		/*[in]*/ long /*iBaseCol*/)VSL_STDMETHOD_NOTIMPL
};

class IVsEditorGoBackLocationsMockImpl :
	public IVsEditorGoBackLocations,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEditorGoBackLocationsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsEditorGoBackLocationsMockImpl)

	typedef IVsEditorGoBackLocations Interface;
	struct SetNonMergeableGoBackLocationValidValues
	{
		/*[in]*/ BOOL fCurrentCaretPos;
		/*[in]*/ long iBaseLine;
		/*[in]*/ long iBaseCol;
		HRESULT retValue;
	};

	STDMETHOD(SetNonMergeableGoBackLocation)(
		/*[in]*/ BOOL fCurrentCaretPos,
		/*[in]*/ long iBaseLine,
		/*[in]*/ long iBaseCol)
	{
		VSL_DEFINE_MOCK_METHOD(SetNonMergeableGoBackLocation)

		VSL_CHECK_VALIDVALUE(fCurrentCaretPos);

		VSL_CHECK_VALIDVALUE(iBaseLine);

		VSL_CHECK_VALIDVALUE(iBaseCol);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetMergeableGoBackLocationValidValues
	{
		/*[in]*/ BOOL fCurrentCaretPos;
		/*[in]*/ long iBaseLine;
		/*[in]*/ long iBaseCol;
		HRESULT retValue;
	};

	STDMETHOD(SetMergeableGoBackLocation)(
		/*[in]*/ BOOL fCurrentCaretPos,
		/*[in]*/ long iBaseLine,
		/*[in]*/ long iBaseCol)
	{
		VSL_DEFINE_MOCK_METHOD(SetMergeableGoBackLocation)

		VSL_CHECK_VALIDVALUE(fCurrentCaretPos);

		VSL_CHECK_VALIDVALUE(iBaseLine);

		VSL_CHECK_VALIDVALUE(iBaseCol);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSEDITORGOBACKLOCATIONS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsEditorFactoryNotify.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSEDITORFACTORYNOTIFY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSEDITORFACTORYNOTIFY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsEditorFactoryNotifyNotImpl :
	public IVsEditorFactoryNotify
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEditorFactoryNotifyNotImpl)

public:

	typedef IVsEditorFactoryNotify Interface;

	STDMETHOD(NotifyItemAdded)(
		/*[in]*/ EFNFLAGS /*grfEFN*/,
		/*[in]*/ IVsHierarchy* /*pHier*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ LPCOLESTR /*pszMkDocument*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(NotifyItemRenamed)(
		/*[in]*/ IVsHierarchy* /*pHier*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ LPCOLESTR /*pszMkDocumentOld*/,
		/*[in]*/ LPCOLESTR /*pszMkDocumentNew*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(NotifyDependentItemSaved)(
		/*[in]*/ IVsHierarchy* /*pHier*/,
		/*[in]*/ VSITEMID /*itemidParent*/,
		/*[in]*/ LPCOLESTR /*pszMkDocumentParent*/,
		/*[in]*/ VSITEMID /*itemidDpendent*/,
		/*[in]*/ LPCOLESTR /*pszMkDocumentDependent*/)VSL_STDMETHOD_NOTIMPL
};

class IVsEditorFactoryNotifyMockImpl :
	public IVsEditorFactoryNotify,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEditorFactoryNotifyMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsEditorFactoryNotifyMockImpl)

	typedef IVsEditorFactoryNotify Interface;
	struct NotifyItemAddedValidValues
	{
		/*[in]*/ EFNFLAGS grfEFN;
		/*[in]*/ IVsHierarchy* pHier;
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ LPCOLESTR pszMkDocument;
		HRESULT retValue;
	};

	STDMETHOD(NotifyItemAdded)(
		/*[in]*/ EFNFLAGS grfEFN,
		/*[in]*/ IVsHierarchy* pHier,
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ LPCOLESTR pszMkDocument)
	{
		VSL_DEFINE_MOCK_METHOD(NotifyItemAdded)

		VSL_CHECK_VALIDVALUE(grfEFN);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHier);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_RETURN_VALIDVALUES();
	}
	struct NotifyItemRenamedValidValues
	{
		/*[in]*/ IVsHierarchy* pHier;
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ LPCOLESTR pszMkDocumentOld;
		/*[in]*/ LPCOLESTR pszMkDocumentNew;
		HRESULT retValue;
	};

	STDMETHOD(NotifyItemRenamed)(
		/*[in]*/ IVsHierarchy* pHier,
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ LPCOLESTR pszMkDocumentOld,
		/*[in]*/ LPCOLESTR pszMkDocumentNew)
	{
		VSL_DEFINE_MOCK_METHOD(NotifyItemRenamed)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHier);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocumentOld);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocumentNew);

		VSL_RETURN_VALIDVALUES();
	}
	struct NotifyDependentItemSavedValidValues
	{
		/*[in]*/ IVsHierarchy* pHier;
		/*[in]*/ VSITEMID itemidParent;
		/*[in]*/ LPCOLESTR pszMkDocumentParent;
		/*[in]*/ VSITEMID itemidDpendent;
		/*[in]*/ LPCOLESTR pszMkDocumentDependent;
		HRESULT retValue;
	};

	STDMETHOD(NotifyDependentItemSaved)(
		/*[in]*/ IVsHierarchy* pHier,
		/*[in]*/ VSITEMID itemidParent,
		/*[in]*/ LPCOLESTR pszMkDocumentParent,
		/*[in]*/ VSITEMID itemidDpendent,
		/*[in]*/ LPCOLESTR pszMkDocumentDependent)
	{
		VSL_DEFINE_MOCK_METHOD(NotifyDependentItemSaved)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHier);

		VSL_CHECK_VALIDVALUE(itemidParent);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocumentParent);

		VSL_CHECK_VALIDVALUE(itemidDpendent);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocumentDependent);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSEDITORFACTORYNOTIFY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsEditorFactory.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSEDITORFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSEDITORFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsEditorFactoryNotImpl :
	public IVsEditorFactory
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEditorFactoryNotImpl)

public:

	typedef IVsEditorFactory Interface;

	STDMETHOD(CreateEditorInstance)(
		/*[in]*/ VSCREATEEDITORFLAGS /*grfCreateDoc*/,
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[in]*/ LPCOLESTR /*pszPhysicalView*/,
		/*[in]*/ IVsHierarchy* /*pvHier*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ IUnknown* /*punkDocDataExisting*/,
		/*[out]*/ IUnknown** /*ppunkDocView*/,
		/*[out]*/ IUnknown** /*ppunkDocData*/,
		/*[out]*/ BSTR* /*pbstrEditorCaption*/,
		/*[out]*/ GUID* /*pguidCmdUI*/,
		/*[out,retval]*/ VSEDITORCREATEDOCWIN* /*pgrfCDW*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetSite)(
		/*[in]*/ IServiceProvider* /*pSP*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Close)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MapLogicalView)(
		/*[in]*/ REFGUID /*rguidLogicalView*/,
		/*[out,retval]*/ BSTR* /*pbstrPhysicalView*/)VSL_STDMETHOD_NOTIMPL
};

class IVsEditorFactoryMockImpl :
	public IVsEditorFactory,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEditorFactoryMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsEditorFactoryMockImpl)

	typedef IVsEditorFactory Interface;
	struct CreateEditorInstanceValidValues
	{
		/*[in]*/ VSCREATEEDITORFLAGS grfCreateDoc;
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[in]*/ LPCOLESTR pszPhysicalView;
		/*[in]*/ IVsHierarchy* pvHier;
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ IUnknown* punkDocDataExisting;
		/*[out]*/ IUnknown** ppunkDocView;
		/*[out]*/ IUnknown** ppunkDocData;
		/*[out]*/ BSTR* pbstrEditorCaption;
		/*[out]*/ GUID* pguidCmdUI;
		/*[out,retval]*/ VSEDITORCREATEDOCWIN* pgrfCDW;
		HRESULT retValue;
	};

	STDMETHOD(CreateEditorInstance)(
		/*[in]*/ VSCREATEEDITORFLAGS grfCreateDoc,
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[in]*/ LPCOLESTR pszPhysicalView,
		/*[in]*/ IVsHierarchy* pvHier,
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ IUnknown* punkDocDataExisting,
		/*[out]*/ IUnknown** ppunkDocView,
		/*[out]*/ IUnknown** ppunkDocData,
		/*[out]*/ BSTR* pbstrEditorCaption,
		/*[out]*/ GUID* pguidCmdUI,
		/*[out,retval]*/ VSEDITORCREATEDOCWIN* pgrfCDW)
	{
		VSL_DEFINE_MOCK_METHOD(CreateEditorInstance)

		VSL_CHECK_VALIDVALUE(grfCreateDoc);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_CHECK_VALIDVALUE_STRINGW(pszPhysicalView);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pvHier);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkDocDataExisting);

		VSL_SET_VALIDVALUE_INTERFACE(ppunkDocView);

		VSL_SET_VALIDVALUE_INTERFACE(ppunkDocData);

		VSL_SET_VALIDVALUE_BSTR(pbstrEditorCaption);

		VSL_SET_VALIDVALUE(pguidCmdUI);

		VSL_SET_VALIDVALUE(pgrfCDW);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetSiteValidValues
	{
		/*[in]*/ IServiceProvider* pSP;
		HRESULT retValue;
	};

	STDMETHOD(SetSite)(
		/*[in]*/ IServiceProvider* pSP)
	{
		VSL_DEFINE_MOCK_METHOD(SetSite)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSP);

		VSL_RETURN_VALIDVALUES();
	}
	struct CloseValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Close)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Close)

		VSL_RETURN_VALIDVALUES();
	}
	struct MapLogicalViewValidValues
	{
		/*[in]*/ REFGUID rguidLogicalView;
		/*[out,retval]*/ BSTR* pbstrPhysicalView;
		HRESULT retValue;
	};

	STDMETHOD(MapLogicalView)(
		/*[in]*/ REFGUID rguidLogicalView,
		/*[out,retval]*/ BSTR* pbstrPhysicalView)
	{
		VSL_DEFINE_MOCK_METHOD(MapLogicalView)

		VSL_CHECK_VALIDVALUE(rguidLogicalView);

		VSL_SET_VALIDVALUE_BSTR(pbstrPhysicalView);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSEDITORFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsENCRebuildableProjectCfg2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSENCREBUILDABLEPROJECTCFG2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSENCREBUILDABLEPROJECTCFG2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "encbuild.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsENCRebuildableProjectCfg2NotImpl :
	public IVsENCRebuildableProjectCfg2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsENCRebuildableProjectCfg2NotImpl)

public:

	typedef IVsENCRebuildableProjectCfg2 Interface;

	STDMETHOD(StartDebuggingPE)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnterBreakStateOnPE)(
		/*[in]*/ ENC_BREAKSTATE_REASON /*encBreakReason*/,
		/*[in]*/ ENC_ACTIVE_STATEMENT* /*pActiveStatements*/,
		/*[in]*/ UINT32 /*cActiveStatements*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(BuildForEnc)(
		/*[in]*/ IUnknown* /*pUpdatePE*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ExitBreakStateOnPE)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(StopDebuggingPE)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetENCBuildState)(
		/*[out]*/ ENC_BUILD_STATE* /*pENCBuildState*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCurrentActiveStatementPosition)(
		/*[in]*/ UINT32 /*id*/,
		/*[out]*/ TextSpan* /*ptsNewPosition*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPEidentity)(
		/*[out]*/ GUID* /*pMVID*/,
		/*[out]*/ BSTR* /*pbstrPEName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExceptionSpanCount)(
		/*[out]*/ UINT32* /*pcExceptionSpan*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExceptionSpans)(
		/*[in]*/ UINT32 /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ ENC_EXCEPTION_SPAN* /*rgelt*/,
		/*[in,out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCurrentExceptionSpanPosition)(
		/*[in]*/ UINT32 /*id*/,
		/*[out]*/ TextSpan* /*ptsNewPosition*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EncApplySucceeded)(
		/*[in]*/ HRESULT /*hrApplyResult*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPEBuildTimeStamp)(
		/*[in,out]*/ FILETIME* /*pTimeStamp*/)VSL_STDMETHOD_NOTIMPL
};

class IVsENCRebuildableProjectCfg2MockImpl :
	public IVsENCRebuildableProjectCfg2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsENCRebuildableProjectCfg2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsENCRebuildableProjectCfg2MockImpl)

	typedef IVsENCRebuildableProjectCfg2 Interface;
	struct StartDebuggingPEValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(StartDebuggingPE)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(StartDebuggingPE)

		VSL_RETURN_VALIDVALUES();
	}
	struct EnterBreakStateOnPEValidValues
	{
		/*[in]*/ ENC_BREAKSTATE_REASON encBreakReason;
		/*[in]*/ ENC_ACTIVE_STATEMENT* pActiveStatements;
		/*[in]*/ UINT32 cActiveStatements;
		HRESULT retValue;
	};

	STDMETHOD(EnterBreakStateOnPE)(
		/*[in]*/ ENC_BREAKSTATE_REASON encBreakReason,
		/*[in]*/ ENC_ACTIVE_STATEMENT* pActiveStatements,
		/*[in]*/ UINT32 cActiveStatements)
	{
		VSL_DEFINE_MOCK_METHOD(EnterBreakStateOnPE)

		VSL_CHECK_VALIDVALUE(encBreakReason);

		VSL_CHECK_VALIDVALUE_POINTER(pActiveStatements);

		VSL_CHECK_VALIDVALUE(cActiveStatements);

		VSL_RETURN_VALIDVALUES();
	}
	struct BuildForEncValidValues
	{
		/*[in]*/ IUnknown* pUpdatePE;
		HRESULT retValue;
	};

	STDMETHOD(BuildForEnc)(
		/*[in]*/ IUnknown* pUpdatePE)
	{
		VSL_DEFINE_MOCK_METHOD(BuildForEnc)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUpdatePE);

		VSL_RETURN_VALIDVALUES();
	}
	struct ExitBreakStateOnPEValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ExitBreakStateOnPE)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ExitBreakStateOnPE)

		VSL_RETURN_VALIDVALUES();
	}
	struct StopDebuggingPEValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(StopDebuggingPE)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(StopDebuggingPE)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetENCBuildStateValidValues
	{
		/*[out]*/ ENC_BUILD_STATE* pENCBuildState;
		HRESULT retValue;
	};

	STDMETHOD(GetENCBuildState)(
		/*[out]*/ ENC_BUILD_STATE* pENCBuildState)
	{
		VSL_DEFINE_MOCK_METHOD(GetENCBuildState)

		VSL_SET_VALIDVALUE(pENCBuildState);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCurrentActiveStatementPositionValidValues
	{
		/*[in]*/ UINT32 id;
		/*[out]*/ TextSpan* ptsNewPosition;
		HRESULT retValue;
	};

	STDMETHOD(GetCurrentActiveStatementPosition)(
		/*[in]*/ UINT32 id,
		/*[out]*/ TextSpan* ptsNewPosition)
	{
		VSL_DEFINE_MOCK_METHOD(GetCurrentActiveStatementPosition)

		VSL_CHECK_VALIDVALUE(id);

		VSL_SET_VALIDVALUE(ptsNewPosition);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPEidentityValidValues
	{
		/*[out]*/ GUID* pMVID;
		/*[out]*/ BSTR* pbstrPEName;
		HRESULT retValue;
	};

	STDMETHOD(GetPEidentity)(
		/*[out]*/ GUID* pMVID,
		/*[out]*/ BSTR* pbstrPEName)
	{
		VSL_DEFINE_MOCK_METHOD(GetPEidentity)

		VSL_SET_VALIDVALUE(pMVID);

		VSL_SET_VALIDVALUE_BSTR(pbstrPEName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExceptionSpanCountValidValues
	{
		/*[out]*/ UINT32* pcExceptionSpan;
		HRESULT retValue;
	};

	STDMETHOD(GetExceptionSpanCount)(
		/*[out]*/ UINT32* pcExceptionSpan)
	{
		VSL_DEFINE_MOCK_METHOD(GetExceptionSpanCount)

		VSL_SET_VALIDVALUE(pcExceptionSpan);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExceptionSpansValidValues
	{
		/*[in]*/ UINT32 celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ ENC_EXCEPTION_SPAN* rgelt;
		/*[in,out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(GetExceptionSpans)(
		/*[in]*/ UINT32 celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ ENC_EXCEPTION_SPAN* rgelt,
		/*[in,out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(GetExceptionSpans)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(rgelt, celt*sizeof(rgelt[0]), *(validValues.pceltFetched)*sizeof(validValues.rgelt[0]));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCurrentExceptionSpanPositionValidValues
	{
		/*[in]*/ UINT32 id;
		/*[out]*/ TextSpan* ptsNewPosition;
		HRESULT retValue;
	};

	STDMETHOD(GetCurrentExceptionSpanPosition)(
		/*[in]*/ UINT32 id,
		/*[out]*/ TextSpan* ptsNewPosition)
	{
		VSL_DEFINE_MOCK_METHOD(GetCurrentExceptionSpanPosition)

		VSL_CHECK_VALIDVALUE(id);

		VSL_SET_VALIDVALUE(ptsNewPosition);

		VSL_RETURN_VALIDVALUES();
	}
	struct EncApplySucceededValidValues
	{
		/*[in]*/ HRESULT hrApplyResult;
		HRESULT retValue;
	};

	STDMETHOD(EncApplySucceeded)(
		/*[in]*/ HRESULT hrApplyResult)
	{
		VSL_DEFINE_MOCK_METHOD(EncApplySucceeded)

		VSL_CHECK_VALIDVALUE(hrApplyResult);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPEBuildTimeStampValidValues
	{
		/*[in,out]*/ FILETIME* pTimeStamp;
		HRESULT retValue;
	};

	STDMETHOD(GetPEBuildTimeStamp)(
		/*[in,out]*/ FILETIME* pTimeStamp)
	{
		VSL_DEFINE_MOCK_METHOD(GetPEBuildTimeStamp)

		VSL_SET_VALIDVALUE(pTimeStamp);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSENCREBUILDABLEPROJECTCFG2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsENCRebuildableProjectCfg.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSENCREBUILDABLEPROJECTCFG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSENCREBUILDABLEPROJECTCFG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "encbuild.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsENCRebuildableProjectCfgNotImpl :
	public IVsENCRebuildableProjectCfg
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsENCRebuildableProjectCfgNotImpl)

public:

	typedef IVsENCRebuildableProjectCfg Interface;

	STDMETHOD(ENCRebuild)(
		/*[in]*/ IUnknown* /*in_pProgram*/,
		/*[out]*/ IUnknown** /*out_ppSnapshot*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CancelENC)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ENCRelink)(
		/*[in]*/ IUnknown* /*pENCRelinkInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(StartDebugging)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(StopDebugging)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(BelongToProject)(
		/*[in]*/ LPCOLESTR /*in_szFileName*/,
		/*[in]*/ ENC_REASON /*in_ENCReason*/,
		/*[in]*/ BOOL /*in_fOnContinue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetENCProjectBuildOption)(
		/*[in]*/ REFGUID /*in_guidOption*/,
		/*[in]*/ LPCOLESTR /*in_szOptionValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ENCComplete)(
		/*[in]*/ BOOL /*in_fENCSuccess*/)VSL_STDMETHOD_NOTIMPL
};

class IVsENCRebuildableProjectCfgMockImpl :
	public IVsENCRebuildableProjectCfg,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsENCRebuildableProjectCfgMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsENCRebuildableProjectCfgMockImpl)

	typedef IVsENCRebuildableProjectCfg Interface;
	struct ENCRebuildValidValues
	{
		/*[in]*/ IUnknown* in_pProgram;
		/*[out]*/ IUnknown** out_ppSnapshot;
		HRESULT retValue;
	};

	STDMETHOD(ENCRebuild)(
		/*[in]*/ IUnknown* in_pProgram,
		/*[out]*/ IUnknown** out_ppSnapshot)
	{
		VSL_DEFINE_MOCK_METHOD(ENCRebuild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(in_pProgram);

		VSL_SET_VALIDVALUE_INTERFACE(out_ppSnapshot);

		VSL_RETURN_VALIDVALUES();
	}
	struct CancelENCValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CancelENC)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CancelENC)

		VSL_RETURN_VALIDVALUES();
	}
	struct ENCRelinkValidValues
	{
		/*[in]*/ IUnknown* pENCRelinkInfo;
		HRESULT retValue;
	};

	STDMETHOD(ENCRelink)(
		/*[in]*/ IUnknown* pENCRelinkInfo)
	{
		VSL_DEFINE_MOCK_METHOD(ENCRelink)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pENCRelinkInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct StartDebuggingValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(StartDebugging)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(StartDebugging)

		VSL_RETURN_VALIDVALUES();
	}
	struct StopDebuggingValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(StopDebugging)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(StopDebugging)

		VSL_RETURN_VALIDVALUES();
	}
	struct BelongToProjectValidValues
	{
		/*[in]*/ LPCOLESTR in_szFileName;
		/*[in]*/ ENC_REASON in_ENCReason;
		/*[in]*/ BOOL in_fOnContinue;
		HRESULT retValue;
	};

	STDMETHOD(BelongToProject)(
		/*[in]*/ LPCOLESTR in_szFileName,
		/*[in]*/ ENC_REASON in_ENCReason,
		/*[in]*/ BOOL in_fOnContinue)
	{
		VSL_DEFINE_MOCK_METHOD(BelongToProject)

		VSL_CHECK_VALIDVALUE_STRINGW(in_szFileName);

		VSL_CHECK_VALIDVALUE(in_ENCReason);

		VSL_CHECK_VALIDVALUE(in_fOnContinue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetENCProjectBuildOptionValidValues
	{
		/*[in]*/ REFGUID in_guidOption;
		/*[in]*/ LPCOLESTR in_szOptionValue;
		HRESULT retValue;
	};

	STDMETHOD(SetENCProjectBuildOption)(
		/*[in]*/ REFGUID in_guidOption,
		/*[in]*/ LPCOLESTR in_szOptionValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetENCProjectBuildOption)

		VSL_CHECK_VALIDVALUE(in_guidOption);

		VSL_CHECK_VALIDVALUE_STRINGW(in_szOptionValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct ENCCompleteValidValues
	{
		/*[in]*/ BOOL in_fENCSuccess;
		HRESULT retValue;
	};

	STDMETHOD(ENCComplete)(
		/*[in]*/ BOOL in_fENCSuccess)
	{
		VSL_DEFINE_MOCK_METHOD(ENCComplete)

		VSL_CHECK_VALIDVALUE(in_fENCSuccess);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSENCREBUILDABLEPROJECTCFG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsEnhancedDataTip.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSENHANCEDDATATIP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSENHANCEDDATATIP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsEnhancedDataTipNotImpl :
	public IVsEnhancedDataTip
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnhancedDataTipNotImpl)

public:

	typedef IVsEnhancedDataTip Interface;

	STDMETHOD(Show)(
		/*[in]*/ HWND /*hwndOwner*/,
		/*[in]*/ POINT* /*pptTopLeft*/,
		/*[in]*/ RECT* /*pHotRect*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetExpression)(
		/*[in]*/ BSTR /*bstrExpression*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBaseWindowHandle)(
		/*[out]*/ HWND* /*phwnd*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsErrorTip)(
		/*[out]*/ BOOL* /*pbIsError*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsOpen)(
		/*[out]*/ BOOL* /*pbIsOpen*/)VSL_STDMETHOD_NOTIMPL
};

class IVsEnhancedDataTipMockImpl :
	public IVsEnhancedDataTip,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnhancedDataTipMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsEnhancedDataTipMockImpl)

	typedef IVsEnhancedDataTip Interface;
	struct ShowValidValues
	{
		/*[in]*/ HWND hwndOwner;
		/*[in]*/ POINT* pptTopLeft;
		/*[in]*/ RECT* pHotRect;
		HRESULT retValue;
	};

	STDMETHOD(Show)(
		/*[in]*/ HWND hwndOwner,
		/*[in]*/ POINT* pptTopLeft,
		/*[in]*/ RECT* pHotRect)
	{
		VSL_DEFINE_MOCK_METHOD(Show)

		VSL_CHECK_VALIDVALUE(hwndOwner);

		VSL_CHECK_VALIDVALUE_POINTER(pptTopLeft);

		VSL_CHECK_VALIDVALUE_POINTER(pHotRect);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetExpressionValidValues
	{
		/*[in]*/ BSTR bstrExpression;
		HRESULT retValue;
	};

	STDMETHOD(SetExpression)(
		/*[in]*/ BSTR bstrExpression)
	{
		VSL_DEFINE_MOCK_METHOD(SetExpression)

		VSL_CHECK_VALIDVALUE_BSTR(bstrExpression);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBaseWindowHandleValidValues
	{
		/*[out]*/ HWND* phwnd;
		HRESULT retValue;
	};

	STDMETHOD(GetBaseWindowHandle)(
		/*[out]*/ HWND* phwnd)
	{
		VSL_DEFINE_MOCK_METHOD(GetBaseWindowHandle)

		VSL_SET_VALIDVALUE(phwnd);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsErrorTipValidValues
	{
		/*[out]*/ BOOL* pbIsError;
		HRESULT retValue;
	};

	STDMETHOD(IsErrorTip)(
		/*[out]*/ BOOL* pbIsError)
	{
		VSL_DEFINE_MOCK_METHOD(IsErrorTip)

		VSL_SET_VALIDVALUE(pbIsError);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsOpenValidValues
	{
		/*[out]*/ BOOL* pbIsOpen;
		HRESULT retValue;
	};

	STDMETHOD(IsOpen)(
		/*[out]*/ BOOL* pbIsOpen)
	{
		VSL_DEFINE_MOCK_METHOD(IsOpen)

		VSL_SET_VALIDVALUE(pbIsOpen);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSENHANCEDDATATIP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsDynamicTabProvider.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSDYNAMICTABPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSDYNAMICTABPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsDynamicTabProviderNotImpl :
	public IVsDynamicTabProvider
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDynamicTabProviderNotImpl)

public:

	typedef IVsDynamicTabProvider Interface;

	STDMETHOD(GetTabStopElements)(
		/*[in]*/ IVsTextLines* /*pBuffer*/,
		/*[in]*/ long /*iLine*/,
		/*[out]*/ UINT* /*cEl*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTabStop)(
		/*[in]*/ IVsTextLines* /*pBuffer*/,
		/*[in]*/ long /*iLine*/,
		/*[out]*/ TabStop* /*sTabStop*/)VSL_STDMETHOD_NOTIMPL
};

class IVsDynamicTabProviderMockImpl :
	public IVsDynamicTabProvider,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsDynamicTabProviderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsDynamicTabProviderMockImpl)

	typedef IVsDynamicTabProvider Interface;
	struct GetTabStopElementsValidValues
	{
		/*[in]*/ IVsTextLines* pBuffer;
		/*[in]*/ long iLine;
		/*[out]*/ UINT* cEl;
		HRESULT retValue;
	};

	STDMETHOD(GetTabStopElements)(
		/*[in]*/ IVsTextLines* pBuffer,
		/*[in]*/ long iLine,
		/*[out]*/ UINT* cEl)
	{
		VSL_DEFINE_MOCK_METHOD(GetTabStopElements)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_SET_VALIDVALUE(cEl);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTabStopValidValues
	{
		/*[in]*/ IVsTextLines* pBuffer;
		/*[in]*/ long iLine;
		/*[out]*/ TabStop* sTabStop;
		HRESULT retValue;
	};

	STDMETHOD(GetTabStop)(
		/*[in]*/ IVsTextLines* pBuffer,
		/*[in]*/ long iLine,
		/*[out]*/ TabStop* sTabStop)
	{
		VSL_DEFINE_MOCK_METHOD(GetTabStop)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_SET_VALIDVALUE(sTabStop);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSDYNAMICTABPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsEnumBSTR.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSENUMBSTR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSENUMBSTR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsEnumBSTRNotImpl :
	public IVsEnumBSTR
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumBSTRNotImpl)

public:

	typedef IVsEnumBSTR Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ BSTR* /*rgelt*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IVsEnumBSTR** /*ppenum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* /*pceltCount*/)VSL_STDMETHOD_NOTIMPL
};

class IVsEnumBSTRMockImpl :
	public IVsEnumBSTR,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumBSTRMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsEnumBSTRMockImpl)

	typedef IVsEnumBSTR Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ BSTR* rgelt;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ BSTR* rgelt,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(rgelt, celt*sizeof(rgelt[0]), *(validValues.pceltFetched)*sizeof(validValues.rgelt[0]));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IVsEnumBSTR** ppenum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IVsEnumBSTR** ppenum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppenum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCountValidValues
	{
		/*[out]*/ ULONG* pceltCount;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* pceltCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pceltCount);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSENUMBSTR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsEnumCodeBlocks.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSENUMCODEBLOCKS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSENUMCODEBLOCKS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "singlefileeditor.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsEnumCodeBlocksNotImpl :
	public IVsEnumCodeBlocks
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumCodeBlocksNotImpl)

public:

	typedef IVsEnumCodeBlocks Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ TextSpanAndCookie* /*rgelt*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IVsEnumCodeBlocks** /*ppenum*/)VSL_STDMETHOD_NOTIMPL
};

class IVsEnumCodeBlocksMockImpl :
	public IVsEnumCodeBlocks,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumCodeBlocksMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsEnumCodeBlocksMockImpl)

	typedef IVsEnumCodeBlocks Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ TextSpanAndCookie* rgelt;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ TextSpanAndCookie* rgelt,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(rgelt, celt*sizeof(rgelt[0]), *(validValues.pceltFetched)*sizeof(validValues.rgelt[0]));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IVsEnumCodeBlocks** ppenum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IVsEnumCodeBlocks** ppenum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppenum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSENUMCODEBLOCKS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsEnumCryptoProviderContainers.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSENUMCRYPTOPROVIDERCONTAINERS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSENUMCRYPTOPROVIDERCONTAINERS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "compsvcspkg80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsEnumCryptoProviderContainersNotImpl :
	public IVsEnumCryptoProviderContainers
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumCryptoProviderContainersNotImpl)

public:

	typedef IVsEnumCryptoProviderContainers Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ BSTR* /*pbstrContainers*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL
};

class IVsEnumCryptoProviderContainersMockImpl :
	public IVsEnumCryptoProviderContainers,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumCryptoProviderContainersMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsEnumCryptoProviderContainersMockImpl)

	typedef IVsEnumCryptoProviderContainers Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ BSTR* pbstrContainers;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ BSTR* pbstrContainers,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(pbstrContainers, celt*sizeof(pbstrContainers[0]), *(validValues.pceltFetched)*sizeof(validValues.pbstrContainers[0]));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSENUMCRYPTOPROVIDERCONTAINERS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsEnumCommentTaskTokens.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSENUMCOMMENTTASKTOKENS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSENUMCOMMENTTASKTOKENS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsEnumCommentTaskTokensNotImpl :
	public IVsEnumCommentTaskTokens
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumCommentTaskTokensNotImpl)

public:

	typedef IVsEnumCommentTaskTokens Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsCommentTaskToken** /*rgelt*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IVsEnumCommentTaskTokens** /*ppenum*/)VSL_STDMETHOD_NOTIMPL
};

class IVsEnumCommentTaskTokensMockImpl :
	public IVsEnumCommentTaskTokens,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumCommentTaskTokensMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsEnumCommentTaskTokensMockImpl)

	typedef IVsEnumCommentTaskTokens Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsCommentTaskToken** rgelt;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsCommentTaskToken** rgelt,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgelt, celt, *(validValues.pceltFetched));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IVsEnumCommentTaskTokens** ppenum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IVsEnumCommentTaskTokens** ppenum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppenum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSENUMCOMMENTTASKTOKENS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsEnumBufferCoordinatorSpans.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSENUMBUFFERCOORDINATORSPANS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSENUMBUFFERCOORDINATORSPANS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "singlefileeditor.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsEnumBufferCoordinatorSpansNotImpl :
	public IVsEnumBufferCoordinatorSpans
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumBufferCoordinatorSpansNotImpl)

public:

	typedef IVsEnumBufferCoordinatorSpans Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[in,out]*/ NewSpanMapping* /*rgelt*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IVsEnumBufferCoordinatorSpans** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL
};

class IVsEnumBufferCoordinatorSpansMockImpl :
	public IVsEnumBufferCoordinatorSpans,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumBufferCoordinatorSpansMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsEnumBufferCoordinatorSpansMockImpl)

	typedef IVsEnumBufferCoordinatorSpans Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[in,out]*/ NewSpanMapping* rgelt;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[in,out]*/ NewSpanMapping* rgelt,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE(rgelt);

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IVsEnumBufferCoordinatorSpans** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IVsEnumBufferCoordinatorSpans** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSENUMBUFFERCOORDINATORSPANS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsEnumDependencies.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSENUMDEPENDENCIES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSENUMDEPENDENCIES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsEnumDependenciesNotImpl :
	public IVsEnumDependencies
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumDependenciesNotImpl)

public:

	typedef IVsEnumDependencies Interface;

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*cElements*/,
		/*[in,out,size_is(cElements)]*/ IVsDependency*[] /*rgpIVsDependency*/,
		/*[out]*/ ULONG* /*pcElementsFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*cElements*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IVsEnumDependencies** /*ppIVsEnumDependencies*/)VSL_STDMETHOD_NOTIMPL
};

class IVsEnumDependenciesMockImpl :
	public IVsEnumDependencies,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumDependenciesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsEnumDependenciesMockImpl)

	typedef IVsEnumDependencies Interface;
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct NextValidValues
	{
		/*[in]*/ ULONG cElements;
		/*[in,out,size_is(cElements)]*/ IVsDependency** rgpIVsDependency;
		/*[out]*/ ULONG* pcElementsFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG cElements,
		/*[in,out,size_is(cElements)]*/ IVsDependency* rgpIVsDependency[],
		/*[out]*/ ULONG* pcElementsFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(cElements);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgpIVsDependency, cElements, validValues.cElements);

		VSL_SET_VALIDVALUE(pcElementsFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG cElements;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG cElements)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(cElements);

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IVsEnumDependencies** ppIVsEnumDependencies;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IVsEnumDependencies** ppIVsEnumDependencies)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsEnumDependencies);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSENUMDEPENDENCIES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsEnumDebugName.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSENUMDEBUGNAME_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSENUMDEBUGNAME_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsEnumDebugNameNotImpl :
	public IVsEnumDebugName
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumDebugNameNotImpl)

public:

	typedef IVsEnumDebugName Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsDebugName** /*rgelt*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IVsEnumDebugName** /*ppenum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* /*pceltCount*/)VSL_STDMETHOD_NOTIMPL
};

class IVsEnumDebugNameMockImpl :
	public IVsEnumDebugName,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumDebugNameMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsEnumDebugNameMockImpl)

	typedef IVsEnumDebugName Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsDebugName** rgelt;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsDebugName** rgelt,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgelt, celt, *(validValues.pceltFetched));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IVsEnumDebugName** ppenum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IVsEnumDebugName** ppenum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppenum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCountValidValues
	{
		/*[out]*/ ULONG* pceltCount;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* pceltCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pceltCount);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSENUMDEBUGNAME_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsEnumExternalErrors.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSENUMEXTERNALERRORS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSENUMEXTERNALERRORS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "singlefileeditor.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsEnumExternalErrorsNotImpl :
	public IVsEnumExternalErrors
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumExternalErrorsNotImpl)

public:

	typedef IVsEnumExternalErrors Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[in,out]*/ ExternalError* /*rgelt*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celts*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IVsEnumExternalErrors** /*ppErrors*/)VSL_STDMETHOD_NOTIMPL
};

class IVsEnumExternalErrorsMockImpl :
	public IVsEnumExternalErrors,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumExternalErrorsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsEnumExternalErrorsMockImpl)

	typedef IVsEnumExternalErrors Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[in,out]*/ ExternalError* rgelt;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[in,out]*/ ExternalError* rgelt,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE(rgelt);

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celts;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celts)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celts);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IVsEnumExternalErrors** ppErrors;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IVsEnumExternalErrors** ppErrors)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppErrors);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSENUMEXTERNALERRORS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsEnumCryptoProviders.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSENUMCRYPTOPROVIDERS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSENUMCRYPTOPROVIDERS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "compsvcspkg80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsEnumCryptoProvidersNotImpl :
	public IVsEnumCryptoProviders
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumCryptoProvidersNotImpl)

public:

	typedef IVsEnumCryptoProviders Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ BSTR* /*pbstrProviders*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL
};

class IVsEnumCryptoProvidersMockImpl :
	public IVsEnumCryptoProviders,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumCryptoProvidersMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsEnumCryptoProvidersMockImpl)

	typedef IVsEnumCryptoProviders Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ BSTR* pbstrProviders;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ BSTR* pbstrProviders,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(pbstrProviders, celt*sizeof(pbstrProviders[0]), *(validValues.pceltFetched)*sizeof(validValues.pbstrProviders[0]));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSENUMCRYPTOPROVIDERS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsEnumLibraries2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSENUMLIBRARIES2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSENUMLIBRARIES2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsEnumLibraries2NotImpl :
	public IVsEnumLibraries2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumLibraries2NotImpl)

public:

	typedef IVsEnumLibraries2 Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsLibrary2** /*rgelt*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IVsEnumLibraries2** /*ppenum*/)VSL_STDMETHOD_NOTIMPL
};

class IVsEnumLibraries2MockImpl :
	public IVsEnumLibraries2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumLibraries2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsEnumLibraries2MockImpl)

	typedef IVsEnumLibraries2 Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsLibrary2** rgelt;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsLibrary2** rgelt,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgelt, celt, *(validValues.pceltFetched));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IVsEnumLibraries2** ppenum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IVsEnumLibraries2** ppenum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppenum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSENUMLIBRARIES2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsEnumIndependentViews.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSENUMINDEPENDENTVIEWS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSENUMINDEPENDENTVIEWS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsEnumIndependentViewsNotImpl :
	public IVsEnumIndependentViews
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumIndependentViewsNotImpl)

public:

	typedef IVsEnumIndependentViews Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IUnknown** /*rgelt*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCount)(
		/*[in]*/ ULONG* /*pCount*/)VSL_STDMETHOD_NOTIMPL
};

class IVsEnumIndependentViewsMockImpl :
	public IVsEnumIndependentViews,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumIndependentViewsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsEnumIndependentViewsMockImpl)

	typedef IVsEnumIndependentViews Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IUnknown** rgelt;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IUnknown** rgelt,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgelt, celt, *(validValues.pceltFetched));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCountValidValues
	{
		/*[in]*/ ULONG* pCount;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[in]*/ ULONG* pCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_CHECK_VALIDVALUE_POINTER(pCount);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSENUMINDEPENDENTVIEWS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsEnumHiddenRegions.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSENUMHIDDENREGIONS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSENUMHIDDENREGIONS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsEnumHiddenRegionsNotImpl :
	public IVsEnumHiddenRegions
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumHiddenRegionsNotImpl)

public:

	typedef IVsEnumHiddenRegions Interface;

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*cEl*/,
		/*[out,size_is(cEl)]*/ IVsHiddenRegion** /*ppOut*/,
		/*[out]*/ ULONG* /*pcElFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* /*pcRegions*/)VSL_STDMETHOD_NOTIMPL
};

class IVsEnumHiddenRegionsMockImpl :
	public IVsEnumHiddenRegions,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumHiddenRegionsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsEnumHiddenRegionsMockImpl)

	typedef IVsEnumHiddenRegions Interface;
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct NextValidValues
	{
		/*[in]*/ ULONG cEl;
		/*[out,size_is(cEl)]*/ IVsHiddenRegion** ppOut;
		/*[out]*/ ULONG* pcElFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG cEl,
		/*[out,size_is(cEl)]*/ IVsHiddenRegion** ppOut,
		/*[out]*/ ULONG* pcElFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(cEl);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(ppOut, cEl, validValues.cEl);

		VSL_SET_VALIDVALUE(pcElFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCountValidValues
	{
		/*[out]*/ ULONG* pcRegions;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* pcRegions)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pcRegions);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSENUMHIDDENREGIONS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsEnumNavInfoNodes.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSENUMNAVINFONODES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSENUMNAVINFONODES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsEnumNavInfoNodesNotImpl :
	public IVsEnumNavInfoNodes
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumNavInfoNodesNotImpl)

public:

	typedef IVsEnumNavInfoNodes Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsNavInfoNode** /*rgelt*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IVsEnumNavInfoNodes** /*ppenum*/)VSL_STDMETHOD_NOTIMPL
};

class IVsEnumNavInfoNodesMockImpl :
	public IVsEnumNavInfoNodes,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumNavInfoNodesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsEnumNavInfoNodesMockImpl)

	typedef IVsEnumNavInfoNodes Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsNavInfoNode** rgelt;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsNavInfoNode** rgelt,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgelt, celt, *(validValues.pceltFetched));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IVsEnumNavInfoNodes** ppenum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IVsEnumNavInfoNodes** ppenum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppenum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSENUMNAVINFONODES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsEnumLayerMarkers.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSENUMLAYERMARKERS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSENUMLAYERMARKERS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsEnumLayerMarkersNotImpl :
	public IVsEnumLayerMarkers
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumLayerMarkersNotImpl)

public:

	typedef IVsEnumLayerMarkers Interface;

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Next)(
		/*[out]*/ IVsTextLayerMarker** /*ppRetval*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCount)(
		/*[out]*/ long* /*pcMarkers*/)VSL_STDMETHOD_NOTIMPL
};

class IVsEnumLayerMarkersMockImpl :
	public IVsEnumLayerMarkers,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumLayerMarkersMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsEnumLayerMarkersMockImpl)

	typedef IVsEnumLayerMarkers Interface;
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct NextValidValues
	{
		/*[out]*/ IVsTextLayerMarker** ppRetval;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[out]*/ IVsTextLayerMarker** ppRetval)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_SET_VALIDVALUE_INTERFACE(ppRetval);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCountValidValues
	{
		/*[out]*/ long* pcMarkers;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out]*/ long* pcMarkers)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pcMarkers);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSENUMLAYERMARKERS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsEnumGUID.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSENUMGUID_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSENUMGUID_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsEnumGUIDNotImpl :
	public IVsEnumGUID
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumGUIDNotImpl)

public:

	typedef IVsEnumGUID Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ GUID* /*rgelt*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IVsEnumGUID** /*ppenum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* /*pceltCount*/)VSL_STDMETHOD_NOTIMPL
};

class IVsEnumGUIDMockImpl :
	public IVsEnumGUID,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumGUIDMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsEnumGUIDMockImpl)

	typedef IVsEnumGUID Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ GUID* rgelt;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ GUID* rgelt,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(rgelt, celt*sizeof(rgelt[0]), *(validValues.pceltFetched)*sizeof(validValues.rgelt[0]));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IVsEnumGUID** ppenum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IVsEnumGUID** ppenum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppenum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCountValidValues
	{
		/*[out]*/ ULONG* pceltCount;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* pceltCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pceltCount);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSENUMGUID_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsEnumHierarchyItemsFactory.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSENUMHIERARCHYITEMSFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSENUMHIERARCHYITEMSFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsEnumHierarchyItemsFactoryNotImpl :
	public IVsEnumHierarchyItemsFactory
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumHierarchyItemsFactoryNotImpl)

public:

	typedef IVsEnumHierarchyItemsFactory Interface;

	STDMETHOD(EnumHierarchyItems)(
		/*[in]*/ IVsHierarchy* /*pHierRoot*/,
		/*[in]*/ VSEHI /*grfItems*/,
		/*[in]*/ VSITEMID /*itemidRoot*/,
		/*[out]*/ IEnumHierarchyItems** /*ppenum*/)VSL_STDMETHOD_NOTIMPL
};

class IVsEnumHierarchyItemsFactoryMockImpl :
	public IVsEnumHierarchyItemsFactory,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumHierarchyItemsFactoryMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsEnumHierarchyItemsFactoryMockImpl)

	typedef IVsEnumHierarchyItemsFactory Interface;
	struct EnumHierarchyItemsValidValues
	{
		/*[in]*/ IVsHierarchy* pHierRoot;
		/*[in]*/ VSEHI grfItems;
		/*[in]*/ VSITEMID itemidRoot;
		/*[out]*/ IEnumHierarchyItems** ppenum;
		HRESULT retValue;
	};

	STDMETHOD(EnumHierarchyItems)(
		/*[in]*/ IVsHierarchy* pHierRoot,
		/*[in]*/ VSEHI grfItems,
		/*[in]*/ VSITEMID itemidRoot,
		/*[out]*/ IEnumHierarchyItems** ppenum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumHierarchyItems)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierRoot);

		VSL_CHECK_VALIDVALUE(grfItems);

		VSL_CHECK_VALIDVALUE(itemidRoot);

		VSL_SET_VALIDVALUE_INTERFACE(ppenum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSENUMHIERARCHYITEMSFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsEnumLineMarkers.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSENUMLINEMARKERS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSENUMLINEMARKERS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsEnumLineMarkersNotImpl :
	public IVsEnumLineMarkers
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumLineMarkersNotImpl)

public:

	typedef IVsEnumLineMarkers Interface;

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Next)(
		/*[out,retval]*/ IVsTextLineMarker** /*ppRetval*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCount)(
		/*[out]*/ long* /*pcMarkers*/)VSL_STDMETHOD_NOTIMPL
};

class IVsEnumLineMarkersMockImpl :
	public IVsEnumLineMarkers,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumLineMarkersMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsEnumLineMarkersMockImpl)

	typedef IVsEnumLineMarkers Interface;
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct NextValidValues
	{
		/*[out,retval]*/ IVsTextLineMarker** ppRetval;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[out,retval]*/ IVsTextLineMarker** ppRetval)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_SET_VALIDVALUE_INTERFACE(ppRetval);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCountValidValues
	{
		/*[out]*/ long* pcMarkers;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out]*/ long* pcMarkers)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pcMarkers);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSENUMLINEMARKERS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsEnumSelectedSymbols.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSENUMSELECTEDSYMBOLS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSENUMSELECTEDSYMBOLS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsEnumSelectedSymbolsNotImpl :
	public IVsEnumSelectedSymbols
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumSelectedSymbolsNotImpl)

public:

	typedef IVsEnumSelectedSymbols Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsSelectedSymbol** /*rgpIVsSelectedSymbol*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IVsEnumSelectedSymbols** /*ppIVsEnumSelectedSymbols*/)VSL_STDMETHOD_NOTIMPL
};

class IVsEnumSelectedSymbolsMockImpl :
	public IVsEnumSelectedSymbols,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumSelectedSymbolsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsEnumSelectedSymbolsMockImpl)

	typedef IVsEnumSelectedSymbols Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsSelectedSymbol** rgpIVsSelectedSymbol;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsSelectedSymbol** rgpIVsSelectedSymbol,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgpIVsSelectedSymbol, celt, *(validValues.pceltFetched));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IVsEnumSelectedSymbols** ppIVsEnumSelectedSymbols;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IVsEnumSelectedSymbols** ppIVsEnumSelectedSymbols)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsEnumSelectedSymbols);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSENUMSELECTEDSYMBOLS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsEnumStreamMarkers.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSENUMSTREAMMARKERS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSENUMSTREAMMARKERS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsEnumStreamMarkersNotImpl :
	public IVsEnumStreamMarkers
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumStreamMarkersNotImpl)

public:

	typedef IVsEnumStreamMarkers Interface;

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Next)(
		/*[out,retval]*/ IVsTextStreamMarker** /*ppRetval*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCount)(
		/*[out]*/ long* /*pcMarkers*/)VSL_STDMETHOD_NOTIMPL
};

class IVsEnumStreamMarkersMockImpl :
	public IVsEnumStreamMarkers,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumStreamMarkersMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsEnumStreamMarkersMockImpl)

	typedef IVsEnumStreamMarkers Interface;
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct NextValidValues
	{
		/*[out,retval]*/ IVsTextStreamMarker** ppRetval;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[out,retval]*/ IVsTextStreamMarker** ppRetval)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_SET_VALIDVALUE_INTERFACE(ppRetval);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCountValidValues
	{
		/*[out]*/ long* pcMarkers;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out]*/ long* pcMarkers)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pcMarkers);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSENUMSTREAMMARKERS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsEnumOutputs.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSENUMOUTPUTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSENUMOUTPUTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsEnumOutputsNotImpl :
	public IVsEnumOutputs
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumOutputsNotImpl)

public:

	typedef IVsEnumOutputs Interface;

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*cElements*/,
		/*[in,out,size_is(cElements)]*/ IVsOutput*[] /*rgpIVsOutput*/,
		/*[out,optional]*/ ULONG* /*pcElementsFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*cElements*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IVsEnumOutputs** /*ppIVsEnumOutputs*/)VSL_STDMETHOD_NOTIMPL
};

class IVsEnumOutputsMockImpl :
	public IVsEnumOutputs,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumOutputsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsEnumOutputsMockImpl)

	typedef IVsEnumOutputs Interface;
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct NextValidValues
	{
		/*[in]*/ ULONG cElements;
		/*[in,out,size_is(cElements)]*/ IVsOutput** rgpIVsOutput;
		/*[out,optional]*/ ULONG* pcElementsFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG cElements,
		/*[in,out,size_is(cElements)]*/ IVsOutput* rgpIVsOutput[],
		/*[out,optional]*/ ULONG* pcElementsFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(cElements);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgpIVsOutput, cElements, validValues.cElements);

		VSL_SET_VALIDVALUE(pcElementsFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG cElements;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG cElements)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(cElements);

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IVsEnumOutputs** ppIVsEnumOutputs;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IVsEnumOutputs** ppIVsEnumOutputs)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsEnumOutputs);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSENUMOUTPUTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsEnumTextViews.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSENUMTEXTVIEWS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSENUMTEXTVIEWS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsEnumTextViewsNotImpl :
	public IVsEnumTextViews
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumTextViewsNotImpl)

public:

	typedef IVsEnumTextViews Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsTextView** /*rgelt*/,
		/*[in]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCount)(
		/*[in]*/ ULONG* /*pCount*/)VSL_STDMETHOD_NOTIMPL
};

class IVsEnumTextViewsMockImpl :
	public IVsEnumTextViews,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumTextViewsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsEnumTextViewsMockImpl)

	typedef IVsEnumTextViews Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsTextView** rgelt;
		/*[in]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsTextView** rgelt,
		/*[in]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgelt, celt, *(validValues.pceltFetched));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCountValidValues
	{
		/*[in]*/ ULONG* pCount;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[in]*/ ULONG* pCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_CHECK_VALIDVALUE_POINTER(pCount);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSENUMTEXTVIEWS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsEnumSyntheticRegions.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSENUMSYNTHETICREGIONS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSENUMSYNTHETICREGIONS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsEnumSyntheticRegionsNotImpl :
	public IVsEnumSyntheticRegions
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumSyntheticRegionsNotImpl)

public:

	typedef IVsEnumSyntheticRegions Interface;

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*cEl*/,
		/*[out,size_is(cEl)]*/ IVsSyntheticRegion** /*ppOut*/,
		/*[out]*/ ULONG* /*pcElFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* /*pcRegions*/)VSL_STDMETHOD_NOTIMPL
};

class IVsEnumSyntheticRegionsMockImpl :
	public IVsEnumSyntheticRegions,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumSyntheticRegionsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsEnumSyntheticRegionsMockImpl)

	typedef IVsEnumSyntheticRegions Interface;
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct NextValidValues
	{
		/*[in]*/ ULONG cEl;
		/*[out,size_is(cEl)]*/ IVsSyntheticRegion** ppOut;
		/*[out]*/ ULONG* pcElFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG cEl,
		/*[out,size_is(cEl)]*/ IVsSyntheticRegion** ppOut,
		/*[out]*/ ULONG* pcElFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(cEl);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(ppOut, cEl, validValues.cEl);

		VSL_SET_VALIDVALUE(pcElFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCountValidValues
	{
		/*[out]*/ ULONG* pcRegions;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* pcRegions)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pcRegions);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSENUMSYNTHETICREGIONS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsEnumTaskItems.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSENUMTASKITEMS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSENUMTASKITEMS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsEnumTaskItemsNotImpl :
	public IVsEnumTaskItems
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumTaskItemsNotImpl)

public:

	typedef IVsEnumTaskItems Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsTaskItem** /*rgelt*/,
		/*[out,optional]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[out]*/ IVsEnumTaskItems** /*ppenum*/)VSL_STDMETHOD_NOTIMPL
};

class IVsEnumTaskItemsMockImpl :
	public IVsEnumTaskItems,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumTaskItemsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsEnumTaskItemsMockImpl)

	typedef IVsEnumTaskItems Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsTaskItem** rgelt;
		/*[out,optional]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsTaskItem** rgelt,
		/*[out,optional]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgelt, celt, *(validValues.pceltFetched));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[out]*/ IVsEnumTaskItems** ppenum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[out]*/ IVsEnumTaskItems** ppenum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_SET_VALIDVALUE_INTERFACE(ppenum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSENUMTASKITEMS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsEnumTextBuffers.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSENUMTEXTBUFFERS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSENUMTEXTBUFFERS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsEnumTextBuffersNotImpl :
	public IVsEnumTextBuffers
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumTextBuffersNotImpl)

public:

	typedef IVsEnumTextBuffers Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsTextBuffer** /*rgelt*/,
		/*[in]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Skip)(
		/*[in]*/ ULONG /*celt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clone)(
		/*[in]*/ IVsEnumTextBuffers** /*ppenum*/)VSL_STDMETHOD_NOTIMPL
};

class IVsEnumTextBuffersMockImpl :
	public IVsEnumTextBuffers,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumTextBuffersMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsEnumTextBuffersMockImpl)

	typedef IVsEnumTextBuffers Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsTextBuffer** rgelt;
		/*[in]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ IVsTextBuffer** rgelt,
		/*[in]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgelt, celt, *(validValues.pceltFetched));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipValidValues
	{
		/*[in]*/ ULONG celt;
		HRESULT retValue;
	};

	STDMETHOD(Skip)(
		/*[in]*/ ULONG celt)
	{
		VSL_DEFINE_MOCK_METHOD(Skip)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneValidValues
	{
		/*[in]*/ IVsEnumTextBuffers** ppenum;
		HRESULT retValue;
	};

	STDMETHOD(Clone)(
		/*[in]*/ IVsEnumTextBuffers** ppenum)
	{
		VSL_DEFINE_MOCK_METHOD(Clone)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(ppenum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSENUMTEXTBUFFERS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsEnumTextSpans.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSENUMTEXTSPANS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSENUMTEXTSPANS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsEnumTextSpansNotImpl :
	public IVsEnumTextSpans
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumTextSpansNotImpl)

public:

	typedef IVsEnumTextSpans Interface;

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*cEl*/,
		/*[out,size_is(cEl)]*/ TextSpan* /*ppOut*/,
		/*[out]*/ ULONG* /*pcElFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* /*pcSpans*/)VSL_STDMETHOD_NOTIMPL
};

class IVsEnumTextSpansMockImpl :
	public IVsEnumTextSpans,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsEnumTextSpansMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsEnumTextSpansMockImpl)

	typedef IVsEnumTextSpans Interface;
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct NextValidValues
	{
		/*[in]*/ ULONG cEl;
		/*[out,size_is(cEl)]*/ TextSpan* ppOut;
		/*[out]*/ ULONG* pcElFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG cEl,
		/*[out,size_is(cEl)]*/ TextSpan* ppOut,
		/*[out]*/ ULONG* pcElFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(cEl);

		VSL_SET_VALIDVALUE_MEMCPY(ppOut, cEl*sizeof(ppOut[0]), validValues.cEl*sizeof(validValues.ppOut[0]));

		VSL_SET_VALIDVALUE(pcElFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCountValidValues
	{
		/*[out]*/ ULONG* pcSpans;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* pcSpans)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pcSpans);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSENUMTEXTSPANS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsExpansion.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSEXPANSION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSEXPANSION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsExpansionNotImpl :
	public IVsExpansion
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsExpansionNotImpl)

public:

	typedef IVsExpansion Interface;

	STDMETHOD(InsertExpansion)(
		/*[in]*/ TextSpan /*tsContext*/,
		/*[in]*/ TextSpan /*tsInsertPos*/,
		/*[in]*/ IVsExpansionClient* /*pExpansionClient*/,
		/*[in]*/ GUID /*guidLang*/,
		/*[out]*/ IVsExpansionSession** /*pSession*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(InsertNamedExpansion)(
		/*[in]*/ BSTR /*bstrTitle*/,
		/*[in]*/ BSTR /*bstrPath*/,
		/*[in]*/ TextSpan /*tsInsertPos*/,
		/*[in]*/ IVsExpansionClient* /*pExpansionClient*/,
		/*[in]*/ GUID /*guidLang*/,
		/*[in]*/ BOOL /*fShowDisambiguationUI*/,
		/*[out]*/ IVsExpansionSession** /*pSession*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(InsertSpecificExpansion)(
		/*[in]*/ IXMLDOMNode* /*pSnippet*/,
		/*[in]*/ TextSpan /*tsInsertPos*/,
		/*[in]*/ IVsExpansionClient* /*pExpansionClient*/,
		/*[in]*/ GUID /*guidLang*/,
		/*[in]*/ BSTR /*pszRelativePath*/,
		/*[out]*/ IVsExpansionSession** /*pSession*/)VSL_STDMETHOD_NOTIMPL
};

class IVsExpansionMockImpl :
	public IVsExpansion,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsExpansionMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsExpansionMockImpl)

	typedef IVsExpansion Interface;
	struct InsertExpansionValidValues
	{
		/*[in]*/ TextSpan tsContext;
		/*[in]*/ TextSpan tsInsertPos;
		/*[in]*/ IVsExpansionClient* pExpansionClient;
		/*[in]*/ GUID guidLang;
		/*[out]*/ IVsExpansionSession** pSession;
		HRESULT retValue;
	};

	STDMETHOD(InsertExpansion)(
		/*[in]*/ TextSpan tsContext,
		/*[in]*/ TextSpan tsInsertPos,
		/*[in]*/ IVsExpansionClient* pExpansionClient,
		/*[in]*/ GUID guidLang,
		/*[out]*/ IVsExpansionSession** pSession)
	{
		VSL_DEFINE_MOCK_METHOD(InsertExpansion)

		VSL_CHECK_VALIDVALUE(tsContext);

		VSL_CHECK_VALIDVALUE(tsInsertPos);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pExpansionClient);

		VSL_CHECK_VALIDVALUE(guidLang);

		VSL_SET_VALIDVALUE_INTERFACE(pSession);

		VSL_RETURN_VALIDVALUES();
	}
	struct InsertNamedExpansionValidValues
	{
		/*[in]*/ BSTR bstrTitle;
		/*[in]*/ BSTR bstrPath;
		/*[in]*/ TextSpan tsInsertPos;
		/*[in]*/ IVsExpansionClient* pExpansionClient;
		/*[in]*/ GUID guidLang;
		/*[in]*/ BOOL fShowDisambiguationUI;
		/*[out]*/ IVsExpansionSession** pSession;
		HRESULT retValue;
	};

	STDMETHOD(InsertNamedExpansion)(
		/*[in]*/ BSTR bstrTitle,
		/*[in]*/ BSTR bstrPath,
		/*[in]*/ TextSpan tsInsertPos,
		/*[in]*/ IVsExpansionClient* pExpansionClient,
		/*[in]*/ GUID guidLang,
		/*[in]*/ BOOL fShowDisambiguationUI,
		/*[out]*/ IVsExpansionSession** pSession)
	{
		VSL_DEFINE_MOCK_METHOD(InsertNamedExpansion)

		VSL_CHECK_VALIDVALUE_BSTR(bstrTitle);

		VSL_CHECK_VALIDVALUE_BSTR(bstrPath);

		VSL_CHECK_VALIDVALUE(tsInsertPos);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pExpansionClient);

		VSL_CHECK_VALIDVALUE(guidLang);

		VSL_CHECK_VALIDVALUE(fShowDisambiguationUI);

		VSL_SET_VALIDVALUE_INTERFACE(pSession);

		VSL_RETURN_VALIDVALUES();
	}
	struct InsertSpecificExpansionValidValues
	{
		/*[in]*/ IXMLDOMNode* pSnippet;
		/*[in]*/ TextSpan tsInsertPos;
		/*[in]*/ IVsExpansionClient* pExpansionClient;
		/*[in]*/ GUID guidLang;
		/*[in]*/ BSTR pszRelativePath;
		/*[out]*/ IVsExpansionSession** pSession;
		HRESULT retValue;
	};

	STDMETHOD(InsertSpecificExpansion)(
		/*[in]*/ IXMLDOMNode* pSnippet,
		/*[in]*/ TextSpan tsInsertPos,
		/*[in]*/ IVsExpansionClient* pExpansionClient,
		/*[in]*/ GUID guidLang,
		/*[in]*/ BSTR pszRelativePath,
		/*[out]*/ IVsExpansionSession** pSession)
	{
		VSL_DEFINE_MOCK_METHOD(InsertSpecificExpansion)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSnippet);

		VSL_CHECK_VALIDVALUE(tsInsertPos);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pExpansionClient);

		VSL_CHECK_VALIDVALUE(guidLang);

		VSL_CHECK_VALIDVALUE_BSTR(pszRelativePath);

		VSL_SET_VALIDVALUE_INTERFACE(pSession);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSEXPANSION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsExpansionEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSEXPANSIONEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSEXPANSIONEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsExpansionEventsNotImpl :
	public IVsExpansionEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsExpansionEventsNotImpl)

public:

	typedef IVsExpansionEvents Interface;

	STDMETHOD(OnAfterSnippetsUpdate)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterSnippetsKeyBindingChange)(
		/*[in]*/ DWORD /*dwCmdGuid*/,
		/*[in]*/ DWORD /*dwCmdId*/,
		/*[in]*/ BOOL /*fBound*/)VSL_STDMETHOD_NOTIMPL
};

class IVsExpansionEventsMockImpl :
	public IVsExpansionEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsExpansionEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsExpansionEventsMockImpl)

	typedef IVsExpansionEvents Interface;
	struct OnAfterSnippetsUpdateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnAfterSnippetsUpdate)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnAfterSnippetsUpdate)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterSnippetsKeyBindingChangeValidValues
	{
		/*[in]*/ DWORD dwCmdGuid;
		/*[in]*/ DWORD dwCmdId;
		/*[in]*/ BOOL fBound;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterSnippetsKeyBindingChange)(
		/*[in]*/ DWORD dwCmdGuid,
		/*[in]*/ DWORD dwCmdId,
		/*[in]*/ BOOL fBound)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterSnippetsKeyBindingChange)

		VSL_CHECK_VALIDVALUE(dwCmdGuid);

		VSL_CHECK_VALIDVALUE(dwCmdId);

		VSL_CHECK_VALIDVALUE(fBound);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSEXPANSIONEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsExpansionEnumeration.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSEXPANSIONENUMERATION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSEXPANSIONENUMERATION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsExpansionEnumerationNotImpl :
	public IVsExpansionEnumeration
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsExpansionEnumerationNotImpl)

public:

	typedef IVsExpansionEnumeration Interface;

	STDMETHOD(Next)(
		/*[in]*/ ULONG /*celt*/,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ VsExpansion** /*rgelt*/,
		/*[out]*/ ULONG* /*pceltFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* /*pCount*/)VSL_STDMETHOD_NOTIMPL
};

class IVsExpansionEnumerationMockImpl :
	public IVsExpansionEnumeration,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsExpansionEnumerationMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsExpansionEnumerationMockImpl)

	typedef IVsExpansionEnumeration Interface;
	struct NextValidValues
	{
		/*[in]*/ ULONG celt;
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ VsExpansion** rgelt;
		/*[out]*/ ULONG* pceltFetched;
		HRESULT retValue;
	};

	STDMETHOD(Next)(
		/*[in]*/ ULONG celt,
		/*[out,size_is(celt),length_is(*pceltFetched)]*/ VsExpansion** rgelt,
		/*[out]*/ ULONG* pceltFetched)
	{
		VSL_DEFINE_MOCK_METHOD(Next)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(rgelt, celt*sizeof(rgelt[0]), *(validValues.pceltFetched)*sizeof(validValues.rgelt[0]));

		VSL_SET_VALIDVALUE(pceltFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCountValidValues
	{
		/*[out]*/ ULONG* pCount;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* pCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pCount);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSEXPANSIONENUMERATION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsErrorItem.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSERRORITEM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSERRORITEM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsErrorItemNotImpl :
	public IVsErrorItem
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsErrorItemNotImpl)

public:

	typedef IVsErrorItem Interface;

	STDMETHOD(GetHierarchy)(
		/*[out]*/ IVsHierarchy** /*ppProject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCategory)(
		/*[out]*/ VSERRORCATEGORY* /*pCategory*/)VSL_STDMETHOD_NOTIMPL
};

class IVsErrorItemMockImpl :
	public IVsErrorItem,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsErrorItemMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsErrorItemMockImpl)

	typedef IVsErrorItem Interface;
	struct GetHierarchyValidValues
	{
		/*[out]*/ IVsHierarchy** ppProject;
		HRESULT retValue;
	};

	STDMETHOD(GetHierarchy)(
		/*[out]*/ IVsHierarchy** ppProject)
	{
		VSL_DEFINE_MOCK_METHOD(GetHierarchy)

		VSL_SET_VALIDVALUE_INTERFACE(ppProject);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCategoryValidValues
	{
		/*[out]*/ VSERRORCATEGORY* pCategory;
		HRESULT retValue;
	};

	STDMETHOD(GetCategory)(
		/*[out]*/ VSERRORCATEGORY* pCategory)
	{
		VSL_DEFINE_MOCK_METHOD(GetCategory)

		VSL_SET_VALIDVALUE(pCategory);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSERRORITEM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsErrorList.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSERRORLIST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSERRORLIST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsErrorListNotImpl :
	public IVsErrorList
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsErrorListNotImpl)

public:

	typedef IVsErrorList Interface;

	STDMETHOD(BringToFront)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ForceShowErrors)()VSL_STDMETHOD_NOTIMPL
};

class IVsErrorListMockImpl :
	public IVsErrorList,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsErrorListMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsErrorListMockImpl)

	typedef IVsErrorList Interface;
	struct BringToFrontValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(BringToFront)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(BringToFront)

		VSL_RETURN_VALIDVALUES();
	}
	struct ForceShowErrorsValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ForceShowErrors)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ForceShowErrors)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSERRORLIST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsExpansionIntellisenseHost.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSEXPANSIONINTELLISENSEHOST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSEXPANSIONINTELLISENSEHOST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "singlefileeditor.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsExpansionIntellisenseHostNotImpl :
	public IVsExpansionIntellisenseHost
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsExpansionIntellisenseHostNotImpl)

public:

	typedef IVsExpansionIntellisenseHost Interface;

	STDMETHOD(GetTextLen)(
		/*[out]*/ long* /*iLen*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetText)(
		/*[out]*/ BSTR* /*bstrText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSelection)(
		/*[out]*/ long* /*iStart*/,
		/*[out]*/ long* /*iEnd*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetSelection)(
		/*[in]*/ long /*iStart*/,
		/*[in]*/ long /*iEnd*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetText)(
		/*[in]*/ BSTR /*bstrText*/,
		/*[in]*/ BOOL /*fReplaceAll*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCurrentLevel)(
		/*[out]*/ long* /*pLevel*/)VSL_STDMETHOD_NOTIMPL
};

class IVsExpansionIntellisenseHostMockImpl :
	public IVsExpansionIntellisenseHost,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsExpansionIntellisenseHostMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsExpansionIntellisenseHostMockImpl)

	typedef IVsExpansionIntellisenseHost Interface;
	struct GetTextLenValidValues
	{
		/*[out]*/ long* iLen;
		HRESULT retValue;
	};

	STDMETHOD(GetTextLen)(
		/*[out]*/ long* iLen)
	{
		VSL_DEFINE_MOCK_METHOD(GetTextLen)

		VSL_SET_VALIDVALUE(iLen);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTextValidValues
	{
		/*[out]*/ BSTR* bstrText;
		HRESULT retValue;
	};

	STDMETHOD(GetText)(
		/*[out]*/ BSTR* bstrText)
	{
		VSL_DEFINE_MOCK_METHOD(GetText)

		VSL_SET_VALIDVALUE_BSTR(bstrText);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSelectionValidValues
	{
		/*[out]*/ long* iStart;
		/*[out]*/ long* iEnd;
		HRESULT retValue;
	};

	STDMETHOD(GetSelection)(
		/*[out]*/ long* iStart,
		/*[out]*/ long* iEnd)
	{
		VSL_DEFINE_MOCK_METHOD(GetSelection)

		VSL_SET_VALIDVALUE(iStart);

		VSL_SET_VALIDVALUE(iEnd);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetSelectionValidValues
	{
		/*[in]*/ long iStart;
		/*[in]*/ long iEnd;
		HRESULT retValue;
	};

	STDMETHOD(SetSelection)(
		/*[in]*/ long iStart,
		/*[in]*/ long iEnd)
	{
		VSL_DEFINE_MOCK_METHOD(SetSelection)

		VSL_CHECK_VALIDVALUE(iStart);

		VSL_CHECK_VALIDVALUE(iEnd);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetTextValidValues
	{
		/*[in]*/ BSTR bstrText;
		/*[in]*/ BOOL fReplaceAll;
		HRESULT retValue;
	};

	STDMETHOD(SetText)(
		/*[in]*/ BSTR bstrText,
		/*[in]*/ BOOL fReplaceAll)
	{
		VSL_DEFINE_MOCK_METHOD(SetText)

		VSL_CHECK_VALIDVALUE_BSTR(bstrText);

		VSL_CHECK_VALIDVALUE(fReplaceAll);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCurrentLevelValidValues
	{
		/*[out]*/ long* pLevel;
		HRESULT retValue;
	};

	STDMETHOD(GetCurrentLevel)(
		/*[out]*/ long* pLevel)
	{
		VSL_DEFINE_MOCK_METHOD(GetCurrentLevel)

		VSL_SET_VALIDVALUE(pLevel);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSEXPANSIONINTELLISENSEHOST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsExpansionClient.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSEXPANSIONCLIENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSEXPANSIONCLIENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsExpansionClientNotImpl :
	public IVsExpansionClient
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsExpansionClientNotImpl)

public:

	typedef IVsExpansionClient Interface;

	STDMETHOD(GetExpansionFunction)(
		/*[in]*/ IXMLDOMNode* /*xmlFunctionNode*/,
		/*[in]*/ BSTR /*bstrFieldName*/,
		/*[out]*/ IVsExpansionFunction** /*pFunc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FormatSpan)(
		/*[in]*/ IVsTextLines* /*pBuffer*/,
		/*[in]*/ TextSpan* /*ts*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EndExpansion)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsValidType)(
		/*[in]*/ IVsTextLines* /*pBuffer*/,
		/*[in]*/ TextSpan* /*ts*/,
		/*[in,size_is(iCountTypes)]*/ BSTR* /*rgTypes*/,
		/*[in]*/ int /*iCountTypes*/,
		/*[out]*/ BOOL* /*pfIsValidType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsValidKind)(
		/*[in]*/ IVsTextLines* /*pBuffer*/,
		/*[in]*/ TextSpan* /*ts*/,
		/*[in]*/ BSTR /*bstrKind*/,
		/*[out]*/ BOOL* /*pfIsValidKind*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnBeforeInsertion)(
		/*[in]*/ IVsExpansionSession* /*pSession*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterInsertion)(
		/*[in]*/ IVsExpansionSession* /*pSession*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(PositionCaretForEditing)(
		/*[in]*/ IVsTextLines* /*pBuffer*/,
		/*[in]*/ TextSpan* /*ts*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnItemChosen)(
		/*[in]*/ BSTR /*pszTitle*/,
		/*[in]*/ BSTR /*pszPath*/)VSL_STDMETHOD_NOTIMPL
};

class IVsExpansionClientMockImpl :
	public IVsExpansionClient,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsExpansionClientMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsExpansionClientMockImpl)

	typedef IVsExpansionClient Interface;
	struct GetExpansionFunctionValidValues
	{
		/*[in]*/ IXMLDOMNode* xmlFunctionNode;
		/*[in]*/ BSTR bstrFieldName;
		/*[out]*/ IVsExpansionFunction** pFunc;
		HRESULT retValue;
	};

	STDMETHOD(GetExpansionFunction)(
		/*[in]*/ IXMLDOMNode* xmlFunctionNode,
		/*[in]*/ BSTR bstrFieldName,
		/*[out]*/ IVsExpansionFunction** pFunc)
	{
		VSL_DEFINE_MOCK_METHOD(GetExpansionFunction)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(xmlFunctionNode);

		VSL_CHECK_VALIDVALUE_BSTR(bstrFieldName);

		VSL_SET_VALIDVALUE_INTERFACE(pFunc);

		VSL_RETURN_VALIDVALUES();
	}
	struct FormatSpanValidValues
	{
		/*[in]*/ IVsTextLines* pBuffer;
		/*[in]*/ TextSpan* ts;
		HRESULT retValue;
	};

	STDMETHOD(FormatSpan)(
		/*[in]*/ IVsTextLines* pBuffer,
		/*[in]*/ TextSpan* ts)
	{
		VSL_DEFINE_MOCK_METHOD(FormatSpan)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_CHECK_VALIDVALUE_POINTER(ts);

		VSL_RETURN_VALIDVALUES();
	}
	struct EndExpansionValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(EndExpansion)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(EndExpansion)

		VSL_RETURN_VALIDVALUES();
	}
	struct IsValidTypeValidValues
	{
		/*[in]*/ IVsTextLines* pBuffer;
		/*[in]*/ TextSpan* ts;
		/*[in,size_is(iCountTypes)]*/ BSTR* rgTypes;
		/*[in]*/ int iCountTypes;
		/*[out]*/ BOOL* pfIsValidType;
		HRESULT retValue;
	};

	STDMETHOD(IsValidType)(
		/*[in]*/ IVsTextLines* pBuffer,
		/*[in]*/ TextSpan* ts,
		/*[in,size_is(iCountTypes)]*/ BSTR* rgTypes,
		/*[in]*/ int iCountTypes,
		/*[out]*/ BOOL* pfIsValidType)
	{
		VSL_DEFINE_MOCK_METHOD(IsValidType)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_CHECK_VALIDVALUE_POINTER(ts);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgTypes, iCountTypes*sizeof(rgTypes[0]), validValues.iCountTypes*sizeof(validValues.rgTypes[0]));

		VSL_CHECK_VALIDVALUE(iCountTypes);

		VSL_SET_VALIDVALUE(pfIsValidType);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsValidKindValidValues
	{
		/*[in]*/ IVsTextLines* pBuffer;
		/*[in]*/ TextSpan* ts;
		/*[in]*/ BSTR bstrKind;
		/*[out]*/ BOOL* pfIsValidKind;
		HRESULT retValue;
	};

	STDMETHOD(IsValidKind)(
		/*[in]*/ IVsTextLines* pBuffer,
		/*[in]*/ TextSpan* ts,
		/*[in]*/ BSTR bstrKind,
		/*[out]*/ BOOL* pfIsValidKind)
	{
		VSL_DEFINE_MOCK_METHOD(IsValidKind)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_CHECK_VALIDVALUE_POINTER(ts);

		VSL_CHECK_VALIDVALUE_BSTR(bstrKind);

		VSL_SET_VALIDVALUE(pfIsValidKind);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnBeforeInsertionValidValues
	{
		/*[in]*/ IVsExpansionSession* pSession;
		HRESULT retValue;
	};

	STDMETHOD(OnBeforeInsertion)(
		/*[in]*/ IVsExpansionSession* pSession)
	{
		VSL_DEFINE_MOCK_METHOD(OnBeforeInsertion)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSession);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterInsertionValidValues
	{
		/*[in]*/ IVsExpansionSession* pSession;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterInsertion)(
		/*[in]*/ IVsExpansionSession* pSession)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterInsertion)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSession);

		VSL_RETURN_VALIDVALUES();
	}
	struct PositionCaretForEditingValidValues
	{
		/*[in]*/ IVsTextLines* pBuffer;
		/*[in]*/ TextSpan* ts;
		HRESULT retValue;
	};

	STDMETHOD(PositionCaretForEditing)(
		/*[in]*/ IVsTextLines* pBuffer,
		/*[in]*/ TextSpan* ts)
	{
		VSL_DEFINE_MOCK_METHOD(PositionCaretForEditing)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_CHECK_VALIDVALUE_POINTER(ts);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnItemChosenValidValues
	{
		/*[in]*/ BSTR pszTitle;
		/*[in]*/ BSTR pszPath;
		HRESULT retValue;
	};

	STDMETHOD(OnItemChosen)(
		/*[in]*/ BSTR pszTitle,
		/*[in]*/ BSTR pszPath)
	{
		VSL_DEFINE_MOCK_METHOD(OnItemChosen)

		VSL_CHECK_VALIDVALUE_BSTR(pszTitle);

		VSL_CHECK_VALIDVALUE_BSTR(pszPath);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSEXPANSIONCLIENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsExpansionFunction.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSEXPANSIONFUNCTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSEXPANSIONFUNCTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsExpansionFunctionNotImpl :
	public IVsExpansionFunction
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsExpansionFunctionNotImpl)

public:

	typedef IVsExpansionFunction Interface;

	STDMETHOD(GetFunctionType)(
		/*[out]*/ ExpansionFunctionType* /*pFuncType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetListCount)(
		/*[out]*/ long* /*iCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetListText)(
		/*[in]*/ long /*iIndex*/,
		/*[out]*/ BSTR* /*pbstrText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDefaultValue)(
		/*[out]*/ BSTR* /*bstrValue*/,
		/*[out]*/ BOOL* /*fHasDefaultValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FieldChanged)(
		/*[in]*/ BSTR /*bstrField*/,
		/*[out]*/ BOOL* /*fRequeryFunction*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCurrentValue)(
		/*[out]*/ BSTR* /*bstrValue*/,
		/*[out]*/ BOOL* /*fHasCurrentValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReleaseFunction)()VSL_STDMETHOD_NOTIMPL
};

class IVsExpansionFunctionMockImpl :
	public IVsExpansionFunction,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsExpansionFunctionMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsExpansionFunctionMockImpl)

	typedef IVsExpansionFunction Interface;
	struct GetFunctionTypeValidValues
	{
		/*[out]*/ ExpansionFunctionType* pFuncType;
		HRESULT retValue;
	};

	STDMETHOD(GetFunctionType)(
		/*[out]*/ ExpansionFunctionType* pFuncType)
	{
		VSL_DEFINE_MOCK_METHOD(GetFunctionType)

		VSL_SET_VALIDVALUE(pFuncType);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetListCountValidValues
	{
		/*[out]*/ long* iCount;
		HRESULT retValue;
	};

	STDMETHOD(GetListCount)(
		/*[out]*/ long* iCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetListCount)

		VSL_SET_VALIDVALUE(iCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetListTextValidValues
	{
		/*[in]*/ long iIndex;
		/*[out]*/ BSTR* pbstrText;
		HRESULT retValue;
	};

	STDMETHOD(GetListText)(
		/*[in]*/ long iIndex,
		/*[out]*/ BSTR* pbstrText)
	{
		VSL_DEFINE_MOCK_METHOD(GetListText)

		VSL_CHECK_VALIDVALUE(iIndex);

		VSL_SET_VALIDVALUE_BSTR(pbstrText);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDefaultValueValidValues
	{
		/*[out]*/ BSTR* bstrValue;
		/*[out]*/ BOOL* fHasDefaultValue;
		HRESULT retValue;
	};

	STDMETHOD(GetDefaultValue)(
		/*[out]*/ BSTR* bstrValue,
		/*[out]*/ BOOL* fHasDefaultValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetDefaultValue)

		VSL_SET_VALIDVALUE_BSTR(bstrValue);

		VSL_SET_VALIDVALUE(fHasDefaultValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct FieldChangedValidValues
	{
		/*[in]*/ BSTR bstrField;
		/*[out]*/ BOOL* fRequeryFunction;
		HRESULT retValue;
	};

	STDMETHOD(FieldChanged)(
		/*[in]*/ BSTR bstrField,
		/*[out]*/ BOOL* fRequeryFunction)
	{
		VSL_DEFINE_MOCK_METHOD(FieldChanged)

		VSL_CHECK_VALIDVALUE_BSTR(bstrField);

		VSL_SET_VALIDVALUE(fRequeryFunction);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCurrentValueValidValues
	{
		/*[out]*/ BSTR* bstrValue;
		/*[out]*/ BOOL* fHasCurrentValue;
		HRESULT retValue;
	};

	STDMETHOD(GetCurrentValue)(
		/*[out]*/ BSTR* bstrValue,
		/*[out]*/ BOOL* fHasCurrentValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetCurrentValue)

		VSL_SET_VALIDVALUE_BSTR(bstrValue);

		VSL_SET_VALIDVALUE(fHasCurrentValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReleaseFunctionValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ReleaseFunction)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ReleaseFunction)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSEXPANSIONFUNCTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsExternalFilesManager.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSEXTERNALFILESMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSEXTERNALFILESMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsExternalFilesManagerNotImpl :
	public IVsExternalFilesManager
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsExternalFilesManagerNotImpl)

public:

	typedef IVsExternalFilesManager Interface;

	STDMETHOD(GetExternalFilesProject)(
		/*[out]*/ IVsProject** /*ppProject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(TransferDocument)(
		/*[in]*/ LPCOLESTR /*pszMkDocumentOld*/,
		/*[in]*/ LPCOLESTR /*pszMkDocumentNew*/,
		/*[in]*/ IVsWindowFrame* /*punkWindowFrame*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddDocument)(
		/*[in]*/ VSCREATEDOCWIN /*dwCDW*/,
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[in]*/ IUnknown* /*punkDocView*/,
		/*[in]*/ IUnknown* /*punkDocData*/,
		/*[in]*/ REFGUID /*rguidEditorType*/,
		/*[in]*/ LPCOLESTR /*pszPhysicalView*/,
		/*[in]*/ REFGUID /*rguidCmdUI*/,
		/*[in]*/ LPCOLESTR /*pszOwnerCaption*/,
		/*[in]*/ LPCOLESTR /*pszEditorCaption*/,
		/*[out]*/ BOOL* /*pfDefaultPosition*/,
		/*[out]*/ IVsWindowFrame** /*ppWindowFrame*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsVisible)(
		/*[out]*/ BOOL* /*pfVisible*/)VSL_STDMETHOD_NOTIMPL
};

class IVsExternalFilesManagerMockImpl :
	public IVsExternalFilesManager,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsExternalFilesManagerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsExternalFilesManagerMockImpl)

	typedef IVsExternalFilesManager Interface;
	struct GetExternalFilesProjectValidValues
	{
		/*[out]*/ IVsProject** ppProject;
		HRESULT retValue;
	};

	STDMETHOD(GetExternalFilesProject)(
		/*[out]*/ IVsProject** ppProject)
	{
		VSL_DEFINE_MOCK_METHOD(GetExternalFilesProject)

		VSL_SET_VALIDVALUE_INTERFACE(ppProject);

		VSL_RETURN_VALIDVALUES();
	}
	struct TransferDocumentValidValues
	{
		/*[in]*/ LPCOLESTR pszMkDocumentOld;
		/*[in]*/ LPCOLESTR pszMkDocumentNew;
		/*[in]*/ IVsWindowFrame* punkWindowFrame;
		HRESULT retValue;
	};

	STDMETHOD(TransferDocument)(
		/*[in]*/ LPCOLESTR pszMkDocumentOld,
		/*[in]*/ LPCOLESTR pszMkDocumentNew,
		/*[in]*/ IVsWindowFrame* punkWindowFrame)
	{
		VSL_DEFINE_MOCK_METHOD(TransferDocument)

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocumentOld);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocumentNew);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkWindowFrame);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddDocumentValidValues
	{
		/*[in]*/ VSCREATEDOCWIN dwCDW;
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[in]*/ IUnknown* punkDocView;
		/*[in]*/ IUnknown* punkDocData;
		/*[in]*/ REFGUID rguidEditorType;
		/*[in]*/ LPCOLESTR pszPhysicalView;
		/*[in]*/ REFGUID rguidCmdUI;
		/*[in]*/ LPCOLESTR pszOwnerCaption;
		/*[in]*/ LPCOLESTR pszEditorCaption;
		/*[out]*/ BOOL* pfDefaultPosition;
		/*[out]*/ IVsWindowFrame** ppWindowFrame;
		HRESULT retValue;
	};

	STDMETHOD(AddDocument)(
		/*[in]*/ VSCREATEDOCWIN dwCDW,
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[in]*/ IUnknown* punkDocView,
		/*[in]*/ IUnknown* punkDocData,
		/*[in]*/ REFGUID rguidEditorType,
		/*[in]*/ LPCOLESTR pszPhysicalView,
		/*[in]*/ REFGUID rguidCmdUI,
		/*[in]*/ LPCOLESTR pszOwnerCaption,
		/*[in]*/ LPCOLESTR pszEditorCaption,
		/*[out]*/ BOOL* pfDefaultPosition,
		/*[out]*/ IVsWindowFrame** ppWindowFrame)
	{
		VSL_DEFINE_MOCK_METHOD(AddDocument)

		VSL_CHECK_VALIDVALUE(dwCDW);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkDocView);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkDocData);

		VSL_CHECK_VALIDVALUE(rguidEditorType);

		VSL_CHECK_VALIDVALUE_STRINGW(pszPhysicalView);

		VSL_CHECK_VALIDVALUE(rguidCmdUI);

		VSL_CHECK_VALIDVALUE_STRINGW(pszOwnerCaption);

		VSL_CHECK_VALIDVALUE_STRINGW(pszEditorCaption);

		VSL_SET_VALIDVALUE(pfDefaultPosition);

		VSL_SET_VALIDVALUE_INTERFACE(ppWindowFrame);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsVisibleValidValues
	{
		/*[out]*/ BOOL* pfVisible;
		HRESULT retValue;
	};

	STDMETHOD(IsVisible)(
		/*[out]*/ BOOL* pfVisible)
	{
		VSL_DEFINE_MOCK_METHOD(IsVisible)

		VSL_SET_VALIDVALUE(pfVisible);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSEXTERNALFILESMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsExpansionSession.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSEXPANSIONSESSION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSEXPANSIONSESSION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsExpansionSessionNotImpl :
	public IVsExpansionSession
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsExpansionSessionNotImpl)

public:

	typedef IVsExpansionSession Interface;

	STDMETHOD(EndCurrentExpansion)(
		/*[in]*/ BOOL /*fLeaveCaret*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GoToNextExpansionField)(
		/*[in]*/ BOOL /*fCommitIfLast*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GoToPreviousExpansionField)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFieldValue)(
		/*[in]*/ BSTR /*bstrFieldName*/,
		/*[out]*/ BSTR* /*pbstrValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetFieldDefault)(
		/*[in]*/ BSTR /*bstrFieldName*/,
		/*[in]*/ BSTR /*bstrNewValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFieldSpan)(
		/*[in]*/ BSTR /*bstrField*/,
		/*[out]*/ TextSpan* /*ptsSpan*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetHeaderNode)(
		/*[in]*/ BSTR /*bstrNode*/,
		/*[out]*/ IXMLDOMNode** /*pNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDeclarationNode)(
		/*[in]*/ BSTR /*bstrNode*/,
		/*[out]*/ IXMLDOMNode** /*pNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSnippetNode)(
		/*[in]*/ BSTR /*bstrNode*/,
		/*[out]*/ IXMLDOMNode** /*pNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSnippetSpan)(
		/*[out]*/ TextSpan* /*pts*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetEndSpan)(
		/*[in]*/ TextSpan /*ts*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEndSpan)(
		/*[out]*/ TextSpan* /*pts*/)VSL_STDMETHOD_NOTIMPL
};

class IVsExpansionSessionMockImpl :
	public IVsExpansionSession,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsExpansionSessionMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsExpansionSessionMockImpl)

	typedef IVsExpansionSession Interface;
	struct EndCurrentExpansionValidValues
	{
		/*[in]*/ BOOL fLeaveCaret;
		HRESULT retValue;
	};

	STDMETHOD(EndCurrentExpansion)(
		/*[in]*/ BOOL fLeaveCaret)
	{
		VSL_DEFINE_MOCK_METHOD(EndCurrentExpansion)

		VSL_CHECK_VALIDVALUE(fLeaveCaret);

		VSL_RETURN_VALIDVALUES();
	}
	struct GoToNextExpansionFieldValidValues
	{
		/*[in]*/ BOOL fCommitIfLast;
		HRESULT retValue;
	};

	STDMETHOD(GoToNextExpansionField)(
		/*[in]*/ BOOL fCommitIfLast)
	{
		VSL_DEFINE_MOCK_METHOD(GoToNextExpansionField)

		VSL_CHECK_VALIDVALUE(fCommitIfLast);

		VSL_RETURN_VALIDVALUES();
	}
	struct GoToPreviousExpansionFieldValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(GoToPreviousExpansionField)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(GoToPreviousExpansionField)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFieldValueValidValues
	{
		/*[in]*/ BSTR bstrFieldName;
		/*[out]*/ BSTR* pbstrValue;
		HRESULT retValue;
	};

	STDMETHOD(GetFieldValue)(
		/*[in]*/ BSTR bstrFieldName,
		/*[out]*/ BSTR* pbstrValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetFieldValue)

		VSL_CHECK_VALIDVALUE_BSTR(bstrFieldName);

		VSL_SET_VALIDVALUE_BSTR(pbstrValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetFieldDefaultValidValues
	{
		/*[in]*/ BSTR bstrFieldName;
		/*[in]*/ BSTR bstrNewValue;
		HRESULT retValue;
	};

	STDMETHOD(SetFieldDefault)(
		/*[in]*/ BSTR bstrFieldName,
		/*[in]*/ BSTR bstrNewValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetFieldDefault)

		VSL_CHECK_VALIDVALUE_BSTR(bstrFieldName);

		VSL_CHECK_VALIDVALUE_BSTR(bstrNewValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFieldSpanValidValues
	{
		/*[in]*/ BSTR bstrField;
		/*[out]*/ TextSpan* ptsSpan;
		HRESULT retValue;
	};

	STDMETHOD(GetFieldSpan)(
		/*[in]*/ BSTR bstrField,
		/*[out]*/ TextSpan* ptsSpan)
	{
		VSL_DEFINE_MOCK_METHOD(GetFieldSpan)

		VSL_CHECK_VALIDVALUE_BSTR(bstrField);

		VSL_SET_VALIDVALUE(ptsSpan);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetHeaderNodeValidValues
	{
		/*[in]*/ BSTR bstrNode;
		/*[out]*/ IXMLDOMNode** pNode;
		HRESULT retValue;
	};

	STDMETHOD(GetHeaderNode)(
		/*[in]*/ BSTR bstrNode,
		/*[out]*/ IXMLDOMNode** pNode)
	{
		VSL_DEFINE_MOCK_METHOD(GetHeaderNode)

		VSL_CHECK_VALIDVALUE_BSTR(bstrNode);

		VSL_SET_VALIDVALUE_INTERFACE(pNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDeclarationNodeValidValues
	{
		/*[in]*/ BSTR bstrNode;
		/*[out]*/ IXMLDOMNode** pNode;
		HRESULT retValue;
	};

	STDMETHOD(GetDeclarationNode)(
		/*[in]*/ BSTR bstrNode,
		/*[out]*/ IXMLDOMNode** pNode)
	{
		VSL_DEFINE_MOCK_METHOD(GetDeclarationNode)

		VSL_CHECK_VALIDVALUE_BSTR(bstrNode);

		VSL_SET_VALIDVALUE_INTERFACE(pNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSnippetNodeValidValues
	{
		/*[in]*/ BSTR bstrNode;
		/*[out]*/ IXMLDOMNode** pNode;
		HRESULT retValue;
	};

	STDMETHOD(GetSnippetNode)(
		/*[in]*/ BSTR bstrNode,
		/*[out]*/ IXMLDOMNode** pNode)
	{
		VSL_DEFINE_MOCK_METHOD(GetSnippetNode)

		VSL_CHECK_VALIDVALUE_BSTR(bstrNode);

		VSL_SET_VALIDVALUE_INTERFACE(pNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSnippetSpanValidValues
	{
		/*[out]*/ TextSpan* pts;
		HRESULT retValue;
	};

	STDMETHOD(GetSnippetSpan)(
		/*[out]*/ TextSpan* pts)
	{
		VSL_DEFINE_MOCK_METHOD(GetSnippetSpan)

		VSL_SET_VALIDVALUE(pts);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetEndSpanValidValues
	{
		/*[in]*/ TextSpan ts;
		HRESULT retValue;
	};

	STDMETHOD(SetEndSpan)(
		/*[in]*/ TextSpan ts)
	{
		VSL_DEFINE_MOCK_METHOD(SetEndSpan)

		VSL_CHECK_VALIDVALUE(ts);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEndSpanValidValues
	{
		/*[out]*/ TextSpan* pts;
		HRESULT retValue;
	};

	STDMETHOD(GetEndSpan)(
		/*[out]*/ TextSpan* pts)
	{
		VSL_DEFINE_MOCK_METHOD(GetEndSpan)

		VSL_SET_VALIDVALUE(pts);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSEXPANSIONSESSION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsExpansionManager.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSEXPANSIONMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSEXPANSIONMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsExpansionManagerNotImpl :
	public IVsExpansionManager
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsExpansionManagerNotImpl)

public:

	typedef IVsExpansionManager Interface;

	STDMETHOD(EnumerateExpansions)(
		/*[in]*/ GUID /*guidLang*/,
		/*[in]*/ BOOL /*fShortCutOnly*/,
		/*[in,size_is(iCountTypes)]*/ BSTR* /*bstrTypes*/,
		/*[in]*/ long /*iCountTypes*/,
		/*[in]*/ BOOL /*fIncludeNULLType*/,
		/*[in]*/ BOOL /*fIncludeDuplicates*/,
		/*[out]*/ IVsExpansionEnumeration** /*pEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(InvokeInsertionUI)(
		/*[in]*/ IVsTextView* /*pView*/,
		/*[in]*/ IVsExpansionClient* /*pClient*/,
		/*[in]*/ GUID /*guidLang*/,
		/*[in,size_is(iCountTypes)]*/ BSTR* /*bstrTypes*/,
		/*[in]*/ long /*iCountTypes*/,
		/*[in]*/ BOOL /*fIncludeNULLType*/,
		/*[in,size_is(iCountKinds)]*/ BSTR* /*bstrKinds*/,
		/*[in]*/ long /*iCountKinds*/,
		/*[in]*/ BOOL /*fIncludeNULLKind*/,
		/*[in]*/ BSTR /*bstrPrefixText*/,
		/*[in]*/ BSTR /*bstrCompletionChar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExpansionByShortcut)(
		/*[in]*/ IVsExpansionClient* /*pClient*/,
		/*[in]*/ GUID /*guidLang*/,
		/*[in,string]*/ LPOLESTR /*szShortcut*/,
		/*[in]*/ IVsTextView* /*pView*/,
		/*[in]*/ TextSpan* /*pts*/,
		/*[in]*/ BOOL /*fShowUI*/,
		/*[out]*/ BSTR* /*pszExpansionPath*/,
		/*[out]*/ BSTR* /*pszTitle*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTokenPath)(
		/*[in]*/ ExpansionToken /*token*/,
		/*[out]*/ BSTR* /*pbstrPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSnippetShortCutKeybindingState)(
		/*[out]*/ BOOL* /*fBound*/)VSL_STDMETHOD_NOTIMPL
};

class IVsExpansionManagerMockImpl :
	public IVsExpansionManager,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsExpansionManagerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsExpansionManagerMockImpl)

	typedef IVsExpansionManager Interface;
	struct EnumerateExpansionsValidValues
	{
		/*[in]*/ GUID guidLang;
		/*[in]*/ BOOL fShortCutOnly;
		/*[in,size_is(iCountTypes)]*/ BSTR* bstrTypes;
		/*[in]*/ long iCountTypes;
		/*[in]*/ BOOL fIncludeNULLType;
		/*[in]*/ BOOL fIncludeDuplicates;
		/*[out]*/ IVsExpansionEnumeration** pEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumerateExpansions)(
		/*[in]*/ GUID guidLang,
		/*[in]*/ BOOL fShortCutOnly,
		/*[in,size_is(iCountTypes)]*/ BSTR* bstrTypes,
		/*[in]*/ long iCountTypes,
		/*[in]*/ BOOL fIncludeNULLType,
		/*[in]*/ BOOL fIncludeDuplicates,
		/*[out]*/ IVsExpansionEnumeration** pEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumerateExpansions)

		VSL_CHECK_VALIDVALUE(guidLang);

		VSL_CHECK_VALIDVALUE(fShortCutOnly);

		VSL_CHECK_VALIDVALUE_MEMCMP(bstrTypes, iCountTypes*sizeof(bstrTypes[0]), validValues.iCountTypes*sizeof(validValues.bstrTypes[0]));

		VSL_CHECK_VALIDVALUE(iCountTypes);

		VSL_CHECK_VALIDVALUE(fIncludeNULLType);

		VSL_CHECK_VALIDVALUE(fIncludeDuplicates);

		VSL_SET_VALIDVALUE_INTERFACE(pEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeInsertionUIValidValues
	{
		/*[in]*/ IVsTextView* pView;
		/*[in]*/ IVsExpansionClient* pClient;
		/*[in]*/ GUID guidLang;
		/*[in,size_is(iCountTypes)]*/ BSTR* bstrTypes;
		/*[in]*/ long iCountTypes;
		/*[in]*/ BOOL fIncludeNULLType;
		/*[in,size_is(iCountKinds)]*/ BSTR* bstrKinds;
		/*[in]*/ long iCountKinds;
		/*[in]*/ BOOL fIncludeNULLKind;
		/*[in]*/ BSTR bstrPrefixText;
		/*[in]*/ BSTR bstrCompletionChar;
		HRESULT retValue;
	};

	STDMETHOD(InvokeInsertionUI)(
		/*[in]*/ IVsTextView* pView,
		/*[in]*/ IVsExpansionClient* pClient,
		/*[in]*/ GUID guidLang,
		/*[in,size_is(iCountTypes)]*/ BSTR* bstrTypes,
		/*[in]*/ long iCountTypes,
		/*[in]*/ BOOL fIncludeNULLType,
		/*[in,size_is(iCountKinds)]*/ BSTR* bstrKinds,
		/*[in]*/ long iCountKinds,
		/*[in]*/ BOOL fIncludeNULLKind,
		/*[in]*/ BSTR bstrPrefixText,
		/*[in]*/ BSTR bstrCompletionChar)
	{
		VSL_DEFINE_MOCK_METHOD(InvokeInsertionUI)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pView);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pClient);

		VSL_CHECK_VALIDVALUE(guidLang);

		VSL_CHECK_VALIDVALUE_MEMCMP(bstrTypes, iCountTypes*sizeof(bstrTypes[0]), validValues.iCountTypes*sizeof(validValues.bstrTypes[0]));

		VSL_CHECK_VALIDVALUE(iCountTypes);

		VSL_CHECK_VALIDVALUE(fIncludeNULLType);

		VSL_CHECK_VALIDVALUE_MEMCMP(bstrKinds, iCountKinds*sizeof(bstrKinds[0]), validValues.iCountKinds*sizeof(validValues.bstrKinds[0]));

		VSL_CHECK_VALIDVALUE(iCountKinds);

		VSL_CHECK_VALIDVALUE(fIncludeNULLKind);

		VSL_CHECK_VALIDVALUE_BSTR(bstrPrefixText);

		VSL_CHECK_VALIDVALUE_BSTR(bstrCompletionChar);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExpansionByShortcutValidValues
	{
		/*[in]*/ IVsExpansionClient* pClient;
		/*[in]*/ GUID guidLang;
		/*[in,string]*/ LPOLESTR szShortcut;
		/*[in]*/ IVsTextView* pView;
		/*[in]*/ TextSpan* pts;
		/*[in]*/ BOOL fShowUI;
		/*[out]*/ BSTR* pszExpansionPath;
		/*[out]*/ BSTR* pszTitle;
		HRESULT retValue;
	};

	STDMETHOD(GetExpansionByShortcut)(
		/*[in]*/ IVsExpansionClient* pClient,
		/*[in]*/ GUID guidLang,
		/*[in,string]*/ LPOLESTR szShortcut,
		/*[in]*/ IVsTextView* pView,
		/*[in]*/ TextSpan* pts,
		/*[in]*/ BOOL fShowUI,
		/*[out]*/ BSTR* pszExpansionPath,
		/*[out]*/ BSTR* pszTitle)
	{
		VSL_DEFINE_MOCK_METHOD(GetExpansionByShortcut)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pClient);

		VSL_CHECK_VALIDVALUE(guidLang);

		VSL_CHECK_VALIDVALUE_STRINGW(szShortcut);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pView);

		VSL_CHECK_VALIDVALUE_POINTER(pts);

		VSL_CHECK_VALIDVALUE(fShowUI);

		VSL_SET_VALIDVALUE_BSTR(pszExpansionPath);

		VSL_SET_VALIDVALUE_BSTR(pszTitle);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTokenPathValidValues
	{
		/*[in]*/ ExpansionToken token;
		/*[out]*/ BSTR* pbstrPath;
		HRESULT retValue;
	};

	STDMETHOD(GetTokenPath)(
		/*[in]*/ ExpansionToken token,
		/*[out]*/ BSTR* pbstrPath)
	{
		VSL_DEFINE_MOCK_METHOD(GetTokenPath)

		VSL_CHECK_VALIDVALUE(token);

		VSL_SET_VALIDVALUE_BSTR(pbstrPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSnippetShortCutKeybindingStateValidValues
	{
		/*[out]*/ BOOL* fBound;
		HRESULT retValue;
	};

	STDMETHOD(GetSnippetShortCutKeybindingState)(
		/*[out]*/ BOOL* fBound)
	{
		VSL_DEFINE_MOCK_METHOD(GetSnippetShortCutKeybindingState)

		VSL_SET_VALIDVALUE(fBound);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSEXPANSIONMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsExternalFilesManager2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSEXTERNALFILESMANAGER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSEXTERNALFILESMANAGER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsExternalFilesManager2NotImpl :
	public IVsExternalFilesManager2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsExternalFilesManager2NotImpl)

public:

	typedef IVsExternalFilesManager2 Interface;

	STDMETHOD(AddDocumentEx)(
		/*[in]*/ VSCREATEDOCWIN /*dwCDW*/,
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[in]*/ IUnknown* /*punkDocView*/,
		/*[in]*/ IUnknown* /*punkDocData*/,
		/*[in]*/ REFGUID /*rguidEditorType*/,
		/*[in]*/ LPCOLESTR /*pszPhysicalView*/,
		/*[in]*/ REFGUID /*rguidCmdUI*/,
		/*[in]*/ LPCOLESTR /*pszOwnerCaption*/,
		/*[in]*/ LPCOLESTR /*pszEditorCaption*/,
		/*[in]*/ IServiceProvider* /*pspContext*/,
		/*[in]*/ HICON /*hIcon*/,
		/*[out]*/ BOOL* /*pfDefaultPosition*/,
		/*[out]*/ IVsWindowFrame** /*ppWindowFrame*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExternalFilesProject)(
		/*[out]*/ IVsProject** /*ppProject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(TransferDocument)(
		/*[in]*/ LPCOLESTR /*pszMkDocumentOld*/,
		/*[in]*/ LPCOLESTR /*pszMkDocumentNew*/,
		/*[in]*/ IVsWindowFrame* /*punkWindowFrame*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddDocument)(
		/*[in]*/ VSCREATEDOCWIN /*dwCDW*/,
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[in]*/ IUnknown* /*punkDocView*/,
		/*[in]*/ IUnknown* /*punkDocData*/,
		/*[in]*/ REFGUID /*rguidEditorType*/,
		/*[in]*/ LPCOLESTR /*pszPhysicalView*/,
		/*[in]*/ REFGUID /*rguidCmdUI*/,
		/*[in]*/ LPCOLESTR /*pszOwnerCaption*/,
		/*[in]*/ LPCOLESTR /*pszEditorCaption*/,
		/*[out]*/ BOOL* /*pfDefaultPosition*/,
		/*[out]*/ IVsWindowFrame** /*ppWindowFrame*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsVisible)(
		/*[out]*/ BOOL* /*pfVisible*/)VSL_STDMETHOD_NOTIMPL
};

class IVsExternalFilesManager2MockImpl :
	public IVsExternalFilesManager2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsExternalFilesManager2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsExternalFilesManager2MockImpl)

	typedef IVsExternalFilesManager2 Interface;
	struct AddDocumentExValidValues
	{
		/*[in]*/ VSCREATEDOCWIN dwCDW;
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[in]*/ IUnknown* punkDocView;
		/*[in]*/ IUnknown* punkDocData;
		/*[in]*/ REFGUID rguidEditorType;
		/*[in]*/ LPCOLESTR pszPhysicalView;
		/*[in]*/ REFGUID rguidCmdUI;
		/*[in]*/ LPCOLESTR pszOwnerCaption;
		/*[in]*/ LPCOLESTR pszEditorCaption;
		/*[in]*/ IServiceProvider* pspContext;
		/*[in]*/ HICON hIcon;
		/*[out]*/ BOOL* pfDefaultPosition;
		/*[out]*/ IVsWindowFrame** ppWindowFrame;
		HRESULT retValue;
	};

	STDMETHOD(AddDocumentEx)(
		/*[in]*/ VSCREATEDOCWIN dwCDW,
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[in]*/ IUnknown* punkDocView,
		/*[in]*/ IUnknown* punkDocData,
		/*[in]*/ REFGUID rguidEditorType,
		/*[in]*/ LPCOLESTR pszPhysicalView,
		/*[in]*/ REFGUID rguidCmdUI,
		/*[in]*/ LPCOLESTR pszOwnerCaption,
		/*[in]*/ LPCOLESTR pszEditorCaption,
		/*[in]*/ IServiceProvider* pspContext,
		/*[in]*/ HICON hIcon,
		/*[out]*/ BOOL* pfDefaultPosition,
		/*[out]*/ IVsWindowFrame** ppWindowFrame)
	{
		VSL_DEFINE_MOCK_METHOD(AddDocumentEx)

		VSL_CHECK_VALIDVALUE(dwCDW);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkDocView);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkDocData);

		VSL_CHECK_VALIDVALUE(rguidEditorType);

		VSL_CHECK_VALIDVALUE_STRINGW(pszPhysicalView);

		VSL_CHECK_VALIDVALUE(rguidCmdUI);

		VSL_CHECK_VALIDVALUE_STRINGW(pszOwnerCaption);

		VSL_CHECK_VALIDVALUE_STRINGW(pszEditorCaption);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pspContext);

		VSL_CHECK_VALIDVALUE(hIcon);

		VSL_SET_VALIDVALUE(pfDefaultPosition);

		VSL_SET_VALIDVALUE_INTERFACE(ppWindowFrame);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExternalFilesProjectValidValues
	{
		/*[out]*/ IVsProject** ppProject;
		HRESULT retValue;
	};

	STDMETHOD(GetExternalFilesProject)(
		/*[out]*/ IVsProject** ppProject)
	{
		VSL_DEFINE_MOCK_METHOD(GetExternalFilesProject)

		VSL_SET_VALIDVALUE_INTERFACE(ppProject);

		VSL_RETURN_VALIDVALUES();
	}
	struct TransferDocumentValidValues
	{
		/*[in]*/ LPCOLESTR pszMkDocumentOld;
		/*[in]*/ LPCOLESTR pszMkDocumentNew;
		/*[in]*/ IVsWindowFrame* punkWindowFrame;
		HRESULT retValue;
	};

	STDMETHOD(TransferDocument)(
		/*[in]*/ LPCOLESTR pszMkDocumentOld,
		/*[in]*/ LPCOLESTR pszMkDocumentNew,
		/*[in]*/ IVsWindowFrame* punkWindowFrame)
	{
		VSL_DEFINE_MOCK_METHOD(TransferDocument)

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocumentOld);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocumentNew);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkWindowFrame);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddDocumentValidValues
	{
		/*[in]*/ VSCREATEDOCWIN dwCDW;
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[in]*/ IUnknown* punkDocView;
		/*[in]*/ IUnknown* punkDocData;
		/*[in]*/ REFGUID rguidEditorType;
		/*[in]*/ LPCOLESTR pszPhysicalView;
		/*[in]*/ REFGUID rguidCmdUI;
		/*[in]*/ LPCOLESTR pszOwnerCaption;
		/*[in]*/ LPCOLESTR pszEditorCaption;
		/*[out]*/ BOOL* pfDefaultPosition;
		/*[out]*/ IVsWindowFrame** ppWindowFrame;
		HRESULT retValue;
	};

	STDMETHOD(AddDocument)(
		/*[in]*/ VSCREATEDOCWIN dwCDW,
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[in]*/ IUnknown* punkDocView,
		/*[in]*/ IUnknown* punkDocData,
		/*[in]*/ REFGUID rguidEditorType,
		/*[in]*/ LPCOLESTR pszPhysicalView,
		/*[in]*/ REFGUID rguidCmdUI,
		/*[in]*/ LPCOLESTR pszOwnerCaption,
		/*[in]*/ LPCOLESTR pszEditorCaption,
		/*[out]*/ BOOL* pfDefaultPosition,
		/*[out]*/ IVsWindowFrame** ppWindowFrame)
	{
		VSL_DEFINE_MOCK_METHOD(AddDocument)

		VSL_CHECK_VALIDVALUE(dwCDW);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkDocView);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkDocData);

		VSL_CHECK_VALIDVALUE(rguidEditorType);

		VSL_CHECK_VALIDVALUE_STRINGW(pszPhysicalView);

		VSL_CHECK_VALIDVALUE(rguidCmdUI);

		VSL_CHECK_VALIDVALUE_STRINGW(pszOwnerCaption);

		VSL_CHECK_VALIDVALUE_STRINGW(pszEditorCaption);

		VSL_SET_VALIDVALUE(pfDefaultPosition);

		VSL_SET_VALIDVALUE_INTERFACE(ppWindowFrame);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsVisibleValidValues
	{
		/*[out]*/ BOOL* pfVisible;
		HRESULT retValue;
	};

	STDMETHOD(IsVisible)(
		/*[out]*/ BOOL* pfVisible)
	{
		VSL_DEFINE_MOCK_METHOD(IsVisible)

		VSL_SET_VALIDVALUE(pfVisible);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSEXTERNALFILESMANAGER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsExternalCompletionSet.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSEXTERNALCOMPLETIONSET_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSEXTERNALCOMPLETIONSET_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "singlefileeditor.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsExternalCompletionSetNotImpl :
	public IVsExternalCompletionSet
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsExternalCompletionSetNotImpl)

public:

	typedef IVsExternalCompletionSet Interface;

	STDMETHOD(SetIntellisenseHost)(
		/*[in]*/ IVsIntellisenseHost* /*pHost*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateCompSet)()VSL_STDMETHOD_NOTIMPL
};

class IVsExternalCompletionSetMockImpl :
	public IVsExternalCompletionSet,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsExternalCompletionSetMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsExternalCompletionSetMockImpl)

	typedef IVsExternalCompletionSet Interface;
	struct SetIntellisenseHostValidValues
	{
		/*[in]*/ IVsIntellisenseHost* pHost;
		HRESULT retValue;
	};

	STDMETHOD(SetIntellisenseHost)(
		/*[in]*/ IVsIntellisenseHost* pHost)
	{
		VSL_DEFINE_MOCK_METHOD(SetIntellisenseHost)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHost);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateCompSetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(UpdateCompSet)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(UpdateCompSet)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSEXTERNALCOMPLETIONSET_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsExtensibleObject.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSEXTENSIBLEOBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSEXTENSIBLEOBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsExtensibleObjectNotImpl :
	public IVsExtensibleObject
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsExtensibleObjectNotImpl)

public:

	typedef IVsExtensibleObject Interface;

	STDMETHOD(GetAutomationObject)(
		/*[in]*/ LPCOLESTR /*pszPropName*/,
		/*[out]*/ IDispatch** /*ppDisp*/)VSL_STDMETHOD_NOTIMPL
};

class IVsExtensibleObjectMockImpl :
	public IVsExtensibleObject,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsExtensibleObjectMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsExtensibleObjectMockImpl)

	typedef IVsExtensibleObject Interface;
	struct GetAutomationObjectValidValues
	{
		/*[in]*/ LPCOLESTR pszPropName;
		/*[out]*/ IDispatch** ppDisp;
		HRESULT retValue;
	};

	STDMETHOD(GetAutomationObject)(
		/*[in]*/ LPCOLESTR pszPropName,
		/*[out]*/ IDispatch** ppDisp)
	{
		VSL_DEFINE_MOCK_METHOD(GetAutomationObject)

		VSL_CHECK_VALIDVALUE_STRINGW(pszPropName);

		VSL_SET_VALIDVALUE_INTERFACE(ppDisp);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSEXTENSIBLEOBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsExtensibility3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSEXTENSIBILITY3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSEXTENSIBILITY3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsExtensibility3NotImpl :
	public IVsExtensibility3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsExtensibility3NotImpl)

public:

	typedef IVsExtensibility3 Interface;

	STDMETHOD(GetProperties)(
		/*[in]*/ IUnknown* /*pParent*/,
		/*[in]*/ IDispatch* /*pdispPropObj*/,
		/*[out]*/ IDispatch** /*ppProperties*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RunWizardFile)(
		/*[in]*/ BSTR /*bstrWizFilename*/,
		/*[in]*/ long /*hwndOwner*/,
		/*[in]*/ SAFEARRAY** /*vContextParams*/,
		/*[out,retval]*/ long* /*pResult*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnterAutomationFunction)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ExitAutomationFunction)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsInAutomationFunction)(
		/*[out,retval]*/ BOOL* /*pfInAutoFunc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetUserControl)(
		/*[out]*/ VARIANT_BOOL* /*fUserControl*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetUserControl)(
		/*[in]*/ VARIANT_BOOL /*fUserControl*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetUserControlUnlatched)(
		/*[in]*/ VARIANT_BOOL /*fUserControl*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LockServer)(
		/*[in]*/ VARIANT_BOOL /*param1*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLockCount)(
		/*[out,retval]*/ long* /*pCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(TestForShutdown)(
		/*[out,retval]*/ VARIANT_BOOL* /*fShutdown*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetGlobalsObject)(
		/*[in]*/ VARIANT /*ExtractFrom*/,
		/*[out,retval]*/ IUnknown** /*ppGlobals*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetConfigMgr)(
		/*[in]*/ IUnknown* /*pIVsProject*/,
		/*[in]*/ DWORD_PTR /*itemid*/,
		/*[out,retval]*/ IUnknown** /*ppCfgMgr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FireMacroReset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDocumentFromDocCookie)(
		/*[in]*/ LONG_PTR /*lDocCookie*/,
		/*[out,retval]*/ IUnknown** /*ppDoc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsMethodDisabled)(
		/*[in]*/ const GUID* /*pGUID*/,
		/*[in]*/ long /*dispid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetSuppressUI)(
		/*[in]*/ VARIANT_BOOL /*In*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSuppressUI)(
		/*[in,out]*/ VARIANT_BOOL* /*pOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FireProjectsEvent_ItemAdded)(
		/*[in]*/ IUnknown* /*Project*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FireProjectsEvent_ItemRemoved)(
		/*[in]*/ IUnknown* /*Project*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FireProjectsEvent_ItemRenamed)(
		/*[in]*/ IUnknown* /*Project*/,
		/*[in]*/ BSTR /*OldName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FireProjectItemsEvent_ItemAdded)(
		/*[in]*/ IUnknown* /*ProjectItem*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FireProjectItemsEvent_ItemRemoved)(
		/*[in]*/ IUnknown* /*ProjectItem*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FireProjectItemsEvent_ItemRenamed)(
		/*[in]*/ IUnknown* /*ProjectItem*/,
		/*[in]*/ BSTR /*OldName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsFireCodeModelEventNeeded)(
		/*[in,out]*/ VARIANT_BOOL* /*vbNeeded*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RunWizardFileEx)(
		/*[in]*/ BSTR /*bstrWizFilename*/,
		/*[in]*/ long /*hwndOwner*/,
		/*[in]*/ SAFEARRAY** /*vContextParams*/,
		/*[in]*/ SAFEARRAY** /*vCustomParams*/,
		/*[out,retval]*/ long* /*pResult*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FireCodeModelEvent3)(
		/*[in]*/ DISPID /*dispid*/,
		/*[in]*/ IDispatch* /*pParent*/,
		/*[in]*/ IUnknown* /*pElement*/,
		/*[in]*/ long /*changeKind*/)VSL_STDMETHOD_NOTIMPL
};

class IVsExtensibility3MockImpl :
	public IVsExtensibility3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsExtensibility3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsExtensibility3MockImpl)

	typedef IVsExtensibility3 Interface;
	struct GetPropertiesValidValues
	{
		/*[in]*/ IUnknown* pParent;
		/*[in]*/ IDispatch* pdispPropObj;
		/*[out]*/ IDispatch** ppProperties;
		HRESULT retValue;
	};

	STDMETHOD(GetProperties)(
		/*[in]*/ IUnknown* pParent,
		/*[in]*/ IDispatch* pdispPropObj,
		/*[out]*/ IDispatch** ppProperties)
	{
		VSL_DEFINE_MOCK_METHOD(GetProperties)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pParent);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pdispPropObj);

		VSL_SET_VALIDVALUE_INTERFACE(ppProperties);

		VSL_RETURN_VALIDVALUES();
	}
	struct RunWizardFileValidValues
	{
		/*[in]*/ BSTR bstrWizFilename;
		/*[in]*/ long hwndOwner;
		/*[in]*/ SAFEARRAY** vContextParams;
		/*[out,retval]*/ long* pResult;
		HRESULT retValue;
	};

	STDMETHOD(RunWizardFile)(
		/*[in]*/ BSTR bstrWizFilename,
		/*[in]*/ long hwndOwner,
		/*[in]*/ SAFEARRAY** vContextParams,
		/*[out,retval]*/ long* pResult)
	{
		VSL_DEFINE_MOCK_METHOD(RunWizardFile)

		VSL_CHECK_VALIDVALUE_BSTR(bstrWizFilename);

		VSL_CHECK_VALIDVALUE(hwndOwner);

		VSL_CHECK_VALIDVALUE_POINTER(vContextParams);

		VSL_SET_VALIDVALUE(pResult);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnterAutomationFunctionValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(EnterAutomationFunction)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(EnterAutomationFunction)

		VSL_RETURN_VALIDVALUES();
	}
	struct ExitAutomationFunctionValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ExitAutomationFunction)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ExitAutomationFunction)

		VSL_RETURN_VALIDVALUES();
	}
	struct IsInAutomationFunctionValidValues
	{
		/*[out,retval]*/ BOOL* pfInAutoFunc;
		HRESULT retValue;
	};

	STDMETHOD(IsInAutomationFunction)(
		/*[out,retval]*/ BOOL* pfInAutoFunc)
	{
		VSL_DEFINE_MOCK_METHOD(IsInAutomationFunction)

		VSL_SET_VALIDVALUE(pfInAutoFunc);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetUserControlValidValues
	{
		/*[out]*/ VARIANT_BOOL* fUserControl;
		HRESULT retValue;
	};

	STDMETHOD(GetUserControl)(
		/*[out]*/ VARIANT_BOOL* fUserControl)
	{
		VSL_DEFINE_MOCK_METHOD(GetUserControl)

		VSL_SET_VALIDVALUE(fUserControl);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetUserControlValidValues
	{
		/*[in]*/ VARIANT_BOOL fUserControl;
		HRESULT retValue;
	};

	STDMETHOD(SetUserControl)(
		/*[in]*/ VARIANT_BOOL fUserControl)
	{
		VSL_DEFINE_MOCK_METHOD(SetUserControl)

		VSL_CHECK_VALIDVALUE(fUserControl);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetUserControlUnlatchedValidValues
	{
		/*[in]*/ VARIANT_BOOL fUserControl;
		HRESULT retValue;
	};

	STDMETHOD(SetUserControlUnlatched)(
		/*[in]*/ VARIANT_BOOL fUserControl)
	{
		VSL_DEFINE_MOCK_METHOD(SetUserControlUnlatched)

		VSL_CHECK_VALIDVALUE(fUserControl);

		VSL_RETURN_VALIDVALUES();
	}
	struct LockServerValidValues
	{
		/*[in]*/ VARIANT_BOOL param1;
		HRESULT retValue;
	};

	STDMETHOD(LockServer)(
		/*[in]*/ VARIANT_BOOL param1)
	{
		VSL_DEFINE_MOCK_METHOD(LockServer)

		VSL_CHECK_VALIDVALUE(param1);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLockCountValidValues
	{
		/*[out,retval]*/ long* pCount;
		HRESULT retValue;
	};

	STDMETHOD(GetLockCount)(
		/*[out,retval]*/ long* pCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetLockCount)

		VSL_SET_VALIDVALUE(pCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct TestForShutdownValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* fShutdown;
		HRESULT retValue;
	};

	STDMETHOD(TestForShutdown)(
		/*[out,retval]*/ VARIANT_BOOL* fShutdown)
	{
		VSL_DEFINE_MOCK_METHOD(TestForShutdown)

		VSL_SET_VALIDVALUE(fShutdown);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetGlobalsObjectValidValues
	{
		/*[in]*/ VARIANT ExtractFrom;
		/*[out,retval]*/ IUnknown** ppGlobals;
		HRESULT retValue;
	};

	STDMETHOD(GetGlobalsObject)(
		/*[in]*/ VARIANT ExtractFrom,
		/*[out,retval]*/ IUnknown** ppGlobals)
	{
		VSL_DEFINE_MOCK_METHOD(GetGlobalsObject)

		VSL_CHECK_VALIDVALUE(ExtractFrom);

		VSL_SET_VALIDVALUE_INTERFACE(ppGlobals);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetConfigMgrValidValues
	{
		/*[in]*/ IUnknown* pIVsProject;
		/*[in]*/ DWORD_PTR itemid;
		/*[out,retval]*/ IUnknown** ppCfgMgr;
		HRESULT retValue;
	};

	STDMETHOD(GetConfigMgr)(
		/*[in]*/ IUnknown* pIVsProject,
		/*[in]*/ DWORD_PTR itemid,
		/*[out,retval]*/ IUnknown** ppCfgMgr)
	{
		VSL_DEFINE_MOCK_METHOD(GetConfigMgr)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsProject);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_SET_VALIDVALUE_INTERFACE(ppCfgMgr);

		VSL_RETURN_VALIDVALUES();
	}
	struct FireMacroResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(FireMacroReset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(FireMacroReset)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDocumentFromDocCookieValidValues
	{
		/*[in]*/ LONG_PTR lDocCookie;
		/*[out,retval]*/ IUnknown** ppDoc;
		HRESULT retValue;
	};

	STDMETHOD(GetDocumentFromDocCookie)(
		/*[in]*/ LONG_PTR lDocCookie,
		/*[out,retval]*/ IUnknown** ppDoc)
	{
		VSL_DEFINE_MOCK_METHOD(GetDocumentFromDocCookie)

		VSL_CHECK_VALIDVALUE(lDocCookie);

		VSL_SET_VALIDVALUE_INTERFACE(ppDoc);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsMethodDisabledValidValues
	{
		/*[in]*/ GUID* pGUID;
		/*[in]*/ long dispid;
		HRESULT retValue;
	};

	STDMETHOD(IsMethodDisabled)(
		/*[in]*/ const GUID* pGUID,
		/*[in]*/ long dispid)
	{
		VSL_DEFINE_MOCK_METHOD(IsMethodDisabled)

		VSL_CHECK_VALIDVALUE_POINTER(pGUID);

		VSL_CHECK_VALIDVALUE(dispid);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetSuppressUIValidValues
	{
		/*[in]*/ VARIANT_BOOL In;
		HRESULT retValue;
	};

	STDMETHOD(SetSuppressUI)(
		/*[in]*/ VARIANT_BOOL In)
	{
		VSL_DEFINE_MOCK_METHOD(SetSuppressUI)

		VSL_CHECK_VALIDVALUE(In);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSuppressUIValidValues
	{
		/*[in,out]*/ VARIANT_BOOL* pOut;
		HRESULT retValue;
	};

	STDMETHOD(GetSuppressUI)(
		/*[in,out]*/ VARIANT_BOOL* pOut)
	{
		VSL_DEFINE_MOCK_METHOD(GetSuppressUI)

		VSL_SET_VALIDVALUE(pOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct FireProjectsEvent_ItemAddedValidValues
	{
		/*[in]*/ IUnknown* Project;
		HRESULT retValue;
	};

	STDMETHOD(FireProjectsEvent_ItemAdded)(
		/*[in]*/ IUnknown* Project)
	{
		VSL_DEFINE_MOCK_METHOD(FireProjectsEvent_ItemAdded)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(Project);

		VSL_RETURN_VALIDVALUES();
	}
	struct FireProjectsEvent_ItemRemovedValidValues
	{
		/*[in]*/ IUnknown* Project;
		HRESULT retValue;
	};

	STDMETHOD(FireProjectsEvent_ItemRemoved)(
		/*[in]*/ IUnknown* Project)
	{
		VSL_DEFINE_MOCK_METHOD(FireProjectsEvent_ItemRemoved)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(Project);

		VSL_RETURN_VALIDVALUES();
	}
	struct FireProjectsEvent_ItemRenamedValidValues
	{
		/*[in]*/ IUnknown* Project;
		/*[in]*/ BSTR OldName;
		HRESULT retValue;
	};

	STDMETHOD(FireProjectsEvent_ItemRenamed)(
		/*[in]*/ IUnknown* Project,
		/*[in]*/ BSTR OldName)
	{
		VSL_DEFINE_MOCK_METHOD(FireProjectsEvent_ItemRenamed)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(Project);

		VSL_CHECK_VALIDVALUE_BSTR(OldName);

		VSL_RETURN_VALIDVALUES();
	}
	struct FireProjectItemsEvent_ItemAddedValidValues
	{
		/*[in]*/ IUnknown* ProjectItem;
		HRESULT retValue;
	};

	STDMETHOD(FireProjectItemsEvent_ItemAdded)(
		/*[in]*/ IUnknown* ProjectItem)
	{
		VSL_DEFINE_MOCK_METHOD(FireProjectItemsEvent_ItemAdded)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(ProjectItem);

		VSL_RETURN_VALIDVALUES();
	}
	struct FireProjectItemsEvent_ItemRemovedValidValues
	{
		/*[in]*/ IUnknown* ProjectItem;
		HRESULT retValue;
	};

	STDMETHOD(FireProjectItemsEvent_ItemRemoved)(
		/*[in]*/ IUnknown* ProjectItem)
	{
		VSL_DEFINE_MOCK_METHOD(FireProjectItemsEvent_ItemRemoved)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(ProjectItem);

		VSL_RETURN_VALIDVALUES();
	}
	struct FireProjectItemsEvent_ItemRenamedValidValues
	{
		/*[in]*/ IUnknown* ProjectItem;
		/*[in]*/ BSTR OldName;
		HRESULT retValue;
	};

	STDMETHOD(FireProjectItemsEvent_ItemRenamed)(
		/*[in]*/ IUnknown* ProjectItem,
		/*[in]*/ BSTR OldName)
	{
		VSL_DEFINE_MOCK_METHOD(FireProjectItemsEvent_ItemRenamed)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(ProjectItem);

		VSL_CHECK_VALIDVALUE_BSTR(OldName);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsFireCodeModelEventNeededValidValues
	{
		/*[in,out]*/ VARIANT_BOOL* vbNeeded;
		HRESULT retValue;
	};

	STDMETHOD(IsFireCodeModelEventNeeded)(
		/*[in,out]*/ VARIANT_BOOL* vbNeeded)
	{
		VSL_DEFINE_MOCK_METHOD(IsFireCodeModelEventNeeded)

		VSL_SET_VALIDVALUE(vbNeeded);

		VSL_RETURN_VALIDVALUES();
	}
	struct RunWizardFileExValidValues
	{
		/*[in]*/ BSTR bstrWizFilename;
		/*[in]*/ long hwndOwner;
		/*[in]*/ SAFEARRAY** vContextParams;
		/*[in]*/ SAFEARRAY** vCustomParams;
		/*[out,retval]*/ long* pResult;
		HRESULT retValue;
	};

	STDMETHOD(RunWizardFileEx)(
		/*[in]*/ BSTR bstrWizFilename,
		/*[in]*/ long hwndOwner,
		/*[in]*/ SAFEARRAY** vContextParams,
		/*[in]*/ SAFEARRAY** vCustomParams,
		/*[out,retval]*/ long* pResult)
	{
		VSL_DEFINE_MOCK_METHOD(RunWizardFileEx)

		VSL_CHECK_VALIDVALUE_BSTR(bstrWizFilename);

		VSL_CHECK_VALIDVALUE(hwndOwner);

		VSL_CHECK_VALIDVALUE_POINTER(vContextParams);

		VSL_CHECK_VALIDVALUE_POINTER(vCustomParams);

		VSL_SET_VALIDVALUE(pResult);

		VSL_RETURN_VALIDVALUES();
	}
	struct FireCodeModelEvent3ValidValues
	{
		/*[in]*/ DISPID dispid;
		/*[in]*/ IDispatch* pParent;
		/*[in]*/ IUnknown* pElement;
		/*[in]*/ long changeKind;
		HRESULT retValue;
	};

	STDMETHOD(FireCodeModelEvent3)(
		/*[in]*/ DISPID dispid,
		/*[in]*/ IDispatch* pParent,
		/*[in]*/ IUnknown* pElement,
		/*[in]*/ long changeKind)
	{
		VSL_DEFINE_MOCK_METHOD(FireCodeModelEvent3)

		VSL_CHECK_VALIDVALUE(dispid);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pParent);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pElement);

		VSL_CHECK_VALIDVALUE(changeKind);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSEXTENSIBILITY3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsFavoritesProvider.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSFAVORITESPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSFAVORITESPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsbrowse.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsFavoritesProviderNotImpl :
	public IVsFavoritesProvider
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFavoritesProviderNotImpl)

public:

	typedef IVsFavoritesProvider Interface;

	STDMETHOD(Navigate)(
		/*[in]*/ LPCOLESTR /*lpszURL*/,
		/*[in]*/ DWORD /*dwFlags*/,
		/*[out]*/ IVsWindowFrame** /*ppFrame*/)VSL_STDMETHOD_NOTIMPL
};

class IVsFavoritesProviderMockImpl :
	public IVsFavoritesProvider,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFavoritesProviderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsFavoritesProviderMockImpl)

	typedef IVsFavoritesProvider Interface;
	struct NavigateValidValues
	{
		/*[in]*/ LPCOLESTR lpszURL;
		/*[in]*/ DWORD dwFlags;
		/*[out]*/ IVsWindowFrame** ppFrame;
		HRESULT retValue;
	};

	STDMETHOD(Navigate)(
		/*[in]*/ LPCOLESTR lpszURL,
		/*[in]*/ DWORD dwFlags,
		/*[out]*/ IVsWindowFrame** ppFrame)
	{
		VSL_DEFINE_MOCK_METHOD(Navigate)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszURL);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_SET_VALIDVALUE_INTERFACE(ppFrame);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSFAVORITESPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsFileChange.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSFILECHANGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSFILECHANGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsFileChangeNotImpl :
	public IVsFileChange
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFileChangeNotImpl)

public:

	typedef IVsFileChange Interface;

	STDMETHOD(AdviseFileChangeEvents)(
		/*[in]*/ IVsFileChangeEvents* /*pFCE*/,
		/*[out]*/ VSCOOKIE* /*pdwAdvise*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseFileChangeEvents)(
		/*[in]*/ VSCOOKIE /*dwAdvise*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddFile)(
		/*[in]*/ VSCOOKIE /*dwAdvise*/,
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[in]*/ VSFILECHANGEFLAGS /*grfFilter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveFile)(
		/*[in]*/ VSCOOKIE /*dwAdvise*/,
		/*[in]*/ LPCOLESTR /*pszMkDocument*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddDirectory)(
		/*[in]*/ VSCOOKIE /*dwAdvise*/,
		/*[in]*/ LPCOLESTR /*pszPath*/,
		/*[in]*/ BOOL /*fWatchSubDir*/,
		/*[in]*/ VSFILECHANGEFLAGS /*grfFilter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveDirectory)(
		/*[in]*/ VSCOOKIE /*dwAdvise*/,
		/*[in]*/ LPCOLESTR /*pszMkDocument*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SyncFile)(
		/*[in]*/ LPCOLESTR /*pszMkDocument*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IgnoreFile)(
		/*[in]*/ VSCOOKIE /*dwAdvise*/,
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[in]*/ BOOL /*fIgnore*/)VSL_STDMETHOD_NOTIMPL
};

class IVsFileChangeMockImpl :
	public IVsFileChange,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFileChangeMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsFileChangeMockImpl)

	typedef IVsFileChange Interface;
	struct AdviseFileChangeEventsValidValues
	{
		/*[in]*/ IVsFileChangeEvents* pFCE;
		/*[out]*/ VSCOOKIE* pdwAdvise;
		HRESULT retValue;
	};

	STDMETHOD(AdviseFileChangeEvents)(
		/*[in]*/ IVsFileChangeEvents* pFCE,
		/*[out]*/ VSCOOKIE* pdwAdvise)
	{
		VSL_DEFINE_MOCK_METHOD(AdviseFileChangeEvents)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pFCE);

		VSL_SET_VALIDVALUE(pdwAdvise);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseFileChangeEventsValidValues
	{
		/*[in]*/ VSCOOKIE dwAdvise;
		HRESULT retValue;
	};

	STDMETHOD(UnadviseFileChangeEvents)(
		/*[in]*/ VSCOOKIE dwAdvise)
	{
		VSL_DEFINE_MOCK_METHOD(UnadviseFileChangeEvents)

		VSL_CHECK_VALIDVALUE(dwAdvise);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddFileValidValues
	{
		/*[in]*/ VSCOOKIE dwAdvise;
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[in]*/ VSFILECHANGEFLAGS grfFilter;
		HRESULT retValue;
	};

	STDMETHOD(AddFile)(
		/*[in]*/ VSCOOKIE dwAdvise,
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[in]*/ VSFILECHANGEFLAGS grfFilter)
	{
		VSL_DEFINE_MOCK_METHOD(AddFile)

		VSL_CHECK_VALIDVALUE(dwAdvise);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_CHECK_VALIDVALUE(grfFilter);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveFileValidValues
	{
		/*[in]*/ VSCOOKIE dwAdvise;
		/*[in]*/ LPCOLESTR pszMkDocument;
		HRESULT retValue;
	};

	STDMETHOD(RemoveFile)(
		/*[in]*/ VSCOOKIE dwAdvise,
		/*[in]*/ LPCOLESTR pszMkDocument)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveFile)

		VSL_CHECK_VALIDVALUE(dwAdvise);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddDirectoryValidValues
	{
		/*[in]*/ VSCOOKIE dwAdvise;
		/*[in]*/ LPCOLESTR pszPath;
		/*[in]*/ BOOL fWatchSubDir;
		/*[in]*/ VSFILECHANGEFLAGS grfFilter;
		HRESULT retValue;
	};

	STDMETHOD(AddDirectory)(
		/*[in]*/ VSCOOKIE dwAdvise,
		/*[in]*/ LPCOLESTR pszPath,
		/*[in]*/ BOOL fWatchSubDir,
		/*[in]*/ VSFILECHANGEFLAGS grfFilter)
	{
		VSL_DEFINE_MOCK_METHOD(AddDirectory)

		VSL_CHECK_VALIDVALUE(dwAdvise);

		VSL_CHECK_VALIDVALUE_STRINGW(pszPath);

		VSL_CHECK_VALIDVALUE(fWatchSubDir);

		VSL_CHECK_VALIDVALUE(grfFilter);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveDirectoryValidValues
	{
		/*[in]*/ VSCOOKIE dwAdvise;
		/*[in]*/ LPCOLESTR pszMkDocument;
		HRESULT retValue;
	};

	STDMETHOD(RemoveDirectory)(
		/*[in]*/ VSCOOKIE dwAdvise,
		/*[in]*/ LPCOLESTR pszMkDocument)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveDirectory)

		VSL_CHECK_VALIDVALUE(dwAdvise);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_RETURN_VALIDVALUES();
	}
	struct SyncFileValidValues
	{
		/*[in]*/ LPCOLESTR pszMkDocument;
		HRESULT retValue;
	};

	STDMETHOD(SyncFile)(
		/*[in]*/ LPCOLESTR pszMkDocument)
	{
		VSL_DEFINE_MOCK_METHOD(SyncFile)

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_RETURN_VALIDVALUES();
	}
	struct IgnoreFileValidValues
	{
		/*[in]*/ VSCOOKIE dwAdvise;
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[in]*/ BOOL fIgnore;
		HRESULT retValue;
	};

	STDMETHOD(IgnoreFile)(
		/*[in]*/ VSCOOKIE dwAdvise,
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[in]*/ BOOL fIgnore)
	{
		VSL_DEFINE_MOCK_METHOD(IgnoreFile)

		VSL_CHECK_VALIDVALUE(dwAdvise);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_CHECK_VALIDVALUE(fIgnore);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSFILECHANGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsFileChangeEx.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSFILECHANGEEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSFILECHANGEEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsFileChangeExNotImpl :
	public IVsFileChangeEx
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFileChangeExNotImpl)

public:

	typedef IVsFileChangeEx Interface;

	STDMETHOD(AdviseFileChange)(
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[in]*/ VSFILECHANGEFLAGS /*grfFilter*/,
		/*[in]*/ IVsFileChangeEvents* /*pFCE*/,
		/*[out]*/ VSCOOKIE* /*pvsCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseFileChange)(
		/*[in]*/ VSCOOKIE /*vsCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SyncFile)(
		/*[in]*/ LPCOLESTR /*pszMkDocument*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IgnoreFile)(
		/*[in]*/ VSCOOKIE /*vsCookie*/,
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[in]*/ BOOL /*fIgnore*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AdviseDirChange)(
		/*[in]*/ LPCOLESTR /*pszDir*/,
		/*[in]*/ BOOL /*fWatchSubDir*/,
		/*[in]*/ IVsFileChangeEvents* /*pFCE*/,
		/*[out]*/ VSCOOKIE* /*pvsCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseDirChange)(
		/*[in]*/ VSCOOKIE /*vsCookie*/)VSL_STDMETHOD_NOTIMPL
};

class IVsFileChangeExMockImpl :
	public IVsFileChangeEx,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFileChangeExMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsFileChangeExMockImpl)

	typedef IVsFileChangeEx Interface;
	struct AdviseFileChangeValidValues
	{
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[in]*/ VSFILECHANGEFLAGS grfFilter;
		/*[in]*/ IVsFileChangeEvents* pFCE;
		/*[out]*/ VSCOOKIE* pvsCookie;
		HRESULT retValue;
	};

	STDMETHOD(AdviseFileChange)(
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[in]*/ VSFILECHANGEFLAGS grfFilter,
		/*[in]*/ IVsFileChangeEvents* pFCE,
		/*[out]*/ VSCOOKIE* pvsCookie)
	{
		VSL_DEFINE_MOCK_METHOD(AdviseFileChange)

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_CHECK_VALIDVALUE(grfFilter);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pFCE);

		VSL_SET_VALIDVALUE(pvsCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseFileChangeValidValues
	{
		/*[in]*/ VSCOOKIE vsCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnadviseFileChange)(
		/*[in]*/ VSCOOKIE vsCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnadviseFileChange)

		VSL_CHECK_VALIDVALUE(vsCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct SyncFileValidValues
	{
		/*[in]*/ LPCOLESTR pszMkDocument;
		HRESULT retValue;
	};

	STDMETHOD(SyncFile)(
		/*[in]*/ LPCOLESTR pszMkDocument)
	{
		VSL_DEFINE_MOCK_METHOD(SyncFile)

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_RETURN_VALIDVALUES();
	}
	struct IgnoreFileValidValues
	{
		/*[in]*/ VSCOOKIE vsCookie;
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[in]*/ BOOL fIgnore;
		HRESULT retValue;
	};

	STDMETHOD(IgnoreFile)(
		/*[in]*/ VSCOOKIE vsCookie,
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[in]*/ BOOL fIgnore)
	{
		VSL_DEFINE_MOCK_METHOD(IgnoreFile)

		VSL_CHECK_VALIDVALUE(vsCookie);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_CHECK_VALIDVALUE(fIgnore);

		VSL_RETURN_VALIDVALUES();
	}
	struct AdviseDirChangeValidValues
	{
		/*[in]*/ LPCOLESTR pszDir;
		/*[in]*/ BOOL fWatchSubDir;
		/*[in]*/ IVsFileChangeEvents* pFCE;
		/*[out]*/ VSCOOKIE* pvsCookie;
		HRESULT retValue;
	};

	STDMETHOD(AdviseDirChange)(
		/*[in]*/ LPCOLESTR pszDir,
		/*[in]*/ BOOL fWatchSubDir,
		/*[in]*/ IVsFileChangeEvents* pFCE,
		/*[out]*/ VSCOOKIE* pvsCookie)
	{
		VSL_DEFINE_MOCK_METHOD(AdviseDirChange)

		VSL_CHECK_VALIDVALUE_STRINGW(pszDir);

		VSL_CHECK_VALIDVALUE(fWatchSubDir);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pFCE);

		VSL_SET_VALIDVALUE(pvsCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseDirChangeValidValues
	{
		/*[in]*/ VSCOOKIE vsCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnadviseDirChange)(
		/*[in]*/ VSCOOKIE vsCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnadviseDirChange)

		VSL_CHECK_VALIDVALUE(vsCookie);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSFILECHANGEEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsFileExtensionMappingEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSFILEEXTENSIONMAPPINGEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSFILEEXTENSIONMAPPINGEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsFileExtensionMappingEventsNotImpl :
	public IVsFileExtensionMappingEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFileExtensionMappingEventsNotImpl)

public:

	typedef IVsFileExtensionMappingEvents Interface;

	STDMETHOD(OnFileExtensionsReset)()VSL_STDMETHOD_NOTIMPL
};

class IVsFileExtensionMappingEventsMockImpl :
	public IVsFileExtensionMappingEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFileExtensionMappingEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsFileExtensionMappingEventsMockImpl)

	typedef IVsFileExtensionMappingEvents Interface;
	struct OnFileExtensionsResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnFileExtensionsReset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnFileExtensionsReset)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSFILEEXTENSIONMAPPINGEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsFileChangeEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSFILECHANGEEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSFILECHANGEEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsFileChangeEventsNotImpl :
	public IVsFileChangeEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFileChangeEventsNotImpl)

public:

	typedef IVsFileChangeEvents Interface;

	STDMETHOD(FilesChanged)(
		/*[in]*/ DWORD /*cChanges*/,
		/*[in,size_is(cChanges)]*/ LPCOLESTR[] /*rgpszFile*/,
		/*[in,size_is(cChanges)]*/ VSFILECHANGEFLAGS[] /*rggrfChange*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DirectoryChanged)(
		/*[in]*/ LPCOLESTR /*pszDirectory*/)VSL_STDMETHOD_NOTIMPL
};

class IVsFileChangeEventsMockImpl :
	public IVsFileChangeEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFileChangeEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsFileChangeEventsMockImpl)

	typedef IVsFileChangeEvents Interface;
	struct FilesChangedValidValues
	{
		/*[in]*/ DWORD cChanges;
		/*[in,size_is(cChanges)]*/ LPCOLESTR* rgpszFile;
		/*[in,size_is(cChanges)]*/ VSFILECHANGEFLAGS* rggrfChange;
		HRESULT retValue;
	};

	STDMETHOD(FilesChanged)(
		/*[in]*/ DWORD cChanges,
		/*[in,size_is(cChanges)]*/ LPCOLESTR rgpszFile[],
		/*[in,size_is(cChanges)]*/ VSFILECHANGEFLAGS rggrfChange[])
	{
		VSL_DEFINE_MOCK_METHOD(FilesChanged)

		VSL_CHECK_VALIDVALUE(cChanges);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszFile, cChanges*sizeof(rgpszFile[0]), validValues.cChanges*sizeof(validValues.rgpszFile[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rggrfChange, cChanges*sizeof(rggrfChange[0]), validValues.cChanges*sizeof(validValues.rggrfChange[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct DirectoryChangedValidValues
	{
		/*[in]*/ LPCOLESTR pszDirectory;
		HRESULT retValue;
	};

	STDMETHOD(DirectoryChanged)(
		/*[in]*/ LPCOLESTR pszDirectory)
	{
		VSL_DEFINE_MOCK_METHOD(DirectoryChanged)

		VSL_CHECK_VALIDVALUE_STRINGW(pszDirectory);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSFILECHANGEEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsFileBackup.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSFILEBACKUP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSFILEBACKUP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsFileBackupNotImpl :
	public IVsFileBackup
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFileBackupNotImpl)

public:

	typedef IVsFileBackup Interface;

	STDMETHOD(BackupFile)(
		/*[in]*/ LPCOLESTR /*pszBackupFileName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsBackupFileObsolete)(
		/*[out]*/ BOOL* /*pbObsolete*/)VSL_STDMETHOD_NOTIMPL
};

class IVsFileBackupMockImpl :
	public IVsFileBackup,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFileBackupMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsFileBackupMockImpl)

	typedef IVsFileBackup Interface;
	struct BackupFileValidValues
	{
		/*[in]*/ LPCOLESTR pszBackupFileName;
		HRESULT retValue;
	};

	STDMETHOD(BackupFile)(
		/*[in]*/ LPCOLESTR pszBackupFileName)
	{
		VSL_DEFINE_MOCK_METHOD(BackupFile)

		VSL_CHECK_VALIDVALUE_STRINGW(pszBackupFileName);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsBackupFileObsoleteValidValues
	{
		/*[out]*/ BOOL* pbObsolete;
		HRESULT retValue;
	};

	STDMETHOD(IsBackupFileObsolete)(
		/*[out]*/ BOOL* pbObsolete)
	{
		VSL_DEFINE_MOCK_METHOD(IsBackupFileObsolete)

		VSL_SET_VALIDVALUE(pbObsolete);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSFILEBACKUP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsFilterAddProjectItemDlg.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSFILTERADDPROJECTITEMDLG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSFILTERADDPROJECTITEMDLG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsFilterAddProjectItemDlgNotImpl :
	public IVsFilterAddProjectItemDlg
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFilterAddProjectItemDlgNotImpl)

public:

	typedef IVsFilterAddProjectItemDlg Interface;

	STDMETHOD(FilterTreeItemByLocalizedName)(
		/*[in]*/ REFGUID /*rguidProjectItemTemplates*/,
		/*[in]*/ LPCOLESTR /*pszLocalizedName*/,
		/*[out]*/ BOOL* /*pfFilter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FilterTreeItemByTemplateDir)(
		/*[in]*/ REFGUID /*rguidProjectItemTemplates*/,
		/*[in]*/ LPCOLESTR /*pszTemplateDir*/,
		/*[out]*/ BOOL* /*pfFilter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FilterListItemByLocalizedName)(
		/*[in]*/ REFGUID /*rguidProjectItemTemplates*/,
		/*[in]*/ LPCOLESTR /*pszLocalizedName*/,
		/*[out]*/ BOOL* /*pfFilter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FilterListItemByTemplateFile)(
		/*[in]*/ REFGUID /*rguidProjectItemTemplates*/,
		/*[in]*/ LPCOLESTR /*pszTemplateFile*/,
		/*[out]*/ BOOL* /*pfFilter*/)VSL_STDMETHOD_NOTIMPL
};

class IVsFilterAddProjectItemDlgMockImpl :
	public IVsFilterAddProjectItemDlg,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFilterAddProjectItemDlgMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsFilterAddProjectItemDlgMockImpl)

	typedef IVsFilterAddProjectItemDlg Interface;
	struct FilterTreeItemByLocalizedNameValidValues
	{
		/*[in]*/ REFGUID rguidProjectItemTemplates;
		/*[in]*/ LPCOLESTR pszLocalizedName;
		/*[out]*/ BOOL* pfFilter;
		HRESULT retValue;
	};

	STDMETHOD(FilterTreeItemByLocalizedName)(
		/*[in]*/ REFGUID rguidProjectItemTemplates,
		/*[in]*/ LPCOLESTR pszLocalizedName,
		/*[out]*/ BOOL* pfFilter)
	{
		VSL_DEFINE_MOCK_METHOD(FilterTreeItemByLocalizedName)

		VSL_CHECK_VALIDVALUE(rguidProjectItemTemplates);

		VSL_CHECK_VALIDVALUE_STRINGW(pszLocalizedName);

		VSL_SET_VALIDVALUE(pfFilter);

		VSL_RETURN_VALIDVALUES();
	}
	struct FilterTreeItemByTemplateDirValidValues
	{
		/*[in]*/ REFGUID rguidProjectItemTemplates;
		/*[in]*/ LPCOLESTR pszTemplateDir;
		/*[out]*/ BOOL* pfFilter;
		HRESULT retValue;
	};

	STDMETHOD(FilterTreeItemByTemplateDir)(
		/*[in]*/ REFGUID rguidProjectItemTemplates,
		/*[in]*/ LPCOLESTR pszTemplateDir,
		/*[out]*/ BOOL* pfFilter)
	{
		VSL_DEFINE_MOCK_METHOD(FilterTreeItemByTemplateDir)

		VSL_CHECK_VALIDVALUE(rguidProjectItemTemplates);

		VSL_CHECK_VALIDVALUE_STRINGW(pszTemplateDir);

		VSL_SET_VALIDVALUE(pfFilter);

		VSL_RETURN_VALIDVALUES();
	}
	struct FilterListItemByLocalizedNameValidValues
	{
		/*[in]*/ REFGUID rguidProjectItemTemplates;
		/*[in]*/ LPCOLESTR pszLocalizedName;
		/*[out]*/ BOOL* pfFilter;
		HRESULT retValue;
	};

	STDMETHOD(FilterListItemByLocalizedName)(
		/*[in]*/ REFGUID rguidProjectItemTemplates,
		/*[in]*/ LPCOLESTR pszLocalizedName,
		/*[out]*/ BOOL* pfFilter)
	{
		VSL_DEFINE_MOCK_METHOD(FilterListItemByLocalizedName)

		VSL_CHECK_VALIDVALUE(rguidProjectItemTemplates);

		VSL_CHECK_VALIDVALUE_STRINGW(pszLocalizedName);

		VSL_SET_VALIDVALUE(pfFilter);

		VSL_RETURN_VALIDVALUES();
	}
	struct FilterListItemByTemplateFileValidValues
	{
		/*[in]*/ REFGUID rguidProjectItemTemplates;
		/*[in]*/ LPCOLESTR pszTemplateFile;
		/*[out]*/ BOOL* pfFilter;
		HRESULT retValue;
	};

	STDMETHOD(FilterListItemByTemplateFile)(
		/*[in]*/ REFGUID rguidProjectItemTemplates,
		/*[in]*/ LPCOLESTR pszTemplateFile,
		/*[out]*/ BOOL* pfFilter)
	{
		VSL_DEFINE_MOCK_METHOD(FilterListItemByTemplateFile)

		VSL_CHECK_VALIDVALUE(rguidProjectItemTemplates);

		VSL_CHECK_VALIDVALUE_STRINGW(pszTemplateFile);

		VSL_SET_VALIDVALUE(pfFilter);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSFILTERADDPROJECTITEMDLG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsFileUpgrade.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSFILEUPGRADE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSFILEUPGRADE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsFileUpgradeNotImpl :
	public IVsFileUpgrade
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFileUpgradeNotImpl)

public:

	typedef IVsFileUpgrade Interface;

	STDMETHOD(UpgradeFile)(
		/*[in]*/ BSTR /*bstrProjectName*/,
		/*[in]*/ BSTR /*bstrFileName*/,
		/*[in]*/ BOOL /*bNoBackup*/,
		/*[in]*/ IVsUpgradeLogger* /*pLogger*/,
		/*[out]*/ BOOL* /*pUpgradeRequired*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpgradeFile_CheckOnly)(
		/*[in]*/ BSTR /*bstrProjectName*/,
		/*[in]*/ BSTR /*bstrFileName*/,
		/*[in]*/ BOOL /*bNoBackup*/,
		/*[in]*/ IVsUpgradeLogger* /*pLogger*/,
		/*[out]*/ BOOL* /*pUpgradeRequired*/)VSL_STDMETHOD_NOTIMPL
};

class IVsFileUpgradeMockImpl :
	public IVsFileUpgrade,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFileUpgradeMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsFileUpgradeMockImpl)

	typedef IVsFileUpgrade Interface;
	struct UpgradeFileValidValues
	{
		/*[in]*/ BSTR bstrProjectName;
		/*[in]*/ BSTR bstrFileName;
		/*[in]*/ BOOL bNoBackup;
		/*[in]*/ IVsUpgradeLogger* pLogger;
		/*[out]*/ BOOL* pUpgradeRequired;
		HRESULT retValue;
	};

	STDMETHOD(UpgradeFile)(
		/*[in]*/ BSTR bstrProjectName,
		/*[in]*/ BSTR bstrFileName,
		/*[in]*/ BOOL bNoBackup,
		/*[in]*/ IVsUpgradeLogger* pLogger,
		/*[out]*/ BOOL* pUpgradeRequired)
	{
		VSL_DEFINE_MOCK_METHOD(UpgradeFile)

		VSL_CHECK_VALIDVALUE_BSTR(bstrProjectName);

		VSL_CHECK_VALIDVALUE_BSTR(bstrFileName);

		VSL_CHECK_VALIDVALUE(bNoBackup);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pLogger);

		VSL_SET_VALIDVALUE(pUpgradeRequired);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpgradeFile_CheckOnlyValidValues
	{
		/*[in]*/ BSTR bstrProjectName;
		/*[in]*/ BSTR bstrFileName;
		/*[in]*/ BOOL bNoBackup;
		/*[in]*/ IVsUpgradeLogger* pLogger;
		/*[out]*/ BOOL* pUpgradeRequired;
		HRESULT retValue;
	};

	STDMETHOD(UpgradeFile_CheckOnly)(
		/*[in]*/ BSTR bstrProjectName,
		/*[in]*/ BSTR bstrFileName,
		/*[in]*/ BOOL bNoBackup,
		/*[in]*/ IVsUpgradeLogger* pLogger,
		/*[out]*/ BOOL* pUpgradeRequired)
	{
		VSL_DEFINE_MOCK_METHOD(UpgradeFile_CheckOnly)

		VSL_CHECK_VALIDVALUE_BSTR(bstrProjectName);

		VSL_CHECK_VALIDVALUE_BSTR(bstrFileName);

		VSL_CHECK_VALIDVALUE(bNoBackup);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pLogger);

		VSL_SET_VALIDVALUE(pUpgradeRequired);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSFILEUPGRADE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsFilterAddProjectItemDlg2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSFILTERADDPROJECTITEMDLG2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSFILTERADDPROJECTITEMDLG2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsFilterAddProjectItemDlg2NotImpl :
	public IVsFilterAddProjectItemDlg2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFilterAddProjectItemDlg2NotImpl)

public:

	typedef IVsFilterAddProjectItemDlg2 Interface;

	STDMETHOD(FilterTreeItemByCategory)(
		/*[in]*/ REFGUID /*rguidProjectItemTemplates*/,
		/*[in]*/ LPCOLESTR /*pszCategoryName*/,
		/*[out]*/ BOOL* /*pfFilter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FilterListItemByCategory)(
		/*[in]*/ REFGUID /*rguidProjectItemTemplates*/,
		/*[in]*/ LPCOLESTR /*pszCategoryName*/,
		/*[out]*/ BOOL* /*pfFilter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FilterTreeItemByLocalizedName)(
		/*[in]*/ REFGUID /*rguidProjectItemTemplates*/,
		/*[in]*/ LPCOLESTR /*pszLocalizedName*/,
		/*[out]*/ BOOL* /*pfFilter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FilterTreeItemByTemplateDir)(
		/*[in]*/ REFGUID /*rguidProjectItemTemplates*/,
		/*[in]*/ LPCOLESTR /*pszTemplateDir*/,
		/*[out]*/ BOOL* /*pfFilter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FilterListItemByLocalizedName)(
		/*[in]*/ REFGUID /*rguidProjectItemTemplates*/,
		/*[in]*/ LPCOLESTR /*pszLocalizedName*/,
		/*[out]*/ BOOL* /*pfFilter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FilterListItemByTemplateFile)(
		/*[in]*/ REFGUID /*rguidProjectItemTemplates*/,
		/*[in]*/ LPCOLESTR /*pszTemplateFile*/,
		/*[out]*/ BOOL* /*pfFilter*/)VSL_STDMETHOD_NOTIMPL
};

class IVsFilterAddProjectItemDlg2MockImpl :
	public IVsFilterAddProjectItemDlg2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFilterAddProjectItemDlg2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsFilterAddProjectItemDlg2MockImpl)

	typedef IVsFilterAddProjectItemDlg2 Interface;
	struct FilterTreeItemByCategoryValidValues
	{
		/*[in]*/ REFGUID rguidProjectItemTemplates;
		/*[in]*/ LPCOLESTR pszCategoryName;
		/*[out]*/ BOOL* pfFilter;
		HRESULT retValue;
	};

	STDMETHOD(FilterTreeItemByCategory)(
		/*[in]*/ REFGUID rguidProjectItemTemplates,
		/*[in]*/ LPCOLESTR pszCategoryName,
		/*[out]*/ BOOL* pfFilter)
	{
		VSL_DEFINE_MOCK_METHOD(FilterTreeItemByCategory)

		VSL_CHECK_VALIDVALUE(rguidProjectItemTemplates);

		VSL_CHECK_VALIDVALUE_STRINGW(pszCategoryName);

		VSL_SET_VALIDVALUE(pfFilter);

		VSL_RETURN_VALIDVALUES();
	}
	struct FilterListItemByCategoryValidValues
	{
		/*[in]*/ REFGUID rguidProjectItemTemplates;
		/*[in]*/ LPCOLESTR pszCategoryName;
		/*[out]*/ BOOL* pfFilter;
		HRESULT retValue;
	};

	STDMETHOD(FilterListItemByCategory)(
		/*[in]*/ REFGUID rguidProjectItemTemplates,
		/*[in]*/ LPCOLESTR pszCategoryName,
		/*[out]*/ BOOL* pfFilter)
	{
		VSL_DEFINE_MOCK_METHOD(FilterListItemByCategory)

		VSL_CHECK_VALIDVALUE(rguidProjectItemTemplates);

		VSL_CHECK_VALIDVALUE_STRINGW(pszCategoryName);

		VSL_SET_VALIDVALUE(pfFilter);

		VSL_RETURN_VALIDVALUES();
	}
	struct FilterTreeItemByLocalizedNameValidValues
	{
		/*[in]*/ REFGUID rguidProjectItemTemplates;
		/*[in]*/ LPCOLESTR pszLocalizedName;
		/*[out]*/ BOOL* pfFilter;
		HRESULT retValue;
	};

	STDMETHOD(FilterTreeItemByLocalizedName)(
		/*[in]*/ REFGUID rguidProjectItemTemplates,
		/*[in]*/ LPCOLESTR pszLocalizedName,
		/*[out]*/ BOOL* pfFilter)
	{
		VSL_DEFINE_MOCK_METHOD(FilterTreeItemByLocalizedName)

		VSL_CHECK_VALIDVALUE(rguidProjectItemTemplates);

		VSL_CHECK_VALIDVALUE_STRINGW(pszLocalizedName);

		VSL_SET_VALIDVALUE(pfFilter);

		VSL_RETURN_VALIDVALUES();
	}
	struct FilterTreeItemByTemplateDirValidValues
	{
		/*[in]*/ REFGUID rguidProjectItemTemplates;
		/*[in]*/ LPCOLESTR pszTemplateDir;
		/*[out]*/ BOOL* pfFilter;
		HRESULT retValue;
	};

	STDMETHOD(FilterTreeItemByTemplateDir)(
		/*[in]*/ REFGUID rguidProjectItemTemplates,
		/*[in]*/ LPCOLESTR pszTemplateDir,
		/*[out]*/ BOOL* pfFilter)
	{
		VSL_DEFINE_MOCK_METHOD(FilterTreeItemByTemplateDir)

		VSL_CHECK_VALIDVALUE(rguidProjectItemTemplates);

		VSL_CHECK_VALIDVALUE_STRINGW(pszTemplateDir);

		VSL_SET_VALIDVALUE(pfFilter);

		VSL_RETURN_VALIDVALUES();
	}
	struct FilterListItemByLocalizedNameValidValues
	{
		/*[in]*/ REFGUID rguidProjectItemTemplates;
		/*[in]*/ LPCOLESTR pszLocalizedName;
		/*[out]*/ BOOL* pfFilter;
		HRESULT retValue;
	};

	STDMETHOD(FilterListItemByLocalizedName)(
		/*[in]*/ REFGUID rguidProjectItemTemplates,
		/*[in]*/ LPCOLESTR pszLocalizedName,
		/*[out]*/ BOOL* pfFilter)
	{
		VSL_DEFINE_MOCK_METHOD(FilterListItemByLocalizedName)

		VSL_CHECK_VALIDVALUE(rguidProjectItemTemplates);

		VSL_CHECK_VALIDVALUE_STRINGW(pszLocalizedName);

		VSL_SET_VALIDVALUE(pfFilter);

		VSL_RETURN_VALIDVALUES();
	}
	struct FilterListItemByTemplateFileValidValues
	{
		/*[in]*/ REFGUID rguidProjectItemTemplates;
		/*[in]*/ LPCOLESTR pszTemplateFile;
		/*[out]*/ BOOL* pfFilter;
		HRESULT retValue;
	};

	STDMETHOD(FilterListItemByTemplateFile)(
		/*[in]*/ REFGUID rguidProjectItemTemplates,
		/*[in]*/ LPCOLESTR pszTemplateFile,
		/*[out]*/ BOOL* pfFilter)
	{
		VSL_DEFINE_MOCK_METHOD(FilterListItemByTemplateFile)

		VSL_CHECK_VALIDVALUE(rguidProjectItemTemplates);

		VSL_CHECK_VALIDVALUE_STRINGW(pszTemplateFile);

		VSL_SET_VALIDVALUE(pfFilter);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSFILTERADDPROJECTITEMDLG2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsFindScope.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSFINDSCOPE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSFINDSCOPE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textfind.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsFindScopeNotImpl :
	public IVsFindScope
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFindScopeNotImpl)

public:

	typedef IVsFindScope Interface;

	STDMETHOD(GetUIName)(
		/*[out,retval]*/ BSTR* /*pbsName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetQuery)(
		/*[out]*/ BSTR* /*pbstrBaseDirectory*/,
		/*[out,retval]*/ BSTR* /*pbstrQuery*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumFilenames)(
		/*[out,retval]*/ IEnumString** /*ppEnumString*/)VSL_STDMETHOD_NOTIMPL
};

class IVsFindScopeMockImpl :
	public IVsFindScope,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFindScopeMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsFindScopeMockImpl)

	typedef IVsFindScope Interface;
	struct GetUINameValidValues
	{
		/*[out,retval]*/ BSTR* pbsName;
		HRESULT retValue;
	};

	STDMETHOD(GetUIName)(
		/*[out,retval]*/ BSTR* pbsName)
	{
		VSL_DEFINE_MOCK_METHOD(GetUIName)

		VSL_SET_VALIDVALUE_BSTR(pbsName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetQueryValidValues
	{
		/*[out]*/ BSTR* pbstrBaseDirectory;
		/*[out,retval]*/ BSTR* pbstrQuery;
		HRESULT retValue;
	};

	STDMETHOD(GetQuery)(
		/*[out]*/ BSTR* pbstrBaseDirectory,
		/*[out,retval]*/ BSTR* pbstrQuery)
	{
		VSL_DEFINE_MOCK_METHOD(GetQuery)

		VSL_SET_VALIDVALUE_BSTR(pbstrBaseDirectory);

		VSL_SET_VALIDVALUE_BSTR(pbstrQuery);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumFilenamesValidValues
	{
		/*[out,retval]*/ IEnumString** ppEnumString;
		HRESULT retValue;
	};

	STDMETHOD(EnumFilenames)(
		/*[out,retval]*/ IEnumString** ppEnumString)
	{
		VSL_DEFINE_MOCK_METHOD(EnumFilenames)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnumString);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSFINDSCOPE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsFindCancelDialog.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSFINDCANCELDIALOG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSFINDCANCELDIALOG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textfind2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsFindCancelDialogNotImpl :
	public IVsFindCancelDialog
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFindCancelDialogNotImpl)

public:

	typedef IVsFindCancelDialog Interface;

	STDMETHOD(LaunchDialog)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryDialog)(
		/*[out]*/ BOOL* /*pfCancel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CloseDialog)()VSL_STDMETHOD_NOTIMPL
};

class IVsFindCancelDialogMockImpl :
	public IVsFindCancelDialog,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFindCancelDialogMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsFindCancelDialogMockImpl)

	typedef IVsFindCancelDialog Interface;
	struct LaunchDialogValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(LaunchDialog)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(LaunchDialog)

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryDialogValidValues
	{
		/*[out]*/ BOOL* pfCancel;
		HRESULT retValue;
	};

	STDMETHOD(QueryDialog)(
		/*[out]*/ BOOL* pfCancel)
	{
		VSL_DEFINE_MOCK_METHOD(QueryDialog)

		VSL_SET_VALIDVALUE(pfCancel);

		VSL_RETURN_VALIDVALUES();
	}
	struct CloseDialogValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CloseDialog)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CloseDialog)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSFINDCANCELDIALOG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsFinder.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSFINDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSFINDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textfind.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsFinderNotImpl :
	public IVsFinder
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFinderNotImpl)

public:

	typedef IVsFinder Interface;

	STDMETHOD(AttachTextImage)(
		/*[in]*/ IUnknown* /*pTextImage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Detach)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetScope)(
		/*[in]*/ IVsTextSpanSet* /*pSpanScope*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Init)(
		/*[in]*/ DWORD /*grfOptions*/,
		/*[in]*/ LPCOLESTR /*pszFindPattern*/,
		/*[in]*/ BOOL /*fReinit*/,
		/*[out,retval]*/ VSFINDERROR* /*pResult*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetPosition)(
		/*[in]*/ VSFINDPOS /*fp*/,
		/*[in]*/ TextAddress /*ta*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Find)(
		/*[in]*/ VSFINDHOW /*grfFindHow*/,
		/*[in,out]*/ TextSpan* /*ptsMatch*/,
		/*[out,retval]*/ VSFINDSTATE* /*pgrfResult*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMatch)(
		/*[out,retval]*/ TextSpan* /*pts*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMatchedSpans)(
		/*[out,retval]*/ IVsTextSpanSet** /*ppSpans*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTaggedSpans)(
		/*[out,retval]*/ IVsTextSpanSet** /*ppTags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetState)(
		/*[out]*/ LONG* /*pcFound*/,
		/*[out]*/ VSFINDERROR* /*pResult*/,
		/*[out,retval]*/ VSFINDSTATE* /*pState*/)VSL_STDMETHOD_NOTIMPL
};

class IVsFinderMockImpl :
	public IVsFinder,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFinderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsFinderMockImpl)

	typedef IVsFinder Interface;
	struct AttachTextImageValidValues
	{
		/*[in]*/ IUnknown* pTextImage;
		HRESULT retValue;
	};

	STDMETHOD(AttachTextImage)(
		/*[in]*/ IUnknown* pTextImage)
	{
		VSL_DEFINE_MOCK_METHOD(AttachTextImage)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pTextImage);

		VSL_RETURN_VALIDVALUES();
	}
	struct DetachValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Detach)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Detach)

		VSL_RETURN_VALIDVALUES();
	}
	struct SetScopeValidValues
	{
		/*[in]*/ IVsTextSpanSet* pSpanScope;
		HRESULT retValue;
	};

	STDMETHOD(SetScope)(
		/*[in]*/ IVsTextSpanSet* pSpanScope)
	{
		VSL_DEFINE_MOCK_METHOD(SetScope)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSpanScope);

		VSL_RETURN_VALIDVALUES();
	}
	struct InitValidValues
	{
		/*[in]*/ DWORD grfOptions;
		/*[in]*/ LPCOLESTR pszFindPattern;
		/*[in]*/ BOOL fReinit;
		/*[out,retval]*/ VSFINDERROR* pResult;
		HRESULT retValue;
	};

	STDMETHOD(Init)(
		/*[in]*/ DWORD grfOptions,
		/*[in]*/ LPCOLESTR pszFindPattern,
		/*[in]*/ BOOL fReinit,
		/*[out,retval]*/ VSFINDERROR* pResult)
	{
		VSL_DEFINE_MOCK_METHOD(Init)

		VSL_CHECK_VALIDVALUE(grfOptions);

		VSL_CHECK_VALIDVALUE_STRINGW(pszFindPattern);

		VSL_CHECK_VALIDVALUE(fReinit);

		VSL_SET_VALIDVALUE(pResult);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetPositionValidValues
	{
		/*[in]*/ VSFINDPOS fp;
		/*[in]*/ TextAddress ta;
		HRESULT retValue;
	};

	STDMETHOD(SetPosition)(
		/*[in]*/ VSFINDPOS fp,
		/*[in]*/ TextAddress ta)
	{
		VSL_DEFINE_MOCK_METHOD(SetPosition)

		VSL_CHECK_VALIDVALUE(fp);

		VSL_CHECK_VALIDVALUE(ta);

		VSL_RETURN_VALIDVALUES();
	}
	struct FindValidValues
	{
		/*[in]*/ VSFINDHOW grfFindHow;
		/*[in,out]*/ TextSpan* ptsMatch;
		/*[out,retval]*/ VSFINDSTATE* pgrfResult;
		HRESULT retValue;
	};

	STDMETHOD(Find)(
		/*[in]*/ VSFINDHOW grfFindHow,
		/*[in,out]*/ TextSpan* ptsMatch,
		/*[out,retval]*/ VSFINDSTATE* pgrfResult)
	{
		VSL_DEFINE_MOCK_METHOD(Find)

		VSL_CHECK_VALIDVALUE(grfFindHow);

		VSL_SET_VALIDVALUE(ptsMatch);

		VSL_SET_VALIDVALUE(pgrfResult);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMatchValidValues
	{
		/*[out,retval]*/ TextSpan* pts;
		HRESULT retValue;
	};

	STDMETHOD(GetMatch)(
		/*[out,retval]*/ TextSpan* pts)
	{
		VSL_DEFINE_MOCK_METHOD(GetMatch)

		VSL_SET_VALIDVALUE(pts);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMatchedSpansValidValues
	{
		/*[out,retval]*/ IVsTextSpanSet** ppSpans;
		HRESULT retValue;
	};

	STDMETHOD(GetMatchedSpans)(
		/*[out,retval]*/ IVsTextSpanSet** ppSpans)
	{
		VSL_DEFINE_MOCK_METHOD(GetMatchedSpans)

		VSL_SET_VALIDVALUE_INTERFACE(ppSpans);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTaggedSpansValidValues
	{
		/*[out,retval]*/ IVsTextSpanSet** ppTags;
		HRESULT retValue;
	};

	STDMETHOD(GetTaggedSpans)(
		/*[out,retval]*/ IVsTextSpanSet** ppTags)
	{
		VSL_DEFINE_MOCK_METHOD(GetTaggedSpans)

		VSL_SET_VALIDVALUE_INTERFACE(ppTags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetStateValidValues
	{
		/*[out]*/ LONG* pcFound;
		/*[out]*/ VSFINDERROR* pResult;
		/*[out,retval]*/ VSFINDSTATE* pState;
		HRESULT retValue;
	};

	STDMETHOD(GetState)(
		/*[out]*/ LONG* pcFound,
		/*[out]*/ VSFINDERROR* pResult,
		/*[out,retval]*/ VSFINDSTATE* pState)
	{
		VSL_DEFINE_MOCK_METHOD(GetState)

		VSL_SET_VALIDVALUE(pcFound);

		VSL_SET_VALIDVALUE(pResult);

		VSL_SET_VALIDVALUE(pState);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSFINDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsFindHelper.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSFINDHELPER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSFINDHELPER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textfind.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsFindHelperNotImpl :
	public IVsFindHelper
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFindHelperNotImpl)

public:

	typedef IVsFindHelper Interface;

	STDMETHOD(FindInText)(
		/*[in]*/ LPCOLESTR /*pszFind*/,
		/*[in]*/ LPCOLESTR /*pszReplace*/,
		/*[in]*/ VSFINDOPTIONS /*grfFindOptions*/,
		/*[in]*/ VSFINDBUFFERFLAGS /*grfBufferFlags*/,
		/*[in]*/ ULONG /*cchText*/,
		/*[in,size_is(cchText)]*/ LPCOLESTR /*pchText*/,
		/*[out]*/ ULONG* /*piFound*/,
		/*[out]*/ ULONG* /*pcchFound*/,
		/*[out]*/ BSTR* /*pbstrReplaceText*/,
		/*[out,retval]*/ BOOL* /*pfFound*/)VSL_STDMETHOD_NOTIMPL
};

class IVsFindHelperMockImpl :
	public IVsFindHelper,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFindHelperMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsFindHelperMockImpl)

	typedef IVsFindHelper Interface;
	struct FindInTextValidValues
	{
		/*[in]*/ LPCOLESTR pszFind;
		/*[in]*/ LPCOLESTR pszReplace;
		/*[in]*/ VSFINDOPTIONS grfFindOptions;
		/*[in]*/ VSFINDBUFFERFLAGS grfBufferFlags;
		/*[in]*/ ULONG cchText;
		/*[in,size_is(cchText)]*/ LPCOLESTR pchText;
		/*[out]*/ ULONG* piFound;
		/*[out]*/ ULONG* pcchFound;
		/*[out]*/ BSTR* pbstrReplaceText;
		/*[out,retval]*/ BOOL* pfFound;
		HRESULT retValue;
	};

	STDMETHOD(FindInText)(
		/*[in]*/ LPCOLESTR pszFind,
		/*[in]*/ LPCOLESTR pszReplace,
		/*[in]*/ VSFINDOPTIONS grfFindOptions,
		/*[in]*/ VSFINDBUFFERFLAGS grfBufferFlags,
		/*[in]*/ ULONG cchText,
		/*[in,size_is(cchText)]*/ LPCOLESTR pchText,
		/*[out]*/ ULONG* piFound,
		/*[out]*/ ULONG* pcchFound,
		/*[out]*/ BSTR* pbstrReplaceText,
		/*[out,retval]*/ BOOL* pfFound)
	{
		VSL_DEFINE_MOCK_METHOD(FindInText)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFind);

		VSL_CHECK_VALIDVALUE_STRINGW(pszReplace);

		VSL_CHECK_VALIDVALUE(grfFindOptions);

		VSL_CHECK_VALIDVALUE(grfBufferFlags);

		VSL_CHECK_VALIDVALUE(cchText);

		VSL_CHECK_VALIDVALUE_STRINGW(pchText);

		VSL_SET_VALIDVALUE(piFound);

		VSL_SET_VALIDVALUE(pcchFound);

		VSL_SET_VALIDVALUE_BSTR(pbstrReplaceText);

		VSL_SET_VALIDVALUE(pfFound);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSFINDHELPER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsFilterKeys2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSFILTERKEYS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSFILTERKEYS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsFilterKeys2NotImpl :
	public IVsFilterKeys2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFilterKeys2NotImpl)

public:

	typedef IVsFilterKeys2 Interface;

	STDMETHOD(TranslateAcceleratorEx)(
		/*[in]*/ LPMSG /*pMsg*/,
		/*[in]*/ VSTRANSACCELEXFLAGS /*dwFlags*/,
		/*[in]*/ DWORD /*cKeyBindingScopes*/,
		/*[in,size_is(cKeyBindingScopes)]*/ const GUID[] /*rgguidKeyBindingScopes*/,
		/*[out]*/ GUID* /*pguidCmd*/,
		/*[out]*/ DWORD* /*pdwCmd*/,
		/*[out]*/ BOOL* /*fCmdTranslated*/,
		/*[out]*/ BOOL* /*pfKeyComboStartsChord*/)VSL_STDMETHOD_NOTIMPL
};

class IVsFilterKeys2MockImpl :
	public IVsFilterKeys2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFilterKeys2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsFilterKeys2MockImpl)

	typedef IVsFilterKeys2 Interface;
	struct TranslateAcceleratorExValidValues
	{
		/*[in]*/ LPMSG pMsg;
		/*[in]*/ VSTRANSACCELEXFLAGS dwFlags;
		/*[in]*/ DWORD cKeyBindingScopes;
		/*[in,size_is(cKeyBindingScopes)]*/ GUID* rgguidKeyBindingScopes;
		/*[out]*/ GUID* pguidCmd;
		/*[out]*/ DWORD* pdwCmd;
		/*[out]*/ BOOL* fCmdTranslated;
		/*[out]*/ BOOL* pfKeyComboStartsChord;
		HRESULT retValue;
	};

	STDMETHOD(TranslateAcceleratorEx)(
		/*[in]*/ LPMSG pMsg,
		/*[in]*/ VSTRANSACCELEXFLAGS dwFlags,
		/*[in]*/ DWORD cKeyBindingScopes,
		/*[in,size_is(cKeyBindingScopes)]*/ const GUID rgguidKeyBindingScopes[],
		/*[out]*/ GUID* pguidCmd,
		/*[out]*/ DWORD* pdwCmd,
		/*[out]*/ BOOL* fCmdTranslated,
		/*[out]*/ BOOL* pfKeyComboStartsChord)
	{
		VSL_DEFINE_MOCK_METHOD(TranslateAcceleratorEx)

		VSL_CHECK_VALIDVALUE(pMsg);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE(cKeyBindingScopes);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgguidKeyBindingScopes, cKeyBindingScopes*sizeof(rgguidKeyBindingScopes[0]), validValues.cKeyBindingScopes*sizeof(validValues.rgguidKeyBindingScopes[0]));

		VSL_SET_VALIDVALUE(pguidCmd);

		VSL_SET_VALIDVALUE(pdwCmd);

		VSL_SET_VALIDVALUE(fCmdTranslated);

		VSL_SET_VALIDVALUE(pfKeyComboStartsChord);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSFILTERKEYS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsFilterKeys.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSFILTERKEYS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSFILTERKEYS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsFilterKeysNotImpl :
	public IVsFilterKeys
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFilterKeysNotImpl)

public:

	typedef IVsFilterKeys Interface;

	STDMETHOD(TranslateAccelerator)(
		/*[in]*/ LPMSG /*pMsg*/,
		/*[in]*/ VSTRANSACCELFLAGS /*dwFlags*/,
		/*[out]*/ GUID* /*pguidCmd*/,
		/*[out]*/ DWORD* /*pdwCmd*/)VSL_STDMETHOD_NOTIMPL
};

class IVsFilterKeysMockImpl :
	public IVsFilterKeys,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFilterKeysMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsFilterKeysMockImpl)

	typedef IVsFilterKeys Interface;
	struct TranslateAcceleratorValidValues
	{
		/*[in]*/ LPMSG pMsg;
		/*[in]*/ VSTRANSACCELFLAGS dwFlags;
		/*[out]*/ GUID* pguidCmd;
		/*[out]*/ DWORD* pdwCmd;
		HRESULT retValue;
	};

	STDMETHOD(TranslateAccelerator)(
		/*[in]*/ LPMSG pMsg,
		/*[in]*/ VSTRANSACCELFLAGS dwFlags,
		/*[out]*/ GUID* pguidCmd,
		/*[out]*/ DWORD* pdwCmd)
	{
		VSL_DEFINE_MOCK_METHOD(TranslateAccelerator)

		VSL_CHECK_VALIDVALUE(pMsg);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_SET_VALIDVALUE(pguidCmd);

		VSL_SET_VALIDVALUE(pdwCmd);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSFILTERKEYS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsFilterNewProjectDlg.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSFILTERNEWPROJECTDLG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSFILTERNEWPROJECTDLG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsFilterNewProjectDlgNotImpl :
	public IVsFilterNewProjectDlg
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFilterNewProjectDlgNotImpl)

public:

	typedef IVsFilterNewProjectDlg Interface;

	STDMETHOD(FilterTreeItemByLocalizedName)(
		/*[in]*/ LPCOLESTR /*pszLocalizedName*/,
		/*[out]*/ BOOL* /*pfFilter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FilterTreeItemByTemplateDir)(
		/*[in]*/ LPCOLESTR /*pszTemplateDir*/,
		/*[out]*/ BOOL* /*pfFilter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FilterListItemByLocalizedName)(
		/*[in]*/ LPCOLESTR /*pszLocalizedName*/,
		/*[out]*/ BOOL* /*pfFilter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FilterListItemByTemplateFile)(
		/*[in]*/ LPCOLESTR /*pszTemplateFile*/,
		/*[out]*/ BOOL* /*pfFilter*/)VSL_STDMETHOD_NOTIMPL
};

class IVsFilterNewProjectDlgMockImpl :
	public IVsFilterNewProjectDlg,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFilterNewProjectDlgMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsFilterNewProjectDlgMockImpl)

	typedef IVsFilterNewProjectDlg Interface;
	struct FilterTreeItemByLocalizedNameValidValues
	{
		/*[in]*/ LPCOLESTR pszLocalizedName;
		/*[out]*/ BOOL* pfFilter;
		HRESULT retValue;
	};

	STDMETHOD(FilterTreeItemByLocalizedName)(
		/*[in]*/ LPCOLESTR pszLocalizedName,
		/*[out]*/ BOOL* pfFilter)
	{
		VSL_DEFINE_MOCK_METHOD(FilterTreeItemByLocalizedName)

		VSL_CHECK_VALIDVALUE_STRINGW(pszLocalizedName);

		VSL_SET_VALIDVALUE(pfFilter);

		VSL_RETURN_VALIDVALUES();
	}
	struct FilterTreeItemByTemplateDirValidValues
	{
		/*[in]*/ LPCOLESTR pszTemplateDir;
		/*[out]*/ BOOL* pfFilter;
		HRESULT retValue;
	};

	STDMETHOD(FilterTreeItemByTemplateDir)(
		/*[in]*/ LPCOLESTR pszTemplateDir,
		/*[out]*/ BOOL* pfFilter)
	{
		VSL_DEFINE_MOCK_METHOD(FilterTreeItemByTemplateDir)

		VSL_CHECK_VALIDVALUE_STRINGW(pszTemplateDir);

		VSL_SET_VALIDVALUE(pfFilter);

		VSL_RETURN_VALIDVALUES();
	}
	struct FilterListItemByLocalizedNameValidValues
	{
		/*[in]*/ LPCOLESTR pszLocalizedName;
		/*[out]*/ BOOL* pfFilter;
		HRESULT retValue;
	};

	STDMETHOD(FilterListItemByLocalizedName)(
		/*[in]*/ LPCOLESTR pszLocalizedName,
		/*[out]*/ BOOL* pfFilter)
	{
		VSL_DEFINE_MOCK_METHOD(FilterListItemByLocalizedName)

		VSL_CHECK_VALIDVALUE_STRINGW(pszLocalizedName);

		VSL_SET_VALIDVALUE(pfFilter);

		VSL_RETURN_VALIDVALUES();
	}
	struct FilterListItemByTemplateFileValidValues
	{
		/*[in]*/ LPCOLESTR pszTemplateFile;
		/*[out]*/ BOOL* pfFilter;
		HRESULT retValue;
	};

	STDMETHOD(FilterListItemByTemplateFile)(
		/*[in]*/ LPCOLESTR pszTemplateFile,
		/*[out]*/ BOOL* pfFilter)
	{
		VSL_DEFINE_MOCK_METHOD(FilterListItemByTemplateFile)

		VSL_CHECK_VALIDVALUE_STRINGW(pszTemplateFile);

		VSL_SET_VALIDVALUE(pfFilter);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSFILTERNEWPROJECTDLG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsFindSymbol.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSFINDSYMBOL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSFINDSYMBOL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsFindSymbolNotImpl :
	public IVsFindSymbol
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFindSymbolNotImpl)

public:

	typedef IVsFindSymbol Interface;

	STDMETHOD(GetUserOptions)(
		/*[out]*/ GUID* /*pguidScope*/,
		/*[out]*/ VSOBSEARCHCRITERIA2* /*pobSrch*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetUserOptions)(
		/*[in]*/ REFGUID /*guidScope*/,
		/*[in]*/ const VSOBSEARCHCRITERIA2* /*pobSrch*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DoSearch)(
		/*[in]*/ REFGUID /*guidSymbolScope*/,
		/*[in]*/ const VSOBSEARCHCRITERIA2* /*pobSrch*/)VSL_STDMETHOD_NOTIMPL
};

class IVsFindSymbolMockImpl :
	public IVsFindSymbol,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFindSymbolMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsFindSymbolMockImpl)

	typedef IVsFindSymbol Interface;
	struct GetUserOptionsValidValues
	{
		/*[out]*/ GUID* pguidScope;
		/*[out]*/ VSOBSEARCHCRITERIA2* pobSrch;
		HRESULT retValue;
	};

	STDMETHOD(GetUserOptions)(
		/*[out]*/ GUID* pguidScope,
		/*[out]*/ VSOBSEARCHCRITERIA2* pobSrch)
	{
		VSL_DEFINE_MOCK_METHOD(GetUserOptions)

		VSL_SET_VALIDVALUE(pguidScope);

		VSL_SET_VALIDVALUE(pobSrch);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetUserOptionsValidValues
	{
		/*[in]*/ REFGUID guidScope;
		/*[in]*/ VSOBSEARCHCRITERIA2* pobSrch;
		HRESULT retValue;
	};

	STDMETHOD(SetUserOptions)(
		/*[in]*/ REFGUID guidScope,
		/*[in]*/ const VSOBSEARCHCRITERIA2* pobSrch)
	{
		VSL_DEFINE_MOCK_METHOD(SetUserOptions)

		VSL_CHECK_VALIDVALUE(guidScope);

		VSL_CHECK_VALIDVALUE_POINTER(pobSrch);

		VSL_RETURN_VALIDVALUES();
	}
	struct DoSearchValidValues
	{
		/*[in]*/ REFGUID guidSymbolScope;
		/*[in]*/ VSOBSEARCHCRITERIA2* pobSrch;
		HRESULT retValue;
	};

	STDMETHOD(DoSearch)(
		/*[in]*/ REFGUID guidSymbolScope,
		/*[in]*/ const VSOBSEARCHCRITERIA2* pobSrch)
	{
		VSL_DEFINE_MOCK_METHOD(DoSearch)

		VSL_CHECK_VALIDVALUE(guidSymbolScope);

		VSL_CHECK_VALIDVALUE_POINTER(pobSrch);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSFINDSYMBOL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsFontAndColorDefaultsProvider.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSFONTANDCOLORDEFAULTSPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSFONTANDCOLORDEFAULTSPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsFontAndColorDefaultsProviderNotImpl :
	public IVsFontAndColorDefaultsProvider
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFontAndColorDefaultsProviderNotImpl)

public:

	typedef IVsFontAndColorDefaultsProvider Interface;

	STDMETHOD(GetObject)(
		/*[in]*/ REFGUID /*rguidCategory*/,
		/*[out]*/ IUnknown** /*ppObj*/)VSL_STDMETHOD_NOTIMPL
};

class IVsFontAndColorDefaultsProviderMockImpl :
	public IVsFontAndColorDefaultsProvider,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFontAndColorDefaultsProviderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsFontAndColorDefaultsProviderMockImpl)

	typedef IVsFontAndColorDefaultsProvider Interface;
	struct GetObjectValidValues
	{
		/*[in]*/ REFGUID rguidCategory;
		/*[out]*/ IUnknown** ppObj;
		HRESULT retValue;
	};

	STDMETHOD(GetObject)(
		/*[in]*/ REFGUID rguidCategory,
		/*[out]*/ IUnknown** ppObj)
	{
		VSL_DEFINE_MOCK_METHOD(GetObject)

		VSL_CHECK_VALIDVALUE(rguidCategory);

		VSL_SET_VALIDVALUE_INTERFACE(ppObj);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSFONTANDCOLORDEFAULTSPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsFontAndColorDefaults.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSFONTANDCOLORDEFAULTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSFONTANDCOLORDEFAULTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsFontAndColorDefaultsNotImpl :
	public IVsFontAndColorDefaults
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFontAndColorDefaultsNotImpl)

public:

	typedef IVsFontAndColorDefaults Interface;

	STDMETHOD(GetFlags)(
		/*[out]*/ FONTCOLORFLAGS* /*dwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPriority)(
		/*[out]*/ FCPRIORITY* /*pPriority*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCategoryName)(
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBaseCategory)(
		/*[out]*/ GUID* /*pguidBase*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFont)(
		/*[out]*/ FontInfo* /*pInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetItemCount)(
		/*[out]*/ LONG* /*pcItems*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetItem)(
		/*[in]*/ LONG /*iItem*/,
		/*[out]*/ AllColorableItemInfo* /*pInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetItemByName)(
		/*[in]*/ LPCOLESTR /*szItem*/,
		/*[out]*/ AllColorableItemInfo* /*pInfo*/)VSL_STDMETHOD_NOTIMPL
};

class IVsFontAndColorDefaultsMockImpl :
	public IVsFontAndColorDefaults,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFontAndColorDefaultsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsFontAndColorDefaultsMockImpl)

	typedef IVsFontAndColorDefaults Interface;
	struct GetFlagsValidValues
	{
		/*[out]*/ FONTCOLORFLAGS* dwFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetFlags)(
		/*[out]*/ FONTCOLORFLAGS* dwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetFlags)

		VSL_SET_VALIDVALUE(dwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPriorityValidValues
	{
		/*[out]*/ FCPRIORITY* pPriority;
		HRESULT retValue;
	};

	STDMETHOD(GetPriority)(
		/*[out]*/ FCPRIORITY* pPriority)
	{
		VSL_DEFINE_MOCK_METHOD(GetPriority)

		VSL_SET_VALIDVALUE(pPriority);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCategoryNameValidValues
	{
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetCategoryName)(
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetCategoryName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBaseCategoryValidValues
	{
		/*[out]*/ GUID* pguidBase;
		HRESULT retValue;
	};

	STDMETHOD(GetBaseCategory)(
		/*[out]*/ GUID* pguidBase)
	{
		VSL_DEFINE_MOCK_METHOD(GetBaseCategory)

		VSL_SET_VALIDVALUE(pguidBase);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFontValidValues
	{
		/*[out]*/ FontInfo* pInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetFont)(
		/*[out]*/ FontInfo* pInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetFont)

		VSL_SET_VALIDVALUE(pInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetItemCountValidValues
	{
		/*[out]*/ LONG* pcItems;
		HRESULT retValue;
	};

	STDMETHOD(GetItemCount)(
		/*[out]*/ LONG* pcItems)
	{
		VSL_DEFINE_MOCK_METHOD(GetItemCount)

		VSL_SET_VALIDVALUE(pcItems);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetItemValidValues
	{
		/*[in]*/ LONG iItem;
		/*[out]*/ AllColorableItemInfo* pInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetItem)(
		/*[in]*/ LONG iItem,
		/*[out]*/ AllColorableItemInfo* pInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetItem)

		VSL_CHECK_VALIDVALUE(iItem);

		VSL_SET_VALIDVALUE(pInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetItemByNameValidValues
	{
		/*[in]*/ LPCOLESTR szItem;
		/*[out]*/ AllColorableItemInfo* pInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetItemByName)(
		/*[in]*/ LPCOLESTR szItem,
		/*[out]*/ AllColorableItemInfo* pInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetItemByName)

		VSL_CHECK_VALIDVALUE_STRINGW(szItem);

		VSL_SET_VALIDVALUE(pInfo);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSFONTANDCOLORDEFAULTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsFontAndColorCacheManager.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSFONTANDCOLORCACHEMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSFONTANDCOLORCACHEMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsFontAndColorCacheManagerNotImpl :
	public IVsFontAndColorCacheManager
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFontAndColorCacheManagerNotImpl)

public:

	typedef IVsFontAndColorCacheManager Interface;

	STDMETHOD(CheckCache)(
		/*[in]*/ REFGUID /*rguidCategory*/,
		/*[out]*/ BOOL* /*pfHasData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ClearCache)(
		/*[in]*/ REFGUID /*rguidCategory*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RefreshCache)(
		/*[in]*/ REFGUID /*rguidCategory*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CheckCacheable)(
		/*[in]*/ REFGUID /*rguidCategory*/,
		/*[out]*/ BOOL* /*pfCacheable*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ClearAllCaches)()VSL_STDMETHOD_NOTIMPL
};

class IVsFontAndColorCacheManagerMockImpl :
	public IVsFontAndColorCacheManager,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFontAndColorCacheManagerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsFontAndColorCacheManagerMockImpl)

	typedef IVsFontAndColorCacheManager Interface;
	struct CheckCacheValidValues
	{
		/*[in]*/ REFGUID rguidCategory;
		/*[out]*/ BOOL* pfHasData;
		HRESULT retValue;
	};

	STDMETHOD(CheckCache)(
		/*[in]*/ REFGUID rguidCategory,
		/*[out]*/ BOOL* pfHasData)
	{
		VSL_DEFINE_MOCK_METHOD(CheckCache)

		VSL_CHECK_VALIDVALUE(rguidCategory);

		VSL_SET_VALIDVALUE(pfHasData);

		VSL_RETURN_VALIDVALUES();
	}
	struct ClearCacheValidValues
	{
		/*[in]*/ REFGUID rguidCategory;
		HRESULT retValue;
	};

	STDMETHOD(ClearCache)(
		/*[in]*/ REFGUID rguidCategory)
	{
		VSL_DEFINE_MOCK_METHOD(ClearCache)

		VSL_CHECK_VALIDVALUE(rguidCategory);

		VSL_RETURN_VALIDVALUES();
	}
	struct RefreshCacheValidValues
	{
		/*[in]*/ REFGUID rguidCategory;
		HRESULT retValue;
	};

	STDMETHOD(RefreshCache)(
		/*[in]*/ REFGUID rguidCategory)
	{
		VSL_DEFINE_MOCK_METHOD(RefreshCache)

		VSL_CHECK_VALIDVALUE(rguidCategory);

		VSL_RETURN_VALIDVALUES();
	}
	struct CheckCacheableValidValues
	{
		/*[in]*/ REFGUID rguidCategory;
		/*[out]*/ BOOL* pfCacheable;
		HRESULT retValue;
	};

	STDMETHOD(CheckCacheable)(
		/*[in]*/ REFGUID rguidCategory,
		/*[out]*/ BOOL* pfCacheable)
	{
		VSL_DEFINE_MOCK_METHOD(CheckCacheable)

		VSL_CHECK_VALIDVALUE(rguidCategory);

		VSL_SET_VALIDVALUE(pfCacheable);

		VSL_RETURN_VALIDVALUES();
	}
	struct ClearAllCachesValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ClearAllCaches)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ClearAllCaches)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSFONTANDCOLORCACHEMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsFireSolutionEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSFIRESOLUTIONEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSFIRESOLUTIONEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsFireSolutionEventsNotImpl :
	public IVsFireSolutionEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFireSolutionEventsNotImpl)

public:

	typedef IVsFireSolutionEvents Interface;

	STDMETHOD(FireOnAfterOpenProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ BOOL /*fAdded*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FireOnQueryCloseProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ BOOL /*fRemoving*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FireOnBeforeCloseProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ BOOL /*fRemoved*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FireOnAfterLoadProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FireOnQueryUnloadProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FireOnBeforeUnloadProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FireOnBeforeOpeningChildren)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FireOnAfterOpeningChildren)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FireOnBeforeClosingChildren)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FireOnAfterClosingChildren)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/)VSL_STDMETHOD_NOTIMPL
};

class IVsFireSolutionEventsMockImpl :
	public IVsFireSolutionEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFireSolutionEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsFireSolutionEventsMockImpl)

	typedef IVsFireSolutionEvents Interface;
	struct FireOnAfterOpenProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ BOOL fAdded;
		HRESULT retValue;
	};

	STDMETHOD(FireOnAfterOpenProject)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ BOOL fAdded)
	{
		VSL_DEFINE_MOCK_METHOD(FireOnAfterOpenProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE(fAdded);

		VSL_RETURN_VALIDVALUES();
	}
	struct FireOnQueryCloseProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ BOOL fRemoving;
		HRESULT retValue;
	};

	STDMETHOD(FireOnQueryCloseProject)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ BOOL fRemoving)
	{
		VSL_DEFINE_MOCK_METHOD(FireOnQueryCloseProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE(fRemoving);

		VSL_RETURN_VALIDVALUES();
	}
	struct FireOnBeforeCloseProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ BOOL fRemoved;
		HRESULT retValue;
	};

	STDMETHOD(FireOnBeforeCloseProject)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ BOOL fRemoved)
	{
		VSL_DEFINE_MOCK_METHOD(FireOnBeforeCloseProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE(fRemoved);

		VSL_RETURN_VALIDVALUES();
	}
	struct FireOnAfterLoadProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(FireOnAfterLoadProject)(
		/*[in]*/ IVsHierarchy* pHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(FireOnAfterLoadProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct FireOnQueryUnloadProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(FireOnQueryUnloadProject)(
		/*[in]*/ IVsHierarchy* pHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(FireOnQueryUnloadProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct FireOnBeforeUnloadProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(FireOnBeforeUnloadProject)(
		/*[in]*/ IVsHierarchy* pHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(FireOnBeforeUnloadProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct FireOnBeforeOpeningChildrenValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(FireOnBeforeOpeningChildren)(
		/*[in]*/ IVsHierarchy* pHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(FireOnBeforeOpeningChildren)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct FireOnAfterOpeningChildrenValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(FireOnAfterOpeningChildren)(
		/*[in]*/ IVsHierarchy* pHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(FireOnAfterOpeningChildren)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct FireOnBeforeClosingChildrenValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(FireOnBeforeClosingChildren)(
		/*[in]*/ IVsHierarchy* pHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(FireOnBeforeClosingChildren)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct FireOnAfterClosingChildrenValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(FireOnAfterClosingChildren)(
		/*[in]*/ IVsHierarchy* pHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(FireOnAfterClosingChildren)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSFIRESOLUTIONEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsFireSolutionEvents2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSFIRESOLUTIONEVENTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSFIRESOLUTIONEVENTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsFireSolutionEvents2NotImpl :
	public IVsFireSolutionEvents2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFireSolutionEvents2NotImpl)

public:

	typedef IVsFireSolutionEvents2 Interface;

	STDMETHOD(FireOnAfterRenameProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FireOnQueryChangeProjectParent)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ IVsHierarchy* /*pNewParentHier*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FireOnAfterChangeProjectParent)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FireOnAfterAsynchOpenProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ BOOL /*fAdded*/)VSL_STDMETHOD_NOTIMPL
};

class IVsFireSolutionEvents2MockImpl :
	public IVsFireSolutionEvents2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFireSolutionEvents2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsFireSolutionEvents2MockImpl)

	typedef IVsFireSolutionEvents2 Interface;
	struct FireOnAfterRenameProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(FireOnAfterRenameProject)(
		/*[in]*/ IVsHierarchy* pHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(FireOnAfterRenameProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct FireOnQueryChangeProjectParentValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ IVsHierarchy* pNewParentHier;
		HRESULT retValue;
	};

	STDMETHOD(FireOnQueryChangeProjectParent)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ IVsHierarchy* pNewParentHier)
	{
		VSL_DEFINE_MOCK_METHOD(FireOnQueryChangeProjectParent)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pNewParentHier);

		VSL_RETURN_VALIDVALUES();
	}
	struct FireOnAfterChangeProjectParentValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(FireOnAfterChangeProjectParent)(
		/*[in]*/ IVsHierarchy* pHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(FireOnAfterChangeProjectParent)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct FireOnAfterAsynchOpenProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ BOOL fAdded;
		HRESULT retValue;
	};

	STDMETHOD(FireOnAfterAsynchOpenProject)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ BOOL fAdded)
	{
		VSL_DEFINE_MOCK_METHOD(FireOnAfterAsynchOpenProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE(fAdded);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSFIRESOLUTIONEVENTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsFindSymbolEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSFINDSYMBOLEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSFINDSYMBOLEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsFindSymbolEventsNotImpl :
	public IVsFindSymbolEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFindSymbolEventsNotImpl)

public:

	typedef IVsFindSymbolEvents Interface;

	STDMETHOD(OnUserOptionsChanged)(
		/*[in]*/ REFGUID /*guidSymbolScope*/,
		/*[in]*/ const VSOBSEARCHCRITERIA2* /*pobSrch*/)VSL_STDMETHOD_NOTIMPL
};

class IVsFindSymbolEventsMockImpl :
	public IVsFindSymbolEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFindSymbolEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsFindSymbolEventsMockImpl)

	typedef IVsFindSymbolEvents Interface;
	struct OnUserOptionsChangedValidValues
	{
		/*[in]*/ REFGUID guidSymbolScope;
		/*[in]*/ VSOBSEARCHCRITERIA2* pobSrch;
		HRESULT retValue;
	};

	STDMETHOD(OnUserOptionsChanged)(
		/*[in]*/ REFGUID guidSymbolScope,
		/*[in]*/ const VSOBSEARCHCRITERIA2* pobSrch)
	{
		VSL_DEFINE_MOCK_METHOD(OnUserOptionsChanged)

		VSL_CHECK_VALIDVALUE(guidSymbolScope);

		VSL_CHECK_VALIDVALUE_POINTER(pobSrch);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSFINDSYMBOLEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsFindTarget.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSFINDTARGET_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSFINDTARGET_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textfind.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsFindTargetNotImpl :
	public IVsFindTarget
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFindTargetNotImpl)

public:

	typedef IVsFindTarget Interface;

	STDMETHOD(GetCapabilities)(
		/*[out,custom(DE89D360-C06A-11d2-936C-D714766E8B50,"optional")]*/ BOOL* /*pfImage*/,
		/*[out]*/ VSFINDOPTIONS* /*pgrfOptions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProperty)(
		/*[in]*/ VSFTPROPID /*propid*/,
		/*[out,retval]*/ VARIANT* /*pvar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSearchImage)(
		/*[in]*/ VSFINDOPTIONS /*grfOptions*/,
		/*[out,custom(DE89D360-C06A-11d2-936C-D714766E8B50,"optional")]*/ IVsTextSpanSet** /*ppSpans*/,
		/*[out,retval]*/ IVsTextImage** /*ppTextImage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Find)(
		/*[in]*/ LPCOLESTR /*pszSearch*/,
		/*[in]*/ VSFINDOPTIONS /*grfOptions*/,
		/*[in]*/ BOOL /*fResetStartPoint*/,
		/*[in]*/ IVsFindHelper* /*pHelper*/,
		/*[out,retval]*/ VSFINDRESULT* /*pResult*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Replace)(
		/*[in]*/ LPCOLESTR /*pszSearch*/,
		/*[in]*/ LPCOLESTR /*pszReplace*/,
		/*[in]*/ VSFINDOPTIONS /*grfOptions*/,
		/*[in]*/ BOOL /*fResetStartPoint*/,
		/*[in]*/ IVsFindHelper* /*pHelper*/,
		/*[out,retval]*/ BOOL* /*pfReplaced*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMatchRect)(
		/*[out,retval]*/ PRECT /*prc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(NavigateTo)(
		/*[in]*/ const TextSpan* /*pts*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCurrentSpan)(
		/*[out,retval]*/ TextSpan* /*pts*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetFindState)(
		/*[in]*/ IUnknown* /*punk*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFindState)(
		/*[out,retval]*/ IUnknown** /*ppunk*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(NotifyFindTarget)(
		/*[in]*/ VSFTNOTIFY /*notification*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MarkSpan)(
		/*[in]*/ const TextSpan* /*pts*/)VSL_STDMETHOD_NOTIMPL
};

class IVsFindTargetMockImpl :
	public IVsFindTarget,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFindTargetMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsFindTargetMockImpl)

	typedef IVsFindTarget Interface;
	struct GetCapabilitiesValidValues
	{
		/*[out,custom(DE89D360-C06A-11d2-936C-D714766E8B50,"optional")]*/ BOOL* pfImage;
		/*[out]*/ VSFINDOPTIONS* pgrfOptions;
		HRESULT retValue;
	};

	STDMETHOD(GetCapabilities)(
		/*[out,custom(DE89D360-C06A-11d2-936C-D714766E8B50,"optional")]*/ BOOL* pfImage,
		/*[out]*/ VSFINDOPTIONS* pgrfOptions)
	{
		VSL_DEFINE_MOCK_METHOD(GetCapabilities)

		VSL_SET_VALIDVALUE(pfImage);

		VSL_SET_VALIDVALUE(pgrfOptions);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPropertyValidValues
	{
		/*[in]*/ VSFTPROPID propid;
		/*[out,retval]*/ VARIANT* pvar;
		HRESULT retValue;
	};

	STDMETHOD(GetProperty)(
		/*[in]*/ VSFTPROPID propid,
		/*[out,retval]*/ VARIANT* pvar)
	{
		VSL_DEFINE_MOCK_METHOD(GetProperty)

		VSL_CHECK_VALIDVALUE(propid);

		VSL_SET_VALIDVALUE_VARIANT(pvar);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSearchImageValidValues
	{
		/*[in]*/ VSFINDOPTIONS grfOptions;
		/*[out,custom(DE89D360-C06A-11d2-936C-D714766E8B50,"optional")]*/ IVsTextSpanSet** ppSpans;
		/*[out,retval]*/ IVsTextImage** ppTextImage;
		HRESULT retValue;
	};

	STDMETHOD(GetSearchImage)(
		/*[in]*/ VSFINDOPTIONS grfOptions,
		/*[out,custom(DE89D360-C06A-11d2-936C-D714766E8B50,"optional")]*/ IVsTextSpanSet** ppSpans,
		/*[out,retval]*/ IVsTextImage** ppTextImage)
	{
		VSL_DEFINE_MOCK_METHOD(GetSearchImage)

		VSL_CHECK_VALIDVALUE(grfOptions);

		VSL_SET_VALIDVALUE_INTERFACE(ppSpans);

		VSL_SET_VALIDVALUE_INTERFACE(ppTextImage);

		VSL_RETURN_VALIDVALUES();
	}
	struct FindValidValues
	{
		/*[in]*/ LPCOLESTR pszSearch;
		/*[in]*/ VSFINDOPTIONS grfOptions;
		/*[in]*/ BOOL fResetStartPoint;
		/*[in]*/ IVsFindHelper* pHelper;
		/*[out,retval]*/ VSFINDRESULT* pResult;
		HRESULT retValue;
	};

	STDMETHOD(Find)(
		/*[in]*/ LPCOLESTR pszSearch,
		/*[in]*/ VSFINDOPTIONS grfOptions,
		/*[in]*/ BOOL fResetStartPoint,
		/*[in]*/ IVsFindHelper* pHelper,
		/*[out,retval]*/ VSFINDRESULT* pResult)
	{
		VSL_DEFINE_MOCK_METHOD(Find)

		VSL_CHECK_VALIDVALUE_STRINGW(pszSearch);

		VSL_CHECK_VALIDVALUE(grfOptions);

		VSL_CHECK_VALIDVALUE(fResetStartPoint);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHelper);

		VSL_SET_VALIDVALUE(pResult);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReplaceValidValues
	{
		/*[in]*/ LPCOLESTR pszSearch;
		/*[in]*/ LPCOLESTR pszReplace;
		/*[in]*/ VSFINDOPTIONS grfOptions;
		/*[in]*/ BOOL fResetStartPoint;
		/*[in]*/ IVsFindHelper* pHelper;
		/*[out,retval]*/ BOOL* pfReplaced;
		HRESULT retValue;
	};

	STDMETHOD(Replace)(
		/*[in]*/ LPCOLESTR pszSearch,
		/*[in]*/ LPCOLESTR pszReplace,
		/*[in]*/ VSFINDOPTIONS grfOptions,
		/*[in]*/ BOOL fResetStartPoint,
		/*[in]*/ IVsFindHelper* pHelper,
		/*[out,retval]*/ BOOL* pfReplaced)
	{
		VSL_DEFINE_MOCK_METHOD(Replace)

		VSL_CHECK_VALIDVALUE_STRINGW(pszSearch);

		VSL_CHECK_VALIDVALUE_STRINGW(pszReplace);

		VSL_CHECK_VALIDVALUE(grfOptions);

		VSL_CHECK_VALIDVALUE(fResetStartPoint);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHelper);

		VSL_SET_VALIDVALUE(pfReplaced);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMatchRectValidValues
	{
		/*[out,retval]*/ PRECT prc;
		HRESULT retValue;
	};

	STDMETHOD(GetMatchRect)(
		/*[out,retval]*/ PRECT prc)
	{
		VSL_DEFINE_MOCK_METHOD(GetMatchRect)

		VSL_SET_VALIDVALUE(prc);

		VSL_RETURN_VALIDVALUES();
	}
	struct NavigateToValidValues
	{
		/*[in]*/ TextSpan* pts;
		HRESULT retValue;
	};

	STDMETHOD(NavigateTo)(
		/*[in]*/ const TextSpan* pts)
	{
		VSL_DEFINE_MOCK_METHOD(NavigateTo)

		VSL_CHECK_VALIDVALUE_POINTER(pts);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCurrentSpanValidValues
	{
		/*[out,retval]*/ TextSpan* pts;
		HRESULT retValue;
	};

	STDMETHOD(GetCurrentSpan)(
		/*[out,retval]*/ TextSpan* pts)
	{
		VSL_DEFINE_MOCK_METHOD(GetCurrentSpan)

		VSL_SET_VALIDVALUE(pts);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetFindStateValidValues
	{
		/*[in]*/ IUnknown* punk;
		HRESULT retValue;
	};

	STDMETHOD(SetFindState)(
		/*[in]*/ IUnknown* punk)
	{
		VSL_DEFINE_MOCK_METHOD(SetFindState)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punk);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFindStateValidValues
	{
		/*[out,retval]*/ IUnknown** ppunk;
		HRESULT retValue;
	};

	STDMETHOD(GetFindState)(
		/*[out,retval]*/ IUnknown** ppunk)
	{
		VSL_DEFINE_MOCK_METHOD(GetFindState)

		VSL_SET_VALIDVALUE_INTERFACE(ppunk);

		VSL_RETURN_VALIDVALUES();
	}
	struct NotifyFindTargetValidValues
	{
		/*[in]*/ VSFTNOTIFY notification;
		HRESULT retValue;
	};

	STDMETHOD(NotifyFindTarget)(
		/*[in]*/ VSFTNOTIFY notification)
	{
		VSL_DEFINE_MOCK_METHOD(NotifyFindTarget)

		VSL_CHECK_VALIDVALUE(notification);

		VSL_RETURN_VALIDVALUES();
	}
	struct MarkSpanValidValues
	{
		/*[in]*/ TextSpan* pts;
		HRESULT retValue;
	};

	STDMETHOD(MarkSpan)(
		/*[in]*/ const TextSpan* pts)
	{
		VSL_DEFINE_MOCK_METHOD(MarkSpan)

		VSL_CHECK_VALIDVALUE_POINTER(pts);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSFINDTARGET_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsFindTarget2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSFINDTARGET2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSFINDTARGET2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textfind2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsFindTarget2NotImpl :
	public IVsFindTarget2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFindTarget2NotImpl)

public:

	typedef IVsFindTarget2 Interface;

	STDMETHOD(NavigateTo2)(
		/*[in]*/ IVsTextSpanSet* /*pSpans*/,
		/*[in]*/ _TextSelMode /*iSelMode*/)VSL_STDMETHOD_NOTIMPL
};

class IVsFindTarget2MockImpl :
	public IVsFindTarget2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFindTarget2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsFindTarget2MockImpl)

	typedef IVsFindTarget2 Interface;
	struct NavigateTo2ValidValues
	{
		/*[in]*/ IVsTextSpanSet* pSpans;
		/*[in]*/ _TextSelMode iSelMode;
		HRESULT retValue;
	};

	STDMETHOD(NavigateTo2)(
		/*[in]*/ IVsTextSpanSet* pSpans,
		/*[in]*/ _TextSelMode iSelMode)
	{
		VSL_DEFINE_MOCK_METHOD(NavigateTo2)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSpans);

		VSL_CHECK_VALIDVALUE(iSelMode);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSFINDTARGET2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsFormatFilterProvider.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSFORMATFILTERPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSFORMATFILTERPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsFormatFilterProviderNotImpl :
	public IVsFormatFilterProvider
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFormatFilterProviderNotImpl)

public:

	typedef IVsFormatFilterProvider Interface;

	STDMETHOD(GetFormatFilterList)(
		/*[out]*/ BSTR* /*pbstrFilterList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CurFileExtensionFormat)(
		/*[in]*/ BSTR /*bstrFileName*/,
		/*[out]*/ DWORD* /*pdwExtnIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryInvalidEncoding)(
		/*[in]*/ VSTFF /*format*/,
		/*[out]*/ BSTR* /*pbstrMessage*/)VSL_STDMETHOD_NOTIMPL
};

class IVsFormatFilterProviderMockImpl :
	public IVsFormatFilterProvider,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFormatFilterProviderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsFormatFilterProviderMockImpl)

	typedef IVsFormatFilterProvider Interface;
	struct GetFormatFilterListValidValues
	{
		/*[out]*/ BSTR* pbstrFilterList;
		HRESULT retValue;
	};

	STDMETHOD(GetFormatFilterList)(
		/*[out]*/ BSTR* pbstrFilterList)
	{
		VSL_DEFINE_MOCK_METHOD(GetFormatFilterList)

		VSL_SET_VALIDVALUE_BSTR(pbstrFilterList);

		VSL_RETURN_VALIDVALUES();
	}
	struct CurFileExtensionFormatValidValues
	{
		/*[in]*/ BSTR bstrFileName;
		/*[out]*/ DWORD* pdwExtnIndex;
		HRESULT retValue;
	};

	STDMETHOD(CurFileExtensionFormat)(
		/*[in]*/ BSTR bstrFileName,
		/*[out]*/ DWORD* pdwExtnIndex)
	{
		VSL_DEFINE_MOCK_METHOD(CurFileExtensionFormat)

		VSL_CHECK_VALIDVALUE_BSTR(bstrFileName);

		VSL_SET_VALIDVALUE(pdwExtnIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryInvalidEncodingValidValues
	{
		/*[in]*/ VSTFF format;
		/*[out]*/ BSTR* pbstrMessage;
		HRESULT retValue;
	};

	STDMETHOD(QueryInvalidEncoding)(
		/*[in]*/ VSTFF format,
		/*[out]*/ BSTR* pbstrMessage)
	{
		VSL_DEFINE_MOCK_METHOD(QueryInvalidEncoding)

		VSL_CHECK_VALIDVALUE(format);

		VSL_SET_VALIDVALUE_BSTR(pbstrMessage);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSFORMATFILTERPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsGetCfgProvider.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSGETCFGPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSGETCFGPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsGetCfgProviderNotImpl :
	public IVsGetCfgProvider
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsGetCfgProviderNotImpl)

public:

	typedef IVsGetCfgProvider Interface;

	STDMETHOD(GetCfgProvider)(
		/*[out]*/ IVsCfgProvider** /*ppCfgProvider*/)VSL_STDMETHOD_NOTIMPL
};

class IVsGetCfgProviderMockImpl :
	public IVsGetCfgProvider,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsGetCfgProviderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsGetCfgProviderMockImpl)

	typedef IVsGetCfgProvider Interface;
	struct GetCfgProviderValidValues
	{
		/*[out]*/ IVsCfgProvider** ppCfgProvider;
		HRESULT retValue;
	};

	STDMETHOD(GetCfgProvider)(
		/*[out]*/ IVsCfgProvider** ppCfgProvider)
	{
		VSL_DEFINE_MOCK_METHOD(GetCfgProvider)

		VSL_SET_VALIDVALUE_INTERFACE(ppCfgProvider);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSGETCFGPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsGeneratorProgress.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSGENERATORPROGRESS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSGENERATORPROGRESS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsGeneratorProgressNotImpl :
	public IVsGeneratorProgress
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsGeneratorProgressNotImpl)

public:

	typedef IVsGeneratorProgress Interface;

	STDMETHOD(GeneratorError)(
		/*[in]*/ BOOL /*fWarning*/,
		/*[in]*/ DWORD /*dwLevel*/,
		/*[in]*/ BSTR /*bstrError*/,
		/*[in]*/ DWORD /*dwLine*/,
		/*[in]*/ DWORD /*dwColumn*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Progress)(
		/*[in]*/ ULONG /*nComplete*/,
		/*[in]*/ ULONG /*nTotal*/)VSL_STDMETHOD_NOTIMPL
};

class IVsGeneratorProgressMockImpl :
	public IVsGeneratorProgress,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsGeneratorProgressMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsGeneratorProgressMockImpl)

	typedef IVsGeneratorProgress Interface;
	struct GeneratorErrorValidValues
	{
		/*[in]*/ BOOL fWarning;
		/*[in]*/ DWORD dwLevel;
		/*[in]*/ BSTR bstrError;
		/*[in]*/ DWORD dwLine;
		/*[in]*/ DWORD dwColumn;
		HRESULT retValue;
	};

	STDMETHOD(GeneratorError)(
		/*[in]*/ BOOL fWarning,
		/*[in]*/ DWORD dwLevel,
		/*[in]*/ BSTR bstrError,
		/*[in]*/ DWORD dwLine,
		/*[in]*/ DWORD dwColumn)
	{
		VSL_DEFINE_MOCK_METHOD(GeneratorError)

		VSL_CHECK_VALIDVALUE(fWarning);

		VSL_CHECK_VALIDVALUE(dwLevel);

		VSL_CHECK_VALIDVALUE_BSTR(bstrError);

		VSL_CHECK_VALIDVALUE(dwLine);

		VSL_CHECK_VALIDVALUE(dwColumn);

		VSL_RETURN_VALIDVALUES();
	}
	struct ProgressValidValues
	{
		/*[in]*/ ULONG nComplete;
		/*[in]*/ ULONG nTotal;
		HRESULT retValue;
	};

	STDMETHOD(Progress)(
		/*[in]*/ ULONG nComplete,
		/*[in]*/ ULONG nTotal)
	{
		VSL_DEFINE_MOCK_METHOD(Progress)

		VSL_CHECK_VALIDVALUE(nComplete);

		VSL_CHECK_VALIDVALUE(nTotal);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSGENERATORPROGRESS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsFontAndColorGroup.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSFONTANDCOLORGROUP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSFONTANDCOLORGROUP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsFontAndColorGroupNotImpl :
	public IVsFontAndColorGroup
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFontAndColorGroupNotImpl)

public:

	typedef IVsFontAndColorGroup Interface;

	STDMETHOD(GetCount)(
		/*[out]*/ long* /*pnCategories*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPriority)(
		/*[out]*/ FCPRIORITY* /*pPriority*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetGroupName)(
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCategory)(
		/*[in]*/ int /*iCategory*/,
		/*[out]*/ GUID* /*pguidCategory*/)VSL_STDMETHOD_NOTIMPL
};

class IVsFontAndColorGroupMockImpl :
	public IVsFontAndColorGroup,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFontAndColorGroupMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsFontAndColorGroupMockImpl)

	typedef IVsFontAndColorGroup Interface;
	struct GetCountValidValues
	{
		/*[out]*/ long* pnCategories;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out]*/ long* pnCategories)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pnCategories);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPriorityValidValues
	{
		/*[out]*/ FCPRIORITY* pPriority;
		HRESULT retValue;
	};

	STDMETHOD(GetPriority)(
		/*[out]*/ FCPRIORITY* pPriority)
	{
		VSL_DEFINE_MOCK_METHOD(GetPriority)

		VSL_SET_VALIDVALUE(pPriority);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetGroupNameValidValues
	{
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetGroupName)(
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetGroupName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCategoryValidValues
	{
		/*[in]*/ int iCategory;
		/*[out]*/ GUID* pguidCategory;
		HRESULT retValue;
	};

	STDMETHOD(GetCategory)(
		/*[in]*/ int iCategory,
		/*[out]*/ GUID* pguidCategory)
	{
		VSL_DEFINE_MOCK_METHOD(GetCategory)

		VSL_CHECK_VALIDVALUE(iCategory);

		VSL_SET_VALIDVALUE(pguidCategory);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSFONTANDCOLORGROUP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsFontAndColorStorage2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSFONTANDCOLORSTORAGE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSFONTANDCOLORSTORAGE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsFontAndColorStorage2NotImpl :
	public IVsFontAndColorStorage2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFontAndColorStorage2NotImpl)

public:

	typedef IVsFontAndColorStorage2 Interface;

	STDMETHOD(RevertFontToDefault)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RevertItemToDefault)(
		/*[in]*/ LPCOLESTR /*szName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RevertAllItemsToDefault)()VSL_STDMETHOD_NOTIMPL
};

class IVsFontAndColorStorage2MockImpl :
	public IVsFontAndColorStorage2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFontAndColorStorage2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsFontAndColorStorage2MockImpl)

	typedef IVsFontAndColorStorage2 Interface;
	struct RevertFontToDefaultValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(RevertFontToDefault)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(RevertFontToDefault)

		VSL_RETURN_VALIDVALUES();
	}
	struct RevertItemToDefaultValidValues
	{
		/*[in]*/ LPCOLESTR szName;
		HRESULT retValue;
	};

	STDMETHOD(RevertItemToDefault)(
		/*[in]*/ LPCOLESTR szName)
	{
		VSL_DEFINE_MOCK_METHOD(RevertItemToDefault)

		VSL_CHECK_VALIDVALUE_STRINGW(szName);

		VSL_RETURN_VALIDVALUES();
	}
	struct RevertAllItemsToDefaultValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(RevertAllItemsToDefault)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(RevertAllItemsToDefault)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSFONTANDCOLORSTORAGE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsFontAndColorStorage.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSFONTANDCOLORSTORAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSFONTANDCOLORSTORAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsFontAndColorStorageNotImpl :
	public IVsFontAndColorStorage
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFontAndColorStorageNotImpl)

public:

	typedef IVsFontAndColorStorage Interface;

	STDMETHOD(OpenCategory)(
		/*[in]*/ REFGUID /*rguidCategory*/,
		/*[in]*/ FCSTORAGEFLAGS /*fFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CloseCategory)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveCategory)(
		/*[in]*/ REFGUID /*rguidCategory*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFont)(
		/*[in,out]*/ LOGFONTW* /*pLOGFONT*/,
		/*[in,out]*/ FontInfo* /*pInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetItem)(
		/*[in]*/ LPCOLESTR /*szName*/,
		/*[in,out]*/ ColorableItemInfo* /*pInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetFont)(
		/*[in]*/ FontInfo* /*pInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetItem)(
		/*[in]*/ LPCOLESTR /*szName*/,
		/*[in]*/ ColorableItemInfo* /*pInfo*/)VSL_STDMETHOD_NOTIMPL
};

class IVsFontAndColorStorageMockImpl :
	public IVsFontAndColorStorage,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFontAndColorStorageMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsFontAndColorStorageMockImpl)

	typedef IVsFontAndColorStorage Interface;
	struct OpenCategoryValidValues
	{
		/*[in]*/ REFGUID rguidCategory;
		/*[in]*/ FCSTORAGEFLAGS fFlags;
		HRESULT retValue;
	};

	STDMETHOD(OpenCategory)(
		/*[in]*/ REFGUID rguidCategory,
		/*[in]*/ FCSTORAGEFLAGS fFlags)
	{
		VSL_DEFINE_MOCK_METHOD(OpenCategory)

		VSL_CHECK_VALIDVALUE(rguidCategory);

		VSL_CHECK_VALIDVALUE(fFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct CloseCategoryValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CloseCategory)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CloseCategory)

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveCategoryValidValues
	{
		/*[in]*/ REFGUID rguidCategory;
		HRESULT retValue;
	};

	STDMETHOD(RemoveCategory)(
		/*[in]*/ REFGUID rguidCategory)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveCategory)

		VSL_CHECK_VALIDVALUE(rguidCategory);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFontValidValues
	{
		/*[in,out]*/ LOGFONTW* pLOGFONT;
		/*[in,out]*/ FontInfo* pInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetFont)(
		/*[in,out]*/ LOGFONTW* pLOGFONT,
		/*[in,out]*/ FontInfo* pInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetFont)

		VSL_SET_VALIDVALUE(pLOGFONT);

		VSL_SET_VALIDVALUE(pInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetItemValidValues
	{
		/*[in]*/ LPCOLESTR szName;
		/*[in,out]*/ ColorableItemInfo* pInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetItem)(
		/*[in]*/ LPCOLESTR szName,
		/*[in,out]*/ ColorableItemInfo* pInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetItem)

		VSL_CHECK_VALIDVALUE_STRINGW(szName);

		VSL_SET_VALIDVALUE(pInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetFontValidValues
	{
		/*[in]*/ FontInfo* pInfo;
		HRESULT retValue;
	};

	STDMETHOD(SetFont)(
		/*[in]*/ FontInfo* pInfo)
	{
		VSL_DEFINE_MOCK_METHOD(SetFont)

		VSL_CHECK_VALIDVALUE_POINTER(pInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetItemValidValues
	{
		/*[in]*/ LPCOLESTR szName;
		/*[in]*/ ColorableItemInfo* pInfo;
		HRESULT retValue;
	};

	STDMETHOD(SetItem)(
		/*[in]*/ LPCOLESTR szName,
		/*[in]*/ ColorableItemInfo* pInfo)
	{
		VSL_DEFINE_MOCK_METHOD(SetItem)

		VSL_CHECK_VALIDVALUE_STRINGW(szName);

		VSL_CHECK_VALIDVALUE_POINTER(pInfo);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSFONTANDCOLORSTORAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsFontAndColorEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSFONTANDCOLOREVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSFONTANDCOLOREVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsFontAndColorEventsNotImpl :
	public IVsFontAndColorEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFontAndColorEventsNotImpl)

public:

	typedef IVsFontAndColorEvents Interface;

	STDMETHOD(OnFontChanged)(
		/*[in]*/ REFGUID /*rguidCategory*/,
		/*[in]*/ const FontInfo* /*pInfo*/,
		/*[in]*/ const LOGFONTW* /*pLOGFONT*/,
		/*[in]*/ HFONT /*hFont*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnItemChanged)(
		/*[in]*/ REFGUID /*rguidCategory*/,
		/*[in]*/ LPCOLESTR /*szItem*/,
		/*[in]*/ LONG /*iItem*/,
		/*[in]*/ const ColorableItemInfo* /*pInfo*/,
		/*[in]*/ COLORREF /*crLiteralForeground*/,
		/*[in]*/ COLORREF /*crLiteralBackground*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnReset)(
		/*[in]*/ REFGUID /*rguidCategory*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnResetToBaseCategory)(
		/*[in]*/ REFGUID /*rguidCategory*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnApply)()VSL_STDMETHOD_NOTIMPL
};

class IVsFontAndColorEventsMockImpl :
	public IVsFontAndColorEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFontAndColorEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsFontAndColorEventsMockImpl)

	typedef IVsFontAndColorEvents Interface;
	struct OnFontChangedValidValues
	{
		/*[in]*/ REFGUID rguidCategory;
		/*[in]*/ FontInfo* pInfo;
		/*[in]*/ LOGFONTW* pLOGFONT;
		/*[in]*/ HFONT hFont;
		HRESULT retValue;
	};

	STDMETHOD(OnFontChanged)(
		/*[in]*/ REFGUID rguidCategory,
		/*[in]*/ const FontInfo* pInfo,
		/*[in]*/ const LOGFONTW* pLOGFONT,
		/*[in]*/ HFONT hFont)
	{
		VSL_DEFINE_MOCK_METHOD(OnFontChanged)

		VSL_CHECK_VALIDVALUE(rguidCategory);

		VSL_CHECK_VALIDVALUE_POINTER(pInfo);

		VSL_CHECK_VALIDVALUE_POINTER(pLOGFONT);

		VSL_CHECK_VALIDVALUE(hFont);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnItemChangedValidValues
	{
		/*[in]*/ REFGUID rguidCategory;
		/*[in]*/ LPCOLESTR szItem;
		/*[in]*/ LONG iItem;
		/*[in]*/ ColorableItemInfo* pInfo;
		/*[in]*/ COLORREF crLiteralForeground;
		/*[in]*/ COLORREF crLiteralBackground;
		HRESULT retValue;
	};

	STDMETHOD(OnItemChanged)(
		/*[in]*/ REFGUID rguidCategory,
		/*[in]*/ LPCOLESTR szItem,
		/*[in]*/ LONG iItem,
		/*[in]*/ const ColorableItemInfo* pInfo,
		/*[in]*/ COLORREF crLiteralForeground,
		/*[in]*/ COLORREF crLiteralBackground)
	{
		VSL_DEFINE_MOCK_METHOD(OnItemChanged)

		VSL_CHECK_VALIDVALUE(rguidCategory);

		VSL_CHECK_VALIDVALUE_STRINGW(szItem);

		VSL_CHECK_VALIDVALUE(iItem);

		VSL_CHECK_VALIDVALUE_POINTER(pInfo);

		VSL_CHECK_VALIDVALUE(crLiteralForeground);

		VSL_CHECK_VALIDVALUE(crLiteralBackground);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnResetValidValues
	{
		/*[in]*/ REFGUID rguidCategory;
		HRESULT retValue;
	};

	STDMETHOD(OnReset)(
		/*[in]*/ REFGUID rguidCategory)
	{
		VSL_DEFINE_MOCK_METHOD(OnReset)

		VSL_CHECK_VALIDVALUE(rguidCategory);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnResetToBaseCategoryValidValues
	{
		/*[in]*/ REFGUID rguidCategory;
		HRESULT retValue;
	};

	STDMETHOD(OnResetToBaseCategory)(
		/*[in]*/ REFGUID rguidCategory)
	{
		VSL_DEFINE_MOCK_METHOD(OnResetToBaseCategory)

		VSL_CHECK_VALIDVALUE(rguidCategory);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnApplyValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnApply)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnApply)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSFONTANDCOLOREVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsFontAndColorUtilities.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSFONTANDCOLORUTILITIES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSFONTANDCOLORUTILITIES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsFontAndColorUtilitiesNotImpl :
	public IVsFontAndColorUtilities
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFontAndColorUtilitiesNotImpl)

public:

	typedef IVsFontAndColorUtilities Interface;

	STDMETHOD(EncodeIndexedColor)(
		/*[in]*/ COLORINDEX /*idx*/,
		/*[out]*/ COLORREF* /*pcrResult*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EncodeSysColor)(
		/*[in]*/ int /*iSysColor*/,
		/*[out]*/ COLORREF* /*pcrResult*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EncodeVSColor)(
		/*[in]*/ VSSYSCOLOREX /*vsColor*/,
		/*[out]*/ COLORREF* /*pcrResult*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EncodeTrackedItem)(
		/*[in]*/ int /*iItemToTrack*/,
		/*[in]*/ VSCOLORASPECT /*aspect*/,
		/*[out]*/ COLORREF* /*pcrResult*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EncodeInvalidColor)(
		/*[out]*/ COLORREF* /*pcrResult*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EncodeAutomaticColor)(
		/*[out]*/ COLORREF* /*pcrResult*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetColorType)(
		/*[in]*/ COLORREF /*crSource*/,
		/*[out]*/ VSCOLORTYPE* /*pctType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEncodedIndex)(
		/*[in]*/ COLORREF /*crSource*/,
		/*[out]*/ COLORINDEX* /*pIdx*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEncodedSysColor)(
		/*[in]*/ COLORREF /*crSource*/,
		/*[out]*/ int* /*piSysColor*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEncodedVSColor)(
		/*[in]*/ COLORREF /*crSource*/,
		/*[out]*/ VSSYSCOLOREX* /*pVSColor*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTrackedItemIndex)(
		/*[in]*/ COLORREF /*crSource*/,
		/*[out]*/ VSCOLORASPECT* /*pAspect*/,
		/*[out]*/ int* /*piItem*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetRGBOfIndex)(
		/*[in]*/ COLORINDEX /*idx*/,
		/*[out]*/ COLORREF* /*pcrResult*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetRGBOfItem)(
		/*[in]*/ AllColorableItemInfo* /*pInfo*/,
		/*[in]*/ REFGUID /*rguidCategory*/,
		/*[out]*/ COLORREF* /*pcrForeground*/,
		/*[out]*/ COLORREF* /*pcrBackground*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetRGBOfEncodedColor)(
		/*[in]*/ COLORREF /*crSource*/,
		/*[in]*/ COLORREF /*crAutoColor*/,
		/*[in]*/ REFGUID /*rguidCategory*/,
		/*[out]*/ COLORREF* /*pcrResult*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(InitFontInfo)(
		/*[in,out]*/ FontInfo* /*pInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FreeFontInfo)(
		/*[in,out]*/ FontInfo* /*pInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CopyFontInfo)(
		/*[in,out]*/ FontInfo* /*pDest*/,
		/*[in]*/ const FontInfo* /*pSource*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(InitItemInfo)(
		/*[in,out]*/ AllColorableItemInfo* /*pInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FreeItemInfo)(
		/*[in,out]*/ AllColorableItemInfo* /*pInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CopyItemInfo)(
		/*[in,out]*/ AllColorableItemInfo* /*pDest*/,
		/*[in]*/ const AllColorableItemInfo* /*pSource*/)VSL_STDMETHOD_NOTIMPL
};

class IVsFontAndColorUtilitiesMockImpl :
	public IVsFontAndColorUtilities,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsFontAndColorUtilitiesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsFontAndColorUtilitiesMockImpl)

	typedef IVsFontAndColorUtilities Interface;
	struct EncodeIndexedColorValidValues
	{
		/*[in]*/ COLORINDEX idx;
		/*[out]*/ COLORREF* pcrResult;
		HRESULT retValue;
	};

	STDMETHOD(EncodeIndexedColor)(
		/*[in]*/ COLORINDEX idx,
		/*[out]*/ COLORREF* pcrResult)
	{
		VSL_DEFINE_MOCK_METHOD(EncodeIndexedColor)

		VSL_CHECK_VALIDVALUE(idx);

		VSL_SET_VALIDVALUE(pcrResult);

		VSL_RETURN_VALIDVALUES();
	}
	struct EncodeSysColorValidValues
	{
		/*[in]*/ int iSysColor;
		/*[out]*/ COLORREF* pcrResult;
		HRESULT retValue;
	};

	STDMETHOD(EncodeSysColor)(
		/*[in]*/ int iSysColor,
		/*[out]*/ COLORREF* pcrResult)
	{
		VSL_DEFINE_MOCK_METHOD(EncodeSysColor)

		VSL_CHECK_VALIDVALUE(iSysColor);

		VSL_SET_VALIDVALUE(pcrResult);

		VSL_RETURN_VALIDVALUES();
	}
	struct EncodeVSColorValidValues
	{
		/*[in]*/ VSSYSCOLOREX vsColor;
		/*[out]*/ COLORREF* pcrResult;
		HRESULT retValue;
	};

	STDMETHOD(EncodeVSColor)(
		/*[in]*/ VSSYSCOLOREX vsColor,
		/*[out]*/ COLORREF* pcrResult)
	{
		VSL_DEFINE_MOCK_METHOD(EncodeVSColor)

		VSL_CHECK_VALIDVALUE(vsColor);

		VSL_SET_VALIDVALUE(pcrResult);

		VSL_RETURN_VALIDVALUES();
	}
	struct EncodeTrackedItemValidValues
	{
		/*[in]*/ int iItemToTrack;
		/*[in]*/ VSCOLORASPECT aspect;
		/*[out]*/ COLORREF* pcrResult;
		HRESULT retValue;
	};

	STDMETHOD(EncodeTrackedItem)(
		/*[in]*/ int iItemToTrack,
		/*[in]*/ VSCOLORASPECT aspect,
		/*[out]*/ COLORREF* pcrResult)
	{
		VSL_DEFINE_MOCK_METHOD(EncodeTrackedItem)

		VSL_CHECK_VALIDVALUE(iItemToTrack);

		VSL_CHECK_VALIDVALUE(aspect);

		VSL_SET_VALIDVALUE(pcrResult);

		VSL_RETURN_VALIDVALUES();
	}
	struct EncodeInvalidColorValidValues
	{
		/*[out]*/ COLORREF* pcrResult;
		HRESULT retValue;
	};

	STDMETHOD(EncodeInvalidColor)(
		/*[out]*/ COLORREF* pcrResult)
	{
		VSL_DEFINE_MOCK_METHOD(EncodeInvalidColor)

		VSL_SET_VALIDVALUE(pcrResult);

		VSL_RETURN_VALIDVALUES();
	}
	struct EncodeAutomaticColorValidValues
	{
		/*[out]*/ COLORREF* pcrResult;
		HRESULT retValue;
	};

	STDMETHOD(EncodeAutomaticColor)(
		/*[out]*/ COLORREF* pcrResult)
	{
		VSL_DEFINE_MOCK_METHOD(EncodeAutomaticColor)

		VSL_SET_VALIDVALUE(pcrResult);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetColorTypeValidValues
	{
		/*[in]*/ COLORREF crSource;
		/*[out]*/ VSCOLORTYPE* pctType;
		HRESULT retValue;
	};

	STDMETHOD(GetColorType)(
		/*[in]*/ COLORREF crSource,
		/*[out]*/ VSCOLORTYPE* pctType)
	{
		VSL_DEFINE_MOCK_METHOD(GetColorType)

		VSL_CHECK_VALIDVALUE(crSource);

		VSL_SET_VALIDVALUE(pctType);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEncodedIndexValidValues
	{
		/*[in]*/ COLORREF crSource;
		/*[out]*/ COLORINDEX* pIdx;
		HRESULT retValue;
	};

	STDMETHOD(GetEncodedIndex)(
		/*[in]*/ COLORREF crSource,
		/*[out]*/ COLORINDEX* pIdx)
	{
		VSL_DEFINE_MOCK_METHOD(GetEncodedIndex)

		VSL_CHECK_VALIDVALUE(crSource);

		VSL_SET_VALIDVALUE(pIdx);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEncodedSysColorValidValues
	{
		/*[in]*/ COLORREF crSource;
		/*[out]*/ int* piSysColor;
		HRESULT retValue;
	};

	STDMETHOD(GetEncodedSysColor)(
		/*[in]*/ COLORREF crSource,
		/*[out]*/ int* piSysColor)
	{
		VSL_DEFINE_MOCK_METHOD(GetEncodedSysColor)

		VSL_CHECK_VALIDVALUE(crSource);

		VSL_SET_VALIDVALUE(piSysColor);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEncodedVSColorValidValues
	{
		/*[in]*/ COLORREF crSource;
		/*[out]*/ VSSYSCOLOREX* pVSColor;
		HRESULT retValue;
	};

	STDMETHOD(GetEncodedVSColor)(
		/*[in]*/ COLORREF crSource,
		/*[out]*/ VSSYSCOLOREX* pVSColor)
	{
		VSL_DEFINE_MOCK_METHOD(GetEncodedVSColor)

		VSL_CHECK_VALIDVALUE(crSource);

		VSL_SET_VALIDVALUE(pVSColor);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTrackedItemIndexValidValues
	{
		/*[in]*/ COLORREF crSource;
		/*[out]*/ VSCOLORASPECT* pAspect;
		/*[out]*/ int* piItem;
		HRESULT retValue;
	};

	STDMETHOD(GetTrackedItemIndex)(
		/*[in]*/ COLORREF crSource,
		/*[out]*/ VSCOLORASPECT* pAspect,
		/*[out]*/ int* piItem)
	{
		VSL_DEFINE_MOCK_METHOD(GetTrackedItemIndex)

		VSL_CHECK_VALIDVALUE(crSource);

		VSL_SET_VALIDVALUE(pAspect);

		VSL_SET_VALIDVALUE(piItem);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetRGBOfIndexValidValues
	{
		/*[in]*/ COLORINDEX idx;
		/*[out]*/ COLORREF* pcrResult;
		HRESULT retValue;
	};

	STDMETHOD(GetRGBOfIndex)(
		/*[in]*/ COLORINDEX idx,
		/*[out]*/ COLORREF* pcrResult)
	{
		VSL_DEFINE_MOCK_METHOD(GetRGBOfIndex)

		VSL_CHECK_VALIDVALUE(idx);

		VSL_SET_VALIDVALUE(pcrResult);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetRGBOfItemValidValues
	{
		/*[in]*/ AllColorableItemInfo* pInfo;
		/*[in]*/ REFGUID rguidCategory;
		/*[out]*/ COLORREF* pcrForeground;
		/*[out]*/ COLORREF* pcrBackground;
		HRESULT retValue;
	};

	STDMETHOD(GetRGBOfItem)(
		/*[in]*/ AllColorableItemInfo* pInfo,
		/*[in]*/ REFGUID rguidCategory,
		/*[out]*/ COLORREF* pcrForeground,
		/*[out]*/ COLORREF* pcrBackground)
	{
		VSL_DEFINE_MOCK_METHOD(GetRGBOfItem)

		VSL_CHECK_VALIDVALUE_POINTER(pInfo);

		VSL_CHECK_VALIDVALUE(rguidCategory);

		VSL_SET_VALIDVALUE(pcrForeground);

		VSL_SET_VALIDVALUE(pcrBackground);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetRGBOfEncodedColorValidValues
	{
		/*[in]*/ COLORREF crSource;
		/*[in]*/ COLORREF crAutoColor;
		/*[in]*/ REFGUID rguidCategory;
		/*[out]*/ COLORREF* pcrResult;
		HRESULT retValue;
	};

	STDMETHOD(GetRGBOfEncodedColor)(
		/*[in]*/ COLORREF crSource,
		/*[in]*/ COLORREF crAutoColor,
		/*[in]*/ REFGUID rguidCategory,
		/*[out]*/ COLORREF* pcrResult)
	{
		VSL_DEFINE_MOCK_METHOD(GetRGBOfEncodedColor)

		VSL_CHECK_VALIDVALUE(crSource);

		VSL_CHECK_VALIDVALUE(crAutoColor);

		VSL_CHECK_VALIDVALUE(rguidCategory);

		VSL_SET_VALIDVALUE(pcrResult);

		VSL_RETURN_VALIDVALUES();
	}
	struct InitFontInfoValidValues
	{
		/*[in,out]*/ FontInfo* pInfo;
		HRESULT retValue;
	};

	STDMETHOD(InitFontInfo)(
		/*[in,out]*/ FontInfo* pInfo)
	{
		VSL_DEFINE_MOCK_METHOD(InitFontInfo)

		VSL_SET_VALIDVALUE(pInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct FreeFontInfoValidValues
	{
		/*[in,out]*/ FontInfo* pInfo;
		HRESULT retValue;
	};

	STDMETHOD(FreeFontInfo)(
		/*[in,out]*/ FontInfo* pInfo)
	{
		VSL_DEFINE_MOCK_METHOD(FreeFontInfo)

		VSL_SET_VALIDVALUE(pInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct CopyFontInfoValidValues
	{
		/*[in,out]*/ FontInfo* pDest;
		/*[in]*/ FontInfo* pSource;
		HRESULT retValue;
	};

	STDMETHOD(CopyFontInfo)(
		/*[in,out]*/ FontInfo* pDest,
		/*[in]*/ const FontInfo* pSource)
	{
		VSL_DEFINE_MOCK_METHOD(CopyFontInfo)

		VSL_SET_VALIDVALUE(pDest);

		VSL_CHECK_VALIDVALUE_POINTER(pSource);

		VSL_RETURN_VALIDVALUES();
	}
	struct InitItemInfoValidValues
	{
		/*[in,out]*/ AllColorableItemInfo* pInfo;
		HRESULT retValue;
	};

	STDMETHOD(InitItemInfo)(
		/*[in,out]*/ AllColorableItemInfo* pInfo)
	{
		VSL_DEFINE_MOCK_METHOD(InitItemInfo)

		VSL_SET_VALIDVALUE(pInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct FreeItemInfoValidValues
	{
		/*[in,out]*/ AllColorableItemInfo* pInfo;
		HRESULT retValue;
	};

	STDMETHOD(FreeItemInfo)(
		/*[in,out]*/ AllColorableItemInfo* pInfo)
	{
		VSL_DEFINE_MOCK_METHOD(FreeItemInfo)

		VSL_SET_VALIDVALUE(pInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct CopyItemInfoValidValues
	{
		/*[in,out]*/ AllColorableItemInfo* pDest;
		/*[in]*/ AllColorableItemInfo* pSource;
		HRESULT retValue;
	};

	STDMETHOD(CopyItemInfo)(
		/*[in,out]*/ AllColorableItemInfo* pDest,
		/*[in]*/ const AllColorableItemInfo* pSource)
	{
		VSL_DEFINE_MOCK_METHOD(CopyItemInfo)

		VSL_SET_VALIDVALUE(pDest);

		VSL_CHECK_VALIDVALUE_POINTER(pSource);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSFONTANDCOLORUTILITIES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsHasRelatedSaveItems.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSHASRELATEDSAVEITEMS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSHASRELATEDSAVEITEMS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsHasRelatedSaveItemsNotImpl :
	public IVsHasRelatedSaveItems
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHasRelatedSaveItemsNotImpl)

public:

	typedef IVsHasRelatedSaveItems Interface;

	STDMETHOD(GetRelatedSaveTreeItems)(
		/*[in]*/ VSSAVETREEITEM /*saveItem*/,
		/*[in]*/ ULONG /*celt*/,
		/*[in,out,size_is(celt)]*/ VSSAVETREEITEM[] /*rgSaveTreeItems*/,
		/*[out]*/ ULONG* /*pcActual*/)VSL_STDMETHOD_NOTIMPL
};

class IVsHasRelatedSaveItemsMockImpl :
	public IVsHasRelatedSaveItems,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHasRelatedSaveItemsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsHasRelatedSaveItemsMockImpl)

	typedef IVsHasRelatedSaveItems Interface;
	struct GetRelatedSaveTreeItemsValidValues
	{
		/*[in]*/ VSSAVETREEITEM saveItem;
		/*[in]*/ ULONG celt;
		/*[in,out,size_is(celt)]*/ VSSAVETREEITEM* rgSaveTreeItems;
		/*[out]*/ ULONG* pcActual;
		HRESULT retValue;
	};

	STDMETHOD(GetRelatedSaveTreeItems)(
		/*[in]*/ VSSAVETREEITEM saveItem,
		/*[in]*/ ULONG celt,
		/*[in,out,size_is(celt)]*/ VSSAVETREEITEM rgSaveTreeItems[],
		/*[out]*/ ULONG* pcActual)
	{
		VSL_DEFINE_MOCK_METHOD(GetRelatedSaveTreeItems)

		VSL_CHECK_VALIDVALUE(saveItem);

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(rgSaveTreeItems, celt*sizeof(rgSaveTreeItems[0]), validValues.celt*sizeof(validValues.rgSaveTreeItems[0]));

		VSL_SET_VALIDVALUE(pcActual);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSHASRELATEDSAVEITEMS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsHelpFavorites.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSHELPFAVORITES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSHELPFAVORITES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "VSHelp80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsHelpFavoritesNotImpl :
	public IVsHelpFavorites
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHelpFavoritesNotImpl)

public:

	typedef IVsHelpFavorites Interface;

	STDMETHOD(ShowFavorites)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddFavoriteTopic)(
		/*[in]*/ BSTR /*strTitle*/,
		/*[in]*/ BSTR /*strUrl*/,
		/*[in]*/ BSTR /*topicKeyword*/,
		/*[in]*/ BSTR /*strTopicLocale*/)VSL_STDMETHOD_NOTIMPL
};

class IVsHelpFavoritesMockImpl :
	public IVsHelpFavorites,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHelpFavoritesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsHelpFavoritesMockImpl)

	typedef IVsHelpFavorites Interface;
	struct ShowFavoritesValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ShowFavorites)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ShowFavorites)

		VSL_RETURN_VALIDVALUES();
	}
	struct AddFavoriteTopicValidValues
	{
		/*[in]*/ BSTR strTitle;
		/*[in]*/ BSTR strUrl;
		/*[in]*/ BSTR topicKeyword;
		/*[in]*/ BSTR strTopicLocale;
		HRESULT retValue;
	};

	STDMETHOD(AddFavoriteTopic)(
		/*[in]*/ BSTR strTitle,
		/*[in]*/ BSTR strUrl,
		/*[in]*/ BSTR topicKeyword,
		/*[in]*/ BSTR strTopicLocale)
	{
		VSL_DEFINE_MOCK_METHOD(AddFavoriteTopic)

		VSL_CHECK_VALIDVALUE_BSTR(strTitle);

		VSL_CHECK_VALIDVALUE_BSTR(strUrl);

		VSL_CHECK_VALIDVALUE_BSTR(topicKeyword);

		VSL_CHECK_VALIDVALUE_BSTR(strTopicLocale);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSHELPFAVORITES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsHelpOwner.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSHELPOWNER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSHELPOWNER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vshelp.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsHelpOwnerNotImpl :
	public IVsHelpOwner
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHelpOwnerNotImpl)

public:

	typedef IVsHelpOwner Interface;

	STDMETHOD(BringHelpToTop)(
		/*[in]*/ long /*hwndHelpApp*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AutomationObject)(
		/*[out,retval]*/ IDispatch** /*ppObj*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class IVsHelpOwnerMockImpl :
	public IVsHelpOwner,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHelpOwnerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsHelpOwnerMockImpl)

	typedef IVsHelpOwner Interface;
	struct BringHelpToTopValidValues
	{
		/*[in]*/ long hwndHelpApp;
		HRESULT retValue;
	};

	STDMETHOD(BringHelpToTop)(
		/*[in]*/ long hwndHelpApp)
	{
		VSL_DEFINE_MOCK_METHOD(BringHelpToTop)

		VSL_CHECK_VALIDVALUE(hwndHelpApp);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AutomationObjectValidValues
	{
		/*[out,retval]*/ IDispatch** ppObj;
		HRESULT retValue;
	};

	STDMETHOD(get_AutomationObject)(
		/*[out,retval]*/ IDispatch** ppObj)
	{
		VSL_DEFINE_MOCK_METHOD(get_AutomationObject)

		VSL_SET_VALIDVALUE_INTERFACE(ppObj);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSHELPOWNER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsGlobals2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSGLOBALS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSGLOBALS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsGlobals2NotImpl :
	public IVsGlobals2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsGlobals2NotImpl)

public:

	typedef IVsGlobals2 Interface;

	STDMETHOD(Load)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Save)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Empty)()VSL_STDMETHOD_NOTIMPL
};

class IVsGlobals2MockImpl :
	public IVsGlobals2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsGlobals2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsGlobals2MockImpl)

	typedef IVsGlobals2 Interface;
	struct LoadValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Load)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Load)

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Save)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Save)

		VSL_RETURN_VALIDVALUES();
	}
	struct EmptyValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Empty)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Empty)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSGLOBALS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsGradient.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSGRADIENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSGRADIENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsGradientNotImpl :
	public IVsGradient
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsGradientNotImpl)

public:

	typedef IVsGradient Interface;

	STDMETHOD(DrawGradient)(
		/*[in]*/ HWND /*hwnd*/,
		/*[in]*/ HDC /*hdc*/,
		/*[in]*/ RECT* /*gradientRect*/,
		/*[in]*/ RECT* /*sliceRect*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetGradientVector)(
		/*[in]*/ int /*cVector*/,
		/*[in,out,size_is(cVector)]*/ COLORREF* /*rgVector*/)VSL_STDMETHOD_NOTIMPL
};

class IVsGradientMockImpl :
	public IVsGradient,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsGradientMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsGradientMockImpl)

	typedef IVsGradient Interface;
	struct DrawGradientValidValues
	{
		/*[in]*/ HWND hwnd;
		/*[in]*/ HDC hdc;
		/*[in]*/ RECT* gradientRect;
		/*[in]*/ RECT* sliceRect;
		HRESULT retValue;
	};

	STDMETHOD(DrawGradient)(
		/*[in]*/ HWND hwnd,
		/*[in]*/ HDC hdc,
		/*[in]*/ RECT* gradientRect,
		/*[in]*/ RECT* sliceRect)
	{
		VSL_DEFINE_MOCK_METHOD(DrawGradient)

		VSL_CHECK_VALIDVALUE(hwnd);

		VSL_CHECK_VALIDVALUE(hdc);

		VSL_CHECK_VALIDVALUE_POINTER(gradientRect);

		VSL_CHECK_VALIDVALUE_POINTER(sliceRect);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetGradientVectorValidValues
	{
		/*[in]*/ int cVector;
		/*[in,out,size_is(cVector)]*/ COLORREF* rgVector;
		HRESULT retValue;
	};

	STDMETHOD(GetGradientVector)(
		/*[in]*/ int cVector,
		/*[in,out,size_is(cVector)]*/ COLORREF* rgVector)
	{
		VSL_DEFINE_MOCK_METHOD(GetGradientVector)

		VSL_CHECK_VALIDVALUE(cVector);

		VSL_SET_VALIDVALUE_MEMCPY(rgVector, cVector*sizeof(rgVector[0]), validValues.cVector*sizeof(validValues.rgVector[0]));

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSGRADIENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsGlobalsCallback2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSGLOBALSCALLBACK2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSGLOBALSCALLBACK2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsGlobalsCallback2NotImpl :
	public IVsGlobalsCallback2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsGlobalsCallback2NotImpl)

public:

	typedef IVsGlobalsCallback2 Interface;

	STDMETHOD(WriteVariablesToData)(
		/*[in]*/ LPCOLESTR /*pVariableName*/,
		/*[in]*/ VARIANT* /*varData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReadData)(
		/*[in]*/ IUnknown* /*pGlobals*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ClearVariables)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(VariableChanged)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanModifySource)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetParent)(
		/*[in]*/ IDispatch** /*ppOut*/)VSL_STDMETHOD_NOTIMPL
};

class IVsGlobalsCallback2MockImpl :
	public IVsGlobalsCallback2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsGlobalsCallback2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsGlobalsCallback2MockImpl)

	typedef IVsGlobalsCallback2 Interface;
	struct WriteVariablesToDataValidValues
	{
		/*[in]*/ LPCOLESTR pVariableName;
		/*[in]*/ VARIANT* varData;
		HRESULT retValue;
	};

	STDMETHOD(WriteVariablesToData)(
		/*[in]*/ LPCOLESTR pVariableName,
		/*[in]*/ VARIANT* varData)
	{
		VSL_DEFINE_MOCK_METHOD(WriteVariablesToData)

		VSL_CHECK_VALIDVALUE_STRINGW(pVariableName);

		VSL_CHECK_VALIDVALUE_POINTER(varData);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReadDataValidValues
	{
		/*[in]*/ IUnknown* pGlobals;
		HRESULT retValue;
	};

	STDMETHOD(ReadData)(
		/*[in]*/ IUnknown* pGlobals)
	{
		VSL_DEFINE_MOCK_METHOD(ReadData)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pGlobals);

		VSL_RETURN_VALIDVALUES();
	}
	struct ClearVariablesValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ClearVariables)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ClearVariables)

		VSL_RETURN_VALIDVALUES();
	}
	struct VariableChangedValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(VariableChanged)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(VariableChanged)

		VSL_RETURN_VALIDVALUES();
	}
	struct CanModifySourceValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CanModifySource)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CanModifySource)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetParentValidValues
	{
		/*[in]*/ IDispatch** ppOut;
		HRESULT retValue;
	};

	STDMETHOD(GetParent)(
		/*[in]*/ IDispatch** ppOut)
	{
		VSL_DEFINE_MOCK_METHOD(GetParent)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(ppOut);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSGLOBALSCALLBACK2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsHelpAttributeList.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSHELPATTRIBUTELIST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSHELPATTRIBUTELIST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "context.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsHelpAttributeListNotImpl :
	public IVsHelpAttributeList
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHelpAttributeListNotImpl)

public:

	typedef IVsHelpAttributeList Interface;

	STDMETHOD(GetAttributeName)(
		/*[out]*/ BSTR* /*bstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCount)(
		/*[out]*/ int* /*pCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateAttributeStatus)(
		/*[in]*/ BOOL* /*afActive*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetAttributeStatusVal)(
		/*[in]*/ BSTR /*bstrValue*/,
		/*[in]*/ ATTRVALUETYPE /*type*/,
		/*[out]*/ BOOL* /*pfActive*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetAttributeStatusIndex)(
		/*[in]*/ int /*index*/,
		/*[out]*/ BOOL* /*pfActive*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetAttributeValue)(
		/*[in]*/ int /*index*/,
		/*[in]*/ ATTRVALUETYPE /*type*/,
		/*[out]*/ BSTR* /*pbstrValue*/)VSL_STDMETHOD_NOTIMPL
};

class IVsHelpAttributeListMockImpl :
	public IVsHelpAttributeList,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHelpAttributeListMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsHelpAttributeListMockImpl)

	typedef IVsHelpAttributeList Interface;
	struct GetAttributeNameValidValues
	{
		/*[out]*/ BSTR* bstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetAttributeName)(
		/*[out]*/ BSTR* bstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetAttributeName)

		VSL_SET_VALIDVALUE_BSTR(bstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCountValidValues
	{
		/*[out]*/ int* pCount;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out]*/ int* pCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateAttributeStatusValidValues
	{
		/*[in]*/ BOOL* afActive;
		HRESULT retValue;
	};

	STDMETHOD(UpdateAttributeStatus)(
		/*[in]*/ BOOL* afActive)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateAttributeStatus)

		VSL_CHECK_VALIDVALUE_POINTER(afActive);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetAttributeStatusValValidValues
	{
		/*[in]*/ BSTR bstrValue;
		/*[in]*/ ATTRVALUETYPE type;
		/*[out]*/ BOOL* pfActive;
		HRESULT retValue;
	};

	STDMETHOD(GetAttributeStatusVal)(
		/*[in]*/ BSTR bstrValue,
		/*[in]*/ ATTRVALUETYPE type,
		/*[out]*/ BOOL* pfActive)
	{
		VSL_DEFINE_MOCK_METHOD(GetAttributeStatusVal)

		VSL_CHECK_VALIDVALUE_BSTR(bstrValue);

		VSL_CHECK_VALIDVALUE(type);

		VSL_SET_VALIDVALUE(pfActive);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetAttributeStatusIndexValidValues
	{
		/*[in]*/ int index;
		/*[out]*/ BOOL* pfActive;
		HRESULT retValue;
	};

	STDMETHOD(GetAttributeStatusIndex)(
		/*[in]*/ int index,
		/*[out]*/ BOOL* pfActive)
	{
		VSL_DEFINE_MOCK_METHOD(GetAttributeStatusIndex)

		VSL_CHECK_VALIDVALUE(index);

		VSL_SET_VALIDVALUE(pfActive);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetAttributeValueValidValues
	{
		/*[in]*/ int index;
		/*[in]*/ ATTRVALUETYPE type;
		/*[out]*/ BSTR* pbstrValue;
		HRESULT retValue;
	};

	STDMETHOD(GetAttributeValue)(
		/*[in]*/ int index,
		/*[in]*/ ATTRVALUETYPE type,
		/*[out]*/ BSTR* pbstrValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetAttributeValue)

		VSL_CHECK_VALIDVALUE(index);

		VSL_CHECK_VALIDVALUE(type);

		VSL_SET_VALIDVALUE_BSTR(pbstrValue);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSHELPATTRIBUTELIST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsHelpEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSHELPEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSHELPEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vshelp.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsHelpEventsNotImpl :
	public IVsHelpEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHelpEventsNotImpl)

public:

	typedef IVsHelpEvents Interface;

	STDMETHOD(OnFilterChanged)(
		/*[in]*/ BSTR /*bstrNewFilter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnCollectionChanged)(
		/*[in]*/ BSTR /*bstrNewCollection*/,
		/*[in]*/ BSTR /*bstrNewFilter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class IVsHelpEventsMockImpl :
	public IVsHelpEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHelpEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsHelpEventsMockImpl)

	typedef IVsHelpEvents Interface;
	struct OnFilterChangedValidValues
	{
		/*[in]*/ BSTR bstrNewFilter;
		HRESULT retValue;
	};

	STDMETHOD(OnFilterChanged)(
		/*[in]*/ BSTR bstrNewFilter)
	{
		VSL_DEFINE_MOCK_METHOD(OnFilterChanged)

		VSL_CHECK_VALIDVALUE_BSTR(bstrNewFilter);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnCollectionChangedValidValues
	{
		/*[in]*/ BSTR bstrNewCollection;
		/*[in]*/ BSTR bstrNewFilter;
		HRESULT retValue;
	};

	STDMETHOD(OnCollectionChanged)(
		/*[in]*/ BSTR bstrNewCollection,
		/*[in]*/ BSTR bstrNewFilter)
	{
		VSL_DEFINE_MOCK_METHOD(OnCollectionChanged)

		VSL_CHECK_VALIDVALUE_BSTR(bstrNewCollection);

		VSL_CHECK_VALIDVALUE_BSTR(bstrNewFilter);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSHELPEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsHiddenTextSessionEx.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSHIDDENTEXTSESSIONEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSHIDDENTEXTSESSIONEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsHiddenTextSessionExNotImpl :
	public IVsHiddenTextSessionEx
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHiddenTextSessionExNotImpl)

public:

	typedef IVsHiddenTextSessionEx Interface;

	STDMETHOD(AddHiddenRegionsEx)(
		/*[in]*/ DWORD /*dwUpdateFlags*/,
		/*[in]*/ long /*cRegions*/,
		/*[in,size_is(cRegions)]*/ NewHiddenRegionEx* /*rgHidReg*/,
		/*[out]*/ IVsEnumHiddenRegions** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL
};

class IVsHiddenTextSessionExMockImpl :
	public IVsHiddenTextSessionEx,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHiddenTextSessionExMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsHiddenTextSessionExMockImpl)

	typedef IVsHiddenTextSessionEx Interface;
	struct AddHiddenRegionsExValidValues
	{
		/*[in]*/ DWORD dwUpdateFlags;
		/*[in]*/ long cRegions;
		/*[in,size_is(cRegions)]*/ NewHiddenRegionEx* rgHidReg;
		/*[out]*/ IVsEnumHiddenRegions** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(AddHiddenRegionsEx)(
		/*[in]*/ DWORD dwUpdateFlags,
		/*[in]*/ long cRegions,
		/*[in,size_is(cRegions)]*/ NewHiddenRegionEx* rgHidReg,
		/*[out]*/ IVsEnumHiddenRegions** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(AddHiddenRegionsEx)

		VSL_CHECK_VALIDVALUE(dwUpdateFlags);

		VSL_CHECK_VALIDVALUE(cRegions);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgHidReg, cRegions*sizeof(rgHidReg[0]), validValues.cRegions*sizeof(validValues.rgHidReg[0]));

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSHIDDENTEXTSESSIONEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsHiddenTextManager.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSHIDDENTEXTMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSHIDDENTEXTMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsHiddenTextManagerNotImpl :
	public IVsHiddenTextManager
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHiddenTextManagerNotImpl)

public:

	typedef IVsHiddenTextManager Interface;

	STDMETHOD(GetHiddenTextSession)(
		/*[in]*/ IUnknown* /*pOwningObject*/,
		/*[out]*/ IVsHiddenTextSession** /*ppSession*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateHiddenTextSession)(
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in]*/ IUnknown* /*pOwningObject*/,
		/*[in]*/ IVsHiddenTextClient* /*pClient*/,
		/*[out]*/ IVsHiddenTextSession** /*ppState*/)VSL_STDMETHOD_NOTIMPL
};

class IVsHiddenTextManagerMockImpl :
	public IVsHiddenTextManager,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHiddenTextManagerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsHiddenTextManagerMockImpl)

	typedef IVsHiddenTextManager Interface;
	struct GetHiddenTextSessionValidValues
	{
		/*[in]*/ IUnknown* pOwningObject;
		/*[out]*/ IVsHiddenTextSession** ppSession;
		HRESULT retValue;
	};

	STDMETHOD(GetHiddenTextSession)(
		/*[in]*/ IUnknown* pOwningObject,
		/*[out]*/ IVsHiddenTextSession** ppSession)
	{
		VSL_DEFINE_MOCK_METHOD(GetHiddenTextSession)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pOwningObject);

		VSL_SET_VALIDVALUE_INTERFACE(ppSession);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateHiddenTextSessionValidValues
	{
		/*[in]*/ DWORD dwFlags;
		/*[in]*/ IUnknown* pOwningObject;
		/*[in]*/ IVsHiddenTextClient* pClient;
		/*[out]*/ IVsHiddenTextSession** ppState;
		HRESULT retValue;
	};

	STDMETHOD(CreateHiddenTextSession)(
		/*[in]*/ DWORD dwFlags,
		/*[in]*/ IUnknown* pOwningObject,
		/*[in]*/ IVsHiddenTextClient* pClient,
		/*[out]*/ IVsHiddenTextSession** ppState)
	{
		VSL_DEFINE_MOCK_METHOD(CreateHiddenTextSession)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pOwningObject);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pClient);

		VSL_SET_VALIDVALUE_INTERFACE(ppState);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSHIDDENTEXTMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsHiddenRegionEx.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSHIDDENREGIONEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSHIDDENREGIONEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsHiddenRegionExNotImpl :
	public IVsHiddenRegionEx
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHiddenRegionExNotImpl)

public:

	typedef IVsHiddenRegionEx Interface;

	STDMETHOD(GetBannerAttr)(
		/*[in]*/ DWORD /*dwLength*/,
		/*[out,size_is(dwLength)]*/ ULONG* /*pColorAttr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetBannerAttr)(
		/*[in]*/ DWORD /*dwLength*/,
		/*[in,size_is(dwLength)]*/ ULONG* /*pColorAttr*/)VSL_STDMETHOD_NOTIMPL
};

class IVsHiddenRegionExMockImpl :
	public IVsHiddenRegionEx,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHiddenRegionExMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsHiddenRegionExMockImpl)

	typedef IVsHiddenRegionEx Interface;
	struct GetBannerAttrValidValues
	{
		/*[in]*/ DWORD dwLength;
		/*[out,size_is(dwLength)]*/ ULONG* pColorAttr;
		HRESULT retValue;
	};

	STDMETHOD(GetBannerAttr)(
		/*[in]*/ DWORD dwLength,
		/*[out,size_is(dwLength)]*/ ULONG* pColorAttr)
	{
		VSL_DEFINE_MOCK_METHOD(GetBannerAttr)

		VSL_CHECK_VALIDVALUE(dwLength);

		VSL_SET_VALIDVALUE_MEMCPY(pColorAttr, dwLength*sizeof(pColorAttr[0]), validValues.dwLength*sizeof(validValues.pColorAttr[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct SetBannerAttrValidValues
	{
		/*[in]*/ DWORD dwLength;
		/*[in,size_is(dwLength)]*/ ULONG* pColorAttr;
		HRESULT retValue;
	};

	STDMETHOD(SetBannerAttr)(
		/*[in]*/ DWORD dwLength,
		/*[in,size_is(dwLength)]*/ ULONG* pColorAttr)
	{
		VSL_DEFINE_MOCK_METHOD(SetBannerAttr)

		VSL_CHECK_VALIDVALUE(dwLength);

		VSL_CHECK_VALIDVALUE_MEMCMP(pColorAttr, dwLength*sizeof(pColorAttr[0]), validValues.dwLength*sizeof(validValues.pColorAttr[0]));

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSHIDDENREGIONEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsHiColorItem.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSHICOLORITEM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSHICOLORITEM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsHiColorItemNotImpl :
	public IVsHiColorItem
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHiColorItemNotImpl)

public:

	typedef IVsHiColorItem Interface;

	STDMETHOD(GetColorData)(
		/*[in]*/ VSCOLORDATA /*cdElement*/,
		/*[out]*/ COLORREF* /*pcrColor*/)VSL_STDMETHOD_NOTIMPL
};

class IVsHiColorItemMockImpl :
	public IVsHiColorItem,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHiColorItemMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsHiColorItemMockImpl)

	typedef IVsHiColorItem Interface;
	struct GetColorDataValidValues
	{
		/*[in]*/ VSCOLORDATA cdElement;
		/*[out]*/ COLORREF* pcrColor;
		HRESULT retValue;
	};

	STDMETHOD(GetColorData)(
		/*[in]*/ VSCOLORDATA cdElement,
		/*[out]*/ COLORREF* pcrColor)
	{
		VSL_DEFINE_MOCK_METHOD(GetColorData)

		VSL_CHECK_VALIDVALUE(cdElement);

		VSL_SET_VALIDVALUE(pcrColor);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSHICOLORITEM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsHiddenRegion.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSHIDDENREGION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSHIDDENREGION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsHiddenRegionNotImpl :
	public IVsHiddenRegion
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHiddenRegionNotImpl)

public:

	typedef IVsHiddenRegion Interface;

	STDMETHOD(GetType)(
		/*[out]*/ long* /*piHiddenRegionType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBehavior)(
		/*[out]*/ DWORD* /*pdwBehavior*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetState)(
		/*[out]*/ DWORD* /*dwState*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetState)(
		/*[in]*/ DWORD /*dwState*/,
		/*[in]*/ DWORD /*dwUpdate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBanner)(
		/*[out]*/ BSTR* /*pbstrBanner*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetBanner)(
		/*[in]*/ LPCWSTR /*pszBanner*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSpan)(
		/*[out]*/ TextSpan* /*pSpan*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetSpan)(
		/*[in]*/ TextSpan* /*pSpan*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetClientData)(
		/*[out]*/ DWORD_PTR* /*pdwData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetClientData)(
		/*[in]*/ DWORD_PTR /*dwData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invalidate)(
		/*[in]*/ DWORD /*dwUpdate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsValid)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBaseBuffer)(
		/*[out]*/ IVsTextLines** /*ppBuffer*/)VSL_STDMETHOD_NOTIMPL
};

class IVsHiddenRegionMockImpl :
	public IVsHiddenRegion,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHiddenRegionMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsHiddenRegionMockImpl)

	typedef IVsHiddenRegion Interface;
	struct GetTypeValidValues
	{
		/*[out]*/ long* piHiddenRegionType;
		HRESULT retValue;
	};

	STDMETHOD(GetType)(
		/*[out]*/ long* piHiddenRegionType)
	{
		VSL_DEFINE_MOCK_METHOD(GetType)

		VSL_SET_VALIDVALUE(piHiddenRegionType);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBehaviorValidValues
	{
		/*[out]*/ DWORD* pdwBehavior;
		HRESULT retValue;
	};

	STDMETHOD(GetBehavior)(
		/*[out]*/ DWORD* pdwBehavior)
	{
		VSL_DEFINE_MOCK_METHOD(GetBehavior)

		VSL_SET_VALIDVALUE(pdwBehavior);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetStateValidValues
	{
		/*[out]*/ DWORD* dwState;
		HRESULT retValue;
	};

	STDMETHOD(GetState)(
		/*[out]*/ DWORD* dwState)
	{
		VSL_DEFINE_MOCK_METHOD(GetState)

		VSL_SET_VALIDVALUE(dwState);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetStateValidValues
	{
		/*[in]*/ DWORD dwState;
		/*[in]*/ DWORD dwUpdate;
		HRESULT retValue;
	};

	STDMETHOD(SetState)(
		/*[in]*/ DWORD dwState,
		/*[in]*/ DWORD dwUpdate)
	{
		VSL_DEFINE_MOCK_METHOD(SetState)

		VSL_CHECK_VALIDVALUE(dwState);

		VSL_CHECK_VALIDVALUE(dwUpdate);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBannerValidValues
	{
		/*[out]*/ BSTR* pbstrBanner;
		HRESULT retValue;
	};

	STDMETHOD(GetBanner)(
		/*[out]*/ BSTR* pbstrBanner)
	{
		VSL_DEFINE_MOCK_METHOD(GetBanner)

		VSL_SET_VALIDVALUE_BSTR(pbstrBanner);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetBannerValidValues
	{
		/*[in]*/ LPCWSTR pszBanner;
		HRESULT retValue;
	};

	STDMETHOD(SetBanner)(
		/*[in]*/ LPCWSTR pszBanner)
	{
		VSL_DEFINE_MOCK_METHOD(SetBanner)

		VSL_CHECK_VALIDVALUE_STRINGW(pszBanner);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSpanValidValues
	{
		/*[out]*/ TextSpan* pSpan;
		HRESULT retValue;
	};

	STDMETHOD(GetSpan)(
		/*[out]*/ TextSpan* pSpan)
	{
		VSL_DEFINE_MOCK_METHOD(GetSpan)

		VSL_SET_VALIDVALUE(pSpan);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetSpanValidValues
	{
		/*[in]*/ TextSpan* pSpan;
		HRESULT retValue;
	};

	STDMETHOD(SetSpan)(
		/*[in]*/ TextSpan* pSpan)
	{
		VSL_DEFINE_MOCK_METHOD(SetSpan)

		VSL_CHECK_VALIDVALUE_POINTER(pSpan);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetClientDataValidValues
	{
		/*[out]*/ DWORD_PTR* pdwData;
		HRESULT retValue;
	};

	STDMETHOD(GetClientData)(
		/*[out]*/ DWORD_PTR* pdwData)
	{
		VSL_DEFINE_MOCK_METHOD(GetClientData)

		VSL_SET_VALIDVALUE(pdwData);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetClientDataValidValues
	{
		/*[in]*/ DWORD_PTR dwData;
		HRESULT retValue;
	};

	STDMETHOD(SetClientData)(
		/*[in]*/ DWORD_PTR dwData)
	{
		VSL_DEFINE_MOCK_METHOD(SetClientData)

		VSL_CHECK_VALIDVALUE(dwData);

		VSL_RETURN_VALIDVALUES();
	}
	struct InvalidateValidValues
	{
		/*[in]*/ DWORD dwUpdate;
		HRESULT retValue;
	};

	STDMETHOD(Invalidate)(
		/*[in]*/ DWORD dwUpdate)
	{
		VSL_DEFINE_MOCK_METHOD(Invalidate)

		VSL_CHECK_VALIDVALUE(dwUpdate);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsValidValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(IsValid)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(IsValid)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBaseBufferValidValues
	{
		/*[out]*/ IVsTextLines** ppBuffer;
		HRESULT retValue;
	};

	STDMETHOD(GetBaseBuffer)(
		/*[out]*/ IVsTextLines** ppBuffer)
	{
		VSL_DEFINE_MOCK_METHOD(GetBaseBuffer)

		VSL_SET_VALIDVALUE_INTERFACE(ppBuffer);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSHIDDENREGION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsHiddenTextClientEx.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSHIDDENTEXTCLIENTEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSHIDDENTEXTCLIENTEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsHiddenTextClientExNotImpl :
	public IVsHiddenTextClientEx
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHiddenTextClientExNotImpl)

public:

	typedef IVsHiddenTextClientEx Interface;

	STDMETHOD(GetBannerGlyphWidth)(
		/*[in]*/ long /*iPixSpaceWidth*/,
		/*[out]*/ long* /*pGlyphPix*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DrawBannerGlyph)(
		/*[in]*/ IVsHiddenRegion* /*pHidReg*/,
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in]*/ HDC /*hdc*/,
		/*[in]*/ RECT* /*pRect*/)VSL_STDMETHOD_NOTIMPL
};

class IVsHiddenTextClientExMockImpl :
	public IVsHiddenTextClientEx,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHiddenTextClientExMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsHiddenTextClientExMockImpl)

	typedef IVsHiddenTextClientEx Interface;
	struct GetBannerGlyphWidthValidValues
	{
		/*[in]*/ long iPixSpaceWidth;
		/*[out]*/ long* pGlyphPix;
		HRESULT retValue;
	};

	STDMETHOD(GetBannerGlyphWidth)(
		/*[in]*/ long iPixSpaceWidth,
		/*[out]*/ long* pGlyphPix)
	{
		VSL_DEFINE_MOCK_METHOD(GetBannerGlyphWidth)

		VSL_CHECK_VALIDVALUE(iPixSpaceWidth);

		VSL_SET_VALIDVALUE(pGlyphPix);

		VSL_RETURN_VALIDVALUES();
	}
	struct DrawBannerGlyphValidValues
	{
		/*[in]*/ IVsHiddenRegion* pHidReg;
		/*[in]*/ DWORD dwFlags;
		/*[in]*/ HDC hdc;
		/*[in]*/ RECT* pRect;
		HRESULT retValue;
	};

	STDMETHOD(DrawBannerGlyph)(
		/*[in]*/ IVsHiddenRegion* pHidReg,
		/*[in]*/ DWORD dwFlags,
		/*[in]*/ HDC hdc,
		/*[in]*/ RECT* pRect)
	{
		VSL_DEFINE_MOCK_METHOD(DrawBannerGlyph)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHidReg);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE(hdc);

		VSL_CHECK_VALIDVALUE_POINTER(pRect);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSHIDDENTEXTCLIENTEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsHelpTopicShowEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSHELPTOPICSHOWEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSHELPTOPICSHOWEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vshelp.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsHelpTopicShowEventsNotImpl :
	public IVsHelpTopicShowEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHelpTopicShowEventsNotImpl)

public:

	typedef IVsHelpTopicShowEvents Interface;

	STDMETHOD(OnBeforeTopicShow)(
		/*[in]*/ BSTR /*bstrURL*/,
		/*[in]*/ IDispatch* /*pWB*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnTopicShowComplete)(
		/*[in]*/ BSTR /*bstrURL*/,
		/*[in]*/ IDispatch* /*pWB*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class IVsHelpTopicShowEventsMockImpl :
	public IVsHelpTopicShowEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHelpTopicShowEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsHelpTopicShowEventsMockImpl)

	typedef IVsHelpTopicShowEvents Interface;
	struct OnBeforeTopicShowValidValues
	{
		/*[in]*/ BSTR bstrURL;
		/*[in]*/ IDispatch* pWB;
		HRESULT retValue;
	};

	STDMETHOD(OnBeforeTopicShow)(
		/*[in]*/ BSTR bstrURL,
		/*[in]*/ IDispatch* pWB)
	{
		VSL_DEFINE_MOCK_METHOD(OnBeforeTopicShow)

		VSL_CHECK_VALIDVALUE_BSTR(bstrURL);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pWB);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnTopicShowCompleteValidValues
	{
		/*[in]*/ BSTR bstrURL;
		/*[in]*/ IDispatch* pWB;
		HRESULT retValue;
	};

	STDMETHOD(OnTopicShowComplete)(
		/*[in]*/ BSTR bstrURL,
		/*[in]*/ IDispatch* pWB)
	{
		VSL_DEFINE_MOCK_METHOD(OnTopicShowComplete)

		VSL_CHECK_VALIDVALUE_BSTR(bstrURL);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pWB);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSHELPTOPICSHOWEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsHiddenTextSession.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSHIDDENTEXTSESSION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSHIDDENTEXTSESSION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsHiddenTextSessionNotImpl :
	public IVsHiddenTextSession
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHiddenTextSessionNotImpl)

public:

	typedef IVsHiddenTextSession Interface;

	STDMETHOD(AddHiddenRegions)(
		/*[in]*/ DWORD /*dwUpdateFlags*/,
		/*[in]*/ long /*cRegions*/,
		/*[in,size_is(cRegions)]*/ NewHiddenRegion* /*rgHidReg*/,
		/*[out]*/ IVsEnumHiddenRegions** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumHiddenRegions)(
		/*[in]*/ DWORD /*dwFindFlags*/,
		/*[in]*/ DWORD_PTR /*dwCookie*/,
		/*[in]*/ TextSpan* /*ptsRange*/,
		/*[out]*/ IVsEnumHiddenRegions** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseClient)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Terminate)()VSL_STDMETHOD_NOTIMPL
};

class IVsHiddenTextSessionMockImpl :
	public IVsHiddenTextSession,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHiddenTextSessionMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsHiddenTextSessionMockImpl)

	typedef IVsHiddenTextSession Interface;
	struct AddHiddenRegionsValidValues
	{
		/*[in]*/ DWORD dwUpdateFlags;
		/*[in]*/ long cRegions;
		/*[in,size_is(cRegions)]*/ NewHiddenRegion* rgHidReg;
		/*[out]*/ IVsEnumHiddenRegions** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(AddHiddenRegions)(
		/*[in]*/ DWORD dwUpdateFlags,
		/*[in]*/ long cRegions,
		/*[in,size_is(cRegions)]*/ NewHiddenRegion* rgHidReg,
		/*[out]*/ IVsEnumHiddenRegions** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(AddHiddenRegions)

		VSL_CHECK_VALIDVALUE(dwUpdateFlags);

		VSL_CHECK_VALIDVALUE(cRegions);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgHidReg, cRegions*sizeof(rgHidReg[0]), validValues.cRegions*sizeof(validValues.rgHidReg[0]));

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumHiddenRegionsValidValues
	{
		/*[in]*/ DWORD dwFindFlags;
		/*[in]*/ DWORD_PTR dwCookie;
		/*[in]*/ TextSpan* ptsRange;
		/*[out]*/ IVsEnumHiddenRegions** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumHiddenRegions)(
		/*[in]*/ DWORD dwFindFlags,
		/*[in]*/ DWORD_PTR dwCookie,
		/*[in]*/ TextSpan* ptsRange,
		/*[out]*/ IVsEnumHiddenRegions** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumHiddenRegions)

		VSL_CHECK_VALIDVALUE(dwFindFlags);

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_CHECK_VALIDVALUE_POINTER(ptsRange);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseClientValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(UnadviseClient)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(UnadviseClient)

		VSL_RETURN_VALIDVALUES();
	}
	struct TerminateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Terminate)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Terminate)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSHIDDENTEXTSESSION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsHierarchyDeleteHandler.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSHIERARCHYDELETEHANDLER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSHIERARCHYDELETEHANDLER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsHierarchyDeleteHandlerNotImpl :
	public IVsHierarchyDeleteHandler
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHierarchyDeleteHandlerNotImpl)

public:

	typedef IVsHierarchyDeleteHandler Interface;

	STDMETHOD(QueryDeleteItem)(
		/*[in]*/ VSDELETEITEMOPERATION /*dwDelItemOp*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[out,retval]*/ BOOL* /*pfCanDelete*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DeleteItem)(
		/*[in]*/ VSDELETEITEMOPERATION /*dwDelItemOp*/,
		/*[in]*/ VSITEMID /*itemid*/)VSL_STDMETHOD_NOTIMPL
};

class IVsHierarchyDeleteHandlerMockImpl :
	public IVsHierarchyDeleteHandler,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHierarchyDeleteHandlerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsHierarchyDeleteHandlerMockImpl)

	typedef IVsHierarchyDeleteHandler Interface;
	struct QueryDeleteItemValidValues
	{
		/*[in]*/ VSDELETEITEMOPERATION dwDelItemOp;
		/*[in]*/ VSITEMID itemid;
		/*[out,retval]*/ BOOL* pfCanDelete;
		HRESULT retValue;
	};

	STDMETHOD(QueryDeleteItem)(
		/*[in]*/ VSDELETEITEMOPERATION dwDelItemOp,
		/*[in]*/ VSITEMID itemid,
		/*[out,retval]*/ BOOL* pfCanDelete)
	{
		VSL_DEFINE_MOCK_METHOD(QueryDeleteItem)

		VSL_CHECK_VALIDVALUE(dwDelItemOp);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_SET_VALIDVALUE(pfCanDelete);

		VSL_RETURN_VALIDVALUES();
	}
	struct DeleteItemValidValues
	{
		/*[in]*/ VSDELETEITEMOPERATION dwDelItemOp;
		/*[in]*/ VSITEMID itemid;
		HRESULT retValue;
	};

	STDMETHOD(DeleteItem)(
		/*[in]*/ VSDELETEITEMOPERATION dwDelItemOp,
		/*[in]*/ VSITEMID itemid)
	{
		VSL_DEFINE_MOCK_METHOD(DeleteItem)

		VSL_CHECK_VALIDVALUE(dwDelItemOp);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSHIERARCHYDELETEHANDLER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsHierarchyDropDataSource.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSHIERARCHYDROPDATASOURCE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSHIERARCHYDROPDATASOURCE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsHierarchyDropDataSourceNotImpl :
	public IVsHierarchyDropDataSource
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHierarchyDropDataSourceNotImpl)

public:

	typedef IVsHierarchyDropDataSource Interface;

	STDMETHOD(GetDropInfo)(
		/*[out]*/ DWORD* /*pdwOKEffects*/,
		/*[out]*/ IDataObject** /*ppDataObject*/,
		/*[out]*/ IDropSource** /*ppDropSource*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnDropNotify)(
		/*[in]*/ BOOL /*fDropped*/,
		/*[in]*/ DWORD /*dwEffects*/)VSL_STDMETHOD_NOTIMPL
};

class IVsHierarchyDropDataSourceMockImpl :
	public IVsHierarchyDropDataSource,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHierarchyDropDataSourceMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsHierarchyDropDataSourceMockImpl)

	typedef IVsHierarchyDropDataSource Interface;
	struct GetDropInfoValidValues
	{
		/*[out]*/ DWORD* pdwOKEffects;
		/*[out]*/ IDataObject** ppDataObject;
		/*[out]*/ IDropSource** ppDropSource;
		HRESULT retValue;
	};

	STDMETHOD(GetDropInfo)(
		/*[out]*/ DWORD* pdwOKEffects,
		/*[out]*/ IDataObject** ppDataObject,
		/*[out]*/ IDropSource** ppDropSource)
	{
		VSL_DEFINE_MOCK_METHOD(GetDropInfo)

		VSL_SET_VALIDVALUE(pdwOKEffects);

		VSL_SET_VALIDVALUE_INTERFACE(ppDataObject);

		VSL_SET_VALIDVALUE_INTERFACE(ppDropSource);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnDropNotifyValidValues
	{
		/*[in]*/ BOOL fDropped;
		/*[in]*/ DWORD dwEffects;
		HRESULT retValue;
	};

	STDMETHOD(OnDropNotify)(
		/*[in]*/ BOOL fDropped,
		/*[in]*/ DWORD dwEffects)
	{
		VSL_DEFINE_MOCK_METHOD(OnDropNotify)

		VSL_CHECK_VALIDVALUE(fDropped);

		VSL_CHECK_VALIDVALUE(dwEffects);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSHIERARCHYDROPDATASOURCE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsHierarchy.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSHIERARCHY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSHIERARCHY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsHierarchyNotImpl :
	public IVsHierarchy
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHierarchyNotImpl)

public:

	typedef IVsHierarchy Interface;

	STDMETHOD(SetSite)(
		/*[in]*/ IServiceProvider* /*pSP*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSite)(
		/*[out]*/ IServiceProvider** /*ppSP*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryClose)(
		/*[out]*/ BOOL* /*pfCanClose*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Close)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetGuidProperty)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ VSHPROPID /*propid*/,
		/*[out]*/ GUID* /*pguid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetGuidProperty)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ VSHPROPID /*propid*/,
		/*[in]*/ REFGUID /*rguid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProperty)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ VSHPROPID /*propid*/,
		/*[out]*/ VARIANT* /*pvar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetProperty)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ VSHPROPID /*propid*/,
		/*[in]*/ VARIANT /*var*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetNestedHierarchy)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ REFIID /*iidHierarchyNested*/,
		/*[out,iid_is(iidHierarchyNested)]*/ void** /*ppHierarchyNested*/,
		/*[out]*/ VSITEMID* /*pitemidNested*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCanonicalName)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ParseCanonicalName)(
		/*[in]*/ LPCOLESTR /*pszName*/,
		/*[out]*/ VSITEMID* /*pitemid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Unused0)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AdviseHierarchyEvents)(
		/*[in]*/ IVsHierarchyEvents* /*pEventSink*/,
		/*[out]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseHierarchyEvents)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Unused1)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Unused2)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Unused3)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Unused4)()VSL_STDMETHOD_NOTIMPL
};

class IVsHierarchyMockImpl :
	public IVsHierarchy,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHierarchyMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsHierarchyMockImpl)

	typedef IVsHierarchy Interface;
	struct SetSiteValidValues
	{
		/*[in]*/ IServiceProvider* pSP;
		HRESULT retValue;
	};

	STDMETHOD(SetSite)(
		/*[in]*/ IServiceProvider* pSP)
	{
		VSL_DEFINE_MOCK_METHOD(SetSite)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSP);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSiteValidValues
	{
		/*[out]*/ IServiceProvider** ppSP;
		HRESULT retValue;
	};

	STDMETHOD(GetSite)(
		/*[out]*/ IServiceProvider** ppSP)
	{
		VSL_DEFINE_MOCK_METHOD(GetSite)

		VSL_SET_VALIDVALUE_INTERFACE(ppSP);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryCloseValidValues
	{
		/*[out]*/ BOOL* pfCanClose;
		HRESULT retValue;
	};

	STDMETHOD(QueryClose)(
		/*[out]*/ BOOL* pfCanClose)
	{
		VSL_DEFINE_MOCK_METHOD(QueryClose)

		VSL_SET_VALIDVALUE(pfCanClose);

		VSL_RETURN_VALIDVALUES();
	}
	struct CloseValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Close)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Close)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetGuidPropertyValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ VSHPROPID propid;
		/*[out]*/ GUID* pguid;
		HRESULT retValue;
	};

	STDMETHOD(GetGuidProperty)(
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ VSHPROPID propid,
		/*[out]*/ GUID* pguid)
	{
		VSL_DEFINE_MOCK_METHOD(GetGuidProperty)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE(propid);

		VSL_SET_VALIDVALUE(pguid);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetGuidPropertyValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ VSHPROPID propid;
		/*[in]*/ REFGUID rguid;
		HRESULT retValue;
	};

	STDMETHOD(SetGuidProperty)(
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ VSHPROPID propid,
		/*[in]*/ REFGUID rguid)
	{
		VSL_DEFINE_MOCK_METHOD(SetGuidProperty)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE(propid);

		VSL_CHECK_VALIDVALUE(rguid);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPropertyValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ VSHPROPID propid;
		/*[out]*/ VARIANT* pvar;
		HRESULT retValue;
	};

	STDMETHOD(GetProperty)(
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ VSHPROPID propid,
		/*[out]*/ VARIANT* pvar)
	{
		VSL_DEFINE_MOCK_METHOD(GetProperty)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE(propid);

		VSL_SET_VALIDVALUE_VARIANT(pvar);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetPropertyValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ VSHPROPID propid;
		/*[in]*/ VARIANT var;
		HRESULT retValue;
	};

	STDMETHOD(SetProperty)(
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ VSHPROPID propid,
		/*[in]*/ VARIANT var)
	{
		VSL_DEFINE_MOCK_METHOD(SetProperty)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE(propid);

		VSL_CHECK_VALIDVALUE(var);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNestedHierarchyValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ REFIID iidHierarchyNested;
		/*[out,iid_is(iidHierarchyNested)]*/ void** ppHierarchyNested;
		/*[out]*/ VSITEMID* pitemidNested;
		HRESULT retValue;
	};

	STDMETHOD(GetNestedHierarchy)(
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ REFIID iidHierarchyNested,
		/*[out,iid_is(iidHierarchyNested)]*/ void** ppHierarchyNested,
		/*[out]*/ VSITEMID* pitemidNested)
	{
		VSL_DEFINE_MOCK_METHOD(GetNestedHierarchy)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE(iidHierarchyNested);

		VSL_SET_VALIDVALUE(ppHierarchyNested);

		VSL_SET_VALIDVALUE(pitemidNested);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCanonicalNameValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetCanonicalName)(
		/*[in]*/ VSITEMID itemid,
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetCanonicalName)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct ParseCanonicalNameValidValues
	{
		/*[in]*/ LPCOLESTR pszName;
		/*[out]*/ VSITEMID* pitemid;
		HRESULT retValue;
	};

	STDMETHOD(ParseCanonicalName)(
		/*[in]*/ LPCOLESTR pszName,
		/*[out]*/ VSITEMID* pitemid)
	{
		VSL_DEFINE_MOCK_METHOD(ParseCanonicalName)

		VSL_CHECK_VALIDVALUE_STRINGW(pszName);

		VSL_SET_VALIDVALUE(pitemid);

		VSL_RETURN_VALIDVALUES();
	}
	struct Unused0ValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Unused0)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Unused0)

		VSL_RETURN_VALIDVALUES();
	}
	struct AdviseHierarchyEventsValidValues
	{
		/*[in]*/ IVsHierarchyEvents* pEventSink;
		/*[out]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(AdviseHierarchyEvents)(
		/*[in]*/ IVsHierarchyEvents* pEventSink,
		/*[out]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(AdviseHierarchyEvents)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pEventSink);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseHierarchyEventsValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnadviseHierarchyEvents)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnadviseHierarchyEvents)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct Unused1ValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Unused1)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Unused1)

		VSL_RETURN_VALIDVALUES();
	}
	struct Unused2ValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Unused2)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Unused2)

		VSL_RETURN_VALIDVALUES();
	}
	struct Unused3ValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Unused3)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Unused3)

		VSL_RETURN_VALIDVALUES();
	}
	struct Unused4ValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Unused4)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Unused4)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSHIERARCHY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsHierarchyDeleteHandler2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSHIERARCHYDELETEHANDLER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSHIERARCHYDELETEHANDLER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsHierarchyDeleteHandler2NotImpl :
	public IVsHierarchyDeleteHandler2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHierarchyDeleteHandler2NotImpl)

public:

	typedef IVsHierarchyDeleteHandler2 Interface;

	STDMETHOD(ShowSpecificDeleteRemoveMessage)(
		/*[in]*/ DWORD /*dwDelItemOps*/,
		/*[in]*/ ULONG /*cDelItems*/,
		/*[in,size_is(cDelItems)]*/ VSITEMID[] /*rgDelItems*/,
		/*[out]*/ BOOL* /*pfShowStandardMessage*/,
		/*[out]*/ VSDELETEITEMOPERATION* /*pdwDelItemOp*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ShowMultiSelDeleteOrRemoveMessage)(
		/*[in]*/ VSDELETEITEMOPERATION /*dwDelItemOp*/,
		/*[in]*/ ULONG /*cDelItems*/,
		/*[in,size_is(cDelItems)]*/ VSITEMID[] /*rgDelItems*/,
		/*[out]*/ BOOL* /*pfCancelOperation*/)VSL_STDMETHOD_NOTIMPL
};

class IVsHierarchyDeleteHandler2MockImpl :
	public IVsHierarchyDeleteHandler2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHierarchyDeleteHandler2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsHierarchyDeleteHandler2MockImpl)

	typedef IVsHierarchyDeleteHandler2 Interface;
	struct ShowSpecificDeleteRemoveMessageValidValues
	{
		/*[in]*/ DWORD dwDelItemOps;
		/*[in]*/ ULONG cDelItems;
		/*[in,size_is(cDelItems)]*/ VSITEMID* rgDelItems;
		/*[out]*/ BOOL* pfShowStandardMessage;
		/*[out]*/ VSDELETEITEMOPERATION* pdwDelItemOp;
		HRESULT retValue;
	};

	STDMETHOD(ShowSpecificDeleteRemoveMessage)(
		/*[in]*/ DWORD dwDelItemOps,
		/*[in]*/ ULONG cDelItems,
		/*[in,size_is(cDelItems)]*/ VSITEMID rgDelItems[],
		/*[out]*/ BOOL* pfShowStandardMessage,
		/*[out]*/ VSDELETEITEMOPERATION* pdwDelItemOp)
	{
		VSL_DEFINE_MOCK_METHOD(ShowSpecificDeleteRemoveMessage)

		VSL_CHECK_VALIDVALUE(dwDelItemOps);

		VSL_CHECK_VALIDVALUE(cDelItems);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgDelItems, cDelItems*sizeof(rgDelItems[0]), validValues.cDelItems*sizeof(validValues.rgDelItems[0]));

		VSL_SET_VALIDVALUE(pfShowStandardMessage);

		VSL_SET_VALIDVALUE(pdwDelItemOp);

		VSL_RETURN_VALIDVALUES();
	}
	struct ShowMultiSelDeleteOrRemoveMessageValidValues
	{
		/*[in]*/ VSDELETEITEMOPERATION dwDelItemOp;
		/*[in]*/ ULONG cDelItems;
		/*[in,size_is(cDelItems)]*/ VSITEMID* rgDelItems;
		/*[out]*/ BOOL* pfCancelOperation;
		HRESULT retValue;
	};

	STDMETHOD(ShowMultiSelDeleteOrRemoveMessage)(
		/*[in]*/ VSDELETEITEMOPERATION dwDelItemOp,
		/*[in]*/ ULONG cDelItems,
		/*[in,size_is(cDelItems)]*/ VSITEMID rgDelItems[],
		/*[out]*/ BOOL* pfCancelOperation)
	{
		VSL_DEFINE_MOCK_METHOD(ShowMultiSelDeleteOrRemoveMessage)

		VSL_CHECK_VALIDVALUE(dwDelItemOp);

		VSL_CHECK_VALIDVALUE(cDelItems);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgDelItems, cDelItems*sizeof(rgDelItems[0]), validValues.cDelItems*sizeof(validValues.rgDelItems[0]));

		VSL_SET_VALIDVALUE(pfCancelOperation);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSHIERARCHYDELETEHANDLER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsHierarchicalOutput.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSHIERARCHICALOUTPUT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSHIERARCHICALOUTPUT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsHierarchicalOutputNotImpl :
	public IVsHierarchicalOutput
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHierarchicalOutputNotImpl)

public:

	typedef IVsHierarchicalOutput Interface;

	STDMETHOD(EnumSubOutputs)(
		/*[out]*/ IVsEnumOutputs** /*ppIVsEnumOutputs*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DisplayName)(
		/*[out]*/ BSTR* /*pbstrDisplayName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CanonicalName)(
		/*[out]*/ BSTR* /*pbstrCanonicalName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DeploySourceURL)(
		/*[out]*/ BSTR* /*pbstrDeploySourceURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Type)(
		/*[out]*/ GUID* /*pguidType*/)VSL_STDMETHOD_NOTIMPL
};

class IVsHierarchicalOutputMockImpl :
	public IVsHierarchicalOutput,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHierarchicalOutputMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsHierarchicalOutputMockImpl)

	typedef IVsHierarchicalOutput Interface;
	struct EnumSubOutputsValidValues
	{
		/*[out]*/ IVsEnumOutputs** ppIVsEnumOutputs;
		HRESULT retValue;
	};

	STDMETHOD(EnumSubOutputs)(
		/*[out]*/ IVsEnumOutputs** ppIVsEnumOutputs)
	{
		VSL_DEFINE_MOCK_METHOD(EnumSubOutputs)

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsEnumOutputs);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DisplayNameValidValues
	{
		/*[out]*/ BSTR* pbstrDisplayName;
		HRESULT retValue;
	};

	STDMETHOD(get_DisplayName)(
		/*[out]*/ BSTR* pbstrDisplayName)
	{
		VSL_DEFINE_MOCK_METHOD(get_DisplayName)

		VSL_SET_VALIDVALUE_BSTR(pbstrDisplayName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CanonicalNameValidValues
	{
		/*[out]*/ BSTR* pbstrCanonicalName;
		HRESULT retValue;
	};

	STDMETHOD(get_CanonicalName)(
		/*[out]*/ BSTR* pbstrCanonicalName)
	{
		VSL_DEFINE_MOCK_METHOD(get_CanonicalName)

		VSL_SET_VALIDVALUE_BSTR(pbstrCanonicalName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DeploySourceURLValidValues
	{
		/*[out]*/ BSTR* pbstrDeploySourceURL;
		HRESULT retValue;
	};

	STDMETHOD(get_DeploySourceURL)(
		/*[out]*/ BSTR* pbstrDeploySourceURL)
	{
		VSL_DEFINE_MOCK_METHOD(get_DeploySourceURL)

		VSL_SET_VALIDVALUE_BSTR(pbstrDeploySourceURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_TypeValidValues
	{
		/*[out]*/ GUID* pguidType;
		HRESULT retValue;
	};

	STDMETHOD(get_Type)(
		/*[out]*/ GUID* pguidType)
	{
		VSL_DEFINE_MOCK_METHOD(get_Type)

		VSL_SET_VALIDVALUE(pguidType);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSHIERARCHICALOUTPUT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsHierarchyDropDataSource2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSHIERARCHYDROPDATASOURCE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSHIERARCHYDROPDATASOURCE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsHierarchyDropDataSource2NotImpl :
	public IVsHierarchyDropDataSource2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHierarchyDropDataSource2NotImpl)

public:

	typedef IVsHierarchyDropDataSource2 Interface;

	STDMETHOD(OnBeforeDropNotify)(
		/*[in]*/ IDataObject* /*pDataObject*/,
		/*[in]*/ DWORD /*dwEffect*/,
		/*[out,retval]*/ BOOL* /*pfCancelDrop*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDropInfo)(
		/*[out]*/ DWORD* /*pdwOKEffects*/,
		/*[out]*/ IDataObject** /*ppDataObject*/,
		/*[out]*/ IDropSource** /*ppDropSource*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnDropNotify)(
		/*[in]*/ BOOL /*fDropped*/,
		/*[in]*/ DWORD /*dwEffects*/)VSL_STDMETHOD_NOTIMPL
};

class IVsHierarchyDropDataSource2MockImpl :
	public IVsHierarchyDropDataSource2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHierarchyDropDataSource2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsHierarchyDropDataSource2MockImpl)

	typedef IVsHierarchyDropDataSource2 Interface;
	struct OnBeforeDropNotifyValidValues
	{
		/*[in]*/ IDataObject* pDataObject;
		/*[in]*/ DWORD dwEffect;
		/*[out,retval]*/ BOOL* pfCancelDrop;
		HRESULT retValue;
	};

	STDMETHOD(OnBeforeDropNotify)(
		/*[in]*/ IDataObject* pDataObject,
		/*[in]*/ DWORD dwEffect,
		/*[out,retval]*/ BOOL* pfCancelDrop)
	{
		VSL_DEFINE_MOCK_METHOD(OnBeforeDropNotify)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDataObject);

		VSL_CHECK_VALIDVALUE(dwEffect);

		VSL_SET_VALIDVALUE(pfCancelDrop);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDropInfoValidValues
	{
		/*[out]*/ DWORD* pdwOKEffects;
		/*[out]*/ IDataObject** ppDataObject;
		/*[out]*/ IDropSource** ppDropSource;
		HRESULT retValue;
	};

	STDMETHOD(GetDropInfo)(
		/*[out]*/ DWORD* pdwOKEffects,
		/*[out]*/ IDataObject** ppDataObject,
		/*[out]*/ IDropSource** ppDropSource)
	{
		VSL_DEFINE_MOCK_METHOD(GetDropInfo)

		VSL_SET_VALIDVALUE(pdwOKEffects);

		VSL_SET_VALIDVALUE_INTERFACE(ppDataObject);

		VSL_SET_VALIDVALUE_INTERFACE(ppDropSource);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnDropNotifyValidValues
	{
		/*[in]*/ BOOL fDropped;
		/*[in]*/ DWORD dwEffects;
		HRESULT retValue;
	};

	STDMETHOD(OnDropNotify)(
		/*[in]*/ BOOL fDropped,
		/*[in]*/ DWORD dwEffects)
	{
		VSL_DEFINE_MOCK_METHOD(OnDropNotify)

		VSL_CHECK_VALIDVALUE(fDropped);

		VSL_CHECK_VALIDVALUE(dwEffects);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSHIERARCHYDROPDATASOURCE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsHierarchyDropDataTarget.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSHIERARCHYDROPDATATARGET_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSHIERARCHYDROPDATATARGET_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsHierarchyDropDataTargetNotImpl :
	public IVsHierarchyDropDataTarget
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHierarchyDropDataTargetNotImpl)

public:

	typedef IVsHierarchyDropDataTarget Interface;

	STDMETHOD(DragEnter)(
		/*[in]*/ IDataObject* /*pDataObject*/,
		/*[in]*/ DWORD /*grfKeyState*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in,out]*/ DWORD* /*pdwEffect*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DragOver)(
		/*[in]*/ DWORD /*grfKeyState*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in,out]*/ DWORD* /*pdwEffect*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DragLeave)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Drop)(
		/*[in]*/ IDataObject* /*pDataObject*/,
		/*[in]*/ DWORD /*grfKeyState*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in,out]*/ DWORD* /*pdwEffect*/)VSL_STDMETHOD_NOTIMPL
};

class IVsHierarchyDropDataTargetMockImpl :
	public IVsHierarchyDropDataTarget,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHierarchyDropDataTargetMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsHierarchyDropDataTargetMockImpl)

	typedef IVsHierarchyDropDataTarget Interface;
	struct DragEnterValidValues
	{
		/*[in]*/ IDataObject* pDataObject;
		/*[in]*/ DWORD grfKeyState;
		/*[in]*/ VSITEMID itemid;
		/*[in,out]*/ DWORD* pdwEffect;
		HRESULT retValue;
	};

	STDMETHOD(DragEnter)(
		/*[in]*/ IDataObject* pDataObject,
		/*[in]*/ DWORD grfKeyState,
		/*[in]*/ VSITEMID itemid,
		/*[in,out]*/ DWORD* pdwEffect)
	{
		VSL_DEFINE_MOCK_METHOD(DragEnter)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDataObject);

		VSL_CHECK_VALIDVALUE(grfKeyState);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_SET_VALIDVALUE(pdwEffect);

		VSL_RETURN_VALIDVALUES();
	}
	struct DragOverValidValues
	{
		/*[in]*/ DWORD grfKeyState;
		/*[in]*/ VSITEMID itemid;
		/*[in,out]*/ DWORD* pdwEffect;
		HRESULT retValue;
	};

	STDMETHOD(DragOver)(
		/*[in]*/ DWORD grfKeyState,
		/*[in]*/ VSITEMID itemid,
		/*[in,out]*/ DWORD* pdwEffect)
	{
		VSL_DEFINE_MOCK_METHOD(DragOver)

		VSL_CHECK_VALIDVALUE(grfKeyState);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_SET_VALIDVALUE(pdwEffect);

		VSL_RETURN_VALIDVALUES();
	}
	struct DragLeaveValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(DragLeave)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(DragLeave)

		VSL_RETURN_VALIDVALUES();
	}
	struct DropValidValues
	{
		/*[in]*/ IDataObject* pDataObject;
		/*[in]*/ DWORD grfKeyState;
		/*[in]*/ VSITEMID itemid;
		/*[in,out]*/ DWORD* pdwEffect;
		HRESULT retValue;
	};

	STDMETHOD(Drop)(
		/*[in]*/ IDataObject* pDataObject,
		/*[in]*/ DWORD grfKeyState,
		/*[in]*/ VSITEMID itemid,
		/*[in,out]*/ DWORD* pdwEffect)
	{
		VSL_DEFINE_MOCK_METHOD(Drop)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDataObject);

		VSL_CHECK_VALIDVALUE(grfKeyState);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_SET_VALIDVALUE(pdwEffect);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSHIERARCHYDROPDATATARGET_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsHierarchyEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSHIERARCHYEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSHIERARCHYEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsHierarchyEventsNotImpl :
	public IVsHierarchyEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHierarchyEventsNotImpl)

public:

	typedef IVsHierarchyEvents Interface;

	STDMETHOD(OnItemAdded)(
		/*[in]*/ VSITEMID /*itemidParent*/,
		/*[in]*/ VSITEMID /*itemidSiblingPrev*/,
		/*[in]*/ VSITEMID /*itemidAdded*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnItemsAppended)(
		/*[in]*/ VSITEMID /*itemidParent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnItemDeleted)(
		/*[in]*/ VSITEMID /*itemid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnPropertyChanged)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ VSHPROPID /*propid*/,
		/*[in]*/ DWORD /*flags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnInvalidateItems)(
		/*[in]*/ VSITEMID /*itemidParent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnInvalidateIcon)(
		/*[in]*/ HICON /*hicon*/)VSL_STDMETHOD_NOTIMPL
};

class IVsHierarchyEventsMockImpl :
	public IVsHierarchyEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHierarchyEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsHierarchyEventsMockImpl)

	typedef IVsHierarchyEvents Interface;
	struct OnItemAddedValidValues
	{
		/*[in]*/ VSITEMID itemidParent;
		/*[in]*/ VSITEMID itemidSiblingPrev;
		/*[in]*/ VSITEMID itemidAdded;
		HRESULT retValue;
	};

	STDMETHOD(OnItemAdded)(
		/*[in]*/ VSITEMID itemidParent,
		/*[in]*/ VSITEMID itemidSiblingPrev,
		/*[in]*/ VSITEMID itemidAdded)
	{
		VSL_DEFINE_MOCK_METHOD(OnItemAdded)

		VSL_CHECK_VALIDVALUE(itemidParent);

		VSL_CHECK_VALIDVALUE(itemidSiblingPrev);

		VSL_CHECK_VALIDVALUE(itemidAdded);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnItemsAppendedValidValues
	{
		/*[in]*/ VSITEMID itemidParent;
		HRESULT retValue;
	};

	STDMETHOD(OnItemsAppended)(
		/*[in]*/ VSITEMID itemidParent)
	{
		VSL_DEFINE_MOCK_METHOD(OnItemsAppended)

		VSL_CHECK_VALIDVALUE(itemidParent);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnItemDeletedValidValues
	{
		/*[in]*/ VSITEMID itemid;
		HRESULT retValue;
	};

	STDMETHOD(OnItemDeleted)(
		/*[in]*/ VSITEMID itemid)
	{
		VSL_DEFINE_MOCK_METHOD(OnItemDeleted)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnPropertyChangedValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ VSHPROPID propid;
		/*[in]*/ DWORD flags;
		HRESULT retValue;
	};

	STDMETHOD(OnPropertyChanged)(
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ VSHPROPID propid,
		/*[in]*/ DWORD flags)
	{
		VSL_DEFINE_MOCK_METHOD(OnPropertyChanged)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE(propid);

		VSL_CHECK_VALIDVALUE(flags);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnInvalidateItemsValidValues
	{
		/*[in]*/ VSITEMID itemidParent;
		HRESULT retValue;
	};

	STDMETHOD(OnInvalidateItems)(
		/*[in]*/ VSITEMID itemidParent)
	{
		VSL_DEFINE_MOCK_METHOD(OnInvalidateItems)

		VSL_CHECK_VALIDVALUE(itemidParent);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnInvalidateIconValidValues
	{
		/*[in]*/ HICON hicon;
		HRESULT retValue;
	};

	STDMETHOD(OnInvalidateIcon)(
		/*[in]*/ HICON hicon)
	{
		VSL_DEFINE_MOCK_METHOD(OnInvalidateIcon)

		VSL_CHECK_VALIDVALUE(hicon);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSHIERARCHYEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsHighlight.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSHIGHLIGHT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSHIGHLIGHT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textfind.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsHighlightNotImpl :
	public IVsHighlight
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHighlightNotImpl)

public:

	typedef IVsHighlight Interface;

	STDMETHOD(GetHighlightRect)(
		/*[out]*/ RECT* /*prc*/)VSL_STDMETHOD_NOTIMPL
};

class IVsHighlightMockImpl :
	public IVsHighlight,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHighlightMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsHighlightMockImpl)

	typedef IVsHighlight Interface;
	struct GetHighlightRectValidValues
	{
		/*[out]*/ RECT* prc;
		HRESULT retValue;
	};

	STDMETHOD(GetHighlightRect)(
		/*[out]*/ RECT* prc)
	{
		VSL_DEFINE_MOCK_METHOD(GetHighlightRect)

		VSL_SET_VALIDVALUE(prc);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSHIGHLIGHT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsHTMLConverter.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSHTMLCONVERTER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSHTMLCONVERTER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsHTMLConverterNotImpl :
	public IVsHTMLConverter
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHTMLConverterNotImpl)

public:

	typedef IVsHTMLConverter Interface;

	STDMETHOD(get_DefaultURLEncodingCodePage)(
		/*[out]*/ UINT* /*pulCodePage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ConvertToEntities)(
		/*[in]*/ LPCOLESTR /*szToConvert*/,
		/*[in]*/ ULONG /*cchBuffSize*/,
		/*[in,out,size_is(cchBuffSize)]*/ OLECHAR[] /*szBuffer*/,
		/*[out]*/ ULONG* /*pcchBuffSizeActual*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ConvertFromEntities)(
		/*[in]*/ LPCOLESTR /*szToConvert*/,
		/*[in]*/ ULONG /*cchBuffSize*/,
		/*[in,out,size_is(cchBuffSize)]*/ OLECHAR[] /*szBuffer*/,
		/*[out]*/ ULONG* /*pcchBuffSizeActual*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ConvertToURLEncoding)(
		/*[in]*/ UINT /*uCodePage*/,
		/*[in]*/ LPCOLESTR /*szToConvert*/,
		/*[in]*/ ULONG /*cchBuffSize*/,
		/*[in,out,size_is(cchBuffSize)]*/ OLECHAR[] /*szBuffer*/,
		/*[out]*/ ULONG* /*pcchBuffSizeActual*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ConvertFromURLEncoding)(
		/*[in]*/ UINT /*uCodePage*/,
		/*[in]*/ LPCOLESTR /*szToConvert*/,
		/*[in]*/ ULONG /*cchBuffSize*/,
		/*[in,out,size_is(cchBuffSize)]*/ OLECHAR[] /*szBuffer*/,
		/*[out]*/ ULONG* /*pcchBuffSizeActual*/)VSL_STDMETHOD_NOTIMPL
};

class IVsHTMLConverterMockImpl :
	public IVsHTMLConverter,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHTMLConverterMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsHTMLConverterMockImpl)

	typedef IVsHTMLConverter Interface;
	struct get_DefaultURLEncodingCodePageValidValues
	{
		/*[out]*/ UINT* pulCodePage;
		HRESULT retValue;
	};

	STDMETHOD(get_DefaultURLEncodingCodePage)(
		/*[out]*/ UINT* pulCodePage)
	{
		VSL_DEFINE_MOCK_METHOD(get_DefaultURLEncodingCodePage)

		VSL_SET_VALIDVALUE(pulCodePage);

		VSL_RETURN_VALIDVALUES();
	}
	struct ConvertToEntitiesValidValues
	{
		/*[in]*/ LPCOLESTR szToConvert;
		/*[in]*/ ULONG cchBuffSize;
		/*[in,out,size_is(cchBuffSize)]*/ OLECHAR* szBuffer;
		/*[out]*/ ULONG* pcchBuffSizeActual;
		HRESULT retValue;
	};

	STDMETHOD(ConvertToEntities)(
		/*[in]*/ LPCOLESTR szToConvert,
		/*[in]*/ ULONG cchBuffSize,
		/*[in,out,size_is(cchBuffSize)]*/ OLECHAR szBuffer[],
		/*[out]*/ ULONG* pcchBuffSizeActual)
	{
		VSL_DEFINE_MOCK_METHOD(ConvertToEntities)

		VSL_CHECK_VALIDVALUE_STRINGW(szToConvert);

		VSL_CHECK_VALIDVALUE(cchBuffSize);

		VSL_SET_VALIDVALUE_STRINGW(szBuffer, cchBuffSize);

		VSL_SET_VALIDVALUE(pcchBuffSizeActual);

		VSL_RETURN_VALIDVALUES();
	}
	struct ConvertFromEntitiesValidValues
	{
		/*[in]*/ LPCOLESTR szToConvert;
		/*[in]*/ ULONG cchBuffSize;
		/*[in,out,size_is(cchBuffSize)]*/ OLECHAR* szBuffer;
		/*[out]*/ ULONG* pcchBuffSizeActual;
		HRESULT retValue;
	};

	STDMETHOD(ConvertFromEntities)(
		/*[in]*/ LPCOLESTR szToConvert,
		/*[in]*/ ULONG cchBuffSize,
		/*[in,out,size_is(cchBuffSize)]*/ OLECHAR szBuffer[],
		/*[out]*/ ULONG* pcchBuffSizeActual)
	{
		VSL_DEFINE_MOCK_METHOD(ConvertFromEntities)

		VSL_CHECK_VALIDVALUE_STRINGW(szToConvert);

		VSL_CHECK_VALIDVALUE(cchBuffSize);

		VSL_SET_VALIDVALUE_STRINGW(szBuffer, cchBuffSize);

		VSL_SET_VALIDVALUE(pcchBuffSizeActual);

		VSL_RETURN_VALIDVALUES();
	}
	struct ConvertToURLEncodingValidValues
	{
		/*[in]*/ UINT uCodePage;
		/*[in]*/ LPCOLESTR szToConvert;
		/*[in]*/ ULONG cchBuffSize;
		/*[in,out,size_is(cchBuffSize)]*/ OLECHAR* szBuffer;
		/*[out]*/ ULONG* pcchBuffSizeActual;
		HRESULT retValue;
	};

	STDMETHOD(ConvertToURLEncoding)(
		/*[in]*/ UINT uCodePage,
		/*[in]*/ LPCOLESTR szToConvert,
		/*[in]*/ ULONG cchBuffSize,
		/*[in,out,size_is(cchBuffSize)]*/ OLECHAR szBuffer[],
		/*[out]*/ ULONG* pcchBuffSizeActual)
	{
		VSL_DEFINE_MOCK_METHOD(ConvertToURLEncoding)

		VSL_CHECK_VALIDVALUE(uCodePage);

		VSL_CHECK_VALIDVALUE_STRINGW(szToConvert);

		VSL_CHECK_VALIDVALUE(cchBuffSize);

		VSL_SET_VALIDVALUE_STRINGW(szBuffer, cchBuffSize);

		VSL_SET_VALIDVALUE(pcchBuffSizeActual);

		VSL_RETURN_VALIDVALUES();
	}
	struct ConvertFromURLEncodingValidValues
	{
		/*[in]*/ UINT uCodePage;
		/*[in]*/ LPCOLESTR szToConvert;
		/*[in]*/ ULONG cchBuffSize;
		/*[in,out,size_is(cchBuffSize)]*/ OLECHAR* szBuffer;
		/*[out]*/ ULONG* pcchBuffSizeActual;
		HRESULT retValue;
	};

	STDMETHOD(ConvertFromURLEncoding)(
		/*[in]*/ UINT uCodePage,
		/*[in]*/ LPCOLESTR szToConvert,
		/*[in]*/ ULONG cchBuffSize,
		/*[in,out,size_is(cchBuffSize)]*/ OLECHAR szBuffer[],
		/*[out]*/ ULONG* pcchBuffSizeActual)
	{
		VSL_DEFINE_MOCK_METHOD(ConvertFromURLEncoding)

		VSL_CHECK_VALIDVALUE(uCodePage);

		VSL_CHECK_VALIDVALUE_STRINGW(szToConvert);

		VSL_CHECK_VALIDVALUE(cchBuffSize);

		VSL_SET_VALIDVALUE_STRINGW(szBuffer, cchBuffSize);

		VSL_SET_VALIDVALUE(pcchBuffSizeActual);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSHTMLCONVERTER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsImageButton.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSIMAGEBUTTON_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSIMAGEBUTTON_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsImageButtonNotImpl :
	public IVsImageButton
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsImageButtonNotImpl)

public:

	typedef IVsImageButton Interface;

	STDMETHOD(Draw)(
		/*[in]*/ VSDRAWITEMSTRUCT* /*pDrawItemStruct*/,
		/*[in]*/ BOOL /*fHot*/)VSL_STDMETHOD_NOTIMPL
};

class IVsImageButtonMockImpl :
	public IVsImageButton,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsImageButtonMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsImageButtonMockImpl)

	typedef IVsImageButton Interface;
	struct DrawValidValues
	{
		/*[in]*/ VSDRAWITEMSTRUCT* pDrawItemStruct;
		/*[in]*/ BOOL fHot;
		HRESULT retValue;
	};

	STDMETHOD(Draw)(
		/*[in]*/ VSDRAWITEMSTRUCT* pDrawItemStruct,
		/*[in]*/ BOOL fHot)
	{
		VSL_DEFINE_MOCK_METHOD(Draw)

		VSL_CHECK_VALIDVALUE_POINTER(pDrawItemStruct);

		VSL_CHECK_VALIDVALUE(fHot);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSIMAGEBUTTON_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsHierarchyRefactorNotify.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSHIERARCHYREFACTORNOTIFY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSHIERARCHYREFACTORNOTIFY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsHierarchyRefactorNotifyNotImpl :
	public IVsHierarchyRefactorNotify
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHierarchyRefactorNotifyNotImpl)

public:

	typedef IVsHierarchyRefactorNotify Interface;

	STDMETHOD(OnBeforeGlobalSymbolRenamed)(
		/*[in]*/ ULONG /*cItemsAffected*/,
		/*[in,size_is(cItemsAffected)]*/ VSITEMID[] /*rgItemsAffected*/,
		/*[in]*/ ULONG /*cRQNames*/,
		/*[in,size_is(cRQNames)]*/ LPCOLESTR[] /*rglpszRQName*/,
		/*[in]*/ LPCOLESTR /*lpszNewName*/,
		/*[in]*/ BOOL /*promptContinueOnFail*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnGlobalSymbolRenamed)(
		/*[in]*/ ULONG /*cItemsAffected*/,
		/*[in,size_is(cItemsAffected)]*/ VSITEMID[] /*rgItemsAffected*/,
		/*[in]*/ ULONG /*cRQNames*/,
		/*[in,size_is(cRQNames)]*/ LPCOLESTR[] /*rglpszRQName*/,
		/*[in]*/ LPCOLESTR /*lpszNewName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnBeforeReorderParams)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ LPCOLESTR /*lpszRQName*/,
		/*[in]*/ ULONG /*cParamIndexes*/,
		/*[in,size_is(cParamIndexes)]*/ ULONG[] /*rgParamIndexes*/,
		/*[in]*/ BOOL /*promptContinueOnFail*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnReorderParams)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ LPCOLESTR /*lpszRQName*/,
		/*[in]*/ ULONG /*cParamIndexes*/,
		/*[in,size_is(cParamIndexes)]*/ ULONG[] /*rgParamIndexes*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnBeforeRemoveParams)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ LPCOLESTR /*lpszRQName*/,
		/*[in]*/ ULONG /*cParamIndexes*/,
		/*[in,size_is(cParamIndexes)]*/ ULONG[] /*rgParamIndexes*/,
		/*[in]*/ BOOL /*promptContinueOnFail*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnRemoveParams)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ LPCOLESTR /*lpszRQName*/,
		/*[in]*/ ULONG /*cParamIndexes*/,
		/*[in,size_is(cParamIndexes)]*/ ULONG[] /*rgParamIndexes*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnBeforeAddParams)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ LPCOLESTR /*lpszRQName*/,
		/*[in]*/ ULONG /*cParams*/,
		/*[in,size_is(cParams)]*/ ULONG[] /*rgszParamIndexes*/,
		/*[in,size_is(cParams)]*/ LPCOLESTR[] /*rgszRQTypeNames*/,
		/*[in,size_is(cParams)]*/ LPCOLESTR[] /*rgszParamNames*/,
		/*[in]*/ BOOL /*promptContinueOnFail*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAddParams)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ LPCOLESTR /*lpszRQName*/,
		/*[in]*/ ULONG /*cParams*/,
		/*[in,size_is(cParams)]*/ ULONG[] /*rgszParamIndexes*/,
		/*[in,size_is(cParams)]*/ LPCOLESTR[] /*rgszRQTypeNames*/,
		/*[in,size_is(cParams)]*/ LPCOLESTR[] /*rgszParamNames*/)VSL_STDMETHOD_NOTIMPL
};

class IVsHierarchyRefactorNotifyMockImpl :
	public IVsHierarchyRefactorNotify,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsHierarchyRefactorNotifyMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsHierarchyRefactorNotifyMockImpl)

	typedef IVsHierarchyRefactorNotify Interface;
	struct OnBeforeGlobalSymbolRenamedValidValues
	{
		/*[in]*/ ULONG cItemsAffected;
		/*[in,size_is(cItemsAffected)]*/ VSITEMID* rgItemsAffected;
		/*[in]*/ ULONG cRQNames;
		/*[in,size_is(cRQNames)]*/ LPCOLESTR* rglpszRQName;
		/*[in]*/ LPCOLESTR lpszNewName;
		/*[in]*/ BOOL promptContinueOnFail;
		HRESULT retValue;
	};

	STDMETHOD(OnBeforeGlobalSymbolRenamed)(
		/*[in]*/ ULONG cItemsAffected,
		/*[in,size_is(cItemsAffected)]*/ VSITEMID rgItemsAffected[],
		/*[in]*/ ULONG cRQNames,
		/*[in,size_is(cRQNames)]*/ LPCOLESTR rglpszRQName[],
		/*[in]*/ LPCOLESTR lpszNewName,
		/*[in]*/ BOOL promptContinueOnFail)
	{
		VSL_DEFINE_MOCK_METHOD(OnBeforeGlobalSymbolRenamed)

		VSL_CHECK_VALIDVALUE(cItemsAffected);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgItemsAffected, cItemsAffected*sizeof(rgItemsAffected[0]), validValues.cItemsAffected*sizeof(validValues.rgItemsAffected[0]));

		VSL_CHECK_VALIDVALUE(cRQNames);

		VSL_CHECK_VALIDVALUE_MEMCMP(rglpszRQName, cRQNames*sizeof(rglpszRQName[0]), validValues.cRQNames*sizeof(validValues.rglpszRQName[0]));

		VSL_CHECK_VALIDVALUE_STRINGW(lpszNewName);

		VSL_CHECK_VALIDVALUE(promptContinueOnFail);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnGlobalSymbolRenamedValidValues
	{
		/*[in]*/ ULONG cItemsAffected;
		/*[in,size_is(cItemsAffected)]*/ VSITEMID* rgItemsAffected;
		/*[in]*/ ULONG cRQNames;
		/*[in,size_is(cRQNames)]*/ LPCOLESTR* rglpszRQName;
		/*[in]*/ LPCOLESTR lpszNewName;
		HRESULT retValue;
	};

	STDMETHOD(OnGlobalSymbolRenamed)(
		/*[in]*/ ULONG cItemsAffected,
		/*[in,size_is(cItemsAffected)]*/ VSITEMID rgItemsAffected[],
		/*[in]*/ ULONG cRQNames,
		/*[in,size_is(cRQNames)]*/ LPCOLESTR rglpszRQName[],
		/*[in]*/ LPCOLESTR lpszNewName)
	{
		VSL_DEFINE_MOCK_METHOD(OnGlobalSymbolRenamed)

		VSL_CHECK_VALIDVALUE(cItemsAffected);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgItemsAffected, cItemsAffected*sizeof(rgItemsAffected[0]), validValues.cItemsAffected*sizeof(validValues.rgItemsAffected[0]));

		VSL_CHECK_VALIDVALUE(cRQNames);

		VSL_CHECK_VALIDVALUE_MEMCMP(rglpszRQName, cRQNames*sizeof(rglpszRQName[0]), validValues.cRQNames*sizeof(validValues.rglpszRQName[0]));

		VSL_CHECK_VALIDVALUE_STRINGW(lpszNewName);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnBeforeReorderParamsValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ LPCOLESTR lpszRQName;
		/*[in]*/ ULONG cParamIndexes;
		/*[in,size_is(cParamIndexes)]*/ ULONG* rgParamIndexes;
		/*[in]*/ BOOL promptContinueOnFail;
		HRESULT retValue;
	};

	STDMETHOD(OnBeforeReorderParams)(
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ LPCOLESTR lpszRQName,
		/*[in]*/ ULONG cParamIndexes,
		/*[in,size_is(cParamIndexes)]*/ ULONG rgParamIndexes[],
		/*[in]*/ BOOL promptContinueOnFail)
	{
		VSL_DEFINE_MOCK_METHOD(OnBeforeReorderParams)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszRQName);

		VSL_CHECK_VALIDVALUE(cParamIndexes);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgParamIndexes, cParamIndexes*sizeof(rgParamIndexes[0]), validValues.cParamIndexes*sizeof(validValues.rgParamIndexes[0]));

		VSL_CHECK_VALIDVALUE(promptContinueOnFail);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnReorderParamsValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ LPCOLESTR lpszRQName;
		/*[in]*/ ULONG cParamIndexes;
		/*[in,size_is(cParamIndexes)]*/ ULONG* rgParamIndexes;
		HRESULT retValue;
	};

	STDMETHOD(OnReorderParams)(
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ LPCOLESTR lpszRQName,
		/*[in]*/ ULONG cParamIndexes,
		/*[in,size_is(cParamIndexes)]*/ ULONG rgParamIndexes[])
	{
		VSL_DEFINE_MOCK_METHOD(OnReorderParams)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszRQName);

		VSL_CHECK_VALIDVALUE(cParamIndexes);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgParamIndexes, cParamIndexes*sizeof(rgParamIndexes[0]), validValues.cParamIndexes*sizeof(validValues.rgParamIndexes[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct OnBeforeRemoveParamsValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ LPCOLESTR lpszRQName;
		/*[in]*/ ULONG cParamIndexes;
		/*[in,size_is(cParamIndexes)]*/ ULONG* rgParamIndexes;
		/*[in]*/ BOOL promptContinueOnFail;
		HRESULT retValue;
	};

	STDMETHOD(OnBeforeRemoveParams)(
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ LPCOLESTR lpszRQName,
		/*[in]*/ ULONG cParamIndexes,
		/*[in,size_is(cParamIndexes)]*/ ULONG rgParamIndexes[],
		/*[in]*/ BOOL promptContinueOnFail)
	{
		VSL_DEFINE_MOCK_METHOD(OnBeforeRemoveParams)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszRQName);

		VSL_CHECK_VALIDVALUE(cParamIndexes);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgParamIndexes, cParamIndexes*sizeof(rgParamIndexes[0]), validValues.cParamIndexes*sizeof(validValues.rgParamIndexes[0]));

		VSL_CHECK_VALIDVALUE(promptContinueOnFail);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnRemoveParamsValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ LPCOLESTR lpszRQName;
		/*[in]*/ ULONG cParamIndexes;
		/*[in,size_is(cParamIndexes)]*/ ULONG* rgParamIndexes;
		HRESULT retValue;
	};

	STDMETHOD(OnRemoveParams)(
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ LPCOLESTR lpszRQName,
		/*[in]*/ ULONG cParamIndexes,
		/*[in,size_is(cParamIndexes)]*/ ULONG rgParamIndexes[])
	{
		VSL_DEFINE_MOCK_METHOD(OnRemoveParams)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszRQName);

		VSL_CHECK_VALIDVALUE(cParamIndexes);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgParamIndexes, cParamIndexes*sizeof(rgParamIndexes[0]), validValues.cParamIndexes*sizeof(validValues.rgParamIndexes[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct OnBeforeAddParamsValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ LPCOLESTR lpszRQName;
		/*[in]*/ ULONG cParams;
		/*[in,size_is(cParams)]*/ ULONG* rgszParamIndexes;
		/*[in,size_is(cParams)]*/ LPCOLESTR* rgszRQTypeNames;
		/*[in,size_is(cParams)]*/ LPCOLESTR* rgszParamNames;
		/*[in]*/ BOOL promptContinueOnFail;
		HRESULT retValue;
	};

	STDMETHOD(OnBeforeAddParams)(
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ LPCOLESTR lpszRQName,
		/*[in]*/ ULONG cParams,
		/*[in,size_is(cParams)]*/ ULONG rgszParamIndexes[],
		/*[in,size_is(cParams)]*/ LPCOLESTR rgszRQTypeNames[],
		/*[in,size_is(cParams)]*/ LPCOLESTR rgszParamNames[],
		/*[in]*/ BOOL promptContinueOnFail)
	{
		VSL_DEFINE_MOCK_METHOD(OnBeforeAddParams)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszRQName);

		VSL_CHECK_VALIDVALUE(cParams);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszParamIndexes, cParams*sizeof(rgszParamIndexes[0]), validValues.cParams*sizeof(validValues.rgszParamIndexes[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszRQTypeNames, cParams*sizeof(rgszRQTypeNames[0]), validValues.cParams*sizeof(validValues.rgszRQTypeNames[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszParamNames, cParams*sizeof(rgszParamNames[0]), validValues.cParams*sizeof(validValues.rgszParamNames[0]));

		VSL_CHECK_VALIDVALUE(promptContinueOnFail);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAddParamsValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ LPCOLESTR lpszRQName;
		/*[in]*/ ULONG cParams;
		/*[in,size_is(cParams)]*/ ULONG* rgszParamIndexes;
		/*[in,size_is(cParams)]*/ LPCOLESTR* rgszRQTypeNames;
		/*[in,size_is(cParams)]*/ LPCOLESTR* rgszParamNames;
		HRESULT retValue;
	};

	STDMETHOD(OnAddParams)(
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ LPCOLESTR lpszRQName,
		/*[in]*/ ULONG cParams,
		/*[in,size_is(cParams)]*/ ULONG rgszParamIndexes[],
		/*[in,size_is(cParams)]*/ LPCOLESTR rgszRQTypeNames[],
		/*[in,size_is(cParams)]*/ LPCOLESTR rgszParamNames[])
	{
		VSL_DEFINE_MOCK_METHOD(OnAddParams)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszRQName);

		VSL_CHECK_VALIDVALUE(cParams);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszParamIndexes, cParams*sizeof(rgszParamIndexes[0]), validValues.cParams*sizeof(validValues.rgszParamIndexes[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszRQTypeNames, cParams*sizeof(rgszRQTypeNames[0]), validValues.cParams*sizeof(validValues.rgszRQTypeNames[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszParamNames, cParams*sizeof(rgszParamNames[0]), validValues.cParams*sizeof(validValues.rgszParamNames[0]));

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSHIERARCHYREFACTORNOTIFY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsIME.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSIME_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSIME_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsIMENotImpl :
	public IVsIME
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsIMENotImpl)

public:

	typedef IVsIME Interface;

	STDMETHOD(IsActive)(
		/*[in]*/ HWND /*hwnd*/,
		/*[out]*/ BOOL* /*pfRetVal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Activate)(
		/*[in]*/ HWND /*hwnd*/,
		/*[out]*/ VSIME_ERR* /*perr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Deactivate)(
		/*[in]*/ HWND /*hwnd*/,
		/*[out]*/ VSIME_ERR* /*perr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FDeactivate)(
		/*[in]*/ HWND /*hwnd*/,
		/*[in]*/ BOOL /*fDisable*/,
		/*[out]*/ VSIME_ERR* /*perr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetFont)(
		/*[in]*/ HWND /*hwnd*/,
		/*[in]*/ HFONT /*hf*/,
		/*[out]*/ VSIME_ERR* /*perr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetCurPos)(
		/*[in]*/ HWND /*hwnd*/,
		/*[in]*/ int /*x*/,
		/*[in]*/ int /*y*/,
		/*[out]*/ VSIME_ERR* /*perr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetDefCurPos)(
		/*[in]*/ HWND /*hwnd*/,
		/*[out]*/ VSIME_ERR* /*perr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AttachContext)(
		/*[in]*/ HWND /*hwnd*/,
		/*[in]*/ BOOL /*fAttach*/,
		/*[out]*/ VSIME_ERR* /*perr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetImmContext)(
		/*[in]*/ HWND /*hwnd*/,
		/*[out]*/ HIMC* /*phimc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReleaseImmContext)(
		/*[in]*/ HWND /*hwnd*/,
		/*[in]*/ HIMC /*himc*/,
		/*[out]*/ BOOL* /*pfRetVal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetImmCompositionString)(
		/*[in]*/ HIMC /*himc*/,
		/*[in]*/ DWORD /*dwIndex*/,
		/*[out]*/ BSTR* /*pbstrCompString*/,
		/*[out]*/ LONG* /*plRetVal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetImmCompositionString)(
		/*[in]*/ HIMC /*himc*/,
		/*[in]*/ DWORD /*dwIndex*/,
		/*[in]*/ BSTR /*bstrCompString*/,
		/*[in]*/ BSTR /*bstrReadString*/,
		/*[out]*/ BOOL* /*pfRetVal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetImmCandidateWindow)(
		/*[in]*/ HIMC /*himc*/,
		/*[in]*/ CANDIDATEFORM* /*lpcf*/,
		/*[out]*/ BOOL* /*pfRetVal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Notify)(
		/*[in]*/ HIMC /*himc*/,
		/*[in]*/ DWORD /*dwAction*/,
		/*[in]*/ DWORD /*dwIndex*/,
		/*[in]*/ DWORD /*dwValue*/,
		/*[out]*/ BOOL* /*pfRetVal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Escape)(
		/*[in]*/ HKL /*hkl*/,
		/*[in]*/ HIMC /*himc*/,
		/*[in]*/ UINT /*uEsc*/,
		/*[in,out]*/ BSTR /*bstrData*/,
		/*[out]*/ LONG* /*plRetVal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDefaultWindow)(
		/*[in]*/ HWND /*hwnd*/,
		/*[out]*/ HWND* /*phRetVal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetImmCompositionStringW)(
		/*[in]*/ HIMC /*himc*/,
		/*[in]*/ DWORD /*dwIndex*/,
		/*[out]*/ BSTR* /*pbstrCompString*/,
		/*[out]*/ LONG* /*plRetVal*/)VSL_STDMETHOD_NOTIMPL
};

class IVsIMEMockImpl :
	public IVsIME,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsIMEMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsIMEMockImpl)

	typedef IVsIME Interface;
	struct IsActiveValidValues
	{
		/*[in]*/ HWND hwnd;
		/*[out]*/ BOOL* pfRetVal;
		HRESULT retValue;
	};

	STDMETHOD(IsActive)(
		/*[in]*/ HWND hwnd,
		/*[out]*/ BOOL* pfRetVal)
	{
		VSL_DEFINE_MOCK_METHOD(IsActive)

		VSL_CHECK_VALIDVALUE(hwnd);

		VSL_SET_VALIDVALUE(pfRetVal);

		VSL_RETURN_VALIDVALUES();
	}
	struct ActivateValidValues
	{
		/*[in]*/ HWND hwnd;
		/*[out]*/ VSIME_ERR* perr;
		HRESULT retValue;
	};

	STDMETHOD(Activate)(
		/*[in]*/ HWND hwnd,
		/*[out]*/ VSIME_ERR* perr)
	{
		VSL_DEFINE_MOCK_METHOD(Activate)

		VSL_CHECK_VALIDVALUE(hwnd);

		VSL_SET_VALIDVALUE(perr);

		VSL_RETURN_VALIDVALUES();
	}
	struct DeactivateValidValues
	{
		/*[in]*/ HWND hwnd;
		/*[out]*/ VSIME_ERR* perr;
		HRESULT retValue;
	};

	STDMETHOD(Deactivate)(
		/*[in]*/ HWND hwnd,
		/*[out]*/ VSIME_ERR* perr)
	{
		VSL_DEFINE_MOCK_METHOD(Deactivate)

		VSL_CHECK_VALIDVALUE(hwnd);

		VSL_SET_VALIDVALUE(perr);

		VSL_RETURN_VALIDVALUES();
	}
	struct FDeactivateValidValues
	{
		/*[in]*/ HWND hwnd;
		/*[in]*/ BOOL fDisable;
		/*[out]*/ VSIME_ERR* perr;
		HRESULT retValue;
	};

	STDMETHOD(FDeactivate)(
		/*[in]*/ HWND hwnd,
		/*[in]*/ BOOL fDisable,
		/*[out]*/ VSIME_ERR* perr)
	{
		VSL_DEFINE_MOCK_METHOD(FDeactivate)

		VSL_CHECK_VALIDVALUE(hwnd);

		VSL_CHECK_VALIDVALUE(fDisable);

		VSL_SET_VALIDVALUE(perr);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetFontValidValues
	{
		/*[in]*/ HWND hwnd;
		/*[in]*/ HFONT hf;
		/*[out]*/ VSIME_ERR* perr;
		HRESULT retValue;
	};

	STDMETHOD(SetFont)(
		/*[in]*/ HWND hwnd,
		/*[in]*/ HFONT hf,
		/*[out]*/ VSIME_ERR* perr)
	{
		VSL_DEFINE_MOCK_METHOD(SetFont)

		VSL_CHECK_VALIDVALUE(hwnd);

		VSL_CHECK_VALIDVALUE(hf);

		VSL_SET_VALIDVALUE(perr);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetCurPosValidValues
	{
		/*[in]*/ HWND hwnd;
		/*[in]*/ int x;
		/*[in]*/ int y;
		/*[out]*/ VSIME_ERR* perr;
		HRESULT retValue;
	};

	STDMETHOD(SetCurPos)(
		/*[in]*/ HWND hwnd,
		/*[in]*/ int x,
		/*[in]*/ int y,
		/*[out]*/ VSIME_ERR* perr)
	{
		VSL_DEFINE_MOCK_METHOD(SetCurPos)

		VSL_CHECK_VALIDVALUE(hwnd);

		VSL_CHECK_VALIDVALUE(x);

		VSL_CHECK_VALIDVALUE(y);

		VSL_SET_VALIDVALUE(perr);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetDefCurPosValidValues
	{
		/*[in]*/ HWND hwnd;
		/*[out]*/ VSIME_ERR* perr;
		HRESULT retValue;
	};

	STDMETHOD(SetDefCurPos)(
		/*[in]*/ HWND hwnd,
		/*[out]*/ VSIME_ERR* perr)
	{
		VSL_DEFINE_MOCK_METHOD(SetDefCurPos)

		VSL_CHECK_VALIDVALUE(hwnd);

		VSL_SET_VALIDVALUE(perr);

		VSL_RETURN_VALIDVALUES();
	}
	struct AttachContextValidValues
	{
		/*[in]*/ HWND hwnd;
		/*[in]*/ BOOL fAttach;
		/*[out]*/ VSIME_ERR* perr;
		HRESULT retValue;
	};

	STDMETHOD(AttachContext)(
		/*[in]*/ HWND hwnd,
		/*[in]*/ BOOL fAttach,
		/*[out]*/ VSIME_ERR* perr)
	{
		VSL_DEFINE_MOCK_METHOD(AttachContext)

		VSL_CHECK_VALIDVALUE(hwnd);

		VSL_CHECK_VALIDVALUE(fAttach);

		VSL_SET_VALIDVALUE(perr);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetImmContextValidValues
	{
		/*[in]*/ HWND hwnd;
		/*[out]*/ HIMC* phimc;
		HRESULT retValue;
	};

	STDMETHOD(GetImmContext)(
		/*[in]*/ HWND hwnd,
		/*[out]*/ HIMC* phimc)
	{
		VSL_DEFINE_MOCK_METHOD(GetImmContext)

		VSL_CHECK_VALIDVALUE(hwnd);

		VSL_SET_VALIDVALUE(phimc);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReleaseImmContextValidValues
	{
		/*[in]*/ HWND hwnd;
		/*[in]*/ HIMC himc;
		/*[out]*/ BOOL* pfRetVal;
		HRESULT retValue;
	};

	STDMETHOD(ReleaseImmContext)(
		/*[in]*/ HWND hwnd,
		/*[in]*/ HIMC himc,
		/*[out]*/ BOOL* pfRetVal)
	{
		VSL_DEFINE_MOCK_METHOD(ReleaseImmContext)

		VSL_CHECK_VALIDVALUE(hwnd);

		VSL_CHECK_VALIDVALUE(himc);

		VSL_SET_VALIDVALUE(pfRetVal);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetImmCompositionStringValidValues
	{
		/*[in]*/ HIMC himc;
		/*[in]*/ DWORD dwIndex;
		/*[out]*/ BSTR* pbstrCompString;
		/*[out]*/ LONG* plRetVal;
		HRESULT retValue;
	};

	STDMETHOD(GetImmCompositionString)(
		/*[in]*/ HIMC himc,
		/*[in]*/ DWORD dwIndex,
		/*[out]*/ BSTR* pbstrCompString,
		/*[out]*/ LONG* plRetVal)
	{
		VSL_DEFINE_MOCK_METHOD(GetImmCompositionString)

		VSL_CHECK_VALIDVALUE(himc);

		VSL_CHECK_VALIDVALUE(dwIndex);

		VSL_SET_VALIDVALUE_BSTR(pbstrCompString);

		VSL_SET_VALIDVALUE(plRetVal);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetImmCompositionStringValidValues
	{
		/*[in]*/ HIMC himc;
		/*[in]*/ DWORD dwIndex;
		/*[in]*/ BSTR bstrCompString;
		/*[in]*/ BSTR bstrReadString;
		/*[out]*/ BOOL* pfRetVal;
		HRESULT retValue;
	};

	STDMETHOD(SetImmCompositionString)(
		/*[in]*/ HIMC himc,
		/*[in]*/ DWORD dwIndex,
		/*[in]*/ BSTR bstrCompString,
		/*[in]*/ BSTR bstrReadString,
		/*[out]*/ BOOL* pfRetVal)
	{
		VSL_DEFINE_MOCK_METHOD(SetImmCompositionString)

		VSL_CHECK_VALIDVALUE(himc);

		VSL_CHECK_VALIDVALUE(dwIndex);

		VSL_CHECK_VALIDVALUE_BSTR(bstrCompString);

		VSL_CHECK_VALIDVALUE_BSTR(bstrReadString);

		VSL_SET_VALIDVALUE(pfRetVal);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetImmCandidateWindowValidValues
	{
		/*[in]*/ HIMC himc;
		/*[in]*/ CANDIDATEFORM* lpcf;
		/*[out]*/ BOOL* pfRetVal;
		HRESULT retValue;
	};

	STDMETHOD(SetImmCandidateWindow)(
		/*[in]*/ HIMC himc,
		/*[in]*/ CANDIDATEFORM* lpcf,
		/*[out]*/ BOOL* pfRetVal)
	{
		VSL_DEFINE_MOCK_METHOD(SetImmCandidateWindow)

		VSL_CHECK_VALIDVALUE(himc);

		VSL_CHECK_VALIDVALUE_POINTER(lpcf);

		VSL_SET_VALIDVALUE(pfRetVal);

		VSL_RETURN_VALIDVALUES();
	}
	struct NotifyValidValues
	{
		/*[in]*/ HIMC himc;
		/*[in]*/ DWORD dwAction;
		/*[in]*/ DWORD dwIndex;
		/*[in]*/ DWORD dwValue;
		/*[out]*/ BOOL* pfRetVal;
		HRESULT retValue;
	};

	STDMETHOD(Notify)(
		/*[in]*/ HIMC himc,
		/*[in]*/ DWORD dwAction,
		/*[in]*/ DWORD dwIndex,
		/*[in]*/ DWORD dwValue,
		/*[out]*/ BOOL* pfRetVal)
	{
		VSL_DEFINE_MOCK_METHOD(Notify)

		VSL_CHECK_VALIDVALUE(himc);

		VSL_CHECK_VALIDVALUE(dwAction);

		VSL_CHECK_VALIDVALUE(dwIndex);

		VSL_CHECK_VALIDVALUE(dwValue);

		VSL_SET_VALIDVALUE(pfRetVal);

		VSL_RETURN_VALIDVALUES();
	}
	struct EscapeValidValues
	{
		/*[in]*/ HKL hkl;
		/*[in]*/ HIMC himc;
		/*[in]*/ UINT uEsc;
		/*[in,out]*/ BSTR bstrData;
		/*[out]*/ LONG* plRetVal;
		HRESULT retValue;
	};

	STDMETHOD(Escape)(
		/*[in]*/ HKL hkl,
		/*[in]*/ HIMC himc,
		/*[in]*/ UINT uEsc,
		/*[in,out]*/ BSTR bstrData,
		/*[out]*/ LONG* plRetVal)
	{
		VSL_DEFINE_MOCK_METHOD(Escape)

		VSL_CHECK_VALIDVALUE(hkl);

		VSL_CHECK_VALIDVALUE(himc);

		VSL_CHECK_VALIDVALUE(uEsc);

		VSL_SET_VALIDVALUE(bstrData);

		VSL_SET_VALIDVALUE(plRetVal);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDefaultWindowValidValues
	{
		/*[in]*/ HWND hwnd;
		/*[out]*/ HWND* phRetVal;
		HRESULT retValue;
	};

	STDMETHOD(GetDefaultWindow)(
		/*[in]*/ HWND hwnd,
		/*[out]*/ HWND* phRetVal)
	{
		VSL_DEFINE_MOCK_METHOD(GetDefaultWindow)

		VSL_CHECK_VALIDVALUE(hwnd);

		VSL_SET_VALIDVALUE(phRetVal);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetImmCompositionStringWValidValues
	{
		/*[in]*/ HIMC himc;
		/*[in]*/ DWORD dwIndex;
		/*[out]*/ BSTR* pbstrCompString;
		/*[out]*/ LONG* plRetVal;
		HRESULT retValue;
	};

	STDMETHOD(GetImmCompositionStringW)(
		/*[in]*/ HIMC himc,
		/*[in]*/ DWORD dwIndex,
		/*[out]*/ BSTR* pbstrCompString,
		/*[out]*/ LONG* plRetVal)
	{
		VSL_DEFINE_MOCK_METHOD(GetImmCompositionStringW)

		VSL_CHECK_VALIDVALUE(himc);

		VSL_CHECK_VALIDVALUE(dwIndex);

		VSL_SET_VALIDVALUE_BSTR(pbstrCompString);

		VSL_SET_VALIDVALUE(plRetVal);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSIME_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsImmediateStatementCompletion2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSIMMEDIATESTATEMENTCOMPLETION2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSIMMEDIATESTATEMENTCOMPLETION2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "completion.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsImmediateStatementCompletion2NotImpl :
	public IVsImmediateStatementCompletion2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsImmediateStatementCompletion2NotImpl)

public:

	typedef IVsImmediateStatementCompletion2 Interface;

	STDMETHOD(EnableStatementCompletion)(
		/*[in]*/ BOOL /*fEnable*/,
		/*[in]*/ CharIndex /*iStartIndex*/,
		/*[in]*/ CharIndex /*iEndIndex*/,
		/*[in]*/ IVsTextView* /*pTextView*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetCompletionContext)(
		/*[in]*/ LPCOLESTR /*pszFilePath*/,
		/*[in]*/ IVsTextLines* /*pBuffer*/,
		/*[in]*/ const TextSpan* /*ptsCurStatement*/,
		/*[in]*/ IUnknown* /*punkContext*/,
		/*[in]*/ IVsTextView* /*pTextView*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFilter)(
		/*[in]*/ IVsTextView* /*pTextView*/,
		/*[out]*/ IVsTextViewFilter** /*ppFilter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(InstallStatementCompletion)(
		/*[in]*/ BOOL /*fInstall*/,
		/*[in]*/ IVsTextView* /*pCmdWinView*/,
		/*[in]*/ BOOL /*fInitialEnable*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnableStatementCompletion_Deprecated)(
		/*[in]*/ BOOL /*fEnable*/,
		/*[in]*/ CharIndex /*iStartIndex*/,
		/*[in]*/ CharIndex /*iEndIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetCompletionContext_Deprecated)(
		/*[in]*/ LPCOLESTR /*pszFilePath*/,
		/*[in]*/ IVsTextLines* /*pBuffer*/,
		/*[in]*/ const TextSpan* /*ptsCurStatement*/,
		/*[in]*/ IUnknown* /*punkContext*/)VSL_STDMETHOD_NOTIMPL
};

class IVsImmediateStatementCompletion2MockImpl :
	public IVsImmediateStatementCompletion2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsImmediateStatementCompletion2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsImmediateStatementCompletion2MockImpl)

	typedef IVsImmediateStatementCompletion2 Interface;
	struct EnableStatementCompletionValidValues
	{
		/*[in]*/ BOOL fEnable;
		/*[in]*/ CharIndex iStartIndex;
		/*[in]*/ CharIndex iEndIndex;
		/*[in]*/ IVsTextView* pTextView;
		HRESULT retValue;
	};

	STDMETHOD(EnableStatementCompletion)(
		/*[in]*/ BOOL fEnable,
		/*[in]*/ CharIndex iStartIndex,
		/*[in]*/ CharIndex iEndIndex,
		/*[in]*/ IVsTextView* pTextView)
	{
		VSL_DEFINE_MOCK_METHOD(EnableStatementCompletion)

		VSL_CHECK_VALIDVALUE(fEnable);

		VSL_CHECK_VALIDVALUE(iStartIndex);

		VSL_CHECK_VALIDVALUE(iEndIndex);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pTextView);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetCompletionContextValidValues
	{
		/*[in]*/ LPCOLESTR pszFilePath;
		/*[in]*/ IVsTextLines* pBuffer;
		/*[in]*/ TextSpan* ptsCurStatement;
		/*[in]*/ IUnknown* punkContext;
		/*[in]*/ IVsTextView* pTextView;
		HRESULT retValue;
	};

	STDMETHOD(SetCompletionContext)(
		/*[in]*/ LPCOLESTR pszFilePath,
		/*[in]*/ IVsTextLines* pBuffer,
		/*[in]*/ const TextSpan* ptsCurStatement,
		/*[in]*/ IUnknown* punkContext,
		/*[in]*/ IVsTextView* pTextView)
	{
		VSL_DEFINE_MOCK_METHOD(SetCompletionContext)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFilePath);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_CHECK_VALIDVALUE_POINTER(ptsCurStatement);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkContext);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pTextView);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFilterValidValues
	{
		/*[in]*/ IVsTextView* pTextView;
		/*[out]*/ IVsTextViewFilter** ppFilter;
		HRESULT retValue;
	};

	STDMETHOD(GetFilter)(
		/*[in]*/ IVsTextView* pTextView,
		/*[out]*/ IVsTextViewFilter** ppFilter)
	{
		VSL_DEFINE_MOCK_METHOD(GetFilter)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pTextView);

		VSL_SET_VALIDVALUE_INTERFACE(ppFilter);

		VSL_RETURN_VALIDVALUES();
	}
	struct InstallStatementCompletionValidValues
	{
		/*[in]*/ BOOL fInstall;
		/*[in]*/ IVsTextView* pCmdWinView;
		/*[in]*/ BOOL fInitialEnable;
		HRESULT retValue;
	};

	STDMETHOD(InstallStatementCompletion)(
		/*[in]*/ BOOL fInstall,
		/*[in]*/ IVsTextView* pCmdWinView,
		/*[in]*/ BOOL fInitialEnable)
	{
		VSL_DEFINE_MOCK_METHOD(InstallStatementCompletion)

		VSL_CHECK_VALIDVALUE(fInstall);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCmdWinView);

		VSL_CHECK_VALIDVALUE(fInitialEnable);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnableStatementCompletion_DeprecatedValidValues
	{
		/*[in]*/ BOOL fEnable;
		/*[in]*/ CharIndex iStartIndex;
		/*[in]*/ CharIndex iEndIndex;
		HRESULT retValue;
	};

	STDMETHOD(EnableStatementCompletion_Deprecated)(
		/*[in]*/ BOOL fEnable,
		/*[in]*/ CharIndex iStartIndex,
		/*[in]*/ CharIndex iEndIndex)
	{
		VSL_DEFINE_MOCK_METHOD(EnableStatementCompletion_Deprecated)

		VSL_CHECK_VALIDVALUE(fEnable);

		VSL_CHECK_VALIDVALUE(iStartIndex);

		VSL_CHECK_VALIDVALUE(iEndIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetCompletionContext_DeprecatedValidValues
	{
		/*[in]*/ LPCOLESTR pszFilePath;
		/*[in]*/ IVsTextLines* pBuffer;
		/*[in]*/ TextSpan* ptsCurStatement;
		/*[in]*/ IUnknown* punkContext;
		HRESULT retValue;
	};

	STDMETHOD(SetCompletionContext_Deprecated)(
		/*[in]*/ LPCOLESTR pszFilePath,
		/*[in]*/ IVsTextLines* pBuffer,
		/*[in]*/ const TextSpan* ptsCurStatement,
		/*[in]*/ IUnknown* punkContext)
	{
		VSL_DEFINE_MOCK_METHOD(SetCompletionContext_Deprecated)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFilePath);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_CHECK_VALIDVALUE_POINTER(ptsCurStatement);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkContext);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSIMMEDIATESTATEMENTCOMPLETION2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsImmediateStatementCompletion.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSIMMEDIATESTATEMENTCOMPLETION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSIMMEDIATESTATEMENTCOMPLETION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "completion.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsImmediateStatementCompletionNotImpl :
	public IVsImmediateStatementCompletion
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsImmediateStatementCompletionNotImpl)

public:

	typedef IVsImmediateStatementCompletion Interface;

	STDMETHOD(InstallStatementCompletion)(
		/*[in]*/ BOOL /*fInstall*/,
		/*[in]*/ IVsTextView* /*pCmdWinView*/,
		/*[in]*/ BOOL /*fInitialEnable*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnableStatementCompletion_Deprecated)(
		/*[in]*/ BOOL /*fEnable*/,
		/*[in]*/ CharIndex /*iStartIndex*/,
		/*[in]*/ CharIndex /*iEndIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetCompletionContext_Deprecated)(
		/*[in]*/ LPCOLESTR /*pszFilePath*/,
		/*[in]*/ IVsTextLines* /*pBuffer*/,
		/*[in]*/ const TextSpan* /*ptsCurStatement*/,
		/*[in]*/ IUnknown* /*punkContext*/)VSL_STDMETHOD_NOTIMPL
};

class IVsImmediateStatementCompletionMockImpl :
	public IVsImmediateStatementCompletion,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsImmediateStatementCompletionMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsImmediateStatementCompletionMockImpl)

	typedef IVsImmediateStatementCompletion Interface;
	struct InstallStatementCompletionValidValues
	{
		/*[in]*/ BOOL fInstall;
		/*[in]*/ IVsTextView* pCmdWinView;
		/*[in]*/ BOOL fInitialEnable;
		HRESULT retValue;
	};

	STDMETHOD(InstallStatementCompletion)(
		/*[in]*/ BOOL fInstall,
		/*[in]*/ IVsTextView* pCmdWinView,
		/*[in]*/ BOOL fInitialEnable)
	{
		VSL_DEFINE_MOCK_METHOD(InstallStatementCompletion)

		VSL_CHECK_VALIDVALUE(fInstall);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCmdWinView);

		VSL_CHECK_VALIDVALUE(fInitialEnable);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnableStatementCompletion_DeprecatedValidValues
	{
		/*[in]*/ BOOL fEnable;
		/*[in]*/ CharIndex iStartIndex;
		/*[in]*/ CharIndex iEndIndex;
		HRESULT retValue;
	};

	STDMETHOD(EnableStatementCompletion_Deprecated)(
		/*[in]*/ BOOL fEnable,
		/*[in]*/ CharIndex iStartIndex,
		/*[in]*/ CharIndex iEndIndex)
	{
		VSL_DEFINE_MOCK_METHOD(EnableStatementCompletion_Deprecated)

		VSL_CHECK_VALIDVALUE(fEnable);

		VSL_CHECK_VALIDVALUE(iStartIndex);

		VSL_CHECK_VALIDVALUE(iEndIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetCompletionContext_DeprecatedValidValues
	{
		/*[in]*/ LPCOLESTR pszFilePath;
		/*[in]*/ IVsTextLines* pBuffer;
		/*[in]*/ TextSpan* ptsCurStatement;
		/*[in]*/ IUnknown* punkContext;
		HRESULT retValue;
	};

	STDMETHOD(SetCompletionContext_Deprecated)(
		/*[in]*/ LPCOLESTR pszFilePath,
		/*[in]*/ IVsTextLines* pBuffer,
		/*[in]*/ const TextSpan* ptsCurStatement,
		/*[in]*/ IUnknown* punkContext)
	{
		VSL_DEFINE_MOCK_METHOD(SetCompletionContext_Deprecated)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFilePath);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_CHECK_VALIDVALUE_POINTER(ptsCurStatement);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkContext);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSIMMEDIATESTATEMENTCOMPLETION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsIntellisenseEngine.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSINTELLISENSEENGINE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSINTELLISENSEENGINE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "containedlanguage.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsIntellisenseEngineNotImpl :
	public IVsIntellisenseEngine
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsIntellisenseEngineNotImpl)

public:

	typedef IVsIntellisenseEngine Interface;

	STDMETHOD(Load)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Unload)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SupportsLoad)()VSL_STDMETHOD_NOTIMPL
};

class IVsIntellisenseEngineMockImpl :
	public IVsIntellisenseEngine,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsIntellisenseEngineMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsIntellisenseEngineMockImpl)

	typedef IVsIntellisenseEngine Interface;
	struct LoadValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Load)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Load)

		VSL_RETURN_VALIDVALUES();
	}
	struct UnloadValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Unload)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Unload)

		VSL_RETURN_VALIDVALUES();
	}
	struct SupportsLoadValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(SupportsLoad)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(SupportsLoad)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSINTELLISENSEENGINE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsIntelliMouseHandler.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSINTELLIMOUSEHANDLER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSINTELLIMOUSEHANDLER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsIntelliMouseHandlerNotImpl :
	public IVsIntelliMouseHandler
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsIntelliMouseHandlerNotImpl)

public:

	typedef IVsIntelliMouseHandler Interface;

	STDMETHOD(IsMouseWheelRotationMessage)(
		/*[in]*/ UINT /*msg*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(HandleWheelRotation)(
		/*[in]*/ HWND /*hwnd*/,
		/*[in]*/ WPARAM /*wp*/,
		/*[in]*/ DWORD /*dwStyle*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(HandleWheelButtonDown)(
		/*[in]*/ HWND /*hwnd*/,
		/*[in]*/ DWORD /*dwStyle*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MouseWheelPresent)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetMouseCursor_)(
		/*[in]*/ POINT /*ptOrg*/,
		/*[in]*/ POINT /*ptNew*/,
		/*[in]*/ UINT /*idCurOrg*/,
		/*[in]*/ UINT /*uNeutralRadius*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LoadBitmap_)(
		/*[in]*/ HWND /*hwnd*/,
		/*[in]*/ UINT /*idbmp*/,
		/*[in]*/ UINT /*idcur*/,
		/*[in]*/ POINT /*ptOrg*/,
		/*[in]*/ DWORD* /*lpPanBitmap*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DrawBitmap_)(
		/*[in]*/ DWORD* /*lpPanBitmap*/,
		/*[in]*/ BOOL /*fErase*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMouseWheelMsg_)(
		/*[out]*/ UINT* /*uMsg*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DeleteBitmap_)(
		/*[in]*/ DWORD* /*lpPanBitmap*/)VSL_STDMETHOD_NOTIMPL
};

class IVsIntelliMouseHandlerMockImpl :
	public IVsIntelliMouseHandler,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsIntelliMouseHandlerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsIntelliMouseHandlerMockImpl)

	typedef IVsIntelliMouseHandler Interface;
	struct IsMouseWheelRotationMessageValidValues
	{
		/*[in]*/ UINT msg;
		HRESULT retValue;
	};

	STDMETHOD(IsMouseWheelRotationMessage)(
		/*[in]*/ UINT msg)
	{
		VSL_DEFINE_MOCK_METHOD(IsMouseWheelRotationMessage)

		VSL_CHECK_VALIDVALUE(msg);

		VSL_RETURN_VALIDVALUES();
	}
	struct HandleWheelRotationValidValues
	{
		/*[in]*/ HWND hwnd;
		/*[in]*/ WPARAM wp;
		/*[in]*/ DWORD dwStyle;
		HRESULT retValue;
	};

	STDMETHOD(HandleWheelRotation)(
		/*[in]*/ HWND hwnd,
		/*[in]*/ WPARAM wp,
		/*[in]*/ DWORD dwStyle)
	{
		VSL_DEFINE_MOCK_METHOD(HandleWheelRotation)

		VSL_CHECK_VALIDVALUE(hwnd);

		VSL_CHECK_VALIDVALUE(wp);

		VSL_CHECK_VALIDVALUE(dwStyle);

		VSL_RETURN_VALIDVALUES();
	}
	struct HandleWheelButtonDownValidValues
	{
		/*[in]*/ HWND hwnd;
		/*[in]*/ DWORD dwStyle;
		HRESULT retValue;
	};

	STDMETHOD(HandleWheelButtonDown)(
		/*[in]*/ HWND hwnd,
		/*[in]*/ DWORD dwStyle)
	{
		VSL_DEFINE_MOCK_METHOD(HandleWheelButtonDown)

		VSL_CHECK_VALIDVALUE(hwnd);

		VSL_CHECK_VALIDVALUE(dwStyle);

		VSL_RETURN_VALIDVALUES();
	}
	struct MouseWheelPresentValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(MouseWheelPresent)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(MouseWheelPresent)

		VSL_RETURN_VALIDVALUES();
	}
	struct SetMouseCursor_ValidValues
	{
		/*[in]*/ POINT ptOrg;
		/*[in]*/ POINT ptNew;
		/*[in]*/ UINT idCurOrg;
		/*[in]*/ UINT uNeutralRadius;
		HRESULT retValue;
	};

	STDMETHOD(SetMouseCursor_)(
		/*[in]*/ POINT ptOrg,
		/*[in]*/ POINT ptNew,
		/*[in]*/ UINT idCurOrg,
		/*[in]*/ UINT uNeutralRadius)
	{
		VSL_DEFINE_MOCK_METHOD(SetMouseCursor_)

		VSL_CHECK_VALIDVALUE(ptOrg);

		VSL_CHECK_VALIDVALUE(ptNew);

		VSL_CHECK_VALIDVALUE(idCurOrg);

		VSL_CHECK_VALIDVALUE(uNeutralRadius);

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadBitmap_ValidValues
	{
		/*[in]*/ HWND hwnd;
		/*[in]*/ UINT idbmp;
		/*[in]*/ UINT idcur;
		/*[in]*/ POINT ptOrg;
		/*[in]*/ DWORD* lpPanBitmap;
		HRESULT retValue;
	};

	STDMETHOD(LoadBitmap_)(
		/*[in]*/ HWND hwnd,
		/*[in]*/ UINT idbmp,
		/*[in]*/ UINT idcur,
		/*[in]*/ POINT ptOrg,
		/*[in]*/ DWORD* lpPanBitmap)
	{
		VSL_DEFINE_MOCK_METHOD(LoadBitmap_)

		VSL_CHECK_VALIDVALUE(hwnd);

		VSL_CHECK_VALIDVALUE(idbmp);

		VSL_CHECK_VALIDVALUE(idcur);

		VSL_CHECK_VALIDVALUE(ptOrg);

		VSL_CHECK_VALIDVALUE_POINTER(lpPanBitmap);

		VSL_RETURN_VALIDVALUES();
	}
	struct DrawBitmap_ValidValues
	{
		/*[in]*/ DWORD* lpPanBitmap;
		/*[in]*/ BOOL fErase;
		HRESULT retValue;
	};

	STDMETHOD(DrawBitmap_)(
		/*[in]*/ DWORD* lpPanBitmap,
		/*[in]*/ BOOL fErase)
	{
		VSL_DEFINE_MOCK_METHOD(DrawBitmap_)

		VSL_CHECK_VALIDVALUE_POINTER(lpPanBitmap);

		VSL_CHECK_VALIDVALUE(fErase);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMouseWheelMsg_ValidValues
	{
		/*[out]*/ UINT* uMsg;
		HRESULT retValue;
	};

	STDMETHOD(GetMouseWheelMsg_)(
		/*[out]*/ UINT* uMsg)
	{
		VSL_DEFINE_MOCK_METHOD(GetMouseWheelMsg_)

		VSL_SET_VALIDVALUE(uMsg);

		VSL_RETURN_VALIDVALUES();
	}
	struct DeleteBitmap_ValidValues
	{
		/*[in]*/ DWORD* lpPanBitmap;
		HRESULT retValue;
	};

	STDMETHOD(DeleteBitmap_)(
		/*[in]*/ DWORD* lpPanBitmap)
	{
		VSL_DEFINE_MOCK_METHOD(DeleteBitmap_)

		VSL_CHECK_VALIDVALUE_POINTER(lpPanBitmap);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSINTELLIMOUSEHANDLER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsInsertionUI.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSINSERTIONUI_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSINSERTIONUI_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsInsertionUINotImpl :
	public IVsInsertionUI
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsInsertionUINotImpl)

public:

	typedef IVsInsertionUI Interface;

	STDMETHOD(GetWindowHandle)(
		/*[out]*/ HWND* /*hwnd*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Hide)()VSL_STDMETHOD_NOTIMPL
};

class IVsInsertionUIMockImpl :
	public IVsInsertionUI,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsInsertionUIMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsInsertionUIMockImpl)

	typedef IVsInsertionUI Interface;
	struct GetWindowHandleValidValues
	{
		/*[out]*/ HWND* hwnd;
		HRESULT retValue;
	};

	STDMETHOD(GetWindowHandle)(
		/*[out]*/ HWND* hwnd)
	{
		VSL_DEFINE_MOCK_METHOD(GetWindowHandle)

		VSL_SET_VALIDVALUE(hwnd);

		VSL_RETURN_VALIDVALUES();
	}
	struct HideValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Hide)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Hide)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSINSERTIONUI_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsIntellisenseCompletor.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSINTELLISENSECOMPLETOR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSINTELLISENSECOMPLETOR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "singlefileeditor.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsIntellisenseCompletorNotImpl :
	public IVsIntellisenseCompletor
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsIntellisenseCompletorNotImpl)

public:

	typedef IVsIntellisenseCompletor Interface;

	STDMETHOD(Initialize)(
		/*[in]*/ IVsIntellisenseHost* /*pHost*/,
		/*[in]*/ HWND /*hwndParent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Update)(
		/*[in]*/ IVsCompletionSet* /*pCompSet*/,
		/*[in]*/ DWORD /*dwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetWidth)(
		/*[in]*/ DWORD* /*dwWidth*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetHeight)(
		/*[in]*/ DWORD* /*dwHeight*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCompletionSpan)(
		/*[in]*/ TextSpan* /*ts*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetLocation)(
		/*[in]*/ POINT* /*p*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Hide)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsActive)(
		/*[out]*/ BOOL* /*pfIsActive*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetWindowHandle)(
		/*[out]*/ HWND* /*phwnd*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryStatus)(
		/*[in,unique]*/ const GUID* /*pguidCmdGroup*/,
		/*[in]*/ ULONG /*cCmds*/,
		/*[size_is(cCmds),in,out]*/ OLECMD[] /*prgCmds*/,
		/*[in,out,unique]*/ OLECMDTEXT* /*pCmdText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Exec)(
		/*[in,unique]*/ const GUID* /*pguidCmdGroup*/,
		/*[in]*/ DWORD /*nCmdID*/,
		/*[in]*/ DWORD /*nCmdexecopt*/,
		/*[in,unique]*/ VARIANT* /*pvaIn*/,
		/*[in,out,unique]*/ VARIANT* /*pvaOut*/)VSL_STDMETHOD_NOTIMPL
};

class IVsIntellisenseCompletorMockImpl :
	public IVsIntellisenseCompletor,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsIntellisenseCompletorMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsIntellisenseCompletorMockImpl)

	typedef IVsIntellisenseCompletor Interface;
	struct InitializeValidValues
	{
		/*[in]*/ IVsIntellisenseHost* pHost;
		/*[in]*/ HWND hwndParent;
		HRESULT retValue;
	};

	STDMETHOD(Initialize)(
		/*[in]*/ IVsIntellisenseHost* pHost,
		/*[in]*/ HWND hwndParent)
	{
		VSL_DEFINE_MOCK_METHOD(Initialize)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHost);

		VSL_CHECK_VALIDVALUE(hwndParent);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateValidValues
	{
		/*[in]*/ IVsCompletionSet* pCompSet;
		/*[in]*/ DWORD dwFlags;
		HRESULT retValue;
	};

	STDMETHOD(Update)(
		/*[in]*/ IVsCompletionSet* pCompSet,
		/*[in]*/ DWORD dwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(Update)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCompSet);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetWidthValidValues
	{
		/*[in]*/ DWORD* dwWidth;
		HRESULT retValue;
	};

	STDMETHOD(GetWidth)(
		/*[in]*/ DWORD* dwWidth)
	{
		VSL_DEFINE_MOCK_METHOD(GetWidth)

		VSL_CHECK_VALIDVALUE_POINTER(dwWidth);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetHeightValidValues
	{
		/*[in]*/ DWORD* dwHeight;
		HRESULT retValue;
	};

	STDMETHOD(GetHeight)(
		/*[in]*/ DWORD* dwHeight)
	{
		VSL_DEFINE_MOCK_METHOD(GetHeight)

		VSL_CHECK_VALIDVALUE_POINTER(dwHeight);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCompletionSpanValidValues
	{
		/*[in]*/ TextSpan* ts;
		HRESULT retValue;
	};

	STDMETHOD(GetCompletionSpan)(
		/*[in]*/ TextSpan* ts)
	{
		VSL_DEFINE_MOCK_METHOD(GetCompletionSpan)

		VSL_CHECK_VALIDVALUE_POINTER(ts);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetLocationValidValues
	{
		/*[in]*/ POINT* p;
		HRESULT retValue;
	};

	STDMETHOD(SetLocation)(
		/*[in]*/ POINT* p)
	{
		VSL_DEFINE_MOCK_METHOD(SetLocation)

		VSL_CHECK_VALIDVALUE_POINTER(p);

		VSL_RETURN_VALIDVALUES();
	}
	struct HideValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Hide)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Hide)

		VSL_RETURN_VALIDVALUES();
	}
	struct IsActiveValidValues
	{
		/*[out]*/ BOOL* pfIsActive;
		HRESULT retValue;
	};

	STDMETHOD(IsActive)(
		/*[out]*/ BOOL* pfIsActive)
	{
		VSL_DEFINE_MOCK_METHOD(IsActive)

		VSL_SET_VALIDVALUE(pfIsActive);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetWindowHandleValidValues
	{
		/*[out]*/ HWND* phwnd;
		HRESULT retValue;
	};

	STDMETHOD(GetWindowHandle)(
		/*[out]*/ HWND* phwnd)
	{
		VSL_DEFINE_MOCK_METHOD(GetWindowHandle)

		VSL_SET_VALIDVALUE(phwnd);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryStatusValidValues
	{
		/*[in,unique]*/ GUID* pguidCmdGroup;
		/*[in]*/ ULONG cCmds;
		/*[size_is(cCmds),in,out]*/ OLECMD* prgCmds;
		/*[in,out,unique]*/ OLECMDTEXT* pCmdText;
		HRESULT retValue;
	};

	STDMETHOD(QueryStatus)(
		/*[in,unique]*/ const GUID* pguidCmdGroup,
		/*[in]*/ ULONG cCmds,
		/*[size_is(cCmds),in,out]*/ OLECMD prgCmds[],
		/*[in,out,unique]*/ OLECMDTEXT* pCmdText)
	{
		VSL_DEFINE_MOCK_METHOD(QueryStatus)

		VSL_CHECK_VALIDVALUE_POINTER(pguidCmdGroup);

		VSL_CHECK_VALIDVALUE(cCmds);

		VSL_SET_VALIDVALUE_MEMCPY(prgCmds, cCmds*sizeof(prgCmds[0]), validValues.cCmds*sizeof(validValues.prgCmds[0]));

		VSL_SET_VALIDVALUE(pCmdText);

		VSL_RETURN_VALIDVALUES();
	}
	struct ExecValidValues
	{
		/*[in,unique]*/ GUID* pguidCmdGroup;
		/*[in]*/ DWORD nCmdID;
		/*[in]*/ DWORD nCmdexecopt;
		/*[in,unique]*/ VARIANT* pvaIn;
		/*[in,out,unique]*/ VARIANT* pvaOut;
		HRESULT retValue;
	};

	STDMETHOD(Exec)(
		/*[in,unique]*/ const GUID* pguidCmdGroup,
		/*[in]*/ DWORD nCmdID,
		/*[in]*/ DWORD nCmdexecopt,
		/*[in,unique]*/ VARIANT* pvaIn,
		/*[in,out,unique]*/ VARIANT* pvaOut)
	{
		VSL_DEFINE_MOCK_METHOD(Exec)

		VSL_CHECK_VALIDVALUE_POINTER(pguidCmdGroup);

		VSL_CHECK_VALIDVALUE(nCmdID);

		VSL_CHECK_VALIDVALUE(nCmdexecopt);

		VSL_CHECK_VALIDVALUE_POINTER(pvaIn);

		VSL_SET_VALIDVALUE_VARIANT(pvaOut);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSINTELLISENSECOMPLETOR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsInstalledProduct.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSINSTALLEDPRODUCT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSINSTALLEDPRODUCT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vssplash.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsInstalledProductNotImpl :
	public IVsInstalledProduct
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsInstalledProductNotImpl)

public:

	typedef IVsInstalledProduct Interface;

	STDMETHOD(get_IdBmpSplash)(
		/*[out,retval]*/ UINT* /*pIdBmp*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_OfficialName)(
		/*[out,retval]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ProductID)(
		/*[out,retval]*/ BSTR* /*pbstrPID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ProductDetails)(
		/*[out,retval]*/ BSTR* /*pbstrProductDetails*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IdIcoLogoForAboutbox)(
		/*[out,retval]*/ UINT* /*pIdIco*/)VSL_STDMETHOD_NOTIMPL
};

class IVsInstalledProductMockImpl :
	public IVsInstalledProduct,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsInstalledProductMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsInstalledProductMockImpl)

	typedef IVsInstalledProduct Interface;
	struct get_IdBmpSplashValidValues
	{
		/*[out,retval]*/ UINT* pIdBmp;
		HRESULT retValue;
	};

	STDMETHOD(get_IdBmpSplash)(
		/*[out,retval]*/ UINT* pIdBmp)
	{
		VSL_DEFINE_MOCK_METHOD(get_IdBmpSplash)

		VSL_SET_VALIDVALUE(pIdBmp);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OfficialNameValidValues
	{
		/*[out,retval]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(get_OfficialName)(
		/*[out,retval]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(get_OfficialName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ProductIDValidValues
	{
		/*[out,retval]*/ BSTR* pbstrPID;
		HRESULT retValue;
	};

	STDMETHOD(get_ProductID)(
		/*[out,retval]*/ BSTR* pbstrPID)
	{
		VSL_DEFINE_MOCK_METHOD(get_ProductID)

		VSL_SET_VALIDVALUE_BSTR(pbstrPID);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ProductDetailsValidValues
	{
		/*[out,retval]*/ BSTR* pbstrProductDetails;
		HRESULT retValue;
	};

	STDMETHOD(get_ProductDetails)(
		/*[out,retval]*/ BSTR* pbstrProductDetails)
	{
		VSL_DEFINE_MOCK_METHOD(get_ProductDetails)

		VSL_SET_VALIDVALUE_BSTR(pbstrProductDetails);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IdIcoLogoForAboutboxValidValues
	{
		/*[out,retval]*/ UINT* pIdIco;
		HRESULT retValue;
	};

	STDMETHOD(get_IdIcoLogoForAboutbox)(
		/*[out,retval]*/ UINT* pIdIco)
	{
		VSL_DEFINE_MOCK_METHOD(get_IdIcoLogoForAboutbox)

		VSL_SET_VALIDVALUE(pIdIco);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSINSTALLEDPRODUCT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsIntellisenseHost.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSINTELLISENSEHOST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSINTELLISENSEHOST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "singlefileeditor.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsIntellisenseHostNotImpl :
	public IVsIntellisenseHost
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsIntellisenseHostNotImpl)

public:

	typedef IVsIntellisenseHost Interface;

	STDMETHOD(GetHostFlags)(
		/*[out,retval]*/ DWORD* /*pdwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetContextBuffer)(
		/*[out,retval]*/ IVsTextLines** /*ppCtxBuffer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetContextFocalPoint)(
		/*[out]*/ TextSpan* /*pSpan*/,
		/*[in]*/ long* /*piLen*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetContextCaretPos)(
		/*[in]*/ long /*iLine*/,
		/*[in]*/ long /*iIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetContextCaretPos)(
		/*[out]*/ long* /*piLine*/,
		/*[out]*/ long* /*piIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetContextSelection)(
		/*[in]*/ long /*iStartLine*/,
		/*[in]*/ long /*iStartIndex*/,
		/*[in]*/ long /*iEndLine*/,
		/*[in]*/ long /*iEndIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetContextSelection)(
		/*[out]*/ TextSpan* /*pSelectionSpan*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSubjectText)(
		/*[out,retval]*/ BSTR* /*pbstrSubjectText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetSubjectCaretPos)(
		/*[in]*/ long /*iIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSubjectCaretPos)(
		/*[out]*/ long* /*piIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetSubjectSelection)(
		/*[in]*/ long /*iAnchorIndex*/,
		/*[in]*/ long /*iEndIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSubjectSelection)(
		/*[out]*/ long* /*piAnchorIndex*/,
		/*[out]*/ long* /*piEndIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReplaceSubjectTextSpan)(
		/*[in]*/ long /*iStartIndex*/,
		/*[in]*/ long /*iEndIndex*/,
		/*[in]*/ LPCWSTR /*pszText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateCompletionStatus)(
		/*[in]*/ IVsCompletionSet* /*pCompSet*/,
		/*[in]*/ DWORD /*dwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateTipWindow)(
		/*[in]*/ IVsTipWindow* /*pTipWindow*/,
		/*[in]*/ DWORD /*dwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(HighlightMatchingBrace)(
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in]*/ ULONG /*cSpans*/,
		/*[in,size_is(cSpans)]*/ TextSpan* /*rgBaseSpans*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(BeforeCompletorCommit)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AfterCompletorCommit)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetServiceProvider)(
		/*[out]*/ IServiceProvider** /*ppSP*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetHostWindow)(
		/*[out]*/ HWND* /*hwnd*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetContextLocation)(
		/*[in]*/ long /*iPos*/,
		/*[in]*/ long /*iLen*/,
		/*[in]*/ BOOL /*fUseCaretPosition*/,
		/*[out]*/ RECT* /*prc*/,
		/*[out]*/ long* /*piTopX*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateSmartTagWindow)(
		/*[in]*/ IVsSmartTagTipWindow* /*pSmartTagWnd*/,
		/*[in]*/ DWORD /*dwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSmartTagRect)(
		/*[out]*/ RECT* /*rcSmartTag*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryStatus)(
		/*[in,unique]*/ const GUID* /*pguidCmdGroup*/,
		/*[in]*/ ULONG /*cCmds*/,
		/*[size_is(cCmds),in,out]*/ OLECMD[] /*prgCmds*/,
		/*[in,out,unique]*/ OLECMDTEXT* /*pCmdText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Exec)(
		/*[in,unique]*/ const GUID* /*pguidCmdGroup*/,
		/*[in]*/ DWORD /*nCmdID*/,
		/*[in]*/ DWORD /*nCmdexecopt*/,
		/*[in,unique]*/ VARIANT* /*pvaIn*/,
		/*[in,out,unique]*/ VARIANT* /*pvaOut*/)VSL_STDMETHOD_NOTIMPL
};

class IVsIntellisenseHostMockImpl :
	public IVsIntellisenseHost,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsIntellisenseHostMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsIntellisenseHostMockImpl)

	typedef IVsIntellisenseHost Interface;
	struct GetHostFlagsValidValues
	{
		/*[out,retval]*/ DWORD* pdwFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetHostFlags)(
		/*[out,retval]*/ DWORD* pdwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetHostFlags)

		VSL_SET_VALIDVALUE(pdwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetContextBufferValidValues
	{
		/*[out,retval]*/ IVsTextLines** ppCtxBuffer;
		HRESULT retValue;
	};

	STDMETHOD(GetContextBuffer)(
		/*[out,retval]*/ IVsTextLines** ppCtxBuffer)
	{
		VSL_DEFINE_MOCK_METHOD(GetContextBuffer)

		VSL_SET_VALIDVALUE_INTERFACE(ppCtxBuffer);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetContextFocalPointValidValues
	{
		/*[out]*/ TextSpan* pSpan;
		/*[in]*/ long* piLen;
		HRESULT retValue;
	};

	STDMETHOD(GetContextFocalPoint)(
		/*[out]*/ TextSpan* pSpan,
		/*[in]*/ long* piLen)
	{
		VSL_DEFINE_MOCK_METHOD(GetContextFocalPoint)

		VSL_SET_VALIDVALUE(pSpan);

		VSL_CHECK_VALIDVALUE_POINTER(piLen);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetContextCaretPosValidValues
	{
		/*[in]*/ long iLine;
		/*[in]*/ long iIndex;
		HRESULT retValue;
	};

	STDMETHOD(SetContextCaretPos)(
		/*[in]*/ long iLine,
		/*[in]*/ long iIndex)
	{
		VSL_DEFINE_MOCK_METHOD(SetContextCaretPos)

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_CHECK_VALIDVALUE(iIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetContextCaretPosValidValues
	{
		/*[out]*/ long* piLine;
		/*[out]*/ long* piIndex;
		HRESULT retValue;
	};

	STDMETHOD(GetContextCaretPos)(
		/*[out]*/ long* piLine,
		/*[out]*/ long* piIndex)
	{
		VSL_DEFINE_MOCK_METHOD(GetContextCaretPos)

		VSL_SET_VALIDVALUE(piLine);

		VSL_SET_VALIDVALUE(piIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetContextSelectionValidValues
	{
		/*[in]*/ long iStartLine;
		/*[in]*/ long iStartIndex;
		/*[in]*/ long iEndLine;
		/*[in]*/ long iEndIndex;
		HRESULT retValue;
	};

	STDMETHOD(SetContextSelection)(
		/*[in]*/ long iStartLine,
		/*[in]*/ long iStartIndex,
		/*[in]*/ long iEndLine,
		/*[in]*/ long iEndIndex)
	{
		VSL_DEFINE_MOCK_METHOD(SetContextSelection)

		VSL_CHECK_VALIDVALUE(iStartLine);

		VSL_CHECK_VALIDVALUE(iStartIndex);

		VSL_CHECK_VALIDVALUE(iEndLine);

		VSL_CHECK_VALIDVALUE(iEndIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetContextSelectionValidValues
	{
		/*[out]*/ TextSpan* pSelectionSpan;
		HRESULT retValue;
	};

	STDMETHOD(GetContextSelection)(
		/*[out]*/ TextSpan* pSelectionSpan)
	{
		VSL_DEFINE_MOCK_METHOD(GetContextSelection)

		VSL_SET_VALIDVALUE(pSelectionSpan);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSubjectTextValidValues
	{
		/*[out,retval]*/ BSTR* pbstrSubjectText;
		HRESULT retValue;
	};

	STDMETHOD(GetSubjectText)(
		/*[out,retval]*/ BSTR* pbstrSubjectText)
	{
		VSL_DEFINE_MOCK_METHOD(GetSubjectText)

		VSL_SET_VALIDVALUE_BSTR(pbstrSubjectText);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetSubjectCaretPosValidValues
	{
		/*[in]*/ long iIndex;
		HRESULT retValue;
	};

	STDMETHOD(SetSubjectCaretPos)(
		/*[in]*/ long iIndex)
	{
		VSL_DEFINE_MOCK_METHOD(SetSubjectCaretPos)

		VSL_CHECK_VALIDVALUE(iIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSubjectCaretPosValidValues
	{
		/*[out]*/ long* piIndex;
		HRESULT retValue;
	};

	STDMETHOD(GetSubjectCaretPos)(
		/*[out]*/ long* piIndex)
	{
		VSL_DEFINE_MOCK_METHOD(GetSubjectCaretPos)

		VSL_SET_VALIDVALUE(piIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetSubjectSelectionValidValues
	{
		/*[in]*/ long iAnchorIndex;
		/*[in]*/ long iEndIndex;
		HRESULT retValue;
	};

	STDMETHOD(SetSubjectSelection)(
		/*[in]*/ long iAnchorIndex,
		/*[in]*/ long iEndIndex)
	{
		VSL_DEFINE_MOCK_METHOD(SetSubjectSelection)

		VSL_CHECK_VALIDVALUE(iAnchorIndex);

		VSL_CHECK_VALIDVALUE(iEndIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSubjectSelectionValidValues
	{
		/*[out]*/ long* piAnchorIndex;
		/*[out]*/ long* piEndIndex;
		HRESULT retValue;
	};

	STDMETHOD(GetSubjectSelection)(
		/*[out]*/ long* piAnchorIndex,
		/*[out]*/ long* piEndIndex)
	{
		VSL_DEFINE_MOCK_METHOD(GetSubjectSelection)

		VSL_SET_VALIDVALUE(piAnchorIndex);

		VSL_SET_VALIDVALUE(piEndIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReplaceSubjectTextSpanValidValues
	{
		/*[in]*/ long iStartIndex;
		/*[in]*/ long iEndIndex;
		/*[in]*/ LPCWSTR pszText;
		HRESULT retValue;
	};

	STDMETHOD(ReplaceSubjectTextSpan)(
		/*[in]*/ long iStartIndex,
		/*[in]*/ long iEndIndex,
		/*[in]*/ LPCWSTR pszText)
	{
		VSL_DEFINE_MOCK_METHOD(ReplaceSubjectTextSpan)

		VSL_CHECK_VALIDVALUE(iStartIndex);

		VSL_CHECK_VALIDVALUE(iEndIndex);

		VSL_CHECK_VALIDVALUE_STRINGW(pszText);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateCompletionStatusValidValues
	{
		/*[in]*/ IVsCompletionSet* pCompSet;
		/*[in]*/ DWORD dwFlags;
		HRESULT retValue;
	};

	STDMETHOD(UpdateCompletionStatus)(
		/*[in]*/ IVsCompletionSet* pCompSet,
		/*[in]*/ DWORD dwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateCompletionStatus)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCompSet);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateTipWindowValidValues
	{
		/*[in]*/ IVsTipWindow* pTipWindow;
		/*[in]*/ DWORD dwFlags;
		HRESULT retValue;
	};

	STDMETHOD(UpdateTipWindow)(
		/*[in]*/ IVsTipWindow* pTipWindow,
		/*[in]*/ DWORD dwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateTipWindow)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pTipWindow);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct HighlightMatchingBraceValidValues
	{
		/*[in]*/ DWORD dwFlags;
		/*[in]*/ ULONG cSpans;
		/*[in,size_is(cSpans)]*/ TextSpan* rgBaseSpans;
		HRESULT retValue;
	};

	STDMETHOD(HighlightMatchingBrace)(
		/*[in]*/ DWORD dwFlags,
		/*[in]*/ ULONG cSpans,
		/*[in,size_is(cSpans)]*/ TextSpan* rgBaseSpans)
	{
		VSL_DEFINE_MOCK_METHOD(HighlightMatchingBrace)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE(cSpans);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgBaseSpans, cSpans*sizeof(rgBaseSpans[0]), validValues.cSpans*sizeof(validValues.rgBaseSpans[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct BeforeCompletorCommitValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(BeforeCompletorCommit)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(BeforeCompletorCommit)

		VSL_RETURN_VALIDVALUES();
	}
	struct AfterCompletorCommitValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(AfterCompletorCommit)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(AfterCompletorCommit)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetServiceProviderValidValues
	{
		/*[out]*/ IServiceProvider** ppSP;
		HRESULT retValue;
	};

	STDMETHOD(GetServiceProvider)(
		/*[out]*/ IServiceProvider** ppSP)
	{
		VSL_DEFINE_MOCK_METHOD(GetServiceProvider)

		VSL_SET_VALIDVALUE_INTERFACE(ppSP);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetHostWindowValidValues
	{
		/*[out]*/ HWND* hwnd;
		HRESULT retValue;
	};

	STDMETHOD(GetHostWindow)(
		/*[out]*/ HWND* hwnd)
	{
		VSL_DEFINE_MOCK_METHOD(GetHostWindow)

		VSL_SET_VALIDVALUE(hwnd);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetContextLocationValidValues
	{
		/*[in]*/ long iPos;
		/*[in]*/ long iLen;
		/*[in]*/ BOOL fUseCaretPosition;
		/*[out]*/ RECT* prc;
		/*[out]*/ long* piTopX;
		HRESULT retValue;
	};

	STDMETHOD(GetContextLocation)(
		/*[in]*/ long iPos,
		/*[in]*/ long iLen,
		/*[in]*/ BOOL fUseCaretPosition,
		/*[out]*/ RECT* prc,
		/*[out]*/ long* piTopX)
	{
		VSL_DEFINE_MOCK_METHOD(GetContextLocation)

		VSL_CHECK_VALIDVALUE(iPos);

		VSL_CHECK_VALIDVALUE(iLen);

		VSL_CHECK_VALIDVALUE(fUseCaretPosition);

		VSL_SET_VALIDVALUE(prc);

		VSL_SET_VALIDVALUE(piTopX);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateSmartTagWindowValidValues
	{
		/*[in]*/ IVsSmartTagTipWindow* pSmartTagWnd;
		/*[in]*/ DWORD dwFlags;
		HRESULT retValue;
	};

	STDMETHOD(UpdateSmartTagWindow)(
		/*[in]*/ IVsSmartTagTipWindow* pSmartTagWnd,
		/*[in]*/ DWORD dwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateSmartTagWindow)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSmartTagWnd);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSmartTagRectValidValues
	{
		/*[out]*/ RECT* rcSmartTag;
		HRESULT retValue;
	};

	STDMETHOD(GetSmartTagRect)(
		/*[out]*/ RECT* rcSmartTag)
	{
		VSL_DEFINE_MOCK_METHOD(GetSmartTagRect)

		VSL_SET_VALIDVALUE(rcSmartTag);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryStatusValidValues
	{
		/*[in,unique]*/ GUID* pguidCmdGroup;
		/*[in]*/ ULONG cCmds;
		/*[size_is(cCmds),in,out]*/ OLECMD* prgCmds;
		/*[in,out,unique]*/ OLECMDTEXT* pCmdText;
		HRESULT retValue;
	};

	STDMETHOD(QueryStatus)(
		/*[in,unique]*/ const GUID* pguidCmdGroup,
		/*[in]*/ ULONG cCmds,
		/*[size_is(cCmds),in,out]*/ OLECMD prgCmds[],
		/*[in,out,unique]*/ OLECMDTEXT* pCmdText)
	{
		VSL_DEFINE_MOCK_METHOD(QueryStatus)

		VSL_CHECK_VALIDVALUE_POINTER(pguidCmdGroup);

		VSL_CHECK_VALIDVALUE(cCmds);

		VSL_SET_VALIDVALUE_MEMCPY(prgCmds, cCmds*sizeof(prgCmds[0]), validValues.cCmds*sizeof(validValues.prgCmds[0]));

		VSL_SET_VALIDVALUE(pCmdText);

		VSL_RETURN_VALIDVALUES();
	}
	struct ExecValidValues
	{
		/*[in,unique]*/ GUID* pguidCmdGroup;
		/*[in]*/ DWORD nCmdID;
		/*[in]*/ DWORD nCmdexecopt;
		/*[in,unique]*/ VARIANT* pvaIn;
		/*[in,out,unique]*/ VARIANT* pvaOut;
		HRESULT retValue;
	};

	STDMETHOD(Exec)(
		/*[in,unique]*/ const GUID* pguidCmdGroup,
		/*[in]*/ DWORD nCmdID,
		/*[in]*/ DWORD nCmdexecopt,
		/*[in,unique]*/ VARIANT* pvaIn,
		/*[in,out,unique]*/ VARIANT* pvaOut)
	{
		VSL_DEFINE_MOCK_METHOD(Exec)

		VSL_CHECK_VALIDVALUE_POINTER(pguidCmdGroup);

		VSL_CHECK_VALIDVALUE(nCmdID);

		VSL_CHECK_VALIDVALUE(nCmdexecopt);

		VSL_CHECK_VALIDVALUE_POINTER(pvaIn);

		VSL_SET_VALIDVALUE_VARIANT(pvaOut);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSINTELLISENSEHOST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsIntellisenseLangTip.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSINTELLISENSELANGTIP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSINTELLISENSELANGTIP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "singlefileeditor.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsIntellisenseLangTipNotImpl :
	public IVsIntellisenseLangTip
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsIntellisenseLangTipNotImpl)

public:

	typedef IVsIntellisenseLangTip Interface;

	STDMETHOD(Initialize)(
		/*[in]*/ IVsIntellisenseHost* /*pHost*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSizePreferences)(
		/*[in]*/ RECT* /*prcCtxBounds*/,
		/*[in]*/ TIPSIZEDATA* /*pSizeData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Create)(
		/*[in]*/ IVsTipWindow* /*pTipWnd*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Update)(
		/*[in]*/ IVsTipWindow* /*pTipWnd*/,
		/*[in]*/ DWORD /*dwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdatePosition)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSizeY)(
		/*[out]*/ short* /*pSizeY*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Close)(
		/*[in]*/ BOOL /*fDeleteThis*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsActive)(
		/*[out]*/ BOOL* /*pfIsActive*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetOverloadCount)(
		/*[out]*/ long* /*plOverloadCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ScrollUp)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ScrollDown)()VSL_STDMETHOD_NOTIMPL
};

class IVsIntellisenseLangTipMockImpl :
	public IVsIntellisenseLangTip,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsIntellisenseLangTipMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsIntellisenseLangTipMockImpl)

	typedef IVsIntellisenseLangTip Interface;
	struct InitializeValidValues
	{
		/*[in]*/ IVsIntellisenseHost* pHost;
		HRESULT retValue;
	};

	STDMETHOD(Initialize)(
		/*[in]*/ IVsIntellisenseHost* pHost)
	{
		VSL_DEFINE_MOCK_METHOD(Initialize)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHost);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSizePreferencesValidValues
	{
		/*[in]*/ RECT* prcCtxBounds;
		/*[in]*/ TIPSIZEDATA* pSizeData;
		HRESULT retValue;
	};

	STDMETHOD(GetSizePreferences)(
		/*[in]*/ RECT* prcCtxBounds,
		/*[in]*/ TIPSIZEDATA* pSizeData)
	{
		VSL_DEFINE_MOCK_METHOD(GetSizePreferences)

		VSL_CHECK_VALIDVALUE_POINTER(prcCtxBounds);

		VSL_CHECK_VALIDVALUE_POINTER(pSizeData);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateValidValues
	{
		/*[in]*/ IVsTipWindow* pTipWnd;
		HRESULT retValue;
	};

	STDMETHOD(Create)(
		/*[in]*/ IVsTipWindow* pTipWnd)
	{
		VSL_DEFINE_MOCK_METHOD(Create)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pTipWnd);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateValidValues
	{
		/*[in]*/ IVsTipWindow* pTipWnd;
		/*[in]*/ DWORD dwFlags;
		HRESULT retValue;
	};

	STDMETHOD(Update)(
		/*[in]*/ IVsTipWindow* pTipWnd,
		/*[in]*/ DWORD dwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(Update)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pTipWnd);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdatePositionValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(UpdatePosition)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(UpdatePosition)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSizeYValidValues
	{
		/*[out]*/ short* pSizeY;
		HRESULT retValue;
	};

	STDMETHOD(GetSizeY)(
		/*[out]*/ short* pSizeY)
	{
		VSL_DEFINE_MOCK_METHOD(GetSizeY)

		VSL_SET_VALIDVALUE(pSizeY);

		VSL_RETURN_VALIDVALUES();
	}
	struct CloseValidValues
	{
		/*[in]*/ BOOL fDeleteThis;
		HRESULT retValue;
	};

	STDMETHOD(Close)(
		/*[in]*/ BOOL fDeleteThis)
	{
		VSL_DEFINE_MOCK_METHOD(Close)

		VSL_CHECK_VALIDVALUE(fDeleteThis);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsActiveValidValues
	{
		/*[out]*/ BOOL* pfIsActive;
		HRESULT retValue;
	};

	STDMETHOD(IsActive)(
		/*[out]*/ BOOL* pfIsActive)
	{
		VSL_DEFINE_MOCK_METHOD(IsActive)

		VSL_SET_VALIDVALUE(pfIsActive);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetOverloadCountValidValues
	{
		/*[out]*/ long* plOverloadCount;
		HRESULT retValue;
	};

	STDMETHOD(GetOverloadCount)(
		/*[out]*/ long* plOverloadCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetOverloadCount)

		VSL_SET_VALIDVALUE(plOverloadCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct ScrollUpValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ScrollUp)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ScrollUp)

		VSL_RETURN_VALIDVALUES();
	}
	struct ScrollDownValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ScrollDown)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ScrollDown)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSINTELLISENSELANGTIP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsIntellisenseProject.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSINTELLISENSEPROJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSINTELLISENSEPROJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "containedlanguage.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsIntellisenseProjectNotImpl :
	public IVsIntellisenseProject
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsIntellisenseProjectNotImpl)

public:

	typedef IVsIntellisenseProject Interface;

	STDMETHOD(Init)(
		/*[in]*/ IVsIntellisenseProjectHost* /*pHost*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Close)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddFile)(
		/*[in]*/ BSTR /*bstrAbsPath*/,
		/*[in]*/ VSITEMID /*itemid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveFile)(
		/*[in]*/ BSTR /*bstrAbsPath*/,
		/*[in]*/ VSITEMID /*itemid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RenameFile)(
		/*[in]*/ BSTR /*bstrAbsPath*/,
		/*[in]*/ BSTR /*bstrNewAbsPath*/,
		/*[in]*/ VSITEMID /*itemid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsCompilableFile)(
		/*[in]*/ BSTR /*bstrFileName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetContainedLanguageFactory)(
		/*[out,retval]*/ IVsContainedLanguageFactory** /*ppContainedLanguageFactory*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCompilerReference)(
		/*[out,retval]*/ IUnknown** /*ppCompilerReference*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFileCodeModel)(
		/*[in]*/ IUnknown* /*pProj*/,
		/*[in]*/ IUnknown* /*pProjectItem*/,
		/*[out,retval]*/ IUnknown** /*ppCodeModel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProjectCodeModel)(
		/*[in]*/ IUnknown* /*pProj*/,
		/*[out,retval]*/ IUnknown** /*ppCodeModel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RefreshCompilerOptions)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCodeDomProviderName)(
		/*[out,retval]*/ BSTR* /*pbstrProvider*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsWebFileRequiredByProject)(
		/*[out,retval]*/ BOOL* /*pbReq*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddAssemblyReference)(
		/*[in]*/ BSTR /*bstrAbsPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveAssemblyReference)(
		/*[in]*/ BSTR /*bstrAbsPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddP2PReference)(
		/*[in]*/ IUnknown* /*pUnk*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveP2PReference)(
		/*[in]*/ IUnknown* /*pUnk*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(StopIntellisenseEngine)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(StartIntellisenseEngine)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsSupportedP2PReference)(
		/*[in]*/ IUnknown* /*pUnk*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(WaitForIntellisenseReady)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExternalErrorReporter)(
		/*[out,retval]*/ IVsReportExternalErrors** /*ppErrorReporter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SuspendPostedNotifications)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ResumePostedNotifications)()VSL_STDMETHOD_NOTIMPL
};

class IVsIntellisenseProjectMockImpl :
	public IVsIntellisenseProject,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsIntellisenseProjectMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsIntellisenseProjectMockImpl)

	typedef IVsIntellisenseProject Interface;
	struct InitValidValues
	{
		/*[in]*/ IVsIntellisenseProjectHost* pHost;
		HRESULT retValue;
	};

	STDMETHOD(Init)(
		/*[in]*/ IVsIntellisenseProjectHost* pHost)
	{
		VSL_DEFINE_MOCK_METHOD(Init)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHost);

		VSL_RETURN_VALIDVALUES();
	}
	struct CloseValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Close)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Close)

		VSL_RETURN_VALIDVALUES();
	}
	struct AddFileValidValues
	{
		/*[in]*/ BSTR bstrAbsPath;
		/*[in]*/ VSITEMID itemid;
		HRESULT retValue;
	};

	STDMETHOD(AddFile)(
		/*[in]*/ BSTR bstrAbsPath,
		/*[in]*/ VSITEMID itemid)
	{
		VSL_DEFINE_MOCK_METHOD(AddFile)

		VSL_CHECK_VALIDVALUE_BSTR(bstrAbsPath);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveFileValidValues
	{
		/*[in]*/ BSTR bstrAbsPath;
		/*[in]*/ VSITEMID itemid;
		HRESULT retValue;
	};

	STDMETHOD(RemoveFile)(
		/*[in]*/ BSTR bstrAbsPath,
		/*[in]*/ VSITEMID itemid)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveFile)

		VSL_CHECK_VALIDVALUE_BSTR(bstrAbsPath);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_RETURN_VALIDVALUES();
	}
	struct RenameFileValidValues
	{
		/*[in]*/ BSTR bstrAbsPath;
		/*[in]*/ BSTR bstrNewAbsPath;
		/*[in]*/ VSITEMID itemid;
		HRESULT retValue;
	};

	STDMETHOD(RenameFile)(
		/*[in]*/ BSTR bstrAbsPath,
		/*[in]*/ BSTR bstrNewAbsPath,
		/*[in]*/ VSITEMID itemid)
	{
		VSL_DEFINE_MOCK_METHOD(RenameFile)

		VSL_CHECK_VALIDVALUE_BSTR(bstrAbsPath);

		VSL_CHECK_VALIDVALUE_BSTR(bstrNewAbsPath);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsCompilableFileValidValues
	{
		/*[in]*/ BSTR bstrFileName;
		HRESULT retValue;
	};

	STDMETHOD(IsCompilableFile)(
		/*[in]*/ BSTR bstrFileName)
	{
		VSL_DEFINE_MOCK_METHOD(IsCompilableFile)

		VSL_CHECK_VALIDVALUE_BSTR(bstrFileName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetContainedLanguageFactoryValidValues
	{
		/*[out,retval]*/ IVsContainedLanguageFactory** ppContainedLanguageFactory;
		HRESULT retValue;
	};

	STDMETHOD(GetContainedLanguageFactory)(
		/*[out,retval]*/ IVsContainedLanguageFactory** ppContainedLanguageFactory)
	{
		VSL_DEFINE_MOCK_METHOD(GetContainedLanguageFactory)

		VSL_SET_VALIDVALUE_INTERFACE(ppContainedLanguageFactory);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCompilerReferenceValidValues
	{
		/*[out,retval]*/ IUnknown** ppCompilerReference;
		HRESULT retValue;
	};

	STDMETHOD(GetCompilerReference)(
		/*[out,retval]*/ IUnknown** ppCompilerReference)
	{
		VSL_DEFINE_MOCK_METHOD(GetCompilerReference)

		VSL_SET_VALIDVALUE_INTERFACE(ppCompilerReference);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFileCodeModelValidValues
	{
		/*[in]*/ IUnknown* pProj;
		/*[in]*/ IUnknown* pProjectItem;
		/*[out,retval]*/ IUnknown** ppCodeModel;
		HRESULT retValue;
	};

	STDMETHOD(GetFileCodeModel)(
		/*[in]*/ IUnknown* pProj,
		/*[in]*/ IUnknown* pProjectItem,
		/*[out,retval]*/ IUnknown** ppCodeModel)
	{
		VSL_DEFINE_MOCK_METHOD(GetFileCodeModel)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProj);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProjectItem);

		VSL_SET_VALIDVALUE_INTERFACE(ppCodeModel);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProjectCodeModelValidValues
	{
		/*[in]*/ IUnknown* pProj;
		/*[out,retval]*/ IUnknown** ppCodeModel;
		HRESULT retValue;
	};

	STDMETHOD(GetProjectCodeModel)(
		/*[in]*/ IUnknown* pProj,
		/*[out,retval]*/ IUnknown** ppCodeModel)
	{
		VSL_DEFINE_MOCK_METHOD(GetProjectCodeModel)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProj);

		VSL_SET_VALIDVALUE_INTERFACE(ppCodeModel);

		VSL_RETURN_VALIDVALUES();
	}
	struct RefreshCompilerOptionsValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(RefreshCompilerOptions)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(RefreshCompilerOptions)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCodeDomProviderNameValidValues
	{
		/*[out,retval]*/ BSTR* pbstrProvider;
		HRESULT retValue;
	};

	STDMETHOD(GetCodeDomProviderName)(
		/*[out,retval]*/ BSTR* pbstrProvider)
	{
		VSL_DEFINE_MOCK_METHOD(GetCodeDomProviderName)

		VSL_SET_VALIDVALUE_BSTR(pbstrProvider);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsWebFileRequiredByProjectValidValues
	{
		/*[out,retval]*/ BOOL* pbReq;
		HRESULT retValue;
	};

	STDMETHOD(IsWebFileRequiredByProject)(
		/*[out,retval]*/ BOOL* pbReq)
	{
		VSL_DEFINE_MOCK_METHOD(IsWebFileRequiredByProject)

		VSL_SET_VALIDVALUE(pbReq);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddAssemblyReferenceValidValues
	{
		/*[in]*/ BSTR bstrAbsPath;
		HRESULT retValue;
	};

	STDMETHOD(AddAssemblyReference)(
		/*[in]*/ BSTR bstrAbsPath)
	{
		VSL_DEFINE_MOCK_METHOD(AddAssemblyReference)

		VSL_CHECK_VALIDVALUE_BSTR(bstrAbsPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveAssemblyReferenceValidValues
	{
		/*[in]*/ BSTR bstrAbsPath;
		HRESULT retValue;
	};

	STDMETHOD(RemoveAssemblyReference)(
		/*[in]*/ BSTR bstrAbsPath)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveAssemblyReference)

		VSL_CHECK_VALIDVALUE_BSTR(bstrAbsPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddP2PReferenceValidValues
	{
		/*[in]*/ IUnknown* pUnk;
		HRESULT retValue;
	};

	STDMETHOD(AddP2PReference)(
		/*[in]*/ IUnknown* pUnk)
	{
		VSL_DEFINE_MOCK_METHOD(AddP2PReference)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnk);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveP2PReferenceValidValues
	{
		/*[in]*/ IUnknown* pUnk;
		HRESULT retValue;
	};

	STDMETHOD(RemoveP2PReference)(
		/*[in]*/ IUnknown* pUnk)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveP2PReference)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnk);

		VSL_RETURN_VALIDVALUES();
	}
	struct StopIntellisenseEngineValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(StopIntellisenseEngine)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(StopIntellisenseEngine)

		VSL_RETURN_VALIDVALUES();
	}
	struct StartIntellisenseEngineValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(StartIntellisenseEngine)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(StartIntellisenseEngine)

		VSL_RETURN_VALIDVALUES();
	}
	struct IsSupportedP2PReferenceValidValues
	{
		/*[in]*/ IUnknown* pUnk;
		HRESULT retValue;
	};

	STDMETHOD(IsSupportedP2PReference)(
		/*[in]*/ IUnknown* pUnk)
	{
		VSL_DEFINE_MOCK_METHOD(IsSupportedP2PReference)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnk);

		VSL_RETURN_VALIDVALUES();
	}
	struct WaitForIntellisenseReadyValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(WaitForIntellisenseReady)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(WaitForIntellisenseReady)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExternalErrorReporterValidValues
	{
		/*[out,retval]*/ IVsReportExternalErrors** ppErrorReporter;
		HRESULT retValue;
	};

	STDMETHOD(GetExternalErrorReporter)(
		/*[out,retval]*/ IVsReportExternalErrors** ppErrorReporter)
	{
		VSL_DEFINE_MOCK_METHOD(GetExternalErrorReporter)

		VSL_SET_VALIDVALUE_INTERFACE(ppErrorReporter);

		VSL_RETURN_VALIDVALUES();
	}
	struct SuspendPostedNotificationsValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(SuspendPostedNotifications)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(SuspendPostedNotifications)

		VSL_RETURN_VALIDVALUES();
	}
	struct ResumePostedNotificationsValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ResumePostedNotifications)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ResumePostedNotifications)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSINTELLISENSEPROJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsIntellisenseOptions.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSINTELLISENSEOPTIONS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSINTELLISENSEOPTIONS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsIntellisenseOptionsNotImpl :
	public IVsIntellisenseOptions
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsIntellisenseOptionsNotImpl)

public:

	typedef IVsIntellisenseOptions Interface;

	STDMETHOD(SetCompletorSize)(
		/*[in]*/ long /*uSize*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCompletorSize)(
		/*[out]*/ long* /*uSize*/)VSL_STDMETHOD_NOTIMPL
};

class IVsIntellisenseOptionsMockImpl :
	public IVsIntellisenseOptions,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsIntellisenseOptionsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsIntellisenseOptionsMockImpl)

	typedef IVsIntellisenseOptions Interface;
	struct SetCompletorSizeValidValues
	{
		/*[in]*/ long uSize;
		HRESULT retValue;
	};

	STDMETHOD(SetCompletorSize)(
		/*[in]*/ long uSize)
	{
		VSL_DEFINE_MOCK_METHOD(SetCompletorSize)

		VSL_CHECK_VALIDVALUE(uSize);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCompletorSizeValidValues
	{
		/*[out]*/ long* uSize;
		HRESULT retValue;
	};

	STDMETHOD(GetCompletorSize)(
		/*[out]*/ long* uSize)
	{
		VSL_DEFINE_MOCK_METHOD(GetCompletorSize)

		VSL_SET_VALIDVALUE(uSize);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSINTELLISENSEOPTIONS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsIntellisenseProjectEventSink.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSINTELLISENSEPROJECTEVENTSINK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSINTELLISENSEPROJECTEVENTSINK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "containedlanguage.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsIntellisenseProjectEventSinkNotImpl :
	public IVsIntellisenseProjectEventSink
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsIntellisenseProjectEventSinkNotImpl)

public:

	typedef IVsIntellisenseProjectEventSink Interface;

	STDMETHOD(OnStatusChange)(
		/*[in]*/ DWORD /*dwStatus*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnReferenceChange)(
		/*[in]*/ DWORD /*dwChangeType*/,
		/*[in]*/ LPCWSTR /*pszAssemblyPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnConfigChange)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnCodeFileChange)(
		/*[in]*/ LPCWSTR /*pszOldCodeFile*/,
		/*[in]*/ LPCWSTR /*pszNewCodeFile*/)VSL_STDMETHOD_NOTIMPL
};

class IVsIntellisenseProjectEventSinkMockImpl :
	public IVsIntellisenseProjectEventSink,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsIntellisenseProjectEventSinkMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsIntellisenseProjectEventSinkMockImpl)

	typedef IVsIntellisenseProjectEventSink Interface;
	struct OnStatusChangeValidValues
	{
		/*[in]*/ DWORD dwStatus;
		HRESULT retValue;
	};

	STDMETHOD(OnStatusChange)(
		/*[in]*/ DWORD dwStatus)
	{
		VSL_DEFINE_MOCK_METHOD(OnStatusChange)

		VSL_CHECK_VALIDVALUE(dwStatus);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnReferenceChangeValidValues
	{
		/*[in]*/ DWORD dwChangeType;
		/*[in]*/ LPCWSTR pszAssemblyPath;
		HRESULT retValue;
	};

	STDMETHOD(OnReferenceChange)(
		/*[in]*/ DWORD dwChangeType,
		/*[in]*/ LPCWSTR pszAssemblyPath)
	{
		VSL_DEFINE_MOCK_METHOD(OnReferenceChange)

		VSL_CHECK_VALIDVALUE(dwChangeType);

		VSL_CHECK_VALIDVALUE_STRINGW(pszAssemblyPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnConfigChangeValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnConfigChange)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnConfigChange)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnCodeFileChangeValidValues
	{
		/*[in]*/ LPCWSTR pszOldCodeFile;
		/*[in]*/ LPCWSTR pszNewCodeFile;
		HRESULT retValue;
	};

	STDMETHOD(OnCodeFileChange)(
		/*[in]*/ LPCWSTR pszOldCodeFile,
		/*[in]*/ LPCWSTR pszNewCodeFile)
	{
		VSL_DEFINE_MOCK_METHOD(OnCodeFileChange)

		VSL_CHECK_VALIDVALUE_STRINGW(pszOldCodeFile);

		VSL_CHECK_VALIDVALUE_STRINGW(pszNewCodeFile);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSINTELLISENSEPROJECTEVENTSINK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsIntellisenseProjectHost.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSINTELLISENSEPROJECTHOST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSINTELLISENSEPROJECTHOST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "containedlanguage.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsIntellisenseProjectHostNotImpl :
	public IVsIntellisenseProjectHost
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsIntellisenseProjectHostNotImpl)

public:

	typedef IVsIntellisenseProjectHost Interface;

	STDMETHOD(GetHostProperty)(
		/*[in]*/ DWORD /*dwPropID*/,
		/*[out,retval]*/ VARIANT* /*pvar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCompilerOptions)(
		/*[out,retval]*/ BSTR* /*pbstrOptions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetOutputAssembly)(
		/*[out,retval]*/ BSTR* /*pbstrOutputAssembly*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateFileCodeModel)(
		/*[in]*/ LPCWSTR /*pszFilename*/,
		/*[out,retval]*/ IUnknown** /*ppCodeModel*/)VSL_STDMETHOD_NOTIMPL
};

class IVsIntellisenseProjectHostMockImpl :
	public IVsIntellisenseProjectHost,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsIntellisenseProjectHostMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsIntellisenseProjectHostMockImpl)

	typedef IVsIntellisenseProjectHost Interface;
	struct GetHostPropertyValidValues
	{
		/*[in]*/ DWORD dwPropID;
		/*[out,retval]*/ VARIANT* pvar;
		HRESULT retValue;
	};

	STDMETHOD(GetHostProperty)(
		/*[in]*/ DWORD dwPropID,
		/*[out,retval]*/ VARIANT* pvar)
	{
		VSL_DEFINE_MOCK_METHOD(GetHostProperty)

		VSL_CHECK_VALIDVALUE(dwPropID);

		VSL_SET_VALIDVALUE_VARIANT(pvar);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCompilerOptionsValidValues
	{
		/*[out,retval]*/ BSTR* pbstrOptions;
		HRESULT retValue;
	};

	STDMETHOD(GetCompilerOptions)(
		/*[out,retval]*/ BSTR* pbstrOptions)
	{
		VSL_DEFINE_MOCK_METHOD(GetCompilerOptions)

		VSL_SET_VALIDVALUE_BSTR(pbstrOptions);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetOutputAssemblyValidValues
	{
		/*[out,retval]*/ BSTR* pbstrOutputAssembly;
		HRESULT retValue;
	};

	STDMETHOD(GetOutputAssembly)(
		/*[out,retval]*/ BSTR* pbstrOutputAssembly)
	{
		VSL_DEFINE_MOCK_METHOD(GetOutputAssembly)

		VSL_SET_VALIDVALUE_BSTR(pbstrOutputAssembly);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateFileCodeModelValidValues
	{
		/*[in]*/ LPCWSTR pszFilename;
		/*[out,retval]*/ IUnknown** ppCodeModel;
		HRESULT retValue;
	};

	STDMETHOD(CreateFileCodeModel)(
		/*[in]*/ LPCWSTR pszFilename,
		/*[out,retval]*/ IUnknown** ppCodeModel)
	{
		VSL_DEFINE_MOCK_METHOD(CreateFileCodeModel)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFilename);

		VSL_SET_VALIDVALUE_INTERFACE(ppCodeModel);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSINTELLISENSEPROJECTHOST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsInvisibleEditor.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSINVISIBLEEDITOR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSINVISIBLEEDITOR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsInvisibleEditorNotImpl :
	public IVsInvisibleEditor
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsInvisibleEditorNotImpl)

public:

	typedef IVsInvisibleEditor Interface;

	STDMETHOD(GetDocData)(
		/*[in]*/ BOOL /*fEnsureWritable*/,
		/*[in]*/ REFIID /*riid*/,
		/*[out,iid_is(riid)]*/ void** /*ppDocData*/)VSL_STDMETHOD_NOTIMPL
};

class IVsInvisibleEditorMockImpl :
	public IVsInvisibleEditor,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsInvisibleEditorMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsInvisibleEditorMockImpl)

	typedef IVsInvisibleEditor Interface;
	struct GetDocDataValidValues
	{
		/*[in]*/ BOOL fEnsureWritable;
		/*[in]*/ REFIID riid;
		/*[out,iid_is(riid)]*/ void** ppDocData;
		HRESULT retValue;
	};

	STDMETHOD(GetDocData)(
		/*[in]*/ BOOL fEnsureWritable,
		/*[in]*/ REFIID riid,
		/*[out,iid_is(riid)]*/ void** ppDocData)
	{
		VSL_DEFINE_MOCK_METHOD(GetDocData)

		VSL_CHECK_VALIDVALUE(fEnsureWritable);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_SET_VALIDVALUE(ppDocData);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSINVISIBLEEDITOR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsIntellisenseProjectManager.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSINTELLISENSEPROJECTMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSINTELLISENSEPROJECTMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "containedlanguage.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsIntellisenseProjectManagerNotImpl :
	public IVsIntellisenseProjectManager
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsIntellisenseProjectManagerNotImpl)

public:

	typedef IVsIntellisenseProjectManager Interface;

	STDMETHOD(AdviseIntellisenseProjectEvents)(
		/*[in]*/ IVsIntellisenseProjectEventSink* /*pSink*/,
		/*[out]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseIntellisenseProjectEvents)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetContainedLanguageFactory)(
		/*[in]*/ BSTR /*bstrLanguage*/,
		/*[out]*/ IVsContainedLanguageFactory** /*ppContainedLanguageFactory*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CloseIntellisenseProject)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnEditorReady)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CompleteIntellisenseProjectLoad)()VSL_STDMETHOD_NOTIMPL
};

class IVsIntellisenseProjectManagerMockImpl :
	public IVsIntellisenseProjectManager,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsIntellisenseProjectManagerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsIntellisenseProjectManagerMockImpl)

	typedef IVsIntellisenseProjectManager Interface;
	struct AdviseIntellisenseProjectEventsValidValues
	{
		/*[in]*/ IVsIntellisenseProjectEventSink* pSink;
		/*[out]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(AdviseIntellisenseProjectEvents)(
		/*[in]*/ IVsIntellisenseProjectEventSink* pSink,
		/*[out]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(AdviseIntellisenseProjectEvents)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSink);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseIntellisenseProjectEventsValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnadviseIntellisenseProjectEvents)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnadviseIntellisenseProjectEvents)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetContainedLanguageFactoryValidValues
	{
		/*[in]*/ BSTR bstrLanguage;
		/*[out]*/ IVsContainedLanguageFactory** ppContainedLanguageFactory;
		HRESULT retValue;
	};

	STDMETHOD(GetContainedLanguageFactory)(
		/*[in]*/ BSTR bstrLanguage,
		/*[out]*/ IVsContainedLanguageFactory** ppContainedLanguageFactory)
	{
		VSL_DEFINE_MOCK_METHOD(GetContainedLanguageFactory)

		VSL_CHECK_VALIDVALUE_BSTR(bstrLanguage);

		VSL_SET_VALIDVALUE_INTERFACE(ppContainedLanguageFactory);

		VSL_RETURN_VALIDVALUES();
	}
	struct CloseIntellisenseProjectValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CloseIntellisenseProject)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CloseIntellisenseProject)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnEditorReadyValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnEditorReady)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnEditorReady)

		VSL_RETURN_VALIDVALUES();
	}
	struct CompleteIntellisenseProjectLoadValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CompleteIntellisenseProjectLoad)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CompleteIntellisenseProjectLoad)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSINTELLISENSEPROJECTMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsInvisibleEditorManager.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSINVISIBLEEDITORMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSINVISIBLEEDITORMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsInvisibleEditorManagerNotImpl :
	public IVsInvisibleEditorManager
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsInvisibleEditorManagerNotImpl)

public:

	typedef IVsInvisibleEditorManager Interface;

	STDMETHOD(RegisterInvisibleEditor)(
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ EDITORREGFLAGS /*dwFlags*/,
		/*[in]*/ IVsSimpleDocFactory* /*pFactory*/,
		/*[out]*/ IVsInvisibleEditor** /*ppEditor*/)VSL_STDMETHOD_NOTIMPL
};

class IVsInvisibleEditorManagerMockImpl :
	public IVsInvisibleEditorManager,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsInvisibleEditorManagerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsInvisibleEditorManagerMockImpl)

	typedef IVsInvisibleEditorManager Interface;
	struct RegisterInvisibleEditorValidValues
	{
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ EDITORREGFLAGS dwFlags;
		/*[in]*/ IVsSimpleDocFactory* pFactory;
		/*[out]*/ IVsInvisibleEditor** ppEditor;
		HRESULT retValue;
	};

	STDMETHOD(RegisterInvisibleEditor)(
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ EDITORREGFLAGS dwFlags,
		/*[in]*/ IVsSimpleDocFactory* pFactory,
		/*[out]*/ IVsInvisibleEditor** ppEditor)
	{
		VSL_DEFINE_MOCK_METHOD(RegisterInvisibleEditor)

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pFactory);

		VSL_SET_VALIDVALUE_INTERFACE(ppEditor);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSINVISIBLEEDITORMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsItemTypeResolutionService.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSITEMTYPERESOLUTIONSERVICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSITEMTYPERESOLUTIONSERVICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "containedlanguage.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsItemTypeResolutionServiceNotImpl :
	public IVsItemTypeResolutionService
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsItemTypeResolutionServiceNotImpl)

public:

	typedef IVsItemTypeResolutionService Interface;

	STDMETHOD(SetSite)(
		/*[in]*/ IUnknown* /*punkVsItemTypeResolutionSite*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(InitializeReferences)(
		/*[in]*/ IUnknown* /*punkCompilerParameters*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReferenceAdded)(
		/*[in]*/ BSTR /*pszReference*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReferenceRemoved)(
		/*[in]*/ BSTR /*pszReference*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReferenceChanged)(
		/*[in]*/ BSTR /*pszReference*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reset)()VSL_STDMETHOD_NOTIMPL
};

class IVsItemTypeResolutionServiceMockImpl :
	public IVsItemTypeResolutionService,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsItemTypeResolutionServiceMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsItemTypeResolutionServiceMockImpl)

	typedef IVsItemTypeResolutionService Interface;
	struct SetSiteValidValues
	{
		/*[in]*/ IUnknown* punkVsItemTypeResolutionSite;
		HRESULT retValue;
	};

	STDMETHOD(SetSite)(
		/*[in]*/ IUnknown* punkVsItemTypeResolutionSite)
	{
		VSL_DEFINE_MOCK_METHOD(SetSite)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkVsItemTypeResolutionSite);

		VSL_RETURN_VALIDVALUES();
	}
	struct InitializeReferencesValidValues
	{
		/*[in]*/ IUnknown* punkCompilerParameters;
		HRESULT retValue;
	};

	STDMETHOD(InitializeReferences)(
		/*[in]*/ IUnknown* punkCompilerParameters)
	{
		VSL_DEFINE_MOCK_METHOD(InitializeReferences)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkCompilerParameters);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReferenceAddedValidValues
	{
		/*[in]*/ BSTR pszReference;
		HRESULT retValue;
	};

	STDMETHOD(ReferenceAdded)(
		/*[in]*/ BSTR pszReference)
	{
		VSL_DEFINE_MOCK_METHOD(ReferenceAdded)

		VSL_CHECK_VALIDVALUE_BSTR(pszReference);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReferenceRemovedValidValues
	{
		/*[in]*/ BSTR pszReference;
		HRESULT retValue;
	};

	STDMETHOD(ReferenceRemoved)(
		/*[in]*/ BSTR pszReference)
	{
		VSL_DEFINE_MOCK_METHOD(ReferenceRemoved)

		VSL_CHECK_VALIDVALUE_BSTR(pszReference);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReferenceChangedValidValues
	{
		/*[in]*/ BSTR pszReference;
		HRESULT retValue;
	};

	STDMETHOD(ReferenceChanged)(
		/*[in]*/ BSTR pszReference)
	{
		VSL_DEFINE_MOCK_METHOD(ReferenceChanged)

		VSL_CHECK_VALIDVALUE_BSTR(pszReference);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reset)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSITEMTYPERESOLUTIONSERVICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsItemTypeResolutionSite.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSITEMTYPERESOLUTIONSITE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSITEMTYPERESOLUTIONSITE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "containedlanguage.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsItemTypeResolutionSiteNotImpl :
	public IVsItemTypeResolutionSite
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsItemTypeResolutionSiteNotImpl)

public:

	typedef IVsItemTypeResolutionSite Interface;

	STDMETHOD(AddReference)(
		/*[in]*/ BSTR /*bstrReferencePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(WaitForReferencesReady)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsCodeDirectoryAssembly)(
		/*[in]*/ BSTR /*bstrAssembly*/,
		/*[out]*/ BOOL* /*pfIsCodeAssembly*/)VSL_STDMETHOD_NOTIMPL
};

class IVsItemTypeResolutionSiteMockImpl :
	public IVsItemTypeResolutionSite,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsItemTypeResolutionSiteMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsItemTypeResolutionSiteMockImpl)

	typedef IVsItemTypeResolutionSite Interface;
	struct AddReferenceValidValues
	{
		/*[in]*/ BSTR bstrReferencePath;
		HRESULT retValue;
	};

	STDMETHOD(AddReference)(
		/*[in]*/ BSTR bstrReferencePath)
	{
		VSL_DEFINE_MOCK_METHOD(AddReference)

		VSL_CHECK_VALIDVALUE_BSTR(bstrReferencePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct WaitForReferencesReadyValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(WaitForReferencesReady)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(WaitForReferencesReady)

		VSL_RETURN_VALIDVALUES();
	}
	struct IsCodeDirectoryAssemblyValidValues
	{
		/*[in]*/ BSTR bstrAssembly;
		/*[out]*/ BOOL* pfIsCodeAssembly;
		HRESULT retValue;
	};

	STDMETHOD(IsCodeDirectoryAssembly)(
		/*[in]*/ BSTR bstrAssembly,
		/*[out]*/ BOOL* pfIsCodeAssembly)
	{
		VSL_DEFINE_MOCK_METHOD(IsCodeDirectoryAssembly)

		VSL_CHECK_VALIDVALUE_BSTR(bstrAssembly);

		VSL_SET_VALIDVALUE(pfIsCodeAssembly);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSITEMTYPERESOLUTIONSITE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsLanguageClipboardOps.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSLANGUAGECLIPBOARDOPS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSLANGUAGECLIPBOARDOPS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsLanguageClipboardOpsNotImpl :
	public IVsLanguageClipboardOps
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLanguageClipboardOpsNotImpl)

public:

	typedef IVsLanguageClipboardOps Interface;

	STDMETHOD(GetDataObject)(
		/*[in]*/ IVsTextView* /*pView*/,
		/*[in]*/ IVsTextLayer* /*pTextLayer*/,
		/*[out,retval]*/ IDataObject** /*ppDO*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsTextData)(
		/*[in]*/ IDataObject* /*pDO*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(TextFromData)(
		/*[in]*/ IVsTextLayer* /*pTextLayer*/,
		/*[in]*/ IDataObject* /*pDO*/,
		/*[out]*/ LTE_TEXTDATAFLAGS* /*ptdfFlags*/,
		/*[out,retval]*/ BSTR* /*pbstrText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DataObjectRendered)(
		/*[in]*/ IVsTextLines* /*pTextLines*/,
		/*[in]*/ DWORD /*dwHint*/,
		/*[in]*/ TextSpan* /*ptsInsertedText*/)VSL_STDMETHOD_NOTIMPL
};

class IVsLanguageClipboardOpsMockImpl :
	public IVsLanguageClipboardOps,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLanguageClipboardOpsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsLanguageClipboardOpsMockImpl)

	typedef IVsLanguageClipboardOps Interface;
	struct GetDataObjectValidValues
	{
		/*[in]*/ IVsTextView* pView;
		/*[in]*/ IVsTextLayer* pTextLayer;
		/*[out,retval]*/ IDataObject** ppDO;
		HRESULT retValue;
	};

	STDMETHOD(GetDataObject)(
		/*[in]*/ IVsTextView* pView,
		/*[in]*/ IVsTextLayer* pTextLayer,
		/*[out,retval]*/ IDataObject** ppDO)
	{
		VSL_DEFINE_MOCK_METHOD(GetDataObject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pView);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pTextLayer);

		VSL_SET_VALIDVALUE_INTERFACE(ppDO);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsTextDataValidValues
	{
		/*[in]*/ IDataObject* pDO;
		HRESULT retValue;
	};

	STDMETHOD(IsTextData)(
		/*[in]*/ IDataObject* pDO)
	{
		VSL_DEFINE_MOCK_METHOD(IsTextData)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDO);

		VSL_RETURN_VALIDVALUES();
	}
	struct TextFromDataValidValues
	{
		/*[in]*/ IVsTextLayer* pTextLayer;
		/*[in]*/ IDataObject* pDO;
		/*[out]*/ LTE_TEXTDATAFLAGS* ptdfFlags;
		/*[out,retval]*/ BSTR* pbstrText;
		HRESULT retValue;
	};

	STDMETHOD(TextFromData)(
		/*[in]*/ IVsTextLayer* pTextLayer,
		/*[in]*/ IDataObject* pDO,
		/*[out]*/ LTE_TEXTDATAFLAGS* ptdfFlags,
		/*[out,retval]*/ BSTR* pbstrText)
	{
		VSL_DEFINE_MOCK_METHOD(TextFromData)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pTextLayer);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDO);

		VSL_SET_VALIDVALUE(ptdfFlags);

		VSL_SET_VALIDVALUE_BSTR(pbstrText);

		VSL_RETURN_VALIDVALUES();
	}
	struct DataObjectRenderedValidValues
	{
		/*[in]*/ IVsTextLines* pTextLines;
		/*[in]*/ DWORD dwHint;
		/*[in]*/ TextSpan* ptsInsertedText;
		HRESULT retValue;
	};

	STDMETHOD(DataObjectRendered)(
		/*[in]*/ IVsTextLines* pTextLines,
		/*[in]*/ DWORD dwHint,
		/*[in]*/ TextSpan* ptsInsertedText)
	{
		VSL_DEFINE_MOCK_METHOD(DataObjectRendered)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pTextLines);

		VSL_CHECK_VALIDVALUE(dwHint);

		VSL_CHECK_VALIDVALUE_POINTER(ptsInsertedText);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSLANGUAGECLIPBOARDOPS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsLanguageBlock.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSLANGUAGEBLOCK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSLANGUAGEBLOCK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsLanguageBlockNotImpl :
	public IVsLanguageBlock
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLanguageBlockNotImpl)

public:

	typedef IVsLanguageBlock Interface;

	STDMETHOD(GetCurrentBlock)(
		/*[in]*/ IVsTextLines* /*pTextLines*/,
		/*[in]*/ LONG /*iCurrentLine*/,
		/*[in]*/ LONG /*iCurrentChar*/,
		/*[out]*/ TextSpan* /*ptsBlockSpan*/,
		/*[out]*/ BSTR* /*pbstrDescription*/,
		/*[out,retval]*/ BOOL* /*pfBlockAvailable*/)VSL_STDMETHOD_NOTIMPL
};

class IVsLanguageBlockMockImpl :
	public IVsLanguageBlock,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLanguageBlockMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsLanguageBlockMockImpl)

	typedef IVsLanguageBlock Interface;
	struct GetCurrentBlockValidValues
	{
		/*[in]*/ IVsTextLines* pTextLines;
		/*[in]*/ LONG iCurrentLine;
		/*[in]*/ LONG iCurrentChar;
		/*[out]*/ TextSpan* ptsBlockSpan;
		/*[out]*/ BSTR* pbstrDescription;
		/*[out,retval]*/ BOOL* pfBlockAvailable;
		HRESULT retValue;
	};

	STDMETHOD(GetCurrentBlock)(
		/*[in]*/ IVsTextLines* pTextLines,
		/*[in]*/ LONG iCurrentLine,
		/*[in]*/ LONG iCurrentChar,
		/*[out]*/ TextSpan* ptsBlockSpan,
		/*[out]*/ BSTR* pbstrDescription,
		/*[out,retval]*/ BOOL* pfBlockAvailable)
	{
		VSL_DEFINE_MOCK_METHOD(GetCurrentBlock)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pTextLines);

		VSL_CHECK_VALIDVALUE(iCurrentLine);

		VSL_CHECK_VALIDVALUE(iCurrentChar);

		VSL_SET_VALIDVALUE(ptsBlockSpan);

		VSL_SET_VALIDVALUE_BSTR(pbstrDescription);

		VSL_SET_VALIDVALUE(pfBlockAvailable);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSLANGUAGEBLOCK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsLangSpecificSyntax.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSLANGSPECIFICSYNTAX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSLANGSPECIFICSYNTAX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsLangSpecificSyntaxNotImpl :
	public IVsLangSpecificSyntax
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLangSpecificSyntaxNotImpl)

public:

	typedef IVsLangSpecificSyntax Interface;

	STDMETHOD(GetText)(
		/*[in]*/ VSOBJECTINFO* /*pobjInfo*/,
		/*[in]*/ VSTREETEXTOPTIONS /*tto*/,
		/*[out]*/ const WCHAR** /*ppszText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FillDescription)(
		/*[in]*/ VSOBJECTINFO* /*pobjInfo*/,
		/*[in]*/ IVsObjectBrowserDescription2* /*pobDesc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSyntaxGuid)(
		/*[out]*/ const GUID* /*pguid*/)VSL_STDMETHOD_NOTIMPL
};

class IVsLangSpecificSyntaxMockImpl :
	public IVsLangSpecificSyntax,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLangSpecificSyntaxMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsLangSpecificSyntaxMockImpl)

	typedef IVsLangSpecificSyntax Interface;
	struct GetTextValidValues
	{
		/*[in]*/ VSOBJECTINFO* pobjInfo;
		/*[in]*/ VSTREETEXTOPTIONS tto;
		/*[out]*/ WCHAR** ppszText;
		HRESULT retValue;
	};

	STDMETHOD(GetText)(
		/*[in]*/ VSOBJECTINFO* pobjInfo,
		/*[in]*/ VSTREETEXTOPTIONS tto,
		/*[out]*/ const WCHAR** ppszText)
	{
		VSL_DEFINE_MOCK_METHOD(GetText)

		VSL_CHECK_VALIDVALUE_POINTER(pobjInfo);

		VSL_CHECK_VALIDVALUE(tto);

		VSL_SET_VALIDVALUE_CONST(ppszText, WCHAR**);

		VSL_RETURN_VALIDVALUES();
	}
	struct FillDescriptionValidValues
	{
		/*[in]*/ VSOBJECTINFO* pobjInfo;
		/*[in]*/ IVsObjectBrowserDescription2* pobDesc;
		HRESULT retValue;
	};

	STDMETHOD(FillDescription)(
		/*[in]*/ VSOBJECTINFO* pobjInfo,
		/*[in]*/ IVsObjectBrowserDescription2* pobDesc)
	{
		VSL_DEFINE_MOCK_METHOD(FillDescription)

		VSL_CHECK_VALIDVALUE_POINTER(pobjInfo);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pobDesc);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSyntaxGuidValidValues
	{
		/*[out]*/ GUID* pguid;
		HRESULT retValue;
	};

	STDMETHOD(GetSyntaxGuid)(
		/*[out]*/ const GUID* pguid)
	{
		VSL_DEFINE_MOCK_METHOD(GetSyntaxGuid)

		VSL_SET_VALIDVALUE_CONST(pguid, GUID*);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSLANGSPECIFICSYNTAX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsLanguageDebugInfo2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSLANGUAGEDEBUGINFO2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSLANGUAGEDEBUGINFO2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsLanguageDebugInfo2NotImpl :
	public IVsLanguageDebugInfo2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLanguageDebugInfo2NotImpl)

public:

	typedef IVsLanguageDebugInfo2 Interface;

	STDMETHOD(QueryCommonLanguageBlock)(
		/*[in]*/ IVsTextBuffer* /*pBuffer*/,
		/*[in]*/ long /*iLine*/,
		/*[in]*/ long /*iCol*/,
		/*[in]*/ DWORD /*dwFlag*/,
		/*[out]*/ BOOL* /*pfInBlock*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ValidateInstructionpointLocation)(
		/*[in]*/ IVsTextBuffer* /*pBuffer*/,
		/*[in]*/ long /*iLine*/,
		/*[in]*/ long /*iCol*/,
		/*[out]*/ TextSpan* /*pCodeSpan*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryCatchLineSpan)(
		/*[in]*/ IVsTextBuffer* /*pBuffer*/,
		/*[in]*/ long /*iLine*/,
		/*[in]*/ long /*iCol*/,
		/*[out]*/ BOOL* /*pfIsInCatch*/,
		/*[out]*/ TextSpan* /*ptsCatchLine*/)VSL_STDMETHOD_NOTIMPL
};

class IVsLanguageDebugInfo2MockImpl :
	public IVsLanguageDebugInfo2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLanguageDebugInfo2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsLanguageDebugInfo2MockImpl)

	typedef IVsLanguageDebugInfo2 Interface;
	struct QueryCommonLanguageBlockValidValues
	{
		/*[in]*/ IVsTextBuffer* pBuffer;
		/*[in]*/ long iLine;
		/*[in]*/ long iCol;
		/*[in]*/ DWORD dwFlag;
		/*[out]*/ BOOL* pfInBlock;
		HRESULT retValue;
	};

	STDMETHOD(QueryCommonLanguageBlock)(
		/*[in]*/ IVsTextBuffer* pBuffer,
		/*[in]*/ long iLine,
		/*[in]*/ long iCol,
		/*[in]*/ DWORD dwFlag,
		/*[out]*/ BOOL* pfInBlock)
	{
		VSL_DEFINE_MOCK_METHOD(QueryCommonLanguageBlock)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_CHECK_VALIDVALUE(iCol);

		VSL_CHECK_VALIDVALUE(dwFlag);

		VSL_SET_VALIDVALUE(pfInBlock);

		VSL_RETURN_VALIDVALUES();
	}
	struct ValidateInstructionpointLocationValidValues
	{
		/*[in]*/ IVsTextBuffer* pBuffer;
		/*[in]*/ long iLine;
		/*[in]*/ long iCol;
		/*[out]*/ TextSpan* pCodeSpan;
		HRESULT retValue;
	};

	STDMETHOD(ValidateInstructionpointLocation)(
		/*[in]*/ IVsTextBuffer* pBuffer,
		/*[in]*/ long iLine,
		/*[in]*/ long iCol,
		/*[out]*/ TextSpan* pCodeSpan)
	{
		VSL_DEFINE_MOCK_METHOD(ValidateInstructionpointLocation)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_CHECK_VALIDVALUE(iCol);

		VSL_SET_VALIDVALUE(pCodeSpan);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryCatchLineSpanValidValues
	{
		/*[in]*/ IVsTextBuffer* pBuffer;
		/*[in]*/ long iLine;
		/*[in]*/ long iCol;
		/*[out]*/ BOOL* pfIsInCatch;
		/*[out]*/ TextSpan* ptsCatchLine;
		HRESULT retValue;
	};

	STDMETHOD(QueryCatchLineSpan)(
		/*[in]*/ IVsTextBuffer* pBuffer,
		/*[in]*/ long iLine,
		/*[in]*/ long iCol,
		/*[out]*/ BOOL* pfIsInCatch,
		/*[out]*/ TextSpan* ptsCatchLine)
	{
		VSL_DEFINE_MOCK_METHOD(QueryCatchLineSpan)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_CHECK_VALIDVALUE(iCol);

		VSL_SET_VALIDVALUE(pfIsInCatch);

		VSL_SET_VALIDVALUE(ptsCatchLine);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSLANGUAGEDEBUGINFO2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsLanguageContextProvider.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSLANGUAGECONTEXTPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSLANGUAGECONTEXTPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsLanguageContextProviderNotImpl :
	public IVsLanguageContextProvider
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLanguageContextProviderNotImpl)

public:

	typedef IVsLanguageContextProvider Interface;

	STDMETHOD(UpdateLanguageContext)(
		/*[in]*/ DWORD /*dwHint*/,
		/*[in]*/ IVsTextLines* /*pBuffer*/,
		/*[in]*/ TextSpan* /*ptsSelection*/,
		/*[in]*/ IVsUserContext* /*pUC*/)VSL_STDMETHOD_NOTIMPL
};

class IVsLanguageContextProviderMockImpl :
	public IVsLanguageContextProvider,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLanguageContextProviderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsLanguageContextProviderMockImpl)

	typedef IVsLanguageContextProvider Interface;
	struct UpdateLanguageContextValidValues
	{
		/*[in]*/ DWORD dwHint;
		/*[in]*/ IVsTextLines* pBuffer;
		/*[in]*/ TextSpan* ptsSelection;
		/*[in]*/ IVsUserContext* pUC;
		HRESULT retValue;
	};

	STDMETHOD(UpdateLanguageContext)(
		/*[in]*/ DWORD dwHint,
		/*[in]*/ IVsTextLines* pBuffer,
		/*[in]*/ TextSpan* ptsSelection,
		/*[in]*/ IVsUserContext* pUC)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateLanguageContext)

		VSL_CHECK_VALIDVALUE(dwHint);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_CHECK_VALIDVALUE_POINTER(ptsSelection);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUC);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSLANGUAGECONTEXTPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsLanguageDebugInfo.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSLANGUAGEDEBUGINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSLANGUAGEDEBUGINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsLanguageDebugInfoNotImpl :
	public IVsLanguageDebugInfo
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLanguageDebugInfoNotImpl)

public:

	typedef IVsLanguageDebugInfo Interface;

	STDMETHOD(GetProximityExpressions)(
		/*[in]*/ IVsTextBuffer* /*pBuffer*/,
		/*[in]*/ long /*iLine*/,
		/*[in]*/ long /*iCol*/,
		/*[in]*/ long /*cLines*/,
		/*[out]*/ IVsEnumBSTR** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ValidateBreakpointLocation)(
		/*[in]*/ IVsTextBuffer* /*pBuffer*/,
		/*[in]*/ long /*iLine*/,
		/*[in]*/ long /*iCol*/,
		/*[out]*/ TextSpan* /*pCodeSpan*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetNameOfLocation)(
		/*[in]*/ IVsTextBuffer* /*pBuffer*/,
		/*[in]*/ long /*iLine*/,
		/*[in]*/ long /*iCol*/,
		/*[out]*/ BSTR* /*pbstrName*/,
		/*[out]*/ long* /*piLineOffset*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLocationOfName)(
		/*[in]*/ LPCOLESTR /*pszName*/,
		/*[out]*/ BSTR* /*pbstrMkDoc*/,
		/*[out]*/ TextSpan* /*pspanLocation*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ResolveName)(
		/*[in]*/ LPCOLESTR /*pszName*/,
		/*[in]*/ DWORD /*dwFlags*/,
		/*[out]*/ IVsEnumDebugName** /*ppNames*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLanguageID)(
		/*[in]*/ IVsTextBuffer* /*pBuffer*/,
		/*[in]*/ long /*iLine*/,
		/*[in]*/ long /*iCol*/,
		/*[out]*/ GUID* /*pguidLanguageID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsMappedLocation)(
		/*[in]*/ IVsTextBuffer* /*pBuffer*/,
		/*[in]*/ long /*iLine*/,
		/*[in]*/ long /*iCol*/)VSL_STDMETHOD_NOTIMPL
};

class IVsLanguageDebugInfoMockImpl :
	public IVsLanguageDebugInfo,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLanguageDebugInfoMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsLanguageDebugInfoMockImpl)

	typedef IVsLanguageDebugInfo Interface;
	struct GetProximityExpressionsValidValues
	{
		/*[in]*/ IVsTextBuffer* pBuffer;
		/*[in]*/ long iLine;
		/*[in]*/ long iCol;
		/*[in]*/ long cLines;
		/*[out]*/ IVsEnumBSTR** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(GetProximityExpressions)(
		/*[in]*/ IVsTextBuffer* pBuffer,
		/*[in]*/ long iLine,
		/*[in]*/ long iCol,
		/*[in]*/ long cLines,
		/*[out]*/ IVsEnumBSTR** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(GetProximityExpressions)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_CHECK_VALIDVALUE(iCol);

		VSL_CHECK_VALIDVALUE(cLines);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct ValidateBreakpointLocationValidValues
	{
		/*[in]*/ IVsTextBuffer* pBuffer;
		/*[in]*/ long iLine;
		/*[in]*/ long iCol;
		/*[out]*/ TextSpan* pCodeSpan;
		HRESULT retValue;
	};

	STDMETHOD(ValidateBreakpointLocation)(
		/*[in]*/ IVsTextBuffer* pBuffer,
		/*[in]*/ long iLine,
		/*[in]*/ long iCol,
		/*[out]*/ TextSpan* pCodeSpan)
	{
		VSL_DEFINE_MOCK_METHOD(ValidateBreakpointLocation)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_CHECK_VALIDVALUE(iCol);

		VSL_SET_VALIDVALUE(pCodeSpan);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNameOfLocationValidValues
	{
		/*[in]*/ IVsTextBuffer* pBuffer;
		/*[in]*/ long iLine;
		/*[in]*/ long iCol;
		/*[out]*/ BSTR* pbstrName;
		/*[out]*/ long* piLineOffset;
		HRESULT retValue;
	};

	STDMETHOD(GetNameOfLocation)(
		/*[in]*/ IVsTextBuffer* pBuffer,
		/*[in]*/ long iLine,
		/*[in]*/ long iCol,
		/*[out]*/ BSTR* pbstrName,
		/*[out]*/ long* piLineOffset)
	{
		VSL_DEFINE_MOCK_METHOD(GetNameOfLocation)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_CHECK_VALIDVALUE(iCol);

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_SET_VALIDVALUE(piLineOffset);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLocationOfNameValidValues
	{
		/*[in]*/ LPCOLESTR pszName;
		/*[out]*/ BSTR* pbstrMkDoc;
		/*[out]*/ TextSpan* pspanLocation;
		HRESULT retValue;
	};

	STDMETHOD(GetLocationOfName)(
		/*[in]*/ LPCOLESTR pszName,
		/*[out]*/ BSTR* pbstrMkDoc,
		/*[out]*/ TextSpan* pspanLocation)
	{
		VSL_DEFINE_MOCK_METHOD(GetLocationOfName)

		VSL_CHECK_VALIDVALUE_STRINGW(pszName);

		VSL_SET_VALIDVALUE_BSTR(pbstrMkDoc);

		VSL_SET_VALIDVALUE(pspanLocation);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResolveNameValidValues
	{
		/*[in]*/ LPCOLESTR pszName;
		/*[in]*/ DWORD dwFlags;
		/*[out]*/ IVsEnumDebugName** ppNames;
		HRESULT retValue;
	};

	STDMETHOD(ResolveName)(
		/*[in]*/ LPCOLESTR pszName,
		/*[in]*/ DWORD dwFlags,
		/*[out]*/ IVsEnumDebugName** ppNames)
	{
		VSL_DEFINE_MOCK_METHOD(ResolveName)

		VSL_CHECK_VALIDVALUE_STRINGW(pszName);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_SET_VALIDVALUE_INTERFACE(ppNames);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLanguageIDValidValues
	{
		/*[in]*/ IVsTextBuffer* pBuffer;
		/*[in]*/ long iLine;
		/*[in]*/ long iCol;
		/*[out]*/ GUID* pguidLanguageID;
		HRESULT retValue;
	};

	STDMETHOD(GetLanguageID)(
		/*[in]*/ IVsTextBuffer* pBuffer,
		/*[in]*/ long iLine,
		/*[in]*/ long iCol,
		/*[out]*/ GUID* pguidLanguageID)
	{
		VSL_DEFINE_MOCK_METHOD(GetLanguageID)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_CHECK_VALIDVALUE(iCol);

		VSL_SET_VALIDVALUE(pguidLanguageID);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsMappedLocationValidValues
	{
		/*[in]*/ IVsTextBuffer* pBuffer;
		/*[in]*/ long iLine;
		/*[in]*/ long iCol;
		HRESULT retValue;
	};

	STDMETHOD(IsMappedLocation)(
		/*[in]*/ IVsTextBuffer* pBuffer,
		/*[in]*/ long iLine,
		/*[in]*/ long iCol)
	{
		VSL_DEFINE_MOCK_METHOD(IsMappedLocation)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_CHECK_VALIDVALUE(iCol);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSLANGUAGEDEBUGINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsLanguageInfo.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSLANGUAGEINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSLANGUAGEINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsLanguageInfoNotImpl :
	public IVsLanguageInfo
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLanguageInfoNotImpl)

public:

	typedef IVsLanguageInfo Interface;

	STDMETHOD(GetLanguageName)(
		/*[out]*/ BSTR* /*bstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFileExtensions)(
		/*[out]*/ BSTR* /*pbstrExtensions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetColorizer)(
		/*[in]*/ IVsTextLines* /*pBuffer*/,
		/*[out]*/ IVsColorizer** /*ppColorizer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCodeWindowManager)(
		/*[in]*/ IVsCodeWindow* /*pCodeWin*/,
		/*[out]*/ IVsCodeWindowManager** /*ppCodeWinMgr*/)VSL_STDMETHOD_NOTIMPL
};

class IVsLanguageInfoMockImpl :
	public IVsLanguageInfo,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLanguageInfoMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsLanguageInfoMockImpl)

	typedef IVsLanguageInfo Interface;
	struct GetLanguageNameValidValues
	{
		/*[out]*/ BSTR* bstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetLanguageName)(
		/*[out]*/ BSTR* bstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetLanguageName)

		VSL_SET_VALIDVALUE_BSTR(bstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFileExtensionsValidValues
	{
		/*[out]*/ BSTR* pbstrExtensions;
		HRESULT retValue;
	};

	STDMETHOD(GetFileExtensions)(
		/*[out]*/ BSTR* pbstrExtensions)
	{
		VSL_DEFINE_MOCK_METHOD(GetFileExtensions)

		VSL_SET_VALIDVALUE_BSTR(pbstrExtensions);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetColorizerValidValues
	{
		/*[in]*/ IVsTextLines* pBuffer;
		/*[out]*/ IVsColorizer** ppColorizer;
		HRESULT retValue;
	};

	STDMETHOD(GetColorizer)(
		/*[in]*/ IVsTextLines* pBuffer,
		/*[out]*/ IVsColorizer** ppColorizer)
	{
		VSL_DEFINE_MOCK_METHOD(GetColorizer)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_SET_VALIDVALUE_INTERFACE(ppColorizer);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCodeWindowManagerValidValues
	{
		/*[in]*/ IVsCodeWindow* pCodeWin;
		/*[out]*/ IVsCodeWindowManager** ppCodeWinMgr;
		HRESULT retValue;
	};

	STDMETHOD(GetCodeWindowManager)(
		/*[in]*/ IVsCodeWindow* pCodeWin,
		/*[out]*/ IVsCodeWindowManager** ppCodeWinMgr)
	{
		VSL_DEFINE_MOCK_METHOD(GetCodeWindowManager)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCodeWin);

		VSL_SET_VALIDVALUE_INTERFACE(ppCodeWinMgr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSLANGUAGEINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsLanguageClipboardOpsEx.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSLANGUAGECLIPBOARDOPSEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSLANGUAGECLIPBOARDOPSEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsLanguageClipboardOpsExNotImpl :
	public IVsLanguageClipboardOpsEx
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLanguageClipboardOpsExNotImpl)

public:

	typedef IVsLanguageClipboardOpsEx Interface;

	STDMETHOD(IsTextDataEx)(
		/*[in]*/ IDataObject* /*pDO*/,
		/*[in]*/ IVsTextLines* /*pBuffer*/,
		/*[out]*/ BOOL* /*pfIsTextData*/)VSL_STDMETHOD_NOTIMPL
};

class IVsLanguageClipboardOpsExMockImpl :
	public IVsLanguageClipboardOpsEx,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLanguageClipboardOpsExMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsLanguageClipboardOpsExMockImpl)

	typedef IVsLanguageClipboardOpsEx Interface;
	struct IsTextDataExValidValues
	{
		/*[in]*/ IDataObject* pDO;
		/*[in]*/ IVsTextLines* pBuffer;
		/*[out]*/ BOOL* pfIsTextData;
		HRESULT retValue;
	};

	STDMETHOD(IsTextDataEx)(
		/*[in]*/ IDataObject* pDO,
		/*[in]*/ IVsTextLines* pBuffer,
		/*[out]*/ BOOL* pfIsTextData)
	{
		VSL_DEFINE_MOCK_METHOD(IsTextDataEx)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDO);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_SET_VALIDVALUE(pfIsTextData);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSLANGUAGECLIPBOARDOPSEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsLanguageDragDropOps.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSLANGUAGEDRAGDROPOPS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSLANGUAGEDRAGDROPOPS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsLanguageDragDropOpsNotImpl :
	public IVsLanguageDragDropOps
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLanguageDragDropOpsNotImpl)

public:

	typedef IVsLanguageDragDropOps Interface;

	STDMETHOD(DragSetup)(
		/*[in]*/ IDataObject* /*pDO*/,
		/*[in]*/ IVsTextLines* /*pBuffer*/,
		/*[out]*/ BOOL* /*pfDocumentContainsTextData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsTextDataAtLocation)(
		/*[in]*/ IVsTextLines* /*pBuffer*/,
		/*[in]*/ long /*iLine*/,
		/*[in]*/ long /*iCol*/,
		/*[out]*/ BOOL* /*pfIsTextDataValidAtLoc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DragCleanup)(
		/*[in]*/ IVsTextLines* /*pBuffer*/)VSL_STDMETHOD_NOTIMPL
};

class IVsLanguageDragDropOpsMockImpl :
	public IVsLanguageDragDropOps,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLanguageDragDropOpsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsLanguageDragDropOpsMockImpl)

	typedef IVsLanguageDragDropOps Interface;
	struct DragSetupValidValues
	{
		/*[in]*/ IDataObject* pDO;
		/*[in]*/ IVsTextLines* pBuffer;
		/*[out]*/ BOOL* pfDocumentContainsTextData;
		HRESULT retValue;
	};

	STDMETHOD(DragSetup)(
		/*[in]*/ IDataObject* pDO,
		/*[in]*/ IVsTextLines* pBuffer,
		/*[out]*/ BOOL* pfDocumentContainsTextData)
	{
		VSL_DEFINE_MOCK_METHOD(DragSetup)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDO);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_SET_VALIDVALUE(pfDocumentContainsTextData);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsTextDataAtLocationValidValues
	{
		/*[in]*/ IVsTextLines* pBuffer;
		/*[in]*/ long iLine;
		/*[in]*/ long iCol;
		/*[out]*/ BOOL* pfIsTextDataValidAtLoc;
		HRESULT retValue;
	};

	STDMETHOD(IsTextDataAtLocation)(
		/*[in]*/ IVsTextLines* pBuffer,
		/*[in]*/ long iLine,
		/*[in]*/ long iCol,
		/*[out]*/ BOOL* pfIsTextDataValidAtLoc)
	{
		VSL_DEFINE_MOCK_METHOD(IsTextDataAtLocation)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_CHECK_VALIDVALUE(iCol);

		VSL_SET_VALIDVALUE(pfIsTextDataValidAtLoc);

		VSL_RETURN_VALIDVALUES();
	}
	struct DragCleanupValidValues
	{
		/*[in]*/ IVsTextLines* pBuffer;
		HRESULT retValue;
	};

	STDMETHOD(DragCleanup)(
		/*[in]*/ IVsTextLines* pBuffer)
	{
		VSL_DEFINE_MOCK_METHOD(DragCleanup)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSLANGUAGEDRAGDROPOPS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsLanguageInfoPackage.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSLANGUAGEINFOPACKAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSLANGUAGEINFOPACKAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsLanguageInfoPackageNotImpl :
	public IVsLanguageInfoPackage
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLanguageInfoPackageNotImpl)

public:

	typedef IVsLanguageInfoPackage Interface;

	STDMETHOD(GetLanguagePropertyPage)(
		/*[in]*/ REFGUID /*rguidPage*/,
		/*[in]*/ REFGUID /*guidLang*/,
		/*[in,out]*/ VSPROPSHEETPAGE* /*ppage*/)VSL_STDMETHOD_NOTIMPL
};

class IVsLanguageInfoPackageMockImpl :
	public IVsLanguageInfoPackage,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLanguageInfoPackageMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsLanguageInfoPackageMockImpl)

	typedef IVsLanguageInfoPackage Interface;
	struct GetLanguagePropertyPageValidValues
	{
		/*[in]*/ REFGUID rguidPage;
		/*[in]*/ REFGUID guidLang;
		/*[in,out]*/ VSPROPSHEETPAGE* ppage;
		HRESULT retValue;
	};

	STDMETHOD(GetLanguagePropertyPage)(
		/*[in]*/ REFGUID rguidPage,
		/*[in]*/ REFGUID guidLang,
		/*[in,out]*/ VSPROPSHEETPAGE* ppage)
	{
		VSL_DEFINE_MOCK_METHOD(GetLanguagePropertyPage)

		VSL_CHECK_VALIDVALUE(rguidPage);

		VSL_CHECK_VALIDVALUE(guidLang);

		VSL_SET_VALIDVALUE(ppage);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSLANGUAGEINFOPACKAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsLanguageLineIndent.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSLANGUAGELINEINDENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSLANGUAGELINEINDENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsLanguageLineIndentNotImpl :
	public IVsLanguageLineIndent
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLanguageLineIndentNotImpl)

public:

	typedef IVsLanguageLineIndent Interface;

	STDMETHOD(GetIndentPosition)(
		/*[in]*/ IVsTextLayer* /*pBaseLayer*/,
		/*[in]*/ long /*BaseBufferLineIndex*/,
		/*[out]*/ long* /*pIndentPosition*/)VSL_STDMETHOD_NOTIMPL
};

class IVsLanguageLineIndentMockImpl :
	public IVsLanguageLineIndent,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLanguageLineIndentMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsLanguageLineIndentMockImpl)

	typedef IVsLanguageLineIndent Interface;
	struct GetIndentPositionValidValues
	{
		/*[in]*/ IVsTextLayer* pBaseLayer;
		/*[in]*/ long BaseBufferLineIndex;
		/*[out]*/ long* pIndentPosition;
		HRESULT retValue;
	};

	STDMETHOD(GetIndentPosition)(
		/*[in]*/ IVsTextLayer* pBaseLayer,
		/*[in]*/ long BaseBufferLineIndex,
		/*[out]*/ long* pIndentPosition)
	{
		VSL_DEFINE_MOCK_METHOD(GetIndentPosition)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBaseLayer);

		VSL_CHECK_VALIDVALUE(BaseBufferLineIndex);

		VSL_SET_VALIDVALUE(pIndentPosition);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSLANGUAGELINEINDENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsLayeredTextView.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSLAYEREDTEXTVIEW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSLAYEREDTEXTVIEW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsLayeredTextViewNotImpl :
	public IVsLayeredTextView
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLayeredTextViewNotImpl)

public:

	typedef IVsLayeredTextView Interface;

	STDMETHOD(GetSelectedAtom)(
		/*[in]*/ DWORD /*dwFlags*/,
		/*[out]*/ IUnknown** /*ppunkAtom*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetRelativeSelectionState)(
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in]*/ IVsTextLayer* /*pReferenceLayer*/,
		/*[out]*/ SELECTIONSTATE* /*pSelState*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetRelativeSelectionState)(
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in]*/ IVsTextLayer* /*pReferenceLayer*/,
		/*[in]*/ SELECTIONSTATE* /*pSelState*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTopmostLayer)(
		/*[out]*/ IVsTextLayer** /*ppLayer*/)VSL_STDMETHOD_NOTIMPL
};

class IVsLayeredTextViewMockImpl :
	public IVsLayeredTextView,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLayeredTextViewMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsLayeredTextViewMockImpl)

	typedef IVsLayeredTextView Interface;
	struct GetSelectedAtomValidValues
	{
		/*[in]*/ DWORD dwFlags;
		/*[out]*/ IUnknown** ppunkAtom;
		HRESULT retValue;
	};

	STDMETHOD(GetSelectedAtom)(
		/*[in]*/ DWORD dwFlags,
		/*[out]*/ IUnknown** ppunkAtom)
	{
		VSL_DEFINE_MOCK_METHOD(GetSelectedAtom)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_SET_VALIDVALUE_INTERFACE(ppunkAtom);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetRelativeSelectionStateValidValues
	{
		/*[in]*/ DWORD dwFlags;
		/*[in]*/ IVsTextLayer* pReferenceLayer;
		/*[out]*/ SELECTIONSTATE* pSelState;
		HRESULT retValue;
	};

	STDMETHOD(GetRelativeSelectionState)(
		/*[in]*/ DWORD dwFlags,
		/*[in]*/ IVsTextLayer* pReferenceLayer,
		/*[out]*/ SELECTIONSTATE* pSelState)
	{
		VSL_DEFINE_MOCK_METHOD(GetRelativeSelectionState)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pReferenceLayer);

		VSL_SET_VALIDVALUE(pSelState);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetRelativeSelectionStateValidValues
	{
		/*[in]*/ DWORD dwFlags;
		/*[in]*/ IVsTextLayer* pReferenceLayer;
		/*[in]*/ SELECTIONSTATE* pSelState;
		HRESULT retValue;
	};

	STDMETHOD(SetRelativeSelectionState)(
		/*[in]*/ DWORD dwFlags,
		/*[in]*/ IVsTextLayer* pReferenceLayer,
		/*[in]*/ SELECTIONSTATE* pSelState)
	{
		VSL_DEFINE_MOCK_METHOD(SetRelativeSelectionState)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pReferenceLayer);

		VSL_CHECK_VALIDVALUE_POINTER(pSelState);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTopmostLayerValidValues
	{
		/*[out]*/ IVsTextLayer** ppLayer;
		HRESULT retValue;
	};

	STDMETHOD(GetTopmostLayer)(
		/*[out]*/ IVsTextLayer** ppLayer)
	{
		VSL_DEFINE_MOCK_METHOD(GetTopmostLayer)

		VSL_SET_VALIDVALUE_INTERFACE(ppLayer);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSLAYEREDTEXTVIEW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsLastChangeTimeProvider.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSLASTCHANGETIMEPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSLASTCHANGETIMEPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsLastChangeTimeProviderNotImpl :
	public IVsLastChangeTimeProvider
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLastChangeTimeProviderNotImpl)

public:

	typedef IVsLastChangeTimeProvider Interface;

	STDMETHOD(GetLastChangeTime)(
		/*[out]*/ FILETIME* /*pFileTime*/)VSL_STDMETHOD_NOTIMPL
};

class IVsLastChangeTimeProviderMockImpl :
	public IVsLastChangeTimeProvider,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLastChangeTimeProviderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsLastChangeTimeProviderMockImpl)

	typedef IVsLastChangeTimeProvider Interface;
	struct GetLastChangeTimeValidValues
	{
		/*[out]*/ FILETIME* pFileTime;
		HRESULT retValue;
	};

	STDMETHOD(GetLastChangeTime)(
		/*[out]*/ FILETIME* pFileTime)
	{
		VSL_DEFINE_MOCK_METHOD(GetLastChangeTime)

		VSL_SET_VALIDVALUE(pFileTime);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSLASTCHANGETIMEPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsLaunchPad.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSLAUNCHPAD_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSLAUNCHPAD_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsLaunchPadNotImpl :
	public IVsLaunchPad
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLaunchPadNotImpl)

public:

	typedef IVsLaunchPad Interface;

	STDMETHOD(ExecCommand)(
		/*[in]*/ LPCOLESTR /*pszApplicationName*/,
		/*[in]*/ LPCOLESTR /*pszCommandLine*/,
		/*[in]*/ LPCOLESTR /*pszWorkingDir*/,
		/*[in]*/ LAUNCHPAD_FLAGS /*lpf*/,
		/*[in]*/ IVsOutputWindowPane* /*pOutputWindowPane*/,
		/*[in]*/ ULONG /*nTaskItemCategory*/,
		/*[in]*/ ULONG /*nTaskItemBitmap*/,
		/*[in]*/ LPCOLESTR /*pszTaskListSubcategory*/,
		/*[in]*/ IVsLaunchPadEvents* /*pVsLaunchPadEvents*/,
		/*[out]*/ DWORD* /*pdwProcessExitCode*/,
		/*[out]*/ BSTR* /*pbstrOutput*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ExecBatchScript)(
		/*[in]*/ LPCOLESTR /*pszBatchFileContents*/,
		/*[in]*/ LPCOLESTR /*pszWorkingDir*/,
		/*[in]*/ LAUNCHPAD_FLAGS /*lpf*/,
		/*[in]*/ IVsOutputWindowPane* /*pOutputWindowPane*/,
		/*[in]*/ ULONG /*nTaskItemCategory*/,
		/*[in]*/ ULONG /*nTaskItemBitmap*/,
		/*[in]*/ LPCOLESTR /*pszTaskListSubcategory*/,
		/*[in]*/ IVsLaunchPadEvents* /*pVsLaunchPadEvents*/,
		/*[out]*/ BSTR* /*pbstrOutput*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ParseOutputStringForTaskItem)(
		/*[in]*/ LPCOLESTR /*pszOutputString*/,
		/*[out]*/ ULONG* /*pnPriority*/,
		/*[out]*/ BSTR* /*pbstrFilename*/,
		/*[out]*/ ULONG* /*pnLineNum*/,
		/*[out]*/ BSTR* /*pbstrTaskItemText*/,
		/*[out]*/ BOOL* /*pfTaskItemFound*/)VSL_STDMETHOD_NOTIMPL
};

class IVsLaunchPadMockImpl :
	public IVsLaunchPad,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLaunchPadMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsLaunchPadMockImpl)

	typedef IVsLaunchPad Interface;
	struct ExecCommandValidValues
	{
		/*[in]*/ LPCOLESTR pszApplicationName;
		/*[in]*/ LPCOLESTR pszCommandLine;
		/*[in]*/ LPCOLESTR pszWorkingDir;
		/*[in]*/ LAUNCHPAD_FLAGS lpf;
		/*[in]*/ IVsOutputWindowPane* pOutputWindowPane;
		/*[in]*/ ULONG nTaskItemCategory;
		/*[in]*/ ULONG nTaskItemBitmap;
		/*[in]*/ LPCOLESTR pszTaskListSubcategory;
		/*[in]*/ IVsLaunchPadEvents* pVsLaunchPadEvents;
		/*[out]*/ DWORD* pdwProcessExitCode;
		/*[out]*/ BSTR* pbstrOutput;
		HRESULT retValue;
	};

	STDMETHOD(ExecCommand)(
		/*[in]*/ LPCOLESTR pszApplicationName,
		/*[in]*/ LPCOLESTR pszCommandLine,
		/*[in]*/ LPCOLESTR pszWorkingDir,
		/*[in]*/ LAUNCHPAD_FLAGS lpf,
		/*[in]*/ IVsOutputWindowPane* pOutputWindowPane,
		/*[in]*/ ULONG nTaskItemCategory,
		/*[in]*/ ULONG nTaskItemBitmap,
		/*[in]*/ LPCOLESTR pszTaskListSubcategory,
		/*[in]*/ IVsLaunchPadEvents* pVsLaunchPadEvents,
		/*[out]*/ DWORD* pdwProcessExitCode,
		/*[out]*/ BSTR* pbstrOutput)
	{
		VSL_DEFINE_MOCK_METHOD(ExecCommand)

		VSL_CHECK_VALIDVALUE_STRINGW(pszApplicationName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszCommandLine);

		VSL_CHECK_VALIDVALUE_STRINGW(pszWorkingDir);

		VSL_CHECK_VALIDVALUE(lpf);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pOutputWindowPane);

		VSL_CHECK_VALIDVALUE(nTaskItemCategory);

		VSL_CHECK_VALIDVALUE(nTaskItemBitmap);

		VSL_CHECK_VALIDVALUE_STRINGW(pszTaskListSubcategory);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pVsLaunchPadEvents);

		VSL_SET_VALIDVALUE(pdwProcessExitCode);

		VSL_SET_VALIDVALUE_BSTR(pbstrOutput);

		VSL_RETURN_VALIDVALUES();
	}
	struct ExecBatchScriptValidValues
	{
		/*[in]*/ LPCOLESTR pszBatchFileContents;
		/*[in]*/ LPCOLESTR pszWorkingDir;
		/*[in]*/ LAUNCHPAD_FLAGS lpf;
		/*[in]*/ IVsOutputWindowPane* pOutputWindowPane;
		/*[in]*/ ULONG nTaskItemCategory;
		/*[in]*/ ULONG nTaskItemBitmap;
		/*[in]*/ LPCOLESTR pszTaskListSubcategory;
		/*[in]*/ IVsLaunchPadEvents* pVsLaunchPadEvents;
		/*[out]*/ BSTR* pbstrOutput;
		HRESULT retValue;
	};

	STDMETHOD(ExecBatchScript)(
		/*[in]*/ LPCOLESTR pszBatchFileContents,
		/*[in]*/ LPCOLESTR pszWorkingDir,
		/*[in]*/ LAUNCHPAD_FLAGS lpf,
		/*[in]*/ IVsOutputWindowPane* pOutputWindowPane,
		/*[in]*/ ULONG nTaskItemCategory,
		/*[in]*/ ULONG nTaskItemBitmap,
		/*[in]*/ LPCOLESTR pszTaskListSubcategory,
		/*[in]*/ IVsLaunchPadEvents* pVsLaunchPadEvents,
		/*[out]*/ BSTR* pbstrOutput)
	{
		VSL_DEFINE_MOCK_METHOD(ExecBatchScript)

		VSL_CHECK_VALIDVALUE_STRINGW(pszBatchFileContents);

		VSL_CHECK_VALIDVALUE_STRINGW(pszWorkingDir);

		VSL_CHECK_VALIDVALUE(lpf);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pOutputWindowPane);

		VSL_CHECK_VALIDVALUE(nTaskItemCategory);

		VSL_CHECK_VALIDVALUE(nTaskItemBitmap);

		VSL_CHECK_VALIDVALUE_STRINGW(pszTaskListSubcategory);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pVsLaunchPadEvents);

		VSL_SET_VALIDVALUE_BSTR(pbstrOutput);

		VSL_RETURN_VALIDVALUES();
	}
	struct ParseOutputStringForTaskItemValidValues
	{
		/*[in]*/ LPCOLESTR pszOutputString;
		/*[out]*/ ULONG* pnPriority;
		/*[out]*/ BSTR* pbstrFilename;
		/*[out]*/ ULONG* pnLineNum;
		/*[out]*/ BSTR* pbstrTaskItemText;
		/*[out]*/ BOOL* pfTaskItemFound;
		HRESULT retValue;
	};

	STDMETHOD(ParseOutputStringForTaskItem)(
		/*[in]*/ LPCOLESTR pszOutputString,
		/*[out]*/ ULONG* pnPriority,
		/*[out]*/ BSTR* pbstrFilename,
		/*[out]*/ ULONG* pnLineNum,
		/*[out]*/ BSTR* pbstrTaskItemText,
		/*[out]*/ BOOL* pfTaskItemFound)
	{
		VSL_DEFINE_MOCK_METHOD(ParseOutputStringForTaskItem)

		VSL_CHECK_VALIDVALUE_STRINGW(pszOutputString);

		VSL_SET_VALIDVALUE(pnPriority);

		VSL_SET_VALIDVALUE_BSTR(pbstrFilename);

		VSL_SET_VALIDVALUE(pnLineNum);

		VSL_SET_VALIDVALUE_BSTR(pbstrTaskItemText);

		VSL_SET_VALIDVALUE(pfTaskItemFound);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSLAUNCHPAD_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsLaunchPadEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSLAUNCHPADEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSLAUNCHPADEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsLaunchPadEventsNotImpl :
	public IVsLaunchPadEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLaunchPadEventsNotImpl)

public:

	typedef IVsLaunchPadEvents Interface;

	STDMETHOD(Tick)(
		/*[in,out]*/ BOOL* /*pfCancel*/)VSL_STDMETHOD_NOTIMPL
};

class IVsLaunchPadEventsMockImpl :
	public IVsLaunchPadEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLaunchPadEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsLaunchPadEventsMockImpl)

	typedef IVsLaunchPadEvents Interface;
	struct TickValidValues
	{
		/*[in,out]*/ BOOL* pfCancel;
		HRESULT retValue;
	};

	STDMETHOD(Tick)(
		/*[in,out]*/ BOOL* pfCancel)
	{
		VSL_DEFINE_MOCK_METHOD(Tick)

		VSL_SET_VALIDVALUE(pfCancel);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSLAUNCHPADEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsLanguageTextOps.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSLANGUAGETEXTOPS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSLANGUAGETEXTOPS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsLanguageTextOpsNotImpl :
	public IVsLanguageTextOps
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLanguageTextOpsNotImpl)

public:

	typedef IVsLanguageTextOps Interface;

	STDMETHOD(GetDataTip)(
		/*[in]*/ IVsTextLayer* /*pTextLayer*/,
		/*[in]*/ const TextSpan* /*ptsSel*/,
		/*[out]*/ TextSpan* /*ptsTip*/,
		/*[out,retval]*/ BSTR* /*pbstrText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPairExtent)(
		/*[in]*/ IVsTextLayer* /*pTextLayer*/,
		/*[in]*/ TextAddress /*ta*/,
		/*[out,retval]*/ TextSpan* /*pts*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetWordExtent)(
		/*[in]*/ IVsTextLayer* /*pTextLayer*/,
		/*[in]*/ TextAddress /*ta*/,
		/*[in]*/ WORDEXTFLAGS /*flags*/,
		/*[out,retval]*/ TextSpan* /*pts*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Format)(
		/*[in]*/ IVsTextLayer* /*pTextLayer*/,
		/*[in]*/ const TextSpan* /*ptsSel*/)VSL_STDMETHOD_NOTIMPL
};

class IVsLanguageTextOpsMockImpl :
	public IVsLanguageTextOps,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLanguageTextOpsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsLanguageTextOpsMockImpl)

	typedef IVsLanguageTextOps Interface;
	struct GetDataTipValidValues
	{
		/*[in]*/ IVsTextLayer* pTextLayer;
		/*[in]*/ TextSpan* ptsSel;
		/*[out]*/ TextSpan* ptsTip;
		/*[out,retval]*/ BSTR* pbstrText;
		HRESULT retValue;
	};

	STDMETHOD(GetDataTip)(
		/*[in]*/ IVsTextLayer* pTextLayer,
		/*[in]*/ const TextSpan* ptsSel,
		/*[out]*/ TextSpan* ptsTip,
		/*[out,retval]*/ BSTR* pbstrText)
	{
		VSL_DEFINE_MOCK_METHOD(GetDataTip)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pTextLayer);

		VSL_CHECK_VALIDVALUE_POINTER(ptsSel);

		VSL_SET_VALIDVALUE(ptsTip);

		VSL_SET_VALIDVALUE_BSTR(pbstrText);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPairExtentValidValues
	{
		/*[in]*/ IVsTextLayer* pTextLayer;
		/*[in]*/ TextAddress ta;
		/*[out,retval]*/ TextSpan* pts;
		HRESULT retValue;
	};

	STDMETHOD(GetPairExtent)(
		/*[in]*/ IVsTextLayer* pTextLayer,
		/*[in]*/ TextAddress ta,
		/*[out,retval]*/ TextSpan* pts)
	{
		VSL_DEFINE_MOCK_METHOD(GetPairExtent)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pTextLayer);

		VSL_CHECK_VALIDVALUE(ta);

		VSL_SET_VALIDVALUE(pts);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetWordExtentValidValues
	{
		/*[in]*/ IVsTextLayer* pTextLayer;
		/*[in]*/ TextAddress ta;
		/*[in]*/ WORDEXTFLAGS flags;
		/*[out,retval]*/ TextSpan* pts;
		HRESULT retValue;
	};

	STDMETHOD(GetWordExtent)(
		/*[in]*/ IVsTextLayer* pTextLayer,
		/*[in]*/ TextAddress ta,
		/*[in]*/ WORDEXTFLAGS flags,
		/*[out,retval]*/ TextSpan* pts)
	{
		VSL_DEFINE_MOCK_METHOD(GetWordExtent)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pTextLayer);

		VSL_CHECK_VALIDVALUE(ta);

		VSL_CHECK_VALIDVALUE(flags);

		VSL_SET_VALIDVALUE(pts);

		VSL_RETURN_VALIDVALUES();
	}
	struct FormatValidValues
	{
		/*[in]*/ IVsTextLayer* pTextLayer;
		/*[in]*/ TextSpan* ptsSel;
		HRESULT retValue;
	};

	STDMETHOD(Format)(
		/*[in]*/ IVsTextLayer* pTextLayer,
		/*[in]*/ const TextSpan* ptsSel)
	{
		VSL_DEFINE_MOCK_METHOD(Format)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pTextLayer);

		VSL_CHECK_VALIDVALUE_POINTER(ptsSel);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSLANGUAGETEXTOPS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsLaunchPad2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSLAUNCHPAD2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSLAUNCHPAD2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsLaunchPad2NotImpl :
	public IVsLaunchPad2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLaunchPad2NotImpl)

public:

	typedef IVsLaunchPad2 Interface;

	STDMETHOD(ExecCommandEx)(
		/*[in]*/ LPCOLESTR /*pszApplicationName*/,
		/*[in]*/ LPCOLESTR /*pszCommandLine*/,
		/*[in]*/ LPCOLESTR /*pszWorkingDir*/,
		/*[in]*/ LAUNCHPAD_FLAGS2 /*lpf*/,
		/*[in]*/ IVsOutputWindowPane* /*pOutputWindowPane*/,
		/*[in]*/ ULONG /*nTaskItemCategory*/,
		/*[in]*/ ULONG /*nTaskItemBitmap*/,
		/*[in]*/ LPCOLESTR /*pszTaskListSubcategory*/,
		/*[in]*/ IVsLaunchPadEvents* /*pVsLaunchPadEvents*/,
		/*[in]*/ IVsLaunchPadOutputParser* /*pOutputParser*/,
		/*[out,optional]*/ DWORD* /*pdwProcessExitCode*/,
		/*[out,optional]*/ BSTR* /*pbstrOutput*/)VSL_STDMETHOD_NOTIMPL
};

class IVsLaunchPad2MockImpl :
	public IVsLaunchPad2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLaunchPad2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsLaunchPad2MockImpl)

	typedef IVsLaunchPad2 Interface;
	struct ExecCommandExValidValues
	{
		/*[in]*/ LPCOLESTR pszApplicationName;
		/*[in]*/ LPCOLESTR pszCommandLine;
		/*[in]*/ LPCOLESTR pszWorkingDir;
		/*[in]*/ LAUNCHPAD_FLAGS2 lpf;
		/*[in]*/ IVsOutputWindowPane* pOutputWindowPane;
		/*[in]*/ ULONG nTaskItemCategory;
		/*[in]*/ ULONG nTaskItemBitmap;
		/*[in]*/ LPCOLESTR pszTaskListSubcategory;
		/*[in]*/ IVsLaunchPadEvents* pVsLaunchPadEvents;
		/*[in]*/ IVsLaunchPadOutputParser* pOutputParser;
		/*[out,optional]*/ DWORD* pdwProcessExitCode;
		/*[out,optional]*/ BSTR* pbstrOutput;
		HRESULT retValue;
	};

	STDMETHOD(ExecCommandEx)(
		/*[in]*/ LPCOLESTR pszApplicationName,
		/*[in]*/ LPCOLESTR pszCommandLine,
		/*[in]*/ LPCOLESTR pszWorkingDir,
		/*[in]*/ LAUNCHPAD_FLAGS2 lpf,
		/*[in]*/ IVsOutputWindowPane* pOutputWindowPane,
		/*[in]*/ ULONG nTaskItemCategory,
		/*[in]*/ ULONG nTaskItemBitmap,
		/*[in]*/ LPCOLESTR pszTaskListSubcategory,
		/*[in]*/ IVsLaunchPadEvents* pVsLaunchPadEvents,
		/*[in]*/ IVsLaunchPadOutputParser* pOutputParser,
		/*[out,optional]*/ DWORD* pdwProcessExitCode,
		/*[out,optional]*/ BSTR* pbstrOutput)
	{
		VSL_DEFINE_MOCK_METHOD(ExecCommandEx)

		VSL_CHECK_VALIDVALUE_STRINGW(pszApplicationName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszCommandLine);

		VSL_CHECK_VALIDVALUE_STRINGW(pszWorkingDir);

		VSL_CHECK_VALIDVALUE(lpf);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pOutputWindowPane);

		VSL_CHECK_VALIDVALUE(nTaskItemCategory);

		VSL_CHECK_VALIDVALUE(nTaskItemBitmap);

		VSL_CHECK_VALIDVALUE_STRINGW(pszTaskListSubcategory);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pVsLaunchPadEvents);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pOutputParser);

		VSL_SET_VALIDVALUE(pdwProcessExitCode);

		VSL_SET_VALIDVALUE_BSTR(pbstrOutput);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSLAUNCHPAD2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsLaunchPadFactory.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSLAUNCHPADFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSLAUNCHPADFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsLaunchPadFactoryNotImpl :
	public IVsLaunchPadFactory
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLaunchPadFactoryNotImpl)

public:

	typedef IVsLaunchPadFactory Interface;

	STDMETHOD(CreateLaunchPad)(
		/*[out]*/ IVsLaunchPad** /*ppLaunchPad*/)VSL_STDMETHOD_NOTIMPL
};

class IVsLaunchPadFactoryMockImpl :
	public IVsLaunchPadFactory,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLaunchPadFactoryMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsLaunchPadFactoryMockImpl)

	typedef IVsLaunchPadFactory Interface;
	struct CreateLaunchPadValidValues
	{
		/*[out]*/ IVsLaunchPad** ppLaunchPad;
		HRESULT retValue;
	};

	STDMETHOD(CreateLaunchPad)(
		/*[out]*/ IVsLaunchPad** ppLaunchPad)
	{
		VSL_DEFINE_MOCK_METHOD(CreateLaunchPad)

		VSL_SET_VALIDVALUE_INTERFACE(ppLaunchPad);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSLAUNCHPADFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsLaunchPadOutputParser.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSLAUNCHPADOUTPUTPARSER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSLAUNCHPADOUTPUTPARSER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsLaunchPadOutputParserNotImpl :
	public IVsLaunchPadOutputParser
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLaunchPadOutputParserNotImpl)

public:

	typedef IVsLaunchPadOutputParser Interface;

	STDMETHOD(ParseOutputStringForInfo)(
		/*[in]*/ LPCOLESTR /*pszOutputString*/,
		/*[out,optional]*/ BSTR* /*pbstrFilename*/,
		/*[out,optional]*/ ULONG* /*pnLineNum*/,
		/*[out,optional]*/ ULONG* /*pnPriority*/,
		/*[out,optional]*/ BSTR* /*pbstrTaskItemText*/,
		/*[out,optional]*/ BSTR* /*pbstrHelpKeyword*/)VSL_STDMETHOD_NOTIMPL
};

class IVsLaunchPadOutputParserMockImpl :
	public IVsLaunchPadOutputParser,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLaunchPadOutputParserMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsLaunchPadOutputParserMockImpl)

	typedef IVsLaunchPadOutputParser Interface;
	struct ParseOutputStringForInfoValidValues
	{
		/*[in]*/ LPCOLESTR pszOutputString;
		/*[out,optional]*/ BSTR* pbstrFilename;
		/*[out,optional]*/ ULONG* pnLineNum;
		/*[out,optional]*/ ULONG* pnPriority;
		/*[out,optional]*/ BSTR* pbstrTaskItemText;
		/*[out,optional]*/ BSTR* pbstrHelpKeyword;
		HRESULT retValue;
	};

	STDMETHOD(ParseOutputStringForInfo)(
		/*[in]*/ LPCOLESTR pszOutputString,
		/*[out,optional]*/ BSTR* pbstrFilename,
		/*[out,optional]*/ ULONG* pnLineNum,
		/*[out,optional]*/ ULONG* pnPriority,
		/*[out,optional]*/ BSTR* pbstrTaskItemText,
		/*[out,optional]*/ BSTR* pbstrHelpKeyword)
	{
		VSL_DEFINE_MOCK_METHOD(ParseOutputStringForInfo)

		VSL_CHECK_VALIDVALUE_STRINGW(pszOutputString);

		VSL_SET_VALIDVALUE_BSTR(pbstrFilename);

		VSL_SET_VALIDVALUE(pnLineNum);

		VSL_SET_VALIDVALUE(pnPriority);

		VSL_SET_VALIDVALUE_BSTR(pbstrTaskItemText);

		VSL_SET_VALIDVALUE_BSTR(pbstrHelpKeyword);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSLAUNCHPADOUTPUTPARSER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsLineAttributes.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSLINEATTRIBUTES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSLINEATTRIBUTES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsLineAttributesNotImpl :
	public IVsLineAttributes
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLineAttributesNotImpl)

public:

	typedef IVsLineAttributes Interface;

	STDMETHOD(SetLineSeparator)(
		/*[in]*/ long* /*rgLines*/,
		/*[in]*/ long /*cLines*/,
		/*[in]*/ BOOL /*fRemoveAll*/)VSL_STDMETHOD_NOTIMPL
};

class IVsLineAttributesMockImpl :
	public IVsLineAttributes,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLineAttributesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsLineAttributesMockImpl)

	typedef IVsLineAttributes Interface;
	struct SetLineSeparatorValidValues
	{
		/*[in]*/ long* rgLines;
		/*[in]*/ long cLines;
		/*[in]*/ BOOL fRemoveAll;
		HRESULT retValue;
	};

	STDMETHOD(SetLineSeparator)(
		/*[in]*/ long* rgLines,
		/*[in]*/ long cLines,
		/*[in]*/ BOOL fRemoveAll)
	{
		VSL_DEFINE_MOCK_METHOD(SetLineSeparator)

		VSL_CHECK_VALIDVALUE_POINTER(rgLines);

		VSL_CHECK_VALIDVALUE(cLines);

		VSL_CHECK_VALIDVALUE(fRemoveAll);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSLINEATTRIBUTES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsLibrary.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSLIBRARY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSLIBRARY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsLibraryNotImpl :
	public IVsLibrary
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLibraryNotImpl)

public:

	typedef IVsLibrary Interface;

	STDMETHOD(GetSupportedCategoryFields)(
		/*[in]*/ LIB_CATEGORY /*Category*/,
		/*[out,retval]*/ DWORD* /*pCatField*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetList)(
		/*[in]*/ LIB_LISTTYPE /*ListType*/,
		/*[in]*/ LIB_LISTFLAGS /*Flags*/,
		/*[in]*/ VSOBSEARCHCRITERIA* /*pobSrch*/,
		/*[out,retval]*/ IVsObjectList** /*ppList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLibList)(
		/*[in]*/ LIB_PERSISTTYPE /*lptType*/,
		/*[out,retval]*/ IVsLiteTreeList** /*ppList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLibFlags)(
		/*[out,retval]*/ LIB_FLAGS* /*pfFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateCounter)(
		/*[out]*/ ULONG* /*pCurUpdate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetGuid)(
		/*[in]*/ const GUID** /*ppguidLib*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSeparatorString)(
		/*[in]*/ LPCWSTR* /*pszSeparator*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LoadState)(
		/*[in]*/ IStream* /*pIStream*/,
		/*[in]*/ LIB_PERSISTTYPE /*lptType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SaveState)(
		/*[in]*/ IStream* /*pIStream*/,
		/*[in]*/ LIB_PERSISTTYPE /*lptType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBrowseContainersForHierarchy)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ ULONG /*celt*/,
		/*[in,out,size_is(celt)]*/ VSBROWSECONTAINER[] /*rgBrowseContainers*/,
		/*[out,optional]*/ ULONG* /*pcActual*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddBrowseContainer)(
		/*[in]*/ PVSCOMPONENTSELECTORDATA /*pcdComponent*/,
		/*[in,out]*/ LIB_ADDREMOVEOPTIONS* /*pgrfOptions*/,
		/*[out]*/ BSTR* /*pbstrComponentAdded*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveBrowseContainer)(
		/*[in]*/ DWORD /*dwReserved*/,
		/*[in]*/ LPCWSTR /*pszLibName*/)VSL_STDMETHOD_NOTIMPL
};

class IVsLibraryMockImpl :
	public IVsLibrary,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLibraryMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsLibraryMockImpl)

	typedef IVsLibrary Interface;
	struct GetSupportedCategoryFieldsValidValues
	{
		/*[in]*/ LIB_CATEGORY Category;
		/*[out,retval]*/ DWORD* pCatField;
		HRESULT retValue;
	};

	STDMETHOD(GetSupportedCategoryFields)(
		/*[in]*/ LIB_CATEGORY Category,
		/*[out,retval]*/ DWORD* pCatField)
	{
		VSL_DEFINE_MOCK_METHOD(GetSupportedCategoryFields)

		VSL_CHECK_VALIDVALUE(Category);

		VSL_SET_VALIDVALUE(pCatField);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetListValidValues
	{
		/*[in]*/ LIB_LISTTYPE ListType;
		/*[in]*/ LIB_LISTFLAGS Flags;
		/*[in]*/ VSOBSEARCHCRITERIA* pobSrch;
		/*[out,retval]*/ IVsObjectList** ppList;
		HRESULT retValue;
	};

	STDMETHOD(GetList)(
		/*[in]*/ LIB_LISTTYPE ListType,
		/*[in]*/ LIB_LISTFLAGS Flags,
		/*[in]*/ VSOBSEARCHCRITERIA* pobSrch,
		/*[out,retval]*/ IVsObjectList** ppList)
	{
		VSL_DEFINE_MOCK_METHOD(GetList)

		VSL_CHECK_VALIDVALUE(ListType);

		VSL_CHECK_VALIDVALUE(Flags);

		VSL_CHECK_VALIDVALUE_POINTER(pobSrch);

		VSL_SET_VALIDVALUE_INTERFACE(ppList);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLibListValidValues
	{
		/*[in]*/ LIB_PERSISTTYPE lptType;
		/*[out,retval]*/ IVsLiteTreeList** ppList;
		HRESULT retValue;
	};

	STDMETHOD(GetLibList)(
		/*[in]*/ LIB_PERSISTTYPE lptType,
		/*[out,retval]*/ IVsLiteTreeList** ppList)
	{
		VSL_DEFINE_MOCK_METHOD(GetLibList)

		VSL_CHECK_VALIDVALUE(lptType);

		VSL_SET_VALIDVALUE_INTERFACE(ppList);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLibFlagsValidValues
	{
		/*[out,retval]*/ LIB_FLAGS* pfFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetLibFlags)(
		/*[out,retval]*/ LIB_FLAGS* pfFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetLibFlags)

		VSL_SET_VALIDVALUE(pfFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateCounterValidValues
	{
		/*[out]*/ ULONG* pCurUpdate;
		HRESULT retValue;
	};

	STDMETHOD(UpdateCounter)(
		/*[out]*/ ULONG* pCurUpdate)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateCounter)

		VSL_SET_VALIDVALUE(pCurUpdate);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetGuidValidValues
	{
		/*[in]*/ GUID** ppguidLib;
		HRESULT retValue;
	};

	STDMETHOD(GetGuid)(
		/*[in]*/ const GUID** ppguidLib)
	{
		VSL_DEFINE_MOCK_METHOD(GetGuid)

		VSL_CHECK_VALIDVALUE_POINTER(ppguidLib);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSeparatorStringValidValues
	{
		/*[in]*/ LPCWSTR* pszSeparator;
		HRESULT retValue;
	};

	STDMETHOD(GetSeparatorString)(
		/*[in]*/ LPCWSTR* pszSeparator)
	{
		VSL_DEFINE_MOCK_METHOD(GetSeparatorString)

		VSL_CHECK_VALIDVALUE_POINTER(pszSeparator);

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadStateValidValues
	{
		/*[in]*/ IStream* pIStream;
		/*[in]*/ LIB_PERSISTTYPE lptType;
		HRESULT retValue;
	};

	STDMETHOD(LoadState)(
		/*[in]*/ IStream* pIStream,
		/*[in]*/ LIB_PERSISTTYPE lptType)
	{
		VSL_DEFINE_MOCK_METHOD(LoadState)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIStream);

		VSL_CHECK_VALIDVALUE(lptType);

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveStateValidValues
	{
		/*[in]*/ IStream* pIStream;
		/*[in]*/ LIB_PERSISTTYPE lptType;
		HRESULT retValue;
	};

	STDMETHOD(SaveState)(
		/*[in]*/ IStream* pIStream,
		/*[in]*/ LIB_PERSISTTYPE lptType)
	{
		VSL_DEFINE_MOCK_METHOD(SaveState)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIStream);

		VSL_CHECK_VALIDVALUE(lptType);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBrowseContainersForHierarchyValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ ULONG celt;
		/*[in,out,size_is(celt)]*/ VSBROWSECONTAINER* rgBrowseContainers;
		/*[out,optional]*/ ULONG* pcActual;
		HRESULT retValue;
	};

	STDMETHOD(GetBrowseContainersForHierarchy)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ ULONG celt,
		/*[in,out,size_is(celt)]*/ VSBROWSECONTAINER rgBrowseContainers[],
		/*[out,optional]*/ ULONG* pcActual)
	{
		VSL_DEFINE_MOCK_METHOD(GetBrowseContainersForHierarchy)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(rgBrowseContainers, celt*sizeof(rgBrowseContainers[0]), validValues.celt*sizeof(validValues.rgBrowseContainers[0]));

		VSL_SET_VALIDVALUE(pcActual);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddBrowseContainerValidValues
	{
		/*[in]*/ PVSCOMPONENTSELECTORDATA pcdComponent;
		/*[in,out]*/ LIB_ADDREMOVEOPTIONS* pgrfOptions;
		/*[out]*/ BSTR* pbstrComponentAdded;
		HRESULT retValue;
	};

	STDMETHOD(AddBrowseContainer)(
		/*[in]*/ PVSCOMPONENTSELECTORDATA pcdComponent,
		/*[in,out]*/ LIB_ADDREMOVEOPTIONS* pgrfOptions,
		/*[out]*/ BSTR* pbstrComponentAdded)
	{
		VSL_DEFINE_MOCK_METHOD(AddBrowseContainer)

		VSL_CHECK_VALIDVALUE(pcdComponent);

		VSL_SET_VALIDVALUE(pgrfOptions);

		VSL_SET_VALIDVALUE_BSTR(pbstrComponentAdded);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveBrowseContainerValidValues
	{
		/*[in]*/ DWORD dwReserved;
		/*[in]*/ LPCWSTR pszLibName;
		HRESULT retValue;
	};

	STDMETHOD(RemoveBrowseContainer)(
		/*[in]*/ DWORD dwReserved,
		/*[in]*/ LPCWSTR pszLibName)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveBrowseContainer)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_CHECK_VALIDVALUE_STRINGW(pszLibName);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSLIBRARY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsLibraryMgr.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSLIBRARYMGR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSLIBRARYMGR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsLibraryMgrNotImpl :
	public IVsLibraryMgr
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLibraryMgrNotImpl)

public:

	typedef IVsLibraryMgr Interface;

	STDMETHOD(GetCount)(
		/*[out,retval]*/ ULONG* /*pnCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLibraryAt)(
		/*[in]*/ ULONG /*nLibIndex*/,
		/*[out,retval]*/ IVsLibrary** /*ppLibrary*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetNameAt)(
		/*[in]*/ ULONG /*nLibIndex*/,
		/*[out,retval]*/ WCHAR** /*pszName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ToggleCheckAt)(
		/*[in]*/ ULONG /*nLibIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCheckAt)(
		/*[in]*/ ULONG /*nLibIndex*/,
		/*[out,retval]*/ LIB_CHECKSTATE* /*pstate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetLibraryGroupEnabled)(
		/*[in]*/ LIB_PERSISTTYPE /*lpt*/,
		/*[in]*/ BOOL /*fEnable*/)VSL_STDMETHOD_NOTIMPL
};

class IVsLibraryMgrMockImpl :
	public IVsLibraryMgr,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLibraryMgrMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsLibraryMgrMockImpl)

	typedef IVsLibraryMgr Interface;
	struct GetCountValidValues
	{
		/*[out,retval]*/ ULONG* pnCount;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out,retval]*/ ULONG* pnCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pnCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLibraryAtValidValues
	{
		/*[in]*/ ULONG nLibIndex;
		/*[out,retval]*/ IVsLibrary** ppLibrary;
		HRESULT retValue;
	};

	STDMETHOD(GetLibraryAt)(
		/*[in]*/ ULONG nLibIndex,
		/*[out,retval]*/ IVsLibrary** ppLibrary)
	{
		VSL_DEFINE_MOCK_METHOD(GetLibraryAt)

		VSL_CHECK_VALIDVALUE(nLibIndex);

		VSL_SET_VALIDVALUE_INTERFACE(ppLibrary);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNameAtValidValues
	{
		/*[in]*/ ULONG nLibIndex;
		/*[out,retval]*/ WCHAR** pszName;
		HRESULT retValue;
	};

	STDMETHOD(GetNameAt)(
		/*[in]*/ ULONG nLibIndex,
		/*[out,retval]*/ WCHAR** pszName)
	{
		VSL_DEFINE_MOCK_METHOD(GetNameAt)

		VSL_CHECK_VALIDVALUE(nLibIndex);

		VSL_SET_VALIDVALUE(pszName);

		VSL_RETURN_VALIDVALUES();
	}
	struct ToggleCheckAtValidValues
	{
		/*[in]*/ ULONG nLibIndex;
		HRESULT retValue;
	};

	STDMETHOD(ToggleCheckAt)(
		/*[in]*/ ULONG nLibIndex)
	{
		VSL_DEFINE_MOCK_METHOD(ToggleCheckAt)

		VSL_CHECK_VALIDVALUE(nLibIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCheckAtValidValues
	{
		/*[in]*/ ULONG nLibIndex;
		/*[out,retval]*/ LIB_CHECKSTATE* pstate;
		HRESULT retValue;
	};

	STDMETHOD(GetCheckAt)(
		/*[in]*/ ULONG nLibIndex,
		/*[out,retval]*/ LIB_CHECKSTATE* pstate)
	{
		VSL_DEFINE_MOCK_METHOD(GetCheckAt)

		VSL_CHECK_VALIDVALUE(nLibIndex);

		VSL_SET_VALIDVALUE(pstate);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetLibraryGroupEnabledValidValues
	{
		/*[in]*/ LIB_PERSISTTYPE lpt;
		/*[in]*/ BOOL fEnable;
		HRESULT retValue;
	};

	STDMETHOD(SetLibraryGroupEnabled)(
		/*[in]*/ LIB_PERSISTTYPE lpt,
		/*[in]*/ BOOL fEnable)
	{
		VSL_DEFINE_MOCK_METHOD(SetLibraryGroupEnabled)

		VSL_CHECK_VALIDVALUE(lpt);

		VSL_CHECK_VALIDVALUE(fEnable);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSLIBRARYMGR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsLibrary2Ex.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSLIBRARY2EX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSLIBRARY2EX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsLibrary2ExNotImpl :
	public IVsLibrary2Ex
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLibrary2ExNotImpl)

public:

	typedef IVsLibrary2Ex Interface;

	STDMETHOD(ProfileSettingsChanged)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetNavInfoContainerData)(
		/*[in]*/ IVsNavInfo* /*pNavInfo*/,
		/*[out]*/ VSCOMPONENTSELECTORDATA* /*pcsdComponent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DoIdle)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetContainerAsUnchanging)(
		/*[in]*/ VSCOMPONENTSELECTORDATA* /*pcsdComponent*/,
		/*[in]*/ BOOL /*fUnchanging*/)VSL_STDMETHOD_NOTIMPL
};

class IVsLibrary2ExMockImpl :
	public IVsLibrary2Ex,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLibrary2ExMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsLibrary2ExMockImpl)

	typedef IVsLibrary2Ex Interface;
	struct ProfileSettingsChangedValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ProfileSettingsChanged)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ProfileSettingsChanged)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNavInfoContainerDataValidValues
	{
		/*[in]*/ IVsNavInfo* pNavInfo;
		/*[out]*/ VSCOMPONENTSELECTORDATA* pcsdComponent;
		HRESULT retValue;
	};

	STDMETHOD(GetNavInfoContainerData)(
		/*[in]*/ IVsNavInfo* pNavInfo,
		/*[out]*/ VSCOMPONENTSELECTORDATA* pcsdComponent)
	{
		VSL_DEFINE_MOCK_METHOD(GetNavInfoContainerData)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pNavInfo);

		VSL_SET_VALIDVALUE(pcsdComponent);

		VSL_RETURN_VALIDVALUES();
	}
	struct DoIdleValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(DoIdle)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(DoIdle)

		VSL_RETURN_VALIDVALUES();
	}
	struct SetContainerAsUnchangingValidValues
	{
		/*[in]*/ VSCOMPONENTSELECTORDATA* pcsdComponent;
		/*[in]*/ BOOL fUnchanging;
		HRESULT retValue;
	};

	STDMETHOD(SetContainerAsUnchanging)(
		/*[in]*/ VSCOMPONENTSELECTORDATA* pcsdComponent,
		/*[in]*/ BOOL fUnchanging)
	{
		VSL_DEFINE_MOCK_METHOD(SetContainerAsUnchanging)

		VSL_CHECK_VALIDVALUE_POINTER(pcsdComponent);

		VSL_CHECK_VALIDVALUE(fUnchanging);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSLIBRARY2EX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsLibrary2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSLIBRARY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSLIBRARY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsLibrary2NotImpl :
	public IVsLibrary2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLibrary2NotImpl)

public:

	typedef IVsLibrary2 Interface;

	STDMETHOD(GetSupportedCategoryFields2)(
		/*[in]*/ LIB_CATEGORY2 /*Category*/,
		/*[out,retval]*/ DWORD* /*pgrfCatField*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetList2)(
		/*[in]*/ LIB_LISTTYPE2 /*ListType*/,
		/*[in]*/ LIB_LISTFLAGS /*Flags*/,
		/*[in]*/ VSOBSEARCHCRITERIA2* /*pobSrch*/,
		/*[out,retval]*/ IVsObjectList2** /*ppIVsObjectList2*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLibList)(
		/*[in]*/ LIB_PERSISTTYPE /*lptType*/,
		/*[out,retval]*/ IVsLiteTreeList** /*ppList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLibFlags2)(
		/*[out,retval]*/ LIB_FLAGS2* /*pgrfFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateCounter)(
		/*[out]*/ ULONG* /*pCurUpdate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetGuid)(
		/*[out]*/ const GUID** /*ppguidLib*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSeparatorString)(
		/*[out,string]*/ LPCWSTR* /*pszSeparator*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LoadState)(
		/*[in]*/ IStream* /*pIStream*/,
		/*[in]*/ LIB_PERSISTTYPE /*lptType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SaveState)(
		/*[in]*/ IStream* /*pIStream*/,
		/*[in]*/ LIB_PERSISTTYPE /*lptType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBrowseContainersForHierarchy)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ ULONG /*celt*/,
		/*[in,out,size_is(celt)]*/ VSBROWSECONTAINER[] /*rgBrowseContainers*/,
		/*[out,optional]*/ ULONG* /*pcActual*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddBrowseContainer)(
		/*[in]*/ PVSCOMPONENTSELECTORDATA /*pcdComponent*/,
		/*[in,out]*/ LIB_ADDREMOVEOPTIONS* /*pgrfOptions*/,
		/*[out,optional]*/ BSTR* /*pbstrComponentAdded*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveBrowseContainer)(
		/*[in]*/ DWORD /*dwReserved*/,
		/*[in]*/ LPCWSTR /*pszLibName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateNavInfo)(
		/*[in,size_is(ulcNodes)]*/ SYMBOL_DESCRIPTION_NODE[] /*rgSymbolNodes*/,
		/*[in]*/ ULONG /*ulcNodes*/,
		/*[out]*/ IVsNavInfo** /*ppNavInfo*/)VSL_STDMETHOD_NOTIMPL
};

class IVsLibrary2MockImpl :
	public IVsLibrary2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLibrary2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsLibrary2MockImpl)

	typedef IVsLibrary2 Interface;
	struct GetSupportedCategoryFields2ValidValues
	{
		/*[in]*/ LIB_CATEGORY2 Category;
		/*[out,retval]*/ DWORD* pgrfCatField;
		HRESULT retValue;
	};

	STDMETHOD(GetSupportedCategoryFields2)(
		/*[in]*/ LIB_CATEGORY2 Category,
		/*[out,retval]*/ DWORD* pgrfCatField)
	{
		VSL_DEFINE_MOCK_METHOD(GetSupportedCategoryFields2)

		VSL_CHECK_VALIDVALUE(Category);

		VSL_SET_VALIDVALUE(pgrfCatField);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetList2ValidValues
	{
		/*[in]*/ LIB_LISTTYPE2 ListType;
		/*[in]*/ LIB_LISTFLAGS Flags;
		/*[in]*/ VSOBSEARCHCRITERIA2* pobSrch;
		/*[out,retval]*/ IVsObjectList2** ppIVsObjectList2;
		HRESULT retValue;
	};

	STDMETHOD(GetList2)(
		/*[in]*/ LIB_LISTTYPE2 ListType,
		/*[in]*/ LIB_LISTFLAGS Flags,
		/*[in]*/ VSOBSEARCHCRITERIA2* pobSrch,
		/*[out,retval]*/ IVsObjectList2** ppIVsObjectList2)
	{
		VSL_DEFINE_MOCK_METHOD(GetList2)

		VSL_CHECK_VALIDVALUE(ListType);

		VSL_CHECK_VALIDVALUE(Flags);

		VSL_CHECK_VALIDVALUE_POINTER(pobSrch);

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsObjectList2);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLibListValidValues
	{
		/*[in]*/ LIB_PERSISTTYPE lptType;
		/*[out,retval]*/ IVsLiteTreeList** ppList;
		HRESULT retValue;
	};

	STDMETHOD(GetLibList)(
		/*[in]*/ LIB_PERSISTTYPE lptType,
		/*[out,retval]*/ IVsLiteTreeList** ppList)
	{
		VSL_DEFINE_MOCK_METHOD(GetLibList)

		VSL_CHECK_VALIDVALUE(lptType);

		VSL_SET_VALIDVALUE_INTERFACE(ppList);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLibFlags2ValidValues
	{
		/*[out,retval]*/ LIB_FLAGS2* pgrfFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetLibFlags2)(
		/*[out,retval]*/ LIB_FLAGS2* pgrfFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetLibFlags2)

		VSL_SET_VALIDVALUE(pgrfFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateCounterValidValues
	{
		/*[out]*/ ULONG* pCurUpdate;
		HRESULT retValue;
	};

	STDMETHOD(UpdateCounter)(
		/*[out]*/ ULONG* pCurUpdate)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateCounter)

		VSL_SET_VALIDVALUE(pCurUpdate);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetGuidValidValues
	{
		/*[out]*/ GUID** ppguidLib;
		HRESULT retValue;
	};

	STDMETHOD(GetGuid)(
		/*[out]*/ const GUID** ppguidLib)
	{
		VSL_DEFINE_MOCK_METHOD(GetGuid)

		VSL_SET_VALIDVALUE_CONST(ppguidLib, GUID**);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSeparatorStringValidValues
	{
		/*[out,string]*/ LPCWSTR* pszSeparator;
		HRESULT retValue;
	};

	STDMETHOD(GetSeparatorString)(
		/*[out,string]*/ LPCWSTR* pszSeparator)
	{
		VSL_DEFINE_MOCK_METHOD(GetSeparatorString)

		VSL_SET_VALIDVALUE(pszSeparator);

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadStateValidValues
	{
		/*[in]*/ IStream* pIStream;
		/*[in]*/ LIB_PERSISTTYPE lptType;
		HRESULT retValue;
	};

	STDMETHOD(LoadState)(
		/*[in]*/ IStream* pIStream,
		/*[in]*/ LIB_PERSISTTYPE lptType)
	{
		VSL_DEFINE_MOCK_METHOD(LoadState)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIStream);

		VSL_CHECK_VALIDVALUE(lptType);

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveStateValidValues
	{
		/*[in]*/ IStream* pIStream;
		/*[in]*/ LIB_PERSISTTYPE lptType;
		HRESULT retValue;
	};

	STDMETHOD(SaveState)(
		/*[in]*/ IStream* pIStream,
		/*[in]*/ LIB_PERSISTTYPE lptType)
	{
		VSL_DEFINE_MOCK_METHOD(SaveState)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIStream);

		VSL_CHECK_VALIDVALUE(lptType);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBrowseContainersForHierarchyValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ ULONG celt;
		/*[in,out,size_is(celt)]*/ VSBROWSECONTAINER* rgBrowseContainers;
		/*[out,optional]*/ ULONG* pcActual;
		HRESULT retValue;
	};

	STDMETHOD(GetBrowseContainersForHierarchy)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ ULONG celt,
		/*[in,out,size_is(celt)]*/ VSBROWSECONTAINER rgBrowseContainers[],
		/*[out,optional]*/ ULONG* pcActual)
	{
		VSL_DEFINE_MOCK_METHOD(GetBrowseContainersForHierarchy)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(rgBrowseContainers, celt*sizeof(rgBrowseContainers[0]), validValues.celt*sizeof(validValues.rgBrowseContainers[0]));

		VSL_SET_VALIDVALUE(pcActual);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddBrowseContainerValidValues
	{
		/*[in]*/ PVSCOMPONENTSELECTORDATA pcdComponent;
		/*[in,out]*/ LIB_ADDREMOVEOPTIONS* pgrfOptions;
		/*[out,optional]*/ BSTR* pbstrComponentAdded;
		HRESULT retValue;
	};

	STDMETHOD(AddBrowseContainer)(
		/*[in]*/ PVSCOMPONENTSELECTORDATA pcdComponent,
		/*[in,out]*/ LIB_ADDREMOVEOPTIONS* pgrfOptions,
		/*[out,optional]*/ BSTR* pbstrComponentAdded)
	{
		VSL_DEFINE_MOCK_METHOD(AddBrowseContainer)

		VSL_CHECK_VALIDVALUE(pcdComponent);

		VSL_SET_VALIDVALUE(pgrfOptions);

		VSL_SET_VALIDVALUE_BSTR(pbstrComponentAdded);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveBrowseContainerValidValues
	{
		/*[in]*/ DWORD dwReserved;
		/*[in]*/ LPCWSTR pszLibName;
		HRESULT retValue;
	};

	STDMETHOD(RemoveBrowseContainer)(
		/*[in]*/ DWORD dwReserved,
		/*[in]*/ LPCWSTR pszLibName)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveBrowseContainer)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_CHECK_VALIDVALUE_STRINGW(pszLibName);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateNavInfoValidValues
	{
		/*[in,size_is(ulcNodes)]*/ SYMBOL_DESCRIPTION_NODE* rgSymbolNodes;
		/*[in]*/ ULONG ulcNodes;
		/*[out]*/ IVsNavInfo** ppNavInfo;
		HRESULT retValue;
	};

	STDMETHOD(CreateNavInfo)(
		/*[in,size_is(ulcNodes)]*/ SYMBOL_DESCRIPTION_NODE rgSymbolNodes[],
		/*[in]*/ ULONG ulcNodes,
		/*[out]*/ IVsNavInfo** ppNavInfo)
	{
		VSL_DEFINE_MOCK_METHOD(CreateNavInfo)

		VSL_CHECK_VALIDVALUE_MEMCMP(rgSymbolNodes, ulcNodes*sizeof(rgSymbolNodes[0]), validValues.ulcNodes*sizeof(validValues.rgSymbolNodes[0]));

		VSL_CHECK_VALIDVALUE(ulcNodes);

		VSL_SET_VALIDVALUE_INTERFACE(ppNavInfo);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSLIBRARY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsLifetimeControlledObject.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSLIFETIMECONTROLLEDOBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSLIFETIMECONTROLLEDOBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsLifetimeControlledObjectNotImpl :
	public IVsLifetimeControlledObject
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLifetimeControlledObjectNotImpl)

public:

	typedef IVsLifetimeControlledObject Interface;

	STDMETHOD(SeverReferencesToOwner)()VSL_STDMETHOD_NOTIMPL
};

class IVsLifetimeControlledObjectMockImpl :
	public IVsLifetimeControlledObject,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLifetimeControlledObjectMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsLifetimeControlledObjectMockImpl)

	typedef IVsLifetimeControlledObject Interface;
	struct SeverReferencesToOwnerValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(SeverReferencesToOwner)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(SeverReferencesToOwner)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSLIFETIMECONTROLLEDOBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsLibraryReferenceManager.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSLIBRARYREFERENCEMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSLIBRARYREFERENCEMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsLibraryReferenceManagerNotImpl :
	public IVsLibraryReferenceManager
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLibraryReferenceManagerNotImpl)

public:

	typedef IVsLibraryReferenceManager Interface;

	STDMETHOD(AddComponentReference)(
		/*[in]*/ LPCOLESTR /*wszPath*/,
		/*[in]*/ IUnknown* /*pVsLibrary*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveComponentReference)(
		/*[in]*/ LPCOLESTR /*wszPath*/,
		/*[in]*/ IUnknown* /*pVsLibrary*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IncrementCheckCount)(
		/*[in]*/ LPCOLESTR /*wszPath*/,
		/*[in]*/ IUnknown* /*pVsLibrary*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DecrementCheckCount)(
		/*[in]*/ LPCOLESTR /*wszPath*/,
		/*[in]*/ IUnknown* /*pVsLibrary*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetListIndex)(
		/*[in]*/ VSOBJECTINFO* /*pobjInfo*/,
		/*[out]*/ IVsObjectList** /*ppList*/,
		/*[out]*/ ULONG* /*pIndex*/)VSL_STDMETHOD_NOTIMPL
};

class IVsLibraryReferenceManagerMockImpl :
	public IVsLibraryReferenceManager,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLibraryReferenceManagerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsLibraryReferenceManagerMockImpl)

	typedef IVsLibraryReferenceManager Interface;
	struct AddComponentReferenceValidValues
	{
		/*[in]*/ LPCOLESTR wszPath;
		/*[in]*/ IUnknown* pVsLibrary;
		HRESULT retValue;
	};

	STDMETHOD(AddComponentReference)(
		/*[in]*/ LPCOLESTR wszPath,
		/*[in]*/ IUnknown* pVsLibrary)
	{
		VSL_DEFINE_MOCK_METHOD(AddComponentReference)

		VSL_CHECK_VALIDVALUE_STRINGW(wszPath);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pVsLibrary);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveComponentReferenceValidValues
	{
		/*[in]*/ LPCOLESTR wszPath;
		/*[in]*/ IUnknown* pVsLibrary;
		HRESULT retValue;
	};

	STDMETHOD(RemoveComponentReference)(
		/*[in]*/ LPCOLESTR wszPath,
		/*[in]*/ IUnknown* pVsLibrary)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveComponentReference)

		VSL_CHECK_VALIDVALUE_STRINGW(wszPath);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pVsLibrary);

		VSL_RETURN_VALIDVALUES();
	}
	struct IncrementCheckCountValidValues
	{
		/*[in]*/ LPCOLESTR wszPath;
		/*[in]*/ IUnknown* pVsLibrary;
		HRESULT retValue;
	};

	STDMETHOD(IncrementCheckCount)(
		/*[in]*/ LPCOLESTR wszPath,
		/*[in]*/ IUnknown* pVsLibrary)
	{
		VSL_DEFINE_MOCK_METHOD(IncrementCheckCount)

		VSL_CHECK_VALIDVALUE_STRINGW(wszPath);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pVsLibrary);

		VSL_RETURN_VALIDVALUES();
	}
	struct DecrementCheckCountValidValues
	{
		/*[in]*/ LPCOLESTR wszPath;
		/*[in]*/ IUnknown* pVsLibrary;
		HRESULT retValue;
	};

	STDMETHOD(DecrementCheckCount)(
		/*[in]*/ LPCOLESTR wszPath,
		/*[in]*/ IUnknown* pVsLibrary)
	{
		VSL_DEFINE_MOCK_METHOD(DecrementCheckCount)

		VSL_CHECK_VALIDVALUE_STRINGW(wszPath);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pVsLibrary);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetListIndexValidValues
	{
		/*[in]*/ VSOBJECTINFO* pobjInfo;
		/*[out]*/ IVsObjectList** ppList;
		/*[out]*/ ULONG* pIndex;
		HRESULT retValue;
	};

	STDMETHOD(GetListIndex)(
		/*[in]*/ VSOBJECTINFO* pobjInfo,
		/*[out]*/ IVsObjectList** ppList,
		/*[out]*/ ULONG* pIndex)
	{
		VSL_DEFINE_MOCK_METHOD(GetListIndex)

		VSL_CHECK_VALIDVALUE_POINTER(pobjInfo);

		VSL_SET_VALIDVALUE_INTERFACE(ppList);

		VSL_SET_VALIDVALUE(pIndex);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSLIBRARYREFERENCEMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsLinkCapableUndoManager.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSLINKCAPABLEUNDOMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSLINKCAPABLEUNDOMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsLinkCapableUndoManagerNotImpl :
	public IVsLinkCapableUndoManager
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLinkCapableUndoManagerNotImpl)

public:

	typedef IVsLinkCapableUndoManager Interface;

	STDMETHOD(AdviseLinkedUndoClient)(
		/*[in]*/ IVsLinkedUndoClient* /*pClient*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseLinkedUndoClient)()VSL_STDMETHOD_NOTIMPL
};

class IVsLinkCapableUndoManagerMockImpl :
	public IVsLinkCapableUndoManager,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLinkCapableUndoManagerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsLinkCapableUndoManagerMockImpl)

	typedef IVsLinkCapableUndoManager Interface;
	struct AdviseLinkedUndoClientValidValues
	{
		/*[in]*/ IVsLinkedUndoClient* pClient;
		HRESULT retValue;
	};

	STDMETHOD(AdviseLinkedUndoClient)(
		/*[in]*/ IVsLinkedUndoClient* pClient)
	{
		VSL_DEFINE_MOCK_METHOD(AdviseLinkedUndoClient)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pClient);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseLinkedUndoClientValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(UnadviseLinkedUndoClient)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(UnadviseLinkedUndoClient)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSLINKCAPABLEUNDOMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsMacros.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSMACROS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSMACROS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vbapkg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsMacrosNotImpl :
	public IVsMacros
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsMacrosNotImpl)

public:

	typedef IVsMacros Interface;

	STDMETHOD(GetMacroCommands)(
		/*[out]*/ SAFEARRAY** /*ppsaMacroCanonicalNames*/)VSL_STDMETHOD_NOTIMPL
};

class IVsMacrosMockImpl :
	public IVsMacros,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsMacrosMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsMacrosMockImpl)

	typedef IVsMacros Interface;
	struct GetMacroCommandsValidValues
	{
		/*[out]*/ SAFEARRAY** ppsaMacroCanonicalNames;
		HRESULT retValue;
	};

	STDMETHOD(GetMacroCommands)(
		/*[out]*/ SAFEARRAY** ppsaMacroCanonicalNames)
	{
		VSL_DEFINE_MOCK_METHOD(GetMacroCommands)

		VSL_SET_VALIDVALUE_SAFEARRAY(ppsaMacroCanonicalNames);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSMACROS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsLiteTreeEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSLITETREEEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSLITETREEEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsLiteTreeEventsNotImpl :
	public IVsLiteTreeEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLiteTreeEventsNotImpl)

public:

	typedef IVsLiteTreeEvents Interface;

	STDMETHOD(OnToggleExpansion)(
		/*[in]*/ ULONG /*AbsIndex*/,
		/*[in]*/ long /*cChange*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnToggleState)(
		/*[in]*/ ULONG /*AbsIndex*/,
		/*[in]*/ VSTREESTATECHANGEREFRESH /*tscr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnRefresh)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnInsertItems)(
		/*[in]*/ ULONG /*iAfter*/,
		/*[in]*/ ULONG /*Count*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnDeleteItems)(
		/*[in]*/ ULONG /*iStart*/,
		/*[in]*/ ULONG /*Count*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnSetRedraw)(
		/*[in]*/ BOOL /*fOn*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnQueryItemVisible)(
		/*[in]*/ ULONG /*AbsIndex*/,
		/*[out]*/ BOOL* /*pfVisible*/)VSL_STDMETHOD_NOTIMPL
};

class IVsLiteTreeEventsMockImpl :
	public IVsLiteTreeEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLiteTreeEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsLiteTreeEventsMockImpl)

	typedef IVsLiteTreeEvents Interface;
	struct OnToggleExpansionValidValues
	{
		/*[in]*/ ULONG AbsIndex;
		/*[in]*/ long cChange;
		HRESULT retValue;
	};

	STDMETHOD(OnToggleExpansion)(
		/*[in]*/ ULONG AbsIndex,
		/*[in]*/ long cChange)
	{
		VSL_DEFINE_MOCK_METHOD(OnToggleExpansion)

		VSL_CHECK_VALIDVALUE(AbsIndex);

		VSL_CHECK_VALIDVALUE(cChange);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnToggleStateValidValues
	{
		/*[in]*/ ULONG AbsIndex;
		/*[in]*/ VSTREESTATECHANGEREFRESH tscr;
		HRESULT retValue;
	};

	STDMETHOD(OnToggleState)(
		/*[in]*/ ULONG AbsIndex,
		/*[in]*/ VSTREESTATECHANGEREFRESH tscr)
	{
		VSL_DEFINE_MOCK_METHOD(OnToggleState)

		VSL_CHECK_VALIDVALUE(AbsIndex);

		VSL_CHECK_VALIDVALUE(tscr);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnRefreshValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnRefresh)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnRefresh)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnInsertItemsValidValues
	{
		/*[in]*/ ULONG iAfter;
		/*[in]*/ ULONG Count;
		HRESULT retValue;
	};

	STDMETHOD(OnInsertItems)(
		/*[in]*/ ULONG iAfter,
		/*[in]*/ ULONG Count)
	{
		VSL_DEFINE_MOCK_METHOD(OnInsertItems)

		VSL_CHECK_VALIDVALUE(iAfter);

		VSL_CHECK_VALIDVALUE(Count);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnDeleteItemsValidValues
	{
		/*[in]*/ ULONG iStart;
		/*[in]*/ ULONG Count;
		HRESULT retValue;
	};

	STDMETHOD(OnDeleteItems)(
		/*[in]*/ ULONG iStart,
		/*[in]*/ ULONG Count)
	{
		VSL_DEFINE_MOCK_METHOD(OnDeleteItems)

		VSL_CHECK_VALIDVALUE(iStart);

		VSL_CHECK_VALIDVALUE(Count);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnSetRedrawValidValues
	{
		/*[in]*/ BOOL fOn;
		HRESULT retValue;
	};

	STDMETHOD(OnSetRedraw)(
		/*[in]*/ BOOL fOn)
	{
		VSL_DEFINE_MOCK_METHOD(OnSetRedraw)

		VSL_CHECK_VALIDVALUE(fOn);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnQueryItemVisibleValidValues
	{
		/*[in]*/ ULONG AbsIndex;
		/*[out]*/ BOOL* pfVisible;
		HRESULT retValue;
	};

	STDMETHOD(OnQueryItemVisible)(
		/*[in]*/ ULONG AbsIndex,
		/*[out]*/ BOOL* pfVisible)
	{
		VSL_DEFINE_MOCK_METHOD(OnQueryItemVisible)

		VSL_CHECK_VALIDVALUE(AbsIndex);

		VSL_SET_VALIDVALUE(pfVisible);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSLITETREEEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVSMDCodeDomCreator.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSMDCODEDOMCREATOR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSMDCODEDOMCREATOR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsmanaged.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVSMDCodeDomCreatorNotImpl :
	public IVSMDCodeDomCreator
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVSMDCodeDomCreatorNotImpl)

public:

	typedef IVSMDCodeDomCreator Interface;

	STDMETHOD(CreateCodeDomProvider)(
		/*[in]*/ IVsHierarchy* /*pHier*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[out,retval]*/ IVSMDCodeDomProvider** /*ppProvider*/)VSL_STDMETHOD_NOTIMPL
};

class IVSMDCodeDomCreatorMockImpl :
	public IVSMDCodeDomCreator,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVSMDCodeDomCreatorMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVSMDCodeDomCreatorMockImpl)

	typedef IVSMDCodeDomCreator Interface;
	struct CreateCodeDomProviderValidValues
	{
		/*[in]*/ IVsHierarchy* pHier;
		/*[in]*/ VSITEMID itemid;
		/*[out,retval]*/ IVSMDCodeDomProvider** ppProvider;
		HRESULT retValue;
	};

	STDMETHOD(CreateCodeDomProvider)(
		/*[in]*/ IVsHierarchy* pHier,
		/*[in]*/ VSITEMID itemid,
		/*[out,retval]*/ IVSMDCodeDomProvider** ppProvider)
	{
		VSL_DEFINE_MOCK_METHOD(CreateCodeDomProvider)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHier);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_SET_VALIDVALUE_INTERFACE(ppProvider);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSMDCODEDOMCREATOR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsLiteTree.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSLITETREE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSLITETREE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsLiteTreeNotImpl :
	public IVsLiteTree
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLiteTreeNotImpl)

public:

	typedef IVsLiteTree Interface;

	STDMETHOD(SetRoot)(
		/*[in]*/ IVsLiteTreeList* /*pList*/,
		/*[out]*/ IVsLiteTree** /*ppClone*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CloneTreeAbsolute)(
		/*[in]*/ ULONG /*AbsIndex*/,
		/*[out,retval]*/ IVsLiteTree** /*retVal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReAlign)(
		/*[in]*/ IVsLiteTreeList* /*pNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(InsertItems)(
		/*[in]*/ IVsLiteTreeList* /*pNode*/,
		/*[in]*/ ULONG /*iAfter*/,
		/*[in]*/ ULONG /*Count*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DeleteItems)(
		/*[in]*/ IVsLiteTreeList* /*pNode*/,
		/*[in]*/ ULONG /*iStart*/,
		/*[in]*/ ULONG /*Count*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ToggleExpansionAbsolute)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ BOOL* /*pfCanRecurse*/,
		/*[out]*/ long* /*pChange*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExpandedAbsolute)(
		/*[in]*/ ULONG /*AbsIndex*/,
		/*[out]*/ BOOL* /*pfExpanded*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExpandableAbsolute)(
		/*[in]*/ ULONG /*AbsIndex*/,
		/*[out]*/ BOOL* /*pfCanExpand*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetItemInfoAbsolute)(
		/*[in]*/ ULONG /*AbsIndex*/,
		/*[out]*/ IVsLiteTreeList** /*pptl*/,
		/*[out]*/ ULONG* /*pIndex*/,
		/*[out]*/ ULONG* /*pLevel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(VisibleItemCount)(
		/*[out]*/ ULONG* /*pCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Refresh)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDescendantItemCount)(
		/*[in]*/ ULONG /*AbsIndex*/,
		/*[out]*/ ULONG* /*pCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetParentIndexAbsolute)(
		/*[in]*/ ULONG /*AbsIndex*/,
		/*[out]*/ ULONG* /*pParentIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExpandedListAbsolute)(
		/*[in]*/ ULONG /*AbsIndex*/,
		/*[out]*/ ULONG* /*pLevel*/,
		/*[out]*/ IVsLiteTreeList** /*pptl*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ToggleStateAbsolute)(
		/*[in]*/ ULONG /*AbsIndex*/,
		/*[out]*/ VSTREESTATECHANGEREFRESH* /*ptscr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AdviseTreeEvents)(
		/*[in]*/ IVsLiteTreeEvents* /*pEventSink*/,
		/*[out]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseTreeEvents)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnableTreeEvents)(
		/*[in]*/ VSCOOKIE /*dwCookie*/,
		/*[in]*/ BOOL /*fEnable*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumAbsoluteIndices)(
		/*[in]*/ IVsLiteTreeList* /*pList*/,
		/*[in]*/ ULONG /*Index*/,
		/*[in,out]*/ void** /*ppvNext*/,
		/*[out]*/ ULONG* /*pAbsIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetOffsetFromParent)(
		/*[in]*/ ULONG /*ParentAbsIndex*/,
		/*[in]*/ ULONG /*RelIndex*/,
		/*[out]*/ ULONG* /*pOffset*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumOrderedListItems)(
		/*[in,out]*/ ULONG* /*pNextStartIndex*/,
		/*[out]*/ IVsLiteTreeList** /*pptl*/,
		/*[out]*/ ULONG* /*pFirstRelIndex*/,
		/*[out]*/ ULONG* /*pLastRelIndex*/,
		/*[out]*/ ULONG* /*pLevel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetRedraw)(
		/*[in]*/ BOOL /*fOn*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DelayRedraw)(
		/*[in]*/ BOOL /*fOn*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryItemVisible)(
		/*[in]*/ ULONG /*AbsIndex*/,
		/*[out]*/ BOOL* /*pfVisible*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Init)(
		/*[in]*/ VSLITETREEOPTS /*grfOpts*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetInitFlags)(
		/*[out]*/ VSLITETREEOPTS* /*pgrfOpts*/)VSL_STDMETHOD_NOTIMPL
};

class IVsLiteTreeMockImpl :
	public IVsLiteTree,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLiteTreeMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsLiteTreeMockImpl)

	typedef IVsLiteTree Interface;
	struct SetRootValidValues
	{
		/*[in]*/ IVsLiteTreeList* pList;
		/*[out]*/ IVsLiteTree** ppClone;
		HRESULT retValue;
	};

	STDMETHOD(SetRoot)(
		/*[in]*/ IVsLiteTreeList* pList,
		/*[out]*/ IVsLiteTree** ppClone)
	{
		VSL_DEFINE_MOCK_METHOD(SetRoot)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pList);

		VSL_SET_VALIDVALUE_INTERFACE(ppClone);

		VSL_RETURN_VALIDVALUES();
	}
	struct CloneTreeAbsoluteValidValues
	{
		/*[in]*/ ULONG AbsIndex;
		/*[out,retval]*/ IVsLiteTree** retVal;
		HRESULT retValue;
	};

	STDMETHOD(CloneTreeAbsolute)(
		/*[in]*/ ULONG AbsIndex,
		/*[out,retval]*/ IVsLiteTree** retVal)
	{
		VSL_DEFINE_MOCK_METHOD(CloneTreeAbsolute)

		VSL_CHECK_VALIDVALUE(AbsIndex);

		VSL_SET_VALIDVALUE_INTERFACE(retVal);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReAlignValidValues
	{
		/*[in]*/ IVsLiteTreeList* pNode;
		HRESULT retValue;
	};

	STDMETHOD(ReAlign)(
		/*[in]*/ IVsLiteTreeList* pNode)
	{
		VSL_DEFINE_MOCK_METHOD(ReAlign)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct InsertItemsValidValues
	{
		/*[in]*/ IVsLiteTreeList* pNode;
		/*[in]*/ ULONG iAfter;
		/*[in]*/ ULONG Count;
		HRESULT retValue;
	};

	STDMETHOD(InsertItems)(
		/*[in]*/ IVsLiteTreeList* pNode,
		/*[in]*/ ULONG iAfter,
		/*[in]*/ ULONG Count)
	{
		VSL_DEFINE_MOCK_METHOD(InsertItems)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pNode);

		VSL_CHECK_VALIDVALUE(iAfter);

		VSL_CHECK_VALIDVALUE(Count);

		VSL_RETURN_VALIDVALUES();
	}
	struct DeleteItemsValidValues
	{
		/*[in]*/ IVsLiteTreeList* pNode;
		/*[in]*/ ULONG iStart;
		/*[in]*/ ULONG Count;
		HRESULT retValue;
	};

	STDMETHOD(DeleteItems)(
		/*[in]*/ IVsLiteTreeList* pNode,
		/*[in]*/ ULONG iStart,
		/*[in]*/ ULONG Count)
	{
		VSL_DEFINE_MOCK_METHOD(DeleteItems)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pNode);

		VSL_CHECK_VALIDVALUE(iStart);

		VSL_CHECK_VALIDVALUE(Count);

		VSL_RETURN_VALIDVALUES();
	}
	struct ToggleExpansionAbsoluteValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ BOOL* pfCanRecurse;
		/*[out]*/ long* pChange;
		HRESULT retValue;
	};

	STDMETHOD(ToggleExpansionAbsolute)(
		/*[in]*/ ULONG Index,
		/*[out]*/ BOOL* pfCanRecurse,
		/*[out]*/ long* pChange)
	{
		VSL_DEFINE_MOCK_METHOD(ToggleExpansionAbsolute)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE(pfCanRecurse);

		VSL_SET_VALIDVALUE(pChange);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExpandedAbsoluteValidValues
	{
		/*[in]*/ ULONG AbsIndex;
		/*[out]*/ BOOL* pfExpanded;
		HRESULT retValue;
	};

	STDMETHOD(GetExpandedAbsolute)(
		/*[in]*/ ULONG AbsIndex,
		/*[out]*/ BOOL* pfExpanded)
	{
		VSL_DEFINE_MOCK_METHOD(GetExpandedAbsolute)

		VSL_CHECK_VALIDVALUE(AbsIndex);

		VSL_SET_VALIDVALUE(pfExpanded);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExpandableAbsoluteValidValues
	{
		/*[in]*/ ULONG AbsIndex;
		/*[out]*/ BOOL* pfCanExpand;
		HRESULT retValue;
	};

	STDMETHOD(GetExpandableAbsolute)(
		/*[in]*/ ULONG AbsIndex,
		/*[out]*/ BOOL* pfCanExpand)
	{
		VSL_DEFINE_MOCK_METHOD(GetExpandableAbsolute)

		VSL_CHECK_VALIDVALUE(AbsIndex);

		VSL_SET_VALIDVALUE(pfCanExpand);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetItemInfoAbsoluteValidValues
	{
		/*[in]*/ ULONG AbsIndex;
		/*[out]*/ IVsLiteTreeList** pptl;
		/*[out]*/ ULONG* pIndex;
		/*[out]*/ ULONG* pLevel;
		HRESULT retValue;
	};

	STDMETHOD(GetItemInfoAbsolute)(
		/*[in]*/ ULONG AbsIndex,
		/*[out]*/ IVsLiteTreeList** pptl,
		/*[out]*/ ULONG* pIndex,
		/*[out]*/ ULONG* pLevel)
	{
		VSL_DEFINE_MOCK_METHOD(GetItemInfoAbsolute)

		VSL_CHECK_VALIDVALUE(AbsIndex);

		VSL_SET_VALIDVALUE_INTERFACE(pptl);

		VSL_SET_VALIDVALUE(pIndex);

		VSL_SET_VALIDVALUE(pLevel);

		VSL_RETURN_VALIDVALUES();
	}
	struct VisibleItemCountValidValues
	{
		/*[out]*/ ULONG* pCount;
		HRESULT retValue;
	};

	STDMETHOD(VisibleItemCount)(
		/*[out]*/ ULONG* pCount)
	{
		VSL_DEFINE_MOCK_METHOD(VisibleItemCount)

		VSL_SET_VALIDVALUE(pCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct RefreshValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Refresh)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Refresh)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDescendantItemCountValidValues
	{
		/*[in]*/ ULONG AbsIndex;
		/*[out]*/ ULONG* pCount;
		HRESULT retValue;
	};

	STDMETHOD(GetDescendantItemCount)(
		/*[in]*/ ULONG AbsIndex,
		/*[out]*/ ULONG* pCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetDescendantItemCount)

		VSL_CHECK_VALIDVALUE(AbsIndex);

		VSL_SET_VALIDVALUE(pCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetParentIndexAbsoluteValidValues
	{
		/*[in]*/ ULONG AbsIndex;
		/*[out]*/ ULONG* pParentIndex;
		HRESULT retValue;
	};

	STDMETHOD(GetParentIndexAbsolute)(
		/*[in]*/ ULONG AbsIndex,
		/*[out]*/ ULONG* pParentIndex)
	{
		VSL_DEFINE_MOCK_METHOD(GetParentIndexAbsolute)

		VSL_CHECK_VALIDVALUE(AbsIndex);

		VSL_SET_VALIDVALUE(pParentIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExpandedListAbsoluteValidValues
	{
		/*[in]*/ ULONG AbsIndex;
		/*[out]*/ ULONG* pLevel;
		/*[out]*/ IVsLiteTreeList** pptl;
		HRESULT retValue;
	};

	STDMETHOD(GetExpandedListAbsolute)(
		/*[in]*/ ULONG AbsIndex,
		/*[out]*/ ULONG* pLevel,
		/*[out]*/ IVsLiteTreeList** pptl)
	{
		VSL_DEFINE_MOCK_METHOD(GetExpandedListAbsolute)

		VSL_CHECK_VALIDVALUE(AbsIndex);

		VSL_SET_VALIDVALUE(pLevel);

		VSL_SET_VALIDVALUE_INTERFACE(pptl);

		VSL_RETURN_VALIDVALUES();
	}
	struct ToggleStateAbsoluteValidValues
	{
		/*[in]*/ ULONG AbsIndex;
		/*[out]*/ VSTREESTATECHANGEREFRESH* ptscr;
		HRESULT retValue;
	};

	STDMETHOD(ToggleStateAbsolute)(
		/*[in]*/ ULONG AbsIndex,
		/*[out]*/ VSTREESTATECHANGEREFRESH* ptscr)
	{
		VSL_DEFINE_MOCK_METHOD(ToggleStateAbsolute)

		VSL_CHECK_VALIDVALUE(AbsIndex);

		VSL_SET_VALIDVALUE(ptscr);

		VSL_RETURN_VALIDVALUES();
	}
	struct AdviseTreeEventsValidValues
	{
		/*[in]*/ IVsLiteTreeEvents* pEventSink;
		/*[out]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(AdviseTreeEvents)(
		/*[in]*/ IVsLiteTreeEvents* pEventSink,
		/*[out]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(AdviseTreeEvents)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pEventSink);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseTreeEventsValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnadviseTreeEvents)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnadviseTreeEvents)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnableTreeEventsValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		/*[in]*/ BOOL fEnable;
		HRESULT retValue;
	};

	STDMETHOD(EnableTreeEvents)(
		/*[in]*/ VSCOOKIE dwCookie,
		/*[in]*/ BOOL fEnable)
	{
		VSL_DEFINE_MOCK_METHOD(EnableTreeEvents)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_CHECK_VALIDVALUE(fEnable);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumAbsoluteIndicesValidValues
	{
		/*[in]*/ IVsLiteTreeList* pList;
		/*[in]*/ ULONG Index;
		/*[in,out]*/ void** ppvNext;
		/*[out]*/ ULONG* pAbsIndex;
		HRESULT retValue;
	};

	STDMETHOD(EnumAbsoluteIndices)(
		/*[in]*/ IVsLiteTreeList* pList,
		/*[in]*/ ULONG Index,
		/*[in,out]*/ void** ppvNext,
		/*[out]*/ ULONG* pAbsIndex)
	{
		VSL_DEFINE_MOCK_METHOD(EnumAbsoluteIndices)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pList);

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE(ppvNext);

		VSL_SET_VALIDVALUE(pAbsIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetOffsetFromParentValidValues
	{
		/*[in]*/ ULONG ParentAbsIndex;
		/*[in]*/ ULONG RelIndex;
		/*[out]*/ ULONG* pOffset;
		HRESULT retValue;
	};

	STDMETHOD(GetOffsetFromParent)(
		/*[in]*/ ULONG ParentAbsIndex,
		/*[in]*/ ULONG RelIndex,
		/*[out]*/ ULONG* pOffset)
	{
		VSL_DEFINE_MOCK_METHOD(GetOffsetFromParent)

		VSL_CHECK_VALIDVALUE(ParentAbsIndex);

		VSL_CHECK_VALIDVALUE(RelIndex);

		VSL_SET_VALIDVALUE(pOffset);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumOrderedListItemsValidValues
	{
		/*[in,out]*/ ULONG* pNextStartIndex;
		/*[out]*/ IVsLiteTreeList** pptl;
		/*[out]*/ ULONG* pFirstRelIndex;
		/*[out]*/ ULONG* pLastRelIndex;
		/*[out]*/ ULONG* pLevel;
		HRESULT retValue;
	};

	STDMETHOD(EnumOrderedListItems)(
		/*[in,out]*/ ULONG* pNextStartIndex,
		/*[out]*/ IVsLiteTreeList** pptl,
		/*[out]*/ ULONG* pFirstRelIndex,
		/*[out]*/ ULONG* pLastRelIndex,
		/*[out]*/ ULONG* pLevel)
	{
		VSL_DEFINE_MOCK_METHOD(EnumOrderedListItems)

		VSL_SET_VALIDVALUE(pNextStartIndex);

		VSL_SET_VALIDVALUE_INTERFACE(pptl);

		VSL_SET_VALIDVALUE(pFirstRelIndex);

		VSL_SET_VALIDVALUE(pLastRelIndex);

		VSL_SET_VALIDVALUE(pLevel);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetRedrawValidValues
	{
		/*[in]*/ BOOL fOn;
		HRESULT retValue;
	};

	STDMETHOD(SetRedraw)(
		/*[in]*/ BOOL fOn)
	{
		VSL_DEFINE_MOCK_METHOD(SetRedraw)

		VSL_CHECK_VALIDVALUE(fOn);

		VSL_RETURN_VALIDVALUES();
	}
	struct DelayRedrawValidValues
	{
		/*[in]*/ BOOL fOn;
		HRESULT retValue;
	};

	STDMETHOD(DelayRedraw)(
		/*[in]*/ BOOL fOn)
	{
		VSL_DEFINE_MOCK_METHOD(DelayRedraw)

		VSL_CHECK_VALIDVALUE(fOn);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryItemVisibleValidValues
	{
		/*[in]*/ ULONG AbsIndex;
		/*[out]*/ BOOL* pfVisible;
		HRESULT retValue;
	};

	STDMETHOD(QueryItemVisible)(
		/*[in]*/ ULONG AbsIndex,
		/*[out]*/ BOOL* pfVisible)
	{
		VSL_DEFINE_MOCK_METHOD(QueryItemVisible)

		VSL_CHECK_VALIDVALUE(AbsIndex);

		VSL_SET_VALIDVALUE(pfVisible);

		VSL_RETURN_VALIDVALUES();
	}
	struct InitValidValues
	{
		/*[in]*/ VSLITETREEOPTS grfOpts;
		HRESULT retValue;
	};

	STDMETHOD(Init)(
		/*[in]*/ VSLITETREEOPTS grfOpts)
	{
		VSL_DEFINE_MOCK_METHOD(Init)

		VSL_CHECK_VALIDVALUE(grfOpts);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetInitFlagsValidValues
	{
		/*[out]*/ VSLITETREEOPTS* pgrfOpts;
		HRESULT retValue;
	};

	STDMETHOD(GetInitFlags)(
		/*[out]*/ VSLITETREEOPTS* pgrfOpts)
	{
		VSL_DEFINE_MOCK_METHOD(GetInitFlags)

		VSL_SET_VALIDVALUE(pgrfOpts);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSLITETREE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsMacroRecorder.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSMACRORECORDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSMACRORECORDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vbapkg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsMacroRecorderNotImpl :
	public IVsMacroRecorder
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsMacroRecorderNotImpl)

public:

	typedef IVsMacroRecorder Interface;

	STDMETHOD(RecordStart)(
		/*[in]*/ LPCOLESTR /*pszReserved*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RecordEnd)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RecordLine)(
		/*[in]*/ LPCOLESTR /*pszLine*/,
		/*[in]*/ REFGUID /*rguidEmitter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLastEmitterId)(
		/*[out]*/ GUID* /*pguidEmitter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReplaceLine)(
		/*[in]*/ LPCOLESTR /*pszLine*/,
		/*[in]*/ REFGUID /*rguidEmitter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RecordCancel)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RecordPause)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RecordResume)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetCodeEmittedFlag)(
		/*[in]*/ BOOL /*fFlag*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCodeEmittedFlag)(
		/*[out]*/ BOOL* /*pfFlag*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetKeyWord)(
		/*[in]*/ UINT /*uiKeyWordId*/,
		/*[out]*/ BSTR* /*pbstrKeyWord*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsValidIdentifier)(
		/*[in]*/ LPCOLESTR /*pszIdentifier*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetRecordMode)(
		/*[out]*/ VSRECORDMODE* /*peRecordMode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetRecordMode)(
		/*[in]*/ VSRECORDMODE /*eRecordMode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetStringLiteralExpression)(
		/*[in]*/ LPCOLESTR /*pszStringValue*/,
		/*[out]*/ BSTR* /*pbstrLiteralExpression*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ExecuteLine)(
		/*[in]*/ LPCOLESTR /*pszLine*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddTypeLibRef)(
		/*[in]*/ REFGUID /*guidTypeLib*/,
		/*[in]*/ UINT /*uVerMaj*/,
		/*[in]*/ UINT /*uVerMin*/)VSL_STDMETHOD_NOTIMPL
};

class IVsMacroRecorderMockImpl :
	public IVsMacroRecorder,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsMacroRecorderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsMacroRecorderMockImpl)

	typedef IVsMacroRecorder Interface;
	struct RecordStartValidValues
	{
		/*[in]*/ LPCOLESTR pszReserved;
		HRESULT retValue;
	};

	STDMETHOD(RecordStart)(
		/*[in]*/ LPCOLESTR pszReserved)
	{
		VSL_DEFINE_MOCK_METHOD(RecordStart)

		VSL_CHECK_VALIDVALUE_STRINGW(pszReserved);

		VSL_RETURN_VALIDVALUES();
	}
	struct RecordEndValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(RecordEnd)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(RecordEnd)

		VSL_RETURN_VALIDVALUES();
	}
	struct RecordLineValidValues
	{
		/*[in]*/ LPCOLESTR pszLine;
		/*[in]*/ REFGUID rguidEmitter;
		HRESULT retValue;
	};

	STDMETHOD(RecordLine)(
		/*[in]*/ LPCOLESTR pszLine,
		/*[in]*/ REFGUID rguidEmitter)
	{
		VSL_DEFINE_MOCK_METHOD(RecordLine)

		VSL_CHECK_VALIDVALUE_STRINGW(pszLine);

		VSL_CHECK_VALIDVALUE(rguidEmitter);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLastEmitterIdValidValues
	{
		/*[out]*/ GUID* pguidEmitter;
		HRESULT retValue;
	};

	STDMETHOD(GetLastEmitterId)(
		/*[out]*/ GUID* pguidEmitter)
	{
		VSL_DEFINE_MOCK_METHOD(GetLastEmitterId)

		VSL_SET_VALIDVALUE(pguidEmitter);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReplaceLineValidValues
	{
		/*[in]*/ LPCOLESTR pszLine;
		/*[in]*/ REFGUID rguidEmitter;
		HRESULT retValue;
	};

	STDMETHOD(ReplaceLine)(
		/*[in]*/ LPCOLESTR pszLine,
		/*[in]*/ REFGUID rguidEmitter)
	{
		VSL_DEFINE_MOCK_METHOD(ReplaceLine)

		VSL_CHECK_VALIDVALUE_STRINGW(pszLine);

		VSL_CHECK_VALIDVALUE(rguidEmitter);

		VSL_RETURN_VALIDVALUES();
	}
	struct RecordCancelValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(RecordCancel)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(RecordCancel)

		VSL_RETURN_VALIDVALUES();
	}
	struct RecordPauseValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(RecordPause)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(RecordPause)

		VSL_RETURN_VALIDVALUES();
	}
	struct RecordResumeValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(RecordResume)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(RecordResume)

		VSL_RETURN_VALIDVALUES();
	}
	struct SetCodeEmittedFlagValidValues
	{
		/*[in]*/ BOOL fFlag;
		HRESULT retValue;
	};

	STDMETHOD(SetCodeEmittedFlag)(
		/*[in]*/ BOOL fFlag)
	{
		VSL_DEFINE_MOCK_METHOD(SetCodeEmittedFlag)

		VSL_CHECK_VALIDVALUE(fFlag);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCodeEmittedFlagValidValues
	{
		/*[out]*/ BOOL* pfFlag;
		HRESULT retValue;
	};

	STDMETHOD(GetCodeEmittedFlag)(
		/*[out]*/ BOOL* pfFlag)
	{
		VSL_DEFINE_MOCK_METHOD(GetCodeEmittedFlag)

		VSL_SET_VALIDVALUE(pfFlag);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetKeyWordValidValues
	{
		/*[in]*/ UINT uiKeyWordId;
		/*[out]*/ BSTR* pbstrKeyWord;
		HRESULT retValue;
	};

	STDMETHOD(GetKeyWord)(
		/*[in]*/ UINT uiKeyWordId,
		/*[out]*/ BSTR* pbstrKeyWord)
	{
		VSL_DEFINE_MOCK_METHOD(GetKeyWord)

		VSL_CHECK_VALIDVALUE(uiKeyWordId);

		VSL_SET_VALIDVALUE_BSTR(pbstrKeyWord);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsValidIdentifierValidValues
	{
		/*[in]*/ LPCOLESTR pszIdentifier;
		HRESULT retValue;
	};

	STDMETHOD(IsValidIdentifier)(
		/*[in]*/ LPCOLESTR pszIdentifier)
	{
		VSL_DEFINE_MOCK_METHOD(IsValidIdentifier)

		VSL_CHECK_VALIDVALUE_STRINGW(pszIdentifier);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetRecordModeValidValues
	{
		/*[out]*/ VSRECORDMODE* peRecordMode;
		HRESULT retValue;
	};

	STDMETHOD(GetRecordMode)(
		/*[out]*/ VSRECORDMODE* peRecordMode)
	{
		VSL_DEFINE_MOCK_METHOD(GetRecordMode)

		VSL_SET_VALIDVALUE(peRecordMode);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetRecordModeValidValues
	{
		/*[in]*/ VSRECORDMODE eRecordMode;
		HRESULT retValue;
	};

	STDMETHOD(SetRecordMode)(
		/*[in]*/ VSRECORDMODE eRecordMode)
	{
		VSL_DEFINE_MOCK_METHOD(SetRecordMode)

		VSL_CHECK_VALIDVALUE(eRecordMode);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetStringLiteralExpressionValidValues
	{
		/*[in]*/ LPCOLESTR pszStringValue;
		/*[out]*/ BSTR* pbstrLiteralExpression;
		HRESULT retValue;
	};

	STDMETHOD(GetStringLiteralExpression)(
		/*[in]*/ LPCOLESTR pszStringValue,
		/*[out]*/ BSTR* pbstrLiteralExpression)
	{
		VSL_DEFINE_MOCK_METHOD(GetStringLiteralExpression)

		VSL_CHECK_VALIDVALUE_STRINGW(pszStringValue);

		VSL_SET_VALIDVALUE_BSTR(pbstrLiteralExpression);

		VSL_RETURN_VALIDVALUES();
	}
	struct ExecuteLineValidValues
	{
		/*[in]*/ LPCOLESTR pszLine;
		HRESULT retValue;
	};

	STDMETHOD(ExecuteLine)(
		/*[in]*/ LPCOLESTR pszLine)
	{
		VSL_DEFINE_MOCK_METHOD(ExecuteLine)

		VSL_CHECK_VALIDVALUE_STRINGW(pszLine);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddTypeLibRefValidValues
	{
		/*[in]*/ REFGUID guidTypeLib;
		/*[in]*/ UINT uVerMaj;
		/*[in]*/ UINT uVerMin;
		HRESULT retValue;
	};

	STDMETHOD(AddTypeLibRef)(
		/*[in]*/ REFGUID guidTypeLib,
		/*[in]*/ UINT uVerMaj,
		/*[in]*/ UINT uVerMin)
	{
		VSL_DEFINE_MOCK_METHOD(AddTypeLibRef)

		VSL_CHECK_VALIDVALUE(guidTypeLib);

		VSL_CHECK_VALIDVALUE(uVerMaj);

		VSL_CHECK_VALIDVALUE(uVerMin);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSMACRORECORDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsLiteTreeList.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSLITETREELIST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSLITETREELIST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsLiteTreeListNotImpl :
	public IVsLiteTreeList
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLiteTreeListNotImpl)

public:

	typedef IVsLiteTreeList Interface;

	STDMETHOD(GetFlags)(
		/*[out]*/ VSTREEFLAGS* /*pFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetItemCount)(
		/*[out]*/ ULONG* /*pCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExpandedList)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ BOOL* /*pfCanRecurse*/,
		/*[out]*/ IVsLiteTreeList** /*pptlNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LocateExpandedList)(
		/*[in]*/ IVsLiteTreeList* /*ExpandedList*/,
		/*[out]*/ ULONG* /*iIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnClose)(
		/*[out]*/ VSTREECLOSEACTIONS* /*ptca*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetText)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSTREETEXTOPTIONS /*tto*/,
		/*[out]*/ const WCHAR** /*ppszText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTipText)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSTREETOOLTIPTYPE /*eTipType*/,
		/*[out]*/ const WCHAR** /*ppszText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExpandable)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ BOOL* /*pfExpandable*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDisplayData)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ VSTREEDISPLAYDATA* /*pData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateCounter)(
		/*[out]*/ ULONG* /*pCurUpdate*/,
		/*[out]*/ VSTREEITEMCHANGESMASK* /*pgrfChanges*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetListChanges)(
		/*[in,out]*/ ULONG* /*pcChanges*/,
		/*[in,size_is(*pcChanges)]*/ VSTREELISTITEMCHANGE* /*prgListChanges*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ToggleState)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ VSTREESTATECHANGEREFRESH* /*ptscr*/)VSL_STDMETHOD_NOTIMPL
};

class IVsLiteTreeListMockImpl :
	public IVsLiteTreeList,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLiteTreeListMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsLiteTreeListMockImpl)

	typedef IVsLiteTreeList Interface;
	struct GetFlagsValidValues
	{
		/*[out]*/ VSTREEFLAGS* pFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetFlags)(
		/*[out]*/ VSTREEFLAGS* pFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetFlags)

		VSL_SET_VALIDVALUE(pFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetItemCountValidValues
	{
		/*[out]*/ ULONG* pCount;
		HRESULT retValue;
	};

	STDMETHOD(GetItemCount)(
		/*[out]*/ ULONG* pCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetItemCount)

		VSL_SET_VALIDVALUE(pCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExpandedListValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ BOOL* pfCanRecurse;
		/*[out]*/ IVsLiteTreeList** pptlNode;
		HRESULT retValue;
	};

	STDMETHOD(GetExpandedList)(
		/*[in]*/ ULONG Index,
		/*[out]*/ BOOL* pfCanRecurse,
		/*[out]*/ IVsLiteTreeList** pptlNode)
	{
		VSL_DEFINE_MOCK_METHOD(GetExpandedList)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE(pfCanRecurse);

		VSL_SET_VALIDVALUE_INTERFACE(pptlNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct LocateExpandedListValidValues
	{
		/*[in]*/ IVsLiteTreeList* ExpandedList;
		/*[out]*/ ULONG* iIndex;
		HRESULT retValue;
	};

	STDMETHOD(LocateExpandedList)(
		/*[in]*/ IVsLiteTreeList* ExpandedList,
		/*[out]*/ ULONG* iIndex)
	{
		VSL_DEFINE_MOCK_METHOD(LocateExpandedList)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(ExpandedList);

		VSL_SET_VALIDVALUE(iIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnCloseValidValues
	{
		/*[out]*/ VSTREECLOSEACTIONS* ptca;
		HRESULT retValue;
	};

	STDMETHOD(OnClose)(
		/*[out]*/ VSTREECLOSEACTIONS* ptca)
	{
		VSL_DEFINE_MOCK_METHOD(OnClose)

		VSL_SET_VALIDVALUE(ptca);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTextValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSTREETEXTOPTIONS tto;
		/*[out]*/ WCHAR** ppszText;
		HRESULT retValue;
	};

	STDMETHOD(GetText)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSTREETEXTOPTIONS tto,
		/*[out]*/ const WCHAR** ppszText)
	{
		VSL_DEFINE_MOCK_METHOD(GetText)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(tto);

		VSL_SET_VALIDVALUE_CONST(ppszText, WCHAR**);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTipTextValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSTREETOOLTIPTYPE eTipType;
		/*[out]*/ WCHAR** ppszText;
		HRESULT retValue;
	};

	STDMETHOD(GetTipText)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSTREETOOLTIPTYPE eTipType,
		/*[out]*/ const WCHAR** ppszText)
	{
		VSL_DEFINE_MOCK_METHOD(GetTipText)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(eTipType);

		VSL_SET_VALIDVALUE_CONST(ppszText, WCHAR**);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExpandableValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ BOOL* pfExpandable;
		HRESULT retValue;
	};

	STDMETHOD(GetExpandable)(
		/*[in]*/ ULONG Index,
		/*[out]*/ BOOL* pfExpandable)
	{
		VSL_DEFINE_MOCK_METHOD(GetExpandable)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE(pfExpandable);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDisplayDataValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ VSTREEDISPLAYDATA* pData;
		HRESULT retValue;
	};

	STDMETHOD(GetDisplayData)(
		/*[in]*/ ULONG Index,
		/*[out]*/ VSTREEDISPLAYDATA* pData)
	{
		VSL_DEFINE_MOCK_METHOD(GetDisplayData)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE(pData);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateCounterValidValues
	{
		/*[out]*/ ULONG* pCurUpdate;
		/*[out]*/ VSTREEITEMCHANGESMASK* pgrfChanges;
		HRESULT retValue;
	};

	STDMETHOD(UpdateCounter)(
		/*[out]*/ ULONG* pCurUpdate,
		/*[out]*/ VSTREEITEMCHANGESMASK* pgrfChanges)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateCounter)

		VSL_SET_VALIDVALUE(pCurUpdate);

		VSL_SET_VALIDVALUE(pgrfChanges);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetListChangesValidValues
	{
		/*[in,out]*/ ULONG* pcChanges;
		/*[in,size_is(*pcChanges)]*/ VSTREELISTITEMCHANGE* prgListChanges;
		HRESULT retValue;
	};

	STDMETHOD(GetListChanges)(
		/*[in,out]*/ ULONG* pcChanges,
		/*[in,size_is(*pcChanges)]*/ VSTREELISTITEMCHANGE* prgListChanges)
	{
		VSL_DEFINE_MOCK_METHOD(GetListChanges)

		VSL_SET_VALIDVALUE(pcChanges);

		VSL_CHECK_VALIDVALUE_MEMCMP(prgListChanges, *pcChanges*sizeof(prgListChanges[0]), *(validValues.pcChanges)*sizeof(validValues.prgListChanges[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct ToggleStateValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ VSTREESTATECHANGEREFRESH* ptscr;
		HRESULT retValue;
	};

	STDMETHOD(ToggleState)(
		/*[in]*/ ULONG Index,
		/*[out]*/ VSTREESTATECHANGEREFRESH* ptscr)
	{
		VSL_DEFINE_MOCK_METHOD(ToggleState)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE(ptscr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSLITETREELIST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsLinkedUndoClient.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSLINKEDUNDOCLIENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSLINKEDUNDOCLIENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsLinkedUndoClientNotImpl :
	public IVsLinkedUndoClient
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLinkedUndoClientNotImpl)

public:

	typedef IVsLinkedUndoClient Interface;

	STDMETHOD(OnInterveningUnitBlockingLinkedUndo)()VSL_STDMETHOD_NOTIMPL
};

class IVsLinkedUndoClientMockImpl :
	public IVsLinkedUndoClient,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLinkedUndoClientMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsLinkedUndoClientMockImpl)

	typedef IVsLinkedUndoClient Interface;
	struct OnInterveningUnitBlockingLinkedUndoValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnInterveningUnitBlockingLinkedUndo)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnInterveningUnitBlockingLinkedUndo)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSLINKEDUNDOCLIENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsLinkedUndoTransactionManager.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSLINKEDUNDOTRANSACTIONMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSLINKEDUNDOTRANSACTIONMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsLinkedUndoTransactionManagerNotImpl :
	public IVsLinkedUndoTransactionManager
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLinkedUndoTransactionManagerNotImpl)

public:

	typedef IVsLinkedUndoTransactionManager Interface;

	STDMETHOD(OpenLinkedUndo)(
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in]*/ const WCHAR* /*pszDescription*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CloseLinkedUndo)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AbortLinkedUndo)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsAborted)(
		/*[in]*/ BOOL* /*pfAborted*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsStrict)(
		/*[in]*/ BOOL* /*pfStrict*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CountOpenTransactions)(
		/*[in]*/ long* /*pCount*/)VSL_STDMETHOD_NOTIMPL
};

class IVsLinkedUndoTransactionManagerMockImpl :
	public IVsLinkedUndoTransactionManager,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsLinkedUndoTransactionManagerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsLinkedUndoTransactionManagerMockImpl)

	typedef IVsLinkedUndoTransactionManager Interface;
	struct OpenLinkedUndoValidValues
	{
		/*[in]*/ DWORD dwFlags;
		/*[in]*/ WCHAR* pszDescription;
		HRESULT retValue;
	};

	STDMETHOD(OpenLinkedUndo)(
		/*[in]*/ DWORD dwFlags,
		/*[in]*/ const WCHAR* pszDescription)
	{
		VSL_DEFINE_MOCK_METHOD(OpenLinkedUndo)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE_STRINGW(pszDescription);

		VSL_RETURN_VALIDVALUES();
	}
	struct CloseLinkedUndoValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CloseLinkedUndo)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CloseLinkedUndo)

		VSL_RETURN_VALIDVALUES();
	}
	struct AbortLinkedUndoValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(AbortLinkedUndo)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(AbortLinkedUndo)

		VSL_RETURN_VALIDVALUES();
	}
	struct IsAbortedValidValues
	{
		/*[in]*/ BOOL* pfAborted;
		HRESULT retValue;
	};

	STDMETHOD(IsAborted)(
		/*[in]*/ BOOL* pfAborted)
	{
		VSL_DEFINE_MOCK_METHOD(IsAborted)

		VSL_CHECK_VALIDVALUE_POINTER(pfAborted);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsStrictValidValues
	{
		/*[in]*/ BOOL* pfStrict;
		HRESULT retValue;
	};

	STDMETHOD(IsStrict)(
		/*[in]*/ BOOL* pfStrict)
	{
		VSL_DEFINE_MOCK_METHOD(IsStrict)

		VSL_CHECK_VALIDVALUE_POINTER(pfStrict);

		VSL_RETURN_VALIDVALUES();
	}
	struct CountOpenTransactionsValidValues
	{
		/*[in]*/ long* pCount;
		HRESULT retValue;
	};

	STDMETHOD(CountOpenTransactions)(
		/*[in]*/ long* pCount)
	{
		VSL_DEFINE_MOCK_METHOD(CountOpenTransactions)

		VSL_CHECK_VALIDVALUE_POINTER(pCount);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSLINKEDUNDOTRANSACTIONMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsMenuEditor.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSMENUEDITOR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSMENUEDITOR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsMenuEditorNotImpl :
	public IVsMenuEditor
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsMenuEditorNotImpl)

public:

	typedef IVsMenuEditor Interface;

	STDMETHOD(AddMenuItem)(
		/*[in]*/ IVsMenuItem* /*pIMI*/,
		/*[in]*/ IVsMenuItem* /*pIMIParent*/,
		/*[in]*/ IVsMenuItem* /*pIMIInsertAfter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnChange)(
		/*[in]*/ IVsMenuItem* /*pIMI*/,
		/*[in]*/ VSMEPROPID /*PropId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SelectionChange)(
		/*[in]*/ IVsMenuItem* /*pIMI*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetItemRect)(
		/*[in]*/ IVsMenuItem* /*pIMI*/,
		/*[out]*/ LPRECT /*prc*/,
		/*[in]*/ BOOL /*fForScrolling*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetHeight)(
		/*[out]*/ INT* /*piHeight*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Filter)(
		/*[in]*/ HWND /*hwnd*/,
		/*[in]*/ UINT /*uMsg*/,
		/*[in]*/ WPARAM /*wParam*/,
		/*[in]*/ LPARAM /*lParam*/,
		/*[out]*/ LRESULT* /*plResult*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsActive)(
		/*[out,retval]*/ BOOL* /*pfActive*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetUIState)(
		/*[out,retval]*/ VSMEUISTATE* /*pState*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DeleteMenuItem)(
		/*[in]*/ IVsMenuItem* /*pIMI*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SelectionChangeFocus)(
		/*[in]*/ IVsMenuItem* /*pIMI*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(TranslateAccelerator)(
		/*[in]*/ LPMSG /*lpMsg*/)VSL_STDMETHOD_NOTIMPL
};

class IVsMenuEditorMockImpl :
	public IVsMenuEditor,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsMenuEditorMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsMenuEditorMockImpl)

	typedef IVsMenuEditor Interface;
	struct AddMenuItemValidValues
	{
		/*[in]*/ IVsMenuItem* pIMI;
		/*[in]*/ IVsMenuItem* pIMIParent;
		/*[in]*/ IVsMenuItem* pIMIInsertAfter;
		HRESULT retValue;
	};

	STDMETHOD(AddMenuItem)(
		/*[in]*/ IVsMenuItem* pIMI,
		/*[in]*/ IVsMenuItem* pIMIParent,
		/*[in]*/ IVsMenuItem* pIMIInsertAfter)
	{
		VSL_DEFINE_MOCK_METHOD(AddMenuItem)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIMI);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIMIParent);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIMIInsertAfter);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnChangeValidValues
	{
		/*[in]*/ IVsMenuItem* pIMI;
		/*[in]*/ VSMEPROPID PropId;
		HRESULT retValue;
	};

	STDMETHOD(OnChange)(
		/*[in]*/ IVsMenuItem* pIMI,
		/*[in]*/ VSMEPROPID PropId)
	{
		VSL_DEFINE_MOCK_METHOD(OnChange)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIMI);

		VSL_CHECK_VALIDVALUE(PropId);

		VSL_RETURN_VALIDVALUES();
	}
	struct SelectionChangeValidValues
	{
		/*[in]*/ IVsMenuItem* pIMI;
		HRESULT retValue;
	};

	STDMETHOD(SelectionChange)(
		/*[in]*/ IVsMenuItem* pIMI)
	{
		VSL_DEFINE_MOCK_METHOD(SelectionChange)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIMI);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetItemRectValidValues
	{
		/*[in]*/ IVsMenuItem* pIMI;
		/*[out]*/ LPRECT prc;
		/*[in]*/ BOOL fForScrolling;
		HRESULT retValue;
	};

	STDMETHOD(GetItemRect)(
		/*[in]*/ IVsMenuItem* pIMI,
		/*[out]*/ LPRECT prc,
		/*[in]*/ BOOL fForScrolling)
	{
		VSL_DEFINE_MOCK_METHOD(GetItemRect)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIMI);

		VSL_SET_VALIDVALUE(prc);

		VSL_CHECK_VALIDVALUE(fForScrolling);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetHeightValidValues
	{
		/*[out]*/ INT* piHeight;
		HRESULT retValue;
	};

	STDMETHOD(GetHeight)(
		/*[out]*/ INT* piHeight)
	{
		VSL_DEFINE_MOCK_METHOD(GetHeight)

		VSL_SET_VALIDVALUE(piHeight);

		VSL_RETURN_VALIDVALUES();
	}
	struct FilterValidValues
	{
		/*[in]*/ HWND hwnd;
		/*[in]*/ UINT uMsg;
		/*[in]*/ WPARAM wParam;
		/*[in]*/ LPARAM lParam;
		/*[out]*/ LRESULT* plResult;
		HRESULT retValue;
	};

	STDMETHOD(Filter)(
		/*[in]*/ HWND hwnd,
		/*[in]*/ UINT uMsg,
		/*[in]*/ WPARAM wParam,
		/*[in]*/ LPARAM lParam,
		/*[out]*/ LRESULT* plResult)
	{
		VSL_DEFINE_MOCK_METHOD(Filter)

		VSL_CHECK_VALIDVALUE(hwnd);

		VSL_CHECK_VALIDVALUE(uMsg);

		VSL_CHECK_VALIDVALUE(wParam);

		VSL_CHECK_VALIDVALUE(lParam);

		VSL_SET_VALIDVALUE(plResult);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsActiveValidValues
	{
		/*[out,retval]*/ BOOL* pfActive;
		HRESULT retValue;
	};

	STDMETHOD(IsActive)(
		/*[out,retval]*/ BOOL* pfActive)
	{
		VSL_DEFINE_MOCK_METHOD(IsActive)

		VSL_SET_VALIDVALUE(pfActive);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetUIStateValidValues
	{
		/*[out,retval]*/ VSMEUISTATE* pState;
		HRESULT retValue;
	};

	STDMETHOD(GetUIState)(
		/*[out,retval]*/ VSMEUISTATE* pState)
	{
		VSL_DEFINE_MOCK_METHOD(GetUIState)

		VSL_SET_VALIDVALUE(pState);

		VSL_RETURN_VALIDVALUES();
	}
	struct DeleteMenuItemValidValues
	{
		/*[in]*/ IVsMenuItem* pIMI;
		HRESULT retValue;
	};

	STDMETHOD(DeleteMenuItem)(
		/*[in]*/ IVsMenuItem* pIMI)
	{
		VSL_DEFINE_MOCK_METHOD(DeleteMenuItem)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIMI);

		VSL_RETURN_VALIDVALUES();
	}
	struct SelectionChangeFocusValidValues
	{
		/*[in]*/ IVsMenuItem* pIMI;
		HRESULT retValue;
	};

	STDMETHOD(SelectionChangeFocus)(
		/*[in]*/ IVsMenuItem* pIMI)
	{
		VSL_DEFINE_MOCK_METHOD(SelectionChangeFocus)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIMI);

		VSL_RETURN_VALIDVALUES();
	}
	struct TranslateAcceleratorValidValues
	{
		/*[in]*/ LPMSG lpMsg;
		HRESULT retValue;
	};

	STDMETHOD(TranslateAccelerator)(
		/*[in]*/ LPMSG lpMsg)
	{
		VSL_DEFINE_MOCK_METHOD(TranslateAccelerator)

		VSL_CHECK_VALIDVALUE(lpMsg);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSMENUEDITOR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVSMDDesignerService.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSMDDESIGNERSERVICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSMDDESIGNERSERVICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsmanaged.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVSMDDesignerServiceNotImpl :
	public IVSMDDesignerService
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVSMDDesignerServiceNotImpl)

public:

	typedef IVSMDDesignerService Interface;

	STDMETHOD(get_DesignViewAttribute)(
		/*[out,retval]*/ BSTR* /*pbstrAttribute*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateDesigner)(
		/*[in]*/ IServiceProvider* /*pSp*/,
		/*[in]*/ IUnknown* /*pDesignerLoader*/,
		/*[out,retval]*/ IVSMDDesigner** /*ppDesigner*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateDesignerForClass)(
		/*[in]*/ IServiceProvider* /*pSp*/,
		/*[in]*/ LPCOLESTR /*pwszComponentClass*/,
		/*[out,retval]*/ IVSMDDesigner** /*ppDesigner*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateDesignerLoader)(
		/*[in]*/ LPCOLESTR /*pwszCodeStreamClass*/,
		/*[out,retval]*/ IUnknown** /*ppCodeStream*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDesignerLoaderClassForFile)(
		/*[in]*/ LPCOLESTR /*pwszFileName*/,
		/*[out,retval]*/ BSTR* /*pbstrDesignerLoaderClass*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RegisterDesignViewAttribute)(
		/*[in]*/ IVsHierarchy* /*pHier*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ int /*dwClass*/,
		/*[in]*/ LPOLESTR /*pwszAttributeValue*/)VSL_STDMETHOD_NOTIMPL
};

class IVSMDDesignerServiceMockImpl :
	public IVSMDDesignerService,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVSMDDesignerServiceMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVSMDDesignerServiceMockImpl)

	typedef IVSMDDesignerService Interface;
	struct get_DesignViewAttributeValidValues
	{
		/*[out,retval]*/ BSTR* pbstrAttribute;
		HRESULT retValue;
	};

	STDMETHOD(get_DesignViewAttribute)(
		/*[out,retval]*/ BSTR* pbstrAttribute)
	{
		VSL_DEFINE_MOCK_METHOD(get_DesignViewAttribute)

		VSL_SET_VALIDVALUE_BSTR(pbstrAttribute);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateDesignerValidValues
	{
		/*[in]*/ IServiceProvider* pSp;
		/*[in]*/ IUnknown* pDesignerLoader;
		/*[out,retval]*/ IVSMDDesigner** ppDesigner;
		HRESULT retValue;
	};

	STDMETHOD(CreateDesigner)(
		/*[in]*/ IServiceProvider* pSp,
		/*[in]*/ IUnknown* pDesignerLoader,
		/*[out,retval]*/ IVSMDDesigner** ppDesigner)
	{
		VSL_DEFINE_MOCK_METHOD(CreateDesigner)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSp);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDesignerLoader);

		VSL_SET_VALIDVALUE_INTERFACE(ppDesigner);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateDesignerForClassValidValues
	{
		/*[in]*/ IServiceProvider* pSp;
		/*[in]*/ LPCOLESTR pwszComponentClass;
		/*[out,retval]*/ IVSMDDesigner** ppDesigner;
		HRESULT retValue;
	};

	STDMETHOD(CreateDesignerForClass)(
		/*[in]*/ IServiceProvider* pSp,
		/*[in]*/ LPCOLESTR pwszComponentClass,
		/*[out,retval]*/ IVSMDDesigner** ppDesigner)
	{
		VSL_DEFINE_MOCK_METHOD(CreateDesignerForClass)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSp);

		VSL_CHECK_VALIDVALUE_STRINGW(pwszComponentClass);

		VSL_SET_VALIDVALUE_INTERFACE(ppDesigner);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateDesignerLoaderValidValues
	{
		/*[in]*/ LPCOLESTR pwszCodeStreamClass;
		/*[out,retval]*/ IUnknown** ppCodeStream;
		HRESULT retValue;
	};

	STDMETHOD(CreateDesignerLoader)(
		/*[in]*/ LPCOLESTR pwszCodeStreamClass,
		/*[out,retval]*/ IUnknown** ppCodeStream)
	{
		VSL_DEFINE_MOCK_METHOD(CreateDesignerLoader)

		VSL_CHECK_VALIDVALUE_STRINGW(pwszCodeStreamClass);

		VSL_SET_VALIDVALUE_INTERFACE(ppCodeStream);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDesignerLoaderClassForFileValidValues
	{
		/*[in]*/ LPCOLESTR pwszFileName;
		/*[out,retval]*/ BSTR* pbstrDesignerLoaderClass;
		HRESULT retValue;
	};

	STDMETHOD(GetDesignerLoaderClassForFile)(
		/*[in]*/ LPCOLESTR pwszFileName,
		/*[out,retval]*/ BSTR* pbstrDesignerLoaderClass)
	{
		VSL_DEFINE_MOCK_METHOD(GetDesignerLoaderClassForFile)

		VSL_CHECK_VALIDVALUE_STRINGW(pwszFileName);

		VSL_SET_VALIDVALUE_BSTR(pbstrDesignerLoaderClass);

		VSL_RETURN_VALIDVALUES();
	}
	struct RegisterDesignViewAttributeValidValues
	{
		/*[in]*/ IVsHierarchy* pHier;
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ int dwClass;
		/*[in]*/ LPOLESTR pwszAttributeValue;
		HRESULT retValue;
	};

	STDMETHOD(RegisterDesignViewAttribute)(
		/*[in]*/ IVsHierarchy* pHier,
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ int dwClass,
		/*[in]*/ LPOLESTR pwszAttributeValue)
	{
		VSL_DEFINE_MOCK_METHOD(RegisterDesignViewAttribute)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHier);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE(dwClass);

		VSL_CHECK_VALIDVALUE_STRINGW(pwszAttributeValue);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSMDDESIGNERSERVICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVSMDTypeResolutionService.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSMDTYPERESOLUTIONSERVICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSMDTYPERESOLUTIONSERVICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVSMDTypeResolutionServiceNotImpl :
	public IVSMDTypeResolutionService
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVSMDTypeResolutionServiceNotImpl)

public:

	typedef IVSMDTypeResolutionService Interface;

	STDMETHOD(get_TypeResolutionService)(
		/*[out,retval]*/ IDispatch** /*ppTrs*/)VSL_STDMETHOD_NOTIMPL
};

class IVSMDTypeResolutionServiceMockImpl :
	public IVSMDTypeResolutionService,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVSMDTypeResolutionServiceMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVSMDTypeResolutionServiceMockImpl)

	typedef IVSMDTypeResolutionService Interface;
	struct get_TypeResolutionServiceValidValues
	{
		/*[out,retval]*/ IDispatch** ppTrs;
		HRESULT retValue;
	};

	STDMETHOD(get_TypeResolutionService)(
		/*[out,retval]*/ IDispatch** ppTrs)
	{
		VSL_DEFINE_MOCK_METHOD(get_TypeResolutionService)

		VSL_SET_VALIDVALUE_INTERFACE(ppTrs);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSMDTYPERESOLUTIONSERVICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVSMDDesignerLoader.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSMDDESIGNERLOADER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSMDDESIGNERLOADER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsmanaged.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVSMDDesignerLoaderNotImpl :
	public IVSMDDesignerLoader
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVSMDDesignerLoaderNotImpl)

public:

	typedef IVSMDDesignerLoader Interface;

	STDMETHOD(Dispose)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEditorCaption)(
		/*[in]*/ READONLYSTATUS /*status*/,
		/*[out,retval]*/ BSTR* /*pbstrCaption*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Initialize)(
		/*[in]*/ IServiceProvider* /*pSp*/,
		/*[in]*/ IVsHierarchy* /*pHier*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ IUnknown* /*pDocData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetBaseEditorCaption)(
		/*[in]*/ LPCOLESTR /*pwszCaption*/)VSL_STDMETHOD_NOTIMPL
};

class IVSMDDesignerLoaderMockImpl :
	public IVSMDDesignerLoader,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVSMDDesignerLoaderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVSMDDesignerLoaderMockImpl)

	typedef IVSMDDesignerLoader Interface;
	struct DisposeValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Dispose)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Dispose)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEditorCaptionValidValues
	{
		/*[in]*/ READONLYSTATUS status;
		/*[out,retval]*/ BSTR* pbstrCaption;
		HRESULT retValue;
	};

	STDMETHOD(GetEditorCaption)(
		/*[in]*/ READONLYSTATUS status,
		/*[out,retval]*/ BSTR* pbstrCaption)
	{
		VSL_DEFINE_MOCK_METHOD(GetEditorCaption)

		VSL_CHECK_VALIDVALUE(status);

		VSL_SET_VALIDVALUE_BSTR(pbstrCaption);

		VSL_RETURN_VALIDVALUES();
	}
	struct InitializeValidValues
	{
		/*[in]*/ IServiceProvider* pSp;
		/*[in]*/ IVsHierarchy* pHier;
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ IUnknown* pDocData;
		HRESULT retValue;
	};

	STDMETHOD(Initialize)(
		/*[in]*/ IServiceProvider* pSp,
		/*[in]*/ IVsHierarchy* pHier,
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ IUnknown* pDocData)
	{
		VSL_DEFINE_MOCK_METHOD(Initialize)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSp);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHier);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDocData);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetBaseEditorCaptionValidValues
	{
		/*[in]*/ LPCOLESTR pwszCaption;
		HRESULT retValue;
	};

	STDMETHOD(SetBaseEditorCaption)(
		/*[in]*/ LPCOLESTR pwszCaption)
	{
		VSL_DEFINE_MOCK_METHOD(SetBaseEditorCaption)

		VSL_CHECK_VALIDVALUE_STRINGW(pwszCaption);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSMDDESIGNERLOADER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVSMDCodeDomProvider.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSMDCODEDOMPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSMDCODEDOMPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsmanaged.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVSMDCodeDomProviderNotImpl :
	public IVSMDCodeDomProvider
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVSMDCodeDomProviderNotImpl)

public:

	typedef IVSMDCodeDomProvider Interface;

	STDMETHOD(get_CodeDomProvider)(
		/*[out,retval]*/ IDispatch** /*ppProvider*/)VSL_STDMETHOD_NOTIMPL
};

class IVSMDCodeDomProviderMockImpl :
	public IVSMDCodeDomProvider,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVSMDCodeDomProviderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVSMDCodeDomProviderMockImpl)

	typedef IVSMDCodeDomProvider Interface;
	struct get_CodeDomProviderValidValues
	{
		/*[out,retval]*/ IDispatch** ppProvider;
		HRESULT retValue;
	};

	STDMETHOD(get_CodeDomProvider)(
		/*[out,retval]*/ IDispatch** ppProvider)
	{
		VSL_DEFINE_MOCK_METHOD(get_CodeDomProvider)

		VSL_SET_VALIDVALUE_INTERFACE(ppProvider);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSMDCODEDOMPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVSMDPerPropertyBrowsing.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSMDPERPROPERTYBROWSING_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSMDPERPROPERTYBROWSING_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsmanaged.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVSMDPerPropertyBrowsingNotImpl :
	public IVSMDPerPropertyBrowsing
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVSMDPerPropertyBrowsingNotImpl)

public:

	typedef IVSMDPerPropertyBrowsing Interface;

	STDMETHOD(GetPropertyAttributes)(
		/*[in]*/ DISPID /*dispid*/,
		/*[out]*/ UINT* /*pceltAttrs*/,
		/*[out,size_is(,*pceltAttrs)]*/ BSTR** /*ppbstrTypeNames*/,
		/*[out,size_is(,*pceltAttrs)]*/ VARIANT** /*ppvarAttrValues*/)VSL_STDMETHOD_NOTIMPL
};

class IVSMDPerPropertyBrowsingMockImpl :
	public IVSMDPerPropertyBrowsing,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVSMDPerPropertyBrowsingMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVSMDPerPropertyBrowsingMockImpl)

	typedef IVSMDPerPropertyBrowsing Interface;
	struct GetPropertyAttributesValidValues
	{
		/*[in]*/ DISPID dispid;
		/*[out]*/ UINT* pceltAttrs;
		/*[out,size_is(,*pceltAttrs)]*/ BSTR** ppbstrTypeNames;
		/*[out,size_is(,*pceltAttrs)]*/ VARIANT** ppvarAttrValues;
		HRESULT retValue;
	};

	STDMETHOD(GetPropertyAttributes)(
		/*[in]*/ DISPID dispid,
		/*[out]*/ UINT* pceltAttrs,
		/*[out,size_is(,*pceltAttrs)]*/ BSTR** ppbstrTypeNames,
		/*[out,size_is(,*pceltAttrs)]*/ VARIANT** ppvarAttrValues)
	{
		VSL_DEFINE_MOCK_METHOD(GetPropertyAttributes)

		VSL_CHECK_VALIDVALUE(dispid);

		VSL_SET_VALIDVALUE(pceltAttrs);

		VSL_SET_VALIDVALUE_MEMCPY(ppbstrTypeNames, *pceltAttrs*sizeof(ppbstrTypeNames[0]), *(validValues.pceltAttrs)*sizeof(validValues.ppbstrTypeNames[0]));

		VSL_SET_VALIDVALUE_MEMCPY(ppvarAttrValues, *pceltAttrs*sizeof(ppvarAttrValues[0]), *(validValues.pceltAttrs)*sizeof(validValues.ppvarAttrValues[0]));

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSMDPERPROPERTYBROWSING_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVSMDDesigner.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSMDDESIGNER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSMDDESIGNER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsmanaged.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVSMDDesignerNotImpl :
	public IVSMDDesigner
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVSMDDesignerNotImpl)

public:

	typedef IVSMDDesigner Interface;

	STDMETHOD(get_CommandGuid)(
		/*[out,retval]*/ GUID* /*pguidCmdId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_View)(
		/*[out,retval]*/ IUnknown** /*pView*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_SelectionContainer)(
		/*[out,retval]*/ IUnknown** /*ppSelCon*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Dispose)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Flush)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLoadError)()VSL_STDMETHOD_NOTIMPL
};

class IVSMDDesignerMockImpl :
	public IVSMDDesigner,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVSMDDesignerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVSMDDesignerMockImpl)

	typedef IVSMDDesigner Interface;
	struct get_CommandGuidValidValues
	{
		/*[out,retval]*/ GUID* pguidCmdId;
		HRESULT retValue;
	};

	STDMETHOD(get_CommandGuid)(
		/*[out,retval]*/ GUID* pguidCmdId)
	{
		VSL_DEFINE_MOCK_METHOD(get_CommandGuid)

		VSL_SET_VALIDVALUE(pguidCmdId);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ViewValidValues
	{
		/*[out,retval]*/ IUnknown** pView;
		HRESULT retValue;
	};

	STDMETHOD(get_View)(
		/*[out,retval]*/ IUnknown** pView)
	{
		VSL_DEFINE_MOCK_METHOD(get_View)

		VSL_SET_VALIDVALUE_INTERFACE(pView);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_SelectionContainerValidValues
	{
		/*[out,retval]*/ IUnknown** ppSelCon;
		HRESULT retValue;
	};

	STDMETHOD(get_SelectionContainer)(
		/*[out,retval]*/ IUnknown** ppSelCon)
	{
		VSL_DEFINE_MOCK_METHOD(get_SelectionContainer)

		VSL_SET_VALIDVALUE_INTERFACE(ppSelCon);

		VSL_RETURN_VALIDVALUES();
	}
	struct DisposeValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Dispose)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Dispose)

		VSL_RETURN_VALIDVALUES();
	}
	struct FlushValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Flush)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Flush)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLoadErrorValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(GetLoadError)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(GetLoadError)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSMDDESIGNER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVSMDPropertyBrowser.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSMDPROPERTYBROWSER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSMDPROPERTYBROWSER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsmanaged.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVSMDPropertyBrowserNotImpl :
	public IVSMDPropertyBrowser
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVSMDPropertyBrowserNotImpl)

public:

	typedef IVSMDPropertyBrowser Interface;

	STDMETHOD(get_WindowGlyphResourceID)(
		/*[out,retval]*/ DWORD* /*pdwResID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreatePropertyGrid)(
		/*[out,retval]*/ IVSMDPropertyGrid** /*ppGrid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Refresh)()VSL_STDMETHOD_NOTIMPL
};

class IVSMDPropertyBrowserMockImpl :
	public IVSMDPropertyBrowser,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVSMDPropertyBrowserMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVSMDPropertyBrowserMockImpl)

	typedef IVSMDPropertyBrowser Interface;
	struct get_WindowGlyphResourceIDValidValues
	{
		/*[out,retval]*/ DWORD* pdwResID;
		HRESULT retValue;
	};

	STDMETHOD(get_WindowGlyphResourceID)(
		/*[out,retval]*/ DWORD* pdwResID)
	{
		VSL_DEFINE_MOCK_METHOD(get_WindowGlyphResourceID)

		VSL_SET_VALIDVALUE(pdwResID);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreatePropertyGridValidValues
	{
		/*[out,retval]*/ IVSMDPropertyGrid** ppGrid;
		HRESULT retValue;
	};

	STDMETHOD(CreatePropertyGrid)(
		/*[out,retval]*/ IVSMDPropertyGrid** ppGrid)
	{
		VSL_DEFINE_MOCK_METHOD(CreatePropertyGrid)

		VSL_SET_VALIDVALUE_INTERFACE(ppGrid);

		VSL_RETURN_VALIDVALUES();
	}
	struct RefreshValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Refresh)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Refresh)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSMDPROPERTYBROWSER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsMethodData.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSMETHODDATA_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSMETHODDATA_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsMethodDataNotImpl :
	public IVsMethodData
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsMethodDataNotImpl)

public:

	typedef IVsMethodData Interface;

	virtual long STDMETHODCALLTYPE GetOverloadCount(){ return long(); }

	virtual const WCHAR* STDMETHODCALLTYPE GetMethodText(
		/*[in]*/ long /*iMethod*/,
		/*[in]*/ MethodTextType /*type*/){ return NULL; }

	virtual long STDMETHODCALLTYPE GetParameterCount(
		/*[in]*/ long /*iMethod*/){ return long(); }

	virtual const WCHAR* STDMETHODCALLTYPE GetParameterText(
		/*[in]*/ long /*iMethod*/,
		/*[in]*/ long /*iParm*/,
		/*[in]*/ ParameterTextType /*type*/){ return NULL; }

	virtual long STDMETHODCALLTYPE GetCurrentParameter(
		/*[in]*/ long /*iMethod*/){ return long(); }

	STDMETHOD(GetContextStream)(
		/*[out]*/ long* /*piPos*/,
		/*[out]*/ long* /*piLength*/)VSL_STDMETHOD_NOTIMPL

	virtual void STDMETHODCALLTYPE OnDismiss(){ return ; }

	virtual long STDMETHODCALLTYPE GetCurMethod(){ return long(); }

	virtual void STDMETHODCALLTYPE UpdateView(){ return ; }

	virtual long STDMETHODCALLTYPE NextMethod(){ return long(); }

	virtual long STDMETHODCALLTYPE PrevMethod(){ return long(); }
};

class IVsMethodDataMockImpl :
	public IVsMethodData,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsMethodDataMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsMethodDataMockImpl)

	typedef IVsMethodData Interface;
	struct GetOverloadCountValidValues
	{
		long retValue;
	};

	virtual long _stdcall GetOverloadCount()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(GetOverloadCount)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMethodTextValidValues
	{
		/*[in]*/ long iMethod;
		/*[in]*/ MethodTextType type;
		const WCHAR* retValue;
	};

	virtual const WCHAR* _stdcall GetMethodText(
		/*[in]*/ long iMethod,
		/*[in]*/ MethodTextType type)
	{
		VSL_DEFINE_MOCK_METHOD(GetMethodText)

		VSL_CHECK_VALIDVALUE(iMethod);

		VSL_CHECK_VALIDVALUE(type);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetParameterCountValidValues
	{
		/*[in]*/ long iMethod;
		long retValue;
	};

	virtual long _stdcall GetParameterCount(
		/*[in]*/ long iMethod)
	{
		VSL_DEFINE_MOCK_METHOD(GetParameterCount)

		VSL_CHECK_VALIDVALUE(iMethod);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetParameterTextValidValues
	{
		/*[in]*/ long iMethod;
		/*[in]*/ long iParm;
		/*[in]*/ ParameterTextType type;
		const WCHAR* retValue;
	};

	virtual const WCHAR* _stdcall GetParameterText(
		/*[in]*/ long iMethod,
		/*[in]*/ long iParm,
		/*[in]*/ ParameterTextType type)
	{
		VSL_DEFINE_MOCK_METHOD(GetParameterText)

		VSL_CHECK_VALIDVALUE(iMethod);

		VSL_CHECK_VALIDVALUE(iParm);

		VSL_CHECK_VALIDVALUE(type);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCurrentParameterValidValues
	{
		/*[in]*/ long iMethod;
		long retValue;
	};

	virtual long _stdcall GetCurrentParameter(
		/*[in]*/ long iMethod)
	{
		VSL_DEFINE_MOCK_METHOD(GetCurrentParameter)

		VSL_CHECK_VALIDVALUE(iMethod);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetContextStreamValidValues
	{
		/*[out]*/ long* piPos;
		/*[out]*/ long* piLength;
		HRESULT retValue;
	};

	STDMETHOD(GetContextStream)(
		/*[out]*/ long* piPos,
		/*[out]*/ long* piLength)
	{
		VSL_DEFINE_MOCK_METHOD(GetContextStream)

		VSL_SET_VALIDVALUE(piPos);

		VSL_SET_VALIDVALUE(piLength);

		VSL_RETURN_VALIDVALUES();
	}

	virtual void _stdcall OnDismiss()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS_NORETURN(OnDismiss)

	}
	struct GetCurMethodValidValues
	{
		long retValue;
	};

	virtual long _stdcall GetCurMethod()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(GetCurMethod)

		VSL_RETURN_VALIDVALUES();
	}

	virtual void _stdcall UpdateView()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS_NORETURN(UpdateView)

	}
	struct NextMethodValidValues
	{
		long retValue;
	};

	virtual long _stdcall NextMethod()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(NextMethod)

		VSL_RETURN_VALIDVALUES();
	}
	struct PrevMethodValidValues
	{
		long retValue;
	};

	virtual long _stdcall PrevMethod()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(PrevMethod)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSMETHODDATA_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsMenuItem.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSMENUITEM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSMENUITEM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsMenuItemNotImpl :
	public IVsMenuItem
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsMenuItemNotImpl)

public:

	typedef IVsMenuItem Interface;

	STDMETHOD(IMISetProp)(
		/*[in]*/ VSMEPROPID /*PropId*/,
		/*[in]*/ VARIANT /*var*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IMIGetProp)(
		/*[in]*/ VSMEPROPID /*PropId*/,
		/*[out]*/ VARIANT* /*pvar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IMISetExtraProps)(
		/*[in]*/ LPSTREAM /*pstm*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IMIGetExtraProps)(
		/*[in]*/ LPSTREAM /*pstm*/)VSL_STDMETHOD_NOTIMPL
};

class IVsMenuItemMockImpl :
	public IVsMenuItem,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsMenuItemMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsMenuItemMockImpl)

	typedef IVsMenuItem Interface;
	struct IMISetPropValidValues
	{
		/*[in]*/ VSMEPROPID PropId;
		/*[in]*/ VARIANT var;
		HRESULT retValue;
	};

	STDMETHOD(IMISetProp)(
		/*[in]*/ VSMEPROPID PropId,
		/*[in]*/ VARIANT var)
	{
		VSL_DEFINE_MOCK_METHOD(IMISetProp)

		VSL_CHECK_VALIDVALUE(PropId);

		VSL_CHECK_VALIDVALUE(var);

		VSL_RETURN_VALIDVALUES();
	}
	struct IMIGetPropValidValues
	{
		/*[in]*/ VSMEPROPID PropId;
		/*[out]*/ VARIANT* pvar;
		HRESULT retValue;
	};

	STDMETHOD(IMIGetProp)(
		/*[in]*/ VSMEPROPID PropId,
		/*[out]*/ VARIANT* pvar)
	{
		VSL_DEFINE_MOCK_METHOD(IMIGetProp)

		VSL_CHECK_VALIDVALUE(PropId);

		VSL_SET_VALIDVALUE_VARIANT(pvar);

		VSL_RETURN_VALIDVALUES();
	}
	struct IMISetExtraPropsValidValues
	{
		/*[in]*/ LPSTREAM pstm;
		HRESULT retValue;
	};

	STDMETHOD(IMISetExtraProps)(
		/*[in]*/ LPSTREAM pstm)
	{
		VSL_DEFINE_MOCK_METHOD(IMISetExtraProps)

		VSL_CHECK_VALIDVALUE(pstm);

		VSL_RETURN_VALIDVALUES();
	}
	struct IMIGetExtraPropsValidValues
	{
		/*[in]*/ LPSTREAM pstm;
		HRESULT retValue;
	};

	STDMETHOD(IMIGetExtraProps)(
		/*[in]*/ LPSTREAM pstm)
	{
		VSL_DEFINE_MOCK_METHOD(IMIGetExtraProps)

		VSL_CHECK_VALIDVALUE(pstm);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSMENUITEM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsMethodDataEx.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSMETHODDATAEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSMETHODDATAEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsMethodDataExNotImpl :
	public IVsMethodDataEx
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsMethodDataExNotImpl)

public:

	typedef IVsMethodDataEx Interface;

	STDMETHOD(GetCopyTipText)(
		/*[in]*/ long /*iMethod*/,
		/*[out]*/ BSTR* /*pbstrTipText*/)VSL_STDMETHOD_NOTIMPL
};

class IVsMethodDataExMockImpl :
	public IVsMethodDataEx,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsMethodDataExMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsMethodDataExMockImpl)

	typedef IVsMethodDataEx Interface;
	struct GetCopyTipTextValidValues
	{
		/*[in]*/ long iMethod;
		/*[out]*/ BSTR* pbstrTipText;
		HRESULT retValue;
	};

	STDMETHOD(GetCopyTipText)(
		/*[in]*/ long iMethod,
		/*[out]*/ BSTR* pbstrTipText)
	{
		VSL_DEFINE_MOCK_METHOD(GetCopyTipText)

		VSL_CHECK_VALIDVALUE(iMethod);

		VSL_SET_VALIDVALUE_BSTR(pbstrTipText);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSMETHODDATAEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsMergeableUIItem.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSMERGEABLEUIITEM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSMERGEABLEUIITEM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsMergeableUIItemNotImpl :
	public IVsMergeableUIItem
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsMergeableUIItemNotImpl)

public:

	typedef IVsMergeableUIItem Interface;

	STDMETHOD(GetCanonicalName)(
		/*[out]*/ BSTR* /*pbstrNonLocalizeName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDisplayName)(
		/*[out]*/ BSTR* /*pbstrDisplayName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMergingPriority)(
		/*[out]*/ long* /*piMergingPriority*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDescription)(
		/*[out]*/ BSTR* /*pbstrDesc*/)VSL_STDMETHOD_NOTIMPL
};

class IVsMergeableUIItemMockImpl :
	public IVsMergeableUIItem,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsMergeableUIItemMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsMergeableUIItemMockImpl)

	typedef IVsMergeableUIItem Interface;
	struct GetCanonicalNameValidValues
	{
		/*[out]*/ BSTR* pbstrNonLocalizeName;
		HRESULT retValue;
	};

	STDMETHOD(GetCanonicalName)(
		/*[out]*/ BSTR* pbstrNonLocalizeName)
	{
		VSL_DEFINE_MOCK_METHOD(GetCanonicalName)

		VSL_SET_VALIDVALUE_BSTR(pbstrNonLocalizeName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDisplayNameValidValues
	{
		/*[out]*/ BSTR* pbstrDisplayName;
		HRESULT retValue;
	};

	STDMETHOD(GetDisplayName)(
		/*[out]*/ BSTR* pbstrDisplayName)
	{
		VSL_DEFINE_MOCK_METHOD(GetDisplayName)

		VSL_SET_VALIDVALUE_BSTR(pbstrDisplayName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMergingPriorityValidValues
	{
		/*[out]*/ long* piMergingPriority;
		HRESULT retValue;
	};

	STDMETHOD(GetMergingPriority)(
		/*[out]*/ long* piMergingPriority)
	{
		VSL_DEFINE_MOCK_METHOD(GetMergingPriority)

		VSL_SET_VALIDVALUE(piMergingPriority);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDescriptionValidValues
	{
		/*[out]*/ BSTR* pbstrDesc;
		HRESULT retValue;
	};

	STDMETHOD(GetDescription)(
		/*[out]*/ BSTR* pbstrDesc)
	{
		VSL_DEFINE_MOCK_METHOD(GetDescription)

		VSL_SET_VALIDVALUE_BSTR(pbstrDesc);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSMERGEABLEUIITEM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsMethodTipWindow.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSMETHODTIPWINDOW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSMETHODTIPWINDOW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsMethodTipWindowNotImpl :
	public IVsMethodTipWindow
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsMethodTipWindowNotImpl)

public:

	typedef IVsMethodTipWindow Interface;

	STDMETHOD(SetMethodData)(
		/*[in]*/ IVsMethodData* /*pMethodData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetContextStream)(
		/*[out]*/ long* /*piPos*/,
		/*[out]*/ long* /*piLength*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSizePreferences)(
		/*[out]*/ const RECT* /*prcCtxBounds*/,
		/*[out]*/ TIPSIZEDATA* /*pSizeData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Paint)(
		/*[in]*/ HDC /*hdc*/,
		/*[in]*/ const RECT* /*prc*/)VSL_STDMETHOD_NOTIMPL

	virtual void STDMETHODCALLTYPE Dismiss(){ return ; }

	virtual LRESULT STDMETHODCALLTYPE WndProc(
		/*[in]*/ HWND /*hwnd*/,
		/*[in]*/ UINT /*iMsg*/,
		/*[in]*/ WPARAM /*wParam*/,
		/*[in]*/ LPARAM /*lParam*/){ return LRESULT(); }
};

class IVsMethodTipWindowMockImpl :
	public IVsMethodTipWindow,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsMethodTipWindowMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsMethodTipWindowMockImpl)

	typedef IVsMethodTipWindow Interface;
	struct SetMethodDataValidValues
	{
		/*[in]*/ IVsMethodData* pMethodData;
		HRESULT retValue;
	};

	STDMETHOD(SetMethodData)(
		/*[in]*/ IVsMethodData* pMethodData)
	{
		VSL_DEFINE_MOCK_METHOD(SetMethodData)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pMethodData);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetContextStreamValidValues
	{
		/*[out]*/ long* piPos;
		/*[out]*/ long* piLength;
		HRESULT retValue;
	};

	STDMETHOD(GetContextStream)(
		/*[out]*/ long* piPos,
		/*[out]*/ long* piLength)
	{
		VSL_DEFINE_MOCK_METHOD(GetContextStream)

		VSL_SET_VALIDVALUE(piPos);

		VSL_SET_VALIDVALUE(piLength);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSizePreferencesValidValues
	{
		/*[out]*/ RECT* prcCtxBounds;
		/*[out]*/ TIPSIZEDATA* pSizeData;
		HRESULT retValue;
	};

	STDMETHOD(GetSizePreferences)(
		/*[out]*/ const RECT* prcCtxBounds,
		/*[out]*/ TIPSIZEDATA* pSizeData)
	{
		VSL_DEFINE_MOCK_METHOD(GetSizePreferences)

		VSL_SET_VALIDVALUE_CONST(prcCtxBounds, RECT*);

		VSL_SET_VALIDVALUE(pSizeData);

		VSL_RETURN_VALIDVALUES();
	}
	struct PaintValidValues
	{
		/*[in]*/ HDC hdc;
		/*[in]*/ RECT* prc;
		HRESULT retValue;
	};

	STDMETHOD(Paint)(
		/*[in]*/ HDC hdc,
		/*[in]*/ const RECT* prc)
	{
		VSL_DEFINE_MOCK_METHOD(Paint)

		VSL_CHECK_VALIDVALUE(hdc);

		VSL_CHECK_VALIDVALUE_POINTER(prc);

		VSL_RETURN_VALIDVALUES();
	}

	virtual void _stdcall Dismiss()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS_NORETURN(Dismiss)

	}
	struct WndProcValidValues
	{
		/*[in]*/ HWND hwnd;
		/*[in]*/ UINT iMsg;
		/*[in]*/ WPARAM wParam;
		/*[in]*/ LPARAM lParam;
		LRESULT retValue;
	};

	virtual LRESULT _stdcall WndProc(
		/*[in]*/ HWND hwnd,
		/*[in]*/ UINT iMsg,
		/*[in]*/ WPARAM wParam,
		/*[in]*/ LPARAM lParam)
	{
		VSL_DEFINE_MOCK_METHOD(WndProc)

		VSL_CHECK_VALIDVALUE(hwnd);

		VSL_CHECK_VALIDVALUE(iMsg);

		VSL_CHECK_VALIDVALUE(wParam);

		VSL_CHECK_VALIDVALUE(lParam);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSMETHODTIPWINDOW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsMenuEditorTransactionEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSMENUEDITORTRANSACTIONEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSMENUEDITORTRANSACTIONEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsMenuEditorTransactionEventsNotImpl :
	public IVsMenuEditorTransactionEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsMenuEditorTransactionEventsNotImpl)

public:

	typedef IVsMenuEditorTransactionEvents Interface;

	STDMETHOD(BeginTransaction)(
		/*[in]*/ MENUEDITOR_TRANSACTION /*trans*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EndTransaction)(
		/*[in]*/ MENUEDITOR_TRANSACTION /*trans*/)VSL_STDMETHOD_NOTIMPL
};

class IVsMenuEditorTransactionEventsMockImpl :
	public IVsMenuEditorTransactionEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsMenuEditorTransactionEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsMenuEditorTransactionEventsMockImpl)

	typedef IVsMenuEditorTransactionEvents Interface;
	struct BeginTransactionValidValues
	{
		/*[in]*/ MENUEDITOR_TRANSACTION trans;
		HRESULT retValue;
	};

	STDMETHOD(BeginTransaction)(
		/*[in]*/ MENUEDITOR_TRANSACTION trans)
	{
		VSL_DEFINE_MOCK_METHOD(BeginTransaction)

		VSL_CHECK_VALIDVALUE(trans);

		VSL_RETURN_VALIDVALUES();
	}
	struct EndTransactionValidValues
	{
		/*[in]*/ MENUEDITOR_TRANSACTION trans;
		HRESULT retValue;
	};

	STDMETHOD(EndTransaction)(
		/*[in]*/ MENUEDITOR_TRANSACTION trans)
	{
		VSL_DEFINE_MOCK_METHOD(EndTransaction)

		VSL_CHECK_VALIDVALUE(trans);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSMENUEDITORTRANSACTIONEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsMenuEditorFactory.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSMENUEDITORFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSMENUEDITORFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsMenuEditorFactoryNotImpl :
	public IVsMenuEditorFactory
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsMenuEditorFactoryNotImpl)

public:

	typedef IVsMenuEditorFactory Interface;

	STDMETHOD(CreateMenuEditor)(
		/*[in]*/ MEINIT* /*pMEInit*/,
		/*[out]*/ IVsMenuEditor** /*ppME*/)VSL_STDMETHOD_NOTIMPL
};

class IVsMenuEditorFactoryMockImpl :
	public IVsMenuEditorFactory,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsMenuEditorFactoryMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsMenuEditorFactoryMockImpl)

	typedef IVsMenuEditorFactory Interface;
	struct CreateMenuEditorValidValues
	{
		/*[in]*/ MEINIT* pMEInit;
		/*[out]*/ IVsMenuEditor** ppME;
		HRESULT retValue;
	};

	STDMETHOD(CreateMenuEditor)(
		/*[in]*/ MEINIT* pMEInit,
		/*[out]*/ IVsMenuEditor** ppME)
	{
		VSL_DEFINE_MOCK_METHOD(CreateMenuEditor)

		VSL_CHECK_VALIDVALUE_POINTER(pMEInit);

		VSL_SET_VALIDVALUE_INTERFACE(ppME);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSMENUEDITORFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsMenuEditorSite.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSMENUEDITORSITE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSMENUEDITORSITE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsMenuEditorSiteNotImpl :
	public IVsMenuEditorSite
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsMenuEditorSiteNotImpl)

public:

	typedef IVsMenuEditorSite Interface;

	STDMETHOD(CreateItem)(
		/*[in]*/ IVsMenuItem* /*pIMIParent*/,
		/*[in]*/ IVsMenuItem* /*pIMIInsertAfter*/,
		/*[out]*/ IVsMenuItem** /*ppIMINew*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DeleteItem)(
		/*[in]*/ IVsMenuItem* /*pIMI*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MoveItems)(
		/*[in]*/ IVsMenuItem* /*pIMIFirst*/,
		/*[in]*/ IVsMenuItem* /*pIMILast*/,
		/*[in]*/ IVsMenuItem* /*pIMIParent*/,
		/*[in]*/ IVsMenuItem* /*pIMIInsertAfter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SelectionChange)(
		/*[in]*/ IVsMenuItem** /*ppIMI*/,
		/*[in]*/ VSMESELCMD /*SelCmd*/)VSL_STDMETHOD_NOTIMPL
};

class IVsMenuEditorSiteMockImpl :
	public IVsMenuEditorSite,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsMenuEditorSiteMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsMenuEditorSiteMockImpl)

	typedef IVsMenuEditorSite Interface;
	struct CreateItemValidValues
	{
		/*[in]*/ IVsMenuItem* pIMIParent;
		/*[in]*/ IVsMenuItem* pIMIInsertAfter;
		/*[out]*/ IVsMenuItem** ppIMINew;
		HRESULT retValue;
	};

	STDMETHOD(CreateItem)(
		/*[in]*/ IVsMenuItem* pIMIParent,
		/*[in]*/ IVsMenuItem* pIMIInsertAfter,
		/*[out]*/ IVsMenuItem** ppIMINew)
	{
		VSL_DEFINE_MOCK_METHOD(CreateItem)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIMIParent);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIMIInsertAfter);

		VSL_SET_VALIDVALUE_INTERFACE(ppIMINew);

		VSL_RETURN_VALIDVALUES();
	}
	struct DeleteItemValidValues
	{
		/*[in]*/ IVsMenuItem* pIMI;
		HRESULT retValue;
	};

	STDMETHOD(DeleteItem)(
		/*[in]*/ IVsMenuItem* pIMI)
	{
		VSL_DEFINE_MOCK_METHOD(DeleteItem)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIMI);

		VSL_RETURN_VALIDVALUES();
	}
	struct MoveItemsValidValues
	{
		/*[in]*/ IVsMenuItem* pIMIFirst;
		/*[in]*/ IVsMenuItem* pIMILast;
		/*[in]*/ IVsMenuItem* pIMIParent;
		/*[in]*/ IVsMenuItem* pIMIInsertAfter;
		HRESULT retValue;
	};

	STDMETHOD(MoveItems)(
		/*[in]*/ IVsMenuItem* pIMIFirst,
		/*[in]*/ IVsMenuItem* pIMILast,
		/*[in]*/ IVsMenuItem* pIMIParent,
		/*[in]*/ IVsMenuItem* pIMIInsertAfter)
	{
		VSL_DEFINE_MOCK_METHOD(MoveItems)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIMIFirst);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIMILast);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIMIParent);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIMIInsertAfter);

		VSL_RETURN_VALIDVALUES();
	}
	struct SelectionChangeValidValues
	{
		/*[in]*/ IVsMenuItem** ppIMI;
		/*[in]*/ VSMESELCMD SelCmd;
		HRESULT retValue;
	};

	STDMETHOD(SelectionChange)(
		/*[in]*/ IVsMenuItem** ppIMI,
		/*[in]*/ VSMESELCMD SelCmd)
	{
		VSL_DEFINE_MOCK_METHOD(SelectionChange)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(ppIMI);

		VSL_CHECK_VALIDVALUE(SelCmd);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSMENUEDITORSITE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsMultiViewDocumentView.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSMULTIVIEWDOCUMENTVIEW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSMULTIVIEWDOCUMENTVIEW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsMultiViewDocumentViewNotImpl :
	public IVsMultiViewDocumentView
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsMultiViewDocumentViewNotImpl)

public:

	typedef IVsMultiViewDocumentView Interface;

	STDMETHOD(ActivateLogicalView)(
		/*[in]*/ REFGUID /*rguidLogicalView*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetActiveLogicalView)(
		/*[out]*/ GUID* /*pguidLogicalView*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsLogicalViewActive)(
		/*[in]*/ REFGUID /*rguidLogicalView*/,
		/*[out,retval]*/ BOOL* /*pIsActive*/)VSL_STDMETHOD_NOTIMPL
};

class IVsMultiViewDocumentViewMockImpl :
	public IVsMultiViewDocumentView,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsMultiViewDocumentViewMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsMultiViewDocumentViewMockImpl)

	typedef IVsMultiViewDocumentView Interface;
	struct ActivateLogicalViewValidValues
	{
		/*[in]*/ REFGUID rguidLogicalView;
		HRESULT retValue;
	};

	STDMETHOD(ActivateLogicalView)(
		/*[in]*/ REFGUID rguidLogicalView)
	{
		VSL_DEFINE_MOCK_METHOD(ActivateLogicalView)

		VSL_CHECK_VALIDVALUE(rguidLogicalView);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetActiveLogicalViewValidValues
	{
		/*[out]*/ GUID* pguidLogicalView;
		HRESULT retValue;
	};

	STDMETHOD(GetActiveLogicalView)(
		/*[out]*/ GUID* pguidLogicalView)
	{
		VSL_DEFINE_MOCK_METHOD(GetActiveLogicalView)

		VSL_SET_VALIDVALUE(pguidLogicalView);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsLogicalViewActiveValidValues
	{
		/*[in]*/ REFGUID rguidLogicalView;
		/*[out,retval]*/ BOOL* pIsActive;
		HRESULT retValue;
	};

	STDMETHOD(IsLogicalViewActive)(
		/*[in]*/ REFGUID rguidLogicalView,
		/*[out,retval]*/ BOOL* pIsActive)
	{
		VSL_DEFINE_MOCK_METHOD(IsLogicalViewActive)

		VSL_CHECK_VALIDVALUE(rguidLogicalView);

		VSL_SET_VALIDVALUE(pIsActive);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSMULTIVIEWDOCUMENTVIEW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsMonitorSelection2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSMONITORSELECTION2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSMONITORSELECTION2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsMonitorSelection2NotImpl :
	public IVsMonitorSelection2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsMonitorSelection2NotImpl)

public:

	typedef IVsMonitorSelection2 Interface;

	STDMETHOD(GetElementID)(
		/*[in]*/ REFGUID /*rguidElement*/,
		/*[out]*/ VSSELELEMID* /*pElementId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEmptySelectionContext)(
		/*[out]*/ IVsTrackSelectionEx** /*ppEmptySelCtxt*/)VSL_STDMETHOD_NOTIMPL
};

class IVsMonitorSelection2MockImpl :
	public IVsMonitorSelection2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsMonitorSelection2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsMonitorSelection2MockImpl)

	typedef IVsMonitorSelection2 Interface;
	struct GetElementIDValidValues
	{
		/*[in]*/ REFGUID rguidElement;
		/*[out]*/ VSSELELEMID* pElementId;
		HRESULT retValue;
	};

	STDMETHOD(GetElementID)(
		/*[in]*/ REFGUID rguidElement,
		/*[out]*/ VSSELELEMID* pElementId)
	{
		VSL_DEFINE_MOCK_METHOD(GetElementID)

		VSL_CHECK_VALIDVALUE(rguidElement);

		VSL_SET_VALIDVALUE(pElementId);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEmptySelectionContextValidValues
	{
		/*[out]*/ IVsTrackSelectionEx** ppEmptySelCtxt;
		HRESULT retValue;
	};

	STDMETHOD(GetEmptySelectionContext)(
		/*[out]*/ IVsTrackSelectionEx** ppEmptySelCtxt)
	{
		VSL_DEFINE_MOCK_METHOD(GetEmptySelectionContext)

		VSL_SET_VALIDVALUE_INTERFACE(ppEmptySelCtxt);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSMONITORSELECTION2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsMouseCursorProvider.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSMOUSECURSORPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSMOUSECURSORPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsMouseCursorProviderNotImpl :
	public IVsMouseCursorProvider
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsMouseCursorProviderNotImpl)

public:

	typedef IVsMouseCursorProvider Interface;

	STDMETHOD(SetMouseCursor)(
		/*[in]*/ DWORD /*dwReserved*/)VSL_STDMETHOD_NOTIMPL
};

class IVsMouseCursorProviderMockImpl :
	public IVsMouseCursorProvider,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsMouseCursorProviderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsMouseCursorProviderMockImpl)

	typedef IVsMouseCursorProvider Interface;
	struct SetMouseCursorValidValues
	{
		/*[in]*/ DWORD dwReserved;
		HRESULT retValue;
	};

	STDMETHOD(SetMouseCursor)(
		/*[in]*/ DWORD dwReserved)
	{
		VSL_DEFINE_MOCK_METHOD(SetMouseCursor)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSMOUSECURSORPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsMultiItemSelect.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSMULTIITEMSELECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSMULTIITEMSELECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsMultiItemSelectNotImpl :
	public IVsMultiItemSelect
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsMultiItemSelectNotImpl)

public:

	typedef IVsMultiItemSelect Interface;

	STDMETHOD(GetSelectionInfo)(
		/*[out]*/ ULONG* /*pcItems*/,
		/*[out]*/ BOOL* /*pfSingleHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSelectedItems)(
		/*[in]*/ VSGSIFLAGS /*grfGSI*/,
		/*[in]*/ ULONG /*cItems*/,
		/*[out,size_is(cItems)]*/ VSITEMSELECTION[] /*rgItemSel*/)VSL_STDMETHOD_NOTIMPL
};

class IVsMultiItemSelectMockImpl :
	public IVsMultiItemSelect,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsMultiItemSelectMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsMultiItemSelectMockImpl)

	typedef IVsMultiItemSelect Interface;
	struct GetSelectionInfoValidValues
	{
		/*[out]*/ ULONG* pcItems;
		/*[out]*/ BOOL* pfSingleHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(GetSelectionInfo)(
		/*[out]*/ ULONG* pcItems,
		/*[out]*/ BOOL* pfSingleHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(GetSelectionInfo)

		VSL_SET_VALIDVALUE(pcItems);

		VSL_SET_VALIDVALUE(pfSingleHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSelectedItemsValidValues
	{
		/*[in]*/ VSGSIFLAGS grfGSI;
		/*[in]*/ ULONG cItems;
		/*[out,size_is(cItems)]*/ VSITEMSELECTION* rgItemSel;
		HRESULT retValue;
	};

	STDMETHOD(GetSelectedItems)(
		/*[in]*/ VSGSIFLAGS grfGSI,
		/*[in]*/ ULONG cItems,
		/*[out,size_is(cItems)]*/ VSITEMSELECTION rgItemSel[])
	{
		VSL_DEFINE_MOCK_METHOD(GetSelectedItems)

		VSL_CHECK_VALIDVALUE(grfGSI);

		VSL_CHECK_VALIDVALUE(cItems);

		VSL_SET_VALIDVALUE_MEMCPY(rgItemSel, cItems*sizeof(rgItemSel[0]), validValues.cItems*sizeof(validValues.rgItemSel[0]));

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSMULTIITEMSELECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsMonitorUserContext.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSMONITORUSERCONTEXT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSMONITORUSERCONTEXT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "context.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsMonitorUserContextNotImpl :
	public IVsMonitorUserContext
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsMonitorUserContextNotImpl)

public:

	typedef IVsMonitorUserContext Interface;

	STDMETHOD(SetSite)(
		/*[in]*/ IServiceProvider* /*pSP*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ApplicationContext)(
		/*[out,retval]*/ IVsUserContext** /*ppContext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_ApplicationContext)(
		/*[in]*/ IVsUserContext* /*pContext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateEmptyContext)(
		/*[out,retval]*/ IVsUserContext** /*ppContext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetContextItems)(
		/*[out]*/ IVsUserContextItemCollection** /*pplist*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FindTargetItems)(
		/*[in]*/ LPCOLESTR /*pszTargetAttr*/,
		/*[in]*/ LPCOLESTR /*pszTargetAttrValue*/,
		/*[out]*/ IVsUserContextItemCollection** /*ppList*/,
		/*[out]*/ BOOL* /*pfF1Kwd*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RegisterItemProvider)(
		/*[in]*/ IVsUserContextItemProvider* /*pProvider*/,
		/*[out,retval]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnregisterItemProvider)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AdviseContextItemEvents)(
		/*[in]*/ IVsUserContextItemEvents* /*pEvents*/,
		/*[out,retval]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseContextItemEvent)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetNextCtxBagAttr)(
		/*[out]*/ BSTR* /*pbstrAttrName*/,
		/*[out]*/ BSTR* /*pbstrAttrVal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ResetNextCtxBagAttr)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPrevAttrCache)(
		/*[out]*/ BSTR** /*pbstrCacheArray*/,
		/*[out]*/ int** /*pnCurrNumStored*/,
		/*[out]*/ int* /*pnMaxNumStored*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetNextCtxBag)(
		/*[out]*/ BSTR* /*pbstrAttrName*/,
		/*[out]*/ BSTR* /*pbstrAttrVal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsIdleAvailable)(
		/*[out]*/ BOOL* /*pfIdleAvail*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetTopicTypeFilter)(
		/*[in]*/ IVsHelpAttributeList* /*pTopicTypeList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetF1Kwd)(
		/*[out]*/ BSTR* /*pbstrKwd*/,
		/*[out]*/ BOOL* /*fF1Kwd*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsF1Lookup)(
		/*[out]*/ BOOL* /*fF1Lookup*/)VSL_STDMETHOD_NOTIMPL
};

class IVsMonitorUserContextMockImpl :
	public IVsMonitorUserContext,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsMonitorUserContextMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsMonitorUserContextMockImpl)

	typedef IVsMonitorUserContext Interface;
	struct SetSiteValidValues
	{
		/*[in]*/ IServiceProvider* pSP;
		HRESULT retValue;
	};

	STDMETHOD(SetSite)(
		/*[in]*/ IServiceProvider* pSP)
	{
		VSL_DEFINE_MOCK_METHOD(SetSite)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSP);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ApplicationContextValidValues
	{
		/*[out,retval]*/ IVsUserContext** ppContext;
		HRESULT retValue;
	};

	STDMETHOD(get_ApplicationContext)(
		/*[out,retval]*/ IVsUserContext** ppContext)
	{
		VSL_DEFINE_MOCK_METHOD(get_ApplicationContext)

		VSL_SET_VALIDVALUE_INTERFACE(ppContext);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_ApplicationContextValidValues
	{
		/*[in]*/ IVsUserContext* pContext;
		HRESULT retValue;
	};

	STDMETHOD(put_ApplicationContext)(
		/*[in]*/ IVsUserContext* pContext)
	{
		VSL_DEFINE_MOCK_METHOD(put_ApplicationContext)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pContext);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateEmptyContextValidValues
	{
		/*[out,retval]*/ IVsUserContext** ppContext;
		HRESULT retValue;
	};

	STDMETHOD(CreateEmptyContext)(
		/*[out,retval]*/ IVsUserContext** ppContext)
	{
		VSL_DEFINE_MOCK_METHOD(CreateEmptyContext)

		VSL_SET_VALIDVALUE_INTERFACE(ppContext);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetContextItemsValidValues
	{
		/*[out]*/ IVsUserContextItemCollection** pplist;
		HRESULT retValue;
	};

	STDMETHOD(GetContextItems)(
		/*[out]*/ IVsUserContextItemCollection** pplist)
	{
		VSL_DEFINE_MOCK_METHOD(GetContextItems)

		VSL_SET_VALIDVALUE_INTERFACE(pplist);

		VSL_RETURN_VALIDVALUES();
	}
	struct FindTargetItemsValidValues
	{
		/*[in]*/ LPCOLESTR pszTargetAttr;
		/*[in]*/ LPCOLESTR pszTargetAttrValue;
		/*[out]*/ IVsUserContextItemCollection** ppList;
		/*[out]*/ BOOL* pfF1Kwd;
		HRESULT retValue;
	};

	STDMETHOD(FindTargetItems)(
		/*[in]*/ LPCOLESTR pszTargetAttr,
		/*[in]*/ LPCOLESTR pszTargetAttrValue,
		/*[out]*/ IVsUserContextItemCollection** ppList,
		/*[out]*/ BOOL* pfF1Kwd)
	{
		VSL_DEFINE_MOCK_METHOD(FindTargetItems)

		VSL_CHECK_VALIDVALUE_STRINGW(pszTargetAttr);

		VSL_CHECK_VALIDVALUE_STRINGW(pszTargetAttrValue);

		VSL_SET_VALIDVALUE_INTERFACE(ppList);

		VSL_SET_VALIDVALUE(pfF1Kwd);

		VSL_RETURN_VALIDVALUES();
	}
	struct RegisterItemProviderValidValues
	{
		/*[in]*/ IVsUserContextItemProvider* pProvider;
		/*[out,retval]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(RegisterItemProvider)(
		/*[in]*/ IVsUserContextItemProvider* pProvider,
		/*[out,retval]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(RegisterItemProvider)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProvider);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnregisterItemProviderValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnregisterItemProvider)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnregisterItemProvider)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct AdviseContextItemEventsValidValues
	{
		/*[in]*/ IVsUserContextItemEvents* pEvents;
		/*[out,retval]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(AdviseContextItemEvents)(
		/*[in]*/ IVsUserContextItemEvents* pEvents,
		/*[out,retval]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(AdviseContextItemEvents)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pEvents);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseContextItemEventValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnadviseContextItemEvent)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnadviseContextItemEvent)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNextCtxBagAttrValidValues
	{
		/*[out]*/ BSTR* pbstrAttrName;
		/*[out]*/ BSTR* pbstrAttrVal;
		HRESULT retValue;
	};

	STDMETHOD(GetNextCtxBagAttr)(
		/*[out]*/ BSTR* pbstrAttrName,
		/*[out]*/ BSTR* pbstrAttrVal)
	{
		VSL_DEFINE_MOCK_METHOD(GetNextCtxBagAttr)

		VSL_SET_VALIDVALUE_BSTR(pbstrAttrName);

		VSL_SET_VALIDVALUE_BSTR(pbstrAttrVal);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetNextCtxBagAttrValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ResetNextCtxBagAttr)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ResetNextCtxBagAttr)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPrevAttrCacheValidValues
	{
		/*[out]*/ BSTR** pbstrCacheArray;
		/*[out]*/ int** pnCurrNumStored;
		/*[out]*/ int* pnMaxNumStored;
		HRESULT retValue;
	};

	STDMETHOD(GetPrevAttrCache)(
		/*[out]*/ BSTR** pbstrCacheArray,
		/*[out]*/ int** pnCurrNumStored,
		/*[out]*/ int* pnMaxNumStored)
	{
		VSL_DEFINE_MOCK_METHOD(GetPrevAttrCache)

		VSL_SET_VALIDVALUE(pbstrCacheArray);

		VSL_SET_VALIDVALUE(pnCurrNumStored);

		VSL_SET_VALIDVALUE(pnMaxNumStored);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNextCtxBagValidValues
	{
		/*[out]*/ BSTR* pbstrAttrName;
		/*[out]*/ BSTR* pbstrAttrVal;
		HRESULT retValue;
	};

	STDMETHOD(GetNextCtxBag)(
		/*[out]*/ BSTR* pbstrAttrName,
		/*[out]*/ BSTR* pbstrAttrVal)
	{
		VSL_DEFINE_MOCK_METHOD(GetNextCtxBag)

		VSL_SET_VALIDVALUE_BSTR(pbstrAttrName);

		VSL_SET_VALIDVALUE_BSTR(pbstrAttrVal);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsIdleAvailableValidValues
	{
		/*[out]*/ BOOL* pfIdleAvail;
		HRESULT retValue;
	};

	STDMETHOD(IsIdleAvailable)(
		/*[out]*/ BOOL* pfIdleAvail)
	{
		VSL_DEFINE_MOCK_METHOD(IsIdleAvailable)

		VSL_SET_VALIDVALUE(pfIdleAvail);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetTopicTypeFilterValidValues
	{
		/*[in]*/ IVsHelpAttributeList* pTopicTypeList;
		HRESULT retValue;
	};

	STDMETHOD(SetTopicTypeFilter)(
		/*[in]*/ IVsHelpAttributeList* pTopicTypeList)
	{
		VSL_DEFINE_MOCK_METHOD(SetTopicTypeFilter)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pTopicTypeList);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetF1KwdValidValues
	{
		/*[out]*/ BSTR* pbstrKwd;
		/*[out]*/ BOOL* fF1Kwd;
		HRESULT retValue;
	};

	STDMETHOD(GetF1Kwd)(
		/*[out]*/ BSTR* pbstrKwd,
		/*[out]*/ BOOL* fF1Kwd)
	{
		VSL_DEFINE_MOCK_METHOD(GetF1Kwd)

		VSL_SET_VALIDVALUE_BSTR(pbstrKwd);

		VSL_SET_VALIDVALUE(fF1Kwd);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsF1LookupValidValues
	{
		/*[out]*/ BOOL* fF1Lookup;
		HRESULT retValue;
	};

	STDMETHOD(IsF1Lookup)(
		/*[out]*/ BOOL* fF1Lookup)
	{
		VSL_DEFINE_MOCK_METHOD(IsF1Lookup)

		VSL_SET_VALIDVALUE(fF1Lookup);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSMONITORUSERCONTEXT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsMethodTipWindow2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSMETHODTIPWINDOW2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSMETHODTIPWINDOW2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsMethodTipWindow2NotImpl :
	public IVsMethodTipWindow2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsMethodTipWindow2NotImpl)

public:

	typedef IVsMethodTipWindow2 Interface;

	STDMETHOD(NextMethod)(
		/*[out]*/ BOOL* /*pfSuccess*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(PrevMethod)(
		/*[out]*/ BOOL* /*pfSuccess*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetOverloadCount)(
		/*[in]*/ long* /*piCount*/)VSL_STDMETHOD_NOTIMPL
};

class IVsMethodTipWindow2MockImpl :
	public IVsMethodTipWindow2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsMethodTipWindow2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsMethodTipWindow2MockImpl)

	typedef IVsMethodTipWindow2 Interface;
	struct NextMethodValidValues
	{
		/*[out]*/ BOOL* pfSuccess;
		HRESULT retValue;
	};

	STDMETHOD(NextMethod)(
		/*[out]*/ BOOL* pfSuccess)
	{
		VSL_DEFINE_MOCK_METHOD(NextMethod)

		VSL_SET_VALIDVALUE(pfSuccess);

		VSL_RETURN_VALIDVALUES();
	}
	struct PrevMethodValidValues
	{
		/*[out]*/ BOOL* pfSuccess;
		HRESULT retValue;
	};

	STDMETHOD(PrevMethod)(
		/*[out]*/ BOOL* pfSuccess)
	{
		VSL_DEFINE_MOCK_METHOD(PrevMethod)

		VSL_SET_VALIDVALUE(pfSuccess);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetOverloadCountValidValues
	{
		/*[in]*/ long* piCount;
		HRESULT retValue;
	};

	STDMETHOD(GetOverloadCount)(
		/*[in]*/ long* piCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetOverloadCount)

		VSL_CHECK_VALIDVALUE_POINTER(piCount);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSMETHODTIPWINDOW2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsMonitorSelection.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSMONITORSELECTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSMONITORSELECTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsMonitorSelectionNotImpl :
	public IVsMonitorSelection
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsMonitorSelectionNotImpl)

public:

	typedef IVsMonitorSelection Interface;

	STDMETHOD(GetCurrentSelection)(
		/*[out]*/ IVsHierarchy** /*ppHier*/,
		/*[out]*/ VSITEMID* /*pitemid*/,
		/*[out]*/ IVsMultiItemSelect** /*ppMIS*/,
		/*[out]*/ ISelectionContainer** /*ppSC*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AdviseSelectionEvents)(
		/*[in]*/ IVsSelectionEvents* /*psink*/,
		/*[out]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseSelectionEvents)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCurrentElementValue)(
		/*[in]*/ VSSELELEMID /*elementid*/,
		/*[out]*/ VARIANT* /*pvarValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCmdUIContextCookie)(
		/*[in]*/ REFGUID /*rguidCmdUI*/,
		/*[out]*/ VSCOOKIE* /*pdwCmdUICookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsCmdUIContextActive)(
		/*[in]*/ VSCOOKIE /*dwCmdUICookie*/,
		/*[out]*/ BOOL* /*pfActive*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetCmdUIContext)(
		/*[in]*/ VSCOOKIE /*dwCmdUICookie*/,
		/*[in]*/ BOOL /*fActive*/)VSL_STDMETHOD_NOTIMPL
};

class IVsMonitorSelectionMockImpl :
	public IVsMonitorSelection,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsMonitorSelectionMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsMonitorSelectionMockImpl)

	typedef IVsMonitorSelection Interface;
	struct GetCurrentSelectionValidValues
	{
		/*[out]*/ IVsHierarchy** ppHier;
		/*[out]*/ VSITEMID* pitemid;
		/*[out]*/ IVsMultiItemSelect** ppMIS;
		/*[out]*/ ISelectionContainer** ppSC;
		HRESULT retValue;
	};

	STDMETHOD(GetCurrentSelection)(
		/*[out]*/ IVsHierarchy** ppHier,
		/*[out]*/ VSITEMID* pitemid,
		/*[out]*/ IVsMultiItemSelect** ppMIS,
		/*[out]*/ ISelectionContainer** ppSC)
	{
		VSL_DEFINE_MOCK_METHOD(GetCurrentSelection)

		VSL_SET_VALIDVALUE_INTERFACE(ppHier);

		VSL_SET_VALIDVALUE(pitemid);

		VSL_SET_VALIDVALUE_INTERFACE(ppMIS);

		VSL_SET_VALIDVALUE_INTERFACE(ppSC);

		VSL_RETURN_VALIDVALUES();
	}
	struct AdviseSelectionEventsValidValues
	{
		/*[in]*/ IVsSelectionEvents* psink;
		/*[out]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(AdviseSelectionEvents)(
		/*[in]*/ IVsSelectionEvents* psink,
		/*[out]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(AdviseSelectionEvents)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(psink);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseSelectionEventsValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnadviseSelectionEvents)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnadviseSelectionEvents)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCurrentElementValueValidValues
	{
		/*[in]*/ VSSELELEMID elementid;
		/*[out]*/ VARIANT* pvarValue;
		HRESULT retValue;
	};

	STDMETHOD(GetCurrentElementValue)(
		/*[in]*/ VSSELELEMID elementid,
		/*[out]*/ VARIANT* pvarValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetCurrentElementValue)

		VSL_CHECK_VALIDVALUE(elementid);

		VSL_SET_VALIDVALUE_VARIANT(pvarValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCmdUIContextCookieValidValues
	{
		/*[in]*/ REFGUID rguidCmdUI;
		/*[out]*/ VSCOOKIE* pdwCmdUICookie;
		HRESULT retValue;
	};

	STDMETHOD(GetCmdUIContextCookie)(
		/*[in]*/ REFGUID rguidCmdUI,
		/*[out]*/ VSCOOKIE* pdwCmdUICookie)
	{
		VSL_DEFINE_MOCK_METHOD(GetCmdUIContextCookie)

		VSL_CHECK_VALIDVALUE(rguidCmdUI);

		VSL_SET_VALIDVALUE(pdwCmdUICookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsCmdUIContextActiveValidValues
	{
		/*[in]*/ VSCOOKIE dwCmdUICookie;
		/*[out]*/ BOOL* pfActive;
		HRESULT retValue;
	};

	STDMETHOD(IsCmdUIContextActive)(
		/*[in]*/ VSCOOKIE dwCmdUICookie,
		/*[out]*/ BOOL* pfActive)
	{
		VSL_DEFINE_MOCK_METHOD(IsCmdUIContextActive)

		VSL_CHECK_VALIDVALUE(dwCmdUICookie);

		VSL_SET_VALIDVALUE(pfActive);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetCmdUIContextValidValues
	{
		/*[in]*/ VSCOOKIE dwCmdUICookie;
		/*[in]*/ BOOL fActive;
		HRESULT retValue;
	};

	STDMETHOD(SetCmdUIContext)(
		/*[in]*/ VSCOOKIE dwCmdUICookie,
		/*[in]*/ BOOL fActive)
	{
		VSL_DEFINE_MOCK_METHOD(SetCmdUIContext)

		VSL_CHECK_VALIDVALUE(dwCmdUICookie);

		VSL_CHECK_VALIDVALUE(fActive);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSMONITORSELECTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsNavigableLocationResolver.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSNAVIGABLELOCATIONRESOLVER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSNAVIGABLELOCATIONRESOLVER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsNavigableLocationResolverNotImpl :
	public IVsNavigableLocationResolver
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsNavigableLocationResolverNotImpl)

public:

	typedef IVsNavigableLocationResolver Interface;

	STDMETHOD(GetDisplayText)(
		/*[in]*/ DWORD /*dwReserved*/,
		/*[in]*/ TextSpan* /*ptsBase*/,
		/*[in]*/ IVsTextLines* /*pBuffer*/,
		/*[out]*/ NavigableLocationResolverFlags* /*dwOutFlags*/,
		/*[out,retval]*/ BSTR* /*pbstrDisplayText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPathFromLocation)(
		/*[in]*/ DWORD /*dwReserved*/,
		/*[in]*/ TextSpan* /*ptsBase*/,
		/*[in]*/ IVsTextLines* /*pBuffer*/,
		/*[in]*/ const WCHAR* /*pszDisplayText*/,
		/*[out]*/ NavigableLocationResolverFlags* /*dwOutFlags*/,
		/*[out,retval]*/ BSTR* /*pbstrPath*/)VSL_STDMETHOD_NOTIMPL
};

class IVsNavigableLocationResolverMockImpl :
	public IVsNavigableLocationResolver,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsNavigableLocationResolverMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsNavigableLocationResolverMockImpl)

	typedef IVsNavigableLocationResolver Interface;
	struct GetDisplayTextValidValues
	{
		/*[in]*/ DWORD dwReserved;
		/*[in]*/ TextSpan* ptsBase;
		/*[in]*/ IVsTextLines* pBuffer;
		/*[out]*/ NavigableLocationResolverFlags* dwOutFlags;
		/*[out,retval]*/ BSTR* pbstrDisplayText;
		HRESULT retValue;
	};

	STDMETHOD(GetDisplayText)(
		/*[in]*/ DWORD dwReserved,
		/*[in]*/ TextSpan* ptsBase,
		/*[in]*/ IVsTextLines* pBuffer,
		/*[out]*/ NavigableLocationResolverFlags* dwOutFlags,
		/*[out,retval]*/ BSTR* pbstrDisplayText)
	{
		VSL_DEFINE_MOCK_METHOD(GetDisplayText)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_CHECK_VALIDVALUE_POINTER(ptsBase);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_SET_VALIDVALUE(dwOutFlags);

		VSL_SET_VALIDVALUE_BSTR(pbstrDisplayText);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPathFromLocationValidValues
	{
		/*[in]*/ DWORD dwReserved;
		/*[in]*/ TextSpan* ptsBase;
		/*[in]*/ IVsTextLines* pBuffer;
		/*[in]*/ WCHAR* pszDisplayText;
		/*[out]*/ NavigableLocationResolverFlags* dwOutFlags;
		/*[out,retval]*/ BSTR* pbstrPath;
		HRESULT retValue;
	};

	STDMETHOD(GetPathFromLocation)(
		/*[in]*/ DWORD dwReserved,
		/*[in]*/ TextSpan* ptsBase,
		/*[in]*/ IVsTextLines* pBuffer,
		/*[in]*/ const WCHAR* pszDisplayText,
		/*[out]*/ NavigableLocationResolverFlags* dwOutFlags,
		/*[out,retval]*/ BSTR* pbstrPath)
	{
		VSL_DEFINE_MOCK_METHOD(GetPathFromLocation)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_CHECK_VALIDVALUE_POINTER(ptsBase);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_CHECK_VALIDVALUE_STRINGW(pszDisplayText);

		VSL_SET_VALIDVALUE(dwOutFlags);

		VSL_SET_VALIDVALUE_BSTR(pbstrPath);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSNAVIGABLELOCATIONRESOLVER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsObjBrowser.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSOBJBROWSER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSOBJBROWSER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsObjBrowserNotImpl :
	public IVsObjBrowser
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsObjBrowserNotImpl)

public:

	typedef IVsObjBrowser Interface;

	STDMETHOD(NavigateTo)(
		/*[in]*/ const VSOBJECTINFO* /*pObjInfo*/,
		/*[in]*/ DWORD /*dwReserved*/)VSL_STDMETHOD_NOTIMPL
};

class IVsObjBrowserMockImpl :
	public IVsObjBrowser,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsObjBrowserMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsObjBrowserMockImpl)

	typedef IVsObjBrowser Interface;
	struct NavigateToValidValues
	{
		/*[in]*/ VSOBJECTINFO* pObjInfo;
		/*[in]*/ DWORD dwReserved;
		HRESULT retValue;
	};

	STDMETHOD(NavigateTo)(
		/*[in]*/ const VSOBJECTINFO* pObjInfo,
		/*[in]*/ DWORD dwReserved)
	{
		VSL_DEFINE_MOCK_METHOD(NavigateTo)

		VSL_CHECK_VALIDVALUE_POINTER(pObjInfo);

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSOBJBROWSER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsNavInfo.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSNAVINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSNAVINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsNavInfoNotImpl :
	public IVsNavInfo
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsNavInfoNotImpl)

public:

	typedef IVsNavInfo Interface;

	STDMETHOD(GetLibGuid)(
		/*[out]*/ GUID* /*pGuid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSymbolType)(
		/*[out]*/ DWORD* /*pdwType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumPresentationNodes)(
		/*[in]*/ DWORD /*dwFlags*/,
		/*[out]*/ IVsEnumNavInfoNodes** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumCanonicalNodes)(
		/*[out]*/ IVsEnumNavInfoNodes** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL
};

class IVsNavInfoMockImpl :
	public IVsNavInfo,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsNavInfoMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsNavInfoMockImpl)

	typedef IVsNavInfo Interface;
	struct GetLibGuidValidValues
	{
		/*[out]*/ GUID* pGuid;
		HRESULT retValue;
	};

	STDMETHOD(GetLibGuid)(
		/*[out]*/ GUID* pGuid)
	{
		VSL_DEFINE_MOCK_METHOD(GetLibGuid)

		VSL_SET_VALIDVALUE(pGuid);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSymbolTypeValidValues
	{
		/*[out]*/ DWORD* pdwType;
		HRESULT retValue;
	};

	STDMETHOD(GetSymbolType)(
		/*[out]*/ DWORD* pdwType)
	{
		VSL_DEFINE_MOCK_METHOD(GetSymbolType)

		VSL_SET_VALIDVALUE(pdwType);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumPresentationNodesValidValues
	{
		/*[in]*/ DWORD dwFlags;
		/*[out]*/ IVsEnumNavInfoNodes** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumPresentationNodes)(
		/*[in]*/ DWORD dwFlags,
		/*[out]*/ IVsEnumNavInfoNodes** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumPresentationNodes)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumCanonicalNodesValidValues
	{
		/*[out]*/ IVsEnumNavInfoNodes** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumCanonicalNodes)(
		/*[out]*/ IVsEnumNavInfoNodes** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumCanonicalNodes)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSNAVINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsNavigationTool.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSNAVIGATIONTOOL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSNAVIGATIONTOOL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsNavigationToolNotImpl :
	public IVsNavigationTool
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsNavigationToolNotImpl)

public:

	typedef IVsNavigationTool Interface;

	STDMETHOD(NavigateToSymbol)(
		/*[in]*/ REFGUID /*guidLib*/,
		/*[in,size_is(ulcNodes)]*/ SYMBOL_DESCRIPTION_NODE[] /*rgSymbolNodes*/,
		/*[in]*/ ULONG /*ulcNodes*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(NavigateToNavInfo)(
		/*[in]*/ IVsNavInfo* /*pNavInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSelectedSymbols)(
		/*[out]*/ IVsSelectedSymbols** /*ppIVsSelectedSymbols*/)VSL_STDMETHOD_NOTIMPL
};

class IVsNavigationToolMockImpl :
	public IVsNavigationTool,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsNavigationToolMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsNavigationToolMockImpl)

	typedef IVsNavigationTool Interface;
	struct NavigateToSymbolValidValues
	{
		/*[in]*/ REFGUID guidLib;
		/*[in,size_is(ulcNodes)]*/ SYMBOL_DESCRIPTION_NODE* rgSymbolNodes;
		/*[in]*/ ULONG ulcNodes;
		HRESULT retValue;
	};

	STDMETHOD(NavigateToSymbol)(
		/*[in]*/ REFGUID guidLib,
		/*[in,size_is(ulcNodes)]*/ SYMBOL_DESCRIPTION_NODE rgSymbolNodes[],
		/*[in]*/ ULONG ulcNodes)
	{
		VSL_DEFINE_MOCK_METHOD(NavigateToSymbol)

		VSL_CHECK_VALIDVALUE(guidLib);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgSymbolNodes, ulcNodes*sizeof(rgSymbolNodes[0]), validValues.ulcNodes*sizeof(validValues.rgSymbolNodes[0]));

		VSL_CHECK_VALIDVALUE(ulcNodes);

		VSL_RETURN_VALIDVALUES();
	}
	struct NavigateToNavInfoValidValues
	{
		/*[in]*/ IVsNavInfo* pNavInfo;
		HRESULT retValue;
	};

	STDMETHOD(NavigateToNavInfo)(
		/*[in]*/ IVsNavInfo* pNavInfo)
	{
		VSL_DEFINE_MOCK_METHOD(NavigateToNavInfo)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pNavInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSelectedSymbolsValidValues
	{
		/*[out]*/ IVsSelectedSymbols** ppIVsSelectedSymbols;
		HRESULT retValue;
	};

	STDMETHOD(GetSelectedSymbols)(
		/*[out]*/ IVsSelectedSymbols** ppIVsSelectedSymbols)
	{
		VSL_DEFINE_MOCK_METHOD(GetSelectedSymbols)

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsSelectedSymbols);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSNAVIGATIONTOOL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsObjectList.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSOBJECTLIST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSOBJECTLIST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsObjectListNotImpl :
	public IVsObjectList
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsObjectListNotImpl)

public:

	typedef IVsObjectList Interface;

	STDMETHOD(GetCapabilities)(
		/*[out]*/ LIB_LISTCAPABILITIES* /*pCapabilities*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetList)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ LIB_LISTTYPE /*ListType*/,
		/*[in]*/ LIB_LISTFLAGS /*Flags*/,
		/*[in]*/ VSOBSEARCHCRITERIA* /*pobSrch*/,
		/*[out]*/ IVsObjectList** /*ppList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCategoryField)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ LIB_CATEGORY /*Category*/,
		/*[out,retval]*/ DWORD* /*pField*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExpandable2)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ LIB_LISTTYPE /*ListTypeExcluded*/,
		/*[out]*/ BOOL* /*pfExpandable*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetNavigationInfo)(
		/*[in]*/ ULONG /*Index*/,
		/*[in,out]*/ VSOBNAVIGATIONINFO2* /*pobNav*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LocateNavigationInfo)(
		/*[in]*/ VSOBNAVIGATIONINFO2* /*pobNav*/,
		/*[in]*/ VSOBNAVNAMEINFONODE* /*pobName*/,
		/*[in]*/ BOOL /*fDontUpdate*/,
		/*[out]*/ BOOL* /*pfMatchedName*/,
		/*[out]*/ ULONG* /*pIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBrowseObject)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ IDispatch** /*ppdispBrowseObj*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetUserContext)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ IUnknown** /*ppunkUserCtx*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ShowHelp)(
		/*[in]*/ ULONG /*Index*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSourceContext)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ const WCHAR** /*pszFileName*/,
		/*[out]*/ ULONG* /*pulLineNum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CountSourceItems)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ IVsHierarchy** /*ppHier*/,
		/*[out]*/ VSITEMID* /*pitemid*/,
		/*[out,retval]*/ ULONG* /*pcItems*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMultipleSourceItems)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSGSIFLAGS /*grfGSI*/,
		/*[in]*/ ULONG /*cItems*/,
		/*[out,size_is(cItems)]*/ VSITEMSELECTION[] /*rgItemSel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanGoToSource)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSOBJGOTOSRCTYPE /*SrcType*/,
		/*[out]*/ BOOL* /*pfOK*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GoToSource)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSOBJGOTOSRCTYPE /*SrcType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetContextMenu)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ CLSID* /*pclsidActive*/,
		/*[out]*/ LONG* /*pnMenuId*/,
		/*[out]*/ IOleCommandTarget** /*ppCmdTrgtActive*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryDragDrop)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ IDataObject* /*pDataObject*/,
		/*[in]*/ DWORD /*grfKeyState*/,
		/*[in,out]*/ DWORD* /*pdwEffect*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DoDragDrop)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ IDataObject* /*pDataObject*/,
		/*[in]*/ DWORD /*grfKeyState*/,
		/*[in,out]*/ DWORD* /*pdwEffect*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanRename)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ LPCOLESTR /*pszNewName*/,
		/*[out]*/ BOOL* /*pfOK*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DoRename)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ LPCOLESTR /*pszNewName*/,
		/*[in]*/ VSOBJOPFLAGS /*grfFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanDelete)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ BOOL* /*pfOK*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DoDelete)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSOBJOPFLAGS /*grfFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FillDescription)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSOBJDESCOPTIONS /*grfOptions*/,
		/*[in]*/ IVsObjectBrowserDescription2* /*pobDesc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumClipboardFormats)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSOBJCFFLAGS /*grfFlags*/,
		/*[in]*/ ULONG /*celt*/,
		/*[in,out,size_is(celt)]*/ VSOBJCLIPFORMAT[] /*rgcfFormats*/,
		/*[out,optional]*/ ULONG* /*pcActual*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetClipboardFormat)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSOBJCFFLAGS /*grfFlags*/,
		/*[in]*/ FORMATETC* /*pFormatetc*/,
		/*[in]*/ STGMEDIUM* /*pMedium*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExtendedClipboardVariant)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSOBJCFFLAGS /*grfFlags*/,
		/*[in]*/ const VSOBJCLIPFORMAT* /*pcfFormat*/,
		/*[out]*/ VARIANT* /*pvarFormat*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFlags)(
		/*[out]*/ VSTREEFLAGS* /*pFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetItemCount)(
		/*[out]*/ ULONG* /*pCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExpandedList)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ BOOL* /*pfCanRecurse*/,
		/*[out]*/ IVsLiteTreeList** /*pptlNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LocateExpandedList)(
		/*[in]*/ IVsLiteTreeList* /*ExpandedList*/,
		/*[out]*/ ULONG* /*iIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnClose)(
		/*[out]*/ VSTREECLOSEACTIONS* /*ptca*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetText)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSTREETEXTOPTIONS /*tto*/,
		/*[out]*/ const WCHAR** /*ppszText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTipText)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSTREETOOLTIPTYPE /*eTipType*/,
		/*[out]*/ const WCHAR** /*ppszText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExpandable)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ BOOL* /*pfExpandable*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDisplayData)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ VSTREEDISPLAYDATA* /*pData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateCounter)(
		/*[out]*/ ULONG* /*pCurUpdate*/,
		/*[out]*/ VSTREEITEMCHANGESMASK* /*pgrfChanges*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetListChanges)(
		/*[in,out]*/ ULONG* /*pcChanges*/,
		/*[in,size_is(*pcChanges)]*/ VSTREELISTITEMCHANGE* /*prgListChanges*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ToggleState)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ VSTREESTATECHANGEREFRESH* /*ptscr*/)VSL_STDMETHOD_NOTIMPL
};

class IVsObjectListMockImpl :
	public IVsObjectList,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsObjectListMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsObjectListMockImpl)

	typedef IVsObjectList Interface;
	struct GetCapabilitiesValidValues
	{
		/*[out]*/ LIB_LISTCAPABILITIES* pCapabilities;
		HRESULT retValue;
	};

	STDMETHOD(GetCapabilities)(
		/*[out]*/ LIB_LISTCAPABILITIES* pCapabilities)
	{
		VSL_DEFINE_MOCK_METHOD(GetCapabilities)

		VSL_SET_VALIDVALUE(pCapabilities);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetListValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ LIB_LISTTYPE ListType;
		/*[in]*/ LIB_LISTFLAGS Flags;
		/*[in]*/ VSOBSEARCHCRITERIA* pobSrch;
		/*[out]*/ IVsObjectList** ppList;
		HRESULT retValue;
	};

	STDMETHOD(GetList)(
		/*[in]*/ ULONG Index,
		/*[in]*/ LIB_LISTTYPE ListType,
		/*[in]*/ LIB_LISTFLAGS Flags,
		/*[in]*/ VSOBSEARCHCRITERIA* pobSrch,
		/*[out]*/ IVsObjectList** ppList)
	{
		VSL_DEFINE_MOCK_METHOD(GetList)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(ListType);

		VSL_CHECK_VALIDVALUE(Flags);

		VSL_CHECK_VALIDVALUE_POINTER(pobSrch);

		VSL_SET_VALIDVALUE_INTERFACE(ppList);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCategoryFieldValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ LIB_CATEGORY Category;
		/*[out,retval]*/ DWORD* pField;
		HRESULT retValue;
	};

	STDMETHOD(GetCategoryField)(
		/*[in]*/ ULONG Index,
		/*[in]*/ LIB_CATEGORY Category,
		/*[out,retval]*/ DWORD* pField)
	{
		VSL_DEFINE_MOCK_METHOD(GetCategoryField)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(Category);

		VSL_SET_VALIDVALUE(pField);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExpandable2ValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ LIB_LISTTYPE ListTypeExcluded;
		/*[out]*/ BOOL* pfExpandable;
		HRESULT retValue;
	};

	STDMETHOD(GetExpandable2)(
		/*[in]*/ ULONG Index,
		/*[in]*/ LIB_LISTTYPE ListTypeExcluded,
		/*[out]*/ BOOL* pfExpandable)
	{
		VSL_DEFINE_MOCK_METHOD(GetExpandable2)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(ListTypeExcluded);

		VSL_SET_VALIDVALUE(pfExpandable);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNavigationInfoValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in,out]*/ VSOBNAVIGATIONINFO2* pobNav;
		HRESULT retValue;
	};

	STDMETHOD(GetNavigationInfo)(
		/*[in]*/ ULONG Index,
		/*[in,out]*/ VSOBNAVIGATIONINFO2* pobNav)
	{
		VSL_DEFINE_MOCK_METHOD(GetNavigationInfo)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE(pobNav);

		VSL_RETURN_VALIDVALUES();
	}
	struct LocateNavigationInfoValidValues
	{
		/*[in]*/ VSOBNAVIGATIONINFO2* pobNav;
		/*[in]*/ VSOBNAVNAMEINFONODE* pobName;
		/*[in]*/ BOOL fDontUpdate;
		/*[out]*/ BOOL* pfMatchedName;
		/*[out]*/ ULONG* pIndex;
		HRESULT retValue;
	};

	STDMETHOD(LocateNavigationInfo)(
		/*[in]*/ VSOBNAVIGATIONINFO2* pobNav,
		/*[in]*/ VSOBNAVNAMEINFONODE* pobName,
		/*[in]*/ BOOL fDontUpdate,
		/*[out]*/ BOOL* pfMatchedName,
		/*[out]*/ ULONG* pIndex)
	{
		VSL_DEFINE_MOCK_METHOD(LocateNavigationInfo)

		VSL_CHECK_VALIDVALUE_POINTER(pobNav);

		VSL_CHECK_VALIDVALUE_POINTER(pobName);

		VSL_CHECK_VALIDVALUE(fDontUpdate);

		VSL_SET_VALIDVALUE(pfMatchedName);

		VSL_SET_VALIDVALUE(pIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBrowseObjectValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ IDispatch** ppdispBrowseObj;
		HRESULT retValue;
	};

	STDMETHOD(GetBrowseObject)(
		/*[in]*/ ULONG Index,
		/*[out]*/ IDispatch** ppdispBrowseObj)
	{
		VSL_DEFINE_MOCK_METHOD(GetBrowseObject)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE_INTERFACE(ppdispBrowseObj);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetUserContextValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ IUnknown** ppunkUserCtx;
		HRESULT retValue;
	};

	STDMETHOD(GetUserContext)(
		/*[in]*/ ULONG Index,
		/*[out]*/ IUnknown** ppunkUserCtx)
	{
		VSL_DEFINE_MOCK_METHOD(GetUserContext)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE_INTERFACE(ppunkUserCtx);

		VSL_RETURN_VALIDVALUES();
	}
	struct ShowHelpValidValues
	{
		/*[in]*/ ULONG Index;
		HRESULT retValue;
	};

	STDMETHOD(ShowHelp)(
		/*[in]*/ ULONG Index)
	{
		VSL_DEFINE_MOCK_METHOD(ShowHelp)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSourceContextValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ WCHAR** pszFileName;
		/*[out]*/ ULONG* pulLineNum;
		HRESULT retValue;
	};

	STDMETHOD(GetSourceContext)(
		/*[in]*/ ULONG Index,
		/*[out]*/ const WCHAR** pszFileName,
		/*[out]*/ ULONG* pulLineNum)
	{
		VSL_DEFINE_MOCK_METHOD(GetSourceContext)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE_CONST(pszFileName, WCHAR**);

		VSL_SET_VALIDVALUE(pulLineNum);

		VSL_RETURN_VALIDVALUES();
	}
	struct CountSourceItemsValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ IVsHierarchy** ppHier;
		/*[out]*/ VSITEMID* pitemid;
		/*[out,retval]*/ ULONG* pcItems;
		HRESULT retValue;
	};

	STDMETHOD(CountSourceItems)(
		/*[in]*/ ULONG Index,
		/*[out]*/ IVsHierarchy** ppHier,
		/*[out]*/ VSITEMID* pitemid,
		/*[out,retval]*/ ULONG* pcItems)
	{
		VSL_DEFINE_MOCK_METHOD(CountSourceItems)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE_INTERFACE(ppHier);

		VSL_SET_VALIDVALUE(pitemid);

		VSL_SET_VALIDVALUE(pcItems);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMultipleSourceItemsValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSGSIFLAGS grfGSI;
		/*[in]*/ ULONG cItems;
		/*[out,size_is(cItems)]*/ VSITEMSELECTION* rgItemSel;
		HRESULT retValue;
	};

	STDMETHOD(GetMultipleSourceItems)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSGSIFLAGS grfGSI,
		/*[in]*/ ULONG cItems,
		/*[out,size_is(cItems)]*/ VSITEMSELECTION rgItemSel[])
	{
		VSL_DEFINE_MOCK_METHOD(GetMultipleSourceItems)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(grfGSI);

		VSL_CHECK_VALIDVALUE(cItems);

		VSL_SET_VALIDVALUE_MEMCPY(rgItemSel, cItems*sizeof(rgItemSel[0]), validValues.cItems*sizeof(validValues.rgItemSel[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct CanGoToSourceValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSOBJGOTOSRCTYPE SrcType;
		/*[out]*/ BOOL* pfOK;
		HRESULT retValue;
	};

	STDMETHOD(CanGoToSource)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSOBJGOTOSRCTYPE SrcType,
		/*[out]*/ BOOL* pfOK)
	{
		VSL_DEFINE_MOCK_METHOD(CanGoToSource)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(SrcType);

		VSL_SET_VALIDVALUE(pfOK);

		VSL_RETURN_VALIDVALUES();
	}
	struct GoToSourceValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSOBJGOTOSRCTYPE SrcType;
		HRESULT retValue;
	};

	STDMETHOD(GoToSource)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSOBJGOTOSRCTYPE SrcType)
	{
		VSL_DEFINE_MOCK_METHOD(GoToSource)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(SrcType);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetContextMenuValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ CLSID* pclsidActive;
		/*[out]*/ LONG* pnMenuId;
		/*[out]*/ IOleCommandTarget** ppCmdTrgtActive;
		HRESULT retValue;
	};

	STDMETHOD(GetContextMenu)(
		/*[in]*/ ULONG Index,
		/*[out]*/ CLSID* pclsidActive,
		/*[out]*/ LONG* pnMenuId,
		/*[out]*/ IOleCommandTarget** ppCmdTrgtActive)
	{
		VSL_DEFINE_MOCK_METHOD(GetContextMenu)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE(pclsidActive);

		VSL_SET_VALIDVALUE(pnMenuId);

		VSL_SET_VALIDVALUE_INTERFACE(ppCmdTrgtActive);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryDragDropValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ IDataObject* pDataObject;
		/*[in]*/ DWORD grfKeyState;
		/*[in,out]*/ DWORD* pdwEffect;
		HRESULT retValue;
	};

	STDMETHOD(QueryDragDrop)(
		/*[in]*/ ULONG Index,
		/*[in]*/ IDataObject* pDataObject,
		/*[in]*/ DWORD grfKeyState,
		/*[in,out]*/ DWORD* pdwEffect)
	{
		VSL_DEFINE_MOCK_METHOD(QueryDragDrop)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDataObject);

		VSL_CHECK_VALIDVALUE(grfKeyState);

		VSL_SET_VALIDVALUE(pdwEffect);

		VSL_RETURN_VALIDVALUES();
	}
	struct DoDragDropValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ IDataObject* pDataObject;
		/*[in]*/ DWORD grfKeyState;
		/*[in,out]*/ DWORD* pdwEffect;
		HRESULT retValue;
	};

	STDMETHOD(DoDragDrop)(
		/*[in]*/ ULONG Index,
		/*[in]*/ IDataObject* pDataObject,
		/*[in]*/ DWORD grfKeyState,
		/*[in,out]*/ DWORD* pdwEffect)
	{
		VSL_DEFINE_MOCK_METHOD(DoDragDrop)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDataObject);

		VSL_CHECK_VALIDVALUE(grfKeyState);

		VSL_SET_VALIDVALUE(pdwEffect);

		VSL_RETURN_VALIDVALUES();
	}
	struct CanRenameValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ LPCOLESTR pszNewName;
		/*[out]*/ BOOL* pfOK;
		HRESULT retValue;
	};

	STDMETHOD(CanRename)(
		/*[in]*/ ULONG Index,
		/*[in]*/ LPCOLESTR pszNewName,
		/*[out]*/ BOOL* pfOK)
	{
		VSL_DEFINE_MOCK_METHOD(CanRename)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE_STRINGW(pszNewName);

		VSL_SET_VALIDVALUE(pfOK);

		VSL_RETURN_VALIDVALUES();
	}
	struct DoRenameValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ LPCOLESTR pszNewName;
		/*[in]*/ VSOBJOPFLAGS grfFlags;
		HRESULT retValue;
	};

	STDMETHOD(DoRename)(
		/*[in]*/ ULONG Index,
		/*[in]*/ LPCOLESTR pszNewName,
		/*[in]*/ VSOBJOPFLAGS grfFlags)
	{
		VSL_DEFINE_MOCK_METHOD(DoRename)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE_STRINGW(pszNewName);

		VSL_CHECK_VALIDVALUE(grfFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct CanDeleteValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ BOOL* pfOK;
		HRESULT retValue;
	};

	STDMETHOD(CanDelete)(
		/*[in]*/ ULONG Index,
		/*[out]*/ BOOL* pfOK)
	{
		VSL_DEFINE_MOCK_METHOD(CanDelete)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE(pfOK);

		VSL_RETURN_VALIDVALUES();
	}
	struct DoDeleteValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSOBJOPFLAGS grfFlags;
		HRESULT retValue;
	};

	STDMETHOD(DoDelete)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSOBJOPFLAGS grfFlags)
	{
		VSL_DEFINE_MOCK_METHOD(DoDelete)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(grfFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct FillDescriptionValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSOBJDESCOPTIONS grfOptions;
		/*[in]*/ IVsObjectBrowserDescription2* pobDesc;
		HRESULT retValue;
	};

	STDMETHOD(FillDescription)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSOBJDESCOPTIONS grfOptions,
		/*[in]*/ IVsObjectBrowserDescription2* pobDesc)
	{
		VSL_DEFINE_MOCK_METHOD(FillDescription)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(grfOptions);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pobDesc);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumClipboardFormatsValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSOBJCFFLAGS grfFlags;
		/*[in]*/ ULONG celt;
		/*[in,out,size_is(celt)]*/ VSOBJCLIPFORMAT* rgcfFormats;
		/*[out,optional]*/ ULONG* pcActual;
		HRESULT retValue;
	};

	STDMETHOD(EnumClipboardFormats)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSOBJCFFLAGS grfFlags,
		/*[in]*/ ULONG celt,
		/*[in,out,size_is(celt)]*/ VSOBJCLIPFORMAT rgcfFormats[],
		/*[out,optional]*/ ULONG* pcActual)
	{
		VSL_DEFINE_MOCK_METHOD(EnumClipboardFormats)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(grfFlags);

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(rgcfFormats, celt*sizeof(rgcfFormats[0]), validValues.celt*sizeof(validValues.rgcfFormats[0]));

		VSL_SET_VALIDVALUE(pcActual);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetClipboardFormatValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSOBJCFFLAGS grfFlags;
		/*[in]*/ FORMATETC* pFormatetc;
		/*[in]*/ STGMEDIUM* pMedium;
		HRESULT retValue;
	};

	STDMETHOD(GetClipboardFormat)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSOBJCFFLAGS grfFlags,
		/*[in]*/ FORMATETC* pFormatetc,
		/*[in]*/ STGMEDIUM* pMedium)
	{
		VSL_DEFINE_MOCK_METHOD(GetClipboardFormat)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(grfFlags);

		VSL_CHECK_VALIDVALUE_POINTER(pFormatetc);

		VSL_CHECK_VALIDVALUE_POINTER(pMedium);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExtendedClipboardVariantValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSOBJCFFLAGS grfFlags;
		/*[in]*/ VSOBJCLIPFORMAT* pcfFormat;
		/*[out]*/ VARIANT* pvarFormat;
		HRESULT retValue;
	};

	STDMETHOD(GetExtendedClipboardVariant)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSOBJCFFLAGS grfFlags,
		/*[in]*/ const VSOBJCLIPFORMAT* pcfFormat,
		/*[out]*/ VARIANT* pvarFormat)
	{
		VSL_DEFINE_MOCK_METHOD(GetExtendedClipboardVariant)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(grfFlags);

		VSL_CHECK_VALIDVALUE_POINTER(pcfFormat);

		VSL_SET_VALIDVALUE_VARIANT(pvarFormat);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFlagsValidValues
	{
		/*[out]*/ VSTREEFLAGS* pFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetFlags)(
		/*[out]*/ VSTREEFLAGS* pFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetFlags)

		VSL_SET_VALIDVALUE(pFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetItemCountValidValues
	{
		/*[out]*/ ULONG* pCount;
		HRESULT retValue;
	};

	STDMETHOD(GetItemCount)(
		/*[out]*/ ULONG* pCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetItemCount)

		VSL_SET_VALIDVALUE(pCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExpandedListValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ BOOL* pfCanRecurse;
		/*[out]*/ IVsLiteTreeList** pptlNode;
		HRESULT retValue;
	};

	STDMETHOD(GetExpandedList)(
		/*[in]*/ ULONG Index,
		/*[out]*/ BOOL* pfCanRecurse,
		/*[out]*/ IVsLiteTreeList** pptlNode)
	{
		VSL_DEFINE_MOCK_METHOD(GetExpandedList)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE(pfCanRecurse);

		VSL_SET_VALIDVALUE_INTERFACE(pptlNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct LocateExpandedListValidValues
	{
		/*[in]*/ IVsLiteTreeList* ExpandedList;
		/*[out]*/ ULONG* iIndex;
		HRESULT retValue;
	};

	STDMETHOD(LocateExpandedList)(
		/*[in]*/ IVsLiteTreeList* ExpandedList,
		/*[out]*/ ULONG* iIndex)
	{
		VSL_DEFINE_MOCK_METHOD(LocateExpandedList)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(ExpandedList);

		VSL_SET_VALIDVALUE(iIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnCloseValidValues
	{
		/*[out]*/ VSTREECLOSEACTIONS* ptca;
		HRESULT retValue;
	};

	STDMETHOD(OnClose)(
		/*[out]*/ VSTREECLOSEACTIONS* ptca)
	{
		VSL_DEFINE_MOCK_METHOD(OnClose)

		VSL_SET_VALIDVALUE(ptca);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTextValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSTREETEXTOPTIONS tto;
		/*[out]*/ WCHAR** ppszText;
		HRESULT retValue;
	};

	STDMETHOD(GetText)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSTREETEXTOPTIONS tto,
		/*[out]*/ const WCHAR** ppszText)
	{
		VSL_DEFINE_MOCK_METHOD(GetText)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(tto);

		VSL_SET_VALIDVALUE_CONST(ppszText, WCHAR**);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTipTextValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSTREETOOLTIPTYPE eTipType;
		/*[out]*/ WCHAR** ppszText;
		HRESULT retValue;
	};

	STDMETHOD(GetTipText)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSTREETOOLTIPTYPE eTipType,
		/*[out]*/ const WCHAR** ppszText)
	{
		VSL_DEFINE_MOCK_METHOD(GetTipText)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(eTipType);

		VSL_SET_VALIDVALUE_CONST(ppszText, WCHAR**);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExpandableValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ BOOL* pfExpandable;
		HRESULT retValue;
	};

	STDMETHOD(GetExpandable)(
		/*[in]*/ ULONG Index,
		/*[out]*/ BOOL* pfExpandable)
	{
		VSL_DEFINE_MOCK_METHOD(GetExpandable)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE(pfExpandable);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDisplayDataValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ VSTREEDISPLAYDATA* pData;
		HRESULT retValue;
	};

	STDMETHOD(GetDisplayData)(
		/*[in]*/ ULONG Index,
		/*[out]*/ VSTREEDISPLAYDATA* pData)
	{
		VSL_DEFINE_MOCK_METHOD(GetDisplayData)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE(pData);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateCounterValidValues
	{
		/*[out]*/ ULONG* pCurUpdate;
		/*[out]*/ VSTREEITEMCHANGESMASK* pgrfChanges;
		HRESULT retValue;
	};

	STDMETHOD(UpdateCounter)(
		/*[out]*/ ULONG* pCurUpdate,
		/*[out]*/ VSTREEITEMCHANGESMASK* pgrfChanges)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateCounter)

		VSL_SET_VALIDVALUE(pCurUpdate);

		VSL_SET_VALIDVALUE(pgrfChanges);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetListChangesValidValues
	{
		/*[in,out]*/ ULONG* pcChanges;
		/*[in,size_is(*pcChanges)]*/ VSTREELISTITEMCHANGE* prgListChanges;
		HRESULT retValue;
	};

	STDMETHOD(GetListChanges)(
		/*[in,out]*/ ULONG* pcChanges,
		/*[in,size_is(*pcChanges)]*/ VSTREELISTITEMCHANGE* prgListChanges)
	{
		VSL_DEFINE_MOCK_METHOD(GetListChanges)

		VSL_SET_VALIDVALUE(pcChanges);

		VSL_CHECK_VALIDVALUE_MEMCMP(prgListChanges, *pcChanges*sizeof(prgListChanges[0]), *(validValues.pcChanges)*sizeof(validValues.prgListChanges[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct ToggleStateValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ VSTREESTATECHANGEREFRESH* ptscr;
		HRESULT retValue;
	};

	STDMETHOD(ToggleState)(
		/*[in]*/ ULONG Index,
		/*[out]*/ VSTREESTATECHANGEREFRESH* ptscr)
	{
		VSL_DEFINE_MOCK_METHOD(ToggleState)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE(ptscr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSOBJECTLIST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsNonLocalProject.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSNONLOCALPROJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSNONLOCALPROJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsNonLocalProjectNotImpl :
	public IVsNonLocalProject
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsNonLocalProjectNotImpl)

public:

	typedef IVsNonLocalProject Interface;

	STDMETHOD(EnsureLocalCopy)(
		/*[in]*/ VSITEMID /*itemid*/)VSL_STDMETHOD_NOTIMPL
};

class IVsNonLocalProjectMockImpl :
	public IVsNonLocalProject,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsNonLocalProjectMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsNonLocalProjectMockImpl)

	typedef IVsNonLocalProject Interface;
	struct EnsureLocalCopyValidValues
	{
		/*[in]*/ VSITEMID itemid;
		HRESULT retValue;
	};

	STDMETHOD(EnsureLocalCopy)(
		/*[in]*/ VSITEMID itemid)
	{
		VSL_DEFINE_MOCK_METHOD(EnsureLocalCopy)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSNONLOCALPROJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsNavInfoNode.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSNAVINFONODE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSNAVINFONODE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsNavInfoNodeNotImpl :
	public IVsNavInfoNode
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsNavInfoNodeNotImpl)

public:

	typedef IVsNavInfoNode Interface;

	STDMETHOD(get_Type)(
		/*[out]*/ DWORD* /*pllt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Name)(
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL
};

class IVsNavInfoNodeMockImpl :
	public IVsNavInfoNode,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsNavInfoNodeMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsNavInfoNodeMockImpl)

	typedef IVsNavInfoNode Interface;
	struct get_TypeValidValues
	{
		/*[out]*/ DWORD* pllt;
		HRESULT retValue;
	};

	STDMETHOD(get_Type)(
		/*[out]*/ DWORD* pllt)
	{
		VSL_DEFINE_MOCK_METHOD(get_Type)

		VSL_SET_VALIDVALUE(pllt);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_NameValidValues
	{
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(get_Name)(
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(get_Name)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSNAVINFONODE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsObjectBrowserDescription3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSOBJECTBROWSERDESCRIPTION3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSOBJECTBROWSERDESCRIPTION3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsObjectBrowserDescription3NotImpl :
	public IVsObjectBrowserDescription3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsObjectBrowserDescription3NotImpl)

public:

	typedef IVsObjectBrowserDescription3 Interface;

	STDMETHOD(AddDescriptionText3)(
		/*[in]*/ LPCWSTR /*pText*/,
		/*[in]*/ VSOBDESCRIPTIONSECTION /*obdSect*/,
		/*[in]*/ IVsNavInfo* /*pHyperJump*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ClearDescriptionText)()VSL_STDMETHOD_NOTIMPL
};

class IVsObjectBrowserDescription3MockImpl :
	public IVsObjectBrowserDescription3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsObjectBrowserDescription3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsObjectBrowserDescription3MockImpl)

	typedef IVsObjectBrowserDescription3 Interface;
	struct AddDescriptionText3ValidValues
	{
		/*[in]*/ LPCWSTR pText;
		/*[in]*/ VSOBDESCRIPTIONSECTION obdSect;
		/*[in]*/ IVsNavInfo* pHyperJump;
		HRESULT retValue;
	};

	STDMETHOD(AddDescriptionText3)(
		/*[in]*/ LPCWSTR pText,
		/*[in]*/ VSOBDESCRIPTIONSECTION obdSect,
		/*[in]*/ IVsNavInfo* pHyperJump)
	{
		VSL_DEFINE_MOCK_METHOD(AddDescriptionText3)

		VSL_CHECK_VALIDVALUE_STRINGW(pText);

		VSL_CHECK_VALIDVALUE(obdSect);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHyperJump);

		VSL_RETURN_VALIDVALUES();
	}
	struct ClearDescriptionTextValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ClearDescriptionText)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ClearDescriptionText)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSOBJECTBROWSERDESCRIPTION3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsObjectBrowserDescription2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSOBJECTBROWSERDESCRIPTION2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSOBJECTBROWSERDESCRIPTION2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsObjectBrowserDescription2NotImpl :
	public IVsObjectBrowserDescription2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsObjectBrowserDescription2NotImpl)

public:

	typedef IVsObjectBrowserDescription2 Interface;

	STDMETHOD(AddDescriptionText)(
		/*[in]*/ LPCWSTR /*pText*/,
		/*[in]*/ VSOBDESCRIPTIONSECTION /*obdSect*/,
		/*[in]*/ VSOBJECTINFO* /*pHyperJump*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ClearDescriptionText)()VSL_STDMETHOD_NOTIMPL
};

class IVsObjectBrowserDescription2MockImpl :
	public IVsObjectBrowserDescription2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsObjectBrowserDescription2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsObjectBrowserDescription2MockImpl)

	typedef IVsObjectBrowserDescription2 Interface;
	struct AddDescriptionTextValidValues
	{
		/*[in]*/ LPCWSTR pText;
		/*[in]*/ VSOBDESCRIPTIONSECTION obdSect;
		/*[in]*/ VSOBJECTINFO* pHyperJump;
		HRESULT retValue;
	};

	STDMETHOD(AddDescriptionText)(
		/*[in]*/ LPCWSTR pText,
		/*[in]*/ VSOBDESCRIPTIONSECTION obdSect,
		/*[in]*/ VSOBJECTINFO* pHyperJump)
	{
		VSL_DEFINE_MOCK_METHOD(AddDescriptionText)

		VSL_CHECK_VALIDVALUE_STRINGW(pText);

		VSL_CHECK_VALIDVALUE(obdSect);

		VSL_CHECK_VALIDVALUE_POINTER(pHyperJump);

		VSL_RETURN_VALIDVALUES();
	}
	struct ClearDescriptionTextValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ClearDescriptionText)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ClearDescriptionText)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSOBJECTBROWSERDESCRIPTION2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsObjectManager2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSOBJECTMANAGER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSOBJECTMANAGER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsObjectManager2NotImpl :
	public IVsObjectManager2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsObjectManager2NotImpl)

public:

	typedef IVsObjectManager2 Interface;

	STDMETHOD(RegisterLibrary)(
		/*[in]*/ IVsLibrary2* /*pLib*/,
		/*[out]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RegisterSimpleLibrary)(
		/*[in]*/ IVsSimpleLibrary2* /*pLib*/,
		/*[out]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnregisterLibrary)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumLibraries)(
		/*[out]*/ IVsEnumLibraries2** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FindLibrary)(
		/*[in]*/ REFGUID /*guidLibrary*/,
		/*[out]*/ IVsLibrary2** /*ppLib*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetListAndIndex)(
		/*[in]*/ IVsNavInfo* /*pNavInfo*/,
		/*[in]*/ DWORD /*dwFlags*/,
		/*[out]*/ IVsObjectList2** /*ppList*/,
		/*[out]*/ ULONG* /*pIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ParseDataObject)(
		/*[in]*/ IDataObject* /*pIDataObject*/,
		/*[out]*/ IVsSelectedSymbols** /*ppSymbols*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateSimpleBrowseComponentSet)(
		/*[in]*/ BROWSE_COMPONENT_SET_TYPE /*Type*/,
		/*[in,size_is(ulcLibs)]*/ const GUID[] /*rgguidLibs*/,
		/*[in]*/ ULONG /*ulcLibs*/,
		/*[out,retval]*/ IVsSimpleBrowseComponentSet** /*ppSet*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateProjectReferenceSet)(
		/*[in]*/ IUnknown* /*pProject*/,
		/*[out,retval]*/ IVsSimpleBrowseComponentSet** /*ppSet*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateCombinedBrowseComponentSet)(
		/*[out,retval]*/ IVsCombinedBrowseComponentSet** /*ppCombinedSet*/)VSL_STDMETHOD_NOTIMPL
};

class IVsObjectManager2MockImpl :
	public IVsObjectManager2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsObjectManager2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsObjectManager2MockImpl)

	typedef IVsObjectManager2 Interface;
	struct RegisterLibraryValidValues
	{
		/*[in]*/ IVsLibrary2* pLib;
		/*[out]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(RegisterLibrary)(
		/*[in]*/ IVsLibrary2* pLib,
		/*[out]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(RegisterLibrary)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pLib);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct RegisterSimpleLibraryValidValues
	{
		/*[in]*/ IVsSimpleLibrary2* pLib;
		/*[out]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(RegisterSimpleLibrary)(
		/*[in]*/ IVsSimpleLibrary2* pLib,
		/*[out]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(RegisterSimpleLibrary)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pLib);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnregisterLibraryValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnregisterLibrary)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnregisterLibrary)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumLibrariesValidValues
	{
		/*[out]*/ IVsEnumLibraries2** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumLibraries)(
		/*[out]*/ IVsEnumLibraries2** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumLibraries)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct FindLibraryValidValues
	{
		/*[in]*/ REFGUID guidLibrary;
		/*[out]*/ IVsLibrary2** ppLib;
		HRESULT retValue;
	};

	STDMETHOD(FindLibrary)(
		/*[in]*/ REFGUID guidLibrary,
		/*[out]*/ IVsLibrary2** ppLib)
	{
		VSL_DEFINE_MOCK_METHOD(FindLibrary)

		VSL_CHECK_VALIDVALUE(guidLibrary);

		VSL_SET_VALIDVALUE_INTERFACE(ppLib);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetListAndIndexValidValues
	{
		/*[in]*/ IVsNavInfo* pNavInfo;
		/*[in]*/ DWORD dwFlags;
		/*[out]*/ IVsObjectList2** ppList;
		/*[out]*/ ULONG* pIndex;
		HRESULT retValue;
	};

	STDMETHOD(GetListAndIndex)(
		/*[in]*/ IVsNavInfo* pNavInfo,
		/*[in]*/ DWORD dwFlags,
		/*[out]*/ IVsObjectList2** ppList,
		/*[out]*/ ULONG* pIndex)
	{
		VSL_DEFINE_MOCK_METHOD(GetListAndIndex)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pNavInfo);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_SET_VALIDVALUE_INTERFACE(ppList);

		VSL_SET_VALIDVALUE(pIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct ParseDataObjectValidValues
	{
		/*[in]*/ IDataObject* pIDataObject;
		/*[out]*/ IVsSelectedSymbols** ppSymbols;
		HRESULT retValue;
	};

	STDMETHOD(ParseDataObject)(
		/*[in]*/ IDataObject* pIDataObject,
		/*[out]*/ IVsSelectedSymbols** ppSymbols)
	{
		VSL_DEFINE_MOCK_METHOD(ParseDataObject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIDataObject);

		VSL_SET_VALIDVALUE_INTERFACE(ppSymbols);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateSimpleBrowseComponentSetValidValues
	{
		/*[in]*/ BROWSE_COMPONENT_SET_TYPE Type;
		/*[in,size_is(ulcLibs)]*/ GUID* rgguidLibs;
		/*[in]*/ ULONG ulcLibs;
		/*[out,retval]*/ IVsSimpleBrowseComponentSet** ppSet;
		HRESULT retValue;
	};

	STDMETHOD(CreateSimpleBrowseComponentSet)(
		/*[in]*/ BROWSE_COMPONENT_SET_TYPE Type,
		/*[in,size_is(ulcLibs)]*/ const GUID rgguidLibs[],
		/*[in]*/ ULONG ulcLibs,
		/*[out,retval]*/ IVsSimpleBrowseComponentSet** ppSet)
	{
		VSL_DEFINE_MOCK_METHOD(CreateSimpleBrowseComponentSet)

		VSL_CHECK_VALIDVALUE(Type);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgguidLibs, ulcLibs*sizeof(rgguidLibs[0]), validValues.ulcLibs*sizeof(validValues.rgguidLibs[0]));

		VSL_CHECK_VALIDVALUE(ulcLibs);

		VSL_SET_VALIDVALUE_INTERFACE(ppSet);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateProjectReferenceSetValidValues
	{
		/*[in]*/ IUnknown* pProject;
		/*[out,retval]*/ IVsSimpleBrowseComponentSet** ppSet;
		HRESULT retValue;
	};

	STDMETHOD(CreateProjectReferenceSet)(
		/*[in]*/ IUnknown* pProject,
		/*[out,retval]*/ IVsSimpleBrowseComponentSet** ppSet)
	{
		VSL_DEFINE_MOCK_METHOD(CreateProjectReferenceSet)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_SET_VALIDVALUE_INTERFACE(ppSet);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateCombinedBrowseComponentSetValidValues
	{
		/*[out,retval]*/ IVsCombinedBrowseComponentSet** ppCombinedSet;
		HRESULT retValue;
	};

	STDMETHOD(CreateCombinedBrowseComponentSet)(
		/*[out,retval]*/ IVsCombinedBrowseComponentSet** ppCombinedSet)
	{
		VSL_DEFINE_MOCK_METHOD(CreateCombinedBrowseComponentSet)

		VSL_SET_VALIDVALUE_INTERFACE(ppCombinedSet);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSOBJECTMANAGER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsObjectListOwner.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSOBJECTLISTOWNER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSOBJECTLISTOWNER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsObjectListOwnerNotImpl :
	public IVsObjectListOwner
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsObjectListOwnerNotImpl)

public:

	typedef IVsObjectListOwner Interface;

	STDMETHOD(GetOptions)(
		/*[in]*/ VSOBJLISTOWNEROTPIONS* /*pOptions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsVisible)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ListLoadRefused)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DoWaitUI)(
		/*[in]*/ BOOL /*fStart*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(NotifySearchHit)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ClearSearchHit)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(HaveSearchHit)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CalculateExtendedText)(
		/*[in]*/ IVsObjectList* /*pList*/,
		/*[in]*/ ULONG /*iItem*/,
		/*[in]*/ LPCWSTR /*strSeperator*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExtendedText)(
		/*[out]*/ LPCWSTR* /*pwszExtText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateDisplayData)(
		/*[in]*/ IVsObjectList* /*pList*/,
		/*[in]*/ ULONG /*iItem*/,
		/*[in]*/ BOOL /*fPackageList*/,
		/*[in]*/ DWORD /*dwReserved*/,
		/*[in,out]*/ VSTREEDISPLAYDATA* /*pData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ClearCachedData)(
		/*[in]*/ VSOBJLISTOWNERCACHEDDATAKINDS /*grfDataKinds*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ClearListFilters)(
		/*[in]*/ DWORD /*dwReserved*/)VSL_STDMETHOD_NOTIMPL
};

class IVsObjectListOwnerMockImpl :
	public IVsObjectListOwner,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsObjectListOwnerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsObjectListOwnerMockImpl)

	typedef IVsObjectListOwner Interface;
	struct GetOptionsValidValues
	{
		/*[in]*/ VSOBJLISTOWNEROTPIONS* pOptions;
		HRESULT retValue;
	};

	STDMETHOD(GetOptions)(
		/*[in]*/ VSOBJLISTOWNEROTPIONS* pOptions)
	{
		VSL_DEFINE_MOCK_METHOD(GetOptions)

		VSL_CHECK_VALIDVALUE_POINTER(pOptions);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsVisibleValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(IsVisible)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(IsVisible)

		VSL_RETURN_VALIDVALUES();
	}
	struct ListLoadRefusedValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ListLoadRefused)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ListLoadRefused)

		VSL_RETURN_VALIDVALUES();
	}
	struct DoWaitUIValidValues
	{
		/*[in]*/ BOOL fStart;
		HRESULT retValue;
	};

	STDMETHOD(DoWaitUI)(
		/*[in]*/ BOOL fStart)
	{
		VSL_DEFINE_MOCK_METHOD(DoWaitUI)

		VSL_CHECK_VALIDVALUE(fStart);

		VSL_RETURN_VALIDVALUES();
	}
	struct NotifySearchHitValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(NotifySearchHit)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(NotifySearchHit)

		VSL_RETURN_VALIDVALUES();
	}
	struct ClearSearchHitValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ClearSearchHit)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ClearSearchHit)

		VSL_RETURN_VALIDVALUES();
	}
	struct HaveSearchHitValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(HaveSearchHit)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(HaveSearchHit)

		VSL_RETURN_VALIDVALUES();
	}
	struct CalculateExtendedTextValidValues
	{
		/*[in]*/ IVsObjectList* pList;
		/*[in]*/ ULONG iItem;
		/*[in]*/ LPCWSTR strSeperator;
		HRESULT retValue;
	};

	STDMETHOD(CalculateExtendedText)(
		/*[in]*/ IVsObjectList* pList,
		/*[in]*/ ULONG iItem,
		/*[in]*/ LPCWSTR strSeperator)
	{
		VSL_DEFINE_MOCK_METHOD(CalculateExtendedText)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pList);

		VSL_CHECK_VALIDVALUE(iItem);

		VSL_CHECK_VALIDVALUE_STRINGW(strSeperator);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExtendedTextValidValues
	{
		/*[out]*/ LPCWSTR* pwszExtText;
		HRESULT retValue;
	};

	STDMETHOD(GetExtendedText)(
		/*[out]*/ LPCWSTR* pwszExtText)
	{
		VSL_DEFINE_MOCK_METHOD(GetExtendedText)

		VSL_SET_VALIDVALUE(pwszExtText);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateDisplayDataValidValues
	{
		/*[in]*/ IVsObjectList* pList;
		/*[in]*/ ULONG iItem;
		/*[in]*/ BOOL fPackageList;
		/*[in]*/ DWORD dwReserved;
		/*[in,out]*/ VSTREEDISPLAYDATA* pData;
		HRESULT retValue;
	};

	STDMETHOD(UpdateDisplayData)(
		/*[in]*/ IVsObjectList* pList,
		/*[in]*/ ULONG iItem,
		/*[in]*/ BOOL fPackageList,
		/*[in]*/ DWORD dwReserved,
		/*[in,out]*/ VSTREEDISPLAYDATA* pData)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateDisplayData)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pList);

		VSL_CHECK_VALIDVALUE(iItem);

		VSL_CHECK_VALIDVALUE(fPackageList);

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_SET_VALIDVALUE(pData);

		VSL_RETURN_VALIDVALUES();
	}
	struct ClearCachedDataValidValues
	{
		/*[in]*/ VSOBJLISTOWNERCACHEDDATAKINDS grfDataKinds;
		HRESULT retValue;
	};

	STDMETHOD(ClearCachedData)(
		/*[in]*/ VSOBJLISTOWNERCACHEDDATAKINDS grfDataKinds)
	{
		VSL_DEFINE_MOCK_METHOD(ClearCachedData)

		VSL_CHECK_VALIDVALUE(grfDataKinds);

		VSL_RETURN_VALIDVALUES();
	}
	struct ClearListFiltersValidValues
	{
		/*[in]*/ DWORD dwReserved;
		HRESULT retValue;
	};

	STDMETHOD(ClearListFilters)(
		/*[in]*/ DWORD dwReserved)
	{
		VSL_DEFINE_MOCK_METHOD(ClearListFilters)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSOBJECTLISTOWNER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsObjectManager.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSOBJECTMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSOBJECTMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsObjectManagerNotImpl :
	public IVsObjectManager
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsObjectManagerNotImpl)

public:

	typedef IVsObjectManager Interface;

	STDMETHOD(RegisterLibMgr)(
		/*[in]*/ REFGUID /*rguidLibMgr*/,
		/*[in]*/ IVsLibraryMgr* /*pLibMgr*/,
		/*[out]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnregisterLibMgr)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumLibMgrs)(
		/*[out]*/ ULONG* /*pCount*/,
		/*[out]*/ IVsLibraryMgr** /*rgpLibMgrs*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RefreshLists)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetList)(
		/*[in]*/ LIB_LISTTYPE /*ListType*/,
		/*[in]*/ LIB_LISTFLAGS /*Flags*/,
		/*[in]*/ IVsLibraryMgr* /*pLibMgr*/,
		/*[in]*/ VSOBSEARCHCRITERIA* /*pobSrch*/,
		/*[out]*/ IVsObjectList** /*ppList*/)VSL_STDMETHOD_NOTIMPL
};

class IVsObjectManagerMockImpl :
	public IVsObjectManager,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsObjectManagerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsObjectManagerMockImpl)

	typedef IVsObjectManager Interface;
	struct RegisterLibMgrValidValues
	{
		/*[in]*/ REFGUID rguidLibMgr;
		/*[in]*/ IVsLibraryMgr* pLibMgr;
		/*[out]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(RegisterLibMgr)(
		/*[in]*/ REFGUID rguidLibMgr,
		/*[in]*/ IVsLibraryMgr* pLibMgr,
		/*[out]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(RegisterLibMgr)

		VSL_CHECK_VALIDVALUE(rguidLibMgr);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pLibMgr);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnregisterLibMgrValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnregisterLibMgr)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnregisterLibMgr)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumLibMgrsValidValues
	{
		/*[out]*/ ULONG* pCount;
		/*[out]*/ IVsLibraryMgr** rgpLibMgrs;
		HRESULT retValue;
	};

	STDMETHOD(EnumLibMgrs)(
		/*[out]*/ ULONG* pCount,
		/*[out]*/ IVsLibraryMgr** rgpLibMgrs)
	{
		VSL_DEFINE_MOCK_METHOD(EnumLibMgrs)

		VSL_SET_VALIDVALUE(pCount);

		VSL_SET_VALIDVALUE_INTERFACE(rgpLibMgrs);

		VSL_RETURN_VALIDVALUES();
	}
	struct RefreshListsValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(RefreshLists)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(RefreshLists)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetListValidValues
	{
		/*[in]*/ LIB_LISTTYPE ListType;
		/*[in]*/ LIB_LISTFLAGS Flags;
		/*[in]*/ IVsLibraryMgr* pLibMgr;
		/*[in]*/ VSOBSEARCHCRITERIA* pobSrch;
		/*[out]*/ IVsObjectList** ppList;
		HRESULT retValue;
	};

	STDMETHOD(GetList)(
		/*[in]*/ LIB_LISTTYPE ListType,
		/*[in]*/ LIB_LISTFLAGS Flags,
		/*[in]*/ IVsLibraryMgr* pLibMgr,
		/*[in]*/ VSOBSEARCHCRITERIA* pobSrch,
		/*[out]*/ IVsObjectList** ppList)
	{
		VSL_DEFINE_MOCK_METHOD(GetList)

		VSL_CHECK_VALIDVALUE(ListType);

		VSL_CHECK_VALIDVALUE(Flags);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pLibMgr);

		VSL_CHECK_VALIDVALUE_POINTER(pobSrch);

		VSL_SET_VALIDVALUE_INTERFACE(ppList);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSOBJECTMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsObjectList2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSOBJECTLIST2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSOBJECTLIST2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsObjectList2NotImpl :
	public IVsObjectList2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsObjectList2NotImpl)

public:

	typedef IVsObjectList2 Interface;

	STDMETHOD(GetFlags)(
		/*[out]*/ VSTREEFLAGS* /*pFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetItemCount)(
		/*[out]*/ ULONG* /*pCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExpandedList)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ BOOL* /*pfCanRecurse*/,
		/*[out]*/ IVsLiteTreeList** /*pptlNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LocateExpandedList)(
		/*[in]*/ IVsLiteTreeList* /*ExpandedList*/,
		/*[out]*/ ULONG* /*iIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnClose)(
		/*[out]*/ VSTREECLOSEACTIONS* /*ptca*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetText)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSTREETEXTOPTIONS /*tto*/,
		/*[out,string]*/ const WCHAR** /*ppszText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTipText)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSTREETOOLTIPTYPE /*eTipType*/,
		/*[out,string]*/ const WCHAR** /*ppszText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExpandable)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ BOOL* /*pfExpandable*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDisplayData)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ VSTREEDISPLAYDATA* /*pData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateCounter)(
		/*[out]*/ ULONG* /*pCurUpdate*/,
		/*[out]*/ VSTREEITEMCHANGESMASK* /*pgrfChanges*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetListChanges)(
		/*[in,out]*/ ULONG* /*pcChanges*/,
		/*[in,size_is(*pcChanges)]*/ VSTREELISTITEMCHANGE* /*prgListChanges*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ToggleState)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ VSTREESTATECHANGEREFRESH* /*ptscr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCapabilities2)(
		/*[out]*/ LIB_LISTCAPABILITIES2* /*pgrfCapabilities*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetList2)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ LIB_LISTTYPE2 /*ListType*/,
		/*[in]*/ LIB_LISTFLAGS /*Flags*/,
		/*[in]*/ VSOBSEARCHCRITERIA2* /*pobSrch*/,
		/*[out,retval]*/ IVsObjectList2** /*ppIVsObjectList2*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCategoryField2)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ LIB_CATEGORY2 /*Category*/,
		/*[out,retval]*/ DWORD* /*pfCatField*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExpandable3)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ LIB_LISTTYPE2 /*ListTypeExcluded*/,
		/*[out]*/ BOOL* /*pfExpandable*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetNavigationInfo2)(
		/*[in]*/ ULONG /*Index*/,
		/*[in,out]*/ VSOBNAVIGATIONINFO3* /*pobNav*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LocateNavigationInfo2)(
		/*[in]*/ VSOBNAVIGATIONINFO3* /*pobNav*/,
		/*[in]*/ VSOBNAVNAMEINFONODE2* /*pobName*/,
		/*[in]*/ BOOL /*fDontUpdate*/,
		/*[out]*/ BOOL* /*pfMatchedName*/,
		/*[out]*/ ULONG* /*pIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBrowseObject)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ IDispatch** /*ppdispBrowseObj*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetUserContext)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ IUnknown** /*ppunkUserCtx*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ShowHelp)(
		/*[in]*/ ULONG /*Index*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSourceContext)(
		/*[in]*/ ULONG /*Index*/,
		/*[out,string]*/ const WCHAR** /*pszFileName*/,
		/*[out]*/ ULONG* /*pulLineNum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CountSourceItems)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ IVsHierarchy** /*ppHier*/,
		/*[out]*/ VSITEMID* /*pitemid*/,
		/*[out,retval]*/ ULONG* /*pcItems*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMultipleSourceItems)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSGSIFLAGS /*grfGSI*/,
		/*[in]*/ ULONG /*cItems*/,
		/*[out,size_is(cItems)]*/ VSITEMSELECTION[] /*rgItemSel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanGoToSource)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSOBJGOTOSRCTYPE /*SrcType*/,
		/*[out]*/ BOOL* /*pfOK*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GoToSource)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSOBJGOTOSRCTYPE /*SrcType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetContextMenu)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ CLSID* /*pclsidActive*/,
		/*[out]*/ LONG* /*pnMenuId*/,
		/*[out]*/ IOleCommandTarget** /*ppCmdTrgtActive*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryDragDrop)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ IDataObject* /*pDataObject*/,
		/*[in]*/ DWORD /*grfKeyState*/,
		/*[in,out]*/ DWORD* /*pdwEffect*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DoDragDrop)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ IDataObject* /*pDataObject*/,
		/*[in]*/ DWORD /*grfKeyState*/,
		/*[in,out]*/ DWORD* /*pdwEffect*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanRename)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ LPCOLESTR /*pszNewName*/,
		/*[out]*/ BOOL* /*pfOK*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DoRename)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ LPCOLESTR /*pszNewName*/,
		/*[in]*/ VSOBJOPFLAGS /*grfFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanDelete)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ BOOL* /*pfOK*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DoDelete)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSOBJOPFLAGS /*grfFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FillDescription)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSOBJDESCOPTIONS /*grfOptions*/,
		/*[in]*/ IVsObjectBrowserDescription2* /*pobDesc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FillDescription2)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSOBJDESCOPTIONS /*grfOptions*/,
		/*[in]*/ IVsObjectBrowserDescription3* /*pobDesc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumClipboardFormats)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSOBJCFFLAGS /*grfFlags*/,
		/*[in]*/ ULONG /*celt*/,
		/*[in,out,size_is(celt)]*/ VSOBJCLIPFORMAT[] /*rgcfFormats*/,
		/*[out,optional]*/ ULONG* /*pcActual*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetClipboardFormat)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSOBJCFFLAGS /*grfFlags*/,
		/*[in]*/ FORMATETC* /*pFormatetc*/,
		/*[in]*/ STGMEDIUM* /*pMedium*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExtendedClipboardVariant)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSOBJCFFLAGS /*grfFlags*/,
		/*[in]*/ const VSOBJCLIPFORMAT* /*pcfFormat*/,
		/*[out]*/ VARIANT* /*pvarFormat*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProperty)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSOBJLISTELEMPROPID /*propid*/,
		/*[out]*/ VARIANT* /*pvar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetNavInfo)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ IVsNavInfo** /*ppNavInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetNavInfoNode)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ IVsNavInfoNode** /*ppNavInfoNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LocateNavInfoNode)(
		/*[in]*/ IVsNavInfoNode* /*pNavInfoNode*/,
		/*[out]*/ ULONG* /*pulIndex*/)VSL_STDMETHOD_NOTIMPL
};

class IVsObjectList2MockImpl :
	public IVsObjectList2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsObjectList2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsObjectList2MockImpl)

	typedef IVsObjectList2 Interface;
	struct GetFlagsValidValues
	{
		/*[out]*/ VSTREEFLAGS* pFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetFlags)(
		/*[out]*/ VSTREEFLAGS* pFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetFlags)

		VSL_SET_VALIDVALUE(pFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetItemCountValidValues
	{
		/*[out]*/ ULONG* pCount;
		HRESULT retValue;
	};

	STDMETHOD(GetItemCount)(
		/*[out]*/ ULONG* pCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetItemCount)

		VSL_SET_VALIDVALUE(pCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExpandedListValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ BOOL* pfCanRecurse;
		/*[out]*/ IVsLiteTreeList** pptlNode;
		HRESULT retValue;
	};

	STDMETHOD(GetExpandedList)(
		/*[in]*/ ULONG Index,
		/*[out]*/ BOOL* pfCanRecurse,
		/*[out]*/ IVsLiteTreeList** pptlNode)
	{
		VSL_DEFINE_MOCK_METHOD(GetExpandedList)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE(pfCanRecurse);

		VSL_SET_VALIDVALUE_INTERFACE(pptlNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct LocateExpandedListValidValues
	{
		/*[in]*/ IVsLiteTreeList* ExpandedList;
		/*[out]*/ ULONG* iIndex;
		HRESULT retValue;
	};

	STDMETHOD(LocateExpandedList)(
		/*[in]*/ IVsLiteTreeList* ExpandedList,
		/*[out]*/ ULONG* iIndex)
	{
		VSL_DEFINE_MOCK_METHOD(LocateExpandedList)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(ExpandedList);

		VSL_SET_VALIDVALUE(iIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnCloseValidValues
	{
		/*[out]*/ VSTREECLOSEACTIONS* ptca;
		HRESULT retValue;
	};

	STDMETHOD(OnClose)(
		/*[out]*/ VSTREECLOSEACTIONS* ptca)
	{
		VSL_DEFINE_MOCK_METHOD(OnClose)

		VSL_SET_VALIDVALUE(ptca);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTextValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSTREETEXTOPTIONS tto;
		/*[out,string]*/ WCHAR** ppszText;
		HRESULT retValue;
	};

	STDMETHOD(GetText)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSTREETEXTOPTIONS tto,
		/*[out,string]*/ const WCHAR** ppszText)
	{
		VSL_DEFINE_MOCK_METHOD(GetText)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(tto);

		VSL_SET_VALIDVALUE_CONST(ppszText, WCHAR**);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTipTextValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSTREETOOLTIPTYPE eTipType;
		/*[out,string]*/ WCHAR** ppszText;
		HRESULT retValue;
	};

	STDMETHOD(GetTipText)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSTREETOOLTIPTYPE eTipType,
		/*[out,string]*/ const WCHAR** ppszText)
	{
		VSL_DEFINE_MOCK_METHOD(GetTipText)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(eTipType);

		VSL_SET_VALIDVALUE_CONST(ppszText, WCHAR**);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExpandableValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ BOOL* pfExpandable;
		HRESULT retValue;
	};

	STDMETHOD(GetExpandable)(
		/*[in]*/ ULONG Index,
		/*[out]*/ BOOL* pfExpandable)
	{
		VSL_DEFINE_MOCK_METHOD(GetExpandable)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE(pfExpandable);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDisplayDataValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ VSTREEDISPLAYDATA* pData;
		HRESULT retValue;
	};

	STDMETHOD(GetDisplayData)(
		/*[in]*/ ULONG Index,
		/*[out]*/ VSTREEDISPLAYDATA* pData)
	{
		VSL_DEFINE_MOCK_METHOD(GetDisplayData)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE(pData);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateCounterValidValues
	{
		/*[out]*/ ULONG* pCurUpdate;
		/*[out]*/ VSTREEITEMCHANGESMASK* pgrfChanges;
		HRESULT retValue;
	};

	STDMETHOD(UpdateCounter)(
		/*[out]*/ ULONG* pCurUpdate,
		/*[out]*/ VSTREEITEMCHANGESMASK* pgrfChanges)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateCounter)

		VSL_SET_VALIDVALUE(pCurUpdate);

		VSL_SET_VALIDVALUE(pgrfChanges);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetListChangesValidValues
	{
		/*[in,out]*/ ULONG* pcChanges;
		/*[in,size_is(*pcChanges)]*/ VSTREELISTITEMCHANGE* prgListChanges;
		HRESULT retValue;
	};

	STDMETHOD(GetListChanges)(
		/*[in,out]*/ ULONG* pcChanges,
		/*[in,size_is(*pcChanges)]*/ VSTREELISTITEMCHANGE* prgListChanges)
	{
		VSL_DEFINE_MOCK_METHOD(GetListChanges)

		VSL_SET_VALIDVALUE(pcChanges);

		VSL_CHECK_VALIDVALUE_MEMCMP(prgListChanges, *pcChanges*sizeof(prgListChanges[0]), *(validValues.pcChanges)*sizeof(validValues.prgListChanges[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct ToggleStateValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ VSTREESTATECHANGEREFRESH* ptscr;
		HRESULT retValue;
	};

	STDMETHOD(ToggleState)(
		/*[in]*/ ULONG Index,
		/*[out]*/ VSTREESTATECHANGEREFRESH* ptscr)
	{
		VSL_DEFINE_MOCK_METHOD(ToggleState)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE(ptscr);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCapabilities2ValidValues
	{
		/*[out]*/ LIB_LISTCAPABILITIES2* pgrfCapabilities;
		HRESULT retValue;
	};

	STDMETHOD(GetCapabilities2)(
		/*[out]*/ LIB_LISTCAPABILITIES2* pgrfCapabilities)
	{
		VSL_DEFINE_MOCK_METHOD(GetCapabilities2)

		VSL_SET_VALIDVALUE(pgrfCapabilities);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetList2ValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ LIB_LISTTYPE2 ListType;
		/*[in]*/ LIB_LISTFLAGS Flags;
		/*[in]*/ VSOBSEARCHCRITERIA2* pobSrch;
		/*[out,retval]*/ IVsObjectList2** ppIVsObjectList2;
		HRESULT retValue;
	};

	STDMETHOD(GetList2)(
		/*[in]*/ ULONG Index,
		/*[in]*/ LIB_LISTTYPE2 ListType,
		/*[in]*/ LIB_LISTFLAGS Flags,
		/*[in]*/ VSOBSEARCHCRITERIA2* pobSrch,
		/*[out,retval]*/ IVsObjectList2** ppIVsObjectList2)
	{
		VSL_DEFINE_MOCK_METHOD(GetList2)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(ListType);

		VSL_CHECK_VALIDVALUE(Flags);

		VSL_CHECK_VALIDVALUE_POINTER(pobSrch);

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsObjectList2);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCategoryField2ValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ LIB_CATEGORY2 Category;
		/*[out,retval]*/ DWORD* pfCatField;
		HRESULT retValue;
	};

	STDMETHOD(GetCategoryField2)(
		/*[in]*/ ULONG Index,
		/*[in]*/ LIB_CATEGORY2 Category,
		/*[out,retval]*/ DWORD* pfCatField)
	{
		VSL_DEFINE_MOCK_METHOD(GetCategoryField2)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(Category);

		VSL_SET_VALIDVALUE(pfCatField);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExpandable3ValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ LIB_LISTTYPE2 ListTypeExcluded;
		/*[out]*/ BOOL* pfExpandable;
		HRESULT retValue;
	};

	STDMETHOD(GetExpandable3)(
		/*[in]*/ ULONG Index,
		/*[in]*/ LIB_LISTTYPE2 ListTypeExcluded,
		/*[out]*/ BOOL* pfExpandable)
	{
		VSL_DEFINE_MOCK_METHOD(GetExpandable3)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(ListTypeExcluded);

		VSL_SET_VALIDVALUE(pfExpandable);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNavigationInfo2ValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in,out]*/ VSOBNAVIGATIONINFO3* pobNav;
		HRESULT retValue;
	};

	STDMETHOD(GetNavigationInfo2)(
		/*[in]*/ ULONG Index,
		/*[in,out]*/ VSOBNAVIGATIONINFO3* pobNav)
	{
		VSL_DEFINE_MOCK_METHOD(GetNavigationInfo2)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE(pobNav);

		VSL_RETURN_VALIDVALUES();
	}
	struct LocateNavigationInfo2ValidValues
	{
		/*[in]*/ VSOBNAVIGATIONINFO3* pobNav;
		/*[in]*/ VSOBNAVNAMEINFONODE2* pobName;
		/*[in]*/ BOOL fDontUpdate;
		/*[out]*/ BOOL* pfMatchedName;
		/*[out]*/ ULONG* pIndex;
		HRESULT retValue;
	};

	STDMETHOD(LocateNavigationInfo2)(
		/*[in]*/ VSOBNAVIGATIONINFO3* pobNav,
		/*[in]*/ VSOBNAVNAMEINFONODE2* pobName,
		/*[in]*/ BOOL fDontUpdate,
		/*[out]*/ BOOL* pfMatchedName,
		/*[out]*/ ULONG* pIndex)
	{
		VSL_DEFINE_MOCK_METHOD(LocateNavigationInfo2)

		VSL_CHECK_VALIDVALUE_POINTER(pobNav);

		VSL_CHECK_VALIDVALUE_POINTER(pobName);

		VSL_CHECK_VALIDVALUE(fDontUpdate);

		VSL_SET_VALIDVALUE(pfMatchedName);

		VSL_SET_VALIDVALUE(pIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBrowseObjectValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ IDispatch** ppdispBrowseObj;
		HRESULT retValue;
	};

	STDMETHOD(GetBrowseObject)(
		/*[in]*/ ULONG Index,
		/*[out]*/ IDispatch** ppdispBrowseObj)
	{
		VSL_DEFINE_MOCK_METHOD(GetBrowseObject)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE_INTERFACE(ppdispBrowseObj);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetUserContextValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ IUnknown** ppunkUserCtx;
		HRESULT retValue;
	};

	STDMETHOD(GetUserContext)(
		/*[in]*/ ULONG Index,
		/*[out]*/ IUnknown** ppunkUserCtx)
	{
		VSL_DEFINE_MOCK_METHOD(GetUserContext)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE_INTERFACE(ppunkUserCtx);

		VSL_RETURN_VALIDVALUES();
	}
	struct ShowHelpValidValues
	{
		/*[in]*/ ULONG Index;
		HRESULT retValue;
	};

	STDMETHOD(ShowHelp)(
		/*[in]*/ ULONG Index)
	{
		VSL_DEFINE_MOCK_METHOD(ShowHelp)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSourceContextValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out,string]*/ WCHAR** pszFileName;
		/*[out]*/ ULONG* pulLineNum;
		HRESULT retValue;
	};

	STDMETHOD(GetSourceContext)(
		/*[in]*/ ULONG Index,
		/*[out,string]*/ const WCHAR** pszFileName,
		/*[out]*/ ULONG* pulLineNum)
	{
		VSL_DEFINE_MOCK_METHOD(GetSourceContext)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE_CONST(pszFileName, WCHAR**);

		VSL_SET_VALIDVALUE(pulLineNum);

		VSL_RETURN_VALIDVALUES();
	}
	struct CountSourceItemsValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ IVsHierarchy** ppHier;
		/*[out]*/ VSITEMID* pitemid;
		/*[out,retval]*/ ULONG* pcItems;
		HRESULT retValue;
	};

	STDMETHOD(CountSourceItems)(
		/*[in]*/ ULONG Index,
		/*[out]*/ IVsHierarchy** ppHier,
		/*[out]*/ VSITEMID* pitemid,
		/*[out,retval]*/ ULONG* pcItems)
	{
		VSL_DEFINE_MOCK_METHOD(CountSourceItems)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE_INTERFACE(ppHier);

		VSL_SET_VALIDVALUE(pitemid);

		VSL_SET_VALIDVALUE(pcItems);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMultipleSourceItemsValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSGSIFLAGS grfGSI;
		/*[in]*/ ULONG cItems;
		/*[out,size_is(cItems)]*/ VSITEMSELECTION* rgItemSel;
		HRESULT retValue;
	};

	STDMETHOD(GetMultipleSourceItems)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSGSIFLAGS grfGSI,
		/*[in]*/ ULONG cItems,
		/*[out,size_is(cItems)]*/ VSITEMSELECTION rgItemSel[])
	{
		VSL_DEFINE_MOCK_METHOD(GetMultipleSourceItems)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(grfGSI);

		VSL_CHECK_VALIDVALUE(cItems);

		VSL_SET_VALIDVALUE_MEMCPY(rgItemSel, cItems*sizeof(rgItemSel[0]), validValues.cItems*sizeof(validValues.rgItemSel[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct CanGoToSourceValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSOBJGOTOSRCTYPE SrcType;
		/*[out]*/ BOOL* pfOK;
		HRESULT retValue;
	};

	STDMETHOD(CanGoToSource)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSOBJGOTOSRCTYPE SrcType,
		/*[out]*/ BOOL* pfOK)
	{
		VSL_DEFINE_MOCK_METHOD(CanGoToSource)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(SrcType);

		VSL_SET_VALIDVALUE(pfOK);

		VSL_RETURN_VALIDVALUES();
	}
	struct GoToSourceValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSOBJGOTOSRCTYPE SrcType;
		HRESULT retValue;
	};

	STDMETHOD(GoToSource)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSOBJGOTOSRCTYPE SrcType)
	{
		VSL_DEFINE_MOCK_METHOD(GoToSource)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(SrcType);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetContextMenuValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ CLSID* pclsidActive;
		/*[out]*/ LONG* pnMenuId;
		/*[out]*/ IOleCommandTarget** ppCmdTrgtActive;
		HRESULT retValue;
	};

	STDMETHOD(GetContextMenu)(
		/*[in]*/ ULONG Index,
		/*[out]*/ CLSID* pclsidActive,
		/*[out]*/ LONG* pnMenuId,
		/*[out]*/ IOleCommandTarget** ppCmdTrgtActive)
	{
		VSL_DEFINE_MOCK_METHOD(GetContextMenu)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE(pclsidActive);

		VSL_SET_VALIDVALUE(pnMenuId);

		VSL_SET_VALIDVALUE_INTERFACE(ppCmdTrgtActive);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryDragDropValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ IDataObject* pDataObject;
		/*[in]*/ DWORD grfKeyState;
		/*[in,out]*/ DWORD* pdwEffect;
		HRESULT retValue;
	};

	STDMETHOD(QueryDragDrop)(
		/*[in]*/ ULONG Index,
		/*[in]*/ IDataObject* pDataObject,
		/*[in]*/ DWORD grfKeyState,
		/*[in,out]*/ DWORD* pdwEffect)
	{
		VSL_DEFINE_MOCK_METHOD(QueryDragDrop)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDataObject);

		VSL_CHECK_VALIDVALUE(grfKeyState);

		VSL_SET_VALIDVALUE(pdwEffect);

		VSL_RETURN_VALIDVALUES();
	}
	struct DoDragDropValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ IDataObject* pDataObject;
		/*[in]*/ DWORD grfKeyState;
		/*[in,out]*/ DWORD* pdwEffect;
		HRESULT retValue;
	};

	STDMETHOD(DoDragDrop)(
		/*[in]*/ ULONG Index,
		/*[in]*/ IDataObject* pDataObject,
		/*[in]*/ DWORD grfKeyState,
		/*[in,out]*/ DWORD* pdwEffect)
	{
		VSL_DEFINE_MOCK_METHOD(DoDragDrop)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDataObject);

		VSL_CHECK_VALIDVALUE(grfKeyState);

		VSL_SET_VALIDVALUE(pdwEffect);

		VSL_RETURN_VALIDVALUES();
	}
	struct CanRenameValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ LPCOLESTR pszNewName;
		/*[out]*/ BOOL* pfOK;
		HRESULT retValue;
	};

	STDMETHOD(CanRename)(
		/*[in]*/ ULONG Index,
		/*[in]*/ LPCOLESTR pszNewName,
		/*[out]*/ BOOL* pfOK)
	{
		VSL_DEFINE_MOCK_METHOD(CanRename)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE_STRINGW(pszNewName);

		VSL_SET_VALIDVALUE(pfOK);

		VSL_RETURN_VALIDVALUES();
	}
	struct DoRenameValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ LPCOLESTR pszNewName;
		/*[in]*/ VSOBJOPFLAGS grfFlags;
		HRESULT retValue;
	};

	STDMETHOD(DoRename)(
		/*[in]*/ ULONG Index,
		/*[in]*/ LPCOLESTR pszNewName,
		/*[in]*/ VSOBJOPFLAGS grfFlags)
	{
		VSL_DEFINE_MOCK_METHOD(DoRename)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE_STRINGW(pszNewName);

		VSL_CHECK_VALIDVALUE(grfFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct CanDeleteValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ BOOL* pfOK;
		HRESULT retValue;
	};

	STDMETHOD(CanDelete)(
		/*[in]*/ ULONG Index,
		/*[out]*/ BOOL* pfOK)
	{
		VSL_DEFINE_MOCK_METHOD(CanDelete)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE(pfOK);

		VSL_RETURN_VALIDVALUES();
	}
	struct DoDeleteValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSOBJOPFLAGS grfFlags;
		HRESULT retValue;
	};

	STDMETHOD(DoDelete)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSOBJOPFLAGS grfFlags)
	{
		VSL_DEFINE_MOCK_METHOD(DoDelete)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(grfFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct FillDescriptionValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSOBJDESCOPTIONS grfOptions;
		/*[in]*/ IVsObjectBrowserDescription2* pobDesc;
		HRESULT retValue;
	};

	STDMETHOD(FillDescription)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSOBJDESCOPTIONS grfOptions,
		/*[in]*/ IVsObjectBrowserDescription2* pobDesc)
	{
		VSL_DEFINE_MOCK_METHOD(FillDescription)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(grfOptions);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pobDesc);

		VSL_RETURN_VALIDVALUES();
	}
	struct FillDescription2ValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSOBJDESCOPTIONS grfOptions;
		/*[in]*/ IVsObjectBrowserDescription3* pobDesc;
		HRESULT retValue;
	};

	STDMETHOD(FillDescription2)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSOBJDESCOPTIONS grfOptions,
		/*[in]*/ IVsObjectBrowserDescription3* pobDesc)
	{
		VSL_DEFINE_MOCK_METHOD(FillDescription2)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(grfOptions);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pobDesc);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumClipboardFormatsValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSOBJCFFLAGS grfFlags;
		/*[in]*/ ULONG celt;
		/*[in,out,size_is(celt)]*/ VSOBJCLIPFORMAT* rgcfFormats;
		/*[out,optional]*/ ULONG* pcActual;
		HRESULT retValue;
	};

	STDMETHOD(EnumClipboardFormats)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSOBJCFFLAGS grfFlags,
		/*[in]*/ ULONG celt,
		/*[in,out,size_is(celt)]*/ VSOBJCLIPFORMAT rgcfFormats[],
		/*[out,optional]*/ ULONG* pcActual)
	{
		VSL_DEFINE_MOCK_METHOD(EnumClipboardFormats)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(grfFlags);

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(rgcfFormats, celt*sizeof(rgcfFormats[0]), validValues.celt*sizeof(validValues.rgcfFormats[0]));

		VSL_SET_VALIDVALUE(pcActual);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetClipboardFormatValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSOBJCFFLAGS grfFlags;
		/*[in]*/ FORMATETC* pFormatetc;
		/*[in]*/ STGMEDIUM* pMedium;
		HRESULT retValue;
	};

	STDMETHOD(GetClipboardFormat)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSOBJCFFLAGS grfFlags,
		/*[in]*/ FORMATETC* pFormatetc,
		/*[in]*/ STGMEDIUM* pMedium)
	{
		VSL_DEFINE_MOCK_METHOD(GetClipboardFormat)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(grfFlags);

		VSL_CHECK_VALIDVALUE_POINTER(pFormatetc);

		VSL_CHECK_VALIDVALUE_POINTER(pMedium);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExtendedClipboardVariantValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSOBJCFFLAGS grfFlags;
		/*[in]*/ VSOBJCLIPFORMAT* pcfFormat;
		/*[out]*/ VARIANT* pvarFormat;
		HRESULT retValue;
	};

	STDMETHOD(GetExtendedClipboardVariant)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSOBJCFFLAGS grfFlags,
		/*[in]*/ const VSOBJCLIPFORMAT* pcfFormat,
		/*[out]*/ VARIANT* pvarFormat)
	{
		VSL_DEFINE_MOCK_METHOD(GetExtendedClipboardVariant)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(grfFlags);

		VSL_CHECK_VALIDVALUE_POINTER(pcfFormat);

		VSL_SET_VALIDVALUE_VARIANT(pvarFormat);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPropertyValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSOBJLISTELEMPROPID propid;
		/*[out]*/ VARIANT* pvar;
		HRESULT retValue;
	};

	STDMETHOD(GetProperty)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSOBJLISTELEMPROPID propid,
		/*[out]*/ VARIANT* pvar)
	{
		VSL_DEFINE_MOCK_METHOD(GetProperty)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(propid);

		VSL_SET_VALIDVALUE_VARIANT(pvar);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNavInfoValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ IVsNavInfo** ppNavInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetNavInfo)(
		/*[in]*/ ULONG Index,
		/*[out]*/ IVsNavInfo** ppNavInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetNavInfo)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE_INTERFACE(ppNavInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNavInfoNodeValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ IVsNavInfoNode** ppNavInfoNode;
		HRESULT retValue;
	};

	STDMETHOD(GetNavInfoNode)(
		/*[in]*/ ULONG Index,
		/*[out]*/ IVsNavInfoNode** ppNavInfoNode)
	{
		VSL_DEFINE_MOCK_METHOD(GetNavInfoNode)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE_INTERFACE(ppNavInfoNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct LocateNavInfoNodeValidValues
	{
		/*[in]*/ IVsNavInfoNode* pNavInfoNode;
		/*[out]*/ ULONG* pulIndex;
		HRESULT retValue;
	};

	STDMETHOD(LocateNavInfoNode)(
		/*[in]*/ IVsNavInfoNode* pNavInfoNode,
		/*[out]*/ ULONG* pulIndex)
	{
		VSL_DEFINE_MOCK_METHOD(LocateNavInfoNode)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pNavInfoNode);

		VSL_SET_VALIDVALUE(pulIndex);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSOBJECTLIST2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsObjectSearch.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSOBJECTSEARCH_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSOBJECTSEARCH_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsObjectSearchNotImpl :
	public IVsObjectSearch
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsObjectSearchNotImpl)

public:

	typedef IVsObjectSearch Interface;

	STDMETHOD(Find)(
		/*[in]*/ VSOBSEARCHFLAGS /*flags*/,
		/*[in]*/ const VSOBSEARCHCRITERIA* /*pobSrch*/,
		/*[out,retval]*/ IVsObjectList** /*ppList*/)VSL_STDMETHOD_NOTIMPL
};

class IVsObjectSearchMockImpl :
	public IVsObjectSearch,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsObjectSearchMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsObjectSearchMockImpl)

	typedef IVsObjectSearch Interface;
	struct FindValidValues
	{
		/*[in]*/ VSOBSEARCHFLAGS flags;
		/*[in]*/ VSOBSEARCHCRITERIA* pobSrch;
		/*[out,retval]*/ IVsObjectList** ppList;
		HRESULT retValue;
	};

	STDMETHOD(Find)(
		/*[in]*/ VSOBSEARCHFLAGS flags,
		/*[in]*/ const VSOBSEARCHCRITERIA* pobSrch,
		/*[out,retval]*/ IVsObjectList** ppList)
	{
		VSL_DEFINE_MOCK_METHOD(Find)

		VSL_CHECK_VALIDVALUE(flags);

		VSL_CHECK_VALIDVALUE_POINTER(pobSrch);

		VSL_SET_VALIDVALUE_INTERFACE(ppList);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSOBJECTSEARCH_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsObjectManagerEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSOBJECTMANAGEREVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSOBJECTMANAGEREVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsObjectManagerEventsNotImpl :
	public IVsObjectManagerEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsObjectManagerEventsNotImpl)

public:

	typedef IVsObjectManagerEvents Interface;

	STDMETHOD(OnBeforeSubsetChange)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterSubsetChange)()VSL_STDMETHOD_NOTIMPL
};

class IVsObjectManagerEventsMockImpl :
	public IVsObjectManagerEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsObjectManagerEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsObjectManagerEventsMockImpl)

	typedef IVsObjectManagerEvents Interface;
	struct OnBeforeSubsetChangeValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnBeforeSubsetChange)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnBeforeSubsetChange)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterSubsetChangeValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnAfterSubsetChange)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnAfterSubsetChange)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSOBJECTMANAGEREVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsObjectSearchPane.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSOBJECTSEARCHPANE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSOBJECTSEARCHPANE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsObjectSearchPaneNotImpl :
	public IVsObjectSearchPane
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsObjectSearchPaneNotImpl)

public:

	typedef IVsObjectSearchPane Interface;

	STDMETHOD(SetResultsList)(
		/*[in]*/ IVsLibrary* /*pLibrary*/,
		/*[in]*/ IVsObjectList* /*pList*/,
		/*[in]*/ VSOBSEARCHFLAGS /*flags*/,
		/*[out]*/ IVsObjectListOwner** /*ppListOwner*/)VSL_STDMETHOD_NOTIMPL
};

class IVsObjectSearchPaneMockImpl :
	public IVsObjectSearchPane,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsObjectSearchPaneMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsObjectSearchPaneMockImpl)

	typedef IVsObjectSearchPane Interface;
	struct SetResultsListValidValues
	{
		/*[in]*/ IVsLibrary* pLibrary;
		/*[in]*/ IVsObjectList* pList;
		/*[in]*/ VSOBSEARCHFLAGS flags;
		/*[out]*/ IVsObjectListOwner** ppListOwner;
		HRESULT retValue;
	};

	STDMETHOD(SetResultsList)(
		/*[in]*/ IVsLibrary* pLibrary,
		/*[in]*/ IVsObjectList* pList,
		/*[in]*/ VSOBSEARCHFLAGS flags,
		/*[out]*/ IVsObjectListOwner** ppListOwner)
	{
		VSL_DEFINE_MOCK_METHOD(SetResultsList)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pLibrary);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pList);

		VSL_CHECK_VALIDVALUE(flags);

		VSL_SET_VALIDVALUE_INTERFACE(ppListOwner);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSOBJECTSEARCHPANE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsOpenProjectOrSolutionDlg.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSOPENPROJECTORSOLUTIONDLG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSOPENPROJECTORSOLUTIONDLG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsOpenProjectOrSolutionDlgNotImpl :
	public IVsOpenProjectOrSolutionDlg
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsOpenProjectOrSolutionDlgNotImpl)

public:

	typedef IVsOpenProjectOrSolutionDlg Interface;

	STDMETHOD(OpenProjectOrSolutionViaDlg)(
		/*[in]*/ VSPROJSLNDLGFLAGS /*grfProjSlnDlgFlags*/,
		/*[in]*/ LPCOLESTR /*pwzStartDirectory*/,
		/*[in]*/ LPCOLESTR /*pwzDialogTitle*/,
		/*[in]*/ REFGUID /*rguidProjectType*/)VSL_STDMETHOD_NOTIMPL
};

class IVsOpenProjectOrSolutionDlgMockImpl :
	public IVsOpenProjectOrSolutionDlg,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsOpenProjectOrSolutionDlgMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsOpenProjectOrSolutionDlgMockImpl)

	typedef IVsOpenProjectOrSolutionDlg Interface;
	struct OpenProjectOrSolutionViaDlgValidValues
	{
		/*[in]*/ VSPROJSLNDLGFLAGS grfProjSlnDlgFlags;
		/*[in]*/ LPCOLESTR pwzStartDirectory;
		/*[in]*/ LPCOLESTR pwzDialogTitle;
		/*[in]*/ REFGUID rguidProjectType;
		HRESULT retValue;
	};

	STDMETHOD(OpenProjectOrSolutionViaDlg)(
		/*[in]*/ VSPROJSLNDLGFLAGS grfProjSlnDlgFlags,
		/*[in]*/ LPCOLESTR pwzStartDirectory,
		/*[in]*/ LPCOLESTR pwzDialogTitle,
		/*[in]*/ REFGUID rguidProjectType)
	{
		VSL_DEFINE_MOCK_METHOD(OpenProjectOrSolutionViaDlg)

		VSL_CHECK_VALIDVALUE(grfProjSlnDlgFlags);

		VSL_CHECK_VALIDVALUE_STRINGW(pwzStartDirectory);

		VSL_CHECK_VALIDVALUE_STRINGW(pwzDialogTitle);

		VSL_CHECK_VALIDVALUE(rguidProjectType);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSOPENPROJECTORSOLUTIONDLG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsOutputGroup2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSOUTPUTGROUP2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSOUTPUTGROUP2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsOutputGroup2NotImpl :
	public IVsOutputGroup2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsOutputGroup2NotImpl)

public:

	typedef IVsOutputGroup2 Interface;

	STDMETHOD(get_KeyOutputObject)(
		/*[out]*/ IVsOutput2** /*ppKeyOutput*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Property)(
		/*[in]*/ LPCOLESTR /*pszProperty*/,
		/*[out]*/ VARIANT* /*pvar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CanonicalName)(
		/*[out]*/ BSTR* /*pbstrCanonicalName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DisplayName)(
		/*[out]*/ BSTR* /*pbstrDisplayName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_KeyOutput)(
		/*[out]*/ BSTR* /*pbstrCanonicalName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ProjectCfg)(
		/*[out]*/ IVsProjectCfg2** /*ppIVsProjectCfg2*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Outputs)(
		/*[in]*/ ULONG /*celt*/,
		/*[in,out,size_is(celt)]*/ IVsOutput2*[] /*rgpcfg*/,
		/*[out,optional]*/ ULONG* /*pcActual*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DeployDependencies)(
		/*[in]*/ ULONG /*celt*/,
		/*[in,out,size_is(celt)]*/ IVsDeployDependency*[] /*rgpdpd*/,
		/*[out,optional]*/ ULONG* /*pcActual*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Description)(
		/*[out]*/ BSTR* /*pbstrDescription*/)VSL_STDMETHOD_NOTIMPL
};

class IVsOutputGroup2MockImpl :
	public IVsOutputGroup2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsOutputGroup2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsOutputGroup2MockImpl)

	typedef IVsOutputGroup2 Interface;
	struct get_KeyOutputObjectValidValues
	{
		/*[out]*/ IVsOutput2** ppKeyOutput;
		HRESULT retValue;
	};

	STDMETHOD(get_KeyOutputObject)(
		/*[out]*/ IVsOutput2** ppKeyOutput)
	{
		VSL_DEFINE_MOCK_METHOD(get_KeyOutputObject)

		VSL_SET_VALIDVALUE_INTERFACE(ppKeyOutput);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_PropertyValidValues
	{
		/*[in]*/ LPCOLESTR pszProperty;
		/*[out]*/ VARIANT* pvar;
		HRESULT retValue;
	};

	STDMETHOD(get_Property)(
		/*[in]*/ LPCOLESTR pszProperty,
		/*[out]*/ VARIANT* pvar)
	{
		VSL_DEFINE_MOCK_METHOD(get_Property)

		VSL_CHECK_VALIDVALUE_STRINGW(pszProperty);

		VSL_SET_VALIDVALUE_VARIANT(pvar);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CanonicalNameValidValues
	{
		/*[out]*/ BSTR* pbstrCanonicalName;
		HRESULT retValue;
	};

	STDMETHOD(get_CanonicalName)(
		/*[out]*/ BSTR* pbstrCanonicalName)
	{
		VSL_DEFINE_MOCK_METHOD(get_CanonicalName)

		VSL_SET_VALIDVALUE_BSTR(pbstrCanonicalName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DisplayNameValidValues
	{
		/*[out]*/ BSTR* pbstrDisplayName;
		HRESULT retValue;
	};

	STDMETHOD(get_DisplayName)(
		/*[out]*/ BSTR* pbstrDisplayName)
	{
		VSL_DEFINE_MOCK_METHOD(get_DisplayName)

		VSL_SET_VALIDVALUE_BSTR(pbstrDisplayName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_KeyOutputValidValues
	{
		/*[out]*/ BSTR* pbstrCanonicalName;
		HRESULT retValue;
	};

	STDMETHOD(get_KeyOutput)(
		/*[out]*/ BSTR* pbstrCanonicalName)
	{
		VSL_DEFINE_MOCK_METHOD(get_KeyOutput)

		VSL_SET_VALIDVALUE_BSTR(pbstrCanonicalName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ProjectCfgValidValues
	{
		/*[out]*/ IVsProjectCfg2** ppIVsProjectCfg2;
		HRESULT retValue;
	};

	STDMETHOD(get_ProjectCfg)(
		/*[out]*/ IVsProjectCfg2** ppIVsProjectCfg2)
	{
		VSL_DEFINE_MOCK_METHOD(get_ProjectCfg)

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsProjectCfg2);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OutputsValidValues
	{
		/*[in]*/ ULONG celt;
		/*[in,out,size_is(celt)]*/ IVsOutput2** rgpcfg;
		/*[out,optional]*/ ULONG* pcActual;
		HRESULT retValue;
	};

	STDMETHOD(get_Outputs)(
		/*[in]*/ ULONG celt,
		/*[in,out,size_is(celt)]*/ IVsOutput2* rgpcfg[],
		/*[out,optional]*/ ULONG* pcActual)
	{
		VSL_DEFINE_MOCK_METHOD(get_Outputs)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgpcfg, celt, validValues.celt);

		VSL_SET_VALIDVALUE(pcActual);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DeployDependenciesValidValues
	{
		/*[in]*/ ULONG celt;
		/*[in,out,size_is(celt)]*/ IVsDeployDependency** rgpdpd;
		/*[out,optional]*/ ULONG* pcActual;
		HRESULT retValue;
	};

	STDMETHOD(get_DeployDependencies)(
		/*[in]*/ ULONG celt,
		/*[in,out,size_is(celt)]*/ IVsDeployDependency* rgpdpd[],
		/*[out,optional]*/ ULONG* pcActual)
	{
		VSL_DEFINE_MOCK_METHOD(get_DeployDependencies)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgpdpd, celt, validValues.celt);

		VSL_SET_VALIDVALUE(pcActual);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DescriptionValidValues
	{
		/*[out]*/ BSTR* pbstrDescription;
		HRESULT retValue;
	};

	STDMETHOD(get_Description)(
		/*[out]*/ BSTR* pbstrDescription)
	{
		VSL_DEFINE_MOCK_METHOD(get_Description)

		VSL_SET_VALIDVALUE_BSTR(pbstrDescription);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSOUTPUTGROUP2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsOutputWindow2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSOUTPUTWINDOW2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSOUTPUTWINDOW2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsOutputWindow2NotImpl :
	public IVsOutputWindow2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsOutputWindow2NotImpl)

public:

	typedef IVsOutputWindow2 Interface;

	STDMETHOD(GetActivePaneGUID)(
		/*[out]*/ GUID* /*pguidPane*/)VSL_STDMETHOD_NOTIMPL
};

class IVsOutputWindow2MockImpl :
	public IVsOutputWindow2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsOutputWindow2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsOutputWindow2MockImpl)

	typedef IVsOutputWindow2 Interface;
	struct GetActivePaneGUIDValidValues
	{
		/*[out]*/ GUID* pguidPane;
		HRESULT retValue;
	};

	STDMETHOD(GetActivePaneGUID)(
		/*[out]*/ GUID* pguidPane)
	{
		VSL_DEFINE_MOCK_METHOD(GetActivePaneGUID)

		VSL_SET_VALIDVALUE(pguidPane);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSOUTPUTWINDOW2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsOutliningSession.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSOUTLININGSESSION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSOUTLININGSESSION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsOutliningSessionNotImpl :
	public IVsOutliningSession
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsOutliningSessionNotImpl)

public:

	typedef IVsOutliningSession Interface;

	STDMETHOD(AddOutlineRegions)(
		/*[in]*/ DWORD /*dwOutliningFlags*/,
		/*[in]*/ long /*cRegions*/,
		/*[in,size_is(cRegions)]*/ NewOutlineRegion* /*rgOutlnReg*/)VSL_STDMETHOD_NOTIMPL
};

class IVsOutliningSessionMockImpl :
	public IVsOutliningSession,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsOutliningSessionMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsOutliningSessionMockImpl)

	typedef IVsOutliningSession Interface;
	struct AddOutlineRegionsValidValues
	{
		/*[in]*/ DWORD dwOutliningFlags;
		/*[in]*/ long cRegions;
		/*[in,size_is(cRegions)]*/ NewOutlineRegion* rgOutlnReg;
		HRESULT retValue;
	};

	STDMETHOD(AddOutlineRegions)(
		/*[in]*/ DWORD dwOutliningFlags,
		/*[in]*/ long cRegions,
		/*[in,size_is(cRegions)]*/ NewOutlineRegion* rgOutlnReg)
	{
		VSL_DEFINE_MOCK_METHOD(AddOutlineRegions)

		VSL_CHECK_VALIDVALUE(dwOutliningFlags);

		VSL_CHECK_VALIDVALUE(cRegions);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgOutlnReg, cRegions*sizeof(rgOutlnReg[0]), validValues.cRegions*sizeof(validValues.rgOutlnReg[0]));

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSOUTLININGSESSION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsOutliningCapableLanguage.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSOUTLININGCAPABLELANGUAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSOUTLININGCAPABLELANGUAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsOutliningCapableLanguageNotImpl :
	public IVsOutliningCapableLanguage
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsOutliningCapableLanguageNotImpl)

public:

	typedef IVsOutliningCapableLanguage Interface;

	STDMETHOD(CollapseToDefinitions)(
		/*[in]*/ IVsTextLines* /*pTextLines*/,
		/*[in]*/ IVsOutliningSession* /*pSession*/)VSL_STDMETHOD_NOTIMPL
};

class IVsOutliningCapableLanguageMockImpl :
	public IVsOutliningCapableLanguage,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsOutliningCapableLanguageMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsOutliningCapableLanguageMockImpl)

	typedef IVsOutliningCapableLanguage Interface;
	struct CollapseToDefinitionsValidValues
	{
		/*[in]*/ IVsTextLines* pTextLines;
		/*[in]*/ IVsOutliningSession* pSession;
		HRESULT retValue;
	};

	STDMETHOD(CollapseToDefinitions)(
		/*[in]*/ IVsTextLines* pTextLines,
		/*[in]*/ IVsOutliningSession* pSession)
	{
		VSL_DEFINE_MOCK_METHOD(CollapseToDefinitions)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pTextLines);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSession);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSOUTLININGCAPABLELANGUAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsOutput.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSOUTPUT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSOUTPUT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsOutputNotImpl :
	public IVsOutput
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsOutputNotImpl)

public:

	typedef IVsOutput Interface;

	STDMETHOD(get_DisplayName)(
		/*[out]*/ BSTR* /*pbstrDisplayName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CanonicalName)(
		/*[out]*/ BSTR* /*pbstrCanonicalName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DeploySourceURL)(
		/*[out]*/ BSTR* /*pbstrDeploySourceURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Type)(
		/*[out]*/ GUID* /*pguidType*/)VSL_STDMETHOD_NOTIMPL
};

class IVsOutputMockImpl :
	public IVsOutput,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsOutputMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsOutputMockImpl)

	typedef IVsOutput Interface;
	struct get_DisplayNameValidValues
	{
		/*[out]*/ BSTR* pbstrDisplayName;
		HRESULT retValue;
	};

	STDMETHOD(get_DisplayName)(
		/*[out]*/ BSTR* pbstrDisplayName)
	{
		VSL_DEFINE_MOCK_METHOD(get_DisplayName)

		VSL_SET_VALIDVALUE_BSTR(pbstrDisplayName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CanonicalNameValidValues
	{
		/*[out]*/ BSTR* pbstrCanonicalName;
		HRESULT retValue;
	};

	STDMETHOD(get_CanonicalName)(
		/*[out]*/ BSTR* pbstrCanonicalName)
	{
		VSL_DEFINE_MOCK_METHOD(get_CanonicalName)

		VSL_SET_VALIDVALUE_BSTR(pbstrCanonicalName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DeploySourceURLValidValues
	{
		/*[out]*/ BSTR* pbstrDeploySourceURL;
		HRESULT retValue;
	};

	STDMETHOD(get_DeploySourceURL)(
		/*[out]*/ BSTR* pbstrDeploySourceURL)
	{
		VSL_DEFINE_MOCK_METHOD(get_DeploySourceURL)

		VSL_SET_VALIDVALUE_BSTR(pbstrDeploySourceURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_TypeValidValues
	{
		/*[out]*/ GUID* pguidType;
		HRESULT retValue;
	};

	STDMETHOD(get_Type)(
		/*[out]*/ GUID* pguidType)
	{
		VSL_DEFINE_MOCK_METHOD(get_Type)

		VSL_SET_VALIDVALUE(pguidType);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSOUTPUT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsOutputWindow.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSOUTPUTWINDOW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSOUTPUTWINDOW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsOutputWindowNotImpl :
	public IVsOutputWindow
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsOutputWindowNotImpl)

public:

	typedef IVsOutputWindow Interface;

	STDMETHOD(GetPane)(
		/*[in]*/ REFGUID /*rguidPane*/,
		/*[out]*/ IVsOutputWindowPane** /*ppPane*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreatePane)(
		/*[in]*/ REFGUID /*rguidPane*/,
		/*[in]*/ LPCOLESTR /*pszPaneName*/,
		/*[in]*/ BOOL /*fInitVisible*/,
		/*[in]*/ BOOL /*fClearWithSolution*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DeletePane)(
		/*[in]*/ REFGUID /*rguidPane*/)VSL_STDMETHOD_NOTIMPL
};

class IVsOutputWindowMockImpl :
	public IVsOutputWindow,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsOutputWindowMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsOutputWindowMockImpl)

	typedef IVsOutputWindow Interface;
	struct GetPaneValidValues
	{
		/*[in]*/ REFGUID rguidPane;
		/*[out]*/ IVsOutputWindowPane** ppPane;
		HRESULT retValue;
	};

	STDMETHOD(GetPane)(
		/*[in]*/ REFGUID rguidPane,
		/*[out]*/ IVsOutputWindowPane** ppPane)
	{
		VSL_DEFINE_MOCK_METHOD(GetPane)

		VSL_CHECK_VALIDVALUE(rguidPane);

		VSL_SET_VALIDVALUE_INTERFACE(ppPane);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreatePaneValidValues
	{
		/*[in]*/ REFGUID rguidPane;
		/*[in]*/ LPCOLESTR pszPaneName;
		/*[in]*/ BOOL fInitVisible;
		/*[in]*/ BOOL fClearWithSolution;
		HRESULT retValue;
	};

	STDMETHOD(CreatePane)(
		/*[in]*/ REFGUID rguidPane,
		/*[in]*/ LPCOLESTR pszPaneName,
		/*[in]*/ BOOL fInitVisible,
		/*[in]*/ BOOL fClearWithSolution)
	{
		VSL_DEFINE_MOCK_METHOD(CreatePane)

		VSL_CHECK_VALIDVALUE(rguidPane);

		VSL_CHECK_VALIDVALUE_STRINGW(pszPaneName);

		VSL_CHECK_VALIDVALUE(fInitVisible);

		VSL_CHECK_VALIDVALUE(fClearWithSolution);

		VSL_RETURN_VALIDVALUES();
	}
	struct DeletePaneValidValues
	{
		/*[in]*/ REFGUID rguidPane;
		HRESULT retValue;
	};

	STDMETHOD(DeletePane)(
		/*[in]*/ REFGUID rguidPane)
	{
		VSL_DEFINE_MOCK_METHOD(DeletePane)

		VSL_CHECK_VALIDVALUE(rguidPane);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSOUTPUTWINDOW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsOutput2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSOUTPUT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSOUTPUT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsOutput2NotImpl :
	public IVsOutput2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsOutput2NotImpl)

public:

	typedef IVsOutput2 Interface;

	STDMETHOD(get_RootRelativeURL)(
		/*[out]*/ BSTR* /*pbstrRelativePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Property)(
		/*[in]*/ LPCOLESTR /*szProperty*/,
		/*[out]*/ VARIANT* /*pvar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DisplayName)(
		/*[out]*/ BSTR* /*pbstrDisplayName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CanonicalName)(
		/*[out]*/ BSTR* /*pbstrCanonicalName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DeploySourceURL)(
		/*[out]*/ BSTR* /*pbstrDeploySourceURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Type)(
		/*[out]*/ GUID* /*pguidType*/)VSL_STDMETHOD_NOTIMPL
};

class IVsOutput2MockImpl :
	public IVsOutput2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsOutput2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsOutput2MockImpl)

	typedef IVsOutput2 Interface;
	struct get_RootRelativeURLValidValues
	{
		/*[out]*/ BSTR* pbstrRelativePath;
		HRESULT retValue;
	};

	STDMETHOD(get_RootRelativeURL)(
		/*[out]*/ BSTR* pbstrRelativePath)
	{
		VSL_DEFINE_MOCK_METHOD(get_RootRelativeURL)

		VSL_SET_VALIDVALUE_BSTR(pbstrRelativePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_PropertyValidValues
	{
		/*[in]*/ LPCOLESTR szProperty;
		/*[out]*/ VARIANT* pvar;
		HRESULT retValue;
	};

	STDMETHOD(get_Property)(
		/*[in]*/ LPCOLESTR szProperty,
		/*[out]*/ VARIANT* pvar)
	{
		VSL_DEFINE_MOCK_METHOD(get_Property)

		VSL_CHECK_VALIDVALUE_STRINGW(szProperty);

		VSL_SET_VALIDVALUE_VARIANT(pvar);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DisplayNameValidValues
	{
		/*[out]*/ BSTR* pbstrDisplayName;
		HRESULT retValue;
	};

	STDMETHOD(get_DisplayName)(
		/*[out]*/ BSTR* pbstrDisplayName)
	{
		VSL_DEFINE_MOCK_METHOD(get_DisplayName)

		VSL_SET_VALIDVALUE_BSTR(pbstrDisplayName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CanonicalNameValidValues
	{
		/*[out]*/ BSTR* pbstrCanonicalName;
		HRESULT retValue;
	};

	STDMETHOD(get_CanonicalName)(
		/*[out]*/ BSTR* pbstrCanonicalName)
	{
		VSL_DEFINE_MOCK_METHOD(get_CanonicalName)

		VSL_SET_VALIDVALUE_BSTR(pbstrCanonicalName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DeploySourceURLValidValues
	{
		/*[out]*/ BSTR* pbstrDeploySourceURL;
		HRESULT retValue;
	};

	STDMETHOD(get_DeploySourceURL)(
		/*[out]*/ BSTR* pbstrDeploySourceURL)
	{
		VSL_DEFINE_MOCK_METHOD(get_DeploySourceURL)

		VSL_SET_VALIDVALUE_BSTR(pbstrDeploySourceURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_TypeValidValues
	{
		/*[out]*/ GUID* pguidType;
		HRESULT retValue;
	};

	STDMETHOD(get_Type)(
		/*[out]*/ GUID* pguidType)
	{
		VSL_DEFINE_MOCK_METHOD(get_Type)

		VSL_SET_VALIDVALUE(pguidType);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSOUTPUT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsOutputGroup.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSOUTPUTGROUP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSOUTPUTGROUP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsOutputGroupNotImpl :
	public IVsOutputGroup
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsOutputGroupNotImpl)

public:

	typedef IVsOutputGroup Interface;

	STDMETHOD(get_CanonicalName)(
		/*[out]*/ BSTR* /*pbstrCanonicalName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DisplayName)(
		/*[out]*/ BSTR* /*pbstrDisplayName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_KeyOutput)(
		/*[out]*/ BSTR* /*pbstrCanonicalName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ProjectCfg)(
		/*[out]*/ IVsProjectCfg2** /*ppIVsProjectCfg2*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Outputs)(
		/*[in]*/ ULONG /*celt*/,
		/*[in,out,size_is(celt)]*/ IVsOutput2*[] /*rgpcfg*/,
		/*[out,optional]*/ ULONG* /*pcActual*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DeployDependencies)(
		/*[in]*/ ULONG /*celt*/,
		/*[in,out,size_is(celt)]*/ IVsDeployDependency*[] /*rgpdpd*/,
		/*[out,optional]*/ ULONG* /*pcActual*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Description)(
		/*[out]*/ BSTR* /*pbstrDescription*/)VSL_STDMETHOD_NOTIMPL
};

class IVsOutputGroupMockImpl :
	public IVsOutputGroup,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsOutputGroupMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsOutputGroupMockImpl)

	typedef IVsOutputGroup Interface;
	struct get_CanonicalNameValidValues
	{
		/*[out]*/ BSTR* pbstrCanonicalName;
		HRESULT retValue;
	};

	STDMETHOD(get_CanonicalName)(
		/*[out]*/ BSTR* pbstrCanonicalName)
	{
		VSL_DEFINE_MOCK_METHOD(get_CanonicalName)

		VSL_SET_VALIDVALUE_BSTR(pbstrCanonicalName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DisplayNameValidValues
	{
		/*[out]*/ BSTR* pbstrDisplayName;
		HRESULT retValue;
	};

	STDMETHOD(get_DisplayName)(
		/*[out]*/ BSTR* pbstrDisplayName)
	{
		VSL_DEFINE_MOCK_METHOD(get_DisplayName)

		VSL_SET_VALIDVALUE_BSTR(pbstrDisplayName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_KeyOutputValidValues
	{
		/*[out]*/ BSTR* pbstrCanonicalName;
		HRESULT retValue;
	};

	STDMETHOD(get_KeyOutput)(
		/*[out]*/ BSTR* pbstrCanonicalName)
	{
		VSL_DEFINE_MOCK_METHOD(get_KeyOutput)

		VSL_SET_VALIDVALUE_BSTR(pbstrCanonicalName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ProjectCfgValidValues
	{
		/*[out]*/ IVsProjectCfg2** ppIVsProjectCfg2;
		HRESULT retValue;
	};

	STDMETHOD(get_ProjectCfg)(
		/*[out]*/ IVsProjectCfg2** ppIVsProjectCfg2)
	{
		VSL_DEFINE_MOCK_METHOD(get_ProjectCfg)

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsProjectCfg2);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OutputsValidValues
	{
		/*[in]*/ ULONG celt;
		/*[in,out,size_is(celt)]*/ IVsOutput2** rgpcfg;
		/*[out,optional]*/ ULONG* pcActual;
		HRESULT retValue;
	};

	STDMETHOD(get_Outputs)(
		/*[in]*/ ULONG celt,
		/*[in,out,size_is(celt)]*/ IVsOutput2* rgpcfg[],
		/*[out,optional]*/ ULONG* pcActual)
	{
		VSL_DEFINE_MOCK_METHOD(get_Outputs)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgpcfg, celt, validValues.celt);

		VSL_SET_VALIDVALUE(pcActual);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DeployDependenciesValidValues
	{
		/*[in]*/ ULONG celt;
		/*[in,out,size_is(celt)]*/ IVsDeployDependency** rgpdpd;
		/*[out,optional]*/ ULONG* pcActual;
		HRESULT retValue;
	};

	STDMETHOD(get_DeployDependencies)(
		/*[in]*/ ULONG celt,
		/*[in,out,size_is(celt)]*/ IVsDeployDependency* rgpdpd[],
		/*[out,optional]*/ ULONG* pcActual)
	{
		VSL_DEFINE_MOCK_METHOD(get_DeployDependencies)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgpdpd, celt, validValues.celt);

		VSL_SET_VALIDVALUE(pcActual);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DescriptionValidValues
	{
		/*[out]*/ BSTR* pbstrDescription;
		HRESULT retValue;
	};

	STDMETHOD(get_Description)(
		/*[out]*/ BSTR* pbstrDescription)
	{
		VSL_DEFINE_MOCK_METHOD(get_Description)

		VSL_SET_VALIDVALUE_BSTR(pbstrDescription);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSOUTPUTGROUP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsParentHierarchy.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPARENTHIERARCHY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPARENTHIERARCHY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsParentHierarchyNotImpl :
	public IVsParentHierarchy
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsParentHierarchyNotImpl)

public:

	typedef IVsParentHierarchy Interface;

	STDMETHOD(ExtendsBrowseObjects)(
		/*[out]*/ VSEXTENDSHIERARCHY* /*peExtends*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBrowseExtender)(
		/*[in]*/ IVsHierarchy* /*pHierarchyChild*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[out]*/ IDispatch** /*ppDispatchExtension*/)VSL_STDMETHOD_NOTIMPL
};

class IVsParentHierarchyMockImpl :
	public IVsParentHierarchy,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsParentHierarchyMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsParentHierarchyMockImpl)

	typedef IVsParentHierarchy Interface;
	struct ExtendsBrowseObjectsValidValues
	{
		/*[out]*/ VSEXTENDSHIERARCHY* peExtends;
		HRESULT retValue;
	};

	STDMETHOD(ExtendsBrowseObjects)(
		/*[out]*/ VSEXTENDSHIERARCHY* peExtends)
	{
		VSL_DEFINE_MOCK_METHOD(ExtendsBrowseObjects)

		VSL_SET_VALIDVALUE(peExtends);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBrowseExtenderValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchyChild;
		/*[in]*/ VSITEMID itemid;
		/*[out]*/ IDispatch** ppDispatchExtension;
		HRESULT retValue;
	};

	STDMETHOD(GetBrowseExtender)(
		/*[in]*/ IVsHierarchy* pHierarchyChild,
		/*[in]*/ VSITEMID itemid,
		/*[out]*/ IDispatch** ppDispatchExtension)
	{
		VSL_DEFINE_MOCK_METHOD(GetBrowseExtender)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchyChild);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_SET_VALIDVALUE_INTERFACE(ppDispatchExtension);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPARENTHIERARCHY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsPackageDefinedTextMarkerType.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPACKAGEDEFINEDTEXTMARKERTYPE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPACKAGEDEFINEDTEXTMARKERTYPE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsPackageDefinedTextMarkerTypeNotImpl :
	public IVsPackageDefinedTextMarkerType
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPackageDefinedTextMarkerTypeNotImpl)

public:

	typedef IVsPackageDefinedTextMarkerType Interface;

	STDMETHOD(GetVisualStyle)(
		/*[out]*/ DWORD* /*pdwVisualFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDefaultColors)(
		/*[out]*/ COLORINDEX* /*piForeground*/,
		/*[out]*/ COLORINDEX* /*piBackground*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDefaultLineStyle)(
		/*[out]*/ COLORINDEX* /*piLineColor*/,
		/*[out]*/ LINESTYLE* /*piLineIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDefaultFontFlags)(
		/*[out]*/ DWORD* /*pdwFontFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DrawGlyphWithColors)(
		/*[in]*/ HDC /*hdc*/,
		/*[in]*/ RECT* /*pRect*/,
		/*[in]*/ long /*iMarkerType*/,
		/*[in]*/ IVsTextMarkerColorSet* /*pMarkerColors*/,
		/*[in]*/ DWORD /*dwGlyphDrawFlags*/,
		/*[in]*/ long /*iLineHeight*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBehaviorFlags)(
		/*[out]*/ DWORD* /*pdwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPriorityIndex)(
		/*[out]*/ long* /*piPriorityIndex*/)VSL_STDMETHOD_NOTIMPL
};

class IVsPackageDefinedTextMarkerTypeMockImpl :
	public IVsPackageDefinedTextMarkerType,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPackageDefinedTextMarkerTypeMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsPackageDefinedTextMarkerTypeMockImpl)

	typedef IVsPackageDefinedTextMarkerType Interface;
	struct GetVisualStyleValidValues
	{
		/*[out]*/ DWORD* pdwVisualFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetVisualStyle)(
		/*[out]*/ DWORD* pdwVisualFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetVisualStyle)

		VSL_SET_VALIDVALUE(pdwVisualFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDefaultColorsValidValues
	{
		/*[out]*/ COLORINDEX* piForeground;
		/*[out]*/ COLORINDEX* piBackground;
		HRESULT retValue;
	};

	STDMETHOD(GetDefaultColors)(
		/*[out]*/ COLORINDEX* piForeground,
		/*[out]*/ COLORINDEX* piBackground)
	{
		VSL_DEFINE_MOCK_METHOD(GetDefaultColors)

		VSL_SET_VALIDVALUE(piForeground);

		VSL_SET_VALIDVALUE(piBackground);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDefaultLineStyleValidValues
	{
		/*[out]*/ COLORINDEX* piLineColor;
		/*[out]*/ LINESTYLE* piLineIndex;
		HRESULT retValue;
	};

	STDMETHOD(GetDefaultLineStyle)(
		/*[out]*/ COLORINDEX* piLineColor,
		/*[out]*/ LINESTYLE* piLineIndex)
	{
		VSL_DEFINE_MOCK_METHOD(GetDefaultLineStyle)

		VSL_SET_VALIDVALUE(piLineColor);

		VSL_SET_VALIDVALUE(piLineIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDefaultFontFlagsValidValues
	{
		/*[out]*/ DWORD* pdwFontFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetDefaultFontFlags)(
		/*[out]*/ DWORD* pdwFontFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetDefaultFontFlags)

		VSL_SET_VALIDVALUE(pdwFontFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct DrawGlyphWithColorsValidValues
	{
		/*[in]*/ HDC hdc;
		/*[in]*/ RECT* pRect;
		/*[in]*/ long iMarkerType;
		/*[in]*/ IVsTextMarkerColorSet* pMarkerColors;
		/*[in]*/ DWORD dwGlyphDrawFlags;
		/*[in]*/ long iLineHeight;
		HRESULT retValue;
	};

	STDMETHOD(DrawGlyphWithColors)(
		/*[in]*/ HDC hdc,
		/*[in]*/ RECT* pRect,
		/*[in]*/ long iMarkerType,
		/*[in]*/ IVsTextMarkerColorSet* pMarkerColors,
		/*[in]*/ DWORD dwGlyphDrawFlags,
		/*[in]*/ long iLineHeight)
	{
		VSL_DEFINE_MOCK_METHOD(DrawGlyphWithColors)

		VSL_CHECK_VALIDVALUE(hdc);

		VSL_CHECK_VALIDVALUE_POINTER(pRect);

		VSL_CHECK_VALIDVALUE(iMarkerType);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pMarkerColors);

		VSL_CHECK_VALIDVALUE(dwGlyphDrawFlags);

		VSL_CHECK_VALIDVALUE(iLineHeight);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBehaviorFlagsValidValues
	{
		/*[out]*/ DWORD* pdwFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetBehaviorFlags)(
		/*[out]*/ DWORD* pdwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetBehaviorFlags)

		VSL_SET_VALIDVALUE(pdwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPriorityIndexValidValues
	{
		/*[out]*/ long* piPriorityIndex;
		HRESULT retValue;
	};

	STDMETHOD(GetPriorityIndex)(
		/*[out]*/ long* piPriorityIndex)
	{
		VSL_DEFINE_MOCK_METHOD(GetPriorityIndex)

		VSL_SET_VALIDVALUE(piPriorityIndex);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPACKAGEDEFINEDTEXTMARKERTYPE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsPackageDynamicToolOwner.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPACKAGEDYNAMICTOOLOWNER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPACKAGEDYNAMICTOOLOWNER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsPackageDynamicToolOwnerNotImpl :
	public IVsPackageDynamicToolOwner
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPackageDynamicToolOwnerNotImpl)

public:

	typedef IVsPackageDynamicToolOwner Interface;

	STDMETHOD(QueryShowTool)(
		/*[in]*/ REFGUID /*rguidPersistenceSlot*/,
		/*[out]*/ BOOL* /*pfShowTool*/)VSL_STDMETHOD_NOTIMPL
};

class IVsPackageDynamicToolOwnerMockImpl :
	public IVsPackageDynamicToolOwner,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPackageDynamicToolOwnerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsPackageDynamicToolOwnerMockImpl)

	typedef IVsPackageDynamicToolOwner Interface;
	struct QueryShowToolValidValues
	{
		/*[in]*/ REFGUID rguidPersistenceSlot;
		/*[out]*/ BOOL* pfShowTool;
		HRESULT retValue;
	};

	STDMETHOD(QueryShowTool)(
		/*[in]*/ REFGUID rguidPersistenceSlot,
		/*[out]*/ BOOL* pfShowTool)
	{
		VSL_DEFINE_MOCK_METHOD(QueryShowTool)

		VSL_CHECK_VALIDVALUE(rguidPersistenceSlot);

		VSL_SET_VALIDVALUE(pfShowTool);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPACKAGEDYNAMICTOOLOWNER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsOutputWindowPane.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSOUTPUTWINDOWPANE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSOUTPUTWINDOWPANE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsOutputWindowPaneNotImpl :
	public IVsOutputWindowPane
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsOutputWindowPaneNotImpl)

public:

	typedef IVsOutputWindowPane Interface;

	STDMETHOD(OutputString)(
		/*[in]*/ LPCOLESTR /*pszOutputString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Activate)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Hide)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Clear)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FlushToTaskList)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OutputTaskItemString)(
		/*[in]*/ LPCOLESTR /*pszOutputString*/,
		/*[in]*/ VSTASKPRIORITY /*nPriority*/,
		/*[in]*/ VSTASKCATEGORY /*nCategory*/,
		/*[in]*/ LPCOLESTR /*pszSubcategory*/,
		/*[in]*/ VSTASKBITMAP /*nBitmap*/,
		/*[in]*/ LPCOLESTR /*pszFilename*/,
		/*[in]*/ ULONG /*nLineNum*/,
		/*[in]*/ LPCOLESTR /*pszTaskItemText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OutputTaskItemStringEx)(
		/*[in]*/ LPCOLESTR /*pszOutputString*/,
		/*[in]*/ VSTASKPRIORITY /*nPriority*/,
		/*[in]*/ VSTASKCATEGORY /*nCategory*/,
		/*[in]*/ LPCOLESTR /*pszSubcategory*/,
		/*[in]*/ VSTASKBITMAP /*nBitmap*/,
		/*[in]*/ LPCOLESTR /*pszFilename*/,
		/*[in]*/ ULONG /*nLineNum*/,
		/*[in]*/ LPCOLESTR /*pszTaskItemText*/,
		/*[in]*/ LPCOLESTR /*pszLookupKwd*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetName)(
		/*[in]*/ BSTR* /*pbstrPaneName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetName)(
		/*[in]*/ LPCOLESTR /*pszPaneName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OutputStringThreadSafe)(
		/*[in]*/ LPCOLESTR /*pszOutputString*/)VSL_STDMETHOD_NOTIMPL
};

class IVsOutputWindowPaneMockImpl :
	public IVsOutputWindowPane,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsOutputWindowPaneMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsOutputWindowPaneMockImpl)

	typedef IVsOutputWindowPane Interface;
	struct OutputStringValidValues
	{
		/*[in]*/ LPCOLESTR pszOutputString;
		HRESULT retValue;
	};

	STDMETHOD(OutputString)(
		/*[in]*/ LPCOLESTR pszOutputString)
	{
		VSL_DEFINE_MOCK_METHOD(OutputString)

		VSL_CHECK_VALIDVALUE_STRINGW(pszOutputString);

		VSL_RETURN_VALIDVALUES();
	}
	struct ActivateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Activate)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Activate)

		VSL_RETURN_VALIDVALUES();
	}
	struct HideValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Hide)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Hide)

		VSL_RETURN_VALIDVALUES();
	}
	struct ClearValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Clear)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Clear)

		VSL_RETURN_VALIDVALUES();
	}
	struct FlushToTaskListValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(FlushToTaskList)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(FlushToTaskList)

		VSL_RETURN_VALIDVALUES();
	}
	struct OutputTaskItemStringValidValues
	{
		/*[in]*/ LPCOLESTR pszOutputString;
		/*[in]*/ VSTASKPRIORITY nPriority;
		/*[in]*/ VSTASKCATEGORY nCategory;
		/*[in]*/ LPCOLESTR pszSubcategory;
		/*[in]*/ VSTASKBITMAP nBitmap;
		/*[in]*/ LPCOLESTR pszFilename;
		/*[in]*/ ULONG nLineNum;
		/*[in]*/ LPCOLESTR pszTaskItemText;
		HRESULT retValue;
	};

	STDMETHOD(OutputTaskItemString)(
		/*[in]*/ LPCOLESTR pszOutputString,
		/*[in]*/ VSTASKPRIORITY nPriority,
		/*[in]*/ VSTASKCATEGORY nCategory,
		/*[in]*/ LPCOLESTR pszSubcategory,
		/*[in]*/ VSTASKBITMAP nBitmap,
		/*[in]*/ LPCOLESTR pszFilename,
		/*[in]*/ ULONG nLineNum,
		/*[in]*/ LPCOLESTR pszTaskItemText)
	{
		VSL_DEFINE_MOCK_METHOD(OutputTaskItemString)

		VSL_CHECK_VALIDVALUE_STRINGW(pszOutputString);

		VSL_CHECK_VALIDVALUE(nPriority);

		VSL_CHECK_VALIDVALUE(nCategory);

		VSL_CHECK_VALIDVALUE_STRINGW(pszSubcategory);

		VSL_CHECK_VALIDVALUE(nBitmap);

		VSL_CHECK_VALIDVALUE_STRINGW(pszFilename);

		VSL_CHECK_VALIDVALUE(nLineNum);

		VSL_CHECK_VALIDVALUE_STRINGW(pszTaskItemText);

		VSL_RETURN_VALIDVALUES();
	}
	struct OutputTaskItemStringExValidValues
	{
		/*[in]*/ LPCOLESTR pszOutputString;
		/*[in]*/ VSTASKPRIORITY nPriority;
		/*[in]*/ VSTASKCATEGORY nCategory;
		/*[in]*/ LPCOLESTR pszSubcategory;
		/*[in]*/ VSTASKBITMAP nBitmap;
		/*[in]*/ LPCOLESTR pszFilename;
		/*[in]*/ ULONG nLineNum;
		/*[in]*/ LPCOLESTR pszTaskItemText;
		/*[in]*/ LPCOLESTR pszLookupKwd;
		HRESULT retValue;
	};

	STDMETHOD(OutputTaskItemStringEx)(
		/*[in]*/ LPCOLESTR pszOutputString,
		/*[in]*/ VSTASKPRIORITY nPriority,
		/*[in]*/ VSTASKCATEGORY nCategory,
		/*[in]*/ LPCOLESTR pszSubcategory,
		/*[in]*/ VSTASKBITMAP nBitmap,
		/*[in]*/ LPCOLESTR pszFilename,
		/*[in]*/ ULONG nLineNum,
		/*[in]*/ LPCOLESTR pszTaskItemText,
		/*[in]*/ LPCOLESTR pszLookupKwd)
	{
		VSL_DEFINE_MOCK_METHOD(OutputTaskItemStringEx)

		VSL_CHECK_VALIDVALUE_STRINGW(pszOutputString);

		VSL_CHECK_VALIDVALUE(nPriority);

		VSL_CHECK_VALIDVALUE(nCategory);

		VSL_CHECK_VALIDVALUE_STRINGW(pszSubcategory);

		VSL_CHECK_VALIDVALUE(nBitmap);

		VSL_CHECK_VALIDVALUE_STRINGW(pszFilename);

		VSL_CHECK_VALIDVALUE(nLineNum);

		VSL_CHECK_VALIDVALUE_STRINGW(pszTaskItemText);

		VSL_CHECK_VALIDVALUE_STRINGW(pszLookupKwd);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNameValidValues
	{
		/*[in]*/ BSTR* pbstrPaneName;
		HRESULT retValue;
	};

	STDMETHOD(GetName)(
		/*[in]*/ BSTR* pbstrPaneName)
	{
		VSL_DEFINE_MOCK_METHOD(GetName)

		VSL_CHECK_VALIDVALUE_POINTER(pbstrPaneName);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetNameValidValues
	{
		/*[in]*/ LPCOLESTR pszPaneName;
		HRESULT retValue;
	};

	STDMETHOD(SetName)(
		/*[in]*/ LPCOLESTR pszPaneName)
	{
		VSL_DEFINE_MOCK_METHOD(SetName)

		VSL_CHECK_VALIDVALUE_STRINGW(pszPaneName);

		VSL_RETURN_VALIDVALUES();
	}
	struct OutputStringThreadSafeValidValues
	{
		/*[in]*/ LPCOLESTR pszOutputString;
		HRESULT retValue;
	};

	STDMETHOD(OutputStringThreadSafe)(
		/*[in]*/ LPCOLESTR pszOutputString)
	{
		VSL_DEFINE_MOCK_METHOD(OutputStringThreadSafe)

		VSL_CHECK_VALIDVALUE_STRINGW(pszOutputString);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSOUTPUTWINDOWPANE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsOverrideTextViewAccessibilityState.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSOVERRIDETEXTVIEWACCESSIBILITYSTATE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSOVERRIDETEXTVIEWACCESSIBILITYSTATE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsOverrideTextViewAccessibilityStateNotImpl :
	public IVsOverrideTextViewAccessibilityState
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsOverrideTextViewAccessibilityStateNotImpl)

public:

	typedef IVsOverrideTextViewAccessibilityState Interface;

	STDMETHOD(GetOverrides)(
		/*[out]*/ DWORD* /*pdwMask*/,
		/*[out]*/ DWORD* /*pdwFlags*/)VSL_STDMETHOD_NOTIMPL
};

class IVsOverrideTextViewAccessibilityStateMockImpl :
	public IVsOverrideTextViewAccessibilityState,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsOverrideTextViewAccessibilityStateMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsOverrideTextViewAccessibilityStateMockImpl)

	typedef IVsOverrideTextViewAccessibilityState Interface;
	struct GetOverridesValidValues
	{
		/*[out]*/ DWORD* pdwMask;
		/*[out]*/ DWORD* pdwFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetOverrides)(
		/*[out]*/ DWORD* pdwMask,
		/*[out]*/ DWORD* pdwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetOverrides)

		VSL_SET_VALIDVALUE(pdwMask);

		VSL_SET_VALIDVALUE(pdwFlags);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSOVERRIDETEXTVIEWACCESSIBILITYSTATE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsOwnedProjectFactory.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSOWNEDPROJECTFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSOWNEDPROJECTFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsOwnedProjectFactoryNotImpl :
	public IVsOwnedProjectFactory
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsOwnedProjectFactoryNotImpl)

public:

	typedef IVsOwnedProjectFactory Interface;

	STDMETHOD(PreCreateForOwner)(
		/*[in]*/ IUnknown* /*pUnkOwner*/,
		/*[out]*/ IUnknown** /*ppUnkInner*/,
		/*[out]*/ VSOWNEDPROJECTOBJECT* /*pCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(InitializeForOwner)(
		/*[in]*/ LPCOLESTR /*pszFilename*/,
		/*[in]*/ LPCOLESTR /*pszLocation*/,
		/*[in]*/ LPCOLESTR /*pszName*/,
		/*[in]*/ VSCREATEPROJFLAGS /*grfCreateFlags*/,
		/*[in]*/ REFIID /*iidProject*/,
		/*[in]*/ VSOWNEDPROJECTOBJECT /*cookie*/,
		/*[out,iid_is(iidProject)]*/ void** /*ppvProject*/,
		/*[out]*/ BOOL* /*pfCanceled*/)VSL_STDMETHOD_NOTIMPL
};

class IVsOwnedProjectFactoryMockImpl :
	public IVsOwnedProjectFactory,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsOwnedProjectFactoryMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsOwnedProjectFactoryMockImpl)

	typedef IVsOwnedProjectFactory Interface;
	struct PreCreateForOwnerValidValues
	{
		/*[in]*/ IUnknown* pUnkOwner;
		/*[out]*/ IUnknown** ppUnkInner;
		/*[out]*/ VSOWNEDPROJECTOBJECT* pCookie;
		HRESULT retValue;
	};

	STDMETHOD(PreCreateForOwner)(
		/*[in]*/ IUnknown* pUnkOwner,
		/*[out]*/ IUnknown** ppUnkInner,
		/*[out]*/ VSOWNEDPROJECTOBJECT* pCookie)
	{
		VSL_DEFINE_MOCK_METHOD(PreCreateForOwner)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnkOwner);

		VSL_SET_VALIDVALUE_INTERFACE(ppUnkInner);

		VSL_SET_VALIDVALUE(pCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct InitializeForOwnerValidValues
	{
		/*[in]*/ LPCOLESTR pszFilename;
		/*[in]*/ LPCOLESTR pszLocation;
		/*[in]*/ LPCOLESTR pszName;
		/*[in]*/ VSCREATEPROJFLAGS grfCreateFlags;
		/*[in]*/ REFIID iidProject;
		/*[in]*/ VSOWNEDPROJECTOBJECT cookie;
		/*[out,iid_is(iidProject)]*/ void** ppvProject;
		/*[out]*/ BOOL* pfCanceled;
		HRESULT retValue;
	};

	STDMETHOD(InitializeForOwner)(
		/*[in]*/ LPCOLESTR pszFilename,
		/*[in]*/ LPCOLESTR pszLocation,
		/*[in]*/ LPCOLESTR pszName,
		/*[in]*/ VSCREATEPROJFLAGS grfCreateFlags,
		/*[in]*/ REFIID iidProject,
		/*[in]*/ VSOWNEDPROJECTOBJECT cookie,
		/*[out,iid_is(iidProject)]*/ void** ppvProject,
		/*[out]*/ BOOL* pfCanceled)
	{
		VSL_DEFINE_MOCK_METHOD(InitializeForOwner)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFilename);

		VSL_CHECK_VALIDVALUE_STRINGW(pszLocation);

		VSL_CHECK_VALIDVALUE_STRINGW(pszName);

		VSL_CHECK_VALIDVALUE(grfCreateFlags);

		VSL_CHECK_VALIDVALUE(iidProject);

		VSL_CHECK_VALIDVALUE(cookie);

		VSL_SET_VALIDVALUE(ppvProject);

		VSL_SET_VALIDVALUE(pfCanceled);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSOWNEDPROJECTFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsPackage.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPACKAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPACKAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsPackageNotImpl :
	public IVsPackage
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPackageNotImpl)

public:

	typedef IVsPackage Interface;

	STDMETHOD(SetSite)(
		/*[in]*/ IServiceProvider* /*pSP*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryClose)(
		/*[out]*/ BOOL* /*pfCanClose*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Close)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetAutomationObject)(
		/*[in]*/ LPCOLESTR /*pszPropName*/,
		/*[out]*/ IDispatch** /*ppDisp*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateTool)(
		/*[in]*/ REFGUID /*rguidPersistenceSlot*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ResetDefaults)(
		/*[in]*/ VSPKGRESETFLAGS /*grfFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPropertyPage)(
		/*[in]*/ REFGUID /*rguidPage*/,
		/*[in,out]*/ VSPROPSHEETPAGE* /*ppage*/)VSL_STDMETHOD_NOTIMPL
};

class IVsPackageMockImpl :
	public IVsPackage,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPackageMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsPackageMockImpl)

	typedef IVsPackage Interface;
	struct SetSiteValidValues
	{
		/*[in]*/ IServiceProvider* pSP;
		HRESULT retValue;
	};

	STDMETHOD(SetSite)(
		/*[in]*/ IServiceProvider* pSP)
	{
		VSL_DEFINE_MOCK_METHOD(SetSite)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSP);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryCloseValidValues
	{
		/*[out]*/ BOOL* pfCanClose;
		HRESULT retValue;
	};

	STDMETHOD(QueryClose)(
		/*[out]*/ BOOL* pfCanClose)
	{
		VSL_DEFINE_MOCK_METHOD(QueryClose)

		VSL_SET_VALIDVALUE(pfCanClose);

		VSL_RETURN_VALIDVALUES();
	}
	struct CloseValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Close)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Close)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetAutomationObjectValidValues
	{
		/*[in]*/ LPCOLESTR pszPropName;
		/*[out]*/ IDispatch** ppDisp;
		HRESULT retValue;
	};

	STDMETHOD(GetAutomationObject)(
		/*[in]*/ LPCOLESTR pszPropName,
		/*[out]*/ IDispatch** ppDisp)
	{
		VSL_DEFINE_MOCK_METHOD(GetAutomationObject)

		VSL_CHECK_VALIDVALUE_STRINGW(pszPropName);

		VSL_SET_VALIDVALUE_INTERFACE(ppDisp);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateToolValidValues
	{
		/*[in]*/ REFGUID rguidPersistenceSlot;
		HRESULT retValue;
	};

	STDMETHOD(CreateTool)(
		/*[in]*/ REFGUID rguidPersistenceSlot)
	{
		VSL_DEFINE_MOCK_METHOD(CreateTool)

		VSL_CHECK_VALIDVALUE(rguidPersistenceSlot);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetDefaultsValidValues
	{
		/*[in]*/ VSPKGRESETFLAGS grfFlags;
		HRESULT retValue;
	};

	STDMETHOD(ResetDefaults)(
		/*[in]*/ VSPKGRESETFLAGS grfFlags)
	{
		VSL_DEFINE_MOCK_METHOD(ResetDefaults)

		VSL_CHECK_VALIDVALUE(grfFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPropertyPageValidValues
	{
		/*[in]*/ REFGUID rguidPage;
		/*[in,out]*/ VSPROPSHEETPAGE* ppage;
		HRESULT retValue;
	};

	STDMETHOD(GetPropertyPage)(
		/*[in]*/ REFGUID rguidPage,
		/*[in,out]*/ VSPROPSHEETPAGE* ppage)
	{
		VSL_DEFINE_MOCK_METHOD(GetPropertyPage)

		VSL_CHECK_VALIDVALUE(rguidPage);

		VSL_SET_VALIDVALUE(ppage);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPACKAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsPackageDynamicToolOwnerEx.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPACKAGEDYNAMICTOOLOWNEREX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPACKAGEDYNAMICTOOLOWNEREX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsPackageDynamicToolOwnerExNotImpl :
	public IVsPackageDynamicToolOwnerEx
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPackageDynamicToolOwnerExNotImpl)

public:

	typedef IVsPackageDynamicToolOwnerEx Interface;

	STDMETHOD(QueryShowTool)(
		/*[in]*/ REFGUID /*rguidPersistenceSlot*/,
		/*[in]*/ DWORD /*dwID*/,
		/*[out]*/ BOOL* /*pfShowTool*/)VSL_STDMETHOD_NOTIMPL
};

class IVsPackageDynamicToolOwnerExMockImpl :
	public IVsPackageDynamicToolOwnerEx,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPackageDynamicToolOwnerExMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsPackageDynamicToolOwnerExMockImpl)

	typedef IVsPackageDynamicToolOwnerEx Interface;
	struct QueryShowToolValidValues
	{
		/*[in]*/ REFGUID rguidPersistenceSlot;
		/*[in]*/ DWORD dwID;
		/*[out]*/ BOOL* pfShowTool;
		HRESULT retValue;
	};

	STDMETHOD(QueryShowTool)(
		/*[in]*/ REFGUID rguidPersistenceSlot,
		/*[in]*/ DWORD dwID,
		/*[out]*/ BOOL* pfShowTool)
	{
		VSL_DEFINE_MOCK_METHOD(QueryShowTool)

		VSL_CHECK_VALIDVALUE(rguidPersistenceSlot);

		VSL_CHECK_VALIDVALUE(dwID);

		VSL_SET_VALIDVALUE(pfShowTool);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPACKAGEDYNAMICTOOLOWNEREX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsParentProject2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPARENTPROJECT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPARENTPROJECT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsParentProject2NotImpl :
	public IVsParentProject2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsParentProject2NotImpl)

public:

	typedef IVsParentProject2 Interface;

	STDMETHOD(CreateNestedProject)(
		/*[in]*/ VSITEMID /*itemidLoc*/,
		/*[in]*/ REFGUID /*rguidProjectType*/,
		/*[in]*/ LPCOLESTR /*lpszMoniker*/,
		/*[in]*/ LPCOLESTR /*lpszLocation*/,
		/*[in]*/ LPCOLESTR /*lpszName*/,
		/*[in]*/ VSCREATEPROJFLAGS /*grfCreateFlags*/,
		/*[in]*/ REFGUID /*rguidProjectID*/,
		/*[in]*/ REFIID /*iidProject*/,
		/*[out,iid_is(iidProject)]*/ void** /*ppProject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddNestedSolution)(
		/*[in]*/ VSITEMID /*itemidLoc*/,
		/*[in]*/ VSSLNOPENOPTIONS /*grfOpenOpts*/,
		/*[in]*/ LPCOLESTR /*pszFilename*/)VSL_STDMETHOD_NOTIMPL
};

class IVsParentProject2MockImpl :
	public IVsParentProject2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsParentProject2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsParentProject2MockImpl)

	typedef IVsParentProject2 Interface;
	struct CreateNestedProjectValidValues
	{
		/*[in]*/ VSITEMID itemidLoc;
		/*[in]*/ REFGUID rguidProjectType;
		/*[in]*/ LPCOLESTR lpszMoniker;
		/*[in]*/ LPCOLESTR lpszLocation;
		/*[in]*/ LPCOLESTR lpszName;
		/*[in]*/ VSCREATEPROJFLAGS grfCreateFlags;
		/*[in]*/ REFGUID rguidProjectID;
		/*[in]*/ REFIID iidProject;
		/*[out,iid_is(iidProject)]*/ void** ppProject;
		HRESULT retValue;
	};

	STDMETHOD(CreateNestedProject)(
		/*[in]*/ VSITEMID itemidLoc,
		/*[in]*/ REFGUID rguidProjectType,
		/*[in]*/ LPCOLESTR lpszMoniker,
		/*[in]*/ LPCOLESTR lpszLocation,
		/*[in]*/ LPCOLESTR lpszName,
		/*[in]*/ VSCREATEPROJFLAGS grfCreateFlags,
		/*[in]*/ REFGUID rguidProjectID,
		/*[in]*/ REFIID iidProject,
		/*[out,iid_is(iidProject)]*/ void** ppProject)
	{
		VSL_DEFINE_MOCK_METHOD(CreateNestedProject)

		VSL_CHECK_VALIDVALUE(itemidLoc);

		VSL_CHECK_VALIDVALUE(rguidProjectType);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszMoniker);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszLocation);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszName);

		VSL_CHECK_VALIDVALUE(grfCreateFlags);

		VSL_CHECK_VALIDVALUE(rguidProjectID);

		VSL_CHECK_VALIDVALUE(iidProject);

		VSL_SET_VALIDVALUE(ppProject);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddNestedSolutionValidValues
	{
		/*[in]*/ VSITEMID itemidLoc;
		/*[in]*/ VSSLNOPENOPTIONS grfOpenOpts;
		/*[in]*/ LPCOLESTR pszFilename;
		HRESULT retValue;
	};

	STDMETHOD(AddNestedSolution)(
		/*[in]*/ VSITEMID itemidLoc,
		/*[in]*/ VSSLNOPENOPTIONS grfOpenOpts,
		/*[in]*/ LPCOLESTR pszFilename)
	{
		VSL_DEFINE_MOCK_METHOD(AddNestedSolution)

		VSL_CHECK_VALIDVALUE(itemidLoc);

		VSL_CHECK_VALIDVALUE(grfOpenOpts);

		VSL_CHECK_VALIDVALUE_STRINGW(pszFilename);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPARENTPROJECT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsParseCommandLine2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPARSECOMMANDLINE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPARSECOMMANDLINE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsParseCommandLine2NotImpl :
	public IVsParseCommandLine2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsParseCommandLine2NotImpl)

public:

	typedef IVsParseCommandLine2 Interface;

	STDMETHOD(GetACParamOrSwitch)(
		/*[out]*/ int* /*piACIndex*/,
		/*[out]*/ int* /*piACStart*/,
		/*[out]*/ int* /*pcchACLength*/,
		/*[out]*/ BSTR* /*pbstrCurSwitch*/,
		/*[out,retval]*/ BSTR* /*pbstrACParam*/)VSL_STDMETHOD_NOTIMPL
};

class IVsParseCommandLine2MockImpl :
	public IVsParseCommandLine2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsParseCommandLine2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsParseCommandLine2MockImpl)

	typedef IVsParseCommandLine2 Interface;
	struct GetACParamOrSwitchValidValues
	{
		/*[out]*/ int* piACIndex;
		/*[out]*/ int* piACStart;
		/*[out]*/ int* pcchACLength;
		/*[out]*/ BSTR* pbstrCurSwitch;
		/*[out,retval]*/ BSTR* pbstrACParam;
		HRESULT retValue;
	};

	STDMETHOD(GetACParamOrSwitch)(
		/*[out]*/ int* piACIndex,
		/*[out]*/ int* piACStart,
		/*[out]*/ int* pcchACLength,
		/*[out]*/ BSTR* pbstrCurSwitch,
		/*[out,retval]*/ BSTR* pbstrACParam)
	{
		VSL_DEFINE_MOCK_METHOD(GetACParamOrSwitch)

		VSL_SET_VALIDVALUE(piACIndex);

		VSL_SET_VALIDVALUE(piACStart);

		VSL_SET_VALIDVALUE(pcchACLength);

		VSL_SET_VALIDVALUE_BSTR(pbstrCurSwitch);

		VSL_SET_VALIDVALUE_BSTR(pbstrACParam);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPARSECOMMANDLINE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsPersistDocData.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPERSISTDOCDATA_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPERSISTDOCDATA_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsPersistDocDataNotImpl :
	public IVsPersistDocData
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPersistDocDataNotImpl)

public:

	typedef IVsPersistDocData Interface;

	STDMETHOD(GetGuidEditorType)(
		/*[out]*/ CLSID* /*pClassID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsDocDataDirty)(
		/*[out]*/ BOOL* /*pfDirty*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetUntitledDocPath)(
		/*[in]*/ LPCOLESTR /*pszDocDataPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LoadDocData)(
		/*[in]*/ LPCOLESTR /*pszMkDocument*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SaveDocData)(
		/*[in]*/ VSSAVEFLAGS /*dwSave*/,
		/*[out]*/ BSTR* /*pbstrMkDocumentNew*/,
		/*[out]*/ BOOL* /*pfSaveCanceled*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Close)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnRegisterDocData)(
		/*[in]*/ VSCOOKIE /*docCookie*/,
		/*[in]*/ IVsHierarchy* /*pHierNew*/,
		/*[in]*/ VSITEMID /*itemidNew*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RenameDocData)(
		/*[in]*/ VSRDTATTRIB /*grfAttribs*/,
		/*[in]*/ IVsHierarchy* /*pHierNew*/,
		/*[in]*/ VSITEMID /*itemidNew*/,
		/*[in]*/ LPCOLESTR /*pszMkDocumentNew*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsDocDataReloadable)(
		/*[out]*/ BOOL* /*pfReloadable*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReloadDocData)(
		/*[in]*/ VSRELOADDOCDATA /*grfFlags*/)VSL_STDMETHOD_NOTIMPL
};

class IVsPersistDocDataMockImpl :
	public IVsPersistDocData,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPersistDocDataMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsPersistDocDataMockImpl)

	typedef IVsPersistDocData Interface;
	struct GetGuidEditorTypeValidValues
	{
		/*[out]*/ CLSID* pClassID;
		HRESULT retValue;
	};

	STDMETHOD(GetGuidEditorType)(
		/*[out]*/ CLSID* pClassID)
	{
		VSL_DEFINE_MOCK_METHOD(GetGuidEditorType)

		VSL_SET_VALIDVALUE(pClassID);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsDocDataDirtyValidValues
	{
		/*[out]*/ BOOL* pfDirty;
		HRESULT retValue;
	};

	STDMETHOD(IsDocDataDirty)(
		/*[out]*/ BOOL* pfDirty)
	{
		VSL_DEFINE_MOCK_METHOD(IsDocDataDirty)

		VSL_SET_VALIDVALUE(pfDirty);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetUntitledDocPathValidValues
	{
		/*[in]*/ LPCOLESTR pszDocDataPath;
		HRESULT retValue;
	};

	STDMETHOD(SetUntitledDocPath)(
		/*[in]*/ LPCOLESTR pszDocDataPath)
	{
		VSL_DEFINE_MOCK_METHOD(SetUntitledDocPath)

		VSL_CHECK_VALIDVALUE_STRINGW(pszDocDataPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadDocDataValidValues
	{
		/*[in]*/ LPCOLESTR pszMkDocument;
		HRESULT retValue;
	};

	STDMETHOD(LoadDocData)(
		/*[in]*/ LPCOLESTR pszMkDocument)
	{
		VSL_DEFINE_MOCK_METHOD(LoadDocData)

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveDocDataValidValues
	{
		/*[in]*/ VSSAVEFLAGS dwSave;
		/*[out]*/ BSTR* pbstrMkDocumentNew;
		/*[out]*/ BOOL* pfSaveCanceled;
		HRESULT retValue;
	};

	STDMETHOD(SaveDocData)(
		/*[in]*/ VSSAVEFLAGS dwSave,
		/*[out]*/ BSTR* pbstrMkDocumentNew,
		/*[out]*/ BOOL* pfSaveCanceled)
	{
		VSL_DEFINE_MOCK_METHOD(SaveDocData)

		VSL_CHECK_VALIDVALUE(dwSave);

		VSL_SET_VALIDVALUE_BSTR(pbstrMkDocumentNew);

		VSL_SET_VALIDVALUE(pfSaveCanceled);

		VSL_RETURN_VALIDVALUES();
	}
	struct CloseValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Close)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Close)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnRegisterDocDataValidValues
	{
		/*[in]*/ VSCOOKIE docCookie;
		/*[in]*/ IVsHierarchy* pHierNew;
		/*[in]*/ VSITEMID itemidNew;
		HRESULT retValue;
	};

	STDMETHOD(OnRegisterDocData)(
		/*[in]*/ VSCOOKIE docCookie,
		/*[in]*/ IVsHierarchy* pHierNew,
		/*[in]*/ VSITEMID itemidNew)
	{
		VSL_DEFINE_MOCK_METHOD(OnRegisterDocData)

		VSL_CHECK_VALIDVALUE(docCookie);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierNew);

		VSL_CHECK_VALIDVALUE(itemidNew);

		VSL_RETURN_VALIDVALUES();
	}
	struct RenameDocDataValidValues
	{
		/*[in]*/ VSRDTATTRIB grfAttribs;
		/*[in]*/ IVsHierarchy* pHierNew;
		/*[in]*/ VSITEMID itemidNew;
		/*[in]*/ LPCOLESTR pszMkDocumentNew;
		HRESULT retValue;
	};

	STDMETHOD(RenameDocData)(
		/*[in]*/ VSRDTATTRIB grfAttribs,
		/*[in]*/ IVsHierarchy* pHierNew,
		/*[in]*/ VSITEMID itemidNew,
		/*[in]*/ LPCOLESTR pszMkDocumentNew)
	{
		VSL_DEFINE_MOCK_METHOD(RenameDocData)

		VSL_CHECK_VALIDVALUE(grfAttribs);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierNew);

		VSL_CHECK_VALIDVALUE(itemidNew);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocumentNew);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsDocDataReloadableValidValues
	{
		/*[out]*/ BOOL* pfReloadable;
		HRESULT retValue;
	};

	STDMETHOD(IsDocDataReloadable)(
		/*[out]*/ BOOL* pfReloadable)
	{
		VSL_DEFINE_MOCK_METHOD(IsDocDataReloadable)

		VSL_SET_VALIDVALUE(pfReloadable);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReloadDocDataValidValues
	{
		/*[in]*/ VSRELOADDOCDATA grfFlags;
		HRESULT retValue;
	};

	STDMETHOD(ReloadDocData)(
		/*[in]*/ VSRELOADDOCDATA grfFlags)
	{
		VSL_DEFINE_MOCK_METHOD(ReloadDocData)

		VSL_CHECK_VALIDVALUE(grfFlags);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPERSISTDOCDATA_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsPerPropertyBrowsing.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPERPROPERTYBROWSING_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPERPROPERTYBROWSING_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsPerPropertyBrowsingNotImpl :
	public IVsPerPropertyBrowsing
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPerPropertyBrowsingNotImpl)

public:

	typedef IVsPerPropertyBrowsing Interface;

	STDMETHOD(HideProperty)(
		/*[in]*/ DISPID /*dispid*/,
		/*[out,retval]*/ BOOL* /*pfHide*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DisplayChildProperties)(
		/*[in]*/ DISPID /*dispid*/,
		/*[out,retval]*/ BOOL* /*pfDisplay*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLocalizedPropertyInfo)(
		/*[in]*/ DISPID /*dispid*/,
		/*[in]*/ LCID /*localeID*/,
		/*[out]*/ BSTR* /*pbstrLocalizedName*/,
		/*[out]*/ BSTR* /*pbstrLocalizeDescription*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(HasDefaultValue)(
		/*[in]*/ DISPID /*dispid*/,
		/*[out,retval]*/ BOOL* /*fDefault*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsPropertyReadOnly)(
		/*[in]*/ DISPID /*dispid*/,
		/*[out,retval]*/ BOOL* /*fReadOnly*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetClassName)(
		/*[out,retval]*/ BSTR* /*pbstrClassName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanResetPropertyValue)(
		/*[in]*/ DISPID /*dispid*/,
		/*[out,retval]*/ BOOL* /*pfCanReset*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ResetPropertyValue)(
		/*[in]*/ DISPID /*dispid*/)VSL_STDMETHOD_NOTIMPL
};

class IVsPerPropertyBrowsingMockImpl :
	public IVsPerPropertyBrowsing,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPerPropertyBrowsingMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsPerPropertyBrowsingMockImpl)

	typedef IVsPerPropertyBrowsing Interface;
	struct HidePropertyValidValues
	{
		/*[in]*/ DISPID dispid;
		/*[out,retval]*/ BOOL* pfHide;
		HRESULT retValue;
	};

	STDMETHOD(HideProperty)(
		/*[in]*/ DISPID dispid,
		/*[out,retval]*/ BOOL* pfHide)
	{
		VSL_DEFINE_MOCK_METHOD(HideProperty)

		VSL_CHECK_VALIDVALUE(dispid);

		VSL_SET_VALIDVALUE(pfHide);

		VSL_RETURN_VALIDVALUES();
	}
	struct DisplayChildPropertiesValidValues
	{
		/*[in]*/ DISPID dispid;
		/*[out,retval]*/ BOOL* pfDisplay;
		HRESULT retValue;
	};

	STDMETHOD(DisplayChildProperties)(
		/*[in]*/ DISPID dispid,
		/*[out,retval]*/ BOOL* pfDisplay)
	{
		VSL_DEFINE_MOCK_METHOD(DisplayChildProperties)

		VSL_CHECK_VALIDVALUE(dispid);

		VSL_SET_VALIDVALUE(pfDisplay);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLocalizedPropertyInfoValidValues
	{
		/*[in]*/ DISPID dispid;
		/*[in]*/ LCID localeID;
		/*[out]*/ BSTR* pbstrLocalizedName;
		/*[out]*/ BSTR* pbstrLocalizeDescription;
		HRESULT retValue;
	};

	STDMETHOD(GetLocalizedPropertyInfo)(
		/*[in]*/ DISPID dispid,
		/*[in]*/ LCID localeID,
		/*[out]*/ BSTR* pbstrLocalizedName,
		/*[out]*/ BSTR* pbstrLocalizeDescription)
	{
		VSL_DEFINE_MOCK_METHOD(GetLocalizedPropertyInfo)

		VSL_CHECK_VALIDVALUE(dispid);

		VSL_CHECK_VALIDVALUE(localeID);

		VSL_SET_VALIDVALUE_BSTR(pbstrLocalizedName);

		VSL_SET_VALIDVALUE_BSTR(pbstrLocalizeDescription);

		VSL_RETURN_VALIDVALUES();
	}
	struct HasDefaultValueValidValues
	{
		/*[in]*/ DISPID dispid;
		/*[out,retval]*/ BOOL* fDefault;
		HRESULT retValue;
	};

	STDMETHOD(HasDefaultValue)(
		/*[in]*/ DISPID dispid,
		/*[out,retval]*/ BOOL* fDefault)
	{
		VSL_DEFINE_MOCK_METHOD(HasDefaultValue)

		VSL_CHECK_VALIDVALUE(dispid);

		VSL_SET_VALIDVALUE(fDefault);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsPropertyReadOnlyValidValues
	{
		/*[in]*/ DISPID dispid;
		/*[out,retval]*/ BOOL* fReadOnly;
		HRESULT retValue;
	};

	STDMETHOD(IsPropertyReadOnly)(
		/*[in]*/ DISPID dispid,
		/*[out,retval]*/ BOOL* fReadOnly)
	{
		VSL_DEFINE_MOCK_METHOD(IsPropertyReadOnly)

		VSL_CHECK_VALIDVALUE(dispid);

		VSL_SET_VALIDVALUE(fReadOnly);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetClassNameValidValues
	{
		/*[out,retval]*/ BSTR* pbstrClassName;
		HRESULT retValue;
	};

	STDMETHOD(GetClassName)(
		/*[out,retval]*/ BSTR* pbstrClassName)
	{
		VSL_DEFINE_MOCK_METHOD(GetClassName)

		VSL_SET_VALIDVALUE_BSTR(pbstrClassName);

		VSL_RETURN_VALIDVALUES();
	}
	struct CanResetPropertyValueValidValues
	{
		/*[in]*/ DISPID dispid;
		/*[out,retval]*/ BOOL* pfCanReset;
		HRESULT retValue;
	};

	STDMETHOD(CanResetPropertyValue)(
		/*[in]*/ DISPID dispid,
		/*[out,retval]*/ BOOL* pfCanReset)
	{
		VSL_DEFINE_MOCK_METHOD(CanResetPropertyValue)

		VSL_CHECK_VALIDVALUE(dispid);

		VSL_SET_VALIDVALUE(pfCanReset);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetPropertyValueValidValues
	{
		/*[in]*/ DISPID dispid;
		HRESULT retValue;
	};

	STDMETHOD(ResetPropertyValue)(
		/*[in]*/ DISPID dispid)
	{
		VSL_DEFINE_MOCK_METHOD(ResetPropertyValue)

		VSL_CHECK_VALIDVALUE(dispid);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPERPROPERTYBROWSING_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsParentProject.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPARENTPROJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPARENTPROJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsParentProjectNotImpl :
	public IVsParentProject
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsParentProjectNotImpl)

public:

	typedef IVsParentProject Interface;

	STDMETHOD(OpenChildren)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CloseChildren)()VSL_STDMETHOD_NOTIMPL
};

class IVsParentProjectMockImpl :
	public IVsParentProject,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsParentProjectMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsParentProjectMockImpl)

	typedef IVsParentProject Interface;
	struct OpenChildrenValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OpenChildren)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OpenChildren)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloseChildrenValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CloseChildren)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CloseChildren)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPARENTPROJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsPersistDocData2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPERSISTDOCDATA2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPERSISTDOCDATA2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsPersistDocData2NotImpl :
	public IVsPersistDocData2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPersistDocData2NotImpl)

public:

	typedef IVsPersistDocData2 Interface;

	STDMETHOD(SetDocDataDirty)(
		/*[in]*/ BOOL /*fDirty*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsDocDataReadOnly)(
		/*[out]*/ BOOL* /*pfReadOnly*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetDocDataReadOnly)(
		/*[in]*/ BOOL /*fReadOnly*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetGuidEditorType)(
		/*[out]*/ CLSID* /*pClassID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsDocDataDirty)(
		/*[out]*/ BOOL* /*pfDirty*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetUntitledDocPath)(
		/*[in]*/ LPCOLESTR /*pszDocDataPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LoadDocData)(
		/*[in]*/ LPCOLESTR /*pszMkDocument*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SaveDocData)(
		/*[in]*/ VSSAVEFLAGS /*dwSave*/,
		/*[out]*/ BSTR* /*pbstrMkDocumentNew*/,
		/*[out]*/ BOOL* /*pfSaveCanceled*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Close)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnRegisterDocData)(
		/*[in]*/ VSCOOKIE /*docCookie*/,
		/*[in]*/ IVsHierarchy* /*pHierNew*/,
		/*[in]*/ VSITEMID /*itemidNew*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RenameDocData)(
		/*[in]*/ VSRDTATTRIB /*grfAttribs*/,
		/*[in]*/ IVsHierarchy* /*pHierNew*/,
		/*[in]*/ VSITEMID /*itemidNew*/,
		/*[in]*/ LPCOLESTR /*pszMkDocumentNew*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsDocDataReloadable)(
		/*[out]*/ BOOL* /*pfReloadable*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReloadDocData)(
		/*[in]*/ VSRELOADDOCDATA /*grfFlags*/)VSL_STDMETHOD_NOTIMPL
};

class IVsPersistDocData2MockImpl :
	public IVsPersistDocData2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPersistDocData2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsPersistDocData2MockImpl)

	typedef IVsPersistDocData2 Interface;
	struct SetDocDataDirtyValidValues
	{
		/*[in]*/ BOOL fDirty;
		HRESULT retValue;
	};

	STDMETHOD(SetDocDataDirty)(
		/*[in]*/ BOOL fDirty)
	{
		VSL_DEFINE_MOCK_METHOD(SetDocDataDirty)

		VSL_CHECK_VALIDVALUE(fDirty);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsDocDataReadOnlyValidValues
	{
		/*[out]*/ BOOL* pfReadOnly;
		HRESULT retValue;
	};

	STDMETHOD(IsDocDataReadOnly)(
		/*[out]*/ BOOL* pfReadOnly)
	{
		VSL_DEFINE_MOCK_METHOD(IsDocDataReadOnly)

		VSL_SET_VALIDVALUE(pfReadOnly);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetDocDataReadOnlyValidValues
	{
		/*[in]*/ BOOL fReadOnly;
		HRESULT retValue;
	};

	STDMETHOD(SetDocDataReadOnly)(
		/*[in]*/ BOOL fReadOnly)
	{
		VSL_DEFINE_MOCK_METHOD(SetDocDataReadOnly)

		VSL_CHECK_VALIDVALUE(fReadOnly);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetGuidEditorTypeValidValues
	{
		/*[out]*/ CLSID* pClassID;
		HRESULT retValue;
	};

	STDMETHOD(GetGuidEditorType)(
		/*[out]*/ CLSID* pClassID)
	{
		VSL_DEFINE_MOCK_METHOD(GetGuidEditorType)

		VSL_SET_VALIDVALUE(pClassID);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsDocDataDirtyValidValues
	{
		/*[out]*/ BOOL* pfDirty;
		HRESULT retValue;
	};

	STDMETHOD(IsDocDataDirty)(
		/*[out]*/ BOOL* pfDirty)
	{
		VSL_DEFINE_MOCK_METHOD(IsDocDataDirty)

		VSL_SET_VALIDVALUE(pfDirty);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetUntitledDocPathValidValues
	{
		/*[in]*/ LPCOLESTR pszDocDataPath;
		HRESULT retValue;
	};

	STDMETHOD(SetUntitledDocPath)(
		/*[in]*/ LPCOLESTR pszDocDataPath)
	{
		VSL_DEFINE_MOCK_METHOD(SetUntitledDocPath)

		VSL_CHECK_VALIDVALUE_STRINGW(pszDocDataPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadDocDataValidValues
	{
		/*[in]*/ LPCOLESTR pszMkDocument;
		HRESULT retValue;
	};

	STDMETHOD(LoadDocData)(
		/*[in]*/ LPCOLESTR pszMkDocument)
	{
		VSL_DEFINE_MOCK_METHOD(LoadDocData)

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveDocDataValidValues
	{
		/*[in]*/ VSSAVEFLAGS dwSave;
		/*[out]*/ BSTR* pbstrMkDocumentNew;
		/*[out]*/ BOOL* pfSaveCanceled;
		HRESULT retValue;
	};

	STDMETHOD(SaveDocData)(
		/*[in]*/ VSSAVEFLAGS dwSave,
		/*[out]*/ BSTR* pbstrMkDocumentNew,
		/*[out]*/ BOOL* pfSaveCanceled)
	{
		VSL_DEFINE_MOCK_METHOD(SaveDocData)

		VSL_CHECK_VALIDVALUE(dwSave);

		VSL_SET_VALIDVALUE_BSTR(pbstrMkDocumentNew);

		VSL_SET_VALIDVALUE(pfSaveCanceled);

		VSL_RETURN_VALIDVALUES();
	}
	struct CloseValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Close)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Close)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnRegisterDocDataValidValues
	{
		/*[in]*/ VSCOOKIE docCookie;
		/*[in]*/ IVsHierarchy* pHierNew;
		/*[in]*/ VSITEMID itemidNew;
		HRESULT retValue;
	};

	STDMETHOD(OnRegisterDocData)(
		/*[in]*/ VSCOOKIE docCookie,
		/*[in]*/ IVsHierarchy* pHierNew,
		/*[in]*/ VSITEMID itemidNew)
	{
		VSL_DEFINE_MOCK_METHOD(OnRegisterDocData)

		VSL_CHECK_VALIDVALUE(docCookie);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierNew);

		VSL_CHECK_VALIDVALUE(itemidNew);

		VSL_RETURN_VALIDVALUES();
	}
	struct RenameDocDataValidValues
	{
		/*[in]*/ VSRDTATTRIB grfAttribs;
		/*[in]*/ IVsHierarchy* pHierNew;
		/*[in]*/ VSITEMID itemidNew;
		/*[in]*/ LPCOLESTR pszMkDocumentNew;
		HRESULT retValue;
	};

	STDMETHOD(RenameDocData)(
		/*[in]*/ VSRDTATTRIB grfAttribs,
		/*[in]*/ IVsHierarchy* pHierNew,
		/*[in]*/ VSITEMID itemidNew,
		/*[in]*/ LPCOLESTR pszMkDocumentNew)
	{
		VSL_DEFINE_MOCK_METHOD(RenameDocData)

		VSL_CHECK_VALIDVALUE(grfAttribs);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierNew);

		VSL_CHECK_VALIDVALUE(itemidNew);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocumentNew);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsDocDataReloadableValidValues
	{
		/*[out]*/ BOOL* pfReloadable;
		HRESULT retValue;
	};

	STDMETHOD(IsDocDataReloadable)(
		/*[out]*/ BOOL* pfReloadable)
	{
		VSL_DEFINE_MOCK_METHOD(IsDocDataReloadable)

		VSL_SET_VALIDVALUE(pfReloadable);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReloadDocDataValidValues
	{
		/*[in]*/ VSRELOADDOCDATA grfFlags;
		HRESULT retValue;
	};

	STDMETHOD(ReloadDocData)(
		/*[in]*/ VSRELOADDOCDATA grfFlags)
	{
		VSL_DEFINE_MOCK_METHOD(ReloadDocData)

		VSL_CHECK_VALIDVALUE(grfFlags);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPERSISTDOCDATA2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsPathVariableResolver.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPATHVARIABLERESOLVER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPATHVARIABLERESOLVER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsPathVariableResolverNotImpl :
	public IVsPathVariableResolver
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPathVariableResolverNotImpl)

public:

	typedef IVsPathVariableResolver Interface;

	STDMETHOD(ResolvePath)(
		/*[in]*/ LPCOLESTR /*strEncodedPath*/,
		/*[in]*/ VSPROFILEPATHRESOLVERFLAGS /*dwFlags*/,
		/*[out]*/ BSTR* /*pbstrPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EncodePath)(
		/*[in]*/ LPCOLESTR /*strPath*/,
		/*[in]*/ VSPROFILEPATHRESOLVERFLAGS /*dwFlags*/,
		/*[out]*/ BSTR* /*pbstrEncodedPath*/)VSL_STDMETHOD_NOTIMPL
};

class IVsPathVariableResolverMockImpl :
	public IVsPathVariableResolver,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPathVariableResolverMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsPathVariableResolverMockImpl)

	typedef IVsPathVariableResolver Interface;
	struct ResolvePathValidValues
	{
		/*[in]*/ LPCOLESTR strEncodedPath;
		/*[in]*/ VSPROFILEPATHRESOLVERFLAGS dwFlags;
		/*[out]*/ BSTR* pbstrPath;
		HRESULT retValue;
	};

	STDMETHOD(ResolvePath)(
		/*[in]*/ LPCOLESTR strEncodedPath,
		/*[in]*/ VSPROFILEPATHRESOLVERFLAGS dwFlags,
		/*[out]*/ BSTR* pbstrPath)
	{
		VSL_DEFINE_MOCK_METHOD(ResolvePath)

		VSL_CHECK_VALIDVALUE_STRINGW(strEncodedPath);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_SET_VALIDVALUE_BSTR(pbstrPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct EncodePathValidValues
	{
		/*[in]*/ LPCOLESTR strPath;
		/*[in]*/ VSPROFILEPATHRESOLVERFLAGS dwFlags;
		/*[out]*/ BSTR* pbstrEncodedPath;
		HRESULT retValue;
	};

	STDMETHOD(EncodePath)(
		/*[in]*/ LPCOLESTR strPath,
		/*[in]*/ VSPROFILEPATHRESOLVERFLAGS dwFlags,
		/*[out]*/ BSTR* pbstrEncodedPath)
	{
		VSL_DEFINE_MOCK_METHOD(EncodePath)

		VSL_CHECK_VALIDVALUE_STRINGW(strPath);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_SET_VALIDVALUE_BSTR(pbstrEncodedPath);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPATHVARIABLERESOLVER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsParseCommandLine.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPARSECOMMANDLINE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPARSECOMMANDLINE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsParseCommandLineNotImpl :
	public IVsParseCommandLine
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsParseCommandLineNotImpl)

public:

	typedef IVsParseCommandLine Interface;

	STDMETHOD(ParseCommandLine)(
		/*[in,ref]*/ LPCOLESTR /*szCommandLine*/,
		/*[in]*/ int /*iMaxParams*/,
		/*[in]*/ int /*iCursorPos*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ParseCommandTail)(
		/*[in,ref]*/ LPCOLESTR /*szCommandTail*/,
		/*[in]*/ int /*iMaxParams*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(HasParams)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(HasSwitches)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(HasSwitchValues)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetParamCount)(
		/*[out,retval]*/ int* /*piParamCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSwitchCount)(
		/*[out,retval]*/ int* /*piSwitchCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSwitchValueCount)(
		/*[out,retval]*/ int* /*piSwitchValueCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SwitchHasValue)(
		/*[in]*/ int /*iIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCommand)(
		/*[out,retval]*/ BSTR* /*pbstrCommand*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetParam)(
		/*[in]*/ int /*iIndex*/,
		/*[out,retval]*/ BSTR* /*pbstrParam*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetRawSwitch)(
		/*[in]*/ int /*iIndex*/,
		/*[out,retval]*/ BSTR* /*pbstrRawSwitch*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetRawSwitchValue)(
		/*[in]*/ int /*iIndex*/,
		/*[out,retval]*/ BSTR* /*pbstrRawSwitchValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCommandTail)(
		/*[out,retval]*/ BSTR* /*pbstrCommandTail*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetACParam)(
		/*[out]*/ int* /*piACIndex*/,
		/*[out]*/ int* /*piACStart*/,
		/*[out]*/ int* /*pcchACLength*/,
		/*[out,retval]*/ BSTR* /*pbstrACParam*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RejectAllSwitches)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ValidateParamCount)(
		/*[in]*/ int /*cParamsMin*/,
		/*[in]*/ int /*cParamsMax*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EvaluateSwitches)(
		/*[in,ref]*/ LPCOLESTR /*szSwitchDefs*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsSwitchPresent)(
		/*[in]*/ int /*iSwitchIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSwitchValue)(
		/*[in]*/ int /*iSwitchIndex*/,
		/*[out,retval]*/ BSTR* /*pbstrValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QuoteParam)(
		/*[in]*/ LPCOLESTR /*szParam*/,
		/*[out,retval]*/ BSTR* /*pbstrQuotedParam*/)VSL_STDMETHOD_NOTIMPL
};

class IVsParseCommandLineMockImpl :
	public IVsParseCommandLine,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsParseCommandLineMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsParseCommandLineMockImpl)

	typedef IVsParseCommandLine Interface;
	struct ParseCommandLineValidValues
	{
		/*[in,ref]*/ LPCOLESTR szCommandLine;
		/*[in]*/ int iMaxParams;
		/*[in]*/ int iCursorPos;
		HRESULT retValue;
	};

	STDMETHOD(ParseCommandLine)(
		/*[in,ref]*/ LPCOLESTR szCommandLine,
		/*[in]*/ int iMaxParams,
		/*[in]*/ int iCursorPos)
	{
		VSL_DEFINE_MOCK_METHOD(ParseCommandLine)

		VSL_CHECK_VALIDVALUE_STRINGW(szCommandLine);

		VSL_CHECK_VALIDVALUE(iMaxParams);

		VSL_CHECK_VALIDVALUE(iCursorPos);

		VSL_RETURN_VALIDVALUES();
	}
	struct ParseCommandTailValidValues
	{
		/*[in,ref]*/ LPCOLESTR szCommandTail;
		/*[in]*/ int iMaxParams;
		HRESULT retValue;
	};

	STDMETHOD(ParseCommandTail)(
		/*[in,ref]*/ LPCOLESTR szCommandTail,
		/*[in]*/ int iMaxParams)
	{
		VSL_DEFINE_MOCK_METHOD(ParseCommandTail)

		VSL_CHECK_VALIDVALUE_STRINGW(szCommandTail);

		VSL_CHECK_VALIDVALUE(iMaxParams);

		VSL_RETURN_VALIDVALUES();
	}
	struct HasParamsValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(HasParams)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(HasParams)

		VSL_RETURN_VALIDVALUES();
	}
	struct HasSwitchesValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(HasSwitches)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(HasSwitches)

		VSL_RETURN_VALIDVALUES();
	}
	struct HasSwitchValuesValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(HasSwitchValues)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(HasSwitchValues)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetParamCountValidValues
	{
		/*[out,retval]*/ int* piParamCount;
		HRESULT retValue;
	};

	STDMETHOD(GetParamCount)(
		/*[out,retval]*/ int* piParamCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetParamCount)

		VSL_SET_VALIDVALUE(piParamCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSwitchCountValidValues
	{
		/*[out,retval]*/ int* piSwitchCount;
		HRESULT retValue;
	};

	STDMETHOD(GetSwitchCount)(
		/*[out,retval]*/ int* piSwitchCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetSwitchCount)

		VSL_SET_VALIDVALUE(piSwitchCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSwitchValueCountValidValues
	{
		/*[out,retval]*/ int* piSwitchValueCount;
		HRESULT retValue;
	};

	STDMETHOD(GetSwitchValueCount)(
		/*[out,retval]*/ int* piSwitchValueCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetSwitchValueCount)

		VSL_SET_VALIDVALUE(piSwitchValueCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct SwitchHasValueValidValues
	{
		/*[in]*/ int iIndex;
		HRESULT retValue;
	};

	STDMETHOD(SwitchHasValue)(
		/*[in]*/ int iIndex)
	{
		VSL_DEFINE_MOCK_METHOD(SwitchHasValue)

		VSL_CHECK_VALIDVALUE(iIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCommandValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCommand;
		HRESULT retValue;
	};

	STDMETHOD(GetCommand)(
		/*[out,retval]*/ BSTR* pbstrCommand)
	{
		VSL_DEFINE_MOCK_METHOD(GetCommand)

		VSL_SET_VALIDVALUE_BSTR(pbstrCommand);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetParamValidValues
	{
		/*[in]*/ int iIndex;
		/*[out,retval]*/ BSTR* pbstrParam;
		HRESULT retValue;
	};

	STDMETHOD(GetParam)(
		/*[in]*/ int iIndex,
		/*[out,retval]*/ BSTR* pbstrParam)
	{
		VSL_DEFINE_MOCK_METHOD(GetParam)

		VSL_CHECK_VALIDVALUE(iIndex);

		VSL_SET_VALIDVALUE_BSTR(pbstrParam);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetRawSwitchValidValues
	{
		/*[in]*/ int iIndex;
		/*[out,retval]*/ BSTR* pbstrRawSwitch;
		HRESULT retValue;
	};

	STDMETHOD(GetRawSwitch)(
		/*[in]*/ int iIndex,
		/*[out,retval]*/ BSTR* pbstrRawSwitch)
	{
		VSL_DEFINE_MOCK_METHOD(GetRawSwitch)

		VSL_CHECK_VALIDVALUE(iIndex);

		VSL_SET_VALIDVALUE_BSTR(pbstrRawSwitch);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetRawSwitchValueValidValues
	{
		/*[in]*/ int iIndex;
		/*[out,retval]*/ BSTR* pbstrRawSwitchValue;
		HRESULT retValue;
	};

	STDMETHOD(GetRawSwitchValue)(
		/*[in]*/ int iIndex,
		/*[out,retval]*/ BSTR* pbstrRawSwitchValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetRawSwitchValue)

		VSL_CHECK_VALIDVALUE(iIndex);

		VSL_SET_VALIDVALUE_BSTR(pbstrRawSwitchValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCommandTailValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCommandTail;
		HRESULT retValue;
	};

	STDMETHOD(GetCommandTail)(
		/*[out,retval]*/ BSTR* pbstrCommandTail)
	{
		VSL_DEFINE_MOCK_METHOD(GetCommandTail)

		VSL_SET_VALIDVALUE_BSTR(pbstrCommandTail);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetACParamValidValues
	{
		/*[out]*/ int* piACIndex;
		/*[out]*/ int* piACStart;
		/*[out]*/ int* pcchACLength;
		/*[out,retval]*/ BSTR* pbstrACParam;
		HRESULT retValue;
	};

	STDMETHOD(GetACParam)(
		/*[out]*/ int* piACIndex,
		/*[out]*/ int* piACStart,
		/*[out]*/ int* pcchACLength,
		/*[out,retval]*/ BSTR* pbstrACParam)
	{
		VSL_DEFINE_MOCK_METHOD(GetACParam)

		VSL_SET_VALIDVALUE(piACIndex);

		VSL_SET_VALIDVALUE(piACStart);

		VSL_SET_VALIDVALUE(pcchACLength);

		VSL_SET_VALIDVALUE_BSTR(pbstrACParam);

		VSL_RETURN_VALIDVALUES();
	}
	struct RejectAllSwitchesValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(RejectAllSwitches)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(RejectAllSwitches)

		VSL_RETURN_VALIDVALUES();
	}
	struct ValidateParamCountValidValues
	{
		/*[in]*/ int cParamsMin;
		/*[in]*/ int cParamsMax;
		HRESULT retValue;
	};

	STDMETHOD(ValidateParamCount)(
		/*[in]*/ int cParamsMin,
		/*[in]*/ int cParamsMax)
	{
		VSL_DEFINE_MOCK_METHOD(ValidateParamCount)

		VSL_CHECK_VALIDVALUE(cParamsMin);

		VSL_CHECK_VALIDVALUE(cParamsMax);

		VSL_RETURN_VALIDVALUES();
	}
	struct EvaluateSwitchesValidValues
	{
		/*[in,ref]*/ LPCOLESTR szSwitchDefs;
		HRESULT retValue;
	};

	STDMETHOD(EvaluateSwitches)(
		/*[in,ref]*/ LPCOLESTR szSwitchDefs)
	{
		VSL_DEFINE_MOCK_METHOD(EvaluateSwitches)

		VSL_CHECK_VALIDVALUE_STRINGW(szSwitchDefs);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsSwitchPresentValidValues
	{
		/*[in]*/ int iSwitchIndex;
		HRESULT retValue;
	};

	STDMETHOD(IsSwitchPresent)(
		/*[in]*/ int iSwitchIndex)
	{
		VSL_DEFINE_MOCK_METHOD(IsSwitchPresent)

		VSL_CHECK_VALIDVALUE(iSwitchIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSwitchValueValidValues
	{
		/*[in]*/ int iSwitchIndex;
		/*[out,retval]*/ BSTR* pbstrValue;
		HRESULT retValue;
	};

	STDMETHOD(GetSwitchValue)(
		/*[in]*/ int iSwitchIndex,
		/*[out,retval]*/ BSTR* pbstrValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetSwitchValue)

		VSL_CHECK_VALIDVALUE(iSwitchIndex);

		VSL_SET_VALIDVALUE_BSTR(pbstrValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct QuoteParamValidValues
	{
		/*[in]*/ LPCOLESTR szParam;
		/*[out,retval]*/ BSTR* pbstrQuotedParam;
		HRESULT retValue;
	};

	STDMETHOD(QuoteParam)(
		/*[in]*/ LPCOLESTR szParam,
		/*[out,retval]*/ BSTR* pbstrQuotedParam)
	{
		VSL_DEFINE_MOCK_METHOD(QuoteParam)

		VSL_CHECK_VALIDVALUE_STRINGW(szParam);

		VSL_SET_VALIDVALUE_BSTR(pbstrQuotedParam);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPARSECOMMANDLINE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsPersistDocData3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPERSISTDOCDATA3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPERSISTDOCDATA3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsPersistDocData3NotImpl :
	public IVsPersistDocData3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPersistDocData3NotImpl)

public:

	typedef IVsPersistDocData3 Interface;

	STDMETHOD(HandsOffDocDataStorage)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(HandsOnDocDataStorage)()VSL_STDMETHOD_NOTIMPL
};

class IVsPersistDocData3MockImpl :
	public IVsPersistDocData3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPersistDocData3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsPersistDocData3MockImpl)

	typedef IVsPersistDocData3 Interface;
	struct HandsOffDocDataStorageValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(HandsOffDocDataStorage)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(HandsOffDocDataStorage)

		VSL_RETURN_VALIDVALUES();
	}
	struct HandsOnDocDataStorageValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(HandsOnDocDataStorage)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(HandsOnDocDataStorage)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPERSISTDOCDATA3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsPersistHierarchyItem2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPERSISTHIERARCHYITEM2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPERSISTHIERARCHYITEM2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsPersistHierarchyItem2NotImpl :
	public IVsPersistHierarchyItem2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPersistHierarchyItem2NotImpl)

public:

	typedef IVsPersistHierarchyItem2 Interface;

	STDMETHOD(IsItemReloadable)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[out,retval]*/ BOOL* /*pfReloadable*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReloadItem)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ DWORD /*dwReserved*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IgnoreItemFileChanges)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ BOOL /*fIgnore*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsItemDirty)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ IUnknown* /*punkDocData*/,
		/*[out]*/ BOOL* /*pfDirty*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SaveItem)(
		/*[in]*/ VSSAVEFLAGS /*dwSave*/,
		/*[in]*/ LPCOLESTR /*pszSilentSaveAsName*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ IUnknown* /*punkDocData*/,
		/*[out]*/ BOOL* /*pfCanceled*/)VSL_STDMETHOD_NOTIMPL
};

class IVsPersistHierarchyItem2MockImpl :
	public IVsPersistHierarchyItem2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPersistHierarchyItem2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsPersistHierarchyItem2MockImpl)

	typedef IVsPersistHierarchyItem2 Interface;
	struct IsItemReloadableValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[out,retval]*/ BOOL* pfReloadable;
		HRESULT retValue;
	};

	STDMETHOD(IsItemReloadable)(
		/*[in]*/ VSITEMID itemid,
		/*[out,retval]*/ BOOL* pfReloadable)
	{
		VSL_DEFINE_MOCK_METHOD(IsItemReloadable)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_SET_VALIDVALUE(pfReloadable);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReloadItemValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ DWORD dwReserved;
		HRESULT retValue;
	};

	STDMETHOD(ReloadItem)(
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ DWORD dwReserved)
	{
		VSL_DEFINE_MOCK_METHOD(ReloadItem)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_RETURN_VALIDVALUES();
	}
	struct IgnoreItemFileChangesValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ BOOL fIgnore;
		HRESULT retValue;
	};

	STDMETHOD(IgnoreItemFileChanges)(
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ BOOL fIgnore)
	{
		VSL_DEFINE_MOCK_METHOD(IgnoreItemFileChanges)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE(fIgnore);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsItemDirtyValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ IUnknown* punkDocData;
		/*[out]*/ BOOL* pfDirty;
		HRESULT retValue;
	};

	STDMETHOD(IsItemDirty)(
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ IUnknown* punkDocData,
		/*[out]*/ BOOL* pfDirty)
	{
		VSL_DEFINE_MOCK_METHOD(IsItemDirty)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkDocData);

		VSL_SET_VALIDVALUE(pfDirty);

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveItemValidValues
	{
		/*[in]*/ VSSAVEFLAGS dwSave;
		/*[in]*/ LPCOLESTR pszSilentSaveAsName;
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ IUnknown* punkDocData;
		/*[out]*/ BOOL* pfCanceled;
		HRESULT retValue;
	};

	STDMETHOD(SaveItem)(
		/*[in]*/ VSSAVEFLAGS dwSave,
		/*[in]*/ LPCOLESTR pszSilentSaveAsName,
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ IUnknown* punkDocData,
		/*[out]*/ BOOL* pfCanceled)
	{
		VSL_DEFINE_MOCK_METHOD(SaveItem)

		VSL_CHECK_VALIDVALUE(dwSave);

		VSL_CHECK_VALIDVALUE_STRINGW(pszSilentSaveAsName);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkDocData);

		VSL_SET_VALIDVALUE(pfCanceled);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPERSISTHIERARCHYITEM2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsPersistSolutionOpts.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPERSISTSOLUTIONOPTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPERSISTSOLUTIONOPTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsPersistSolutionOptsNotImpl :
	public IVsPersistSolutionOpts
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPersistSolutionOptsNotImpl)

public:

	typedef IVsPersistSolutionOpts Interface;

	STDMETHOD(SaveUserOptions)(
		/*[in]*/ IVsSolutionPersistence* /*pPersistence*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LoadUserOptions)(
		/*[in]*/ IVsSolutionPersistence* /*pPersistence*/,
		/*[in]*/ VSLOADUSEROPTS /*grfLoadOpts*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(WriteUserOptions)(
		/*[in]*/ IStream* /*pOptionsStream*/,
		/*[in]*/ LPCOLESTR /*pszKey*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReadUserOptions)(
		/*[in]*/ IStream* /*pOptionsStream*/,
		/*[in]*/ LPCOLESTR /*pszKey*/)VSL_STDMETHOD_NOTIMPL
};

class IVsPersistSolutionOptsMockImpl :
	public IVsPersistSolutionOpts,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPersistSolutionOptsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsPersistSolutionOptsMockImpl)

	typedef IVsPersistSolutionOpts Interface;
	struct SaveUserOptionsValidValues
	{
		/*[in]*/ IVsSolutionPersistence* pPersistence;
		HRESULT retValue;
	};

	STDMETHOD(SaveUserOptions)(
		/*[in]*/ IVsSolutionPersistence* pPersistence)
	{
		VSL_DEFINE_MOCK_METHOD(SaveUserOptions)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPersistence);

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadUserOptionsValidValues
	{
		/*[in]*/ IVsSolutionPersistence* pPersistence;
		/*[in]*/ VSLOADUSEROPTS grfLoadOpts;
		HRESULT retValue;
	};

	STDMETHOD(LoadUserOptions)(
		/*[in]*/ IVsSolutionPersistence* pPersistence,
		/*[in]*/ VSLOADUSEROPTS grfLoadOpts)
	{
		VSL_DEFINE_MOCK_METHOD(LoadUserOptions)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPersistence);

		VSL_CHECK_VALIDVALUE(grfLoadOpts);

		VSL_RETURN_VALIDVALUES();
	}
	struct WriteUserOptionsValidValues
	{
		/*[in]*/ IStream* pOptionsStream;
		/*[in]*/ LPCOLESTR pszKey;
		HRESULT retValue;
	};

	STDMETHOD(WriteUserOptions)(
		/*[in]*/ IStream* pOptionsStream,
		/*[in]*/ LPCOLESTR pszKey)
	{
		VSL_DEFINE_MOCK_METHOD(WriteUserOptions)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pOptionsStream);

		VSL_CHECK_VALIDVALUE_STRINGW(pszKey);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReadUserOptionsValidValues
	{
		/*[in]*/ IStream* pOptionsStream;
		/*[in]*/ LPCOLESTR pszKey;
		HRESULT retValue;
	};

	STDMETHOD(ReadUserOptions)(
		/*[in]*/ IStream* pOptionsStream,
		/*[in]*/ LPCOLESTR pszKey)
	{
		VSL_DEFINE_MOCK_METHOD(ReadUserOptions)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pOptionsStream);

		VSL_CHECK_VALIDVALUE_STRINGW(pszKey);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPERSISTSOLUTIONOPTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsPersistHierarchyItem.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPERSISTHIERARCHYITEM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPERSISTHIERARCHYITEM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsPersistHierarchyItemNotImpl :
	public IVsPersistHierarchyItem
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPersistHierarchyItemNotImpl)

public:

	typedef IVsPersistHierarchyItem Interface;

	STDMETHOD(IsItemDirty)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ IUnknown* /*punkDocData*/,
		/*[out]*/ BOOL* /*pfDirty*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SaveItem)(
		/*[in]*/ VSSAVEFLAGS /*dwSave*/,
		/*[in]*/ LPCOLESTR /*pszSilentSaveAsName*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ IUnknown* /*punkDocData*/,
		/*[out]*/ BOOL* /*pfCanceled*/)VSL_STDMETHOD_NOTIMPL
};

class IVsPersistHierarchyItemMockImpl :
	public IVsPersistHierarchyItem,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPersistHierarchyItemMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsPersistHierarchyItemMockImpl)

	typedef IVsPersistHierarchyItem Interface;
	struct IsItemDirtyValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ IUnknown* punkDocData;
		/*[out]*/ BOOL* pfDirty;
		HRESULT retValue;
	};

	STDMETHOD(IsItemDirty)(
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ IUnknown* punkDocData,
		/*[out]*/ BOOL* pfDirty)
	{
		VSL_DEFINE_MOCK_METHOD(IsItemDirty)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkDocData);

		VSL_SET_VALIDVALUE(pfDirty);

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveItemValidValues
	{
		/*[in]*/ VSSAVEFLAGS dwSave;
		/*[in]*/ LPCOLESTR pszSilentSaveAsName;
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ IUnknown* punkDocData;
		/*[out]*/ BOOL* pfCanceled;
		HRESULT retValue;
	};

	STDMETHOD(SaveItem)(
		/*[in]*/ VSSAVEFLAGS dwSave,
		/*[in]*/ LPCOLESTR pszSilentSaveAsName,
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ IUnknown* punkDocData,
		/*[out]*/ BOOL* pfCanceled)
	{
		VSL_DEFINE_MOCK_METHOD(SaveItem)

		VSL_CHECK_VALIDVALUE(dwSave);

		VSL_CHECK_VALIDVALUE_STRINGW(pszSilentSaveAsName);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkDocData);

		VSL_SET_VALIDVALUE(pfCanceled);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPERSISTHIERARCHYITEM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsPersistentTextImage.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPERSISTENTTEXTIMAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPERSISTENTTEXTIMAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsPersistentTextImageNotImpl :
	public IVsPersistentTextImage
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPersistentTextImageNotImpl)

public:

	typedef IVsPersistentTextImage Interface;

	virtual void* STDMETHODCALLTYPE Image_Alloc(
		/*[in]*/ int /*iSize*/){ return NULL; }

	virtual void* STDMETHODCALLTYPE Image_Realloc(
		/*[in,out]*/ void* /*p*/,
		/*[in]*/ int /*iSize*/){ return NULL; }

	virtual void STDMETHODCALLTYPE Image_Free(
		/*[in]*/ void* /*p*/){ return ; }

	virtual long STDMETHODCALLTYPE Image_GetLength(){ return long(); }

	STDMETHOD(Image_LoadText)(
		/*[in]*/ const WCHAR* /*pszText*/,
		/*[in]*/ INT /*iLength*/,
		/*[in]*/ DWORD /*dwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Image_OpenFullTextScan)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Image_FullTextRead)(
		/*[out]*/ const WCHAR** /*ppszText*/,
		/*[out]*/ long* /*piLength*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Image_CloseFullTextScan)()VSL_STDMETHOD_NOTIMPL
};

class IVsPersistentTextImageMockImpl :
	public IVsPersistentTextImage,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPersistentTextImageMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsPersistentTextImageMockImpl)

	typedef IVsPersistentTextImage Interface;
	struct Image_AllocValidValues
	{
		/*[in]*/ int iSize;
		void* retValue;
	};

	virtual void* _stdcall Image_Alloc(
		/*[in]*/ int iSize)
	{
		VSL_DEFINE_MOCK_METHOD(Image_Alloc)

		VSL_CHECK_VALIDVALUE(iSize);

		VSL_RETURN_VALIDVALUES();
	}
	struct Image_ReallocValidValues
	{
		/*[in,out]*/ void* p;
		/*[in]*/ int iSize;
		void* retValue;
		size_t p_size_in_bytes;
	};

	virtual void* _stdcall Image_Realloc(
		/*[in,out]*/ void* p,
		/*[in]*/ int iSize)
	{
		VSL_DEFINE_MOCK_METHOD(Image_Realloc)

		VSL_SET_VALIDVALUE_PVOID(p);

		VSL_CHECK_VALIDVALUE(iSize);

		VSL_RETURN_VALIDVALUES();
	}
	struct Image_FreeValidValues
	{
		/*[in]*/ void* p;
		size_t p_size_in_bytes;
	};

	virtual void _stdcall Image_Free(
		/*[in]*/ void* p)
	{
		VSL_DEFINE_MOCK_METHOD(Image_Free)

		VSL_CHECK_VALIDVALUE_PVOID(p);

	}
	struct Image_GetLengthValidValues
	{
		long retValue;
	};

	virtual long _stdcall Image_GetLength()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Image_GetLength)

		VSL_RETURN_VALIDVALUES();
	}
	struct Image_LoadTextValidValues
	{
		/*[in]*/ WCHAR* pszText;
		/*[in]*/ INT iLength;
		/*[in]*/ DWORD dwFlags;
		HRESULT retValue;
	};

	STDMETHOD(Image_LoadText)(
		/*[in]*/ const WCHAR* pszText,
		/*[in]*/ INT iLength,
		/*[in]*/ DWORD dwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(Image_LoadText)

		VSL_CHECK_VALIDVALUE_STRINGW(pszText);

		VSL_CHECK_VALIDVALUE(iLength);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct Image_OpenFullTextScanValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Image_OpenFullTextScan)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Image_OpenFullTextScan)

		VSL_RETURN_VALIDVALUES();
	}
	struct Image_FullTextReadValidValues
	{
		/*[out]*/ WCHAR** ppszText;
		/*[out]*/ long* piLength;
		HRESULT retValue;
	};

	STDMETHOD(Image_FullTextRead)(
		/*[out]*/ const WCHAR** ppszText,
		/*[out]*/ long* piLength)
	{
		VSL_DEFINE_MOCK_METHOD(Image_FullTextRead)

		VSL_SET_VALIDVALUE_CONST(ppszText, WCHAR**);

		VSL_SET_VALIDVALUE(piLength);

		VSL_RETURN_VALIDVALUES();
	}
	struct Image_CloseFullTextScanValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Image_CloseFullTextScan)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Image_CloseFullTextScan)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPERSISTENTTEXTIMAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsPersistSolutionProps.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPERSISTSOLUTIONPROPS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPERSISTSOLUTIONPROPS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsPersistSolutionPropsNotImpl :
	public IVsPersistSolutionProps
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPersistSolutionPropsNotImpl)

public:

	typedef IVsPersistSolutionProps Interface;

	STDMETHOD(QuerySaveSolutionProps)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[out]*/ VSQUERYSAVESLNPROPS* /*pqsspSave*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SaveSolutionProps)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ IVsSolutionPersistence* /*pPersistence*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(WriteSolutionProps)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ LPCOLESTR /*pszKey*/,
		/*[in]*/ IPropertyBag* /*pPropBag*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReadSolutionProps)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ LPCOLESTR /*pszProjectName*/,
		/*[in]*/ LPCOLESTR /*pszProjectMk*/,
		/*[in]*/ LPCOLESTR /*pszKey*/,
		/*[in]*/ BOOL /*fPreLoad*/,
		/*[in]*/ IPropertyBag* /*pPropBag*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnProjectLoadFailure)(
		/*[in]*/ IVsHierarchy* /*pStubHierarchy*/,
		/*[in]*/ LPCOLESTR /*pszProjectName*/,
		/*[in]*/ LPCOLESTR /*pszProjectMk*/,
		/*[in]*/ LPCOLESTR /*pszKey*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SaveUserOptions)(
		/*[in]*/ IVsSolutionPersistence* /*pPersistence*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LoadUserOptions)(
		/*[in]*/ IVsSolutionPersistence* /*pPersistence*/,
		/*[in]*/ VSLOADUSEROPTS /*grfLoadOpts*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(WriteUserOptions)(
		/*[in]*/ IStream* /*pOptionsStream*/,
		/*[in]*/ LPCOLESTR /*pszKey*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReadUserOptions)(
		/*[in]*/ IStream* /*pOptionsStream*/,
		/*[in]*/ LPCOLESTR /*pszKey*/)VSL_STDMETHOD_NOTIMPL
};

class IVsPersistSolutionPropsMockImpl :
	public IVsPersistSolutionProps,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPersistSolutionPropsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsPersistSolutionPropsMockImpl)

	typedef IVsPersistSolutionProps Interface;
	struct QuerySaveSolutionPropsValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[out]*/ VSQUERYSAVESLNPROPS* pqsspSave;
		HRESULT retValue;
	};

	STDMETHOD(QuerySaveSolutionProps)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[out]*/ VSQUERYSAVESLNPROPS* pqsspSave)
	{
		VSL_DEFINE_MOCK_METHOD(QuerySaveSolutionProps)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_SET_VALIDVALUE(pqsspSave);

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveSolutionPropsValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ IVsSolutionPersistence* pPersistence;
		HRESULT retValue;
	};

	STDMETHOD(SaveSolutionProps)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ IVsSolutionPersistence* pPersistence)
	{
		VSL_DEFINE_MOCK_METHOD(SaveSolutionProps)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPersistence);

		VSL_RETURN_VALIDVALUES();
	}
	struct WriteSolutionPropsValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ LPCOLESTR pszKey;
		/*[in]*/ IPropertyBag* pPropBag;
		HRESULT retValue;
	};

	STDMETHOD(WriteSolutionProps)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ LPCOLESTR pszKey,
		/*[in]*/ IPropertyBag* pPropBag)
	{
		VSL_DEFINE_MOCK_METHOD(WriteSolutionProps)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE_STRINGW(pszKey);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPropBag);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReadSolutionPropsValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ LPCOLESTR pszProjectName;
		/*[in]*/ LPCOLESTR pszProjectMk;
		/*[in]*/ LPCOLESTR pszKey;
		/*[in]*/ BOOL fPreLoad;
		/*[in]*/ IPropertyBag* pPropBag;
		HRESULT retValue;
	};

	STDMETHOD(ReadSolutionProps)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ LPCOLESTR pszProjectName,
		/*[in]*/ LPCOLESTR pszProjectMk,
		/*[in]*/ LPCOLESTR pszKey,
		/*[in]*/ BOOL fPreLoad,
		/*[in]*/ IPropertyBag* pPropBag)
	{
		VSL_DEFINE_MOCK_METHOD(ReadSolutionProps)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE_STRINGW(pszProjectName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszProjectMk);

		VSL_CHECK_VALIDVALUE_STRINGW(pszKey);

		VSL_CHECK_VALIDVALUE(fPreLoad);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPropBag);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnProjectLoadFailureValidValues
	{
		/*[in]*/ IVsHierarchy* pStubHierarchy;
		/*[in]*/ LPCOLESTR pszProjectName;
		/*[in]*/ LPCOLESTR pszProjectMk;
		/*[in]*/ LPCOLESTR pszKey;
		HRESULT retValue;
	};

	STDMETHOD(OnProjectLoadFailure)(
		/*[in]*/ IVsHierarchy* pStubHierarchy,
		/*[in]*/ LPCOLESTR pszProjectName,
		/*[in]*/ LPCOLESTR pszProjectMk,
		/*[in]*/ LPCOLESTR pszKey)
	{
		VSL_DEFINE_MOCK_METHOD(OnProjectLoadFailure)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStubHierarchy);

		VSL_CHECK_VALIDVALUE_STRINGW(pszProjectName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszProjectMk);

		VSL_CHECK_VALIDVALUE_STRINGW(pszKey);

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveUserOptionsValidValues
	{
		/*[in]*/ IVsSolutionPersistence* pPersistence;
		HRESULT retValue;
	};

	STDMETHOD(SaveUserOptions)(
		/*[in]*/ IVsSolutionPersistence* pPersistence)
	{
		VSL_DEFINE_MOCK_METHOD(SaveUserOptions)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPersistence);

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadUserOptionsValidValues
	{
		/*[in]*/ IVsSolutionPersistence* pPersistence;
		/*[in]*/ VSLOADUSEROPTS grfLoadOpts;
		HRESULT retValue;
	};

	STDMETHOD(LoadUserOptions)(
		/*[in]*/ IVsSolutionPersistence* pPersistence,
		/*[in]*/ VSLOADUSEROPTS grfLoadOpts)
	{
		VSL_DEFINE_MOCK_METHOD(LoadUserOptions)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPersistence);

		VSL_CHECK_VALIDVALUE(grfLoadOpts);

		VSL_RETURN_VALIDVALUES();
	}
	struct WriteUserOptionsValidValues
	{
		/*[in]*/ IStream* pOptionsStream;
		/*[in]*/ LPCOLESTR pszKey;
		HRESULT retValue;
	};

	STDMETHOD(WriteUserOptions)(
		/*[in]*/ IStream* pOptionsStream,
		/*[in]*/ LPCOLESTR pszKey)
	{
		VSL_DEFINE_MOCK_METHOD(WriteUserOptions)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pOptionsStream);

		VSL_CHECK_VALIDVALUE_STRINGW(pszKey);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReadUserOptionsValidValues
	{
		/*[in]*/ IStream* pOptionsStream;
		/*[in]*/ LPCOLESTR pszKey;
		HRESULT retValue;
	};

	STDMETHOD(ReadUserOptions)(
		/*[in]*/ IStream* pOptionsStream,
		/*[in]*/ LPCOLESTR pszKey)
	{
		VSL_DEFINE_MOCK_METHOD(ReadUserOptions)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pOptionsStream);

		VSL_CHECK_VALIDVALUE_STRINGW(pszKey);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPERSISTSOLUTIONPROPS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsPersistSolutionProps2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPERSISTSOLUTIONPROPS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPERSISTSOLUTIONPROPS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsPersistSolutionProps2NotImpl :
	public IVsPersistSolutionProps2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPersistSolutionProps2NotImpl)

public:

	typedef IVsPersistSolutionProps2 Interface;

	STDMETHOD(OnSolutionLoadFailure)(
		/*[in]*/ LPCOLESTR /*pszKey*/)VSL_STDMETHOD_NOTIMPL
};

class IVsPersistSolutionProps2MockImpl :
	public IVsPersistSolutionProps2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPersistSolutionProps2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsPersistSolutionProps2MockImpl)

	typedef IVsPersistSolutionProps2 Interface;
	struct OnSolutionLoadFailureValidValues
	{
		/*[in]*/ LPCOLESTR pszKey;
		HRESULT retValue;
	};

	STDMETHOD(OnSolutionLoadFailure)(
		/*[in]*/ LPCOLESTR pszKey)
	{
		VSL_DEFINE_MOCK_METHOD(OnSolutionLoadFailure)

		VSL_CHECK_VALIDVALUE_STRINGW(pszKey);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPERSISTSOLUTIONPROPS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsPreviewChangesEngine.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPREVIEWCHANGESENGINE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPREVIEWCHANGESENGINE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsPreviewChangesEngineNotImpl :
	public IVsPreviewChangesEngine
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPreviewChangesEngineNotImpl)

public:

	typedef IVsPreviewChangesEngine Interface;

	STDMETHOD(GetTitle)(
		/*[out]*/ BSTR* /*pbstrTitle*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDescription)(
		/*[out]*/ BSTR* /*pbstrDescription*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTextViewDescription)(
		/*[out]*/ BSTR* /*pbstrTextViewDescription*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetWarning)(
		/*[out]*/ BSTR* /*pbstrWarning*/,
		/*[out]*/ PREVIEWCHANGESWARNINGLEVEL* /*ppcwlWarningLevel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetHelpContext)(
		/*[out]*/ BSTR* /*pbstrHelpContext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetConfirmation)(
		/*[out]*/ BSTR* /*pbstrConfirmation*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetRootChangesList)(
		/*[out]*/ IUnknown** /*ppIUnknownPreviewChangesList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ApplyChanges)()VSL_STDMETHOD_NOTIMPL
};

class IVsPreviewChangesEngineMockImpl :
	public IVsPreviewChangesEngine,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPreviewChangesEngineMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsPreviewChangesEngineMockImpl)

	typedef IVsPreviewChangesEngine Interface;
	struct GetTitleValidValues
	{
		/*[out]*/ BSTR* pbstrTitle;
		HRESULT retValue;
	};

	STDMETHOD(GetTitle)(
		/*[out]*/ BSTR* pbstrTitle)
	{
		VSL_DEFINE_MOCK_METHOD(GetTitle)

		VSL_SET_VALIDVALUE_BSTR(pbstrTitle);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDescriptionValidValues
	{
		/*[out]*/ BSTR* pbstrDescription;
		HRESULT retValue;
	};

	STDMETHOD(GetDescription)(
		/*[out]*/ BSTR* pbstrDescription)
	{
		VSL_DEFINE_MOCK_METHOD(GetDescription)

		VSL_SET_VALIDVALUE_BSTR(pbstrDescription);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTextViewDescriptionValidValues
	{
		/*[out]*/ BSTR* pbstrTextViewDescription;
		HRESULT retValue;
	};

	STDMETHOD(GetTextViewDescription)(
		/*[out]*/ BSTR* pbstrTextViewDescription)
	{
		VSL_DEFINE_MOCK_METHOD(GetTextViewDescription)

		VSL_SET_VALIDVALUE_BSTR(pbstrTextViewDescription);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetWarningValidValues
	{
		/*[out]*/ BSTR* pbstrWarning;
		/*[out]*/ PREVIEWCHANGESWARNINGLEVEL* ppcwlWarningLevel;
		HRESULT retValue;
	};

	STDMETHOD(GetWarning)(
		/*[out]*/ BSTR* pbstrWarning,
		/*[out]*/ PREVIEWCHANGESWARNINGLEVEL* ppcwlWarningLevel)
	{
		VSL_DEFINE_MOCK_METHOD(GetWarning)

		VSL_SET_VALIDVALUE_BSTR(pbstrWarning);

		VSL_SET_VALIDVALUE(ppcwlWarningLevel);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetHelpContextValidValues
	{
		/*[out]*/ BSTR* pbstrHelpContext;
		HRESULT retValue;
	};

	STDMETHOD(GetHelpContext)(
		/*[out]*/ BSTR* pbstrHelpContext)
	{
		VSL_DEFINE_MOCK_METHOD(GetHelpContext)

		VSL_SET_VALIDVALUE_BSTR(pbstrHelpContext);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetConfirmationValidValues
	{
		/*[out]*/ BSTR* pbstrConfirmation;
		HRESULT retValue;
	};

	STDMETHOD(GetConfirmation)(
		/*[out]*/ BSTR* pbstrConfirmation)
	{
		VSL_DEFINE_MOCK_METHOD(GetConfirmation)

		VSL_SET_VALIDVALUE_BSTR(pbstrConfirmation);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetRootChangesListValidValues
	{
		/*[out]*/ IUnknown** ppIUnknownPreviewChangesList;
		HRESULT retValue;
	};

	STDMETHOD(GetRootChangesList)(
		/*[out]*/ IUnknown** ppIUnknownPreviewChangesList)
	{
		VSL_DEFINE_MOCK_METHOD(GetRootChangesList)

		VSL_SET_VALIDVALUE_INTERFACE(ppIUnknownPreviewChangesList);

		VSL_RETURN_VALIDVALUES();
	}
	struct ApplyChangesValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ApplyChanges)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ApplyChanges)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPREVIEWCHANGESENGINE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsPreviewChangesList.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPREVIEWCHANGESLIST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPREVIEWCHANGESLIST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsPreviewChangesListNotImpl :
	public IVsPreviewChangesList
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPreviewChangesListNotImpl)

public:

	typedef IVsPreviewChangesList Interface;

	STDMETHOD(GetFlags)(
		/*[out]*/ VSTREEFLAGS* /*pFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetItemCount)(
		/*[out]*/ ULONG* /*pCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExpandedList)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ BOOL* /*pfCanRecurse*/,
		/*[out]*/ IVsLiteTreeList** /*pptlNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LocateExpandedList)(
		/*[in]*/ IVsLiteTreeList* /*ExpandedList*/,
		/*[out]*/ ULONG* /*iIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnClose)(
		/*[out]*/ VSTREECLOSEACTIONS* /*ptca*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetText)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSTREETEXTOPTIONS /*tto*/,
		/*[out,string]*/ const WCHAR** /*ppszText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTipText)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSTREETOOLTIPTYPE /*eTipType*/,
		/*[out,string]*/ const WCHAR** /*ppszText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExpandable)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ BOOL* /*pfExpandable*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDisplayData)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ VSTREEDISPLAYDATA* /*pData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateCounter)(
		/*[out]*/ ULONG* /*pCurUpdate*/,
		/*[out]*/ VSTREEITEMCHANGESMASK* /*pgrfChanges*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetListChanges)(
		/*[in,out]*/ ULONG* /*pcChanges*/,
		/*[in,size_is(*pcChanges)]*/ VSTREELISTITEMCHANGE* /*prgListChanges*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ToggleState)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ VSTREESTATECHANGEREFRESH* /*ptscr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnRequestSource)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ IUnknown* /*pIUnknownTextView*/)VSL_STDMETHOD_NOTIMPL
};

class IVsPreviewChangesListMockImpl :
	public IVsPreviewChangesList,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPreviewChangesListMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsPreviewChangesListMockImpl)

	typedef IVsPreviewChangesList Interface;
	struct GetFlagsValidValues
	{
		/*[out]*/ VSTREEFLAGS* pFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetFlags)(
		/*[out]*/ VSTREEFLAGS* pFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetFlags)

		VSL_SET_VALIDVALUE(pFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetItemCountValidValues
	{
		/*[out]*/ ULONG* pCount;
		HRESULT retValue;
	};

	STDMETHOD(GetItemCount)(
		/*[out]*/ ULONG* pCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetItemCount)

		VSL_SET_VALIDVALUE(pCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExpandedListValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ BOOL* pfCanRecurse;
		/*[out]*/ IVsLiteTreeList** pptlNode;
		HRESULT retValue;
	};

	STDMETHOD(GetExpandedList)(
		/*[in]*/ ULONG Index,
		/*[out]*/ BOOL* pfCanRecurse,
		/*[out]*/ IVsLiteTreeList** pptlNode)
	{
		VSL_DEFINE_MOCK_METHOD(GetExpandedList)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE(pfCanRecurse);

		VSL_SET_VALIDVALUE_INTERFACE(pptlNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct LocateExpandedListValidValues
	{
		/*[in]*/ IVsLiteTreeList* ExpandedList;
		/*[out]*/ ULONG* iIndex;
		HRESULT retValue;
	};

	STDMETHOD(LocateExpandedList)(
		/*[in]*/ IVsLiteTreeList* ExpandedList,
		/*[out]*/ ULONG* iIndex)
	{
		VSL_DEFINE_MOCK_METHOD(LocateExpandedList)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(ExpandedList);

		VSL_SET_VALIDVALUE(iIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnCloseValidValues
	{
		/*[out]*/ VSTREECLOSEACTIONS* ptca;
		HRESULT retValue;
	};

	STDMETHOD(OnClose)(
		/*[out]*/ VSTREECLOSEACTIONS* ptca)
	{
		VSL_DEFINE_MOCK_METHOD(OnClose)

		VSL_SET_VALIDVALUE(ptca);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTextValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSTREETEXTOPTIONS tto;
		/*[out,string]*/ WCHAR** ppszText;
		HRESULT retValue;
	};

	STDMETHOD(GetText)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSTREETEXTOPTIONS tto,
		/*[out,string]*/ const WCHAR** ppszText)
	{
		VSL_DEFINE_MOCK_METHOD(GetText)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(tto);

		VSL_SET_VALIDVALUE_CONST(ppszText, WCHAR**);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTipTextValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSTREETOOLTIPTYPE eTipType;
		/*[out,string]*/ WCHAR** ppszText;
		HRESULT retValue;
	};

	STDMETHOD(GetTipText)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSTREETOOLTIPTYPE eTipType,
		/*[out,string]*/ const WCHAR** ppszText)
	{
		VSL_DEFINE_MOCK_METHOD(GetTipText)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(eTipType);

		VSL_SET_VALIDVALUE_CONST(ppszText, WCHAR**);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExpandableValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ BOOL* pfExpandable;
		HRESULT retValue;
	};

	STDMETHOD(GetExpandable)(
		/*[in]*/ ULONG Index,
		/*[out]*/ BOOL* pfExpandable)
	{
		VSL_DEFINE_MOCK_METHOD(GetExpandable)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE(pfExpandable);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDisplayDataValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ VSTREEDISPLAYDATA* pData;
		HRESULT retValue;
	};

	STDMETHOD(GetDisplayData)(
		/*[in]*/ ULONG Index,
		/*[out]*/ VSTREEDISPLAYDATA* pData)
	{
		VSL_DEFINE_MOCK_METHOD(GetDisplayData)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE(pData);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateCounterValidValues
	{
		/*[out]*/ ULONG* pCurUpdate;
		/*[out]*/ VSTREEITEMCHANGESMASK* pgrfChanges;
		HRESULT retValue;
	};

	STDMETHOD(UpdateCounter)(
		/*[out]*/ ULONG* pCurUpdate,
		/*[out]*/ VSTREEITEMCHANGESMASK* pgrfChanges)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateCounter)

		VSL_SET_VALIDVALUE(pCurUpdate);

		VSL_SET_VALIDVALUE(pgrfChanges);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetListChangesValidValues
	{
		/*[in,out]*/ ULONG* pcChanges;
		/*[in,size_is(*pcChanges)]*/ VSTREELISTITEMCHANGE* prgListChanges;
		HRESULT retValue;
	};

	STDMETHOD(GetListChanges)(
		/*[in,out]*/ ULONG* pcChanges,
		/*[in,size_is(*pcChanges)]*/ VSTREELISTITEMCHANGE* prgListChanges)
	{
		VSL_DEFINE_MOCK_METHOD(GetListChanges)

		VSL_SET_VALIDVALUE(pcChanges);

		VSL_CHECK_VALIDVALUE_MEMCMP(prgListChanges, *pcChanges*sizeof(prgListChanges[0]), *(validValues.pcChanges)*sizeof(validValues.prgListChanges[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct ToggleStateValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ VSTREESTATECHANGEREFRESH* ptscr;
		HRESULT retValue;
	};

	STDMETHOD(ToggleState)(
		/*[in]*/ ULONG Index,
		/*[out]*/ VSTREESTATECHANGEREFRESH* ptscr)
	{
		VSL_DEFINE_MOCK_METHOD(ToggleState)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE(ptscr);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnRequestSourceValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ IUnknown* pIUnknownTextView;
		HRESULT retValue;
	};

	STDMETHOD(OnRequestSource)(
		/*[in]*/ ULONG Index,
		/*[in]*/ IUnknown* pIUnknownTextView)
	{
		VSL_DEFINE_MOCK_METHOD(OnRequestSource)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIUnknownTextView);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPREVIEWCHANGESLIST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsProfileDataManager.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROFILEDATAMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROFILEDATAMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsProfileDataManagerNotImpl :
	public IVsProfileDataManager
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProfileDataManagerNotImpl)

public:

	typedef IVsProfileDataManager Interface;

	STDMETHOD(LastResetPoint)(
		/*[out]*/ BSTR* /*pbstrResetFilename*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSettingsFiles)(
		/*[in]*/ VSPROFILELOCATIONS /*fileLocations*/,
		/*[out]*/ IVsProfileSettingsFileCollection** /*ppCollection*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDefaultSettingsLocation)(
		/*[out]*/ BSTR* /*pbstrSettingsLocation*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetUniqueExportFileName)(
		/*[in]*/ VSPROFILEGETFILENAME /*flags*/,
		/*[out]*/ BSTR* /*pbstrExportFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSettingsFileExtension)(
		/*[out]*/ BSTR* /*pbstrSettingsFileExtension*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSettingsForExport)(
		/*[out]*/ IVsProfileSettingsTree** /*ppSettingsTree*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ExportSettings)(
		/*[in]*/ BSTR /*bstrFilePath*/,
		/*[in]*/ IVsProfileSettingsTree* /*pSettingsTree*/,
		/*[out]*/ IVsSettingsErrorInformation** /*ppsettingsErrorInformation*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ImportSettings)(
		/*[in]*/ IVsProfileSettingsTree* /*pSettingsTree*/,
		/*[out]*/ IVsSettingsErrorInformation** /*ppsettingsErrorInformation*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ResetSettings)(
		/*[in]*/ IVsProfileSettingsFileInfo* /*pFileInfo*/,
		/*[out]*/ IVsSettingsErrorInformation** /*ppsettingsErrorInformation*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ExportAllSettings)(
		/*[in]*/ BSTR /*bstrFilePath*/,
		/*[out]*/ IVsSettingsErrorInformation** /*ppsettingsErrorInformation*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AutoSaveAllSettings)(
		/*[out]*/ IVsSettingsErrorInformation** /*ppsettingsErrorInformation*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CheckUpdateTeamSettings)(
		/*[in]*/ VSPROFILETEAMSETTINGSFLAGS /*dwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReportTeamSettingsChanged)(
		/*[in]*/ VSPROFILETEAMSETTINGSCHANGEDFLAGS /*dwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ShowProfilesUI)()VSL_STDMETHOD_NOTIMPL
};

class IVsProfileDataManagerMockImpl :
	public IVsProfileDataManager,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProfileDataManagerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsProfileDataManagerMockImpl)

	typedef IVsProfileDataManager Interface;
	struct LastResetPointValidValues
	{
		/*[out]*/ BSTR* pbstrResetFilename;
		HRESULT retValue;
	};

	STDMETHOD(LastResetPoint)(
		/*[out]*/ BSTR* pbstrResetFilename)
	{
		VSL_DEFINE_MOCK_METHOD(LastResetPoint)

		VSL_SET_VALIDVALUE_BSTR(pbstrResetFilename);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSettingsFilesValidValues
	{
		/*[in]*/ VSPROFILELOCATIONS fileLocations;
		/*[out]*/ IVsProfileSettingsFileCollection** ppCollection;
		HRESULT retValue;
	};

	STDMETHOD(GetSettingsFiles)(
		/*[in]*/ VSPROFILELOCATIONS fileLocations,
		/*[out]*/ IVsProfileSettingsFileCollection** ppCollection)
	{
		VSL_DEFINE_MOCK_METHOD(GetSettingsFiles)

		VSL_CHECK_VALIDVALUE(fileLocations);

		VSL_SET_VALIDVALUE_INTERFACE(ppCollection);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDefaultSettingsLocationValidValues
	{
		/*[out]*/ BSTR* pbstrSettingsLocation;
		HRESULT retValue;
	};

	STDMETHOD(GetDefaultSettingsLocation)(
		/*[out]*/ BSTR* pbstrSettingsLocation)
	{
		VSL_DEFINE_MOCK_METHOD(GetDefaultSettingsLocation)

		VSL_SET_VALIDVALUE_BSTR(pbstrSettingsLocation);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetUniqueExportFileNameValidValues
	{
		/*[in]*/ VSPROFILEGETFILENAME flags;
		/*[out]*/ BSTR* pbstrExportFile;
		HRESULT retValue;
	};

	STDMETHOD(GetUniqueExportFileName)(
		/*[in]*/ VSPROFILEGETFILENAME flags,
		/*[out]*/ BSTR* pbstrExportFile)
	{
		VSL_DEFINE_MOCK_METHOD(GetUniqueExportFileName)

		VSL_CHECK_VALIDVALUE(flags);

		VSL_SET_VALIDVALUE_BSTR(pbstrExportFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSettingsFileExtensionValidValues
	{
		/*[out]*/ BSTR* pbstrSettingsFileExtension;
		HRESULT retValue;
	};

	STDMETHOD(GetSettingsFileExtension)(
		/*[out]*/ BSTR* pbstrSettingsFileExtension)
	{
		VSL_DEFINE_MOCK_METHOD(GetSettingsFileExtension)

		VSL_SET_VALIDVALUE_BSTR(pbstrSettingsFileExtension);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSettingsForExportValidValues
	{
		/*[out]*/ IVsProfileSettingsTree** ppSettingsTree;
		HRESULT retValue;
	};

	STDMETHOD(GetSettingsForExport)(
		/*[out]*/ IVsProfileSettingsTree** ppSettingsTree)
	{
		VSL_DEFINE_MOCK_METHOD(GetSettingsForExport)

		VSL_SET_VALIDVALUE_INTERFACE(ppSettingsTree);

		VSL_RETURN_VALIDVALUES();
	}
	struct ExportSettingsValidValues
	{
		/*[in]*/ BSTR bstrFilePath;
		/*[in]*/ IVsProfileSettingsTree* pSettingsTree;
		/*[out]*/ IVsSettingsErrorInformation** ppsettingsErrorInformation;
		HRESULT retValue;
	};

	STDMETHOD(ExportSettings)(
		/*[in]*/ BSTR bstrFilePath,
		/*[in]*/ IVsProfileSettingsTree* pSettingsTree,
		/*[out]*/ IVsSettingsErrorInformation** ppsettingsErrorInformation)
	{
		VSL_DEFINE_MOCK_METHOD(ExportSettings)

		VSL_CHECK_VALIDVALUE_BSTR(bstrFilePath);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSettingsTree);

		VSL_SET_VALIDVALUE_INTERFACE(ppsettingsErrorInformation);

		VSL_RETURN_VALIDVALUES();
	}
	struct ImportSettingsValidValues
	{
		/*[in]*/ IVsProfileSettingsTree* pSettingsTree;
		/*[out]*/ IVsSettingsErrorInformation** ppsettingsErrorInformation;
		HRESULT retValue;
	};

	STDMETHOD(ImportSettings)(
		/*[in]*/ IVsProfileSettingsTree* pSettingsTree,
		/*[out]*/ IVsSettingsErrorInformation** ppsettingsErrorInformation)
	{
		VSL_DEFINE_MOCK_METHOD(ImportSettings)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSettingsTree);

		VSL_SET_VALIDVALUE_INTERFACE(ppsettingsErrorInformation);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetSettingsValidValues
	{
		/*[in]*/ IVsProfileSettingsFileInfo* pFileInfo;
		/*[out]*/ IVsSettingsErrorInformation** ppsettingsErrorInformation;
		HRESULT retValue;
	};

	STDMETHOD(ResetSettings)(
		/*[in]*/ IVsProfileSettingsFileInfo* pFileInfo,
		/*[out]*/ IVsSettingsErrorInformation** ppsettingsErrorInformation)
	{
		VSL_DEFINE_MOCK_METHOD(ResetSettings)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pFileInfo);

		VSL_SET_VALIDVALUE_INTERFACE(ppsettingsErrorInformation);

		VSL_RETURN_VALIDVALUES();
	}
	struct ExportAllSettingsValidValues
	{
		/*[in]*/ BSTR bstrFilePath;
		/*[out]*/ IVsSettingsErrorInformation** ppsettingsErrorInformation;
		HRESULT retValue;
	};

	STDMETHOD(ExportAllSettings)(
		/*[in]*/ BSTR bstrFilePath,
		/*[out]*/ IVsSettingsErrorInformation** ppsettingsErrorInformation)
	{
		VSL_DEFINE_MOCK_METHOD(ExportAllSettings)

		VSL_CHECK_VALIDVALUE_BSTR(bstrFilePath);

		VSL_SET_VALIDVALUE_INTERFACE(ppsettingsErrorInformation);

		VSL_RETURN_VALIDVALUES();
	}
	struct AutoSaveAllSettingsValidValues
	{
		/*[out]*/ IVsSettingsErrorInformation** ppsettingsErrorInformation;
		HRESULT retValue;
	};

	STDMETHOD(AutoSaveAllSettings)(
		/*[out]*/ IVsSettingsErrorInformation** ppsettingsErrorInformation)
	{
		VSL_DEFINE_MOCK_METHOD(AutoSaveAllSettings)

		VSL_SET_VALIDVALUE_INTERFACE(ppsettingsErrorInformation);

		VSL_RETURN_VALIDVALUES();
	}
	struct CheckUpdateTeamSettingsValidValues
	{
		/*[in]*/ VSPROFILETEAMSETTINGSFLAGS dwFlags;
		HRESULT retValue;
	};

	STDMETHOD(CheckUpdateTeamSettings)(
		/*[in]*/ VSPROFILETEAMSETTINGSFLAGS dwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(CheckUpdateTeamSettings)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReportTeamSettingsChangedValidValues
	{
		/*[in]*/ VSPROFILETEAMSETTINGSCHANGEDFLAGS dwFlags;
		HRESULT retValue;
	};

	STDMETHOD(ReportTeamSettingsChanged)(
		/*[in]*/ VSPROFILETEAMSETTINGSCHANGEDFLAGS dwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(ReportTeamSettingsChanged)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct ShowProfilesUIValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ShowProfilesUI)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ShowProfilesUI)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROFILEDATAMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsProfileSettingsTree.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROFILESETTINGSTREE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROFILESETTINGSTREE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsProfileSettingsTreeNotImpl :
	public IVsProfileSettingsTree
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProfileSettingsTreeNotImpl)

public:

	typedef IVsProfileSettingsTree Interface;

	STDMETHOD(GetChildCount)(
		/*[out]*/ int* /*pCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetChild)(
		/*[in]*/ int /*index*/,
		/*[out]*/ IVsProfileSettingsTree** /*ppChildTree*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEnabledChildCount)(
		/*[out]*/ int* /*pCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDisplayName)(
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDescription)(
		/*[out]*/ BSTR* /*pbstrDescription*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCategory)(
		/*[out]*/ BSTR* /*pbstrCategory*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetRegisteredName)(
		/*[out]*/ BSTR* /*pbstrRegisteredName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetNameForID)(
		/*[out]*/ BSTR* /*pbstrNameForID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFullPath)(
		/*[out]*/ BSTR* /*pbstrFullPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPackage)(
		/*[out]*/ BSTR* /*pbstrPackage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIsAutomationPropBased)(
		/*[out]*/ BOOL* /*pfAutoProp*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEnabled)(
		/*[out]*/ BOOL* /*pfEnabled*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetEnabled)(
		/*[in]*/ BOOL /*fEnabled*/,
		/*[in]*/ BOOL /*fIncludeChildren*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetVisible)(
		/*[out]*/ BOOL* /*pfVisible*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetAlternatePath)(
		/*[out]*/ BSTR* /*pbstrAlternatePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIsPlaceholder)(
		/*[out]*/ BOOL* /*pfPlaceholder*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetRepresentedNode)(
		/*[out]*/ IVsProfileSettingsTree** /*ppRepresentedNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSecurityLevel)(
		/*[out]*/ VSPROFILECATEGORYSECURITY* /*pSecurityLevel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSensitivityLevel)(
		/*[out]*/ VSPROFILECATEGORYSENSITIVITY* /*pSensitivityLevel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FindChildTree)(
		/*[in]*/ BSTR /*bstrNameSearch*/,
		/*[out]*/ IVsProfileSettingsTree** /*ppChildTree*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddChildTree)(
		/*[in]*/ IVsProfileSettingsTree* /*pChildTree*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RevisePlacements)(
		/*[in]*/ IVsProfileSettingsTree* /*pTreeRoot*/,
		/*[in]*/ IVsProfileSettingsTree* /*pTreeRootBasis*/,
		/*[in]*/ BSTR /*bstrCurrentParent*/)VSL_STDMETHOD_NOTIMPL
};

class IVsProfileSettingsTreeMockImpl :
	public IVsProfileSettingsTree,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProfileSettingsTreeMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsProfileSettingsTreeMockImpl)

	typedef IVsProfileSettingsTree Interface;
	struct GetChildCountValidValues
	{
		/*[out]*/ int* pCount;
		HRESULT retValue;
	};

	STDMETHOD(GetChildCount)(
		/*[out]*/ int* pCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetChildCount)

		VSL_SET_VALIDVALUE(pCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetChildValidValues
	{
		/*[in]*/ int index;
		/*[out]*/ IVsProfileSettingsTree** ppChildTree;
		HRESULT retValue;
	};

	STDMETHOD(GetChild)(
		/*[in]*/ int index,
		/*[out]*/ IVsProfileSettingsTree** ppChildTree)
	{
		VSL_DEFINE_MOCK_METHOD(GetChild)

		VSL_CHECK_VALIDVALUE(index);

		VSL_SET_VALIDVALUE_INTERFACE(ppChildTree);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEnabledChildCountValidValues
	{
		/*[out]*/ int* pCount;
		HRESULT retValue;
	};

	STDMETHOD(GetEnabledChildCount)(
		/*[out]*/ int* pCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetEnabledChildCount)

		VSL_SET_VALIDVALUE(pCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDisplayNameValidValues
	{
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetDisplayName)(
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetDisplayName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDescriptionValidValues
	{
		/*[out]*/ BSTR* pbstrDescription;
		HRESULT retValue;
	};

	STDMETHOD(GetDescription)(
		/*[out]*/ BSTR* pbstrDescription)
	{
		VSL_DEFINE_MOCK_METHOD(GetDescription)

		VSL_SET_VALIDVALUE_BSTR(pbstrDescription);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCategoryValidValues
	{
		/*[out]*/ BSTR* pbstrCategory;
		HRESULT retValue;
	};

	STDMETHOD(GetCategory)(
		/*[out]*/ BSTR* pbstrCategory)
	{
		VSL_DEFINE_MOCK_METHOD(GetCategory)

		VSL_SET_VALIDVALUE_BSTR(pbstrCategory);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetRegisteredNameValidValues
	{
		/*[out]*/ BSTR* pbstrRegisteredName;
		HRESULT retValue;
	};

	STDMETHOD(GetRegisteredName)(
		/*[out]*/ BSTR* pbstrRegisteredName)
	{
		VSL_DEFINE_MOCK_METHOD(GetRegisteredName)

		VSL_SET_VALIDVALUE_BSTR(pbstrRegisteredName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNameForIDValidValues
	{
		/*[out]*/ BSTR* pbstrNameForID;
		HRESULT retValue;
	};

	STDMETHOD(GetNameForID)(
		/*[out]*/ BSTR* pbstrNameForID)
	{
		VSL_DEFINE_MOCK_METHOD(GetNameForID)

		VSL_SET_VALIDVALUE_BSTR(pbstrNameForID);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFullPathValidValues
	{
		/*[out]*/ BSTR* pbstrFullPath;
		HRESULT retValue;
	};

	STDMETHOD(GetFullPath)(
		/*[out]*/ BSTR* pbstrFullPath)
	{
		VSL_DEFINE_MOCK_METHOD(GetFullPath)

		VSL_SET_VALIDVALUE_BSTR(pbstrFullPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPackageValidValues
	{
		/*[out]*/ BSTR* pbstrPackage;
		HRESULT retValue;
	};

	STDMETHOD(GetPackage)(
		/*[out]*/ BSTR* pbstrPackage)
	{
		VSL_DEFINE_MOCK_METHOD(GetPackage)

		VSL_SET_VALIDVALUE_BSTR(pbstrPackage);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIsAutomationPropBasedValidValues
	{
		/*[out]*/ BOOL* pfAutoProp;
		HRESULT retValue;
	};

	STDMETHOD(GetIsAutomationPropBased)(
		/*[out]*/ BOOL* pfAutoProp)
	{
		VSL_DEFINE_MOCK_METHOD(GetIsAutomationPropBased)

		VSL_SET_VALIDVALUE(pfAutoProp);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEnabledValidValues
	{
		/*[out]*/ BOOL* pfEnabled;
		HRESULT retValue;
	};

	STDMETHOD(GetEnabled)(
		/*[out]*/ BOOL* pfEnabled)
	{
		VSL_DEFINE_MOCK_METHOD(GetEnabled)

		VSL_SET_VALIDVALUE(pfEnabled);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetEnabledValidValues
	{
		/*[in]*/ BOOL fEnabled;
		/*[in]*/ BOOL fIncludeChildren;
		HRESULT retValue;
	};

	STDMETHOD(SetEnabled)(
		/*[in]*/ BOOL fEnabled,
		/*[in]*/ BOOL fIncludeChildren)
	{
		VSL_DEFINE_MOCK_METHOD(SetEnabled)

		VSL_CHECK_VALIDVALUE(fEnabled);

		VSL_CHECK_VALIDVALUE(fIncludeChildren);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetVisibleValidValues
	{
		/*[out]*/ BOOL* pfVisible;
		HRESULT retValue;
	};

	STDMETHOD(GetVisible)(
		/*[out]*/ BOOL* pfVisible)
	{
		VSL_DEFINE_MOCK_METHOD(GetVisible)

		VSL_SET_VALIDVALUE(pfVisible);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetAlternatePathValidValues
	{
		/*[out]*/ BSTR* pbstrAlternatePath;
		HRESULT retValue;
	};

	STDMETHOD(GetAlternatePath)(
		/*[out]*/ BSTR* pbstrAlternatePath)
	{
		VSL_DEFINE_MOCK_METHOD(GetAlternatePath)

		VSL_SET_VALIDVALUE_BSTR(pbstrAlternatePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIsPlaceholderValidValues
	{
		/*[out]*/ BOOL* pfPlaceholder;
		HRESULT retValue;
	};

	STDMETHOD(GetIsPlaceholder)(
		/*[out]*/ BOOL* pfPlaceholder)
	{
		VSL_DEFINE_MOCK_METHOD(GetIsPlaceholder)

		VSL_SET_VALIDVALUE(pfPlaceholder);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetRepresentedNodeValidValues
	{
		/*[out]*/ IVsProfileSettingsTree** ppRepresentedNode;
		HRESULT retValue;
	};

	STDMETHOD(GetRepresentedNode)(
		/*[out]*/ IVsProfileSettingsTree** ppRepresentedNode)
	{
		VSL_DEFINE_MOCK_METHOD(GetRepresentedNode)

		VSL_SET_VALIDVALUE_INTERFACE(ppRepresentedNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSecurityLevelValidValues
	{
		/*[out]*/ VSPROFILECATEGORYSECURITY* pSecurityLevel;
		HRESULT retValue;
	};

	STDMETHOD(GetSecurityLevel)(
		/*[out]*/ VSPROFILECATEGORYSECURITY* pSecurityLevel)
	{
		VSL_DEFINE_MOCK_METHOD(GetSecurityLevel)

		VSL_SET_VALIDVALUE(pSecurityLevel);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSensitivityLevelValidValues
	{
		/*[out]*/ VSPROFILECATEGORYSENSITIVITY* pSensitivityLevel;
		HRESULT retValue;
	};

	STDMETHOD(GetSensitivityLevel)(
		/*[out]*/ VSPROFILECATEGORYSENSITIVITY* pSensitivityLevel)
	{
		VSL_DEFINE_MOCK_METHOD(GetSensitivityLevel)

		VSL_SET_VALIDVALUE(pSensitivityLevel);

		VSL_RETURN_VALIDVALUES();
	}
	struct FindChildTreeValidValues
	{
		/*[in]*/ BSTR bstrNameSearch;
		/*[out]*/ IVsProfileSettingsTree** ppChildTree;
		HRESULT retValue;
	};

	STDMETHOD(FindChildTree)(
		/*[in]*/ BSTR bstrNameSearch,
		/*[out]*/ IVsProfileSettingsTree** ppChildTree)
	{
		VSL_DEFINE_MOCK_METHOD(FindChildTree)

		VSL_CHECK_VALIDVALUE_BSTR(bstrNameSearch);

		VSL_SET_VALIDVALUE_INTERFACE(ppChildTree);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddChildTreeValidValues
	{
		/*[in]*/ IVsProfileSettingsTree* pChildTree;
		HRESULT retValue;
	};

	STDMETHOD(AddChildTree)(
		/*[in]*/ IVsProfileSettingsTree* pChildTree)
	{
		VSL_DEFINE_MOCK_METHOD(AddChildTree)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pChildTree);

		VSL_RETURN_VALIDVALUES();
	}
	struct RevisePlacementsValidValues
	{
		/*[in]*/ IVsProfileSettingsTree* pTreeRoot;
		/*[in]*/ IVsProfileSettingsTree* pTreeRootBasis;
		/*[in]*/ BSTR bstrCurrentParent;
		HRESULT retValue;
	};

	STDMETHOD(RevisePlacements)(
		/*[in]*/ IVsProfileSettingsTree* pTreeRoot,
		/*[in]*/ IVsProfileSettingsTree* pTreeRootBasis,
		/*[in]*/ BSTR bstrCurrentParent)
	{
		VSL_DEFINE_MOCK_METHOD(RevisePlacements)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pTreeRoot);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pTreeRootBasis);

		VSL_CHECK_VALIDVALUE_BSTR(bstrCurrentParent);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROFILESETTINGSTREE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsPreviewChangesService.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPREVIEWCHANGESSERVICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPREVIEWCHANGESSERVICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsPreviewChangesServiceNotImpl :
	public IVsPreviewChangesService
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPreviewChangesServiceNotImpl)

public:

	typedef IVsPreviewChangesService Interface;

	STDMETHOD(PreviewChanges)(
		/*[in]*/ IVsPreviewChangesEngine* /*pIVsPreviewChangesEngine*/)VSL_STDMETHOD_NOTIMPL
};

class IVsPreviewChangesServiceMockImpl :
	public IVsPreviewChangesService,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPreviewChangesServiceMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsPreviewChangesServiceMockImpl)

	typedef IVsPreviewChangesService Interface;
	struct PreviewChangesValidValues
	{
		/*[in]*/ IVsPreviewChangesEngine* pIVsPreviewChangesEngine;
		HRESULT retValue;
	};

	STDMETHOD(PreviewChanges)(
		/*[in]*/ IVsPreviewChangesEngine* pIVsPreviewChangesEngine)
	{
		VSL_DEFINE_MOCK_METHOD(PreviewChanges)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsPreviewChangesEngine);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPREVIEWCHANGESSERVICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsPrioritizedSolutionEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPRIORITIZEDSOLUTIONEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPRIORITIZEDSOLUTIONEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsPrioritizedSolutionEventsNotImpl :
	public IVsPrioritizedSolutionEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPrioritizedSolutionEventsNotImpl)

public:

	typedef IVsPrioritizedSolutionEvents Interface;

	STDMETHOD(PrioritizedOnAfterOpenProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ BOOL /*fAdded*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(PrioritizedOnBeforeCloseProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ BOOL /*fRemoved*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(PrioritizedOnAfterLoadProject)(
		/*[in]*/ IVsHierarchy* /*pStubHierarchy*/,
		/*[in]*/ IVsHierarchy* /*pRealHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(PrioritizedOnBeforeUnloadProject)(
		/*[in]*/ IVsHierarchy* /*pRealHierarchy*/,
		/*[in]*/ IVsHierarchy* /*pStubHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(PrioritizedOnAfterOpenSolution)(
		/*[in]*/ IUnknown* /*pUnkReserved*/,
		/*[in]*/ BOOL /*fNewSolution*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(PrioritizedOnBeforeCloseSolution)(
		/*[in]*/ IUnknown* /*pUnkReserved*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(PrioritizedOnAfterCloseSolution)(
		/*[in]*/ IUnknown* /*pUnkReserved*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(PrioritizedOnAfterMergeSolution)(
		/*[in]*/ IUnknown* /*pUnkReserved*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(PrioritizedOnBeforeOpeningChildren)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(PrioritizedOnAfterOpeningChildren)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(PrioritizedOnBeforeClosingChildren)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(PrioritizedOnAfterClosingChildren)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(PrioritizedOnAfterRenameProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(PrioritizedOnAfterChangeProjectParent)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(PrioritizedOnAfterAsynchOpenProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ BOOL /*fAdded*/)VSL_STDMETHOD_NOTIMPL
};

class IVsPrioritizedSolutionEventsMockImpl :
	public IVsPrioritizedSolutionEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPrioritizedSolutionEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsPrioritizedSolutionEventsMockImpl)

	typedef IVsPrioritizedSolutionEvents Interface;
	struct PrioritizedOnAfterOpenProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ BOOL fAdded;
		HRESULT retValue;
	};

	STDMETHOD(PrioritizedOnAfterOpenProject)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ BOOL fAdded)
	{
		VSL_DEFINE_MOCK_METHOD(PrioritizedOnAfterOpenProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE(fAdded);

		VSL_RETURN_VALIDVALUES();
	}
	struct PrioritizedOnBeforeCloseProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ BOOL fRemoved;
		HRESULT retValue;
	};

	STDMETHOD(PrioritizedOnBeforeCloseProject)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ BOOL fRemoved)
	{
		VSL_DEFINE_MOCK_METHOD(PrioritizedOnBeforeCloseProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE(fRemoved);

		VSL_RETURN_VALIDVALUES();
	}
	struct PrioritizedOnAfterLoadProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pStubHierarchy;
		/*[in]*/ IVsHierarchy* pRealHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(PrioritizedOnAfterLoadProject)(
		/*[in]*/ IVsHierarchy* pStubHierarchy,
		/*[in]*/ IVsHierarchy* pRealHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(PrioritizedOnAfterLoadProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStubHierarchy);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pRealHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct PrioritizedOnBeforeUnloadProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pRealHierarchy;
		/*[in]*/ IVsHierarchy* pStubHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(PrioritizedOnBeforeUnloadProject)(
		/*[in]*/ IVsHierarchy* pRealHierarchy,
		/*[in]*/ IVsHierarchy* pStubHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(PrioritizedOnBeforeUnloadProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pRealHierarchy);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStubHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct PrioritizedOnAfterOpenSolutionValidValues
	{
		/*[in]*/ IUnknown* pUnkReserved;
		/*[in]*/ BOOL fNewSolution;
		HRESULT retValue;
	};

	STDMETHOD(PrioritizedOnAfterOpenSolution)(
		/*[in]*/ IUnknown* pUnkReserved,
		/*[in]*/ BOOL fNewSolution)
	{
		VSL_DEFINE_MOCK_METHOD(PrioritizedOnAfterOpenSolution)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnkReserved);

		VSL_CHECK_VALIDVALUE(fNewSolution);

		VSL_RETURN_VALIDVALUES();
	}
	struct PrioritizedOnBeforeCloseSolutionValidValues
	{
		/*[in]*/ IUnknown* pUnkReserved;
		HRESULT retValue;
	};

	STDMETHOD(PrioritizedOnBeforeCloseSolution)(
		/*[in]*/ IUnknown* pUnkReserved)
	{
		VSL_DEFINE_MOCK_METHOD(PrioritizedOnBeforeCloseSolution)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnkReserved);

		VSL_RETURN_VALIDVALUES();
	}
	struct PrioritizedOnAfterCloseSolutionValidValues
	{
		/*[in]*/ IUnknown* pUnkReserved;
		HRESULT retValue;
	};

	STDMETHOD(PrioritizedOnAfterCloseSolution)(
		/*[in]*/ IUnknown* pUnkReserved)
	{
		VSL_DEFINE_MOCK_METHOD(PrioritizedOnAfterCloseSolution)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnkReserved);

		VSL_RETURN_VALIDVALUES();
	}
	struct PrioritizedOnAfterMergeSolutionValidValues
	{
		/*[in]*/ IUnknown* pUnkReserved;
		HRESULT retValue;
	};

	STDMETHOD(PrioritizedOnAfterMergeSolution)(
		/*[in]*/ IUnknown* pUnkReserved)
	{
		VSL_DEFINE_MOCK_METHOD(PrioritizedOnAfterMergeSolution)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnkReserved);

		VSL_RETURN_VALIDVALUES();
	}
	struct PrioritizedOnBeforeOpeningChildrenValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(PrioritizedOnBeforeOpeningChildren)(
		/*[in]*/ IVsHierarchy* pHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(PrioritizedOnBeforeOpeningChildren)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct PrioritizedOnAfterOpeningChildrenValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(PrioritizedOnAfterOpeningChildren)(
		/*[in]*/ IVsHierarchy* pHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(PrioritizedOnAfterOpeningChildren)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct PrioritizedOnBeforeClosingChildrenValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(PrioritizedOnBeforeClosingChildren)(
		/*[in]*/ IVsHierarchy* pHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(PrioritizedOnBeforeClosingChildren)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct PrioritizedOnAfterClosingChildrenValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(PrioritizedOnAfterClosingChildren)(
		/*[in]*/ IVsHierarchy* pHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(PrioritizedOnAfterClosingChildren)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct PrioritizedOnAfterRenameProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(PrioritizedOnAfterRenameProject)(
		/*[in]*/ IVsHierarchy* pHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(PrioritizedOnAfterRenameProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct PrioritizedOnAfterChangeProjectParentValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(PrioritizedOnAfterChangeProjectParent)(
		/*[in]*/ IVsHierarchy* pHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(PrioritizedOnAfterChangeProjectParent)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct PrioritizedOnAfterAsynchOpenProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ BOOL fAdded;
		HRESULT retValue;
	};

	STDMETHOD(PrioritizedOnAfterAsynchOpenProject)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ BOOL fAdded)
	{
		VSL_DEFINE_MOCK_METHOD(PrioritizedOnAfterAsynchOpenProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE(fAdded);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPRIORITIZEDSOLUTIONEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsProfileSettingsFileInfo.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROFILESETTINGSFILEINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROFILESETTINGSFILEINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsProfileSettingsFileInfoNotImpl :
	public IVsProfileSettingsFileInfo
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProfileSettingsFileInfoNotImpl)

public:

	typedef IVsProfileSettingsFileInfo Interface;

	STDMETHOD(GetFilePath)(
		/*[out]*/ BSTR* /*pbstrFilePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFileLocation)(
		/*[out]*/ VSPROFILELOCATIONS* /*pfileLocation*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFriendlyName)(
		/*[out]*/ BSTR* /*pbstrFriendlyName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDescription)(
		/*[out]*/ BSTR* /*pbstrDescription*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSettingsForImport)(
		/*[out]*/ IVsProfileSettingsTree** /*ppSettingsTree*/)VSL_STDMETHOD_NOTIMPL
};

class IVsProfileSettingsFileInfoMockImpl :
	public IVsProfileSettingsFileInfo,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProfileSettingsFileInfoMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsProfileSettingsFileInfoMockImpl)

	typedef IVsProfileSettingsFileInfo Interface;
	struct GetFilePathValidValues
	{
		/*[out]*/ BSTR* pbstrFilePath;
		HRESULT retValue;
	};

	STDMETHOD(GetFilePath)(
		/*[out]*/ BSTR* pbstrFilePath)
	{
		VSL_DEFINE_MOCK_METHOD(GetFilePath)

		VSL_SET_VALIDVALUE_BSTR(pbstrFilePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFileLocationValidValues
	{
		/*[out]*/ VSPROFILELOCATIONS* pfileLocation;
		HRESULT retValue;
	};

	STDMETHOD(GetFileLocation)(
		/*[out]*/ VSPROFILELOCATIONS* pfileLocation)
	{
		VSL_DEFINE_MOCK_METHOD(GetFileLocation)

		VSL_SET_VALIDVALUE(pfileLocation);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFriendlyNameValidValues
	{
		/*[out]*/ BSTR* pbstrFriendlyName;
		HRESULT retValue;
	};

	STDMETHOD(GetFriendlyName)(
		/*[out]*/ BSTR* pbstrFriendlyName)
	{
		VSL_DEFINE_MOCK_METHOD(GetFriendlyName)

		VSL_SET_VALIDVALUE_BSTR(pbstrFriendlyName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDescriptionValidValues
	{
		/*[out]*/ BSTR* pbstrDescription;
		HRESULT retValue;
	};

	STDMETHOD(GetDescription)(
		/*[out]*/ BSTR* pbstrDescription)
	{
		VSL_DEFINE_MOCK_METHOD(GetDescription)

		VSL_SET_VALIDVALUE_BSTR(pbstrDescription);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSettingsForImportValidValues
	{
		/*[out]*/ IVsProfileSettingsTree** ppSettingsTree;
		HRESULT retValue;
	};

	STDMETHOD(GetSettingsForImport)(
		/*[out]*/ IVsProfileSettingsTree** ppSettingsTree)
	{
		VSL_DEFINE_MOCK_METHOD(GetSettingsForImport)

		VSL_SET_VALIDVALUE_INTERFACE(ppSettingsTree);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROFILESETTINGSFILEINFO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsProfileSettingsFileCollection.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROFILESETTINGSFILECOLLECTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROFILESETTINGSFILECOLLECTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsProfileSettingsFileCollectionNotImpl :
	public IVsProfileSettingsFileCollection
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProfileSettingsFileCollectionNotImpl)

public:

	typedef IVsProfileSettingsFileCollection Interface;

	STDMETHOD(GetCount)(
		/*[out]*/ int* /*pCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSettingsFile)(
		/*[in]*/ int /*index*/,
		/*[out]*/ IVsProfileSettingsFileInfo** /*ppFileInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddBrowseFile)(
		/*[in]*/ BSTR /*bstrFilePath*/,
		/*[out]*/ IVsProfileSettingsFileInfo** /*ppFileInfo*/)VSL_STDMETHOD_NOTIMPL
};

class IVsProfileSettingsFileCollectionMockImpl :
	public IVsProfileSettingsFileCollection,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProfileSettingsFileCollectionMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsProfileSettingsFileCollectionMockImpl)

	typedef IVsProfileSettingsFileCollection Interface;
	struct GetCountValidValues
	{
		/*[out]*/ int* pCount;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out]*/ int* pCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSettingsFileValidValues
	{
		/*[in]*/ int index;
		/*[out]*/ IVsProfileSettingsFileInfo** ppFileInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetSettingsFile)(
		/*[in]*/ int index,
		/*[out]*/ IVsProfileSettingsFileInfo** ppFileInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetSettingsFile)

		VSL_CHECK_VALIDVALUE(index);

		VSL_SET_VALIDVALUE_INTERFACE(ppFileInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddBrowseFileValidValues
	{
		/*[in]*/ BSTR bstrFilePath;
		/*[out]*/ IVsProfileSettingsFileInfo** ppFileInfo;
		HRESULT retValue;
	};

	STDMETHOD(AddBrowseFile)(
		/*[in]*/ BSTR bstrFilePath,
		/*[out]*/ IVsProfileSettingsFileInfo** ppFileInfo)
	{
		VSL_DEFINE_MOCK_METHOD(AddBrowseFile)

		VSL_CHECK_VALIDVALUE_BSTR(bstrFilePath);

		VSL_SET_VALIDVALUE_INTERFACE(ppFileInfo);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROFILESETTINGSFILECOLLECTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsProfferCommands3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROFFERCOMMANDS3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROFFERCOMMANDS3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsProfferCommands3NotImpl :
	public IVsProfferCommands3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProfferCommands3NotImpl)

public:

	typedef IVsProfferCommands3 Interface;

	STDMETHOD(AddNamedCommand)(
		/*[in]*/ const GUID* /*pguidPackage*/,
		/*[in]*/ const GUID* /*pguidCmdGroup*/,
		/*[in,string]*/ const LPCOLESTR /*pszCmdNameCanonical*/,
		/*[out]*/ DWORD* /*pdwCmdId*/,
		/*[in,string]*/ const LPCOLESTR /*pszCmdNameLocalized*/,
		/*[in,string]*/ const LPCOLESTR /*pszBtnText*/,
		/*[in,string]*/ const LPCOLESTR /*pszCmdTooltip*/,
		/*[in,string]*/ const LPCOLESTR /*pszSatelliteDLL*/,
		/*[in]*/ DWORD /*dwBitmapResourceId*/,
		/*[in]*/ DWORD /*dwBitmapImageIndex*/,
		/*[in]*/ DWORD /*dwCmdFlagsDefault*/,
		/*[in]*/ DWORD /*cUIContexts*/,
		/*[in,size_is(cUIContexts)]*/ const GUID* /*rgguidUIContexts*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveNamedCommand)(
		/*[in,string]*/ const LPCOLESTR /*pszCmdNameCanonical*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RenameNamedCommand)(
		/*[in,string]*/ const LPCOLESTR /*pszCmdNameCanonical*/,
		/*[in,string]*/ const LPCOLESTR /*pszCmdNameCanonicalNew*/,
		/*[in,string]*/ const LPCOLESTR /*pszCmdNameLocalizedNew*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddCommandBarControl)(
		/*[in,string]*/ const LPCOLESTR /*pszCmdNameCanonical*/,
		/*[in]*/ IDispatch* /*pCmdBarParent*/,
		/*[in]*/ DWORD /*dwIndex*/,
		/*[in]*/ DWORD /*dwCmdType*/,
		/*[out]*/ IDispatch** /*ppCmdBarCtrl*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveCommandBarControl)(
		/*[in]*/ IDispatch* /*pCmdBarCtrl*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddCommandBar)(
		/*[in,string]*/ const LPCOLESTR /*pszCmdBarName*/,
		/*[in]*/ DWORD /*dwType*/,
		/*[in]*/ IDispatch* /*pCmdBarParent*/,
		/*[in]*/ DWORD /*dwIndex*/,
		/*[out]*/ IDispatch** /*ppCmdBar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveCommandBar)(
		/*[in]*/ IDispatch* /*pCmdBar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FindCommandBar)(
		/*[in]*/ IUnknown* /*pToolbarSet*/,
		/*[in]*/ const GUID* /*pguidCmdGroup*/,
		/*[in]*/ DWORD /*dwMenuId*/,
		/*[out,retval]*/ IDispatch** /*ppdispCmdBar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddNamedCommand2)(
		/*[in]*/ const GUID* /*pguidPackage*/,
		/*[in]*/ const GUID* /*pguidCmdGroup*/,
		/*[in,string]*/ const LPCOLESTR /*pszCmdNameCanonical*/,
		/*[out]*/ DWORD* /*pdwCmdId*/,
		/*[in,string]*/ const LPCOLESTR /*pszCmdNameLocalized*/,
		/*[in,string]*/ const LPCOLESTR /*pszBtnText*/,
		/*[in,string]*/ const LPCOLESTR /*pszCmdTooltip*/,
		/*[in,string]*/ const LPCOLESTR /*pszSatelliteDLL*/,
		/*[in]*/ DWORD /*dwBitmapResourceId*/,
		/*[in]*/ DWORD /*dwBitmapImageIndex*/,
		/*[in]*/ DWORD /*dwCmdFlagsDefault*/,
		/*[in]*/ DWORD /*cUIContexts*/,
		/*[in,size_is(cUIContexts)]*/ const GUID* /*rgguidUIContexts*/,
		/*[in]*/ DWORD /*dwUIElementType*/)VSL_STDMETHOD_NOTIMPL
};

class IVsProfferCommands3MockImpl :
	public IVsProfferCommands3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProfferCommands3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsProfferCommands3MockImpl)

	typedef IVsProfferCommands3 Interface;
	struct AddNamedCommandValidValues
	{
		/*[in]*/ GUID* pguidPackage;
		/*[in]*/ GUID* pguidCmdGroup;
		/*[in,string]*/ LPCOLESTR pszCmdNameCanonical;
		/*[out]*/ DWORD* pdwCmdId;
		/*[in,string]*/ LPCOLESTR pszCmdNameLocalized;
		/*[in,string]*/ LPCOLESTR pszBtnText;
		/*[in,string]*/ LPCOLESTR pszCmdTooltip;
		/*[in,string]*/ LPCOLESTR pszSatelliteDLL;
		/*[in]*/ DWORD dwBitmapResourceId;
		/*[in]*/ DWORD dwBitmapImageIndex;
		/*[in]*/ DWORD dwCmdFlagsDefault;
		/*[in]*/ DWORD cUIContexts;
		/*[in,size_is(cUIContexts)]*/ GUID* rgguidUIContexts;
		HRESULT retValue;
	};

	STDMETHOD(AddNamedCommand)(
		/*[in]*/ const GUID* pguidPackage,
		/*[in]*/ const GUID* pguidCmdGroup,
		/*[in,string]*/ const LPCOLESTR pszCmdNameCanonical,
		/*[out]*/ DWORD* pdwCmdId,
		/*[in,string]*/ const LPCOLESTR pszCmdNameLocalized,
		/*[in,string]*/ const LPCOLESTR pszBtnText,
		/*[in,string]*/ const LPCOLESTR pszCmdTooltip,
		/*[in,string]*/ const LPCOLESTR pszSatelliteDLL,
		/*[in]*/ DWORD dwBitmapResourceId,
		/*[in]*/ DWORD dwBitmapImageIndex,
		/*[in]*/ DWORD dwCmdFlagsDefault,
		/*[in]*/ DWORD cUIContexts,
		/*[in,size_is(cUIContexts)]*/ const GUID* rgguidUIContexts)
	{
		VSL_DEFINE_MOCK_METHOD(AddNamedCommand)

		VSL_CHECK_VALIDVALUE_POINTER(pguidPackage);

		VSL_CHECK_VALIDVALUE_POINTER(pguidCmdGroup);

		VSL_CHECK_VALIDVALUE_STRINGW(pszCmdNameCanonical);

		VSL_SET_VALIDVALUE(pdwCmdId);

		VSL_CHECK_VALIDVALUE_STRINGW(pszCmdNameLocalized);

		VSL_CHECK_VALIDVALUE_STRINGW(pszBtnText);

		VSL_CHECK_VALIDVALUE_STRINGW(pszCmdTooltip);

		VSL_CHECK_VALIDVALUE_STRINGW(pszSatelliteDLL);

		VSL_CHECK_VALIDVALUE(dwBitmapResourceId);

		VSL_CHECK_VALIDVALUE(dwBitmapImageIndex);

		VSL_CHECK_VALIDVALUE(dwCmdFlagsDefault);

		VSL_CHECK_VALIDVALUE(cUIContexts);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgguidUIContexts, cUIContexts*sizeof(rgguidUIContexts[0]), validValues.cUIContexts*sizeof(validValues.rgguidUIContexts[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveNamedCommandValidValues
	{
		/*[in,string]*/ LPCOLESTR pszCmdNameCanonical;
		HRESULT retValue;
	};

	STDMETHOD(RemoveNamedCommand)(
		/*[in,string]*/ const LPCOLESTR pszCmdNameCanonical)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveNamedCommand)

		VSL_CHECK_VALIDVALUE_STRINGW(pszCmdNameCanonical);

		VSL_RETURN_VALIDVALUES();
	}
	struct RenameNamedCommandValidValues
	{
		/*[in,string]*/ LPCOLESTR pszCmdNameCanonical;
		/*[in,string]*/ LPCOLESTR pszCmdNameCanonicalNew;
		/*[in,string]*/ LPCOLESTR pszCmdNameLocalizedNew;
		HRESULT retValue;
	};

	STDMETHOD(RenameNamedCommand)(
		/*[in,string]*/ const LPCOLESTR pszCmdNameCanonical,
		/*[in,string]*/ const LPCOLESTR pszCmdNameCanonicalNew,
		/*[in,string]*/ const LPCOLESTR pszCmdNameLocalizedNew)
	{
		VSL_DEFINE_MOCK_METHOD(RenameNamedCommand)

		VSL_CHECK_VALIDVALUE_STRINGW(pszCmdNameCanonical);

		VSL_CHECK_VALIDVALUE_STRINGW(pszCmdNameCanonicalNew);

		VSL_CHECK_VALIDVALUE_STRINGW(pszCmdNameLocalizedNew);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddCommandBarControlValidValues
	{
		/*[in,string]*/ LPCOLESTR pszCmdNameCanonical;
		/*[in]*/ IDispatch* pCmdBarParent;
		/*[in]*/ DWORD dwIndex;
		/*[in]*/ DWORD dwCmdType;
		/*[out]*/ IDispatch** ppCmdBarCtrl;
		HRESULT retValue;
	};

	STDMETHOD(AddCommandBarControl)(
		/*[in,string]*/ const LPCOLESTR pszCmdNameCanonical,
		/*[in]*/ IDispatch* pCmdBarParent,
		/*[in]*/ DWORD dwIndex,
		/*[in]*/ DWORD dwCmdType,
		/*[out]*/ IDispatch** ppCmdBarCtrl)
	{
		VSL_DEFINE_MOCK_METHOD(AddCommandBarControl)

		VSL_CHECK_VALIDVALUE_STRINGW(pszCmdNameCanonical);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCmdBarParent);

		VSL_CHECK_VALIDVALUE(dwIndex);

		VSL_CHECK_VALIDVALUE(dwCmdType);

		VSL_SET_VALIDVALUE_INTERFACE(ppCmdBarCtrl);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveCommandBarControlValidValues
	{
		/*[in]*/ IDispatch* pCmdBarCtrl;
		HRESULT retValue;
	};

	STDMETHOD(RemoveCommandBarControl)(
		/*[in]*/ IDispatch* pCmdBarCtrl)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveCommandBarControl)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCmdBarCtrl);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddCommandBarValidValues
	{
		/*[in,string]*/ LPCOLESTR pszCmdBarName;
		/*[in]*/ DWORD dwType;
		/*[in]*/ IDispatch* pCmdBarParent;
		/*[in]*/ DWORD dwIndex;
		/*[out]*/ IDispatch** ppCmdBar;
		HRESULT retValue;
	};

	STDMETHOD(AddCommandBar)(
		/*[in,string]*/ const LPCOLESTR pszCmdBarName,
		/*[in]*/ DWORD dwType,
		/*[in]*/ IDispatch* pCmdBarParent,
		/*[in]*/ DWORD dwIndex,
		/*[out]*/ IDispatch** ppCmdBar)
	{
		VSL_DEFINE_MOCK_METHOD(AddCommandBar)

		VSL_CHECK_VALIDVALUE_STRINGW(pszCmdBarName);

		VSL_CHECK_VALIDVALUE(dwType);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCmdBarParent);

		VSL_CHECK_VALIDVALUE(dwIndex);

		VSL_SET_VALIDVALUE_INTERFACE(ppCmdBar);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveCommandBarValidValues
	{
		/*[in]*/ IDispatch* pCmdBar;
		HRESULT retValue;
	};

	STDMETHOD(RemoveCommandBar)(
		/*[in]*/ IDispatch* pCmdBar)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveCommandBar)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCmdBar);

		VSL_RETURN_VALIDVALUES();
	}
	struct FindCommandBarValidValues
	{
		/*[in]*/ IUnknown* pToolbarSet;
		/*[in]*/ GUID* pguidCmdGroup;
		/*[in]*/ DWORD dwMenuId;
		/*[out,retval]*/ IDispatch** ppdispCmdBar;
		HRESULT retValue;
	};

	STDMETHOD(FindCommandBar)(
		/*[in]*/ IUnknown* pToolbarSet,
		/*[in]*/ const GUID* pguidCmdGroup,
		/*[in]*/ DWORD dwMenuId,
		/*[out,retval]*/ IDispatch** ppdispCmdBar)
	{
		VSL_DEFINE_MOCK_METHOD(FindCommandBar)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pToolbarSet);

		VSL_CHECK_VALIDVALUE_POINTER(pguidCmdGroup);

		VSL_CHECK_VALIDVALUE(dwMenuId);

		VSL_SET_VALIDVALUE_INTERFACE(ppdispCmdBar);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddNamedCommand2ValidValues
	{
		/*[in]*/ GUID* pguidPackage;
		/*[in]*/ GUID* pguidCmdGroup;
		/*[in,string]*/ LPCOLESTR pszCmdNameCanonical;
		/*[out]*/ DWORD* pdwCmdId;
		/*[in,string]*/ LPCOLESTR pszCmdNameLocalized;
		/*[in,string]*/ LPCOLESTR pszBtnText;
		/*[in,string]*/ LPCOLESTR pszCmdTooltip;
		/*[in,string]*/ LPCOLESTR pszSatelliteDLL;
		/*[in]*/ DWORD dwBitmapResourceId;
		/*[in]*/ DWORD dwBitmapImageIndex;
		/*[in]*/ DWORD dwCmdFlagsDefault;
		/*[in]*/ DWORD cUIContexts;
		/*[in,size_is(cUIContexts)]*/ GUID* rgguidUIContexts;
		/*[in]*/ DWORD dwUIElementType;
		HRESULT retValue;
	};

	STDMETHOD(AddNamedCommand2)(
		/*[in]*/ const GUID* pguidPackage,
		/*[in]*/ const GUID* pguidCmdGroup,
		/*[in,string]*/ const LPCOLESTR pszCmdNameCanonical,
		/*[out]*/ DWORD* pdwCmdId,
		/*[in,string]*/ const LPCOLESTR pszCmdNameLocalized,
		/*[in,string]*/ const LPCOLESTR pszBtnText,
		/*[in,string]*/ const LPCOLESTR pszCmdTooltip,
		/*[in,string]*/ const LPCOLESTR pszSatelliteDLL,
		/*[in]*/ DWORD dwBitmapResourceId,
		/*[in]*/ DWORD dwBitmapImageIndex,
		/*[in]*/ DWORD dwCmdFlagsDefault,
		/*[in]*/ DWORD cUIContexts,
		/*[in,size_is(cUIContexts)]*/ const GUID* rgguidUIContexts,
		/*[in]*/ DWORD dwUIElementType)
	{
		VSL_DEFINE_MOCK_METHOD(AddNamedCommand2)

		VSL_CHECK_VALIDVALUE_POINTER(pguidPackage);

		VSL_CHECK_VALIDVALUE_POINTER(pguidCmdGroup);

		VSL_CHECK_VALIDVALUE_STRINGW(pszCmdNameCanonical);

		VSL_SET_VALIDVALUE(pdwCmdId);

		VSL_CHECK_VALIDVALUE_STRINGW(pszCmdNameLocalized);

		VSL_CHECK_VALIDVALUE_STRINGW(pszBtnText);

		VSL_CHECK_VALIDVALUE_STRINGW(pszCmdTooltip);

		VSL_CHECK_VALIDVALUE_STRINGW(pszSatelliteDLL);

		VSL_CHECK_VALIDVALUE(dwBitmapResourceId);

		VSL_CHECK_VALIDVALUE(dwBitmapImageIndex);

		VSL_CHECK_VALIDVALUE(dwCmdFlagsDefault);

		VSL_CHECK_VALIDVALUE(cUIContexts);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgguidUIContexts, cUIContexts*sizeof(rgguidUIContexts[0]), validValues.cUIContexts*sizeof(validValues.rgguidUIContexts[0]));

		VSL_CHECK_VALIDVALUE(dwUIElementType);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROFFERCOMMANDS3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsProject.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsProjectNotImpl :
	public IVsProject
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectNotImpl)

public:

	typedef IVsProject Interface;

	STDMETHOD(IsDocumentInProject)(
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[out]*/ BOOL* /*pfFound*/,
		/*[out]*/ VSDOCUMENTPRIORITY* /*pdwPriority*/,
		/*[out]*/ VSITEMID* /*pitemid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMkDocument)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[out]*/ BSTR* /*pbstrMkDocument*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OpenItem)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ REFGUID /*rguidLogicalView*/,
		/*[in]*/ IUnknown* /*punkDocDataExisting*/,
		/*[out]*/ IVsWindowFrame** /*ppWindowFrame*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetItemContext)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[out]*/ IServiceProvider** /*ppSP*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GenerateUniqueItemName)(
		/*[in]*/ VSITEMID /*itemidLoc*/,
		/*[in]*/ LPCOLESTR /*pszExt*/,
		/*[in]*/ LPCOLESTR /*pszSuggestedRoot*/,
		/*[out]*/ BSTR* /*pbstrItemName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddItem)(
		/*[in]*/ VSITEMID /*itemidLoc*/,
		/*[in]*/ VSADDITEMOPERATION /*dwAddItemOperation*/,
		/*[in]*/ LPCOLESTR /*pszItemName*/,
		/*[in]*/ ULONG /*cFilesToOpen*/,
		/*[in,size_is(cFilesToOpen)]*/ LPCOLESTR[] /*rgpszFilesToOpen*/,
		/*[in]*/ HWND /*hwndDlgOwner*/,
		/*[out,retval]*/ VSADDRESULT* /*pResult*/)VSL_STDMETHOD_NOTIMPL
};

class IVsProjectMockImpl :
	public IVsProject,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsProjectMockImpl)

	typedef IVsProject Interface;
	struct IsDocumentInProjectValidValues
	{
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[out]*/ BOOL* pfFound;
		/*[out]*/ VSDOCUMENTPRIORITY* pdwPriority;
		/*[out]*/ VSITEMID* pitemid;
		HRESULT retValue;
	};

	STDMETHOD(IsDocumentInProject)(
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[out]*/ BOOL* pfFound,
		/*[out]*/ VSDOCUMENTPRIORITY* pdwPriority,
		/*[out]*/ VSITEMID* pitemid)
	{
		VSL_DEFINE_MOCK_METHOD(IsDocumentInProject)

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_SET_VALIDVALUE(pfFound);

		VSL_SET_VALIDVALUE(pdwPriority);

		VSL_SET_VALIDVALUE(pitemid);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMkDocumentValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[out]*/ BSTR* pbstrMkDocument;
		HRESULT retValue;
	};

	STDMETHOD(GetMkDocument)(
		/*[in]*/ VSITEMID itemid,
		/*[out]*/ BSTR* pbstrMkDocument)
	{
		VSL_DEFINE_MOCK_METHOD(GetMkDocument)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_SET_VALIDVALUE_BSTR(pbstrMkDocument);

		VSL_RETURN_VALIDVALUES();
	}
	struct OpenItemValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ REFGUID rguidLogicalView;
		/*[in]*/ IUnknown* punkDocDataExisting;
		/*[out]*/ IVsWindowFrame** ppWindowFrame;
		HRESULT retValue;
	};

	STDMETHOD(OpenItem)(
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ REFGUID rguidLogicalView,
		/*[in]*/ IUnknown* punkDocDataExisting,
		/*[out]*/ IVsWindowFrame** ppWindowFrame)
	{
		VSL_DEFINE_MOCK_METHOD(OpenItem)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE(rguidLogicalView);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkDocDataExisting);

		VSL_SET_VALIDVALUE_INTERFACE(ppWindowFrame);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetItemContextValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[out]*/ IServiceProvider** ppSP;
		HRESULT retValue;
	};

	STDMETHOD(GetItemContext)(
		/*[in]*/ VSITEMID itemid,
		/*[out]*/ IServiceProvider** ppSP)
	{
		VSL_DEFINE_MOCK_METHOD(GetItemContext)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_SET_VALIDVALUE_INTERFACE(ppSP);

		VSL_RETURN_VALIDVALUES();
	}
	struct GenerateUniqueItemNameValidValues
	{
		/*[in]*/ VSITEMID itemidLoc;
		/*[in]*/ LPCOLESTR pszExt;
		/*[in]*/ LPCOLESTR pszSuggestedRoot;
		/*[out]*/ BSTR* pbstrItemName;
		HRESULT retValue;
	};

	STDMETHOD(GenerateUniqueItemName)(
		/*[in]*/ VSITEMID itemidLoc,
		/*[in]*/ LPCOLESTR pszExt,
		/*[in]*/ LPCOLESTR pszSuggestedRoot,
		/*[out]*/ BSTR* pbstrItemName)
	{
		VSL_DEFINE_MOCK_METHOD(GenerateUniqueItemName)

		VSL_CHECK_VALIDVALUE(itemidLoc);

		VSL_CHECK_VALIDVALUE_STRINGW(pszExt);

		VSL_CHECK_VALIDVALUE_STRINGW(pszSuggestedRoot);

		VSL_SET_VALIDVALUE_BSTR(pbstrItemName);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddItemValidValues
	{
		/*[in]*/ VSITEMID itemidLoc;
		/*[in]*/ VSADDITEMOPERATION dwAddItemOperation;
		/*[in]*/ LPCOLESTR pszItemName;
		/*[in]*/ ULONG cFilesToOpen;
		/*[in,size_is(cFilesToOpen)]*/ LPCOLESTR* rgpszFilesToOpen;
		/*[in]*/ HWND hwndDlgOwner;
		/*[out,retval]*/ VSADDRESULT* pResult;
		HRESULT retValue;
	};

	STDMETHOD(AddItem)(
		/*[in]*/ VSITEMID itemidLoc,
		/*[in]*/ VSADDITEMOPERATION dwAddItemOperation,
		/*[in]*/ LPCOLESTR pszItemName,
		/*[in]*/ ULONG cFilesToOpen,
		/*[in,size_is(cFilesToOpen)]*/ LPCOLESTR rgpszFilesToOpen[],
		/*[in]*/ HWND hwndDlgOwner,
		/*[out,retval]*/ VSADDRESULT* pResult)
	{
		VSL_DEFINE_MOCK_METHOD(AddItem)

		VSL_CHECK_VALIDVALUE(itemidLoc);

		VSL_CHECK_VALIDVALUE(dwAddItemOperation);

		VSL_CHECK_VALIDVALUE_STRINGW(pszItemName);

		VSL_CHECK_VALIDVALUE(cFilesToOpen);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszFilesToOpen, cFilesToOpen*sizeof(rgpszFilesToOpen[0]), validValues.cFilesToOpen*sizeof(validValues.rgpszFilesToOpen[0]));

		VSL_CHECK_VALIDVALUE(hwndDlgOwner);

		VSL_SET_VALIDVALUE(pResult);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsProject2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROJECT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROJECT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsProject2NotImpl :
	public IVsProject2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProject2NotImpl)

public:

	typedef IVsProject2 Interface;

	STDMETHOD(RemoveItem)(
		/*[in]*/ DWORD /*dwReserved*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[out,retval]*/ BOOL* /*pfResult*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReopenItem)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ REFGUID /*rguidEditorType*/,
		/*[in]*/ LPCOLESTR /*pszPhysicalView*/,
		/*[in]*/ REFGUID /*rguidLogicalView*/,
		/*[in]*/ IUnknown* /*punkDocDataExisting*/,
		/*[out,retval]*/ IVsWindowFrame** /*ppWindowFrame*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsDocumentInProject)(
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[out]*/ BOOL* /*pfFound*/,
		/*[out]*/ VSDOCUMENTPRIORITY* /*pdwPriority*/,
		/*[out]*/ VSITEMID* /*pitemid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMkDocument)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[out]*/ BSTR* /*pbstrMkDocument*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OpenItem)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ REFGUID /*rguidLogicalView*/,
		/*[in]*/ IUnknown* /*punkDocDataExisting*/,
		/*[out]*/ IVsWindowFrame** /*ppWindowFrame*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetItemContext)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[out]*/ IServiceProvider** /*ppSP*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GenerateUniqueItemName)(
		/*[in]*/ VSITEMID /*itemidLoc*/,
		/*[in]*/ LPCOLESTR /*pszExt*/,
		/*[in]*/ LPCOLESTR /*pszSuggestedRoot*/,
		/*[out]*/ BSTR* /*pbstrItemName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddItem)(
		/*[in]*/ VSITEMID /*itemidLoc*/,
		/*[in]*/ VSADDITEMOPERATION /*dwAddItemOperation*/,
		/*[in]*/ LPCOLESTR /*pszItemName*/,
		/*[in]*/ ULONG /*cFilesToOpen*/,
		/*[in,size_is(cFilesToOpen)]*/ LPCOLESTR[] /*rgpszFilesToOpen*/,
		/*[in]*/ HWND /*hwndDlgOwner*/,
		/*[out,retval]*/ VSADDRESULT* /*pResult*/)VSL_STDMETHOD_NOTIMPL
};

class IVsProject2MockImpl :
	public IVsProject2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProject2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsProject2MockImpl)

	typedef IVsProject2 Interface;
	struct RemoveItemValidValues
	{
		/*[in]*/ DWORD dwReserved;
		/*[in]*/ VSITEMID itemid;
		/*[out,retval]*/ BOOL* pfResult;
		HRESULT retValue;
	};

	STDMETHOD(RemoveItem)(
		/*[in]*/ DWORD dwReserved,
		/*[in]*/ VSITEMID itemid,
		/*[out,retval]*/ BOOL* pfResult)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveItem)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_SET_VALIDVALUE(pfResult);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReopenItemValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ REFGUID rguidEditorType;
		/*[in]*/ LPCOLESTR pszPhysicalView;
		/*[in]*/ REFGUID rguidLogicalView;
		/*[in]*/ IUnknown* punkDocDataExisting;
		/*[out,retval]*/ IVsWindowFrame** ppWindowFrame;
		HRESULT retValue;
	};

	STDMETHOD(ReopenItem)(
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ REFGUID rguidEditorType,
		/*[in]*/ LPCOLESTR pszPhysicalView,
		/*[in]*/ REFGUID rguidLogicalView,
		/*[in]*/ IUnknown* punkDocDataExisting,
		/*[out,retval]*/ IVsWindowFrame** ppWindowFrame)
	{
		VSL_DEFINE_MOCK_METHOD(ReopenItem)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE(rguidEditorType);

		VSL_CHECK_VALIDVALUE_STRINGW(pszPhysicalView);

		VSL_CHECK_VALIDVALUE(rguidLogicalView);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkDocDataExisting);

		VSL_SET_VALIDVALUE_INTERFACE(ppWindowFrame);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsDocumentInProjectValidValues
	{
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[out]*/ BOOL* pfFound;
		/*[out]*/ VSDOCUMENTPRIORITY* pdwPriority;
		/*[out]*/ VSITEMID* pitemid;
		HRESULT retValue;
	};

	STDMETHOD(IsDocumentInProject)(
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[out]*/ BOOL* pfFound,
		/*[out]*/ VSDOCUMENTPRIORITY* pdwPriority,
		/*[out]*/ VSITEMID* pitemid)
	{
		VSL_DEFINE_MOCK_METHOD(IsDocumentInProject)

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_SET_VALIDVALUE(pfFound);

		VSL_SET_VALIDVALUE(pdwPriority);

		VSL_SET_VALIDVALUE(pitemid);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMkDocumentValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[out]*/ BSTR* pbstrMkDocument;
		HRESULT retValue;
	};

	STDMETHOD(GetMkDocument)(
		/*[in]*/ VSITEMID itemid,
		/*[out]*/ BSTR* pbstrMkDocument)
	{
		VSL_DEFINE_MOCK_METHOD(GetMkDocument)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_SET_VALIDVALUE_BSTR(pbstrMkDocument);

		VSL_RETURN_VALIDVALUES();
	}
	struct OpenItemValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ REFGUID rguidLogicalView;
		/*[in]*/ IUnknown* punkDocDataExisting;
		/*[out]*/ IVsWindowFrame** ppWindowFrame;
		HRESULT retValue;
	};

	STDMETHOD(OpenItem)(
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ REFGUID rguidLogicalView,
		/*[in]*/ IUnknown* punkDocDataExisting,
		/*[out]*/ IVsWindowFrame** ppWindowFrame)
	{
		VSL_DEFINE_MOCK_METHOD(OpenItem)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE(rguidLogicalView);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkDocDataExisting);

		VSL_SET_VALIDVALUE_INTERFACE(ppWindowFrame);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetItemContextValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[out]*/ IServiceProvider** ppSP;
		HRESULT retValue;
	};

	STDMETHOD(GetItemContext)(
		/*[in]*/ VSITEMID itemid,
		/*[out]*/ IServiceProvider** ppSP)
	{
		VSL_DEFINE_MOCK_METHOD(GetItemContext)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_SET_VALIDVALUE_INTERFACE(ppSP);

		VSL_RETURN_VALIDVALUES();
	}
	struct GenerateUniqueItemNameValidValues
	{
		/*[in]*/ VSITEMID itemidLoc;
		/*[in]*/ LPCOLESTR pszExt;
		/*[in]*/ LPCOLESTR pszSuggestedRoot;
		/*[out]*/ BSTR* pbstrItemName;
		HRESULT retValue;
	};

	STDMETHOD(GenerateUniqueItemName)(
		/*[in]*/ VSITEMID itemidLoc,
		/*[in]*/ LPCOLESTR pszExt,
		/*[in]*/ LPCOLESTR pszSuggestedRoot,
		/*[out]*/ BSTR* pbstrItemName)
	{
		VSL_DEFINE_MOCK_METHOD(GenerateUniqueItemName)

		VSL_CHECK_VALIDVALUE(itemidLoc);

		VSL_CHECK_VALIDVALUE_STRINGW(pszExt);

		VSL_CHECK_VALIDVALUE_STRINGW(pszSuggestedRoot);

		VSL_SET_VALIDVALUE_BSTR(pbstrItemName);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddItemValidValues
	{
		/*[in]*/ VSITEMID itemidLoc;
		/*[in]*/ VSADDITEMOPERATION dwAddItemOperation;
		/*[in]*/ LPCOLESTR pszItemName;
		/*[in]*/ ULONG cFilesToOpen;
		/*[in,size_is(cFilesToOpen)]*/ LPCOLESTR* rgpszFilesToOpen;
		/*[in]*/ HWND hwndDlgOwner;
		/*[out,retval]*/ VSADDRESULT* pResult;
		HRESULT retValue;
	};

	STDMETHOD(AddItem)(
		/*[in]*/ VSITEMID itemidLoc,
		/*[in]*/ VSADDITEMOPERATION dwAddItemOperation,
		/*[in]*/ LPCOLESTR pszItemName,
		/*[in]*/ ULONG cFilesToOpen,
		/*[in,size_is(cFilesToOpen)]*/ LPCOLESTR rgpszFilesToOpen[],
		/*[in]*/ HWND hwndDlgOwner,
		/*[out,retval]*/ VSADDRESULT* pResult)
	{
		VSL_DEFINE_MOCK_METHOD(AddItem)

		VSL_CHECK_VALIDVALUE(itemidLoc);

		VSL_CHECK_VALIDVALUE(dwAddItemOperation);

		VSL_CHECK_VALIDVALUE_STRINGW(pszItemName);

		VSL_CHECK_VALIDVALUE(cFilesToOpen);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszFilesToOpen, cFilesToOpen*sizeof(rgpszFilesToOpen[0]), validValues.cFilesToOpen*sizeof(validValues.rgpszFilesToOpen[0]));

		VSL_CHECK_VALIDVALUE(hwndDlgOwner);

		VSL_SET_VALIDVALUE(pResult);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROJECT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsProfilesManagerUI.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROFILESMANAGERUI_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROFILESMANAGERUI_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsProfilesManagerUINotImpl :
	public IVsProfilesManagerUI
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProfilesManagerUINotImpl)

public:

	typedef IVsProfilesManagerUI Interface;

	STDMETHOD(ShowProfilesUI)(
		/*[in]*/ IVsProfileDataManager* /*pDataManager*/)VSL_STDMETHOD_NOTIMPL
};

class IVsProfilesManagerUIMockImpl :
	public IVsProfilesManagerUI,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProfilesManagerUIMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsProfilesManagerUIMockImpl)

	typedef IVsProfilesManagerUI Interface;
	struct ShowProfilesUIValidValues
	{
		/*[in]*/ IVsProfileDataManager* pDataManager;
		HRESULT retValue;
	};

	STDMETHOD(ShowProfilesUI)(
		/*[in]*/ IVsProfileDataManager* pDataManager)
	{
		VSL_DEFINE_MOCK_METHOD(ShowProfilesUI)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDataManager);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROFILESMANAGERUI_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsProjectBuildSystem.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROJECTBUILDSYSTEM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROJECTBUILDSYSTEM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsProjectBuildSystemNotImpl :
	public IVsProjectBuildSystem
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectBuildSystemNotImpl)

public:

	typedef IVsProjectBuildSystem Interface;

	STDMETHOD(SetHostObject)(
		/*[in]*/ LPCOLESTR /*pszTargetName*/,
		/*[in]*/ LPCOLESTR /*pszTaskName*/,
		/*[in]*/ IUnknown* /*punkHostObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(StartBatchEdit)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EndBatchEdit)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CancelBatchEdit)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(BuildTarget)(
		/*[in]*/ LPCOLESTR /*pszTargetName*/,
		/*[out,retval]*/ VARIANT_BOOL* /*pbSuccess*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBuildSystemKind)(
		/*[out,retval]*/ BuildSystemKindFlags* /*pBuildSystemKind*/)VSL_STDMETHOD_NOTIMPL
};

class IVsProjectBuildSystemMockImpl :
	public IVsProjectBuildSystem,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectBuildSystemMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsProjectBuildSystemMockImpl)

	typedef IVsProjectBuildSystem Interface;
	struct SetHostObjectValidValues
	{
		/*[in]*/ LPCOLESTR pszTargetName;
		/*[in]*/ LPCOLESTR pszTaskName;
		/*[in]*/ IUnknown* punkHostObject;
		HRESULT retValue;
	};

	STDMETHOD(SetHostObject)(
		/*[in]*/ LPCOLESTR pszTargetName,
		/*[in]*/ LPCOLESTR pszTaskName,
		/*[in]*/ IUnknown* punkHostObject)
	{
		VSL_DEFINE_MOCK_METHOD(SetHostObject)

		VSL_CHECK_VALIDVALUE_STRINGW(pszTargetName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszTaskName);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkHostObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct StartBatchEditValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(StartBatchEdit)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(StartBatchEdit)

		VSL_RETURN_VALIDVALUES();
	}
	struct EndBatchEditValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(EndBatchEdit)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(EndBatchEdit)

		VSL_RETURN_VALIDVALUES();
	}
	struct CancelBatchEditValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CancelBatchEdit)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CancelBatchEdit)

		VSL_RETURN_VALIDVALUES();
	}
	struct BuildTargetValidValues
	{
		/*[in]*/ LPCOLESTR pszTargetName;
		/*[out,retval]*/ VARIANT_BOOL* pbSuccess;
		HRESULT retValue;
	};

	STDMETHOD(BuildTarget)(
		/*[in]*/ LPCOLESTR pszTargetName,
		/*[out,retval]*/ VARIANT_BOOL* pbSuccess)
	{
		VSL_DEFINE_MOCK_METHOD(BuildTarget)

		VSL_CHECK_VALIDVALUE_STRINGW(pszTargetName);

		VSL_SET_VALIDVALUE(pbSuccess);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBuildSystemKindValidValues
	{
		/*[out,retval]*/ BuildSystemKindFlags* pBuildSystemKind;
		HRESULT retValue;
	};

	STDMETHOD(GetBuildSystemKind)(
		/*[out,retval]*/ BuildSystemKindFlags* pBuildSystemKind)
	{
		VSL_DEFINE_MOCK_METHOD(GetBuildSystemKind)

		VSL_SET_VALIDVALUE(pBuildSystemKind);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROJECTBUILDSYSTEM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsProjectCfg2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROJECTCFG2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROJECTCFG2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsProjectCfg2NotImpl :
	public IVsProjectCfg2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectCfg2NotImpl)

public:

	typedef IVsProjectCfg2 Interface;

	STDMETHOD(get_CfgType)(
		/*[in]*/ REFIID /*iidCfg*/,
		/*[out,iid_is(iidCfg)]*/ void** /*ppCfg*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_OutputGroups)(
		/*[in]*/ ULONG /*celt*/,
		/*[in,out,size_is(celt)]*/ IVsOutputGroup*[] /*rgpcfg*/,
		/*[out,optional]*/ ULONG* /*pcActual*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OpenOutputGroup)(
		/*[in]*/ LPCOLESTR /*szCanonicalName*/,
		/*[out]*/ IVsOutputGroup** /*ppIVsOutputGroup*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OutputsRequireAppRoot)(
		/*[out]*/ BOOL* /*pfRequiresAppRoot*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_VirtualRoot)(
		/*[out]*/ BSTR* /*pbstrVRoot*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IsPrivate)(
		/*[out]*/ BOOL* /*pfPrivate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumOutputs)(
		/*[out]*/ IVsEnumOutputs** /*ppIVsEnumOutputs*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OpenOutput)(
		/*[in]*/ LPCOLESTR /*szOutputCanonicalName*/,
		/*[out]*/ IVsOutput** /*ppIVsOutput*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ProjectCfgProvider)(
		/*[out]*/ IVsProjectCfgProvider** /*ppIVsProjectCfgProvider*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_BuildableProjectCfg)(
		/*[out]*/ IVsBuildableProjectCfg** /*ppIVsBuildableProjectCfg*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CanonicalName)(
		/*[out]*/ BSTR* /*pbstrCanonicalName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Platform)(
		/*[out]*/ GUID* /*pguidPlatform*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IsPackaged)(
		/*[out]*/ BOOL* /*pfIsPackaged*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IsSpecifyingOutputSupported)(
		/*[out]*/ BOOL* /*pfIsSpecifyingOutputSupported*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_TargetCodePage)(
		/*[out]*/ UINT* /*puiTargetCodePage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_UpdateSequenceNumber)(
		/*[out]*/ ULARGE_INTEGER* /*puliUSN*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RootURL)(
		/*[out]*/ BSTR* /*pbstrRootURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DisplayName)(
		/*[out]*/ BSTR* /*pbstrDisplayName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IsDebugOnly)(
		/*[out]*/ BOOL* /*pfIsDebugOnly*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IsReleaseOnly)(
		/*[out]*/ BOOL* /*pfIsReleaseOnly*/)VSL_STDMETHOD_NOTIMPL
};

class IVsProjectCfg2MockImpl :
	public IVsProjectCfg2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectCfg2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsProjectCfg2MockImpl)

	typedef IVsProjectCfg2 Interface;
	struct get_CfgTypeValidValues
	{
		/*[in]*/ REFIID iidCfg;
		/*[out,iid_is(iidCfg)]*/ void** ppCfg;
		HRESULT retValue;
	};

	STDMETHOD(get_CfgType)(
		/*[in]*/ REFIID iidCfg,
		/*[out,iid_is(iidCfg)]*/ void** ppCfg)
	{
		VSL_DEFINE_MOCK_METHOD(get_CfgType)

		VSL_CHECK_VALIDVALUE(iidCfg);

		VSL_SET_VALIDVALUE(ppCfg);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OutputGroupsValidValues
	{
		/*[in]*/ ULONG celt;
		/*[in,out,size_is(celt)]*/ IVsOutputGroup** rgpcfg;
		/*[out,optional]*/ ULONG* pcActual;
		HRESULT retValue;
	};

	STDMETHOD(get_OutputGroups)(
		/*[in]*/ ULONG celt,
		/*[in,out,size_is(celt)]*/ IVsOutputGroup* rgpcfg[],
		/*[out,optional]*/ ULONG* pcActual)
	{
		VSL_DEFINE_MOCK_METHOD(get_OutputGroups)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgpcfg, celt, validValues.celt);

		VSL_SET_VALIDVALUE(pcActual);

		VSL_RETURN_VALIDVALUES();
	}
	struct OpenOutputGroupValidValues
	{
		/*[in]*/ LPCOLESTR szCanonicalName;
		/*[out]*/ IVsOutputGroup** ppIVsOutputGroup;
		HRESULT retValue;
	};

	STDMETHOD(OpenOutputGroup)(
		/*[in]*/ LPCOLESTR szCanonicalName,
		/*[out]*/ IVsOutputGroup** ppIVsOutputGroup)
	{
		VSL_DEFINE_MOCK_METHOD(OpenOutputGroup)

		VSL_CHECK_VALIDVALUE_STRINGW(szCanonicalName);

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsOutputGroup);

		VSL_RETURN_VALIDVALUES();
	}
	struct OutputsRequireAppRootValidValues
	{
		/*[out]*/ BOOL* pfRequiresAppRoot;
		HRESULT retValue;
	};

	STDMETHOD(OutputsRequireAppRoot)(
		/*[out]*/ BOOL* pfRequiresAppRoot)
	{
		VSL_DEFINE_MOCK_METHOD(OutputsRequireAppRoot)

		VSL_SET_VALIDVALUE(pfRequiresAppRoot);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_VirtualRootValidValues
	{
		/*[out]*/ BSTR* pbstrVRoot;
		HRESULT retValue;
	};

	STDMETHOD(get_VirtualRoot)(
		/*[out]*/ BSTR* pbstrVRoot)
	{
		VSL_DEFINE_MOCK_METHOD(get_VirtualRoot)

		VSL_SET_VALIDVALUE_BSTR(pbstrVRoot);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IsPrivateValidValues
	{
		/*[out]*/ BOOL* pfPrivate;
		HRESULT retValue;
	};

	STDMETHOD(get_IsPrivate)(
		/*[out]*/ BOOL* pfPrivate)
	{
		VSL_DEFINE_MOCK_METHOD(get_IsPrivate)

		VSL_SET_VALIDVALUE(pfPrivate);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumOutputsValidValues
	{
		/*[out]*/ IVsEnumOutputs** ppIVsEnumOutputs;
		HRESULT retValue;
	};

	STDMETHOD(EnumOutputs)(
		/*[out]*/ IVsEnumOutputs** ppIVsEnumOutputs)
	{
		VSL_DEFINE_MOCK_METHOD(EnumOutputs)

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsEnumOutputs);

		VSL_RETURN_VALIDVALUES();
	}
	struct OpenOutputValidValues
	{
		/*[in]*/ LPCOLESTR szOutputCanonicalName;
		/*[out]*/ IVsOutput** ppIVsOutput;
		HRESULT retValue;
	};

	STDMETHOD(OpenOutput)(
		/*[in]*/ LPCOLESTR szOutputCanonicalName,
		/*[out]*/ IVsOutput** ppIVsOutput)
	{
		VSL_DEFINE_MOCK_METHOD(OpenOutput)

		VSL_CHECK_VALIDVALUE_STRINGW(szOutputCanonicalName);

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsOutput);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ProjectCfgProviderValidValues
	{
		/*[out]*/ IVsProjectCfgProvider** ppIVsProjectCfgProvider;
		HRESULT retValue;
	};

	STDMETHOD(get_ProjectCfgProvider)(
		/*[out]*/ IVsProjectCfgProvider** ppIVsProjectCfgProvider)
	{
		VSL_DEFINE_MOCK_METHOD(get_ProjectCfgProvider)

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsProjectCfgProvider);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_BuildableProjectCfgValidValues
	{
		/*[out]*/ IVsBuildableProjectCfg** ppIVsBuildableProjectCfg;
		HRESULT retValue;
	};

	STDMETHOD(get_BuildableProjectCfg)(
		/*[out]*/ IVsBuildableProjectCfg** ppIVsBuildableProjectCfg)
	{
		VSL_DEFINE_MOCK_METHOD(get_BuildableProjectCfg)

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsBuildableProjectCfg);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CanonicalNameValidValues
	{
		/*[out]*/ BSTR* pbstrCanonicalName;
		HRESULT retValue;
	};

	STDMETHOD(get_CanonicalName)(
		/*[out]*/ BSTR* pbstrCanonicalName)
	{
		VSL_DEFINE_MOCK_METHOD(get_CanonicalName)

		VSL_SET_VALIDVALUE_BSTR(pbstrCanonicalName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_PlatformValidValues
	{
		/*[out]*/ GUID* pguidPlatform;
		HRESULT retValue;
	};

	STDMETHOD(get_Platform)(
		/*[out]*/ GUID* pguidPlatform)
	{
		VSL_DEFINE_MOCK_METHOD(get_Platform)

		VSL_SET_VALIDVALUE(pguidPlatform);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IsPackagedValidValues
	{
		/*[out]*/ BOOL* pfIsPackaged;
		HRESULT retValue;
	};

	STDMETHOD(get_IsPackaged)(
		/*[out]*/ BOOL* pfIsPackaged)
	{
		VSL_DEFINE_MOCK_METHOD(get_IsPackaged)

		VSL_SET_VALIDVALUE(pfIsPackaged);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IsSpecifyingOutputSupportedValidValues
	{
		/*[out]*/ BOOL* pfIsSpecifyingOutputSupported;
		HRESULT retValue;
	};

	STDMETHOD(get_IsSpecifyingOutputSupported)(
		/*[out]*/ BOOL* pfIsSpecifyingOutputSupported)
	{
		VSL_DEFINE_MOCK_METHOD(get_IsSpecifyingOutputSupported)

		VSL_SET_VALIDVALUE(pfIsSpecifyingOutputSupported);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_TargetCodePageValidValues
	{
		/*[out]*/ UINT* puiTargetCodePage;
		HRESULT retValue;
	};

	STDMETHOD(get_TargetCodePage)(
		/*[out]*/ UINT* puiTargetCodePage)
	{
		VSL_DEFINE_MOCK_METHOD(get_TargetCodePage)

		VSL_SET_VALIDVALUE(puiTargetCodePage);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_UpdateSequenceNumberValidValues
	{
		/*[out]*/ ULARGE_INTEGER* puliUSN;
		HRESULT retValue;
	};

	STDMETHOD(get_UpdateSequenceNumber)(
		/*[out]*/ ULARGE_INTEGER* puliUSN)
	{
		VSL_DEFINE_MOCK_METHOD(get_UpdateSequenceNumber)

		VSL_SET_VALIDVALUE(puliUSN);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RootURLValidValues
	{
		/*[out]*/ BSTR* pbstrRootURL;
		HRESULT retValue;
	};

	STDMETHOD(get_RootURL)(
		/*[out]*/ BSTR* pbstrRootURL)
	{
		VSL_DEFINE_MOCK_METHOD(get_RootURL)

		VSL_SET_VALIDVALUE_BSTR(pbstrRootURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DisplayNameValidValues
	{
		/*[out]*/ BSTR* pbstrDisplayName;
		HRESULT retValue;
	};

	STDMETHOD(get_DisplayName)(
		/*[out]*/ BSTR* pbstrDisplayName)
	{
		VSL_DEFINE_MOCK_METHOD(get_DisplayName)

		VSL_SET_VALIDVALUE_BSTR(pbstrDisplayName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IsDebugOnlyValidValues
	{
		/*[out]*/ BOOL* pfIsDebugOnly;
		HRESULT retValue;
	};

	STDMETHOD(get_IsDebugOnly)(
		/*[out]*/ BOOL* pfIsDebugOnly)
	{
		VSL_DEFINE_MOCK_METHOD(get_IsDebugOnly)

		VSL_SET_VALIDVALUE(pfIsDebugOnly);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IsReleaseOnlyValidValues
	{
		/*[out]*/ BOOL* pfIsReleaseOnly;
		HRESULT retValue;
	};

	STDMETHOD(get_IsReleaseOnly)(
		/*[out]*/ BOOL* pfIsReleaseOnly)
	{
		VSL_DEFINE_MOCK_METHOD(get_IsReleaseOnly)

		VSL_SET_VALIDVALUE(pfIsReleaseOnly);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROJECTCFG2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsProject3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROJECT3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROJECT3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsProject3NotImpl :
	public IVsProject3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProject3NotImpl)

public:

	typedef IVsProject3 Interface;

	STDMETHOD(AddItemWithSpecific)(
		/*[in]*/ VSITEMID /*itemidLoc*/,
		/*[in]*/ VSADDITEMOPERATION /*dwAddItemOperation*/,
		/*[in]*/ LPCOLESTR /*pszItemName*/,
		/*[in]*/ ULONG /*cFilesToOpen*/,
		/*[in,size_is(cFilesToOpen)]*/ LPCOLESTR[] /*rgpszFilesToOpen*/,
		/*[in]*/ HWND /*hwndDlgOwner*/,
		/*[in]*/ VSSPECIFICEDITORFLAGS /*grfEditorFlags*/,
		/*[in]*/ REFGUID /*rguidEditorType*/,
		/*[in]*/ LPCOLESTR /*pszPhysicalView*/,
		/*[in]*/ REFGUID /*rguidLogicalView*/,
		/*[out,retval]*/ VSADDRESULT* /*pResult*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OpenItemWithSpecific)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ VSSPECIFICEDITORFLAGS /*grfEditorFlags*/,
		/*[in]*/ REFGUID /*rguidEditorType*/,
		/*[in]*/ LPCOLESTR /*pszPhysicalView*/,
		/*[in]*/ REFGUID /*rguidLogicalView*/,
		/*[in]*/ IUnknown* /*punkDocDataExisting*/,
		/*[out]*/ IVsWindowFrame** /*ppWindowFrame*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(TransferItem)(
		/*[in]*/ LPCOLESTR /*pszMkDocumentOld*/,
		/*[in]*/ LPCOLESTR /*pszMkDocumentNew*/,
		/*[in]*/ IVsWindowFrame* /*punkWindowFrame*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveItem)(
		/*[in]*/ DWORD /*dwReserved*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[out,retval]*/ BOOL* /*pfResult*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReopenItem)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ REFGUID /*rguidEditorType*/,
		/*[in]*/ LPCOLESTR /*pszPhysicalView*/,
		/*[in]*/ REFGUID /*rguidLogicalView*/,
		/*[in]*/ IUnknown* /*punkDocDataExisting*/,
		/*[out,retval]*/ IVsWindowFrame** /*ppWindowFrame*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsDocumentInProject)(
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[out]*/ BOOL* /*pfFound*/,
		/*[out]*/ VSDOCUMENTPRIORITY* /*pdwPriority*/,
		/*[out]*/ VSITEMID* /*pitemid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMkDocument)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[out]*/ BSTR* /*pbstrMkDocument*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OpenItem)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ REFGUID /*rguidLogicalView*/,
		/*[in]*/ IUnknown* /*punkDocDataExisting*/,
		/*[out]*/ IVsWindowFrame** /*ppWindowFrame*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetItemContext)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[out]*/ IServiceProvider** /*ppSP*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GenerateUniqueItemName)(
		/*[in]*/ VSITEMID /*itemidLoc*/,
		/*[in]*/ LPCOLESTR /*pszExt*/,
		/*[in]*/ LPCOLESTR /*pszSuggestedRoot*/,
		/*[out]*/ BSTR* /*pbstrItemName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddItem)(
		/*[in]*/ VSITEMID /*itemidLoc*/,
		/*[in]*/ VSADDITEMOPERATION /*dwAddItemOperation*/,
		/*[in]*/ LPCOLESTR /*pszItemName*/,
		/*[in]*/ ULONG /*cFilesToOpen*/,
		/*[in,size_is(cFilesToOpen)]*/ LPCOLESTR[] /*rgpszFilesToOpen*/,
		/*[in]*/ HWND /*hwndDlgOwner*/,
		/*[out,retval]*/ VSADDRESULT* /*pResult*/)VSL_STDMETHOD_NOTIMPL
};

class IVsProject3MockImpl :
	public IVsProject3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProject3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsProject3MockImpl)

	typedef IVsProject3 Interface;
	struct AddItemWithSpecificValidValues
	{
		/*[in]*/ VSITEMID itemidLoc;
		/*[in]*/ VSADDITEMOPERATION dwAddItemOperation;
		/*[in]*/ LPCOLESTR pszItemName;
		/*[in]*/ ULONG cFilesToOpen;
		/*[in,size_is(cFilesToOpen)]*/ LPCOLESTR* rgpszFilesToOpen;
		/*[in]*/ HWND hwndDlgOwner;
		/*[in]*/ VSSPECIFICEDITORFLAGS grfEditorFlags;
		/*[in]*/ REFGUID rguidEditorType;
		/*[in]*/ LPCOLESTR pszPhysicalView;
		/*[in]*/ REFGUID rguidLogicalView;
		/*[out,retval]*/ VSADDRESULT* pResult;
		HRESULT retValue;
	};

	STDMETHOD(AddItemWithSpecific)(
		/*[in]*/ VSITEMID itemidLoc,
		/*[in]*/ VSADDITEMOPERATION dwAddItemOperation,
		/*[in]*/ LPCOLESTR pszItemName,
		/*[in]*/ ULONG cFilesToOpen,
		/*[in,size_is(cFilesToOpen)]*/ LPCOLESTR rgpszFilesToOpen[],
		/*[in]*/ HWND hwndDlgOwner,
		/*[in]*/ VSSPECIFICEDITORFLAGS grfEditorFlags,
		/*[in]*/ REFGUID rguidEditorType,
		/*[in]*/ LPCOLESTR pszPhysicalView,
		/*[in]*/ REFGUID rguidLogicalView,
		/*[out,retval]*/ VSADDRESULT* pResult)
	{
		VSL_DEFINE_MOCK_METHOD(AddItemWithSpecific)

		VSL_CHECK_VALIDVALUE(itemidLoc);

		VSL_CHECK_VALIDVALUE(dwAddItemOperation);

		VSL_CHECK_VALIDVALUE_STRINGW(pszItemName);

		VSL_CHECK_VALIDVALUE(cFilesToOpen);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszFilesToOpen, cFilesToOpen*sizeof(rgpszFilesToOpen[0]), validValues.cFilesToOpen*sizeof(validValues.rgpszFilesToOpen[0]));

		VSL_CHECK_VALIDVALUE(hwndDlgOwner);

		VSL_CHECK_VALIDVALUE(grfEditorFlags);

		VSL_CHECK_VALIDVALUE(rguidEditorType);

		VSL_CHECK_VALIDVALUE_STRINGW(pszPhysicalView);

		VSL_CHECK_VALIDVALUE(rguidLogicalView);

		VSL_SET_VALIDVALUE(pResult);

		VSL_RETURN_VALIDVALUES();
	}
	struct OpenItemWithSpecificValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ VSSPECIFICEDITORFLAGS grfEditorFlags;
		/*[in]*/ REFGUID rguidEditorType;
		/*[in]*/ LPCOLESTR pszPhysicalView;
		/*[in]*/ REFGUID rguidLogicalView;
		/*[in]*/ IUnknown* punkDocDataExisting;
		/*[out]*/ IVsWindowFrame** ppWindowFrame;
		HRESULT retValue;
	};

	STDMETHOD(OpenItemWithSpecific)(
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ VSSPECIFICEDITORFLAGS grfEditorFlags,
		/*[in]*/ REFGUID rguidEditorType,
		/*[in]*/ LPCOLESTR pszPhysicalView,
		/*[in]*/ REFGUID rguidLogicalView,
		/*[in]*/ IUnknown* punkDocDataExisting,
		/*[out]*/ IVsWindowFrame** ppWindowFrame)
	{
		VSL_DEFINE_MOCK_METHOD(OpenItemWithSpecific)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE(grfEditorFlags);

		VSL_CHECK_VALIDVALUE(rguidEditorType);

		VSL_CHECK_VALIDVALUE_STRINGW(pszPhysicalView);

		VSL_CHECK_VALIDVALUE(rguidLogicalView);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkDocDataExisting);

		VSL_SET_VALIDVALUE_INTERFACE(ppWindowFrame);

		VSL_RETURN_VALIDVALUES();
	}
	struct TransferItemValidValues
	{
		/*[in]*/ LPCOLESTR pszMkDocumentOld;
		/*[in]*/ LPCOLESTR pszMkDocumentNew;
		/*[in]*/ IVsWindowFrame* punkWindowFrame;
		HRESULT retValue;
	};

	STDMETHOD(TransferItem)(
		/*[in]*/ LPCOLESTR pszMkDocumentOld,
		/*[in]*/ LPCOLESTR pszMkDocumentNew,
		/*[in]*/ IVsWindowFrame* punkWindowFrame)
	{
		VSL_DEFINE_MOCK_METHOD(TransferItem)

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocumentOld);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocumentNew);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkWindowFrame);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveItemValidValues
	{
		/*[in]*/ DWORD dwReserved;
		/*[in]*/ VSITEMID itemid;
		/*[out,retval]*/ BOOL* pfResult;
		HRESULT retValue;
	};

	STDMETHOD(RemoveItem)(
		/*[in]*/ DWORD dwReserved,
		/*[in]*/ VSITEMID itemid,
		/*[out,retval]*/ BOOL* pfResult)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveItem)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_SET_VALIDVALUE(pfResult);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReopenItemValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ REFGUID rguidEditorType;
		/*[in]*/ LPCOLESTR pszPhysicalView;
		/*[in]*/ REFGUID rguidLogicalView;
		/*[in]*/ IUnknown* punkDocDataExisting;
		/*[out,retval]*/ IVsWindowFrame** ppWindowFrame;
		HRESULT retValue;
	};

	STDMETHOD(ReopenItem)(
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ REFGUID rguidEditorType,
		/*[in]*/ LPCOLESTR pszPhysicalView,
		/*[in]*/ REFGUID rguidLogicalView,
		/*[in]*/ IUnknown* punkDocDataExisting,
		/*[out,retval]*/ IVsWindowFrame** ppWindowFrame)
	{
		VSL_DEFINE_MOCK_METHOD(ReopenItem)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE(rguidEditorType);

		VSL_CHECK_VALIDVALUE_STRINGW(pszPhysicalView);

		VSL_CHECK_VALIDVALUE(rguidLogicalView);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkDocDataExisting);

		VSL_SET_VALIDVALUE_INTERFACE(ppWindowFrame);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsDocumentInProjectValidValues
	{
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[out]*/ BOOL* pfFound;
		/*[out]*/ VSDOCUMENTPRIORITY* pdwPriority;
		/*[out]*/ VSITEMID* pitemid;
		HRESULT retValue;
	};

	STDMETHOD(IsDocumentInProject)(
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[out]*/ BOOL* pfFound,
		/*[out]*/ VSDOCUMENTPRIORITY* pdwPriority,
		/*[out]*/ VSITEMID* pitemid)
	{
		VSL_DEFINE_MOCK_METHOD(IsDocumentInProject)

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_SET_VALIDVALUE(pfFound);

		VSL_SET_VALIDVALUE(pdwPriority);

		VSL_SET_VALIDVALUE(pitemid);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMkDocumentValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[out]*/ BSTR* pbstrMkDocument;
		HRESULT retValue;
	};

	STDMETHOD(GetMkDocument)(
		/*[in]*/ VSITEMID itemid,
		/*[out]*/ BSTR* pbstrMkDocument)
	{
		VSL_DEFINE_MOCK_METHOD(GetMkDocument)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_SET_VALIDVALUE_BSTR(pbstrMkDocument);

		VSL_RETURN_VALIDVALUES();
	}
	struct OpenItemValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ REFGUID rguidLogicalView;
		/*[in]*/ IUnknown* punkDocDataExisting;
		/*[out]*/ IVsWindowFrame** ppWindowFrame;
		HRESULT retValue;
	};

	STDMETHOD(OpenItem)(
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ REFGUID rguidLogicalView,
		/*[in]*/ IUnknown* punkDocDataExisting,
		/*[out]*/ IVsWindowFrame** ppWindowFrame)
	{
		VSL_DEFINE_MOCK_METHOD(OpenItem)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE(rguidLogicalView);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkDocDataExisting);

		VSL_SET_VALIDVALUE_INTERFACE(ppWindowFrame);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetItemContextValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[out]*/ IServiceProvider** ppSP;
		HRESULT retValue;
	};

	STDMETHOD(GetItemContext)(
		/*[in]*/ VSITEMID itemid,
		/*[out]*/ IServiceProvider** ppSP)
	{
		VSL_DEFINE_MOCK_METHOD(GetItemContext)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_SET_VALIDVALUE_INTERFACE(ppSP);

		VSL_RETURN_VALIDVALUES();
	}
	struct GenerateUniqueItemNameValidValues
	{
		/*[in]*/ VSITEMID itemidLoc;
		/*[in]*/ LPCOLESTR pszExt;
		/*[in]*/ LPCOLESTR pszSuggestedRoot;
		/*[out]*/ BSTR* pbstrItemName;
		HRESULT retValue;
	};

	STDMETHOD(GenerateUniqueItemName)(
		/*[in]*/ VSITEMID itemidLoc,
		/*[in]*/ LPCOLESTR pszExt,
		/*[in]*/ LPCOLESTR pszSuggestedRoot,
		/*[out]*/ BSTR* pbstrItemName)
	{
		VSL_DEFINE_MOCK_METHOD(GenerateUniqueItemName)

		VSL_CHECK_VALIDVALUE(itemidLoc);

		VSL_CHECK_VALIDVALUE_STRINGW(pszExt);

		VSL_CHECK_VALIDVALUE_STRINGW(pszSuggestedRoot);

		VSL_SET_VALIDVALUE_BSTR(pbstrItemName);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddItemValidValues
	{
		/*[in]*/ VSITEMID itemidLoc;
		/*[in]*/ VSADDITEMOPERATION dwAddItemOperation;
		/*[in]*/ LPCOLESTR pszItemName;
		/*[in]*/ ULONG cFilesToOpen;
		/*[in,size_is(cFilesToOpen)]*/ LPCOLESTR* rgpszFilesToOpen;
		/*[in]*/ HWND hwndDlgOwner;
		/*[out,retval]*/ VSADDRESULT* pResult;
		HRESULT retValue;
	};

	STDMETHOD(AddItem)(
		/*[in]*/ VSITEMID itemidLoc,
		/*[in]*/ VSADDITEMOPERATION dwAddItemOperation,
		/*[in]*/ LPCOLESTR pszItemName,
		/*[in]*/ ULONG cFilesToOpen,
		/*[in,size_is(cFilesToOpen)]*/ LPCOLESTR rgpszFilesToOpen[],
		/*[in]*/ HWND hwndDlgOwner,
		/*[out,retval]*/ VSADDRESULT* pResult)
	{
		VSL_DEFINE_MOCK_METHOD(AddItem)

		VSL_CHECK_VALIDVALUE(itemidLoc);

		VSL_CHECK_VALIDVALUE(dwAddItemOperation);

		VSL_CHECK_VALIDVALUE_STRINGW(pszItemName);

		VSL_CHECK_VALIDVALUE(cFilesToOpen);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszFilesToOpen, cFilesToOpen*sizeof(rgpszFilesToOpen[0]), validValues.cFilesToOpen*sizeof(validValues.rgpszFilesToOpen[0]));

		VSL_CHECK_VALIDVALUE(hwndDlgOwner);

		VSL_SET_VALIDVALUE(pResult);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROJECT3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsProjectCfgProvider.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROJECTCFGPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROJECTCFGPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsProjectCfgProviderNotImpl :
	public IVsProjectCfgProvider
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectCfgProviderNotImpl)

public:

	typedef IVsProjectCfgProvider Interface;

	STDMETHOD(OpenProjectCfg)(
		/*[in]*/ LPCOLESTR /*szProjectCfgCanonicalName*/,
		/*[out]*/ IVsProjectCfg** /*ppIVsProjectCfg*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_UsesIndependentConfigurations)(
		/*[out]*/ BOOL* /*pfUsesIndependentConfigurations*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCfgs)(
		/*[in]*/ ULONG /*celt*/,
		/*[in,out,size_is(celt)]*/ IVsCfg*[] /*rgpcfg*/,
		/*[out,optional]*/ ULONG* /*pcActual*/,
		/*[out,optional]*/ VSCFGFLAGS* /*prgfFlags*/)VSL_STDMETHOD_NOTIMPL
};

class IVsProjectCfgProviderMockImpl :
	public IVsProjectCfgProvider,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectCfgProviderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsProjectCfgProviderMockImpl)

	typedef IVsProjectCfgProvider Interface;
	struct OpenProjectCfgValidValues
	{
		/*[in]*/ LPCOLESTR szProjectCfgCanonicalName;
		/*[out]*/ IVsProjectCfg** ppIVsProjectCfg;
		HRESULT retValue;
	};

	STDMETHOD(OpenProjectCfg)(
		/*[in]*/ LPCOLESTR szProjectCfgCanonicalName,
		/*[out]*/ IVsProjectCfg** ppIVsProjectCfg)
	{
		VSL_DEFINE_MOCK_METHOD(OpenProjectCfg)

		VSL_CHECK_VALIDVALUE_STRINGW(szProjectCfgCanonicalName);

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsProjectCfg);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_UsesIndependentConfigurationsValidValues
	{
		/*[out]*/ BOOL* pfUsesIndependentConfigurations;
		HRESULT retValue;
	};

	STDMETHOD(get_UsesIndependentConfigurations)(
		/*[out]*/ BOOL* pfUsesIndependentConfigurations)
	{
		VSL_DEFINE_MOCK_METHOD(get_UsesIndependentConfigurations)

		VSL_SET_VALIDVALUE(pfUsesIndependentConfigurations);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCfgsValidValues
	{
		/*[in]*/ ULONG celt;
		/*[in,out,size_is(celt)]*/ IVsCfg** rgpcfg;
		/*[out,optional]*/ ULONG* pcActual;
		/*[out,optional]*/ VSCFGFLAGS* prgfFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetCfgs)(
		/*[in]*/ ULONG celt,
		/*[in,out,size_is(celt)]*/ IVsCfg* rgpcfg[],
		/*[out,optional]*/ ULONG* pcActual,
		/*[out,optional]*/ VSCFGFLAGS* prgfFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetCfgs)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgpcfg, celt, validValues.celt);

		VSL_SET_VALIDVALUE(pcActual);

		VSL_SET_VALIDVALUE(prgfFlags);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROJECTCFGPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsProjectCfg.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROJECTCFG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROJECTCFG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsProjectCfgNotImpl :
	public IVsProjectCfg
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectCfgNotImpl)

public:

	typedef IVsProjectCfg Interface;

	STDMETHOD(EnumOutputs)(
		/*[out]*/ IVsEnumOutputs** /*ppIVsEnumOutputs*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OpenOutput)(
		/*[in]*/ LPCOLESTR /*szOutputCanonicalName*/,
		/*[out]*/ IVsOutput** /*ppIVsOutput*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ProjectCfgProvider)(
		/*[out]*/ IVsProjectCfgProvider** /*ppIVsProjectCfgProvider*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_BuildableProjectCfg)(
		/*[out]*/ IVsBuildableProjectCfg** /*ppIVsBuildableProjectCfg*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CanonicalName)(
		/*[out]*/ BSTR* /*pbstrCanonicalName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Platform)(
		/*[out]*/ GUID* /*pguidPlatform*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IsPackaged)(
		/*[out]*/ BOOL* /*pfIsPackaged*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IsSpecifyingOutputSupported)(
		/*[out]*/ BOOL* /*pfIsSpecifyingOutputSupported*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_TargetCodePage)(
		/*[out]*/ UINT* /*puiTargetCodePage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_UpdateSequenceNumber)(
		/*[out]*/ ULARGE_INTEGER* /*puliUSN*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RootURL)(
		/*[out]*/ BSTR* /*pbstrRootURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DisplayName)(
		/*[out]*/ BSTR* /*pbstrDisplayName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IsDebugOnly)(
		/*[out]*/ BOOL* /*pfIsDebugOnly*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IsReleaseOnly)(
		/*[out]*/ BOOL* /*pfIsReleaseOnly*/)VSL_STDMETHOD_NOTIMPL
};

class IVsProjectCfgMockImpl :
	public IVsProjectCfg,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectCfgMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsProjectCfgMockImpl)

	typedef IVsProjectCfg Interface;
	struct EnumOutputsValidValues
	{
		/*[out]*/ IVsEnumOutputs** ppIVsEnumOutputs;
		HRESULT retValue;
	};

	STDMETHOD(EnumOutputs)(
		/*[out]*/ IVsEnumOutputs** ppIVsEnumOutputs)
	{
		VSL_DEFINE_MOCK_METHOD(EnumOutputs)

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsEnumOutputs);

		VSL_RETURN_VALIDVALUES();
	}
	struct OpenOutputValidValues
	{
		/*[in]*/ LPCOLESTR szOutputCanonicalName;
		/*[out]*/ IVsOutput** ppIVsOutput;
		HRESULT retValue;
	};

	STDMETHOD(OpenOutput)(
		/*[in]*/ LPCOLESTR szOutputCanonicalName,
		/*[out]*/ IVsOutput** ppIVsOutput)
	{
		VSL_DEFINE_MOCK_METHOD(OpenOutput)

		VSL_CHECK_VALIDVALUE_STRINGW(szOutputCanonicalName);

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsOutput);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ProjectCfgProviderValidValues
	{
		/*[out]*/ IVsProjectCfgProvider** ppIVsProjectCfgProvider;
		HRESULT retValue;
	};

	STDMETHOD(get_ProjectCfgProvider)(
		/*[out]*/ IVsProjectCfgProvider** ppIVsProjectCfgProvider)
	{
		VSL_DEFINE_MOCK_METHOD(get_ProjectCfgProvider)

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsProjectCfgProvider);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_BuildableProjectCfgValidValues
	{
		/*[out]*/ IVsBuildableProjectCfg** ppIVsBuildableProjectCfg;
		HRESULT retValue;
	};

	STDMETHOD(get_BuildableProjectCfg)(
		/*[out]*/ IVsBuildableProjectCfg** ppIVsBuildableProjectCfg)
	{
		VSL_DEFINE_MOCK_METHOD(get_BuildableProjectCfg)

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsBuildableProjectCfg);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CanonicalNameValidValues
	{
		/*[out]*/ BSTR* pbstrCanonicalName;
		HRESULT retValue;
	};

	STDMETHOD(get_CanonicalName)(
		/*[out]*/ BSTR* pbstrCanonicalName)
	{
		VSL_DEFINE_MOCK_METHOD(get_CanonicalName)

		VSL_SET_VALIDVALUE_BSTR(pbstrCanonicalName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_PlatformValidValues
	{
		/*[out]*/ GUID* pguidPlatform;
		HRESULT retValue;
	};

	STDMETHOD(get_Platform)(
		/*[out]*/ GUID* pguidPlatform)
	{
		VSL_DEFINE_MOCK_METHOD(get_Platform)

		VSL_SET_VALIDVALUE(pguidPlatform);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IsPackagedValidValues
	{
		/*[out]*/ BOOL* pfIsPackaged;
		HRESULT retValue;
	};

	STDMETHOD(get_IsPackaged)(
		/*[out]*/ BOOL* pfIsPackaged)
	{
		VSL_DEFINE_MOCK_METHOD(get_IsPackaged)

		VSL_SET_VALIDVALUE(pfIsPackaged);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IsSpecifyingOutputSupportedValidValues
	{
		/*[out]*/ BOOL* pfIsSpecifyingOutputSupported;
		HRESULT retValue;
	};

	STDMETHOD(get_IsSpecifyingOutputSupported)(
		/*[out]*/ BOOL* pfIsSpecifyingOutputSupported)
	{
		VSL_DEFINE_MOCK_METHOD(get_IsSpecifyingOutputSupported)

		VSL_SET_VALIDVALUE(pfIsSpecifyingOutputSupported);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_TargetCodePageValidValues
	{
		/*[out]*/ UINT* puiTargetCodePage;
		HRESULT retValue;
	};

	STDMETHOD(get_TargetCodePage)(
		/*[out]*/ UINT* puiTargetCodePage)
	{
		VSL_DEFINE_MOCK_METHOD(get_TargetCodePage)

		VSL_SET_VALIDVALUE(puiTargetCodePage);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_UpdateSequenceNumberValidValues
	{
		/*[out]*/ ULARGE_INTEGER* puliUSN;
		HRESULT retValue;
	};

	STDMETHOD(get_UpdateSequenceNumber)(
		/*[out]*/ ULARGE_INTEGER* puliUSN)
	{
		VSL_DEFINE_MOCK_METHOD(get_UpdateSequenceNumber)

		VSL_SET_VALIDVALUE(puliUSN);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RootURLValidValues
	{
		/*[out]*/ BSTR* pbstrRootURL;
		HRESULT retValue;
	};

	STDMETHOD(get_RootURL)(
		/*[out]*/ BSTR* pbstrRootURL)
	{
		VSL_DEFINE_MOCK_METHOD(get_RootURL)

		VSL_SET_VALIDVALUE_BSTR(pbstrRootURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DisplayNameValidValues
	{
		/*[out]*/ BSTR* pbstrDisplayName;
		HRESULT retValue;
	};

	STDMETHOD(get_DisplayName)(
		/*[out]*/ BSTR* pbstrDisplayName)
	{
		VSL_DEFINE_MOCK_METHOD(get_DisplayName)

		VSL_SET_VALIDVALUE_BSTR(pbstrDisplayName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IsDebugOnlyValidValues
	{
		/*[out]*/ BOOL* pfIsDebugOnly;
		HRESULT retValue;
	};

	STDMETHOD(get_IsDebugOnly)(
		/*[out]*/ BOOL* pfIsDebugOnly)
	{
		VSL_DEFINE_MOCK_METHOD(get_IsDebugOnly)

		VSL_SET_VALIDVALUE(pfIsDebugOnly);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IsReleaseOnlyValidValues
	{
		/*[out]*/ BOOL* pfIsReleaseOnly;
		HRESULT retValue;
	};

	STDMETHOD(get_IsReleaseOnly)(
		/*[out]*/ BOOL* pfIsReleaseOnly)
	{
		VSL_DEFINE_MOCK_METHOD(get_IsReleaseOnly)

		VSL_SET_VALIDVALUE(pfIsReleaseOnly);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROJECTCFG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsProjectDeployDependency.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROJECTDEPLOYDEPENDENCY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROJECTDEPLOYDEPENDENCY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsProjectDeployDependencyNotImpl :
	public IVsProjectDeployDependency
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectDeployDependencyNotImpl)

public:

	typedef IVsProjectDeployDependency Interface;

	STDMETHOD(get_ProjectInfo)(
		/*[out]*/ IVsHierarchy** /*ppIVsHierarchy*/,
		/*[out]*/ IVsProjectCfg** /*ppIVsProjectCfg*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DeployDependencyURL)(
		/*[out]*/ BSTR* /*pbstrURL*/)VSL_STDMETHOD_NOTIMPL
};

class IVsProjectDeployDependencyMockImpl :
	public IVsProjectDeployDependency,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectDeployDependencyMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsProjectDeployDependencyMockImpl)

	typedef IVsProjectDeployDependency Interface;
	struct get_ProjectInfoValidValues
	{
		/*[out]*/ IVsHierarchy** ppIVsHierarchy;
		/*[out]*/ IVsProjectCfg** ppIVsProjectCfg;
		HRESULT retValue;
	};

	STDMETHOD(get_ProjectInfo)(
		/*[out]*/ IVsHierarchy** ppIVsHierarchy,
		/*[out]*/ IVsProjectCfg** ppIVsProjectCfg)
	{
		VSL_DEFINE_MOCK_METHOD(get_ProjectInfo)

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsHierarchy);

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsProjectCfg);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DeployDependencyURLValidValues
	{
		/*[out]*/ BSTR* pbstrURL;
		HRESULT retValue;
	};

	STDMETHOD(get_DeployDependencyURL)(
		/*[out]*/ BSTR* pbstrURL)
	{
		VSL_DEFINE_MOCK_METHOD(get_DeployDependencyURL)

		VSL_SET_VALIDVALUE_BSTR(pbstrURL);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROJECTDEPLOYDEPENDENCY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsProjectFactory.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROJECTFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROJECTFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsProjectFactoryNotImpl :
	public IVsProjectFactory
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectFactoryNotImpl)

public:

	typedef IVsProjectFactory Interface;

	STDMETHOD(CanCreateProject)(
		/*[in]*/ LPCOLESTR /*pszFilename*/,
		/*[in]*/ VSCREATEPROJFLAGS /*grfCreateFlags*/,
		/*[out]*/ BOOL* /*pfCanCreate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateProject)(
		/*[in]*/ LPCOLESTR /*pszFilename*/,
		/*[in]*/ LPCOLESTR /*pszLocation*/,
		/*[in]*/ LPCOLESTR /*pszName*/,
		/*[in]*/ VSCREATEPROJFLAGS /*grfCreateFlags*/,
		/*[in]*/ REFIID /*iidProject*/,
		/*[out,iid_is(iidProject)]*/ void** /*ppvProject*/,
		/*[out]*/ BOOL* /*pfCanceled*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetSite)(
		/*[in]*/ IServiceProvider* /*pSP*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Close)()VSL_STDMETHOD_NOTIMPL
};

class IVsProjectFactoryMockImpl :
	public IVsProjectFactory,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectFactoryMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsProjectFactoryMockImpl)

	typedef IVsProjectFactory Interface;
	struct CanCreateProjectValidValues
	{
		/*[in]*/ LPCOLESTR pszFilename;
		/*[in]*/ VSCREATEPROJFLAGS grfCreateFlags;
		/*[out]*/ BOOL* pfCanCreate;
		HRESULT retValue;
	};

	STDMETHOD(CanCreateProject)(
		/*[in]*/ LPCOLESTR pszFilename,
		/*[in]*/ VSCREATEPROJFLAGS grfCreateFlags,
		/*[out]*/ BOOL* pfCanCreate)
	{
		VSL_DEFINE_MOCK_METHOD(CanCreateProject)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFilename);

		VSL_CHECK_VALIDVALUE(grfCreateFlags);

		VSL_SET_VALIDVALUE(pfCanCreate);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateProjectValidValues
	{
		/*[in]*/ LPCOLESTR pszFilename;
		/*[in]*/ LPCOLESTR pszLocation;
		/*[in]*/ LPCOLESTR pszName;
		/*[in]*/ VSCREATEPROJFLAGS grfCreateFlags;
		/*[in]*/ REFIID iidProject;
		/*[out,iid_is(iidProject)]*/ void** ppvProject;
		/*[out]*/ BOOL* pfCanceled;
		HRESULT retValue;
	};

	STDMETHOD(CreateProject)(
		/*[in]*/ LPCOLESTR pszFilename,
		/*[in]*/ LPCOLESTR pszLocation,
		/*[in]*/ LPCOLESTR pszName,
		/*[in]*/ VSCREATEPROJFLAGS grfCreateFlags,
		/*[in]*/ REFIID iidProject,
		/*[out,iid_is(iidProject)]*/ void** ppvProject,
		/*[out]*/ BOOL* pfCanceled)
	{
		VSL_DEFINE_MOCK_METHOD(CreateProject)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFilename);

		VSL_CHECK_VALIDVALUE_STRINGW(pszLocation);

		VSL_CHECK_VALIDVALUE_STRINGW(pszName);

		VSL_CHECK_VALIDVALUE(grfCreateFlags);

		VSL_CHECK_VALIDVALUE(iidProject);

		VSL_SET_VALIDVALUE(ppvProject);

		VSL_SET_VALIDVALUE(pfCanceled);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetSiteValidValues
	{
		/*[in]*/ IServiceProvider* pSP;
		HRESULT retValue;
	};

	STDMETHOD(SetSite)(
		/*[in]*/ IServiceProvider* pSP)
	{
		VSL_DEFINE_MOCK_METHOD(SetSite)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSP);

		VSL_RETURN_VALIDVALUES();
	}
	struct CloseValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Close)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Close)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROJECTFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsProjectFlavorCfg.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROJECTFLAVORCFG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROJECTFLAVORCFG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsProjectFlavorCfgNotImpl :
	public IVsProjectFlavorCfg
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectFlavorCfgNotImpl)

public:

	typedef IVsProjectFlavorCfg Interface;

	STDMETHOD(get_CfgType)(
		/*[in]*/ REFIID /*iidCfg*/,
		/*[out,iid_is(iidCfg)]*/ void** /*ppCfg*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Close)()VSL_STDMETHOD_NOTIMPL
};

class IVsProjectFlavorCfgMockImpl :
	public IVsProjectFlavorCfg,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectFlavorCfgMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsProjectFlavorCfgMockImpl)

	typedef IVsProjectFlavorCfg Interface;
	struct get_CfgTypeValidValues
	{
		/*[in]*/ REFIID iidCfg;
		/*[out,iid_is(iidCfg)]*/ void** ppCfg;
		HRESULT retValue;
	};

	STDMETHOD(get_CfgType)(
		/*[in]*/ REFIID iidCfg,
		/*[out,iid_is(iidCfg)]*/ void** ppCfg)
	{
		VSL_DEFINE_MOCK_METHOD(get_CfgType)

		VSL_CHECK_VALIDVALUE(iidCfg);

		VSL_SET_VALIDVALUE(ppCfg);

		VSL_RETURN_VALIDVALUES();
	}
	struct CloseValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Close)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Close)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROJECTFLAVORCFG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsProjectDebugTargetProvider.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROJECTDEBUGTARGETPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROJECTDEBUGTARGETPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsProjectDebugTargetProviderNotImpl :
	public IVsProjectDebugTargetProvider
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectDebugTargetProviderNotImpl)

public:

	typedef IVsProjectDebugTargetProvider Interface;

	STDMETHOD(SupplyDebugTarget)(
		/*[out]*/ BSTR* /*pbstrTarget*/,
		/*[out]*/ BSTR* /*pbstrCommandLine*/)VSL_STDMETHOD_NOTIMPL
};

class IVsProjectDebugTargetProviderMockImpl :
	public IVsProjectDebugTargetProvider,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectDebugTargetProviderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsProjectDebugTargetProviderMockImpl)

	typedef IVsProjectDebugTargetProvider Interface;
	struct SupplyDebugTargetValidValues
	{
		/*[out]*/ BSTR* pbstrTarget;
		/*[out]*/ BSTR* pbstrCommandLine;
		HRESULT retValue;
	};

	STDMETHOD(SupplyDebugTarget)(
		/*[out]*/ BSTR* pbstrTarget,
		/*[out]*/ BSTR* pbstrCommandLine)
	{
		VSL_DEFINE_MOCK_METHOD(SupplyDebugTarget)

		VSL_SET_VALIDVALUE_BSTR(pbstrTarget);

		VSL_SET_VALIDVALUE_BSTR(pbstrCommandLine);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROJECTDEBUGTARGETPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsProjectDataConnection.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROJECTDATACONNECTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROJECTDATACONNECTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsProjectDataConnectionNotImpl :
	public IVsProjectDataConnection
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectDataConnectionNotImpl)

public:

	typedef IVsProjectDataConnection Interface;

	STDMETHOD(GetProjectSqlConnection)(
		/*[out]*/ IUnknown** /*pConnection*/)VSL_STDMETHOD_NOTIMPL
};

class IVsProjectDataConnectionMockImpl :
	public IVsProjectDataConnection,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectDataConnectionMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsProjectDataConnectionMockImpl)

	typedef IVsProjectDataConnection Interface;
	struct GetProjectSqlConnectionValidValues
	{
		/*[out]*/ IUnknown** pConnection;
		HRESULT retValue;
	};

	STDMETHOD(GetProjectSqlConnection)(
		/*[out]*/ IUnknown** pConnection)
	{
		VSL_DEFINE_MOCK_METHOD(GetProjectSqlConnection)

		VSL_SET_VALIDVALUE_INTERFACE(pConnection);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROJECTDATACONNECTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsProjectFlavorCfgProvider.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROJECTFLAVORCFGPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROJECTFLAVORCFGPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsProjectFlavorCfgProviderNotImpl :
	public IVsProjectFlavorCfgProvider
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectFlavorCfgProviderNotImpl)

public:

	typedef IVsProjectFlavorCfgProvider Interface;

	STDMETHOD(CreateProjectFlavorCfg)(
		/*[in]*/ IVsCfg* /*pBaseProjectCfg*/,
		/*[out]*/ IVsProjectFlavorCfg** /*ppFlavorCfg*/)VSL_STDMETHOD_NOTIMPL
};

class IVsProjectFlavorCfgProviderMockImpl :
	public IVsProjectFlavorCfgProvider,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectFlavorCfgProviderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsProjectFlavorCfgProviderMockImpl)

	typedef IVsProjectFlavorCfgProvider Interface;
	struct CreateProjectFlavorCfgValidValues
	{
		/*[in]*/ IVsCfg* pBaseProjectCfg;
		/*[out]*/ IVsProjectFlavorCfg** ppFlavorCfg;
		HRESULT retValue;
	};

	STDMETHOD(CreateProjectFlavorCfg)(
		/*[in]*/ IVsCfg* pBaseProjectCfg,
		/*[out]*/ IVsProjectFlavorCfg** ppFlavorCfg)
	{
		VSL_DEFINE_MOCK_METHOD(CreateProjectFlavorCfg)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBaseProjectCfg);

		VSL_SET_VALIDVALUE_INTERFACE(ppFlavorCfg);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROJECTFLAVORCFGPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsProjectFlavorCfgOutputGroups.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROJECTFLAVORCFGOUTPUTGROUPS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROJECTFLAVORCFGOUTPUTGROUPS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsProjectFlavorCfgOutputGroupsNotImpl :
	public IVsProjectFlavorCfgOutputGroups
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectFlavorCfgOutputGroupsNotImpl)

public:

	typedef IVsProjectFlavorCfgOutputGroups Interface;

	STDMETHOD(CustomizeOutputGroup)(
		/*[in]*/ IVsOutputGroup* /*pIn*/,
		/*[out]*/ IVsOutputGroup** /*pOut*/)VSL_STDMETHOD_NOTIMPL
};

class IVsProjectFlavorCfgOutputGroupsMockImpl :
	public IVsProjectFlavorCfgOutputGroups,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectFlavorCfgOutputGroupsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsProjectFlavorCfgOutputGroupsMockImpl)

	typedef IVsProjectFlavorCfgOutputGroups Interface;
	struct CustomizeOutputGroupValidValues
	{
		/*[in]*/ IVsOutputGroup* pIn;
		/*[out]*/ IVsOutputGroup** pOut;
		HRESULT retValue;
	};

	STDMETHOD(CustomizeOutputGroup)(
		/*[in]*/ IVsOutputGroup* pIn,
		/*[out]*/ IVsOutputGroup** pOut)
	{
		VSL_DEFINE_MOCK_METHOD(CustomizeOutputGroup)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIn);

		VSL_SET_VALIDVALUE_INTERFACE(pOut);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROJECTFLAVORCFGOUTPUTGROUPS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsProjectFactory2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROJECTFACTORY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROJECTFACTORY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsProjectFactory2NotImpl :
	public IVsProjectFactory2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectFactory2NotImpl)

public:

	typedef IVsProjectFactory2 Interface;

	STDMETHOD(GetAsynchOpenProjectType)(
		/*[out,retval]*/ VSASYNCHOPENPROJECTTYPE* /*pType*/)VSL_STDMETHOD_NOTIMPL
};

class IVsProjectFactory2MockImpl :
	public IVsProjectFactory2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectFactory2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsProjectFactory2MockImpl)

	typedef IVsProjectFactory2 Interface;
	struct GetAsynchOpenProjectTypeValidValues
	{
		/*[out,retval]*/ VSASYNCHOPENPROJECTTYPE* pType;
		HRESULT retValue;
	};

	STDMETHOD(GetAsynchOpenProjectType)(
		/*[out,retval]*/ VSASYNCHOPENPROJECTTYPE* pType)
	{
		VSL_DEFINE_MOCK_METHOD(GetAsynchOpenProjectType)

		VSL_SET_VALIDVALUE(pType);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROJECTFACTORY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsProjectFlavorReferences.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROJECTFLAVORREFERENCES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROJECTFLAVORREFERENCES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsProjectFlavorReferencesNotImpl :
	public IVsProjectFlavorReferences
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectFlavorReferencesNotImpl)

public:

	typedef IVsProjectFlavorReferences Interface;

	STDMETHOD(QueryAddProjectReference)(
		/*[in]*/ IUnknown* /*pReferencedProject*/,
		/*[out,retval]*/ BOOL* /*pbCanAdd*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryCanBeReferenced)(
		/*[in]*/ IUnknown* /*pReferencingProject*/,
		/*[out,retval]*/ BOOL* /*pbAllowReferenced*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryRefreshReferences)(
		/*[in]*/ UPDATE_REFERENCE_REASON /*reason*/,
		/*[out,retval]*/ BOOL* /*pbUpdate*/)VSL_STDMETHOD_NOTIMPL
};

class IVsProjectFlavorReferencesMockImpl :
	public IVsProjectFlavorReferences,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectFlavorReferencesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsProjectFlavorReferencesMockImpl)

	typedef IVsProjectFlavorReferences Interface;
	struct QueryAddProjectReferenceValidValues
	{
		/*[in]*/ IUnknown* pReferencedProject;
		/*[out,retval]*/ BOOL* pbCanAdd;
		HRESULT retValue;
	};

	STDMETHOD(QueryAddProjectReference)(
		/*[in]*/ IUnknown* pReferencedProject,
		/*[out,retval]*/ BOOL* pbCanAdd)
	{
		VSL_DEFINE_MOCK_METHOD(QueryAddProjectReference)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pReferencedProject);

		VSL_SET_VALIDVALUE(pbCanAdd);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryCanBeReferencedValidValues
	{
		/*[in]*/ IUnknown* pReferencingProject;
		/*[out,retval]*/ BOOL* pbAllowReferenced;
		HRESULT retValue;
	};

	STDMETHOD(QueryCanBeReferenced)(
		/*[in]*/ IUnknown* pReferencingProject,
		/*[out,retval]*/ BOOL* pbAllowReferenced)
	{
		VSL_DEFINE_MOCK_METHOD(QueryCanBeReferenced)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pReferencingProject);

		VSL_SET_VALIDVALUE(pbAllowReferenced);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryRefreshReferencesValidValues
	{
		/*[in]*/ UPDATE_REFERENCE_REASON reason;
		/*[out,retval]*/ BOOL* pbUpdate;
		HRESULT retValue;
	};

	STDMETHOD(QueryRefreshReferences)(
		/*[in]*/ UPDATE_REFERENCE_REASON reason,
		/*[out,retval]*/ BOOL* pbUpdate)
	{
		VSL_DEFINE_MOCK_METHOD(QueryRefreshReferences)

		VSL_CHECK_VALIDVALUE(reason);

		VSL_SET_VALIDVALUE(pbUpdate);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROJECTFLAVORREFERENCES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsProjectSpecificEditorMap2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROJECTSPECIFICEDITORMAP2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROJECTSPECIFICEDITORMAP2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsProjectSpecificEditorMap2NotImpl :
	public IVsProjectSpecificEditorMap2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectSpecificEditorMap2NotImpl)

public:

	typedef IVsProjectSpecificEditorMap2 Interface;

	STDMETHOD(GetSpecificLanguageService)(
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[out,retval]*/ GUID* /*pguidLanguageService*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSpecificEditorProperty)(
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[in]*/ VSPSEPROPID /*propid*/,
		/*[out,retval]*/ VARIANT* /*pvar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetSpecificEditorProperty)(
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[in]*/ VSPSEPROPID /*propid*/,
		/*[in]*/ VARIANT /*var*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSpecificEditorType)(
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[out,retval]*/ GUID* /*pguidEditorType*/)VSL_STDMETHOD_NOTIMPL
};

class IVsProjectSpecificEditorMap2MockImpl :
	public IVsProjectSpecificEditorMap2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectSpecificEditorMap2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsProjectSpecificEditorMap2MockImpl)

	typedef IVsProjectSpecificEditorMap2 Interface;
	struct GetSpecificLanguageServiceValidValues
	{
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[out,retval]*/ GUID* pguidLanguageService;
		HRESULT retValue;
	};

	STDMETHOD(GetSpecificLanguageService)(
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[out,retval]*/ GUID* pguidLanguageService)
	{
		VSL_DEFINE_MOCK_METHOD(GetSpecificLanguageService)

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_SET_VALIDVALUE(pguidLanguageService);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSpecificEditorPropertyValidValues
	{
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[in]*/ VSPSEPROPID propid;
		/*[out,retval]*/ VARIANT* pvar;
		HRESULT retValue;
	};

	STDMETHOD(GetSpecificEditorProperty)(
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[in]*/ VSPSEPROPID propid,
		/*[out,retval]*/ VARIANT* pvar)
	{
		VSL_DEFINE_MOCK_METHOD(GetSpecificEditorProperty)

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_CHECK_VALIDVALUE(propid);

		VSL_SET_VALIDVALUE_VARIANT(pvar);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetSpecificEditorPropertyValidValues
	{
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[in]*/ VSPSEPROPID propid;
		/*[in]*/ VARIANT var;
		HRESULT retValue;
	};

	STDMETHOD(SetSpecificEditorProperty)(
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[in]*/ VSPSEPROPID propid,
		/*[in]*/ VARIANT var)
	{
		VSL_DEFINE_MOCK_METHOD(SetSpecificEditorProperty)

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_CHECK_VALIDVALUE(propid);

		VSL_CHECK_VALIDVALUE(var);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSpecificEditorTypeValidValues
	{
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[out,retval]*/ GUID* pguidEditorType;
		HRESULT retValue;
	};

	STDMETHOD(GetSpecificEditorType)(
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[out,retval]*/ GUID* pguidEditorType)
	{
		VSL_DEFINE_MOCK_METHOD(GetSpecificEditorType)

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_SET_VALIDVALUE(pguidEditorType);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROJECTSPECIFICEDITORMAP2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsProjectStartupServices.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROJECTSTARTUPSERVICES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROJECTSTARTUPSERVICES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsProjectStartupServicesNotImpl :
	public IVsProjectStartupServices
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectStartupServicesNotImpl)

public:

	typedef IVsProjectStartupServices Interface;

	STDMETHOD(AddStartupService)(
		/*[in]*/ REFGUID /*guidService*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveStartupService)(
		/*[in]*/ REFGUID /*guidService*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetStartupServiceEnum)(
		/*[out]*/ IEnumProjectStartupServices** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL
};

class IVsProjectStartupServicesMockImpl :
	public IVsProjectStartupServices,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectStartupServicesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsProjectStartupServicesMockImpl)

	typedef IVsProjectStartupServices Interface;
	struct AddStartupServiceValidValues
	{
		/*[in]*/ REFGUID guidService;
		HRESULT retValue;
	};

	STDMETHOD(AddStartupService)(
		/*[in]*/ REFGUID guidService)
	{
		VSL_DEFINE_MOCK_METHOD(AddStartupService)

		VSL_CHECK_VALIDVALUE(guidService);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveStartupServiceValidValues
	{
		/*[in]*/ REFGUID guidService;
		HRESULT retValue;
	};

	STDMETHOD(RemoveStartupService)(
		/*[in]*/ REFGUID guidService)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveStartupService)

		VSL_CHECK_VALIDVALUE(guidService);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetStartupServiceEnumValidValues
	{
		/*[out]*/ IEnumProjectStartupServices** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(GetStartupServiceEnum)(
		/*[out]*/ IEnumProjectStartupServices** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(GetStartupServiceEnum)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROJECTSTARTUPSERVICES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsProjectUpgrade.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROJECTUPGRADE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROJECTUPGRADE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsProjectUpgradeNotImpl :
	public IVsProjectUpgrade
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectUpgradeNotImpl)

public:

	typedef IVsProjectUpgrade Interface;

	STDMETHOD(UpgradeProject)(
		/*[in]*/ VSUPGRADEPROJFLAGS /*grfUpgradeFlags*/)VSL_STDMETHOD_NOTIMPL
};

class IVsProjectUpgradeMockImpl :
	public IVsProjectUpgrade,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectUpgradeMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsProjectUpgradeMockImpl)

	typedef IVsProjectUpgrade Interface;
	struct UpgradeProjectValidValues
	{
		/*[in]*/ VSUPGRADEPROJFLAGS grfUpgradeFlags;
		HRESULT retValue;
	};

	STDMETHOD(UpgradeProject)(
		/*[in]*/ VSUPGRADEPROJFLAGS grfUpgradeFlags)
	{
		VSL_DEFINE_MOCK_METHOD(UpgradeProject)

		VSL_CHECK_VALIDVALUE(grfUpgradeFlags);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROJECTUPGRADE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsProjectTextImageProvider.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROJECTTEXTIMAGEPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROJECTTEXTIMAGEPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsProjectTextImageProviderNotImpl :
	public IVsProjectTextImageProvider
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectTextImageProviderNotImpl)

public:

	typedef IVsProjectTextImageProvider Interface;

	STDMETHOD(OpenItemTextImage)(
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[in]*/ VSPTIP_MODE /*grfMode*/,
		/*[out,retval]*/ IVsTextImage** /*ppTextImage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CloseItemTextImage)(
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[in]*/ VSPTIP_DISPOSITION /*vsptipDisposition*/,
		/*[in]*/ IVsTextImage* /*pTextImage*/)VSL_STDMETHOD_NOTIMPL
};

class IVsProjectTextImageProviderMockImpl :
	public IVsProjectTextImageProvider,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectTextImageProviderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsProjectTextImageProviderMockImpl)

	typedef IVsProjectTextImageProvider Interface;
	struct OpenItemTextImageValidValues
	{
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[in]*/ VSPTIP_MODE grfMode;
		/*[out,retval]*/ IVsTextImage** ppTextImage;
		HRESULT retValue;
	};

	STDMETHOD(OpenItemTextImage)(
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[in]*/ VSPTIP_MODE grfMode,
		/*[out,retval]*/ IVsTextImage** ppTextImage)
	{
		VSL_DEFINE_MOCK_METHOD(OpenItemTextImage)

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_CHECK_VALIDVALUE(grfMode);

		VSL_SET_VALIDVALUE_INTERFACE(ppTextImage);

		VSL_RETURN_VALIDVALUES();
	}
	struct CloseItemTextImageValidValues
	{
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[in]*/ VSPTIP_DISPOSITION vsptipDisposition;
		/*[in]*/ IVsTextImage* pTextImage;
		HRESULT retValue;
	};

	STDMETHOD(CloseItemTextImage)(
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[in]*/ VSPTIP_DISPOSITION vsptipDisposition,
		/*[in]*/ IVsTextImage* pTextImage)
	{
		VSL_DEFINE_MOCK_METHOD(CloseItemTextImage)

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_CHECK_VALIDVALUE(vsptipDisposition);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pTextImage);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROJECTTEXTIMAGEPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsProjectSpecialFiles.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROJECTSPECIALFILES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROJECTSPECIALFILES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsProjectSpecialFilesNotImpl :
	public IVsProjectSpecialFiles
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectSpecialFilesNotImpl)

public:

	typedef IVsProjectSpecialFiles Interface;

	STDMETHOD(GetFile)(
		/*[in]*/ PSFFILEID /*fileID*/,
		/*[in]*/ PSFFLAGS /*grfFlags*/,
		/*[out]*/ VSITEMID* /*pitemid*/,
		/*[out]*/ BSTR* /*pbstrFilename*/)VSL_STDMETHOD_NOTIMPL
};

class IVsProjectSpecialFilesMockImpl :
	public IVsProjectSpecialFiles,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectSpecialFilesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsProjectSpecialFilesMockImpl)

	typedef IVsProjectSpecialFiles Interface;
	struct GetFileValidValues
	{
		/*[in]*/ PSFFILEID fileID;
		/*[in]*/ PSFFLAGS grfFlags;
		/*[out]*/ VSITEMID* pitemid;
		/*[out]*/ BSTR* pbstrFilename;
		HRESULT retValue;
	};

	STDMETHOD(GetFile)(
		/*[in]*/ PSFFILEID fileID,
		/*[in]*/ PSFFLAGS grfFlags,
		/*[out]*/ VSITEMID* pitemid,
		/*[out]*/ BSTR* pbstrFilename)
	{
		VSL_DEFINE_MOCK_METHOD(GetFile)

		VSL_CHECK_VALIDVALUE(fileID);

		VSL_CHECK_VALIDVALUE(grfFlags);

		VSL_SET_VALIDVALUE(pitemid);

		VSL_SET_VALIDVALUE_BSTR(pbstrFilename);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROJECTSPECIALFILES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsProjectSpecificEditorMap.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROJECTSPECIFICEDITORMAP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROJECTSPECIFICEDITORMAP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsProjectSpecificEditorMapNotImpl :
	public IVsProjectSpecificEditorMap
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectSpecificEditorMapNotImpl)

public:

	typedef IVsProjectSpecificEditorMap Interface;

	STDMETHOD(GetSpecificEditorType)(
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[out,retval]*/ GUID* /*pguidEditorType*/)VSL_STDMETHOD_NOTIMPL
};

class IVsProjectSpecificEditorMapMockImpl :
	public IVsProjectSpecificEditorMap,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectSpecificEditorMapMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsProjectSpecificEditorMapMockImpl)

	typedef IVsProjectSpecificEditorMap Interface;
	struct GetSpecificEditorTypeValidValues
	{
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[out,retval]*/ GUID* pguidEditorType;
		HRESULT retValue;
	};

	STDMETHOD(GetSpecificEditorType)(
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[out,retval]*/ GUID* pguidEditorType)
	{
		VSL_DEFINE_MOCK_METHOD(GetSpecificEditorType)

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_SET_VALIDVALUE(pguidEditorType);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROJECTSPECIFICEDITORMAP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsProjectResources.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROJECTRESOURCES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROJECTRESOURCES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsProjectResourcesNotImpl :
	public IVsProjectResources
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectResourcesNotImpl)

public:

	typedef IVsProjectResources Interface;

	STDMETHOD(GetResourceItem)(
		/*[in]*/ VSITEMID /*itemidDocument*/,
		/*[in]*/ LPCOLESTR /*pszCulture*/,
		/*[in]*/ VSPROJRESFLAGS /*grfPRF*/,
		/*[out,retval]*/ VSITEMID* /*pitemidResource*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateResourceDocData)(
		/*[in]*/ VSITEMID /*itemidResource*/,
		/*[out,retval]*/ IUnknown** /*punkDocData*/)VSL_STDMETHOD_NOTIMPL
};

class IVsProjectResourcesMockImpl :
	public IVsProjectResources,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectResourcesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsProjectResourcesMockImpl)

	typedef IVsProjectResources Interface;
	struct GetResourceItemValidValues
	{
		/*[in]*/ VSITEMID itemidDocument;
		/*[in]*/ LPCOLESTR pszCulture;
		/*[in]*/ VSPROJRESFLAGS grfPRF;
		/*[out,retval]*/ VSITEMID* pitemidResource;
		HRESULT retValue;
	};

	STDMETHOD(GetResourceItem)(
		/*[in]*/ VSITEMID itemidDocument,
		/*[in]*/ LPCOLESTR pszCulture,
		/*[in]*/ VSPROJRESFLAGS grfPRF,
		/*[out,retval]*/ VSITEMID* pitemidResource)
	{
		VSL_DEFINE_MOCK_METHOD(GetResourceItem)

		VSL_CHECK_VALIDVALUE(itemidDocument);

		VSL_CHECK_VALIDVALUE_STRINGW(pszCulture);

		VSL_CHECK_VALIDVALUE(grfPRF);

		VSL_SET_VALIDVALUE(pitemidResource);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateResourceDocDataValidValues
	{
		/*[in]*/ VSITEMID itemidResource;
		/*[out,retval]*/ IUnknown** punkDocData;
		HRESULT retValue;
	};

	STDMETHOD(CreateResourceDocData)(
		/*[in]*/ VSITEMID itemidResource,
		/*[out,retval]*/ IUnknown** punkDocData)
	{
		VSL_DEFINE_MOCK_METHOD(CreateResourceDocData)

		VSL_CHECK_VALIDVALUE(itemidResource);

		VSL_SET_VALIDVALUE_INTERFACE(punkDocData);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROJECTRESOURCES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsPropertyFileIn.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROPERTYFILEIN_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROPERTYFILEIN_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsPropertyFileInNotImpl :
	public IVsPropertyFileIn
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPropertyFileInNotImpl)

public:

	typedef IVsPropertyFileIn Interface;

	STDMETHOD(Close)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Read)(
		/*[in]*/ ULONG /*cchPropertyName*/,
		/*[in,out,size_is(cchPropertyName)]*/ OLECHAR[] /*szPropertyName*/,
		/*[out]*/ ULONG* /*pcchPropertyNameActual*/,
		/*[out]*/ VSPROPERTYSTREAMPROPERTYTYPE* /*pvspspt*/,
		/*[out]*/ VARIANT* /*pvarValue*/,
		/*[in]*/ IErrorLog* /*pIErrorLog*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SkipToEnd)()VSL_STDMETHOD_NOTIMPL
};

class IVsPropertyFileInMockImpl :
	public IVsPropertyFileIn,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPropertyFileInMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsPropertyFileInMockImpl)

	typedef IVsPropertyFileIn Interface;
	struct CloseValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Close)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Close)

		VSL_RETURN_VALIDVALUES();
	}
	struct ReadValidValues
	{
		/*[in]*/ ULONG cchPropertyName;
		/*[in,out,size_is(cchPropertyName)]*/ OLECHAR* szPropertyName;
		/*[out]*/ ULONG* pcchPropertyNameActual;
		/*[out]*/ VSPROPERTYSTREAMPROPERTYTYPE* pvspspt;
		/*[out]*/ VARIANT* pvarValue;
		/*[in]*/ IErrorLog* pIErrorLog;
		HRESULT retValue;
	};

	STDMETHOD(Read)(
		/*[in]*/ ULONG cchPropertyName,
		/*[in,out,size_is(cchPropertyName)]*/ OLECHAR szPropertyName[],
		/*[out]*/ ULONG* pcchPropertyNameActual,
		/*[out]*/ VSPROPERTYSTREAMPROPERTYTYPE* pvspspt,
		/*[out]*/ VARIANT* pvarValue,
		/*[in]*/ IErrorLog* pIErrorLog)
	{
		VSL_DEFINE_MOCK_METHOD(Read)

		VSL_CHECK_VALIDVALUE(cchPropertyName);

		VSL_SET_VALIDVALUE_STRINGW(szPropertyName, cchPropertyName);

		VSL_SET_VALIDVALUE(pcchPropertyNameActual);

		VSL_SET_VALIDVALUE(pvspspt);

		VSL_SET_VALIDVALUE_VARIANT(pvarValue);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIErrorLog);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipToEndValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(SkipToEnd)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(SkipToEnd)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROPERTYFILEIN_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsPropertyPage.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROPERTYPAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROPERTYPAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsPropertyPageNotImpl :
	public IVsPropertyPage
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPropertyPageNotImpl)

public:

	typedef IVsPropertyPage Interface;

	STDMETHOD(get_CategoryTitle)(
		/*[in]*/ UINT /*iLevel*/,
		/*[out,retval]*/ BSTR* /*pbstrCategory*/)VSL_STDMETHOD_NOTIMPL
};

class IVsPropertyPageMockImpl :
	public IVsPropertyPage,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPropertyPageMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsPropertyPageMockImpl)

	typedef IVsPropertyPage Interface;
	struct get_CategoryTitleValidValues
	{
		/*[in]*/ UINT iLevel;
		/*[out,retval]*/ BSTR* pbstrCategory;
		HRESULT retValue;
	};

	STDMETHOD(get_CategoryTitle)(
		/*[in]*/ UINT iLevel,
		/*[out,retval]*/ BSTR* pbstrCategory)
	{
		VSL_DEFINE_MOCK_METHOD(get_CategoryTitle)

		VSL_CHECK_VALIDVALUE(iLevel);

		VSL_SET_VALIDVALUE_BSTR(pbstrCategory);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROPERTYPAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsProjectUpgradeViaFactory2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROJECTUPGRADEVIAFACTORY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROJECTUPGRADEVIAFACTORY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsProjectUpgradeViaFactory2NotImpl :
	public IVsProjectUpgradeViaFactory2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectUpgradeViaFactory2NotImpl)

public:

	typedef IVsProjectUpgradeViaFactory2 Interface;

	STDMETHOD(OnUpgradeProjectCancelled)(
		/*[in]*/ BSTR /*bstrFileName*/)VSL_STDMETHOD_NOTIMPL
};

class IVsProjectUpgradeViaFactory2MockImpl :
	public IVsProjectUpgradeViaFactory2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectUpgradeViaFactory2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsProjectUpgradeViaFactory2MockImpl)

	typedef IVsProjectUpgradeViaFactory2 Interface;
	struct OnUpgradeProjectCancelledValidValues
	{
		/*[in]*/ BSTR bstrFileName;
		HRESULT retValue;
	};

	STDMETHOD(OnUpgradeProjectCancelled)(
		/*[in]*/ BSTR bstrFileName)
	{
		VSL_DEFINE_MOCK_METHOD(OnUpgradeProjectCancelled)

		VSL_CHECK_VALIDVALUE_BSTR(bstrFileName);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROJECTUPGRADEVIAFACTORY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsPropertyBrowser.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROPERTYBROWSER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROPERTYBROWSER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsPropertyBrowserNotImpl :
	public IVsPropertyBrowser
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPropertyBrowserNotImpl)

public:

	typedef IVsPropertyBrowser Interface;

	STDMETHOD(GetState)(
		/*[in,out]*/ VsPropertyBrowserState* /*pState*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetState)(
		/*[in]*/ const VsPropertyBrowserState* /*pState*/)VSL_STDMETHOD_NOTIMPL
};

class IVsPropertyBrowserMockImpl :
	public IVsPropertyBrowser,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPropertyBrowserMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsPropertyBrowserMockImpl)

	typedef IVsPropertyBrowser Interface;
	struct GetStateValidValues
	{
		/*[in,out]*/ VsPropertyBrowserState* pState;
		HRESULT retValue;
	};

	STDMETHOD(GetState)(
		/*[in,out]*/ VsPropertyBrowserState* pState)
	{
		VSL_DEFINE_MOCK_METHOD(GetState)

		VSL_SET_VALIDVALUE(pState);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetStateValidValues
	{
		/*[in]*/ VsPropertyBrowserState* pState;
		HRESULT retValue;
	};

	STDMETHOD(SetState)(
		/*[in]*/ const VsPropertyBrowserState* pState)
	{
		VSL_DEFINE_MOCK_METHOD(SetState)

		VSL_CHECK_VALIDVALUE_POINTER(pState);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROPERTYBROWSER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsProjectUpgradeViaFactory.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROJECTUPGRADEVIAFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROJECTUPGRADEVIAFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsProjectUpgradeViaFactoryNotImpl :
	public IVsProjectUpgradeViaFactory
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectUpgradeViaFactoryNotImpl)

public:

	typedef IVsProjectUpgradeViaFactory Interface;

	STDMETHOD(UpgradeProject)(
		/*[in]*/ BSTR /*bstrFileName*/,
		/*[in]*/ VSPUVF_FLAGS /*fUpgradeFlag*/,
		/*[in]*/ BSTR /*bstrCopyLocation*/,
		/*[out]*/ BSTR* /*pbstrUpgradedFullyQualifiedFileName*/,
		/*[in]*/ IVsUpgradeLogger* /*pLogger*/,
		/*[out]*/ BOOL* /*pUpgradeRequired*/,
		/*[out]*/ GUID* /*pguidNewProjectFactory*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpgradeProject_CheckOnly)(
		/*[in]*/ BSTR /*bstrFileName*/,
		/*[in]*/ IVsUpgradeLogger* /*pLogger*/,
		/*[out]*/ BOOL* /*pUpgradeRequired*/,
		/*[out]*/ GUID* /*pguidNewProjectFactory*/,
		/*[out]*/ VSPUVF_FLAGS* /*pUpgradeProjectCapabilityFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSccInfo)(
		/*[in]*/ BSTR /*bstrProjectFileName*/,
		/*[out]*/ BSTR* /*pbstrSccProjectName*/,
		/*[out]*/ BSTR* /*pbstrSccAuxPath*/,
		/*[out]*/ BSTR* /*pbstrSccLocalPath*/,
		/*[out]*/ BSTR* /*pbstrProvider*/)VSL_STDMETHOD_NOTIMPL
};

class IVsProjectUpgradeViaFactoryMockImpl :
	public IVsProjectUpgradeViaFactory,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProjectUpgradeViaFactoryMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsProjectUpgradeViaFactoryMockImpl)

	typedef IVsProjectUpgradeViaFactory Interface;
	struct UpgradeProjectValidValues
	{
		/*[in]*/ BSTR bstrFileName;
		/*[in]*/ VSPUVF_FLAGS fUpgradeFlag;
		/*[in]*/ BSTR bstrCopyLocation;
		/*[out]*/ BSTR* pbstrUpgradedFullyQualifiedFileName;
		/*[in]*/ IVsUpgradeLogger* pLogger;
		/*[out]*/ BOOL* pUpgradeRequired;
		/*[out]*/ GUID* pguidNewProjectFactory;
		HRESULT retValue;
	};

	STDMETHOD(UpgradeProject)(
		/*[in]*/ BSTR bstrFileName,
		/*[in]*/ VSPUVF_FLAGS fUpgradeFlag,
		/*[in]*/ BSTR bstrCopyLocation,
		/*[out]*/ BSTR* pbstrUpgradedFullyQualifiedFileName,
		/*[in]*/ IVsUpgradeLogger* pLogger,
		/*[out]*/ BOOL* pUpgradeRequired,
		/*[out]*/ GUID* pguidNewProjectFactory)
	{
		VSL_DEFINE_MOCK_METHOD(UpgradeProject)

		VSL_CHECK_VALIDVALUE_BSTR(bstrFileName);

		VSL_CHECK_VALIDVALUE(fUpgradeFlag);

		VSL_CHECK_VALIDVALUE_BSTR(bstrCopyLocation);

		VSL_SET_VALIDVALUE_BSTR(pbstrUpgradedFullyQualifiedFileName);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pLogger);

		VSL_SET_VALIDVALUE(pUpgradeRequired);

		VSL_SET_VALIDVALUE(pguidNewProjectFactory);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpgradeProject_CheckOnlyValidValues
	{
		/*[in]*/ BSTR bstrFileName;
		/*[in]*/ IVsUpgradeLogger* pLogger;
		/*[out]*/ BOOL* pUpgradeRequired;
		/*[out]*/ GUID* pguidNewProjectFactory;
		/*[out]*/ VSPUVF_FLAGS* pUpgradeProjectCapabilityFlags;
		HRESULT retValue;
	};

	STDMETHOD(UpgradeProject_CheckOnly)(
		/*[in]*/ BSTR bstrFileName,
		/*[in]*/ IVsUpgradeLogger* pLogger,
		/*[out]*/ BOOL* pUpgradeRequired,
		/*[out]*/ GUID* pguidNewProjectFactory,
		/*[out]*/ VSPUVF_FLAGS* pUpgradeProjectCapabilityFlags)
	{
		VSL_DEFINE_MOCK_METHOD(UpgradeProject_CheckOnly)

		VSL_CHECK_VALIDVALUE_BSTR(bstrFileName);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pLogger);

		VSL_SET_VALIDVALUE(pUpgradeRequired);

		VSL_SET_VALIDVALUE(pguidNewProjectFactory);

		VSL_SET_VALIDVALUE(pUpgradeProjectCapabilityFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSccInfoValidValues
	{
		/*[in]*/ BSTR bstrProjectFileName;
		/*[out]*/ BSTR* pbstrSccProjectName;
		/*[out]*/ BSTR* pbstrSccAuxPath;
		/*[out]*/ BSTR* pbstrSccLocalPath;
		/*[out]*/ BSTR* pbstrProvider;
		HRESULT retValue;
	};

	STDMETHOD(GetSccInfo)(
		/*[in]*/ BSTR bstrProjectFileName,
		/*[out]*/ BSTR* pbstrSccProjectName,
		/*[out]*/ BSTR* pbstrSccAuxPath,
		/*[out]*/ BSTR* pbstrSccLocalPath,
		/*[out]*/ BSTR* pbstrProvider)
	{
		VSL_DEFINE_MOCK_METHOD(GetSccInfo)

		VSL_CHECK_VALIDVALUE_BSTR(bstrProjectFileName);

		VSL_SET_VALIDVALUE_BSTR(pbstrSccProjectName);

		VSL_SET_VALIDVALUE_BSTR(pbstrSccAuxPath);

		VSL_SET_VALIDVALUE_BSTR(pbstrSccLocalPath);

		VSL_SET_VALIDVALUE_BSTR(pbstrProvider);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROJECTUPGRADEVIAFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsPropertyFileOut.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROPERTYFILEOUT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROPERTYFILEOUT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsPropertyFileOutNotImpl :
	public IVsPropertyFileOut
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPropertyFileOutNotImpl)

public:

	typedef IVsPropertyFileOut Interface;

	STDMETHOD(Close)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Write)(
		/*[in]*/ LPCOLESTR /*szPropertyName*/,
		/*[in]*/ VARIANT /*varValue*/,
		/*[in,optional]*/ LPCOLESTR /*szLineComment*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(WriteSzAsBSTR)(
		/*[in]*/ LPCOLESTR /*szPropertyName*/,
		/*[in]*/ LPCOLESTR /*szValue*/,
		/*[in,optional]*/ LPCOLESTR /*szLineComment*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(BeginPropertySection)(
		/*[in]*/ LPCOLESTR /*szName*/,
		/*[in]*/ LPCOLESTR /*szLineComment*/,
		/*[out]*/ IVsPropertyStreamOut** /*ppIVsPropertyStreamOut*/,
		/*[out]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EndPropertySection)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Flush)()VSL_STDMETHOD_NOTIMPL
};

class IVsPropertyFileOutMockImpl :
	public IVsPropertyFileOut,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPropertyFileOutMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsPropertyFileOutMockImpl)

	typedef IVsPropertyFileOut Interface;
	struct CloseValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Close)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Close)

		VSL_RETURN_VALIDVALUES();
	}
	struct WriteValidValues
	{
		/*[in]*/ LPCOLESTR szPropertyName;
		/*[in]*/ VARIANT varValue;
		/*[in,optional]*/ LPCOLESTR szLineComment;
		HRESULT retValue;
	};

	STDMETHOD(Write)(
		/*[in]*/ LPCOLESTR szPropertyName,
		/*[in]*/ VARIANT varValue,
		/*[in,optional]*/ LPCOLESTR szLineComment)
	{
		VSL_DEFINE_MOCK_METHOD(Write)

		VSL_CHECK_VALIDVALUE_STRINGW(szPropertyName);

		VSL_CHECK_VALIDVALUE(varValue);

		VSL_CHECK_VALIDVALUE_STRINGW(szLineComment);

		VSL_RETURN_VALIDVALUES();
	}
	struct WriteSzAsBSTRValidValues
	{
		/*[in]*/ LPCOLESTR szPropertyName;
		/*[in]*/ LPCOLESTR szValue;
		/*[in,optional]*/ LPCOLESTR szLineComment;
		HRESULT retValue;
	};

	STDMETHOD(WriteSzAsBSTR)(
		/*[in]*/ LPCOLESTR szPropertyName,
		/*[in]*/ LPCOLESTR szValue,
		/*[in,optional]*/ LPCOLESTR szLineComment)
	{
		VSL_DEFINE_MOCK_METHOD(WriteSzAsBSTR)

		VSL_CHECK_VALIDVALUE_STRINGW(szPropertyName);

		VSL_CHECK_VALIDVALUE_STRINGW(szValue);

		VSL_CHECK_VALIDVALUE_STRINGW(szLineComment);

		VSL_RETURN_VALIDVALUES();
	}
	struct BeginPropertySectionValidValues
	{
		/*[in]*/ LPCOLESTR szName;
		/*[in]*/ LPCOLESTR szLineComment;
		/*[out]*/ IVsPropertyStreamOut** ppIVsPropertyStreamOut;
		/*[out]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(BeginPropertySection)(
		/*[in]*/ LPCOLESTR szName,
		/*[in]*/ LPCOLESTR szLineComment,
		/*[out]*/ IVsPropertyStreamOut** ppIVsPropertyStreamOut,
		/*[out]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(BeginPropertySection)

		VSL_CHECK_VALIDVALUE_STRINGW(szName);

		VSL_CHECK_VALIDVALUE_STRINGW(szLineComment);

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsPropertyStreamOut);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct EndPropertySectionValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(EndPropertySection)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(EndPropertySection)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct FlushValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Flush)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Flush)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROPERTYFILEOUT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsPropertyPage2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROPERTYPAGE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROPERTYPAGE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsPropertyPage2NotImpl :
	public IVsPropertyPage2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPropertyPage2NotImpl)

public:

	typedef IVsPropertyPage2 Interface;

	STDMETHOD(GetProperty)(
		/*[in]*/ VSPPPID /*propid*/,
		/*[out]*/ VARIANT* /*pvar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetProperty)(
		/*[in]*/ VSPPPID /*propid*/,
		/*[in]*/ VARIANT /*var*/)VSL_STDMETHOD_NOTIMPL
};

class IVsPropertyPage2MockImpl :
	public IVsPropertyPage2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPropertyPage2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsPropertyPage2MockImpl)

	typedef IVsPropertyPage2 Interface;
	struct GetPropertyValidValues
	{
		/*[in]*/ VSPPPID propid;
		/*[out]*/ VARIANT* pvar;
		HRESULT retValue;
	};

	STDMETHOD(GetProperty)(
		/*[in]*/ VSPPPID propid,
		/*[out]*/ VARIANT* pvar)
	{
		VSL_DEFINE_MOCK_METHOD(GetProperty)

		VSL_CHECK_VALIDVALUE(propid);

		VSL_SET_VALIDVALUE_VARIANT(pvar);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetPropertyValidValues
	{
		/*[in]*/ VSPPPID propid;
		/*[in]*/ VARIANT var;
		HRESULT retValue;
	};

	STDMETHOD(SetProperty)(
		/*[in]*/ VSPPPID propid,
		/*[in]*/ VARIANT var)
	{
		VSL_DEFINE_MOCK_METHOD(SetProperty)

		VSL_CHECK_VALIDVALUE(propid);

		VSL_CHECK_VALIDVALUE(var);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROPERTYPAGE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsPropertyPageFrame.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROPERTYPAGEFRAME_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROPERTYPAGEFRAME_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsPropertyPageFrameNotImpl :
	public IVsPropertyPageFrame
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPropertyPageFrameNotImpl)

public:

	typedef IVsPropertyPageFrame Interface;

	STDMETHOD(ShowFrame)(
		/*[in]*/ CLSID /*clsidInitialPage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(HideFrame)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Update)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanShowPropertyPages)(
		/*[out,retval]*/ BOOL* /*pbCanShow*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReportError)(
		/*[in]*/ HRESULT /*hrErr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ShowFrameDISPID)(
		/*[in]*/ DISPID /*dispidToActivate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateAfterApply)()VSL_STDMETHOD_NOTIMPL
};

class IVsPropertyPageFrameMockImpl :
	public IVsPropertyPageFrame,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPropertyPageFrameMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsPropertyPageFrameMockImpl)

	typedef IVsPropertyPageFrame Interface;
	struct ShowFrameValidValues
	{
		/*[in]*/ CLSID clsidInitialPage;
		HRESULT retValue;
	};

	STDMETHOD(ShowFrame)(
		/*[in]*/ CLSID clsidInitialPage)
	{
		VSL_DEFINE_MOCK_METHOD(ShowFrame)

		VSL_CHECK_VALIDVALUE(clsidInitialPage);

		VSL_RETURN_VALIDVALUES();
	}
	struct HideFrameValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(HideFrame)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(HideFrame)

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Update)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Update)

		VSL_RETURN_VALIDVALUES();
	}
	struct CanShowPropertyPagesValidValues
	{
		/*[out,retval]*/ BOOL* pbCanShow;
		HRESULT retValue;
	};

	STDMETHOD(CanShowPropertyPages)(
		/*[out,retval]*/ BOOL* pbCanShow)
	{
		VSL_DEFINE_MOCK_METHOD(CanShowPropertyPages)

		VSL_SET_VALIDVALUE(pbCanShow);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReportErrorValidValues
	{
		/*[in]*/ HRESULT hrErr;
		HRESULT retValue;
	};

	STDMETHOD(ReportError)(
		/*[in]*/ HRESULT hrErr)
	{
		VSL_DEFINE_MOCK_METHOD(ReportError)

		VSL_CHECK_VALIDVALUE(hrErr);

		VSL_RETURN_VALIDVALUES();
	}
	struct ShowFrameDISPIDValidValues
	{
		/*[in]*/ DISPID dispidToActivate;
		HRESULT retValue;
	};

	STDMETHOD(ShowFrameDISPID)(
		/*[in]*/ DISPID dispidToActivate)
	{
		VSL_DEFINE_MOCK_METHOD(ShowFrameDISPID)

		VSL_CHECK_VALIDVALUE(dispidToActivate);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateAfterApplyValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(UpdateAfterApply)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(UpdateAfterApply)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROPERTYPAGEFRAME_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsProvideUserContext2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROVIDEUSERCONTEXT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROVIDEUSERCONTEXT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsProvideUserContext2NotImpl :
	public IVsProvideUserContext2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProvideUserContext2NotImpl)

public:

	typedef IVsProvideUserContext2 Interface;

	STDMETHOD(GetUserContextEx)(
		/*[out]*/ IVsUserContext** /*ppctx*/,
		/*[out]*/ int* /*iPriority*/)VSL_STDMETHOD_NOTIMPL
};

class IVsProvideUserContext2MockImpl :
	public IVsProvideUserContext2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProvideUserContext2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsProvideUserContext2MockImpl)

	typedef IVsProvideUserContext2 Interface;
	struct GetUserContextExValidValues
	{
		/*[out]*/ IVsUserContext** ppctx;
		/*[out]*/ int* iPriority;
		HRESULT retValue;
	};

	STDMETHOD(GetUserContextEx)(
		/*[out]*/ IVsUserContext** ppctx,
		/*[out]*/ int* iPriority)
	{
		VSL_DEFINE_MOCK_METHOD(GetUserContextEx)

		VSL_SET_VALIDVALUE_INTERFACE(ppctx);

		VSL_SET_VALIDVALUE(iPriority);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROVIDEUSERCONTEXT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsPropertyPageNotify.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROPERTYPAGENOTIFY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROPERTYPAGENOTIFY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsPropertyPageNotifyNotImpl :
	public IVsPropertyPageNotify
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPropertyPageNotifyNotImpl)

public:

	typedef IVsPropertyPageNotify Interface;

	STDMETHOD(OnShowPage)(
		/*[in]*/ BOOL /*fPageActivated*/)VSL_STDMETHOD_NOTIMPL
};

class IVsPropertyPageNotifyMockImpl :
	public IVsPropertyPageNotify,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPropertyPageNotifyMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsPropertyPageNotifyMockImpl)

	typedef IVsPropertyPageNotify Interface;
	struct OnShowPageValidValues
	{
		/*[in]*/ BOOL fPageActivated;
		HRESULT retValue;
	};

	STDMETHOD(OnShowPage)(
		/*[in]*/ BOOL fPageActivated)
	{
		VSL_DEFINE_MOCK_METHOD(OnShowPage)

		VSL_CHECK_VALIDVALUE(fPageActivated);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROPERTYPAGENOTIFY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsPropertyStreamIn.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROPERTYSTREAMIN_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROPERTYSTREAMIN_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsPropertyStreamInNotImpl :
	public IVsPropertyStreamIn
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPropertyStreamInNotImpl)

public:

	typedef IVsPropertyStreamIn Interface;

	STDMETHOD(Read)(
		/*[in]*/ ULONG /*cchPropertyName*/,
		/*[in,out,size_is(cchPropertyName)]*/ OLECHAR[] /*szPropertyName*/,
		/*[out]*/ ULONG* /*pcchPropertyNameActual*/,
		/*[out]*/ VSPROPERTYSTREAMPROPERTYTYPE* /*pvspspt*/,
		/*[out]*/ VARIANT* /*pvarValue*/,
		/*[in]*/ IErrorLog* /*pIErrorLog*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SkipToEnd)()VSL_STDMETHOD_NOTIMPL
};

class IVsPropertyStreamInMockImpl :
	public IVsPropertyStreamIn,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPropertyStreamInMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsPropertyStreamInMockImpl)

	typedef IVsPropertyStreamIn Interface;
	struct ReadValidValues
	{
		/*[in]*/ ULONG cchPropertyName;
		/*[in,out,size_is(cchPropertyName)]*/ OLECHAR* szPropertyName;
		/*[out]*/ ULONG* pcchPropertyNameActual;
		/*[out]*/ VSPROPERTYSTREAMPROPERTYTYPE* pvspspt;
		/*[out]*/ VARIANT* pvarValue;
		/*[in]*/ IErrorLog* pIErrorLog;
		HRESULT retValue;
	};

	STDMETHOD(Read)(
		/*[in]*/ ULONG cchPropertyName,
		/*[in,out,size_is(cchPropertyName)]*/ OLECHAR szPropertyName[],
		/*[out]*/ ULONG* pcchPropertyNameActual,
		/*[out]*/ VSPROPERTYSTREAMPROPERTYTYPE* pvspspt,
		/*[out]*/ VARIANT* pvarValue,
		/*[in]*/ IErrorLog* pIErrorLog)
	{
		VSL_DEFINE_MOCK_METHOD(Read)

		VSL_CHECK_VALIDVALUE(cchPropertyName);

		VSL_SET_VALIDVALUE_STRINGW(szPropertyName, cchPropertyName);

		VSL_SET_VALIDVALUE(pcchPropertyNameActual);

		VSL_SET_VALIDVALUE(pvspspt);

		VSL_SET_VALIDVALUE_VARIANT(pvarValue);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIErrorLog);

		VSL_RETURN_VALIDVALUES();
	}
	struct SkipToEndValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(SkipToEnd)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(SkipToEnd)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROPERTYSTREAMIN_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsProvideColorableItems.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROVIDECOLORABLEITEMS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROVIDECOLORABLEITEMS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsProvideColorableItemsNotImpl :
	public IVsProvideColorableItems
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProvideColorableItemsNotImpl)

public:

	typedef IVsProvideColorableItems Interface;

	STDMETHOD(GetItemCount)(
		/*[out]*/ int* /*piCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetColorableItem)(
		/*[in]*/ int /*iIndex*/,
		/*[out]*/ IVsColorableItem** /*ppItem*/)VSL_STDMETHOD_NOTIMPL
};

class IVsProvideColorableItemsMockImpl :
	public IVsProvideColorableItems,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProvideColorableItemsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsProvideColorableItemsMockImpl)

	typedef IVsProvideColorableItems Interface;
	struct GetItemCountValidValues
	{
		/*[out]*/ int* piCount;
		HRESULT retValue;
	};

	STDMETHOD(GetItemCount)(
		/*[out]*/ int* piCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetItemCount)

		VSL_SET_VALIDVALUE(piCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetColorableItemValidValues
	{
		/*[in]*/ int iIndex;
		/*[out]*/ IVsColorableItem** ppItem;
		HRESULT retValue;
	};

	STDMETHOD(GetColorableItem)(
		/*[in]*/ int iIndex,
		/*[out]*/ IVsColorableItem** ppItem)
	{
		VSL_DEFINE_MOCK_METHOD(GetColorableItem)

		VSL_CHECK_VALIDVALUE(iIndex);

		VSL_SET_VALIDVALUE_INTERFACE(ppItem);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROVIDECOLORABLEITEMS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsProvideComponentEnumeration.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROVIDECOMPONENTENUMERATION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROVIDECOMPONENTENUMERATION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "compsvcspkg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsProvideComponentEnumerationNotImpl :
	public IVsProvideComponentEnumeration
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProvideComponentEnumerationNotImpl)

public:

	typedef IVsProvideComponentEnumeration Interface;

	STDMETHOD(WriteXMLToFile)(
		/*[in]*/ BSTR /*bstrDesiredFile*/,
		/*[out]*/ BSTR* /*pbstrActualFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class IVsProvideComponentEnumerationMockImpl :
	public IVsProvideComponentEnumeration,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProvideComponentEnumerationMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsProvideComponentEnumerationMockImpl)

	typedef IVsProvideComponentEnumeration Interface;
	struct WriteXMLToFileValidValues
	{
		/*[in]*/ BSTR bstrDesiredFile;
		/*[out]*/ BSTR* pbstrActualFile;
		HRESULT retValue;
	};

	STDMETHOD(WriteXMLToFile)(
		/*[in]*/ BSTR bstrDesiredFile,
		/*[out]*/ BSTR* pbstrActualFile)
	{
		VSL_DEFINE_MOCK_METHOD(WriteXMLToFile)

		VSL_CHECK_VALIDVALUE_BSTR(bstrDesiredFile);

		VSL_SET_VALIDVALUE_BSTR(pbstrActualFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROVIDECOMPONENTENUMERATION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsPropertyStreamOut.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROPERTYSTREAMOUT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROPERTYSTREAMOUT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsPropertyStreamOutNotImpl :
	public IVsPropertyStreamOut
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPropertyStreamOutNotImpl)

public:

	typedef IVsPropertyStreamOut Interface;

	STDMETHOD(Write)(
		/*[in]*/ LPCOLESTR /*szPropertyName*/,
		/*[in]*/ VARIANT /*varValue*/,
		/*[in,optional]*/ LPCOLESTR /*szLineComment*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(WriteSzAsBSTR)(
		/*[in]*/ LPCOLESTR /*szPropertyName*/,
		/*[in]*/ LPCOLESTR /*szValue*/,
		/*[in,optional]*/ LPCOLESTR /*szLineComment*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(BeginPropertySection)(
		/*[in]*/ LPCOLESTR /*szName*/,
		/*[in]*/ LPCOLESTR /*szLineComment*/,
		/*[out]*/ IVsPropertyStreamOut** /*ppIVsPropertyStreamOut*/,
		/*[out]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EndPropertySection)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Flush)()VSL_STDMETHOD_NOTIMPL
};

class IVsPropertyStreamOutMockImpl :
	public IVsPropertyStreamOut,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPropertyStreamOutMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsPropertyStreamOutMockImpl)

	typedef IVsPropertyStreamOut Interface;
	struct WriteValidValues
	{
		/*[in]*/ LPCOLESTR szPropertyName;
		/*[in]*/ VARIANT varValue;
		/*[in,optional]*/ LPCOLESTR szLineComment;
		HRESULT retValue;
	};

	STDMETHOD(Write)(
		/*[in]*/ LPCOLESTR szPropertyName,
		/*[in]*/ VARIANT varValue,
		/*[in,optional]*/ LPCOLESTR szLineComment)
	{
		VSL_DEFINE_MOCK_METHOD(Write)

		VSL_CHECK_VALIDVALUE_STRINGW(szPropertyName);

		VSL_CHECK_VALIDVALUE(varValue);

		VSL_CHECK_VALIDVALUE_STRINGW(szLineComment);

		VSL_RETURN_VALIDVALUES();
	}
	struct WriteSzAsBSTRValidValues
	{
		/*[in]*/ LPCOLESTR szPropertyName;
		/*[in]*/ LPCOLESTR szValue;
		/*[in,optional]*/ LPCOLESTR szLineComment;
		HRESULT retValue;
	};

	STDMETHOD(WriteSzAsBSTR)(
		/*[in]*/ LPCOLESTR szPropertyName,
		/*[in]*/ LPCOLESTR szValue,
		/*[in,optional]*/ LPCOLESTR szLineComment)
	{
		VSL_DEFINE_MOCK_METHOD(WriteSzAsBSTR)

		VSL_CHECK_VALIDVALUE_STRINGW(szPropertyName);

		VSL_CHECK_VALIDVALUE_STRINGW(szValue);

		VSL_CHECK_VALIDVALUE_STRINGW(szLineComment);

		VSL_RETURN_VALIDVALUES();
	}
	struct BeginPropertySectionValidValues
	{
		/*[in]*/ LPCOLESTR szName;
		/*[in]*/ LPCOLESTR szLineComment;
		/*[out]*/ IVsPropertyStreamOut** ppIVsPropertyStreamOut;
		/*[out]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(BeginPropertySection)(
		/*[in]*/ LPCOLESTR szName,
		/*[in]*/ LPCOLESTR szLineComment,
		/*[out]*/ IVsPropertyStreamOut** ppIVsPropertyStreamOut,
		/*[out]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(BeginPropertySection)

		VSL_CHECK_VALIDVALUE_STRINGW(szName);

		VSL_CHECK_VALIDVALUE_STRINGW(szLineComment);

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsPropertyStreamOut);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct EndPropertySectionValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(EndPropertySection)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(EndPropertySection)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct FlushValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Flush)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Flush)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROPERTYSTREAMOUT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsProvideUserContext.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROVIDEUSERCONTEXT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROVIDEUSERCONTEXT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "context.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsProvideUserContextNotImpl :
	public IVsProvideUserContext
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProvideUserContextNotImpl)

public:

	typedef IVsProvideUserContext Interface;

	STDMETHOD(GetUserContext)(
		/*[out,retval]*/ IVsUserContext** /*ppctx*/)VSL_STDMETHOD_NOTIMPL
};

class IVsProvideUserContextMockImpl :
	public IVsProvideUserContext,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProvideUserContextMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsProvideUserContextMockImpl)

	typedef IVsProvideUserContext Interface;
	struct GetUserContextValidValues
	{
		/*[out,retval]*/ IVsUserContext** ppctx;
		HRESULT retValue;
	};

	STDMETHOD(GetUserContext)(
		/*[out,retval]*/ IVsUserContext** ppctx)
	{
		VSL_DEFINE_MOCK_METHOD(GetUserContext)

		VSL_SET_VALIDVALUE_INTERFACE(ppctx);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROVIDEUSERCONTEXT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsProvideUserContextForObject.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPROVIDEUSERCONTEXTFOROBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPROVIDEUSERCONTEXTFOROBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "context.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsProvideUserContextForObjectNotImpl :
	public IVsProvideUserContextForObject
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProvideUserContextForObjectNotImpl)

public:

	typedef IVsProvideUserContextForObject Interface;

	STDMETHOD(GetObjectContext)(
		/*[in]*/ IUnknown* /*punk*/,
		/*[out,retval]*/ IVsUserContext** /*ppctx*/)VSL_STDMETHOD_NOTIMPL
};

class IVsProvideUserContextForObjectMockImpl :
	public IVsProvideUserContextForObject,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsProvideUserContextForObjectMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsProvideUserContextForObjectMockImpl)

	typedef IVsProvideUserContextForObject Interface;
	struct GetObjectContextValidValues
	{
		/*[in]*/ IUnknown* punk;
		/*[out,retval]*/ IVsUserContext** ppctx;
		HRESULT retValue;
	};

	STDMETHOD(GetObjectContext)(
		/*[in]*/ IUnknown* punk,
		/*[out,retval]*/ IVsUserContext** ppctx)
	{
		VSL_DEFINE_MOCK_METHOD(GetObjectContext)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punk);

		VSL_SET_VALIDVALUE_INTERFACE(ppctx);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPROVIDEUSERCONTEXTFOROBJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsQueryDebuggableProjectCfg.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSQUERYDEBUGGABLEPROJECTCFG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSQUERYDEBUGGABLEPROJECTCFG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsQueryDebuggableProjectCfgNotImpl :
	public IVsQueryDebuggableProjectCfg
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsQueryDebuggableProjectCfgNotImpl)

public:

	typedef IVsQueryDebuggableProjectCfg Interface;

	STDMETHOD(QueryDebugTargets)(
		/*[in]*/ VSDBGLAUNCHFLAGS /*grfLaunch*/,
		/*[in]*/ ULONG /*cTargets*/,
		/*[in,out,size_is(cTargets)]*/ VsDebugTargetInfo2[] /*rgDebugTargetInfo*/,
		/*[out,optional]*/ ULONG* /*pcActual*/)VSL_STDMETHOD_NOTIMPL
};

class IVsQueryDebuggableProjectCfgMockImpl :
	public IVsQueryDebuggableProjectCfg,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsQueryDebuggableProjectCfgMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsQueryDebuggableProjectCfgMockImpl)

	typedef IVsQueryDebuggableProjectCfg Interface;
	struct QueryDebugTargetsValidValues
	{
		/*[in]*/ VSDBGLAUNCHFLAGS grfLaunch;
		/*[in]*/ ULONG cTargets;
		/*[in,out,size_is(cTargets)]*/ VsDebugTargetInfo2* rgDebugTargetInfo;
		/*[out,optional]*/ ULONG* pcActual;
		HRESULT retValue;
	};

	STDMETHOD(QueryDebugTargets)(
		/*[in]*/ VSDBGLAUNCHFLAGS grfLaunch,
		/*[in]*/ ULONG cTargets,
		/*[in,out,size_is(cTargets)]*/ VsDebugTargetInfo2 rgDebugTargetInfo[],
		/*[out,optional]*/ ULONG* pcActual)
	{
		VSL_DEFINE_MOCK_METHOD(QueryDebugTargets)

		VSL_CHECK_VALIDVALUE(grfLaunch);

		VSL_CHECK_VALIDVALUE(cTargets);

		VSL_SET_VALIDVALUE_MEMCPY(rgDebugTargetInfo, cTargets*sizeof(rgDebugTargetInfo[0]), validValues.cTargets*sizeof(validValues.rgDebugTargetInfo[0]));

		VSL_SET_VALIDVALUE(pcActual);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSQUERYDEBUGGABLEPROJECTCFG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsPublishableProjectStatusCallback.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPUBLISHABLEPROJECTSTATUSCALLBACK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPUBLISHABLEPROJECTSTATUSCALLBACK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsPublishableProjectStatusCallbackNotImpl :
	public IVsPublishableProjectStatusCallback
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPublishableProjectStatusCallbackNotImpl)

public:

	typedef IVsPublishableProjectStatusCallback Interface;

	STDMETHOD(PublishBegin)(
		/*[in,out]*/ BOOL* /*pfContinue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(PublishEnd)(
		/*[in]*/ BOOL /*fSuccess*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Tick)(
		/*[in,out]*/ BOOL* /*pfContinue*/)VSL_STDMETHOD_NOTIMPL
};

class IVsPublishableProjectStatusCallbackMockImpl :
	public IVsPublishableProjectStatusCallback,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPublishableProjectStatusCallbackMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsPublishableProjectStatusCallbackMockImpl)

	typedef IVsPublishableProjectStatusCallback Interface;
	struct PublishBeginValidValues
	{
		/*[in,out]*/ BOOL* pfContinue;
		HRESULT retValue;
	};

	STDMETHOD(PublishBegin)(
		/*[in,out]*/ BOOL* pfContinue)
	{
		VSL_DEFINE_MOCK_METHOD(PublishBegin)

		VSL_SET_VALIDVALUE(pfContinue);

		VSL_RETURN_VALIDVALUES();
	}
	struct PublishEndValidValues
	{
		/*[in]*/ BOOL fSuccess;
		HRESULT retValue;
	};

	STDMETHOD(PublishEnd)(
		/*[in]*/ BOOL fSuccess)
	{
		VSL_DEFINE_MOCK_METHOD(PublishEnd)

		VSL_CHECK_VALIDVALUE(fSuccess);

		VSL_RETURN_VALIDVALUES();
	}
	struct TickValidValues
	{
		/*[in,out]*/ BOOL* pfContinue;
		HRESULT retValue;
	};

	STDMETHOD(Tick)(
		/*[in,out]*/ BOOL* pfContinue)
	{
		VSL_DEFINE_MOCK_METHOD(Tick)

		VSL_SET_VALIDVALUE(pfContinue);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPUBLISHABLEPROJECTSTATUSCALLBACK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsPublishableProjectCfg.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSPUBLISHABLEPROJECTCFG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSPUBLISHABLEPROJECTCFG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsPublishableProjectCfgNotImpl :
	public IVsPublishableProjectCfg
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPublishableProjectCfgNotImpl)

public:

	typedef IVsPublishableProjectCfg Interface;

	STDMETHOD(AdvisePublishStatusCallback)(
		/*[in]*/ IVsPublishableProjectStatusCallback* /*pIVsPublishStatusCallback*/,
		/*[out]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadvisePublishStatusCallback)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(StartPublish)(
		/*[in]*/ IVsOutputWindowPane* /*pIVsOutputWindowPane*/,
		/*[in]*/ DWORD /*dwOptions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryStatusPublish)(
		/*[out]*/ BOOL* /*pfPublishDone*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(StopPublish)(
		/*[in]*/ BOOL /*fSync*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ShowPublishPrompt)(
		/*[out]*/ BOOL* /*pfContinue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryStartPublish)(
		/*[in]*/ DWORD /*dwOptions*/,
		/*[out,optional]*/ BOOL* /*pfSupported*/,
		/*[out,optional]*/ BOOL* /*pfReady*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPublishProperty)(
		/*[in]*/ VSPUBLISHOPTS /*propid*/,
		/*[out]*/ VARIANT* /*pvar*/)VSL_STDMETHOD_NOTIMPL
};

class IVsPublishableProjectCfgMockImpl :
	public IVsPublishableProjectCfg,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsPublishableProjectCfgMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsPublishableProjectCfgMockImpl)

	typedef IVsPublishableProjectCfg Interface;
	struct AdvisePublishStatusCallbackValidValues
	{
		/*[in]*/ IVsPublishableProjectStatusCallback* pIVsPublishStatusCallback;
		/*[out]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(AdvisePublishStatusCallback)(
		/*[in]*/ IVsPublishableProjectStatusCallback* pIVsPublishStatusCallback,
		/*[out]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(AdvisePublishStatusCallback)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsPublishStatusCallback);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadvisePublishStatusCallbackValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnadvisePublishStatusCallback)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnadvisePublishStatusCallback)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct StartPublishValidValues
	{
		/*[in]*/ IVsOutputWindowPane* pIVsOutputWindowPane;
		/*[in]*/ DWORD dwOptions;
		HRESULT retValue;
	};

	STDMETHOD(StartPublish)(
		/*[in]*/ IVsOutputWindowPane* pIVsOutputWindowPane,
		/*[in]*/ DWORD dwOptions)
	{
		VSL_DEFINE_MOCK_METHOD(StartPublish)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsOutputWindowPane);

		VSL_CHECK_VALIDVALUE(dwOptions);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryStatusPublishValidValues
	{
		/*[out]*/ BOOL* pfPublishDone;
		HRESULT retValue;
	};

	STDMETHOD(QueryStatusPublish)(
		/*[out]*/ BOOL* pfPublishDone)
	{
		VSL_DEFINE_MOCK_METHOD(QueryStatusPublish)

		VSL_SET_VALIDVALUE(pfPublishDone);

		VSL_RETURN_VALIDVALUES();
	}
	struct StopPublishValidValues
	{
		/*[in]*/ BOOL fSync;
		HRESULT retValue;
	};

	STDMETHOD(StopPublish)(
		/*[in]*/ BOOL fSync)
	{
		VSL_DEFINE_MOCK_METHOD(StopPublish)

		VSL_CHECK_VALIDVALUE(fSync);

		VSL_RETURN_VALIDVALUES();
	}
	struct ShowPublishPromptValidValues
	{
		/*[out]*/ BOOL* pfContinue;
		HRESULT retValue;
	};

	STDMETHOD(ShowPublishPrompt)(
		/*[out]*/ BOOL* pfContinue)
	{
		VSL_DEFINE_MOCK_METHOD(ShowPublishPrompt)

		VSL_SET_VALIDVALUE(pfContinue);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryStartPublishValidValues
	{
		/*[in]*/ DWORD dwOptions;
		/*[out,optional]*/ BOOL* pfSupported;
		/*[out,optional]*/ BOOL* pfReady;
		HRESULT retValue;
	};

	STDMETHOD(QueryStartPublish)(
		/*[in]*/ DWORD dwOptions,
		/*[out,optional]*/ BOOL* pfSupported,
		/*[out,optional]*/ BOOL* pfReady)
	{
		VSL_DEFINE_MOCK_METHOD(QueryStartPublish)

		VSL_CHECK_VALIDVALUE(dwOptions);

		VSL_SET_VALIDVALUE(pfSupported);

		VSL_SET_VALIDVALUE(pfReady);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPublishPropertyValidValues
	{
		/*[in]*/ VSPUBLISHOPTS propid;
		/*[out]*/ VARIANT* pvar;
		HRESULT retValue;
	};

	STDMETHOD(GetPublishProperty)(
		/*[in]*/ VSPUBLISHOPTS propid,
		/*[out]*/ VARIANT* pvar)
	{
		VSL_DEFINE_MOCK_METHOD(GetPublishProperty)

		VSL_CHECK_VALIDVALUE(propid);

		VSL_SET_VALIDVALUE_VARIANT(pvar);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSPUBLISHABLEPROJECTCFG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsQueryUndoManager.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSQUERYUNDOMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSQUERYUNDOMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsQueryUndoManagerNotImpl :
	public IVsQueryUndoManager
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsQueryUndoManagerNotImpl)

public:

	typedef IVsQueryUndoManager Interface;

	STDMETHOD(IsLinkedTransactionOpen)(
		/*[out]*/ BOOL* /*pbTransactionIsOpen*/)VSL_STDMETHOD_NOTIMPL
};

class IVsQueryUndoManagerMockImpl :
	public IVsQueryUndoManager,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsQueryUndoManagerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsQueryUndoManagerMockImpl)

	typedef IVsQueryUndoManager Interface;
	struct IsLinkedTransactionOpenValidValues
	{
		/*[out]*/ BOOL* pbTransactionIsOpen;
		HRESULT retValue;
	};

	STDMETHOD(IsLinkedTransactionOpen)(
		/*[out]*/ BOOL* pbTransactionIsOpen)
	{
		VSL_DEFINE_MOCK_METHOD(IsLinkedTransactionOpen)

		VSL_SET_VALIDVALUE(pbTransactionIsOpen);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSQUERYUNDOMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsQueryEditQuerySave2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSQUERYEDITQUERYSAVE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSQUERYEDITQUERYSAVE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "IVsQueryEditQuerySave2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsQueryEditQuerySave2NotImpl :
	public IVsQueryEditQuerySave2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsQueryEditQuerySave2NotImpl)

public:

	typedef IVsQueryEditQuerySave2 Interface;

	STDMETHOD(QueryEditFiles)(
		/*[in]*/ VSQueryEditFlags /*rgfQueryEdit*/,
		/*[in]*/ int /*cFiles*/,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR[] /*rgpszMkDocuments*/,
		/*[in,size_is(cFiles)]*/ const VSQEQSFlags[] /*rgrgf*/,
		/*[in,size_is(cFiles)]*/ const VSQEQS_FILE_ATTRIBUTE_DATA[] /*rgFileInfo*/,
		/*[out]*/ VSQueryEditResult* /*pfEditVerdict*/,
		/*[out]*/ VSQueryEditResultFlags* /*prgfMoreInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QuerySaveFiles)(
		/*[in]*/ VSQuerySaveFlags /*rgfQuerySave*/,
		/*[in]*/ int /*cFiles*/,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR[] /*rgpszMkDocuments*/,
		/*[in,size_is(cFiles)]*/ const VSQEQSFlags[] /*rgrgf*/,
		/*[in,size_is(cFiles)]*/ const VSQEQS_FILE_ATTRIBUTE_DATA[] /*rgFileInfo*/,
		/*[out,retval]*/ VSQuerySaveResult* /*pdwQSResult*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QuerySaveFile)(
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[in]*/ VSQEQSFlags /*rgf*/,
		/*[in]*/ const VSQEQS_FILE_ATTRIBUTE_DATA* /*pFileInfo*/,
		/*[out,retval]*/ VSQuerySaveResult* /*pdwQSResult*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DeclareReloadableFile)(
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[in]*/ VSQEQSFlags /*rgf*/,
		/*[in]*/ const VSQEQS_FILE_ATTRIBUTE_DATA* /*pFileInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DeclareUnreloadableFile)(
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[in]*/ VSQEQSFlags /*rgf*/,
		/*[in]*/ const VSQEQS_FILE_ATTRIBUTE_DATA* /*pFileInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterSaveUnreloadableFile)(
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[in]*/ VSQEQSFlags /*rgf*/,
		/*[in]*/ const VSQEQS_FILE_ATTRIBUTE_DATA* /*pFileInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsReloadable)(
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[out,retval]*/ BOOL* /*pbResult*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(BeginQuerySaveBatch)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EndQuerySaveBatch)()VSL_STDMETHOD_NOTIMPL
};

class IVsQueryEditQuerySave2MockImpl :
	public IVsQueryEditQuerySave2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsQueryEditQuerySave2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsQueryEditQuerySave2MockImpl)

	typedef IVsQueryEditQuerySave2 Interface;
	struct QueryEditFilesValidValues
	{
		/*[in]*/ VSQueryEditFlags rgfQueryEdit;
		/*[in]*/ int cFiles;
		/*[in,size_is(cFiles)]*/ LPCOLESTR* rgpszMkDocuments;
		/*[in,size_is(cFiles)]*/ VSQEQSFlags* rgrgf;
		/*[in,size_is(cFiles)]*/ VSQEQS_FILE_ATTRIBUTE_DATA* rgFileInfo;
		/*[out]*/ VSQueryEditResult* pfEditVerdict;
		/*[out]*/ VSQueryEditResultFlags* prgfMoreInfo;
		HRESULT retValue;
	};

	STDMETHOD(QueryEditFiles)(
		/*[in]*/ VSQueryEditFlags rgfQueryEdit,
		/*[in]*/ int cFiles,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR rgpszMkDocuments[],
		/*[in,size_is(cFiles)]*/ const VSQEQSFlags rgrgf[],
		/*[in,size_is(cFiles)]*/ const VSQEQS_FILE_ATTRIBUTE_DATA rgFileInfo[],
		/*[out]*/ VSQueryEditResult* pfEditVerdict,
		/*[out]*/ VSQueryEditResultFlags* prgfMoreInfo)
	{
		VSL_DEFINE_MOCK_METHOD(QueryEditFiles)

		VSL_CHECK_VALIDVALUE(rgfQueryEdit);

		VSL_CHECK_VALIDVALUE(cFiles);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszMkDocuments, cFiles*sizeof(rgpszMkDocuments[0]), validValues.cFiles*sizeof(validValues.rgpszMkDocuments[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgrgf, cFiles*sizeof(rgrgf[0]), validValues.cFiles*sizeof(validValues.rgrgf[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgFileInfo, cFiles*sizeof(rgFileInfo[0]), validValues.cFiles*sizeof(validValues.rgFileInfo[0]));

		VSL_SET_VALIDVALUE(pfEditVerdict);

		VSL_SET_VALIDVALUE(prgfMoreInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct QuerySaveFilesValidValues
	{
		/*[in]*/ VSQuerySaveFlags rgfQuerySave;
		/*[in]*/ int cFiles;
		/*[in,size_is(cFiles)]*/ LPCOLESTR* rgpszMkDocuments;
		/*[in,size_is(cFiles)]*/ VSQEQSFlags* rgrgf;
		/*[in,size_is(cFiles)]*/ VSQEQS_FILE_ATTRIBUTE_DATA* rgFileInfo;
		/*[out,retval]*/ VSQuerySaveResult* pdwQSResult;
		HRESULT retValue;
	};

	STDMETHOD(QuerySaveFiles)(
		/*[in]*/ VSQuerySaveFlags rgfQuerySave,
		/*[in]*/ int cFiles,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR rgpszMkDocuments[],
		/*[in,size_is(cFiles)]*/ const VSQEQSFlags rgrgf[],
		/*[in,size_is(cFiles)]*/ const VSQEQS_FILE_ATTRIBUTE_DATA rgFileInfo[],
		/*[out,retval]*/ VSQuerySaveResult* pdwQSResult)
	{
		VSL_DEFINE_MOCK_METHOD(QuerySaveFiles)

		VSL_CHECK_VALIDVALUE(rgfQuerySave);

		VSL_CHECK_VALIDVALUE(cFiles);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszMkDocuments, cFiles*sizeof(rgpszMkDocuments[0]), validValues.cFiles*sizeof(validValues.rgpszMkDocuments[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgrgf, cFiles*sizeof(rgrgf[0]), validValues.cFiles*sizeof(validValues.rgrgf[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgFileInfo, cFiles*sizeof(rgFileInfo[0]), validValues.cFiles*sizeof(validValues.rgFileInfo[0]));

		VSL_SET_VALIDVALUE(pdwQSResult);

		VSL_RETURN_VALIDVALUES();
	}
	struct QuerySaveFileValidValues
	{
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[in]*/ VSQEQSFlags rgf;
		/*[in]*/ VSQEQS_FILE_ATTRIBUTE_DATA* pFileInfo;
		/*[out,retval]*/ VSQuerySaveResult* pdwQSResult;
		HRESULT retValue;
	};

	STDMETHOD(QuerySaveFile)(
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[in]*/ VSQEQSFlags rgf,
		/*[in]*/ const VSQEQS_FILE_ATTRIBUTE_DATA* pFileInfo,
		/*[out,retval]*/ VSQuerySaveResult* pdwQSResult)
	{
		VSL_DEFINE_MOCK_METHOD(QuerySaveFile)

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_CHECK_VALIDVALUE(rgf);

		VSL_CHECK_VALIDVALUE_POINTER(pFileInfo);

		VSL_SET_VALIDVALUE(pdwQSResult);

		VSL_RETURN_VALIDVALUES();
	}
	struct DeclareReloadableFileValidValues
	{
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[in]*/ VSQEQSFlags rgf;
		/*[in]*/ VSQEQS_FILE_ATTRIBUTE_DATA* pFileInfo;
		HRESULT retValue;
	};

	STDMETHOD(DeclareReloadableFile)(
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[in]*/ VSQEQSFlags rgf,
		/*[in]*/ const VSQEQS_FILE_ATTRIBUTE_DATA* pFileInfo)
	{
		VSL_DEFINE_MOCK_METHOD(DeclareReloadableFile)

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_CHECK_VALIDVALUE(rgf);

		VSL_CHECK_VALIDVALUE_POINTER(pFileInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct DeclareUnreloadableFileValidValues
	{
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[in]*/ VSQEQSFlags rgf;
		/*[in]*/ VSQEQS_FILE_ATTRIBUTE_DATA* pFileInfo;
		HRESULT retValue;
	};

	STDMETHOD(DeclareUnreloadableFile)(
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[in]*/ VSQEQSFlags rgf,
		/*[in]*/ const VSQEQS_FILE_ATTRIBUTE_DATA* pFileInfo)
	{
		VSL_DEFINE_MOCK_METHOD(DeclareUnreloadableFile)

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_CHECK_VALIDVALUE(rgf);

		VSL_CHECK_VALIDVALUE_POINTER(pFileInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterSaveUnreloadableFileValidValues
	{
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[in]*/ VSQEQSFlags rgf;
		/*[in]*/ VSQEQS_FILE_ATTRIBUTE_DATA* pFileInfo;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterSaveUnreloadableFile)(
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[in]*/ VSQEQSFlags rgf,
		/*[in]*/ const VSQEQS_FILE_ATTRIBUTE_DATA* pFileInfo)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterSaveUnreloadableFile)

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_CHECK_VALIDVALUE(rgf);

		VSL_CHECK_VALIDVALUE_POINTER(pFileInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsReloadableValidValues
	{
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[out,retval]*/ BOOL* pbResult;
		HRESULT retValue;
	};

	STDMETHOD(IsReloadable)(
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[out,retval]*/ BOOL* pbResult)
	{
		VSL_DEFINE_MOCK_METHOD(IsReloadable)

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_SET_VALIDVALUE(pbResult);

		VSL_RETURN_VALIDVALUES();
	}
	struct BeginQuerySaveBatchValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(BeginQuerySaveBatch)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(BeginQuerySaveBatch)

		VSL_RETURN_VALIDVALUES();
	}
	struct EndQuerySaveBatchValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(EndQuerySaveBatch)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(EndQuerySaveBatch)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSQUERYEDITQUERYSAVE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsQueryLineChangeCommit.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSQUERYLINECHANGECOMMIT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSQUERYLINECHANGECOMMIT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsQueryLineChangeCommitNotImpl :
	public IVsQueryLineChangeCommit
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsQueryLineChangeCommitNotImpl)

public:

	typedef IVsQueryLineChangeCommit Interface;

	STDMETHOD(QuerySendEnterLineCommit)(
		/*[in]*/ DWORD /*dwReserved*/,
		/*[in]*/ long /*iLineStart*/,
		/*[in]*/ long /*iLineEnd*/,
		/*[out,retval]*/ QuerySendCommitFlags* /*dwQuerySendCommitFlags*/)VSL_STDMETHOD_NOTIMPL
};

class IVsQueryLineChangeCommitMockImpl :
	public IVsQueryLineChangeCommit,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsQueryLineChangeCommitMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsQueryLineChangeCommitMockImpl)

	typedef IVsQueryLineChangeCommit Interface;
	struct QuerySendEnterLineCommitValidValues
	{
		/*[in]*/ DWORD dwReserved;
		/*[in]*/ long iLineStart;
		/*[in]*/ long iLineEnd;
		/*[out,retval]*/ QuerySendCommitFlags* dwQuerySendCommitFlags;
		HRESULT retValue;
	};

	STDMETHOD(QuerySendEnterLineCommit)(
		/*[in]*/ DWORD dwReserved,
		/*[in]*/ long iLineStart,
		/*[in]*/ long iLineEnd,
		/*[out,retval]*/ QuerySendCommitFlags* dwQuerySendCommitFlags)
	{
		VSL_DEFINE_MOCK_METHOD(QuerySendEnterLineCommit)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_CHECK_VALIDVALUE(iLineStart);

		VSL_CHECK_VALIDVALUE(iLineEnd);

		VSL_SET_VALIDVALUE(dwQuerySendCommitFlags);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSQUERYLINECHANGECOMMIT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsQueryUndoUnit.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSQUERYUNDOUNIT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSQUERYUNDOUNIT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsQueryUndoUnitNotImpl :
	public IVsQueryUndoUnit
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsQueryUndoUnitNotImpl)

public:

	typedef IVsQueryUndoUnit Interface;

	STDMETHOD(ActionWouldBeAborted)(
		/*[out]*/ BOOL* /*pbWouldBeAborted*/)VSL_STDMETHOD_NOTIMPL
};

class IVsQueryUndoUnitMockImpl :
	public IVsQueryUndoUnit,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsQueryUndoUnitMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsQueryUndoUnitMockImpl)

	typedef IVsQueryUndoUnit Interface;
	struct ActionWouldBeAbortedValidValues
	{
		/*[out]*/ BOOL* pbWouldBeAborted;
		HRESULT retValue;
	};

	STDMETHOD(ActionWouldBeAborted)(
		/*[out]*/ BOOL* pbWouldBeAborted)
	{
		VSL_DEFINE_MOCK_METHOD(ActionWouldBeAborted)

		VSL_SET_VALIDVALUE(pbWouldBeAborted);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSQUERYUNDOUNIT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsRefactorNotify.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSREFACTORNOTIFY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSREFACTORNOTIFY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsRefactorNotifyNotImpl :
	public IVsRefactorNotify
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsRefactorNotifyNotImpl)

public:

	typedef IVsRefactorNotify Interface;

	STDMETHOD(OnBeforeGlobalSymbolRenamed)(
		/*[in]*/ IVsHierarchy* /*pHier*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ ULONG /*cRQNames*/,
		/*[in,size_is(cRQNames)]*/ LPCOLESTR[] /*rglpszRQName*/,
		/*[in]*/ LPCOLESTR /*lpszNewName*/,
		/*[out,retval]*/ SAFEARRAY** /*prgAdditionalCheckoutVSITEMIDs*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnGlobalSymbolRenamed)(
		/*[in]*/ IVsHierarchy* /*pHier*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ ULONG /*cRQNames*/,
		/*[in,size_is(cRQNames)]*/ LPCOLESTR[] /*rglpszRQName*/,
		/*[in]*/ LPCOLESTR /*lpszNewName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnBeforeReorderParams)(
		/*[in]*/ IVsHierarchy* /*pHier*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ LPCOLESTR /*lpszRQName*/,
		/*[in]*/ ULONG /*cParamIndexes*/,
		/*[in,size_is(cParamIndexes)]*/ ULONG[] /*rgParamIndexes*/,
		/*[out,retval]*/ SAFEARRAY** /*prgAdditionalCheckoutVSITEMIDs*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnReorderParams)(
		/*[in]*/ IVsHierarchy* /*pHier*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ LPCOLESTR /*lpszRQName*/,
		/*[in]*/ ULONG /*cParamIndexes*/,
		/*[in,size_is(cParamIndexes)]*/ ULONG[] /*rgParamIndexes*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnBeforeRemoveParams)(
		/*[in]*/ IVsHierarchy* /*pHier*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ LPCOLESTR /*lpszRQName*/,
		/*[in]*/ ULONG /*cParamIndexes*/,
		/*[in,size_is(cParamIndexes)]*/ ULONG[] /*rgParamIndexes*/,
		/*[out,retval]*/ SAFEARRAY** /*prgAdditionalCheckoutVSITEMIDs*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnRemoveParams)(
		/*[in]*/ IVsHierarchy* /*pHier*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ LPCOLESTR /*lpszRQName*/,
		/*[in]*/ ULONG /*cParamIndexes*/,
		/*[in,size_is(cParamIndexes)]*/ ULONG[] /*rgParamIndexes*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnBeforeAddParams)(
		/*[in]*/ IVsHierarchy* /*pHier*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ LPCOLESTR /*lpszRQName*/,
		/*[in]*/ ULONG /*cParams*/,
		/*[in,size_is(cParams)]*/ ULONG[] /*rgszParamIndexes*/,
		/*[in,size_is(cParams)]*/ LPCOLESTR[] /*rgszRQTypeNames*/,
		/*[in,size_is(cParams)]*/ LPCOLESTR[] /*rgszParamNames*/,
		/*[out,retval]*/ SAFEARRAY** /*prgAdditionalCheckoutVSITEMIDs*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAddParams)(
		/*[in]*/ IVsHierarchy* /*pHier*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ LPCOLESTR /*lpszRQName*/,
		/*[in]*/ ULONG /*cParams*/,
		/*[in,size_is(cParams)]*/ ULONG[] /*rgszParamIndexes*/,
		/*[in,size_is(cParams)]*/ LPCOLESTR[] /*rgszRQTypeNames*/,
		/*[in,size_is(cParams)]*/ LPCOLESTR[] /*rgszParamNames*/)VSL_STDMETHOD_NOTIMPL
};

class IVsRefactorNotifyMockImpl :
	public IVsRefactorNotify,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsRefactorNotifyMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsRefactorNotifyMockImpl)

	typedef IVsRefactorNotify Interface;
	struct OnBeforeGlobalSymbolRenamedValidValues
	{
		/*[in]*/ IVsHierarchy* pHier;
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ ULONG cRQNames;
		/*[in,size_is(cRQNames)]*/ LPCOLESTR* rglpszRQName;
		/*[in]*/ LPCOLESTR lpszNewName;
		/*[out,retval]*/ SAFEARRAY** prgAdditionalCheckoutVSITEMIDs;
		HRESULT retValue;
	};

	STDMETHOD(OnBeforeGlobalSymbolRenamed)(
		/*[in]*/ IVsHierarchy* pHier,
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ ULONG cRQNames,
		/*[in,size_is(cRQNames)]*/ LPCOLESTR rglpszRQName[],
		/*[in]*/ LPCOLESTR lpszNewName,
		/*[out,retval]*/ SAFEARRAY** prgAdditionalCheckoutVSITEMIDs)
	{
		VSL_DEFINE_MOCK_METHOD(OnBeforeGlobalSymbolRenamed)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHier);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE(cRQNames);

		VSL_CHECK_VALIDVALUE_MEMCMP(rglpszRQName, cRQNames*sizeof(rglpszRQName[0]), validValues.cRQNames*sizeof(validValues.rglpszRQName[0]));

		VSL_CHECK_VALIDVALUE_STRINGW(lpszNewName);

		VSL_SET_VALIDVALUE_SAFEARRAY(prgAdditionalCheckoutVSITEMIDs);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnGlobalSymbolRenamedValidValues
	{
		/*[in]*/ IVsHierarchy* pHier;
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ ULONG cRQNames;
		/*[in,size_is(cRQNames)]*/ LPCOLESTR* rglpszRQName;
		/*[in]*/ LPCOLESTR lpszNewName;
		HRESULT retValue;
	};

	STDMETHOD(OnGlobalSymbolRenamed)(
		/*[in]*/ IVsHierarchy* pHier,
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ ULONG cRQNames,
		/*[in,size_is(cRQNames)]*/ LPCOLESTR rglpszRQName[],
		/*[in]*/ LPCOLESTR lpszNewName)
	{
		VSL_DEFINE_MOCK_METHOD(OnGlobalSymbolRenamed)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHier);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE(cRQNames);

		VSL_CHECK_VALIDVALUE_MEMCMP(rglpszRQName, cRQNames*sizeof(rglpszRQName[0]), validValues.cRQNames*sizeof(validValues.rglpszRQName[0]));

		VSL_CHECK_VALIDVALUE_STRINGW(lpszNewName);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnBeforeReorderParamsValidValues
	{
		/*[in]*/ IVsHierarchy* pHier;
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ LPCOLESTR lpszRQName;
		/*[in]*/ ULONG cParamIndexes;
		/*[in,size_is(cParamIndexes)]*/ ULONG* rgParamIndexes;
		/*[out,retval]*/ SAFEARRAY** prgAdditionalCheckoutVSITEMIDs;
		HRESULT retValue;
	};

	STDMETHOD(OnBeforeReorderParams)(
		/*[in]*/ IVsHierarchy* pHier,
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ LPCOLESTR lpszRQName,
		/*[in]*/ ULONG cParamIndexes,
		/*[in,size_is(cParamIndexes)]*/ ULONG rgParamIndexes[],
		/*[out,retval]*/ SAFEARRAY** prgAdditionalCheckoutVSITEMIDs)
	{
		VSL_DEFINE_MOCK_METHOD(OnBeforeReorderParams)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHier);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszRQName);

		VSL_CHECK_VALIDVALUE(cParamIndexes);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgParamIndexes, cParamIndexes*sizeof(rgParamIndexes[0]), validValues.cParamIndexes*sizeof(validValues.rgParamIndexes[0]));

		VSL_SET_VALIDVALUE_SAFEARRAY(prgAdditionalCheckoutVSITEMIDs);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnReorderParamsValidValues
	{
		/*[in]*/ IVsHierarchy* pHier;
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ LPCOLESTR lpszRQName;
		/*[in]*/ ULONG cParamIndexes;
		/*[in,size_is(cParamIndexes)]*/ ULONG* rgParamIndexes;
		HRESULT retValue;
	};

	STDMETHOD(OnReorderParams)(
		/*[in]*/ IVsHierarchy* pHier,
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ LPCOLESTR lpszRQName,
		/*[in]*/ ULONG cParamIndexes,
		/*[in,size_is(cParamIndexes)]*/ ULONG rgParamIndexes[])
	{
		VSL_DEFINE_MOCK_METHOD(OnReorderParams)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHier);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszRQName);

		VSL_CHECK_VALIDVALUE(cParamIndexes);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgParamIndexes, cParamIndexes*sizeof(rgParamIndexes[0]), validValues.cParamIndexes*sizeof(validValues.rgParamIndexes[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct OnBeforeRemoveParamsValidValues
	{
		/*[in]*/ IVsHierarchy* pHier;
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ LPCOLESTR lpszRQName;
		/*[in]*/ ULONG cParamIndexes;
		/*[in,size_is(cParamIndexes)]*/ ULONG* rgParamIndexes;
		/*[out,retval]*/ SAFEARRAY** prgAdditionalCheckoutVSITEMIDs;
		HRESULT retValue;
	};

	STDMETHOD(OnBeforeRemoveParams)(
		/*[in]*/ IVsHierarchy* pHier,
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ LPCOLESTR lpszRQName,
		/*[in]*/ ULONG cParamIndexes,
		/*[in,size_is(cParamIndexes)]*/ ULONG rgParamIndexes[],
		/*[out,retval]*/ SAFEARRAY** prgAdditionalCheckoutVSITEMIDs)
	{
		VSL_DEFINE_MOCK_METHOD(OnBeforeRemoveParams)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHier);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszRQName);

		VSL_CHECK_VALIDVALUE(cParamIndexes);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgParamIndexes, cParamIndexes*sizeof(rgParamIndexes[0]), validValues.cParamIndexes*sizeof(validValues.rgParamIndexes[0]));

		VSL_SET_VALIDVALUE_SAFEARRAY(prgAdditionalCheckoutVSITEMIDs);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnRemoveParamsValidValues
	{
		/*[in]*/ IVsHierarchy* pHier;
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ LPCOLESTR lpszRQName;
		/*[in]*/ ULONG cParamIndexes;
		/*[in,size_is(cParamIndexes)]*/ ULONG* rgParamIndexes;
		HRESULT retValue;
	};

	STDMETHOD(OnRemoveParams)(
		/*[in]*/ IVsHierarchy* pHier,
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ LPCOLESTR lpszRQName,
		/*[in]*/ ULONG cParamIndexes,
		/*[in,size_is(cParamIndexes)]*/ ULONG rgParamIndexes[])
	{
		VSL_DEFINE_MOCK_METHOD(OnRemoveParams)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHier);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszRQName);

		VSL_CHECK_VALIDVALUE(cParamIndexes);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgParamIndexes, cParamIndexes*sizeof(rgParamIndexes[0]), validValues.cParamIndexes*sizeof(validValues.rgParamIndexes[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct OnBeforeAddParamsValidValues
	{
		/*[in]*/ IVsHierarchy* pHier;
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ LPCOLESTR lpszRQName;
		/*[in]*/ ULONG cParams;
		/*[in,size_is(cParams)]*/ ULONG* rgszParamIndexes;
		/*[in,size_is(cParams)]*/ LPCOLESTR* rgszRQTypeNames;
		/*[in,size_is(cParams)]*/ LPCOLESTR* rgszParamNames;
		/*[out,retval]*/ SAFEARRAY** prgAdditionalCheckoutVSITEMIDs;
		HRESULT retValue;
	};

	STDMETHOD(OnBeforeAddParams)(
		/*[in]*/ IVsHierarchy* pHier,
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ LPCOLESTR lpszRQName,
		/*[in]*/ ULONG cParams,
		/*[in,size_is(cParams)]*/ ULONG rgszParamIndexes[],
		/*[in,size_is(cParams)]*/ LPCOLESTR rgszRQTypeNames[],
		/*[in,size_is(cParams)]*/ LPCOLESTR rgszParamNames[],
		/*[out,retval]*/ SAFEARRAY** prgAdditionalCheckoutVSITEMIDs)
	{
		VSL_DEFINE_MOCK_METHOD(OnBeforeAddParams)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHier);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszRQName);

		VSL_CHECK_VALIDVALUE(cParams);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszParamIndexes, cParams*sizeof(rgszParamIndexes[0]), validValues.cParams*sizeof(validValues.rgszParamIndexes[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszRQTypeNames, cParams*sizeof(rgszRQTypeNames[0]), validValues.cParams*sizeof(validValues.rgszRQTypeNames[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszParamNames, cParams*sizeof(rgszParamNames[0]), validValues.cParams*sizeof(validValues.rgszParamNames[0]));

		VSL_SET_VALIDVALUE_SAFEARRAY(prgAdditionalCheckoutVSITEMIDs);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAddParamsValidValues
	{
		/*[in]*/ IVsHierarchy* pHier;
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ LPCOLESTR lpszRQName;
		/*[in]*/ ULONG cParams;
		/*[in,size_is(cParams)]*/ ULONG* rgszParamIndexes;
		/*[in,size_is(cParams)]*/ LPCOLESTR* rgszRQTypeNames;
		/*[in,size_is(cParams)]*/ LPCOLESTR* rgszParamNames;
		HRESULT retValue;
	};

	STDMETHOD(OnAddParams)(
		/*[in]*/ IVsHierarchy* pHier,
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ LPCOLESTR lpszRQName,
		/*[in]*/ ULONG cParams,
		/*[in,size_is(cParams)]*/ ULONG rgszParamIndexes[],
		/*[in,size_is(cParams)]*/ LPCOLESTR rgszRQTypeNames[],
		/*[in,size_is(cParams)]*/ LPCOLESTR rgszParamNames[])
	{
		VSL_DEFINE_MOCK_METHOD(OnAddParams)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHier);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszRQName);

		VSL_CHECK_VALIDVALUE(cParams);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszParamIndexes, cParams*sizeof(rgszParamIndexes[0]), validValues.cParams*sizeof(validValues.rgszParamIndexes[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszRQTypeNames, cParams*sizeof(rgszRQTypeNames[0]), validValues.cParams*sizeof(validValues.rgszRQTypeNames[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszParamNames, cParams*sizeof(rgszParamNames[0]), validValues.cParams*sizeof(validValues.rgszParamNames[0]));

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSREFACTORNOTIFY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsRegisterCustomFindScope.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSREGISTERCUSTOMFINDSCOPE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSREGISTERCUSTOMFINDSCOPE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "customfind.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsRegisterCustomFindScopeNotImpl :
	public IVsRegisterCustomFindScope
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsRegisterCustomFindScopeNotImpl)

public:

	typedef IVsRegisterCustomFindScope Interface;

	STDMETHOD(RegisterCustomFindScope)(
		/*[in]*/ REFGUID /*guidSID*/,
		/*[in]*/ LPCOLESTR /*pszName*/,
		/*[in]*/ VSFINDOPTIONS /*grfEnabledOptions*/,
		/*[out]*/ DWORD_PTR* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnRegisterCustomFindScope)(
		/*[in]*/ DWORD_PTR /*dwCookie*/)VSL_STDMETHOD_NOTIMPL
};

class IVsRegisterCustomFindScopeMockImpl :
	public IVsRegisterCustomFindScope,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsRegisterCustomFindScopeMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsRegisterCustomFindScopeMockImpl)

	typedef IVsRegisterCustomFindScope Interface;
	struct RegisterCustomFindScopeValidValues
	{
		/*[in]*/ REFGUID guidSID;
		/*[in]*/ LPCOLESTR pszName;
		/*[in]*/ VSFINDOPTIONS grfEnabledOptions;
		/*[out]*/ DWORD_PTR* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(RegisterCustomFindScope)(
		/*[in]*/ REFGUID guidSID,
		/*[in]*/ LPCOLESTR pszName,
		/*[in]*/ VSFINDOPTIONS grfEnabledOptions,
		/*[out]*/ DWORD_PTR* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(RegisterCustomFindScope)

		VSL_CHECK_VALIDVALUE(guidSID);

		VSL_CHECK_VALIDVALUE_STRINGW(pszName);

		VSL_CHECK_VALIDVALUE(grfEnabledOptions);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnRegisterCustomFindScopeValidValues
	{
		/*[in]*/ DWORD_PTR dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnRegisterCustomFindScope)(
		/*[in]*/ DWORD_PTR dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnRegisterCustomFindScope)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSREGISTERCUSTOMFINDSCOPE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsRegisterEditors.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSREGISTEREDITORS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSREGISTEREDITORS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsRegisterEditorsNotImpl :
	public IVsRegisterEditors
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsRegisterEditorsNotImpl)

public:

	typedef IVsRegisterEditors Interface;

	STDMETHOD(RegisterEditor)(
		/*[in]*/ REFGUID /*rguidEditor*/,
		/*[in]*/ IVsEditorFactory* /*pVsPF*/,
		/*[out]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnregisterEditor)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL
};

class IVsRegisterEditorsMockImpl :
	public IVsRegisterEditors,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsRegisterEditorsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsRegisterEditorsMockImpl)

	typedef IVsRegisterEditors Interface;
	struct RegisterEditorValidValues
	{
		/*[in]*/ REFGUID rguidEditor;
		/*[in]*/ IVsEditorFactory* pVsPF;
		/*[out]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(RegisterEditor)(
		/*[in]*/ REFGUID rguidEditor,
		/*[in]*/ IVsEditorFactory* pVsPF,
		/*[out]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(RegisterEditor)

		VSL_CHECK_VALIDVALUE(rguidEditor);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pVsPF);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnregisterEditorValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnregisterEditor)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnregisterEditor)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSREGISTEREDITORS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsRegisterFindScope.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSREGISTERFINDSCOPE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSREGISTERFINDSCOPE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textfind.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsRegisterFindScopeNotImpl :
	public IVsRegisterFindScope
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsRegisterFindScopeNotImpl)

public:

	typedef IVsRegisterFindScope Interface;

	STDMETHOD(RegisterFindScope)(
		/*[in]*/ IVsFindScope* /*pScope*/,
		/*[out]*/ DWORD_PTR* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnRegisterFindScope)(
		/*[in]*/ DWORD_PTR /*dwCookie*/)VSL_STDMETHOD_NOTIMPL
};

class IVsRegisterFindScopeMockImpl :
	public IVsRegisterFindScope,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsRegisterFindScopeMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsRegisterFindScopeMockImpl)

	typedef IVsRegisterFindScope Interface;
	struct RegisterFindScopeValidValues
	{
		/*[in]*/ IVsFindScope* pScope;
		/*[out]*/ DWORD_PTR* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(RegisterFindScope)(
		/*[in]*/ IVsFindScope* pScope,
		/*[out]*/ DWORD_PTR* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(RegisterFindScope)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pScope);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnRegisterFindScopeValidValues
	{
		/*[in]*/ DWORD_PTR dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnRegisterFindScope)(
		/*[in]*/ DWORD_PTR dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnRegisterFindScope)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSREGISTERFINDSCOPE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsRegisterNewDialogFilters.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSREGISTERNEWDIALOGFILTERS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSREGISTERNEWDIALOGFILTERS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsRegisterNewDialogFiltersNotImpl :
	public IVsRegisterNewDialogFilters
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsRegisterNewDialogFiltersNotImpl)

public:

	typedef IVsRegisterNewDialogFilters Interface;

	STDMETHOD(RegisterNewProjectDialogFilter)(
		/*[in]*/ IVsFilterNewProjectDlg* /*pFilter*/,
		/*[out]*/ VSCOOKIE* /*pdwFilterCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnregisterNewProjectDialogFilter)(
		/*[in]*/ VSCOOKIE /*dwFilterCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RegisterAddNewItemDialogFilter)(
		/*[in]*/ IVsFilterAddProjectItemDlg* /*pFilter*/,
		/*[out]*/ VSCOOKIE* /*pdwFilterCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnregisterAddNewItemDialogFilter)(
		/*[in]*/ VSCOOKIE /*dwFilterCookie*/)VSL_STDMETHOD_NOTIMPL
};

class IVsRegisterNewDialogFiltersMockImpl :
	public IVsRegisterNewDialogFilters,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsRegisterNewDialogFiltersMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsRegisterNewDialogFiltersMockImpl)

	typedef IVsRegisterNewDialogFilters Interface;
	struct RegisterNewProjectDialogFilterValidValues
	{
		/*[in]*/ IVsFilterNewProjectDlg* pFilter;
		/*[out]*/ VSCOOKIE* pdwFilterCookie;
		HRESULT retValue;
	};

	STDMETHOD(RegisterNewProjectDialogFilter)(
		/*[in]*/ IVsFilterNewProjectDlg* pFilter,
		/*[out]*/ VSCOOKIE* pdwFilterCookie)
	{
		VSL_DEFINE_MOCK_METHOD(RegisterNewProjectDialogFilter)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pFilter);

		VSL_SET_VALIDVALUE(pdwFilterCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnregisterNewProjectDialogFilterValidValues
	{
		/*[in]*/ VSCOOKIE dwFilterCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnregisterNewProjectDialogFilter)(
		/*[in]*/ VSCOOKIE dwFilterCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnregisterNewProjectDialogFilter)

		VSL_CHECK_VALIDVALUE(dwFilterCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct RegisterAddNewItemDialogFilterValidValues
	{
		/*[in]*/ IVsFilterAddProjectItemDlg* pFilter;
		/*[out]*/ VSCOOKIE* pdwFilterCookie;
		HRESULT retValue;
	};

	STDMETHOD(RegisterAddNewItemDialogFilter)(
		/*[in]*/ IVsFilterAddProjectItemDlg* pFilter,
		/*[out]*/ VSCOOKIE* pdwFilterCookie)
	{
		VSL_DEFINE_MOCK_METHOD(RegisterAddNewItemDialogFilter)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pFilter);

		VSL_SET_VALIDVALUE(pdwFilterCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnregisterAddNewItemDialogFilterValidValues
	{
		/*[in]*/ VSCOOKIE dwFilterCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnregisterAddNewItemDialogFilter)(
		/*[in]*/ VSCOOKIE dwFilterCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnregisterAddNewItemDialogFilter)

		VSL_CHECK_VALIDVALUE(dwFilterCookie);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSREGISTERNEWDIALOGFILTERS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsReadOnlyViewNotification.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSREADONLYVIEWNOTIFICATION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSREADONLYVIEWNOTIFICATION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsReadOnlyViewNotificationNotImpl :
	public IVsReadOnlyViewNotification
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsReadOnlyViewNotificationNotImpl)

public:

	typedef IVsReadOnlyViewNotification Interface;

	STDMETHOD(OnDisabledEditingCommand)(
		/*[unique,in]*/ const GUID* /*pguidCmdGuid*/,
		/*[in]*/ DWORD /*dwCmdId*/)VSL_STDMETHOD_NOTIMPL
};

class IVsReadOnlyViewNotificationMockImpl :
	public IVsReadOnlyViewNotification,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsReadOnlyViewNotificationMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsReadOnlyViewNotificationMockImpl)

	typedef IVsReadOnlyViewNotification Interface;
	struct OnDisabledEditingCommandValidValues
	{
		/*[unique,in]*/ GUID* pguidCmdGuid;
		/*[in]*/ DWORD dwCmdId;
		HRESULT retValue;
	};

	STDMETHOD(OnDisabledEditingCommand)(
		/*[unique,in]*/ const GUID* pguidCmdGuid,
		/*[in]*/ DWORD dwCmdId)
	{
		VSL_DEFINE_MOCK_METHOD(OnDisabledEditingCommand)

		VSL_CHECK_VALIDVALUE_POINTER(pguidCmdGuid);

		VSL_CHECK_VALIDVALUE(dwCmdId);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSREADONLYVIEWNOTIFICATION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsRegisterPriorityCommandTarget.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSREGISTERPRIORITYCOMMANDTARGET_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSREGISTERPRIORITYCOMMANDTARGET_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsRegisterPriorityCommandTargetNotImpl :
	public IVsRegisterPriorityCommandTarget
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsRegisterPriorityCommandTargetNotImpl)

public:

	typedef IVsRegisterPriorityCommandTarget Interface;

	STDMETHOD(RegisterPriorityCommandTarget)(
		/*[in]*/ DWORD /*dwReserved*/,
		/*[in]*/ IOleCommandTarget* /*pCmdTrgt*/,
		/*[out,retval]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnregisterPriorityCommandTarget)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL
};

class IVsRegisterPriorityCommandTargetMockImpl :
	public IVsRegisterPriorityCommandTarget,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsRegisterPriorityCommandTargetMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsRegisterPriorityCommandTargetMockImpl)

	typedef IVsRegisterPriorityCommandTarget Interface;
	struct RegisterPriorityCommandTargetValidValues
	{
		/*[in]*/ DWORD dwReserved;
		/*[in]*/ IOleCommandTarget* pCmdTrgt;
		/*[out,retval]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(RegisterPriorityCommandTarget)(
		/*[in]*/ DWORD dwReserved,
		/*[in]*/ IOleCommandTarget* pCmdTrgt,
		/*[out,retval]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(RegisterPriorityCommandTarget)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCmdTrgt);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnregisterPriorityCommandTargetValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnregisterPriorityCommandTarget)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnregisterPriorityCommandTarget)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSREGISTERPRIORITYCOMMANDTARGET_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsRegisterProjectDebugTargetProvider.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSREGISTERPROJECTDEBUGTARGETPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSREGISTERPROJECTDEBUGTARGETPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsRegisterProjectDebugTargetProviderNotImpl :
	public IVsRegisterProjectDebugTargetProvider
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsRegisterProjectDebugTargetProviderNotImpl)

public:

	typedef IVsRegisterProjectDebugTargetProvider Interface;

	STDMETHOD(AddDebugTargetProvider)(
		/*[in]*/ IVsProjectDebugTargetProvider* /*pNewDbgTrgtProvider*/,
		/*[out]*/ IVsProjectDebugTargetProvider** /*ppNextDbgTrgtProvider*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveDebugTargetProvider)(
		/*[in]*/ IVsProjectDebugTargetProvider* /*pDbgTrgtProvider*/)VSL_STDMETHOD_NOTIMPL
};

class IVsRegisterProjectDebugTargetProviderMockImpl :
	public IVsRegisterProjectDebugTargetProvider,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsRegisterProjectDebugTargetProviderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsRegisterProjectDebugTargetProviderMockImpl)

	typedef IVsRegisterProjectDebugTargetProvider Interface;
	struct AddDebugTargetProviderValidValues
	{
		/*[in]*/ IVsProjectDebugTargetProvider* pNewDbgTrgtProvider;
		/*[out]*/ IVsProjectDebugTargetProvider** ppNextDbgTrgtProvider;
		HRESULT retValue;
	};

	STDMETHOD(AddDebugTargetProvider)(
		/*[in]*/ IVsProjectDebugTargetProvider* pNewDbgTrgtProvider,
		/*[out]*/ IVsProjectDebugTargetProvider** ppNextDbgTrgtProvider)
	{
		VSL_DEFINE_MOCK_METHOD(AddDebugTargetProvider)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pNewDbgTrgtProvider);

		VSL_SET_VALIDVALUE_INTERFACE(ppNextDbgTrgtProvider);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveDebugTargetProviderValidValues
	{
		/*[in]*/ IVsProjectDebugTargetProvider* pDbgTrgtProvider;
		HRESULT retValue;
	};

	STDMETHOD(RemoveDebugTargetProvider)(
		/*[in]*/ IVsProjectDebugTargetProvider* pDbgTrgtProvider)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveDebugTargetProvider)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDbgTrgtProvider);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSREGISTERPROJECTDEBUGTARGETPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsRunningDocTableEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSRUNNINGDOCTABLEEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSRUNNINGDOCTABLEEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsRunningDocTableEventsNotImpl :
	public IVsRunningDocTableEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsRunningDocTableEventsNotImpl)

public:

	typedef IVsRunningDocTableEvents Interface;

	STDMETHOD(OnAfterFirstDocumentLock)(
		/*[in]*/ VSCOOKIE /*docCookie*/,
		/*[in]*/ VSRDTFLAGS /*dwRDTLockType*/,
		/*[in]*/ DWORD /*dwReadLocksRemaining*/,
		/*[in]*/ DWORD /*dwEditLocksRemaining*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnBeforeLastDocumentUnlock)(
		/*[in]*/ VSCOOKIE /*docCookie*/,
		/*[in]*/ VSRDTFLAGS /*dwRDTLockType*/,
		/*[in]*/ DWORD /*dwReadLocksRemaining*/,
		/*[in]*/ DWORD /*dwEditLocksRemaining*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterSave)(
		/*[in]*/ VSCOOKIE /*docCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterAttributeChange)(
		/*[in]*/ VSCOOKIE /*docCookie*/,
		/*[in]*/ VSRDTATTRIB /*grfAttribs*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnBeforeDocumentWindowShow)(
		/*[in]*/ VSCOOKIE /*docCookie*/,
		/*[in]*/ BOOL /*fFirstShow*/,
		/*[in]*/ IVsWindowFrame* /*pFrame*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterDocumentWindowHide)(
		/*[in]*/ VSCOOKIE /*docCookie*/,
		/*[in]*/ IVsWindowFrame* /*pFrame*/)VSL_STDMETHOD_NOTIMPL
};

class IVsRunningDocTableEventsMockImpl :
	public IVsRunningDocTableEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsRunningDocTableEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsRunningDocTableEventsMockImpl)

	typedef IVsRunningDocTableEvents Interface;
	struct OnAfterFirstDocumentLockValidValues
	{
		/*[in]*/ VSCOOKIE docCookie;
		/*[in]*/ VSRDTFLAGS dwRDTLockType;
		/*[in]*/ DWORD dwReadLocksRemaining;
		/*[in]*/ DWORD dwEditLocksRemaining;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterFirstDocumentLock)(
		/*[in]*/ VSCOOKIE docCookie,
		/*[in]*/ VSRDTFLAGS dwRDTLockType,
		/*[in]*/ DWORD dwReadLocksRemaining,
		/*[in]*/ DWORD dwEditLocksRemaining)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterFirstDocumentLock)

		VSL_CHECK_VALIDVALUE(docCookie);

		VSL_CHECK_VALIDVALUE(dwRDTLockType);

		VSL_CHECK_VALIDVALUE(dwReadLocksRemaining);

		VSL_CHECK_VALIDVALUE(dwEditLocksRemaining);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnBeforeLastDocumentUnlockValidValues
	{
		/*[in]*/ VSCOOKIE docCookie;
		/*[in]*/ VSRDTFLAGS dwRDTLockType;
		/*[in]*/ DWORD dwReadLocksRemaining;
		/*[in]*/ DWORD dwEditLocksRemaining;
		HRESULT retValue;
	};

	STDMETHOD(OnBeforeLastDocumentUnlock)(
		/*[in]*/ VSCOOKIE docCookie,
		/*[in]*/ VSRDTFLAGS dwRDTLockType,
		/*[in]*/ DWORD dwReadLocksRemaining,
		/*[in]*/ DWORD dwEditLocksRemaining)
	{
		VSL_DEFINE_MOCK_METHOD(OnBeforeLastDocumentUnlock)

		VSL_CHECK_VALIDVALUE(docCookie);

		VSL_CHECK_VALIDVALUE(dwRDTLockType);

		VSL_CHECK_VALIDVALUE(dwReadLocksRemaining);

		VSL_CHECK_VALIDVALUE(dwEditLocksRemaining);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterSaveValidValues
	{
		/*[in]*/ VSCOOKIE docCookie;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterSave)(
		/*[in]*/ VSCOOKIE docCookie)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterSave)

		VSL_CHECK_VALIDVALUE(docCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterAttributeChangeValidValues
	{
		/*[in]*/ VSCOOKIE docCookie;
		/*[in]*/ VSRDTATTRIB grfAttribs;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterAttributeChange)(
		/*[in]*/ VSCOOKIE docCookie,
		/*[in]*/ VSRDTATTRIB grfAttribs)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterAttributeChange)

		VSL_CHECK_VALIDVALUE(docCookie);

		VSL_CHECK_VALIDVALUE(grfAttribs);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnBeforeDocumentWindowShowValidValues
	{
		/*[in]*/ VSCOOKIE docCookie;
		/*[in]*/ BOOL fFirstShow;
		/*[in]*/ IVsWindowFrame* pFrame;
		HRESULT retValue;
	};

	STDMETHOD(OnBeforeDocumentWindowShow)(
		/*[in]*/ VSCOOKIE docCookie,
		/*[in]*/ BOOL fFirstShow,
		/*[in]*/ IVsWindowFrame* pFrame)
	{
		VSL_DEFINE_MOCK_METHOD(OnBeforeDocumentWindowShow)

		VSL_CHECK_VALIDVALUE(docCookie);

		VSL_CHECK_VALIDVALUE(fFirstShow);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pFrame);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterDocumentWindowHideValidValues
	{
		/*[in]*/ VSCOOKIE docCookie;
		/*[in]*/ IVsWindowFrame* pFrame;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterDocumentWindowHide)(
		/*[in]*/ VSCOOKIE docCookie,
		/*[in]*/ IVsWindowFrame* pFrame)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterDocumentWindowHide)

		VSL_CHECK_VALIDVALUE(docCookie);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pFrame);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSRUNNINGDOCTABLEEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsResourceManager.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSRESOURCEMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSRESOURCEMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsResourceManagerNotImpl :
	public IVsResourceManager
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsResourceManagerNotImpl)

public:

	typedef IVsResourceManager Interface;

	STDMETHOD(LoadResourceString)(
		/*[in]*/ REFGUID /*guidPackage*/,
		/*[in]*/ int /*culture*/,
		/*[in,string]*/ LPCOLESTR /*pszResourceName*/,
		/*[out,retval]*/ BSTR* /*pbstrValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LoadResourceBitmap)(
		/*[in]*/ REFGUID /*guidPackage*/,
		/*[in]*/ int /*culture*/,
		/*[in,string]*/ LPCOLESTR /*pszResourceName*/,
		/*[out,retval]*/ HBITMAP* /*hbmpValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LoadResourceIcon)(
		/*[in]*/ REFGUID /*guidPackage*/,
		/*[in]*/ int /*culture*/,
		/*[in,string]*/ LPCOLESTR /*pszResourceName*/,
		/*[in]*/ int /*cx*/,
		/*[in]*/ int /*cy*/,
		/*[out,retval]*/ HICON* /*hicoValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LoadResourceBlob)(
		/*[in]*/ REFGUID /*guidPackage*/,
		/*[in]*/ int /*culture*/,
		/*[in,string]*/ LPCOLESTR /*pszResourceName*/,
		/*[out]*/ BYTE** /*pBytes*/,
		/*[out]*/ long* /*lAllocated*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LoadResourceString2)(
		/*[in,string]*/ LPCOLESTR /*pszAssemblyPath*/,
		/*[in]*/ int /*culture*/,
		/*[in,string]*/ LPCOLESTR /*pszResourceName*/,
		/*[out,retval]*/ BSTR* /*pbstrValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LoadResourceBitmap2)(
		/*[in,string]*/ LPCOLESTR /*pszAssemblyPath*/,
		/*[in]*/ int /*culture*/,
		/*[in,string]*/ LPCOLESTR /*szResourceName*/,
		/*[out,retval]*/ HBITMAP* /*hbmpValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LoadResourceIcon2)(
		/*[in,string]*/ LPCOLESTR /*pszAssemblyPath*/,
		/*[in]*/ int /*culture*/,
		/*[in,string]*/ LPCOLESTR /*pszResourceName*/,
		/*[in]*/ int /*cx*/,
		/*[in]*/ int /*cy*/,
		/*[out,retval]*/ HICON* /*hicoValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LoadResourceBlob2)(
		/*[in,string]*/ LPCOLESTR /*pszAssemblyPath*/,
		/*[in]*/ int /*culture*/,
		/*[in,string]*/ LPCOLESTR /*pszResourceName*/,
		/*[out]*/ BYTE** /*pBytes*/,
		/*[out]*/ long* /*lAllocated*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSatelliteAssemblyPath)(
		/*[in,string]*/ LPCOLESTR /*assemblyPath*/,
		/*[in]*/ int /*lcid*/,
		/*[out,retval]*/ BSTR* /*pbstrPath*/)VSL_STDMETHOD_NOTIMPL
};

class IVsResourceManagerMockImpl :
	public IVsResourceManager,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsResourceManagerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsResourceManagerMockImpl)

	typedef IVsResourceManager Interface;
	struct LoadResourceStringValidValues
	{
		/*[in]*/ REFGUID guidPackage;
		/*[in]*/ int culture;
		/*[in,string]*/ LPCOLESTR pszResourceName;
		/*[out,retval]*/ BSTR* pbstrValue;
		HRESULT retValue;
	};

	STDMETHOD(LoadResourceString)(
		/*[in]*/ REFGUID guidPackage,
		/*[in]*/ int culture,
		/*[in,string]*/ LPCOLESTR pszResourceName,
		/*[out,retval]*/ BSTR* pbstrValue)
	{
		VSL_DEFINE_MOCK_METHOD(LoadResourceString)

		VSL_CHECK_VALIDVALUE(guidPackage);

		VSL_CHECK_VALIDVALUE(culture);

		VSL_CHECK_VALIDVALUE_STRINGW(pszResourceName);

		VSL_SET_VALIDVALUE_BSTR(pbstrValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadResourceBitmapValidValues
	{
		/*[in]*/ REFGUID guidPackage;
		/*[in]*/ int culture;
		/*[in,string]*/ LPCOLESTR pszResourceName;
		/*[out,retval]*/ HBITMAP* hbmpValue;
		HRESULT retValue;
	};

	STDMETHOD(LoadResourceBitmap)(
		/*[in]*/ REFGUID guidPackage,
		/*[in]*/ int culture,
		/*[in,string]*/ LPCOLESTR pszResourceName,
		/*[out,retval]*/ HBITMAP* hbmpValue)
	{
		VSL_DEFINE_MOCK_METHOD(LoadResourceBitmap)

		VSL_CHECK_VALIDVALUE(guidPackage);

		VSL_CHECK_VALIDVALUE(culture);

		VSL_CHECK_VALIDVALUE_STRINGW(pszResourceName);

		VSL_SET_VALIDVALUE(hbmpValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadResourceIconValidValues
	{
		/*[in]*/ REFGUID guidPackage;
		/*[in]*/ int culture;
		/*[in,string]*/ LPCOLESTR pszResourceName;
		/*[in]*/ int cx;
		/*[in]*/ int cy;
		/*[out,retval]*/ HICON* hicoValue;
		HRESULT retValue;
	};

	STDMETHOD(LoadResourceIcon)(
		/*[in]*/ REFGUID guidPackage,
		/*[in]*/ int culture,
		/*[in,string]*/ LPCOLESTR pszResourceName,
		/*[in]*/ int cx,
		/*[in]*/ int cy,
		/*[out,retval]*/ HICON* hicoValue)
	{
		VSL_DEFINE_MOCK_METHOD(LoadResourceIcon)

		VSL_CHECK_VALIDVALUE(guidPackage);

		VSL_CHECK_VALIDVALUE(culture);

		VSL_CHECK_VALIDVALUE_STRINGW(pszResourceName);

		VSL_CHECK_VALIDVALUE(cx);

		VSL_CHECK_VALIDVALUE(cy);

		VSL_SET_VALIDVALUE(hicoValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadResourceBlobValidValues
	{
		/*[in]*/ REFGUID guidPackage;
		/*[in]*/ int culture;
		/*[in,string]*/ LPCOLESTR pszResourceName;
		/*[out]*/ BYTE** pBytes;
		/*[out]*/ long* lAllocated;
		HRESULT retValue;
	};

	STDMETHOD(LoadResourceBlob)(
		/*[in]*/ REFGUID guidPackage,
		/*[in]*/ int culture,
		/*[in,string]*/ LPCOLESTR pszResourceName,
		/*[out]*/ BYTE** pBytes,
		/*[out]*/ long* lAllocated)
	{
		VSL_DEFINE_MOCK_METHOD(LoadResourceBlob)

		VSL_CHECK_VALIDVALUE(guidPackage);

		VSL_CHECK_VALIDVALUE(culture);

		VSL_CHECK_VALIDVALUE_STRINGW(pszResourceName);

		VSL_SET_VALIDVALUE(pBytes);

		VSL_SET_VALIDVALUE(lAllocated);

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadResourceString2ValidValues
	{
		/*[in,string]*/ LPCOLESTR pszAssemblyPath;
		/*[in]*/ int culture;
		/*[in,string]*/ LPCOLESTR pszResourceName;
		/*[out,retval]*/ BSTR* pbstrValue;
		HRESULT retValue;
	};

	STDMETHOD(LoadResourceString2)(
		/*[in,string]*/ LPCOLESTR pszAssemblyPath,
		/*[in]*/ int culture,
		/*[in,string]*/ LPCOLESTR pszResourceName,
		/*[out,retval]*/ BSTR* pbstrValue)
	{
		VSL_DEFINE_MOCK_METHOD(LoadResourceString2)

		VSL_CHECK_VALIDVALUE_STRINGW(pszAssemblyPath);

		VSL_CHECK_VALIDVALUE(culture);

		VSL_CHECK_VALIDVALUE_STRINGW(pszResourceName);

		VSL_SET_VALIDVALUE_BSTR(pbstrValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadResourceBitmap2ValidValues
	{
		/*[in,string]*/ LPCOLESTR pszAssemblyPath;
		/*[in]*/ int culture;
		/*[in,string]*/ LPCOLESTR szResourceName;
		/*[out,retval]*/ HBITMAP* hbmpValue;
		HRESULT retValue;
	};

	STDMETHOD(LoadResourceBitmap2)(
		/*[in,string]*/ LPCOLESTR pszAssemblyPath,
		/*[in]*/ int culture,
		/*[in,string]*/ LPCOLESTR szResourceName,
		/*[out,retval]*/ HBITMAP* hbmpValue)
	{
		VSL_DEFINE_MOCK_METHOD(LoadResourceBitmap2)

		VSL_CHECK_VALIDVALUE_STRINGW(pszAssemblyPath);

		VSL_CHECK_VALIDVALUE(culture);

		VSL_CHECK_VALIDVALUE_STRINGW(szResourceName);

		VSL_SET_VALIDVALUE(hbmpValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadResourceIcon2ValidValues
	{
		/*[in,string]*/ LPCOLESTR pszAssemblyPath;
		/*[in]*/ int culture;
		/*[in,string]*/ LPCOLESTR pszResourceName;
		/*[in]*/ int cx;
		/*[in]*/ int cy;
		/*[out,retval]*/ HICON* hicoValue;
		HRESULT retValue;
	};

	STDMETHOD(LoadResourceIcon2)(
		/*[in,string]*/ LPCOLESTR pszAssemblyPath,
		/*[in]*/ int culture,
		/*[in,string]*/ LPCOLESTR pszResourceName,
		/*[in]*/ int cx,
		/*[in]*/ int cy,
		/*[out,retval]*/ HICON* hicoValue)
	{
		VSL_DEFINE_MOCK_METHOD(LoadResourceIcon2)

		VSL_CHECK_VALIDVALUE_STRINGW(pszAssemblyPath);

		VSL_CHECK_VALIDVALUE(culture);

		VSL_CHECK_VALIDVALUE_STRINGW(pszResourceName);

		VSL_CHECK_VALIDVALUE(cx);

		VSL_CHECK_VALIDVALUE(cy);

		VSL_SET_VALIDVALUE(hicoValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadResourceBlob2ValidValues
	{
		/*[in,string]*/ LPCOLESTR pszAssemblyPath;
		/*[in]*/ int culture;
		/*[in,string]*/ LPCOLESTR pszResourceName;
		/*[out]*/ BYTE** pBytes;
		/*[out]*/ long* lAllocated;
		HRESULT retValue;
	};

	STDMETHOD(LoadResourceBlob2)(
		/*[in,string]*/ LPCOLESTR pszAssemblyPath,
		/*[in]*/ int culture,
		/*[in,string]*/ LPCOLESTR pszResourceName,
		/*[out]*/ BYTE** pBytes,
		/*[out]*/ long* lAllocated)
	{
		VSL_DEFINE_MOCK_METHOD(LoadResourceBlob2)

		VSL_CHECK_VALIDVALUE_STRINGW(pszAssemblyPath);

		VSL_CHECK_VALIDVALUE(culture);

		VSL_CHECK_VALIDVALUE_STRINGW(pszResourceName);

		VSL_SET_VALIDVALUE(pBytes);

		VSL_SET_VALIDVALUE(lAllocated);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSatelliteAssemblyPathValidValues
	{
		/*[in,string]*/ LPCOLESTR assemblyPath;
		/*[in]*/ int lcid;
		/*[out,retval]*/ BSTR* pbstrPath;
		HRESULT retValue;
	};

	STDMETHOD(GetSatelliteAssemblyPath)(
		/*[in,string]*/ LPCOLESTR assemblyPath,
		/*[in]*/ int lcid,
		/*[out,retval]*/ BSTR* pbstrPath)
	{
		VSL_DEFINE_MOCK_METHOD(GetSatelliteAssemblyPath)

		VSL_CHECK_VALIDVALUE_STRINGW(assemblyPath);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_BSTR(pbstrPath);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSRESOURCEMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsRegisterScciProvider.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSREGISTERSCCIPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSREGISTERSCCIPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "IVsRegisterScciProvider.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsRegisterScciProviderNotImpl :
	public IVsRegisterScciProvider
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsRegisterScciProviderNotImpl)

public:

	typedef IVsRegisterScciProvider Interface;

	STDMETHOD(RegisterSourceControlProvider)(
		/*[in]*/ GUID /*guidProvider*/)VSL_STDMETHOD_NOTIMPL
};

class IVsRegisterScciProviderMockImpl :
	public IVsRegisterScciProvider,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsRegisterScciProviderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsRegisterScciProviderMockImpl)

	typedef IVsRegisterScciProvider Interface;
	struct RegisterSourceControlProviderValidValues
	{
		/*[in]*/ GUID guidProvider;
		HRESULT retValue;
	};

	STDMETHOD(RegisterSourceControlProvider)(
		/*[in]*/ GUID guidProvider)
	{
		VSL_DEFINE_MOCK_METHOD(RegisterSourceControlProvider)

		VSL_CHECK_VALIDVALUE(guidProvider);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSREGISTERSCCIPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsRegisterProjectTypes.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSREGISTERPROJECTTYPES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSREGISTERPROJECTTYPES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsRegisterProjectTypesNotImpl :
	public IVsRegisterProjectTypes
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsRegisterProjectTypesNotImpl)

public:

	typedef IVsRegisterProjectTypes Interface;

	STDMETHOD(RegisterProjectType)(
		/*[in]*/ REFGUID /*rguidProjType*/,
		/*[in]*/ IVsProjectFactory* /*pVsPF*/,
		/*[out]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnregisterProjectType)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL
};

class IVsRegisterProjectTypesMockImpl :
	public IVsRegisterProjectTypes,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsRegisterProjectTypesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsRegisterProjectTypesMockImpl)

	typedef IVsRegisterProjectTypes Interface;
	struct RegisterProjectTypeValidValues
	{
		/*[in]*/ REFGUID rguidProjType;
		/*[in]*/ IVsProjectFactory* pVsPF;
		/*[out]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(RegisterProjectType)(
		/*[in]*/ REFGUID rguidProjType,
		/*[in]*/ IVsProjectFactory* pVsPF,
		/*[out]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(RegisterProjectType)

		VSL_CHECK_VALIDVALUE(rguidProjType);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pVsPF);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnregisterProjectTypeValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnregisterProjectType)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnregisterProjectType)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSREGISTERPROJECTTYPES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsRunningDocTableEvents2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSRUNNINGDOCTABLEEVENTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSRUNNINGDOCTABLEEVENTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsRunningDocTableEvents2NotImpl :
	public IVsRunningDocTableEvents2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsRunningDocTableEvents2NotImpl)

public:

	typedef IVsRunningDocTableEvents2 Interface;

	STDMETHOD(OnAfterAttributeChangeEx)(
		/*[in]*/ VSCOOKIE /*docCookie*/,
		/*[in]*/ VSRDTATTRIB /*grfAttribs*/,
		/*[in]*/ IVsHierarchy* /*pHierOld*/,
		/*[in]*/ VSITEMID /*itemidOld*/,
		/*[in]*/ LPCOLESTR /*pszMkDocumentOld*/,
		/*[in]*/ IVsHierarchy* /*pHierNew*/,
		/*[in]*/ VSITEMID /*itemidNew*/,
		/*[in]*/ LPCOLESTR /*pszMkDocumentNew*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterFirstDocumentLock)(
		/*[in]*/ VSCOOKIE /*docCookie*/,
		/*[in]*/ VSRDTFLAGS /*dwRDTLockType*/,
		/*[in]*/ DWORD /*dwReadLocksRemaining*/,
		/*[in]*/ DWORD /*dwEditLocksRemaining*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnBeforeLastDocumentUnlock)(
		/*[in]*/ VSCOOKIE /*docCookie*/,
		/*[in]*/ VSRDTFLAGS /*dwRDTLockType*/,
		/*[in]*/ DWORD /*dwReadLocksRemaining*/,
		/*[in]*/ DWORD /*dwEditLocksRemaining*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterSave)(
		/*[in]*/ VSCOOKIE /*docCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterAttributeChange)(
		/*[in]*/ VSCOOKIE /*docCookie*/,
		/*[in]*/ VSRDTATTRIB /*grfAttribs*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnBeforeDocumentWindowShow)(
		/*[in]*/ VSCOOKIE /*docCookie*/,
		/*[in]*/ BOOL /*fFirstShow*/,
		/*[in]*/ IVsWindowFrame* /*pFrame*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterDocumentWindowHide)(
		/*[in]*/ VSCOOKIE /*docCookie*/,
		/*[in]*/ IVsWindowFrame* /*pFrame*/)VSL_STDMETHOD_NOTIMPL
};

class IVsRunningDocTableEvents2MockImpl :
	public IVsRunningDocTableEvents2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsRunningDocTableEvents2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsRunningDocTableEvents2MockImpl)

	typedef IVsRunningDocTableEvents2 Interface;
	struct OnAfterAttributeChangeExValidValues
	{
		/*[in]*/ VSCOOKIE docCookie;
		/*[in]*/ VSRDTATTRIB grfAttribs;
		/*[in]*/ IVsHierarchy* pHierOld;
		/*[in]*/ VSITEMID itemidOld;
		/*[in]*/ LPCOLESTR pszMkDocumentOld;
		/*[in]*/ IVsHierarchy* pHierNew;
		/*[in]*/ VSITEMID itemidNew;
		/*[in]*/ LPCOLESTR pszMkDocumentNew;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterAttributeChangeEx)(
		/*[in]*/ VSCOOKIE docCookie,
		/*[in]*/ VSRDTATTRIB grfAttribs,
		/*[in]*/ IVsHierarchy* pHierOld,
		/*[in]*/ VSITEMID itemidOld,
		/*[in]*/ LPCOLESTR pszMkDocumentOld,
		/*[in]*/ IVsHierarchy* pHierNew,
		/*[in]*/ VSITEMID itemidNew,
		/*[in]*/ LPCOLESTR pszMkDocumentNew)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterAttributeChangeEx)

		VSL_CHECK_VALIDVALUE(docCookie);

		VSL_CHECK_VALIDVALUE(grfAttribs);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierOld);

		VSL_CHECK_VALIDVALUE(itemidOld);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocumentOld);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierNew);

		VSL_CHECK_VALIDVALUE(itemidNew);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocumentNew);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterFirstDocumentLockValidValues
	{
		/*[in]*/ VSCOOKIE docCookie;
		/*[in]*/ VSRDTFLAGS dwRDTLockType;
		/*[in]*/ DWORD dwReadLocksRemaining;
		/*[in]*/ DWORD dwEditLocksRemaining;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterFirstDocumentLock)(
		/*[in]*/ VSCOOKIE docCookie,
		/*[in]*/ VSRDTFLAGS dwRDTLockType,
		/*[in]*/ DWORD dwReadLocksRemaining,
		/*[in]*/ DWORD dwEditLocksRemaining)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterFirstDocumentLock)

		VSL_CHECK_VALIDVALUE(docCookie);

		VSL_CHECK_VALIDVALUE(dwRDTLockType);

		VSL_CHECK_VALIDVALUE(dwReadLocksRemaining);

		VSL_CHECK_VALIDVALUE(dwEditLocksRemaining);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnBeforeLastDocumentUnlockValidValues
	{
		/*[in]*/ VSCOOKIE docCookie;
		/*[in]*/ VSRDTFLAGS dwRDTLockType;
		/*[in]*/ DWORD dwReadLocksRemaining;
		/*[in]*/ DWORD dwEditLocksRemaining;
		HRESULT retValue;
	};

	STDMETHOD(OnBeforeLastDocumentUnlock)(
		/*[in]*/ VSCOOKIE docCookie,
		/*[in]*/ VSRDTFLAGS dwRDTLockType,
		/*[in]*/ DWORD dwReadLocksRemaining,
		/*[in]*/ DWORD dwEditLocksRemaining)
	{
		VSL_DEFINE_MOCK_METHOD(OnBeforeLastDocumentUnlock)

		VSL_CHECK_VALIDVALUE(docCookie);

		VSL_CHECK_VALIDVALUE(dwRDTLockType);

		VSL_CHECK_VALIDVALUE(dwReadLocksRemaining);

		VSL_CHECK_VALIDVALUE(dwEditLocksRemaining);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterSaveValidValues
	{
		/*[in]*/ VSCOOKIE docCookie;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterSave)(
		/*[in]*/ VSCOOKIE docCookie)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterSave)

		VSL_CHECK_VALIDVALUE(docCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterAttributeChangeValidValues
	{
		/*[in]*/ VSCOOKIE docCookie;
		/*[in]*/ VSRDTATTRIB grfAttribs;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterAttributeChange)(
		/*[in]*/ VSCOOKIE docCookie,
		/*[in]*/ VSRDTATTRIB grfAttribs)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterAttributeChange)

		VSL_CHECK_VALIDVALUE(docCookie);

		VSL_CHECK_VALIDVALUE(grfAttribs);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnBeforeDocumentWindowShowValidValues
	{
		/*[in]*/ VSCOOKIE docCookie;
		/*[in]*/ BOOL fFirstShow;
		/*[in]*/ IVsWindowFrame* pFrame;
		HRESULT retValue;
	};

	STDMETHOD(OnBeforeDocumentWindowShow)(
		/*[in]*/ VSCOOKIE docCookie,
		/*[in]*/ BOOL fFirstShow,
		/*[in]*/ IVsWindowFrame* pFrame)
	{
		VSL_DEFINE_MOCK_METHOD(OnBeforeDocumentWindowShow)

		VSL_CHECK_VALIDVALUE(docCookie);

		VSL_CHECK_VALIDVALUE(fFirstShow);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pFrame);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterDocumentWindowHideValidValues
	{
		/*[in]*/ VSCOOKIE docCookie;
		/*[in]*/ IVsWindowFrame* pFrame;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterDocumentWindowHide)(
		/*[in]*/ VSCOOKIE docCookie,
		/*[in]*/ IVsWindowFrame* pFrame)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterDocumentWindowHide)

		VSL_CHECK_VALIDVALUE(docCookie);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pFrame);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSRUNNINGDOCTABLEEVENTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsReportExternalErrors.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSREPORTEXTERNALERRORS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSREPORTEXTERNALERRORS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "singlefileeditor.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsReportExternalErrorsNotImpl :
	public IVsReportExternalErrors
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsReportExternalErrorsNotImpl)

public:

	typedef IVsReportExternalErrors Interface;

	STDMETHOD(ClearAllErrors)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddNewErrors)(
		/*[in]*/ IVsEnumExternalErrors* /*pErrors*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetErrors)(
		/*[out]*/ IVsEnumExternalErrors** /*pErrors*/)VSL_STDMETHOD_NOTIMPL
};

class IVsReportExternalErrorsMockImpl :
	public IVsReportExternalErrors,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsReportExternalErrorsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsReportExternalErrorsMockImpl)

	typedef IVsReportExternalErrors Interface;
	struct ClearAllErrorsValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ClearAllErrors)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ClearAllErrors)

		VSL_RETURN_VALIDVALUES();
	}
	struct AddNewErrorsValidValues
	{
		/*[in]*/ IVsEnumExternalErrors* pErrors;
		HRESULT retValue;
	};

	STDMETHOD(AddNewErrors)(
		/*[in]*/ IVsEnumExternalErrors* pErrors)
	{
		VSL_DEFINE_MOCK_METHOD(AddNewErrors)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pErrors);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetErrorsValidValues
	{
		/*[out]*/ IVsEnumExternalErrors** pErrors;
		HRESULT retValue;
	};

	STDMETHOD(GetErrors)(
		/*[out]*/ IVsEnumExternalErrors** pErrors)
	{
		VSL_DEFINE_MOCK_METHOD(GetErrors)

		VSL_SET_VALIDVALUE_INTERFACE(pErrors);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSREPORTEXTERNALERRORS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsRelativePathResolver.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSRELATIVEPATHRESOLVER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSRELATIVEPATHRESOLVER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsRelativePathResolverNotImpl :
	public IVsRelativePathResolver
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsRelativePathResolverNotImpl)

public:

	typedef IVsRelativePathResolver Interface;

	STDMETHOD(ResolveRelativePath)(
		/*[in]*/ DWORD /*dwReserved*/,
		/*[in]*/ LPCOLESTR /*pszRelPath*/,
		/*[out,retval]*/ BSTR* /*pbstrAbsPath*/)VSL_STDMETHOD_NOTIMPL
};

class IVsRelativePathResolverMockImpl :
	public IVsRelativePathResolver,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsRelativePathResolverMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsRelativePathResolverMockImpl)

	typedef IVsRelativePathResolver Interface;
	struct ResolveRelativePathValidValues
	{
		/*[in]*/ DWORD dwReserved;
		/*[in]*/ LPCOLESTR pszRelPath;
		/*[out,retval]*/ BSTR* pbstrAbsPath;
		HRESULT retValue;
	};

	STDMETHOD(ResolveRelativePath)(
		/*[in]*/ DWORD dwReserved,
		/*[in]*/ LPCOLESTR pszRelPath,
		/*[out,retval]*/ BSTR* pbstrAbsPath)
	{
		VSL_DEFINE_MOCK_METHOD(ResolveRelativePath)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_CHECK_VALIDVALUE_STRINGW(pszRelPath);

		VSL_SET_VALIDVALUE_BSTR(pbstrAbsPath);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSRELATIVEPATHRESOLVER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsRunningDocumentTable.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSRUNNINGDOCUMENTTABLE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSRUNNINGDOCUMENTTABLE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsRunningDocumentTableNotImpl :
	public IVsRunningDocumentTable
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsRunningDocumentTableNotImpl)

public:

	typedef IVsRunningDocumentTable Interface;

	STDMETHOD(RegisterAndLockDocument)(
		/*[in]*/ VSRDTFLAGS /*grfRDTLockType*/,
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[in]*/ IVsHierarchy* /*pHier*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ IUnknown* /*punkDocData*/,
		/*[out]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LockDocument)(
		/*[in]*/ VSRDTFLAGS /*grfRDTLockType*/,
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnlockDocument)(
		/*[in]*/ VSRDTFLAGS /*grfRDTLockType*/,
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FindAndLockDocument)(
		/*[in]*/ VSRDTFLAGS /*dwRDTLockType*/,
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[out]*/ IVsHierarchy** /*ppHier*/,
		/*[out]*/ VSITEMID* /*pitemid*/,
		/*[out]*/ IUnknown** /*ppunkDocData*/,
		/*[out]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RenameDocument)(
		/*[in]*/ LPCOLESTR /*pszMkDocumentOld*/,
		/*[in]*/ LPCOLESTR /*pszMkDocumentNew*/,
		/*[in]*/ IVsHierarchy* /*pHier*/,
		/*[in]*/ VSITEMID /*itemidNew*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AdviseRunningDocTableEvents)(
		/*[in]*/ IVsRunningDocTableEvents* /*pSink*/,
		/*[out]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseRunningDocTableEvents)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDocumentInfo)(
		/*[in]*/ VSCOOKIE /*docCookie*/,
		/*[out]*/ VSRDTFLAGS* /*pgrfRDTFlags*/,
		/*[out]*/ DWORD* /*pdwReadLocks*/,
		/*[out]*/ DWORD* /*pdwEditLocks*/,
		/*[out]*/ BSTR* /*pbstrMkDocument*/,
		/*[out]*/ IVsHierarchy** /*ppHier*/,
		/*[out]*/ VSITEMID* /*pitemid*/,
		/*[out]*/ IUnknown** /*ppunkDocData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(NotifyDocumentChanged)(
		/*[in]*/ VSCOOKIE /*dwCookie*/,
		/*[in]*/ VSRDTATTRIB /*grfDocChanged*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(NotifyOnAfterSave)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetRunningDocumentsEnum)(
		/*[out]*/ IEnumRunningDocuments** /*ppenum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SaveDocuments)(
		/*[in]*/ VSRDTSAVEOPTIONS /*grfSaveOpts*/,
		/*[in]*/ IVsHierarchy* /*pHier*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ VSCOOKIE /*docCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(NotifyOnBeforeSave)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RegisterDocumentLockHolder)(
		/*[in]*/ VSREGDOCLOCKHOLDER /*grfRDLH*/,
		/*[in]*/ VSCOOKIE /*dwCookie*/,
		/*[in]*/ IVsDocumentLockHolder* /*pLockHolder*/,
		/*[out]*/ VSCOOKIE* /*pdwLHCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnregisterDocumentLockHolder)(
		/*[in]*/ VSCOOKIE /*dwLHCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ModifyDocumentFlags)(
		/*[in]*/ VSCOOKIE /*docCookie*/,
		/*[in]*/ VSRDTFLAGS /*grfFlags*/,
		/*[in]*/ BOOL /*fSet*/)VSL_STDMETHOD_NOTIMPL
};

class IVsRunningDocumentTableMockImpl :
	public IVsRunningDocumentTable,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsRunningDocumentTableMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsRunningDocumentTableMockImpl)

	typedef IVsRunningDocumentTable Interface;
	struct RegisterAndLockDocumentValidValues
	{
		/*[in]*/ VSRDTFLAGS grfRDTLockType;
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[in]*/ IVsHierarchy* pHier;
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ IUnknown* punkDocData;
		/*[out]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(RegisterAndLockDocument)(
		/*[in]*/ VSRDTFLAGS grfRDTLockType,
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[in]*/ IVsHierarchy* pHier,
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ IUnknown* punkDocData,
		/*[out]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(RegisterAndLockDocument)

		VSL_CHECK_VALIDVALUE(grfRDTLockType);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHier);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkDocData);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct LockDocumentValidValues
	{
		/*[in]*/ VSRDTFLAGS grfRDTLockType;
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(LockDocument)(
		/*[in]*/ VSRDTFLAGS grfRDTLockType,
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(LockDocument)

		VSL_CHECK_VALIDVALUE(grfRDTLockType);

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnlockDocumentValidValues
	{
		/*[in]*/ VSRDTFLAGS grfRDTLockType;
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnlockDocument)(
		/*[in]*/ VSRDTFLAGS grfRDTLockType,
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnlockDocument)

		VSL_CHECK_VALIDVALUE(grfRDTLockType);

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct FindAndLockDocumentValidValues
	{
		/*[in]*/ VSRDTFLAGS dwRDTLockType;
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[out]*/ IVsHierarchy** ppHier;
		/*[out]*/ VSITEMID* pitemid;
		/*[out]*/ IUnknown** ppunkDocData;
		/*[out]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(FindAndLockDocument)(
		/*[in]*/ VSRDTFLAGS dwRDTLockType,
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[out]*/ IVsHierarchy** ppHier,
		/*[out]*/ VSITEMID* pitemid,
		/*[out]*/ IUnknown** ppunkDocData,
		/*[out]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(FindAndLockDocument)

		VSL_CHECK_VALIDVALUE(dwRDTLockType);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_SET_VALIDVALUE_INTERFACE(ppHier);

		VSL_SET_VALIDVALUE(pitemid);

		VSL_SET_VALIDVALUE_INTERFACE(ppunkDocData);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct RenameDocumentValidValues
	{
		/*[in]*/ LPCOLESTR pszMkDocumentOld;
		/*[in]*/ LPCOLESTR pszMkDocumentNew;
		/*[in]*/ IVsHierarchy* pHier;
		/*[in]*/ VSITEMID itemidNew;
		HRESULT retValue;
	};

	STDMETHOD(RenameDocument)(
		/*[in]*/ LPCOLESTR pszMkDocumentOld,
		/*[in]*/ LPCOLESTR pszMkDocumentNew,
		/*[in]*/ IVsHierarchy* pHier,
		/*[in]*/ VSITEMID itemidNew)
	{
		VSL_DEFINE_MOCK_METHOD(RenameDocument)

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocumentOld);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocumentNew);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHier);

		VSL_CHECK_VALIDVALUE(itemidNew);

		VSL_RETURN_VALIDVALUES();
	}
	struct AdviseRunningDocTableEventsValidValues
	{
		/*[in]*/ IVsRunningDocTableEvents* pSink;
		/*[out]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(AdviseRunningDocTableEvents)(
		/*[in]*/ IVsRunningDocTableEvents* pSink,
		/*[out]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(AdviseRunningDocTableEvents)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSink);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseRunningDocTableEventsValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnadviseRunningDocTableEvents)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnadviseRunningDocTableEvents)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDocumentInfoValidValues
	{
		/*[in]*/ VSCOOKIE docCookie;
		/*[out]*/ VSRDTFLAGS* pgrfRDTFlags;
		/*[out]*/ DWORD* pdwReadLocks;
		/*[out]*/ DWORD* pdwEditLocks;
		/*[out]*/ BSTR* pbstrMkDocument;
		/*[out]*/ IVsHierarchy** ppHier;
		/*[out]*/ VSITEMID* pitemid;
		/*[out]*/ IUnknown** ppunkDocData;
		HRESULT retValue;
	};

	STDMETHOD(GetDocumentInfo)(
		/*[in]*/ VSCOOKIE docCookie,
		/*[out]*/ VSRDTFLAGS* pgrfRDTFlags,
		/*[out]*/ DWORD* pdwReadLocks,
		/*[out]*/ DWORD* pdwEditLocks,
		/*[out]*/ BSTR* pbstrMkDocument,
		/*[out]*/ IVsHierarchy** ppHier,
		/*[out]*/ VSITEMID* pitemid,
		/*[out]*/ IUnknown** ppunkDocData)
	{
		VSL_DEFINE_MOCK_METHOD(GetDocumentInfo)

		VSL_CHECK_VALIDVALUE(docCookie);

		VSL_SET_VALIDVALUE(pgrfRDTFlags);

		VSL_SET_VALIDVALUE(pdwReadLocks);

		VSL_SET_VALIDVALUE(pdwEditLocks);

		VSL_SET_VALIDVALUE_BSTR(pbstrMkDocument);

		VSL_SET_VALIDVALUE_INTERFACE(ppHier);

		VSL_SET_VALIDVALUE(pitemid);

		VSL_SET_VALIDVALUE_INTERFACE(ppunkDocData);

		VSL_RETURN_VALIDVALUES();
	}
	struct NotifyDocumentChangedValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		/*[in]*/ VSRDTATTRIB grfDocChanged;
		HRESULT retValue;
	};

	STDMETHOD(NotifyDocumentChanged)(
		/*[in]*/ VSCOOKIE dwCookie,
		/*[in]*/ VSRDTATTRIB grfDocChanged)
	{
		VSL_DEFINE_MOCK_METHOD(NotifyDocumentChanged)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_CHECK_VALIDVALUE(grfDocChanged);

		VSL_RETURN_VALIDVALUES();
	}
	struct NotifyOnAfterSaveValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(NotifyOnAfterSave)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(NotifyOnAfterSave)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetRunningDocumentsEnumValidValues
	{
		/*[out]*/ IEnumRunningDocuments** ppenum;
		HRESULT retValue;
	};

	STDMETHOD(GetRunningDocumentsEnum)(
		/*[out]*/ IEnumRunningDocuments** ppenum)
	{
		VSL_DEFINE_MOCK_METHOD(GetRunningDocumentsEnum)

		VSL_SET_VALIDVALUE_INTERFACE(ppenum);

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveDocumentsValidValues
	{
		/*[in]*/ VSRDTSAVEOPTIONS grfSaveOpts;
		/*[in]*/ IVsHierarchy* pHier;
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ VSCOOKIE docCookie;
		HRESULT retValue;
	};

	STDMETHOD(SaveDocuments)(
		/*[in]*/ VSRDTSAVEOPTIONS grfSaveOpts,
		/*[in]*/ IVsHierarchy* pHier,
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ VSCOOKIE docCookie)
	{
		VSL_DEFINE_MOCK_METHOD(SaveDocuments)

		VSL_CHECK_VALIDVALUE(grfSaveOpts);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHier);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE(docCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct NotifyOnBeforeSaveValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(NotifyOnBeforeSave)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(NotifyOnBeforeSave)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct RegisterDocumentLockHolderValidValues
	{
		/*[in]*/ VSREGDOCLOCKHOLDER grfRDLH;
		/*[in]*/ VSCOOKIE dwCookie;
		/*[in]*/ IVsDocumentLockHolder* pLockHolder;
		/*[out]*/ VSCOOKIE* pdwLHCookie;
		HRESULT retValue;
	};

	STDMETHOD(RegisterDocumentLockHolder)(
		/*[in]*/ VSREGDOCLOCKHOLDER grfRDLH,
		/*[in]*/ VSCOOKIE dwCookie,
		/*[in]*/ IVsDocumentLockHolder* pLockHolder,
		/*[out]*/ VSCOOKIE* pdwLHCookie)
	{
		VSL_DEFINE_MOCK_METHOD(RegisterDocumentLockHolder)

		VSL_CHECK_VALIDVALUE(grfRDLH);

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pLockHolder);

		VSL_SET_VALIDVALUE(pdwLHCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnregisterDocumentLockHolderValidValues
	{
		/*[in]*/ VSCOOKIE dwLHCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnregisterDocumentLockHolder)(
		/*[in]*/ VSCOOKIE dwLHCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnregisterDocumentLockHolder)

		VSL_CHECK_VALIDVALUE(dwLHCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct ModifyDocumentFlagsValidValues
	{
		/*[in]*/ VSCOOKIE docCookie;
		/*[in]*/ VSRDTFLAGS grfFlags;
		/*[in]*/ BOOL fSet;
		HRESULT retValue;
	};

	STDMETHOD(ModifyDocumentFlags)(
		/*[in]*/ VSCOOKIE docCookie,
		/*[in]*/ VSRDTFLAGS grfFlags,
		/*[in]*/ BOOL fSet)
	{
		VSL_DEFINE_MOCK_METHOD(ModifyDocumentFlags)

		VSL_CHECK_VALIDVALUE(docCookie);

		VSL_CHECK_VALIDVALUE(grfFlags);

		VSL_CHECK_VALIDVALUE(fSet);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSRUNNINGDOCUMENTTABLE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSccControlNewSolution.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSCCCONTROLNEWSOLUTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSCCCONTROLNEWSOLUTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "IVsSccControlNewSolution.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSccControlNewSolutionNotImpl :
	public IVsSccControlNewSolution
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSccControlNewSolutionNotImpl)

public:

	typedef IVsSccControlNewSolution Interface;

	STDMETHOD(AddNewSolutionToSourceControl)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDisplayStringForAction)(
		/*[out]*/ BSTR* /*pbstrActionName*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSccControlNewSolutionMockImpl :
	public IVsSccControlNewSolution,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSccControlNewSolutionMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSccControlNewSolutionMockImpl)

	typedef IVsSccControlNewSolution Interface;
	struct AddNewSolutionToSourceControlValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(AddNewSolutionToSourceControl)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(AddNewSolutionToSourceControl)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDisplayStringForActionValidValues
	{
		/*[out]*/ BSTR* pbstrActionName;
		HRESULT retValue;
	};

	STDMETHOD(GetDisplayStringForAction)(
		/*[out]*/ BSTR* pbstrActionName)
	{
		VSL_DEFINE_MOCK_METHOD(GetDisplayStringForAction)

		VSL_SET_VALIDVALUE_BSTR(pbstrActionName);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSCCCONTROLNEWSOLUTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsRunningDocTableEvents3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSRUNNINGDOCTABLEEVENTS3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSRUNNINGDOCTABLEEVENTS3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsRunningDocTableEvents3NotImpl :
	public IVsRunningDocTableEvents3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsRunningDocTableEvents3NotImpl)

public:

	typedef IVsRunningDocTableEvents3 Interface;

	STDMETHOD(OnBeforeSave)(
		/*[in]*/ VSCOOKIE /*docCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterAttributeChangeEx)(
		/*[in]*/ VSCOOKIE /*docCookie*/,
		/*[in]*/ VSRDTATTRIB /*grfAttribs*/,
		/*[in]*/ IVsHierarchy* /*pHierOld*/,
		/*[in]*/ VSITEMID /*itemidOld*/,
		/*[in]*/ LPCOLESTR /*pszMkDocumentOld*/,
		/*[in]*/ IVsHierarchy* /*pHierNew*/,
		/*[in]*/ VSITEMID /*itemidNew*/,
		/*[in]*/ LPCOLESTR /*pszMkDocumentNew*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterFirstDocumentLock)(
		/*[in]*/ VSCOOKIE /*docCookie*/,
		/*[in]*/ VSRDTFLAGS /*dwRDTLockType*/,
		/*[in]*/ DWORD /*dwReadLocksRemaining*/,
		/*[in]*/ DWORD /*dwEditLocksRemaining*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnBeforeLastDocumentUnlock)(
		/*[in]*/ VSCOOKIE /*docCookie*/,
		/*[in]*/ VSRDTFLAGS /*dwRDTLockType*/,
		/*[in]*/ DWORD /*dwReadLocksRemaining*/,
		/*[in]*/ DWORD /*dwEditLocksRemaining*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterSave)(
		/*[in]*/ VSCOOKIE /*docCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterAttributeChange)(
		/*[in]*/ VSCOOKIE /*docCookie*/,
		/*[in]*/ VSRDTATTRIB /*grfAttribs*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnBeforeDocumentWindowShow)(
		/*[in]*/ VSCOOKIE /*docCookie*/,
		/*[in]*/ BOOL /*fFirstShow*/,
		/*[in]*/ IVsWindowFrame* /*pFrame*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterDocumentWindowHide)(
		/*[in]*/ VSCOOKIE /*docCookie*/,
		/*[in]*/ IVsWindowFrame* /*pFrame*/)VSL_STDMETHOD_NOTIMPL
};

class IVsRunningDocTableEvents3MockImpl :
	public IVsRunningDocTableEvents3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsRunningDocTableEvents3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsRunningDocTableEvents3MockImpl)

	typedef IVsRunningDocTableEvents3 Interface;
	struct OnBeforeSaveValidValues
	{
		/*[in]*/ VSCOOKIE docCookie;
		HRESULT retValue;
	};

	STDMETHOD(OnBeforeSave)(
		/*[in]*/ VSCOOKIE docCookie)
	{
		VSL_DEFINE_MOCK_METHOD(OnBeforeSave)

		VSL_CHECK_VALIDVALUE(docCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterAttributeChangeExValidValues
	{
		/*[in]*/ VSCOOKIE docCookie;
		/*[in]*/ VSRDTATTRIB grfAttribs;
		/*[in]*/ IVsHierarchy* pHierOld;
		/*[in]*/ VSITEMID itemidOld;
		/*[in]*/ LPCOLESTR pszMkDocumentOld;
		/*[in]*/ IVsHierarchy* pHierNew;
		/*[in]*/ VSITEMID itemidNew;
		/*[in]*/ LPCOLESTR pszMkDocumentNew;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterAttributeChangeEx)(
		/*[in]*/ VSCOOKIE docCookie,
		/*[in]*/ VSRDTATTRIB grfAttribs,
		/*[in]*/ IVsHierarchy* pHierOld,
		/*[in]*/ VSITEMID itemidOld,
		/*[in]*/ LPCOLESTR pszMkDocumentOld,
		/*[in]*/ IVsHierarchy* pHierNew,
		/*[in]*/ VSITEMID itemidNew,
		/*[in]*/ LPCOLESTR pszMkDocumentNew)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterAttributeChangeEx)

		VSL_CHECK_VALIDVALUE(docCookie);

		VSL_CHECK_VALIDVALUE(grfAttribs);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierOld);

		VSL_CHECK_VALIDVALUE(itemidOld);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocumentOld);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierNew);

		VSL_CHECK_VALIDVALUE(itemidNew);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocumentNew);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterFirstDocumentLockValidValues
	{
		/*[in]*/ VSCOOKIE docCookie;
		/*[in]*/ VSRDTFLAGS dwRDTLockType;
		/*[in]*/ DWORD dwReadLocksRemaining;
		/*[in]*/ DWORD dwEditLocksRemaining;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterFirstDocumentLock)(
		/*[in]*/ VSCOOKIE docCookie,
		/*[in]*/ VSRDTFLAGS dwRDTLockType,
		/*[in]*/ DWORD dwReadLocksRemaining,
		/*[in]*/ DWORD dwEditLocksRemaining)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterFirstDocumentLock)

		VSL_CHECK_VALIDVALUE(docCookie);

		VSL_CHECK_VALIDVALUE(dwRDTLockType);

		VSL_CHECK_VALIDVALUE(dwReadLocksRemaining);

		VSL_CHECK_VALIDVALUE(dwEditLocksRemaining);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnBeforeLastDocumentUnlockValidValues
	{
		/*[in]*/ VSCOOKIE docCookie;
		/*[in]*/ VSRDTFLAGS dwRDTLockType;
		/*[in]*/ DWORD dwReadLocksRemaining;
		/*[in]*/ DWORD dwEditLocksRemaining;
		HRESULT retValue;
	};

	STDMETHOD(OnBeforeLastDocumentUnlock)(
		/*[in]*/ VSCOOKIE docCookie,
		/*[in]*/ VSRDTFLAGS dwRDTLockType,
		/*[in]*/ DWORD dwReadLocksRemaining,
		/*[in]*/ DWORD dwEditLocksRemaining)
	{
		VSL_DEFINE_MOCK_METHOD(OnBeforeLastDocumentUnlock)

		VSL_CHECK_VALIDVALUE(docCookie);

		VSL_CHECK_VALIDVALUE(dwRDTLockType);

		VSL_CHECK_VALIDVALUE(dwReadLocksRemaining);

		VSL_CHECK_VALIDVALUE(dwEditLocksRemaining);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterSaveValidValues
	{
		/*[in]*/ VSCOOKIE docCookie;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterSave)(
		/*[in]*/ VSCOOKIE docCookie)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterSave)

		VSL_CHECK_VALIDVALUE(docCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterAttributeChangeValidValues
	{
		/*[in]*/ VSCOOKIE docCookie;
		/*[in]*/ VSRDTATTRIB grfAttribs;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterAttributeChange)(
		/*[in]*/ VSCOOKIE docCookie,
		/*[in]*/ VSRDTATTRIB grfAttribs)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterAttributeChange)

		VSL_CHECK_VALIDVALUE(docCookie);

		VSL_CHECK_VALIDVALUE(grfAttribs);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnBeforeDocumentWindowShowValidValues
	{
		/*[in]*/ VSCOOKIE docCookie;
		/*[in]*/ BOOL fFirstShow;
		/*[in]*/ IVsWindowFrame* pFrame;
		HRESULT retValue;
	};

	STDMETHOD(OnBeforeDocumentWindowShow)(
		/*[in]*/ VSCOOKIE docCookie,
		/*[in]*/ BOOL fFirstShow,
		/*[in]*/ IVsWindowFrame* pFrame)
	{
		VSL_DEFINE_MOCK_METHOD(OnBeforeDocumentWindowShow)

		VSL_CHECK_VALIDVALUE(docCookie);

		VSL_CHECK_VALIDVALUE(fFirstShow);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pFrame);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterDocumentWindowHideValidValues
	{
		/*[in]*/ VSCOOKIE docCookie;
		/*[in]*/ IVsWindowFrame* pFrame;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterDocumentWindowHide)(
		/*[in]*/ VSCOOKIE docCookie,
		/*[in]*/ IVsWindowFrame* pFrame)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterDocumentWindowHide)

		VSL_CHECK_VALIDVALUE(docCookie);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pFrame);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSRUNNINGDOCTABLEEVENTS3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsRunningDocTableEvents4.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSRUNNINGDOCTABLEEVENTS4_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSRUNNINGDOCTABLEEVENTS4_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsRunningDocTableEvents4NotImpl :
	public IVsRunningDocTableEvents4
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsRunningDocTableEvents4NotImpl)

public:

	typedef IVsRunningDocTableEvents4 Interface;

	STDMETHOD(OnBeforeFirstDocumentLock)(
		/*[in]*/ IVsHierarchy* /*pHier*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ LPCOLESTR /*pszMkDocument*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterSaveAll)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterLastDocumentUnlock)(
		/*[in]*/ IVsHierarchy* /*pHier*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[in]*/ BOOL /*fClosedWithoutSaving*/)VSL_STDMETHOD_NOTIMPL
};

class IVsRunningDocTableEvents4MockImpl :
	public IVsRunningDocTableEvents4,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsRunningDocTableEvents4MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsRunningDocTableEvents4MockImpl)

	typedef IVsRunningDocTableEvents4 Interface;
	struct OnBeforeFirstDocumentLockValidValues
	{
		/*[in]*/ IVsHierarchy* pHier;
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ LPCOLESTR pszMkDocument;
		HRESULT retValue;
	};

	STDMETHOD(OnBeforeFirstDocumentLock)(
		/*[in]*/ IVsHierarchy* pHier,
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ LPCOLESTR pszMkDocument)
	{
		VSL_DEFINE_MOCK_METHOD(OnBeforeFirstDocumentLock)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHier);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterSaveAllValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnAfterSaveAll)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnAfterSaveAll)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterLastDocumentUnlockValidValues
	{
		/*[in]*/ IVsHierarchy* pHier;
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[in]*/ BOOL fClosedWithoutSaving;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterLastDocumentUnlock)(
		/*[in]*/ IVsHierarchy* pHier,
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[in]*/ BOOL fClosedWithoutSaving)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterLastDocumentUnlock)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHier);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_CHECK_VALIDVALUE(fClosedWithoutSaving);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSRUNNINGDOCTABLEEVENTS4_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsRunningDocumentTable2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSRUNNINGDOCUMENTTABLE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSRUNNINGDOCUMENTTABLE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsRunningDocumentTable2NotImpl :
	public IVsRunningDocumentTable2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsRunningDocumentTable2NotImpl)

public:

	typedef IVsRunningDocumentTable2 Interface;

	STDMETHOD(CloseDocuments)(
		/*[in]*/ FRAMECLOSE /*grfSaveOptions*/,
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ VSCOOKIE /*docCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryCloseRunningDocument)(
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[out]*/ BOOL* /*pfFoundAndClosed*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FindAndLockDocumentEx)(
		/*[in]*/ VSRDTFLAGS /*grfRDTLockType*/,
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[in]*/ IVsHierarchy* /*pHierPreferred*/,
		/*[in]*/ VSITEMID /*itemidPreferred*/,
		/*[out]*/ IVsHierarchy** /*ppHierActual*/,
		/*[out]*/ VSITEMID* /*pitemidActual*/,
		/*[out]*/ IUnknown** /*ppunkDocDataActual*/,
		/*[out]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FindOrRegisterAndLockDocument)(
		/*[in]*/ VSRDTFLAGS /*grfRDTLockType*/,
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[in]*/ IVsHierarchy* /*pHierPreferred*/,
		/*[in]*/ VSITEMID /*itemidPreferred*/,
		/*[in]*/ IUnknown* /*punkDocData*/,
		/*[out]*/ IVsHierarchy** /*ppHierActual*/,
		/*[out]*/ VSITEMID* /*pitemidActual*/,
		/*[out]*/ IUnknown** /*ppunkDocDataActual*/,
		/*[out]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL
};

class IVsRunningDocumentTable2MockImpl :
	public IVsRunningDocumentTable2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsRunningDocumentTable2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsRunningDocumentTable2MockImpl)

	typedef IVsRunningDocumentTable2 Interface;
	struct CloseDocumentsValidValues
	{
		/*[in]*/ FRAMECLOSE grfSaveOptions;
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ VSCOOKIE docCookie;
		HRESULT retValue;
	};

	STDMETHOD(CloseDocuments)(
		/*[in]*/ FRAMECLOSE grfSaveOptions,
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ VSCOOKIE docCookie)
	{
		VSL_DEFINE_MOCK_METHOD(CloseDocuments)

		VSL_CHECK_VALIDVALUE(grfSaveOptions);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE(docCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryCloseRunningDocumentValidValues
	{
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[out]*/ BOOL* pfFoundAndClosed;
		HRESULT retValue;
	};

	STDMETHOD(QueryCloseRunningDocument)(
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[out]*/ BOOL* pfFoundAndClosed)
	{
		VSL_DEFINE_MOCK_METHOD(QueryCloseRunningDocument)

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_SET_VALIDVALUE(pfFoundAndClosed);

		VSL_RETURN_VALIDVALUES();
	}
	struct FindAndLockDocumentExValidValues
	{
		/*[in]*/ VSRDTFLAGS grfRDTLockType;
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[in]*/ IVsHierarchy* pHierPreferred;
		/*[in]*/ VSITEMID itemidPreferred;
		/*[out]*/ IVsHierarchy** ppHierActual;
		/*[out]*/ VSITEMID* pitemidActual;
		/*[out]*/ IUnknown** ppunkDocDataActual;
		/*[out]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(FindAndLockDocumentEx)(
		/*[in]*/ VSRDTFLAGS grfRDTLockType,
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[in]*/ IVsHierarchy* pHierPreferred,
		/*[in]*/ VSITEMID itemidPreferred,
		/*[out]*/ IVsHierarchy** ppHierActual,
		/*[out]*/ VSITEMID* pitemidActual,
		/*[out]*/ IUnknown** ppunkDocDataActual,
		/*[out]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(FindAndLockDocumentEx)

		VSL_CHECK_VALIDVALUE(grfRDTLockType);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierPreferred);

		VSL_CHECK_VALIDVALUE(itemidPreferred);

		VSL_SET_VALIDVALUE_INTERFACE(ppHierActual);

		VSL_SET_VALIDVALUE(pitemidActual);

		VSL_SET_VALIDVALUE_INTERFACE(ppunkDocDataActual);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct FindOrRegisterAndLockDocumentValidValues
	{
		/*[in]*/ VSRDTFLAGS grfRDTLockType;
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[in]*/ IVsHierarchy* pHierPreferred;
		/*[in]*/ VSITEMID itemidPreferred;
		/*[in]*/ IUnknown* punkDocData;
		/*[out]*/ IVsHierarchy** ppHierActual;
		/*[out]*/ VSITEMID* pitemidActual;
		/*[out]*/ IUnknown** ppunkDocDataActual;
		/*[out]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(FindOrRegisterAndLockDocument)(
		/*[in]*/ VSRDTFLAGS grfRDTLockType,
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[in]*/ IVsHierarchy* pHierPreferred,
		/*[in]*/ VSITEMID itemidPreferred,
		/*[in]*/ IUnknown* punkDocData,
		/*[out]*/ IVsHierarchy** ppHierActual,
		/*[out]*/ VSITEMID* pitemidActual,
		/*[out]*/ IUnknown** ppunkDocDataActual,
		/*[out]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(FindOrRegisterAndLockDocument)

		VSL_CHECK_VALIDVALUE(grfRDTLockType);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierPreferred);

		VSL_CHECK_VALIDVALUE(itemidPreferred);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkDocData);

		VSL_SET_VALIDVALUE_INTERFACE(ppHierActual);

		VSL_SET_VALIDVALUE(pitemidActual);

		VSL_SET_VALIDVALUE_INTERFACE(ppunkDocDataActual);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSRUNNINGDOCUMENTTABLE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSccAddWebProjectFromSourceControl.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSCCADDWEBPROJECTFROMSOURCECONTROL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSCCADDWEBPROJECTFROMSOURCECONTROL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "IVsSccAddWebProjectFromSourceControl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSccAddWebProjectFromSourceControlNotImpl :
	public IVsSccAddWebProjectFromSourceControl
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSccAddWebProjectFromSourceControlNotImpl)

public:

	typedef IVsSccAddWebProjectFromSourceControl Interface;

	STDMETHOD(IsAddWebProjectSupported)(
		/*[out]*/ VARIANT_BOOL* /*pfResult*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(BrowseForServerLocation)(
		/*[out]*/ BSTR* /*pbstrLocationDescription*/,
		/*[out]*/ BSTR* /*pbstrLocalPath*/,
		/*[out]*/ BSTR* /*pbstrDatabasePath*/,
		/*[out]*/ BSTR* /*pbstrAuxiliarPath*/,
		/*[out]*/ BSTR* /*pbstrProviderName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddWebProjectFromSourceControl)(
		/*[in]*/ BSTR /*bstrLocalPath*/,
		/*[in]*/ BSTR /*bstrDatabasePath*/,
		/*[in]*/ BSTR /*bstrAuxiliarPath*/,
		/*[in]*/ BSTR /*bstrProviderName*/,
		/*[in]*/ BSTR /*bstrDebuggingPath*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSccAddWebProjectFromSourceControlMockImpl :
	public IVsSccAddWebProjectFromSourceControl,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSccAddWebProjectFromSourceControlMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSccAddWebProjectFromSourceControlMockImpl)

	typedef IVsSccAddWebProjectFromSourceControl Interface;
	struct IsAddWebProjectSupportedValidValues
	{
		/*[out]*/ VARIANT_BOOL* pfResult;
		HRESULT retValue;
	};

	STDMETHOD(IsAddWebProjectSupported)(
		/*[out]*/ VARIANT_BOOL* pfResult)
	{
		VSL_DEFINE_MOCK_METHOD(IsAddWebProjectSupported)

		VSL_SET_VALIDVALUE(pfResult);

		VSL_RETURN_VALIDVALUES();
	}
	struct BrowseForServerLocationValidValues
	{
		/*[out]*/ BSTR* pbstrLocationDescription;
		/*[out]*/ BSTR* pbstrLocalPath;
		/*[out]*/ BSTR* pbstrDatabasePath;
		/*[out]*/ BSTR* pbstrAuxiliarPath;
		/*[out]*/ BSTR* pbstrProviderName;
		HRESULT retValue;
	};

	STDMETHOD(BrowseForServerLocation)(
		/*[out]*/ BSTR* pbstrLocationDescription,
		/*[out]*/ BSTR* pbstrLocalPath,
		/*[out]*/ BSTR* pbstrDatabasePath,
		/*[out]*/ BSTR* pbstrAuxiliarPath,
		/*[out]*/ BSTR* pbstrProviderName)
	{
		VSL_DEFINE_MOCK_METHOD(BrowseForServerLocation)

		VSL_SET_VALIDVALUE_BSTR(pbstrLocationDescription);

		VSL_SET_VALIDVALUE_BSTR(pbstrLocalPath);

		VSL_SET_VALIDVALUE_BSTR(pbstrDatabasePath);

		VSL_SET_VALIDVALUE_BSTR(pbstrAuxiliarPath);

		VSL_SET_VALIDVALUE_BSTR(pbstrProviderName);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddWebProjectFromSourceControlValidValues
	{
		/*[in]*/ BSTR bstrLocalPath;
		/*[in]*/ BSTR bstrDatabasePath;
		/*[in]*/ BSTR bstrAuxiliarPath;
		/*[in]*/ BSTR bstrProviderName;
		/*[in]*/ BSTR bstrDebuggingPath;
		HRESULT retValue;
	};

	STDMETHOD(AddWebProjectFromSourceControl)(
		/*[in]*/ BSTR bstrLocalPath,
		/*[in]*/ BSTR bstrDatabasePath,
		/*[in]*/ BSTR bstrAuxiliarPath,
		/*[in]*/ BSTR bstrProviderName,
		/*[in]*/ BSTR bstrDebuggingPath)
	{
		VSL_DEFINE_MOCK_METHOD(AddWebProjectFromSourceControl)

		VSL_CHECK_VALIDVALUE_BSTR(bstrLocalPath);

		VSL_CHECK_VALIDVALUE_BSTR(bstrDatabasePath);

		VSL_CHECK_VALIDVALUE_BSTR(bstrAuxiliarPath);

		VSL_CHECK_VALIDVALUE_BSTR(bstrProviderName);

		VSL_CHECK_VALIDVALUE_BSTR(bstrDebuggingPath);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSCCADDWEBPROJECTFROMSOURCECONTROL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSaveOptionsDlg.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSAVEOPTIONSDLG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSAVEOPTIONSDLG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSaveOptionsDlgNotImpl :
	public IVsSaveOptionsDlg
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSaveOptionsDlgNotImpl)

public:

	typedef IVsSaveOptionsDlg Interface;

	STDMETHOD(ShowSaveOptionsDlg)(
		/*[in]*/ DWORD /*dwReserved*/,
		/*[in]*/ HWND /*hwndDlgParent*/,
		/*[in]*/ WCHAR* /*pszFileName*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSaveOptionsDlgMockImpl :
	public IVsSaveOptionsDlg,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSaveOptionsDlgMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSaveOptionsDlgMockImpl)

	typedef IVsSaveOptionsDlg Interface;
	struct ShowSaveOptionsDlgValidValues
	{
		/*[in]*/ DWORD dwReserved;
		/*[in]*/ HWND hwndDlgParent;
		/*[in]*/ WCHAR* pszFileName;
		HRESULT retValue;
	};

	STDMETHOD(ShowSaveOptionsDlg)(
		/*[in]*/ DWORD dwReserved,
		/*[in]*/ HWND hwndDlgParent,
		/*[in]*/ WCHAR* pszFileName)
	{
		VSL_DEFINE_MOCK_METHOD(ShowSaveOptionsDlg)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_CHECK_VALIDVALUE(hwndDlgParent);

		VSL_CHECK_VALIDVALUE_STRINGW(pszFileName);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSAVEOPTIONSDLG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSccEnlistmentPathTranslation.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSCCENLISTMENTPATHTRANSLATION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSCCENLISTMENTPATHTRANSLATION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "IVsSccEnlistmentPathTranslation.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSccEnlistmentPathTranslationNotImpl :
	public IVsSccEnlistmentPathTranslation
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSccEnlistmentPathTranslationNotImpl)

public:

	typedef IVsSccEnlistmentPathTranslation Interface;

	STDMETHOD(TranslateProjectPathToEnlistmentPath)(
		/*[in]*/ LPCOLESTR /*lpszProjectPath*/,
		/*[out]*/ BSTR* /*pbstrEnlistmentPath*/,
		/*[out]*/ BSTR* /*pbstrEnlistmentPathUNC*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(TranslateEnlistmentPathToProjectPath)(
		/*[in]*/ LPCOLESTR /*lpszEnlistmentPath*/,
		/*[out,retval]*/ BSTR* /*pbstrProjectPath*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSccEnlistmentPathTranslationMockImpl :
	public IVsSccEnlistmentPathTranslation,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSccEnlistmentPathTranslationMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSccEnlistmentPathTranslationMockImpl)

	typedef IVsSccEnlistmentPathTranslation Interface;
	struct TranslateProjectPathToEnlistmentPathValidValues
	{
		/*[in]*/ LPCOLESTR lpszProjectPath;
		/*[out]*/ BSTR* pbstrEnlistmentPath;
		/*[out]*/ BSTR* pbstrEnlistmentPathUNC;
		HRESULT retValue;
	};

	STDMETHOD(TranslateProjectPathToEnlistmentPath)(
		/*[in]*/ LPCOLESTR lpszProjectPath,
		/*[out]*/ BSTR* pbstrEnlistmentPath,
		/*[out]*/ BSTR* pbstrEnlistmentPathUNC)
	{
		VSL_DEFINE_MOCK_METHOD(TranslateProjectPathToEnlistmentPath)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszProjectPath);

		VSL_SET_VALIDVALUE_BSTR(pbstrEnlistmentPath);

		VSL_SET_VALIDVALUE_BSTR(pbstrEnlistmentPathUNC);

		VSL_RETURN_VALIDVALUES();
	}
	struct TranslateEnlistmentPathToProjectPathValidValues
	{
		/*[in]*/ LPCOLESTR lpszEnlistmentPath;
		/*[out,retval]*/ BSTR* pbstrProjectPath;
		HRESULT retValue;
	};

	STDMETHOD(TranslateEnlistmentPathToProjectPath)(
		/*[in]*/ LPCOLESTR lpszEnlistmentPath,
		/*[out,retval]*/ BSTR* pbstrProjectPath)
	{
		VSL_DEFINE_MOCK_METHOD(TranslateEnlistmentPathToProjectPath)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszEnlistmentPath);

		VSL_SET_VALIDVALUE_BSTR(pbstrProjectPath);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSCCENLISTMENTPATHTRANSLATION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSccGlyphs.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSCCGLYPHS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSCCGLYPHS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "IVsSccGlyphs.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSccGlyphsNotImpl :
	public IVsSccGlyphs
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSccGlyphsNotImpl)

public:

	typedef IVsSccGlyphs Interface;

	STDMETHOD(GetCustomGlyphList)(
		/*[in]*/ ULONG /*BaseIndex*/,
		/*[out]*/ PDWORD_PTR /*pdwImageListHandle*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSccGlyphsMockImpl :
	public IVsSccGlyphs,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSccGlyphsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSccGlyphsMockImpl)

	typedef IVsSccGlyphs Interface;
	struct GetCustomGlyphListValidValues
	{
		/*[in]*/ ULONG BaseIndex;
		/*[out]*/ PDWORD_PTR pdwImageListHandle;
		HRESULT retValue;
	};

	STDMETHOD(GetCustomGlyphList)(
		/*[in]*/ ULONG BaseIndex,
		/*[out]*/ PDWORD_PTR pdwImageListHandle)
	{
		VSL_DEFINE_MOCK_METHOD(GetCustomGlyphList)

		VSL_CHECK_VALIDVALUE(BaseIndex);

		VSL_SET_VALIDVALUE(pdwImageListHandle);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSCCGLYPHS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSccManagerTooltip.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSCCMANAGERTOOLTIP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSCCMANAGERTOOLTIP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "IVsSccManagerTooltip.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSccManagerTooltipNotImpl :
	public IVsSccManagerTooltip
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSccManagerTooltipNotImpl)

public:

	typedef IVsSccManagerTooltip Interface;

	STDMETHOD(GetGlyphTipText)(
		/*[in]*/ IVsHierarchy* /*phierHierarchy*/,
		/*[in]*/ VSITEMID /*itemidNode*/,
		/*[out,retval]*/ BSTR* /*pbstrTooltipText*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSccManagerTooltipMockImpl :
	public IVsSccManagerTooltip,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSccManagerTooltipMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSccManagerTooltipMockImpl)

	typedef IVsSccManagerTooltip Interface;
	struct GetGlyphTipTextValidValues
	{
		/*[in]*/ IVsHierarchy* phierHierarchy;
		/*[in]*/ VSITEMID itemidNode;
		/*[out,retval]*/ BSTR* pbstrTooltipText;
		HRESULT retValue;
	};

	STDMETHOD(GetGlyphTipText)(
		/*[in]*/ IVsHierarchy* phierHierarchy,
		/*[in]*/ VSITEMID itemidNode,
		/*[out,retval]*/ BSTR* pbstrTooltipText)
	{
		VSL_DEFINE_MOCK_METHOD(GetGlyphTipText)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(phierHierarchy);

		VSL_CHECK_VALIDVALUE(itemidNode);

		VSL_SET_VALIDVALUE_BSTR(pbstrTooltipText);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSCCMANAGERTOOLTIP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSccOpenFromSourceControl.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSCCOPENFROMSOURCECONTROL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSCCOPENFROMSOURCECONTROL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "IVsSccOpenFromSourceControl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSccOpenFromSourceControlNotImpl :
	public IVsSccOpenFromSourceControl
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSccOpenFromSourceControlNotImpl)

public:

	typedef IVsSccOpenFromSourceControl Interface;

	STDMETHOD(OpenSolutionFromSourceControl)(
		/*[in]*/ LPCOLESTR /*pszSolutionStoreUrl*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddProjectFromSourceControl)(
		/*[in]*/ LPCOLESTR /*pszProjectStoreUrl*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddItemFromSourceControl)(
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ VSITEMID /*itemidLoc*/,
		/*[in]*/ ULONG /*cFilesToAdd*/,
		/*[in,size_is(cFilesToAdd)]*/ LPCOLESTR[] /*rgpszFilesToAdd*/,
		/*[in]*/ HWND /*hwndDlgOwner*/,
		/*[in]*/ VSSPECIFICEDITORFLAGS /*grfEditorFlags*/,
		/*[in]*/ REFGUID /*rguidEditorType*/,
		/*[in]*/ LPCOLESTR /*pszPhysicalView*/,
		/*[in]*/ REFGUID /*rguidLogicalView*/,
		/*[out,retval]*/ VSADDRESULT* /*pResult*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetNamespaceExtensionInformation)(
		/*[in]*/ VSOPENFROMSCCDLG /*vsofsdDlg*/,
		/*[out]*/ BSTR* /*pbstrNamespaceGUID*/,
		/*[out]*/ BSTR* /*pbstrTrayDisplayName*/,
		/*[out]*/ BSTR* /*pbstrProtocolPrefix*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSccOpenFromSourceControlMockImpl :
	public IVsSccOpenFromSourceControl,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSccOpenFromSourceControlMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSccOpenFromSourceControlMockImpl)

	typedef IVsSccOpenFromSourceControl Interface;
	struct OpenSolutionFromSourceControlValidValues
	{
		/*[in]*/ LPCOLESTR pszSolutionStoreUrl;
		HRESULT retValue;
	};

	STDMETHOD(OpenSolutionFromSourceControl)(
		/*[in]*/ LPCOLESTR pszSolutionStoreUrl)
	{
		VSL_DEFINE_MOCK_METHOD(OpenSolutionFromSourceControl)

		VSL_CHECK_VALIDVALUE_STRINGW(pszSolutionStoreUrl);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddProjectFromSourceControlValidValues
	{
		/*[in]*/ LPCOLESTR pszProjectStoreUrl;
		HRESULT retValue;
	};

	STDMETHOD(AddProjectFromSourceControl)(
		/*[in]*/ LPCOLESTR pszProjectStoreUrl)
	{
		VSL_DEFINE_MOCK_METHOD(AddProjectFromSourceControl)

		VSL_CHECK_VALIDVALUE_STRINGW(pszProjectStoreUrl);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddItemFromSourceControlValidValues
	{
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ VSITEMID itemidLoc;
		/*[in]*/ ULONG cFilesToAdd;
		/*[in,size_is(cFilesToAdd)]*/ LPCOLESTR* rgpszFilesToAdd;
		/*[in]*/ HWND hwndDlgOwner;
		/*[in]*/ VSSPECIFICEDITORFLAGS grfEditorFlags;
		/*[in]*/ REFGUID rguidEditorType;
		/*[in]*/ LPCOLESTR pszPhysicalView;
		/*[in]*/ REFGUID rguidLogicalView;
		/*[out,retval]*/ VSADDRESULT* pResult;
		HRESULT retValue;
	};

	STDMETHOD(AddItemFromSourceControl)(
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ VSITEMID itemidLoc,
		/*[in]*/ ULONG cFilesToAdd,
		/*[in,size_is(cFilesToAdd)]*/ LPCOLESTR rgpszFilesToAdd[],
		/*[in]*/ HWND hwndDlgOwner,
		/*[in]*/ VSSPECIFICEDITORFLAGS grfEditorFlags,
		/*[in]*/ REFGUID rguidEditorType,
		/*[in]*/ LPCOLESTR pszPhysicalView,
		/*[in]*/ REFGUID rguidLogicalView,
		/*[out,retval]*/ VSADDRESULT* pResult)
	{
		VSL_DEFINE_MOCK_METHOD(AddItemFromSourceControl)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE(itemidLoc);

		VSL_CHECK_VALIDVALUE(cFilesToAdd);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszFilesToAdd, cFilesToAdd*sizeof(rgpszFilesToAdd[0]), validValues.cFilesToAdd*sizeof(validValues.rgpszFilesToAdd[0]));

		VSL_CHECK_VALIDVALUE(hwndDlgOwner);

		VSL_CHECK_VALIDVALUE(grfEditorFlags);

		VSL_CHECK_VALIDVALUE(rguidEditorType);

		VSL_CHECK_VALIDVALUE_STRINGW(pszPhysicalView);

		VSL_CHECK_VALIDVALUE(rguidLogicalView);

		VSL_SET_VALIDVALUE(pResult);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNamespaceExtensionInformationValidValues
	{
		/*[in]*/ VSOPENFROMSCCDLG vsofsdDlg;
		/*[out]*/ BSTR* pbstrNamespaceGUID;
		/*[out]*/ BSTR* pbstrTrayDisplayName;
		/*[out]*/ BSTR* pbstrProtocolPrefix;
		HRESULT retValue;
	};

	STDMETHOD(GetNamespaceExtensionInformation)(
		/*[in]*/ VSOPENFROMSCCDLG vsofsdDlg,
		/*[out]*/ BSTR* pbstrNamespaceGUID,
		/*[out]*/ BSTR* pbstrTrayDisplayName,
		/*[out]*/ BSTR* pbstrProtocolPrefix)
	{
		VSL_DEFINE_MOCK_METHOD(GetNamespaceExtensionInformation)

		VSL_CHECK_VALIDVALUE(vsofsdDlg);

		VSL_SET_VALIDVALUE_BSTR(pbstrNamespaceGUID);

		VSL_SET_VALIDVALUE_BSTR(pbstrTrayDisplayName);

		VSL_SET_VALIDVALUE_BSTR(pbstrProtocolPrefix);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSCCOPENFROMSOURCECONTROL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSccManager2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSCCMANAGER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSCCMANAGER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "IVsSccManager2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSccManager2NotImpl :
	public IVsSccManager2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSccManager2NotImpl)

public:

	typedef IVsSccManager2 Interface;

	STDMETHOD(RegisterSccProject)(
		/*[in]*/ IVsSccProject2* /*pscp2Project*/,
		/*[in]*/ LPCOLESTR /*pszSccProjectName*/,
		/*[in]*/ LPCOLESTR /*pszSccAuxPath*/,
		/*[in]*/ LPCOLESTR /*pszSccLocalPath*/,
		/*[in]*/ LPCOLESTR /*pszProvider*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnregisterSccProject)(
		/*[in]*/ IVsSccProject2* /*pscp2Project*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSccGlyph)(
		/*[in]*/ int /*cFiles*/,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR[] /*rgpszFullPaths*/,
		/*[out,size_is(cFiles)]*/ VsStateIcon[] /*rgsiGlyphs*/,
		/*[out,size_is(cFiles)]*/ DWORD[] /*rgdwSccStatus*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSccGlyphFromStatus)(
		/*[in]*/ DWORD /*dwSccStatus*/,
		/*[out,retval]*/ VsStateIcon* /*psiGlyph*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsInstalled)(
		/*[out,retval]*/ BOOL* /*pbInstalled*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(BrowseForProject)(
		/*[out]*/ BSTR* /*pbstrDirectory*/,
		/*[out]*/ BOOL* /*pfOK*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CancelAfterBrowseForProject)()VSL_STDMETHOD_NOTIMPL
};

class IVsSccManager2MockImpl :
	public IVsSccManager2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSccManager2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSccManager2MockImpl)

	typedef IVsSccManager2 Interface;
	struct RegisterSccProjectValidValues
	{
		/*[in]*/ IVsSccProject2* pscp2Project;
		/*[in]*/ LPCOLESTR pszSccProjectName;
		/*[in]*/ LPCOLESTR pszSccAuxPath;
		/*[in]*/ LPCOLESTR pszSccLocalPath;
		/*[in]*/ LPCOLESTR pszProvider;
		HRESULT retValue;
	};

	STDMETHOD(RegisterSccProject)(
		/*[in]*/ IVsSccProject2* pscp2Project,
		/*[in]*/ LPCOLESTR pszSccProjectName,
		/*[in]*/ LPCOLESTR pszSccAuxPath,
		/*[in]*/ LPCOLESTR pszSccLocalPath,
		/*[in]*/ LPCOLESTR pszProvider)
	{
		VSL_DEFINE_MOCK_METHOD(RegisterSccProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pscp2Project);

		VSL_CHECK_VALIDVALUE_STRINGW(pszSccProjectName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszSccAuxPath);

		VSL_CHECK_VALIDVALUE_STRINGW(pszSccLocalPath);

		VSL_CHECK_VALIDVALUE_STRINGW(pszProvider);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnregisterSccProjectValidValues
	{
		/*[in]*/ IVsSccProject2* pscp2Project;
		HRESULT retValue;
	};

	STDMETHOD(UnregisterSccProject)(
		/*[in]*/ IVsSccProject2* pscp2Project)
	{
		VSL_DEFINE_MOCK_METHOD(UnregisterSccProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pscp2Project);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSccGlyphValidValues
	{
		/*[in]*/ int cFiles;
		/*[in,size_is(cFiles)]*/ LPCOLESTR* rgpszFullPaths;
		/*[out,size_is(cFiles)]*/ VsStateIcon* rgsiGlyphs;
		/*[out,size_is(cFiles)]*/ DWORD* rgdwSccStatus;
		HRESULT retValue;
	};

	STDMETHOD(GetSccGlyph)(
		/*[in]*/ int cFiles,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR rgpszFullPaths[],
		/*[out,size_is(cFiles)]*/ VsStateIcon rgsiGlyphs[],
		/*[out,size_is(cFiles)]*/ DWORD rgdwSccStatus[])
	{
		VSL_DEFINE_MOCK_METHOD(GetSccGlyph)

		VSL_CHECK_VALIDVALUE(cFiles);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszFullPaths, cFiles*sizeof(rgpszFullPaths[0]), validValues.cFiles*sizeof(validValues.rgpszFullPaths[0]));

		VSL_SET_VALIDVALUE_MEMCPY(rgsiGlyphs, cFiles*sizeof(rgsiGlyphs[0]), validValues.cFiles*sizeof(validValues.rgsiGlyphs[0]));

		VSL_SET_VALIDVALUE_MEMCPY(rgdwSccStatus, cFiles*sizeof(rgdwSccStatus[0]), validValues.cFiles*sizeof(validValues.rgdwSccStatus[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSccGlyphFromStatusValidValues
	{
		/*[in]*/ DWORD dwSccStatus;
		/*[out,retval]*/ VsStateIcon* psiGlyph;
		HRESULT retValue;
	};

	STDMETHOD(GetSccGlyphFromStatus)(
		/*[in]*/ DWORD dwSccStatus,
		/*[out,retval]*/ VsStateIcon* psiGlyph)
	{
		VSL_DEFINE_MOCK_METHOD(GetSccGlyphFromStatus)

		VSL_CHECK_VALIDVALUE(dwSccStatus);

		VSL_SET_VALIDVALUE(psiGlyph);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsInstalledValidValues
	{
		/*[out,retval]*/ BOOL* pbInstalled;
		HRESULT retValue;
	};

	STDMETHOD(IsInstalled)(
		/*[out,retval]*/ BOOL* pbInstalled)
	{
		VSL_DEFINE_MOCK_METHOD(IsInstalled)

		VSL_SET_VALIDVALUE(pbInstalled);

		VSL_RETURN_VALIDVALUES();
	}
	struct BrowseForProjectValidValues
	{
		/*[out]*/ BSTR* pbstrDirectory;
		/*[out]*/ BOOL* pfOK;
		HRESULT retValue;
	};

	STDMETHOD(BrowseForProject)(
		/*[out]*/ BSTR* pbstrDirectory,
		/*[out]*/ BOOL* pfOK)
	{
		VSL_DEFINE_MOCK_METHOD(BrowseForProject)

		VSL_SET_VALIDVALUE_BSTR(pbstrDirectory);

		VSL_SET_VALIDVALUE(pfOK);

		VSL_RETURN_VALIDVALUES();
	}
	struct CancelAfterBrowseForProjectValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CancelAfterBrowseForProject)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CancelAfterBrowseForProject)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSCCMANAGER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSccProjectEnlistmentFactory.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSCCPROJECTENLISTMENTFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSCCPROJECTENLISTMENTFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "IVsSccProjectEnlistmentFactory.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSccProjectEnlistmentFactoryNotImpl :
	public IVsSccProjectEnlistmentFactory
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSccProjectEnlistmentFactoryNotImpl)

public:

	typedef IVsSccProjectEnlistmentFactory Interface;

	STDMETHOD(GetDefaultEnlistment)(
		/*[in]*/ LPCOLESTR /*lpszProjectPath*/,
		/*[out]*/ BSTR* /*pbstrDefaultEnlistment*/,
		/*[out]*/ BSTR* /*pbstrDefaultEnlistmentUNC*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEnlistmentFactoryOptions)(
		/*[out,retval]*/ VSSCCENLISTMENTFACTORYOPTIONS* /*pvscefoOptions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ValidateEnlistmentEdit)(
		/*[in]*/ BOOL /*fQuick*/,
		/*[in]*/ LPCOLESTR /*lpszProjectPath*/,
		/*[in]*/ LPCOLESTR /*lpszChosenEnlistment*/,
		/*[out]*/ BSTR* /*pbstrChosenEnlistmentUNC*/,
		/*[out]*/ BOOL* /*pfValidEnlistment*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(BrowseEnlistment)(
		/*[in]*/ LPCOLESTR /*lpszProjectPath*/,
		/*[in]*/ LPCOLESTR /*lpszInitialEnlistment*/,
		/*[out]*/ BSTR* /*pbstrChosenEnlistment*/,
		/*[out]*/ BSTR* /*pbstrChosenEnlistmentUNC*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnBeforeEnlistmentCreate)(
		/*[in]*/ LPCOLESTR /*lpszProjectPath*/,
		/*[in]*/ LPCOLESTR /*lpszEnlistment*/,
		/*[in]*/ LPCOLESTR /*lpszEnlistmentUNC*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterEnlistmentCreate)(
		/*[in]*/ LPCOLESTR /*lpszProjectPath*/,
		/*[in]*/ LPCOLESTR /*lpszEnlistment*/,
		/*[in]*/ LPCOLESTR /*lpszEnlistmentUNC*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSccProjectEnlistmentFactoryMockImpl :
	public IVsSccProjectEnlistmentFactory,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSccProjectEnlistmentFactoryMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSccProjectEnlistmentFactoryMockImpl)

	typedef IVsSccProjectEnlistmentFactory Interface;
	struct GetDefaultEnlistmentValidValues
	{
		/*[in]*/ LPCOLESTR lpszProjectPath;
		/*[out]*/ BSTR* pbstrDefaultEnlistment;
		/*[out]*/ BSTR* pbstrDefaultEnlistmentUNC;
		HRESULT retValue;
	};

	STDMETHOD(GetDefaultEnlistment)(
		/*[in]*/ LPCOLESTR lpszProjectPath,
		/*[out]*/ BSTR* pbstrDefaultEnlistment,
		/*[out]*/ BSTR* pbstrDefaultEnlistmentUNC)
	{
		VSL_DEFINE_MOCK_METHOD(GetDefaultEnlistment)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszProjectPath);

		VSL_SET_VALIDVALUE_BSTR(pbstrDefaultEnlistment);

		VSL_SET_VALIDVALUE_BSTR(pbstrDefaultEnlistmentUNC);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEnlistmentFactoryOptionsValidValues
	{
		/*[out,retval]*/ VSSCCENLISTMENTFACTORYOPTIONS* pvscefoOptions;
		HRESULT retValue;
	};

	STDMETHOD(GetEnlistmentFactoryOptions)(
		/*[out,retval]*/ VSSCCENLISTMENTFACTORYOPTIONS* pvscefoOptions)
	{
		VSL_DEFINE_MOCK_METHOD(GetEnlistmentFactoryOptions)

		VSL_SET_VALIDVALUE(pvscefoOptions);

		VSL_RETURN_VALIDVALUES();
	}
	struct ValidateEnlistmentEditValidValues
	{
		/*[in]*/ BOOL fQuick;
		/*[in]*/ LPCOLESTR lpszProjectPath;
		/*[in]*/ LPCOLESTR lpszChosenEnlistment;
		/*[out]*/ BSTR* pbstrChosenEnlistmentUNC;
		/*[out]*/ BOOL* pfValidEnlistment;
		HRESULT retValue;
	};

	STDMETHOD(ValidateEnlistmentEdit)(
		/*[in]*/ BOOL fQuick,
		/*[in]*/ LPCOLESTR lpszProjectPath,
		/*[in]*/ LPCOLESTR lpszChosenEnlistment,
		/*[out]*/ BSTR* pbstrChosenEnlistmentUNC,
		/*[out]*/ BOOL* pfValidEnlistment)
	{
		VSL_DEFINE_MOCK_METHOD(ValidateEnlistmentEdit)

		VSL_CHECK_VALIDVALUE(fQuick);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszProjectPath);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszChosenEnlistment);

		VSL_SET_VALIDVALUE_BSTR(pbstrChosenEnlistmentUNC);

		VSL_SET_VALIDVALUE(pfValidEnlistment);

		VSL_RETURN_VALIDVALUES();
	}
	struct BrowseEnlistmentValidValues
	{
		/*[in]*/ LPCOLESTR lpszProjectPath;
		/*[in]*/ LPCOLESTR lpszInitialEnlistment;
		/*[out]*/ BSTR* pbstrChosenEnlistment;
		/*[out]*/ BSTR* pbstrChosenEnlistmentUNC;
		HRESULT retValue;
	};

	STDMETHOD(BrowseEnlistment)(
		/*[in]*/ LPCOLESTR lpszProjectPath,
		/*[in]*/ LPCOLESTR lpszInitialEnlistment,
		/*[out]*/ BSTR* pbstrChosenEnlistment,
		/*[out]*/ BSTR* pbstrChosenEnlistmentUNC)
	{
		VSL_DEFINE_MOCK_METHOD(BrowseEnlistment)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszProjectPath);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszInitialEnlistment);

		VSL_SET_VALIDVALUE_BSTR(pbstrChosenEnlistment);

		VSL_SET_VALIDVALUE_BSTR(pbstrChosenEnlistmentUNC);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnBeforeEnlistmentCreateValidValues
	{
		/*[in]*/ LPCOLESTR lpszProjectPath;
		/*[in]*/ LPCOLESTR lpszEnlistment;
		/*[in]*/ LPCOLESTR lpszEnlistmentUNC;
		HRESULT retValue;
	};

	STDMETHOD(OnBeforeEnlistmentCreate)(
		/*[in]*/ LPCOLESTR lpszProjectPath,
		/*[in]*/ LPCOLESTR lpszEnlistment,
		/*[in]*/ LPCOLESTR lpszEnlistmentUNC)
	{
		VSL_DEFINE_MOCK_METHOD(OnBeforeEnlistmentCreate)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszProjectPath);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszEnlistment);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszEnlistmentUNC);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterEnlistmentCreateValidValues
	{
		/*[in]*/ LPCOLESTR lpszProjectPath;
		/*[in]*/ LPCOLESTR lpszEnlistment;
		/*[in]*/ LPCOLESTR lpszEnlistmentUNC;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterEnlistmentCreate)(
		/*[in]*/ LPCOLESTR lpszProjectPath,
		/*[in]*/ LPCOLESTR lpszEnlistment,
		/*[in]*/ LPCOLESTR lpszEnlistmentUNC)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterEnlistmentCreate)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszProjectPath);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszEnlistment);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszEnlistmentUNC);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSCCPROJECTENLISTMENTFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSccProjectEnlistmentChoice.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSCCPROJECTENLISTMENTCHOICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSCCPROJECTENLISTMENTCHOICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "IVsSccProjectEnlistmentChoice.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSccProjectEnlistmentChoiceNotImpl :
	public IVsSccProjectEnlistmentChoice
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSccProjectEnlistmentChoiceNotImpl)

public:

	typedef IVsSccProjectEnlistmentChoice Interface;

	STDMETHOD(GetEnlistmentChoice)(
		/*[out,retval]*/ VSSCCENLISTMENTCHOICE* /*pvscecEnlistmentChoice*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSccProjectEnlistmentChoiceMockImpl :
	public IVsSccProjectEnlistmentChoice,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSccProjectEnlistmentChoiceMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSccProjectEnlistmentChoiceMockImpl)

	typedef IVsSccProjectEnlistmentChoice Interface;
	struct GetEnlistmentChoiceValidValues
	{
		/*[out,retval]*/ VSSCCENLISTMENTCHOICE* pvscecEnlistmentChoice;
		HRESULT retValue;
	};

	STDMETHOD(GetEnlistmentChoice)(
		/*[out,retval]*/ VSSCCENLISTMENTCHOICE* pvscecEnlistmentChoice)
	{
		VSL_DEFINE_MOCK_METHOD(GetEnlistmentChoice)

		VSL_SET_VALIDVALUE(pvscecEnlistmentChoice);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSCCPROJECTENLISTMENTCHOICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSccProject2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSCCPROJECT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSCCPROJECT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "IVsSccProject2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSccProject2NotImpl :
	public IVsSccProject2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSccProject2NotImpl)

public:

	typedef IVsSccProject2 Interface;

	STDMETHOD(SccGlyphChanged)(
		/*[in]*/ int /*cAffectedNodes*/,
		/*[in,size_is(cAffectedNodes)]*/ const VSITEMID[] /*rgitemidAffectedNodes*/,
		/*[in,size_is(cAffectedNodes)]*/ const VsStateIcon[] /*rgsiNewGlyphs*/,
		/*[in,size_is(cAffectedNodes)]*/ const DWORD[] /*rgdwNewSccStatus*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetSccLocation)(
		/*[in]*/ LPCOLESTR /*pszSccProjectName*/,
		/*[in]*/ LPCOLESTR /*pszSccAuxPath*/,
		/*[in]*/ LPCOLESTR /*pszSccLocalPath*/,
		/*[in]*/ LPCOLESTR /*pszSccProvider*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSccFiles)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[out]*/ CALPOLESTR* /*pCaStringsOut*/,
		/*[out]*/ CADWORD* /*pCaFlagsOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSccSpecialFiles)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ LPCOLESTR /*pszSccFile*/,
		/*[out]*/ CALPOLESTR* /*pCaStringsOut*/,
		/*[out]*/ CADWORD* /*pCaFlagsOut*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSccProject2MockImpl :
	public IVsSccProject2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSccProject2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSccProject2MockImpl)

	typedef IVsSccProject2 Interface;
	struct SccGlyphChangedValidValues
	{
		/*[in]*/ int cAffectedNodes;
		/*[in,size_is(cAffectedNodes)]*/ VSITEMID* rgitemidAffectedNodes;
		/*[in,size_is(cAffectedNodes)]*/ VsStateIcon* rgsiNewGlyphs;
		/*[in,size_is(cAffectedNodes)]*/ DWORD* rgdwNewSccStatus;
		HRESULT retValue;
	};

	STDMETHOD(SccGlyphChanged)(
		/*[in]*/ int cAffectedNodes,
		/*[in,size_is(cAffectedNodes)]*/ const VSITEMID rgitemidAffectedNodes[],
		/*[in,size_is(cAffectedNodes)]*/ const VsStateIcon rgsiNewGlyphs[],
		/*[in,size_is(cAffectedNodes)]*/ const DWORD rgdwNewSccStatus[])
	{
		VSL_DEFINE_MOCK_METHOD(SccGlyphChanged)

		VSL_CHECK_VALIDVALUE(cAffectedNodes);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgitemidAffectedNodes, cAffectedNodes*sizeof(rgitemidAffectedNodes[0]), validValues.cAffectedNodes*sizeof(validValues.rgitemidAffectedNodes[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgsiNewGlyphs, cAffectedNodes*sizeof(rgsiNewGlyphs[0]), validValues.cAffectedNodes*sizeof(validValues.rgsiNewGlyphs[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgdwNewSccStatus, cAffectedNodes*sizeof(rgdwNewSccStatus[0]), validValues.cAffectedNodes*sizeof(validValues.rgdwNewSccStatus[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct SetSccLocationValidValues
	{
		/*[in]*/ LPCOLESTR pszSccProjectName;
		/*[in]*/ LPCOLESTR pszSccAuxPath;
		/*[in]*/ LPCOLESTR pszSccLocalPath;
		/*[in]*/ LPCOLESTR pszSccProvider;
		HRESULT retValue;
	};

	STDMETHOD(SetSccLocation)(
		/*[in]*/ LPCOLESTR pszSccProjectName,
		/*[in]*/ LPCOLESTR pszSccAuxPath,
		/*[in]*/ LPCOLESTR pszSccLocalPath,
		/*[in]*/ LPCOLESTR pszSccProvider)
	{
		VSL_DEFINE_MOCK_METHOD(SetSccLocation)

		VSL_CHECK_VALIDVALUE_STRINGW(pszSccProjectName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszSccAuxPath);

		VSL_CHECK_VALIDVALUE_STRINGW(pszSccLocalPath);

		VSL_CHECK_VALIDVALUE_STRINGW(pszSccProvider);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSccFilesValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[out]*/ CALPOLESTR* pCaStringsOut;
		/*[out]*/ CADWORD* pCaFlagsOut;
		HRESULT retValue;
	};

	STDMETHOD(GetSccFiles)(
		/*[in]*/ VSITEMID itemid,
		/*[out]*/ CALPOLESTR* pCaStringsOut,
		/*[out]*/ CADWORD* pCaFlagsOut)
	{
		VSL_DEFINE_MOCK_METHOD(GetSccFiles)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_SET_VALIDVALUE(pCaStringsOut);

		VSL_SET_VALIDVALUE(pCaFlagsOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSccSpecialFilesValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ LPCOLESTR pszSccFile;
		/*[out]*/ CALPOLESTR* pCaStringsOut;
		/*[out]*/ CADWORD* pCaFlagsOut;
		HRESULT retValue;
	};

	STDMETHOD(GetSccSpecialFiles)(
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ LPCOLESTR pszSccFile,
		/*[out]*/ CALPOLESTR* pCaStringsOut,
		/*[out]*/ CADWORD* pCaFlagsOut)
	{
		VSL_DEFINE_MOCK_METHOD(GetSccSpecialFiles)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE_STRINGW(pszSccFile);

		VSL_SET_VALIDVALUE(pCaStringsOut);

		VSL_SET_VALIDVALUE(pCaFlagsOut);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSCCPROJECT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSccProjectProviderBinding.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSCCPROJECTPROVIDERBINDING_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSCCPROJECTPROVIDERBINDING_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "IVsSccProjectProviderBinding.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSccProjectProviderBindingNotImpl :
	public IVsSccProjectProviderBinding
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSccProjectProviderBindingNotImpl)

public:

	typedef IVsSccProjectProviderBinding Interface;

	STDMETHOD(GetProviderBinding)(
		/*[out,retval]*/ VSSCCPROVIDERBINDING* /*pvscpbBinding*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProviderService)(
		/*[out,retval]*/ GUID* /*pguidService*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProviderSession)(
		/*[out,retval]*/ IUnknown** /*punkSession*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(TranslateEnlistmentPath)(
		/*[in]*/ LPCOLESTR /*lpszPath*/,
		/*[out]*/ BOOL* /*pfAlternateIsDisplay*/,
		/*[out]*/ BSTR* /*pbstrAlternatePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProviderBindingOptions)(
		/*[out,retval]*/ VSSCCPROVIDERBINDINGOPTIONS* /*pvscpboOptions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ValidateServerPathEdit)(
		/*[in]*/ BOOL /*fQuick*/,
		/*[in]*/ LPCOLESTR /*lpszServerPath*/,
		/*[out,retval]*/ BOOL* /*pfValidServer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(BrowseServerPath)(
		/*[in]*/ LPCOLESTR /*lpszServerPath*/,
		/*[out,retval]*/ BSTR* /*pbstrNewServerPath*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSccProjectProviderBindingMockImpl :
	public IVsSccProjectProviderBinding,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSccProjectProviderBindingMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSccProjectProviderBindingMockImpl)

	typedef IVsSccProjectProviderBinding Interface;
	struct GetProviderBindingValidValues
	{
		/*[out,retval]*/ VSSCCPROVIDERBINDING* pvscpbBinding;
		HRESULT retValue;
	};

	STDMETHOD(GetProviderBinding)(
		/*[out,retval]*/ VSSCCPROVIDERBINDING* pvscpbBinding)
	{
		VSL_DEFINE_MOCK_METHOD(GetProviderBinding)

		VSL_SET_VALIDVALUE(pvscpbBinding);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProviderServiceValidValues
	{
		/*[out,retval]*/ GUID* pguidService;
		HRESULT retValue;
	};

	STDMETHOD(GetProviderService)(
		/*[out,retval]*/ GUID* pguidService)
	{
		VSL_DEFINE_MOCK_METHOD(GetProviderService)

		VSL_SET_VALIDVALUE(pguidService);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProviderSessionValidValues
	{
		/*[out,retval]*/ IUnknown** punkSession;
		HRESULT retValue;
	};

	STDMETHOD(GetProviderSession)(
		/*[out,retval]*/ IUnknown** punkSession)
	{
		VSL_DEFINE_MOCK_METHOD(GetProviderSession)

		VSL_SET_VALIDVALUE_INTERFACE(punkSession);

		VSL_RETURN_VALIDVALUES();
	}
	struct TranslateEnlistmentPathValidValues
	{
		/*[in]*/ LPCOLESTR lpszPath;
		/*[out]*/ BOOL* pfAlternateIsDisplay;
		/*[out]*/ BSTR* pbstrAlternatePath;
		HRESULT retValue;
	};

	STDMETHOD(TranslateEnlistmentPath)(
		/*[in]*/ LPCOLESTR lpszPath,
		/*[out]*/ BOOL* pfAlternateIsDisplay,
		/*[out]*/ BSTR* pbstrAlternatePath)
	{
		VSL_DEFINE_MOCK_METHOD(TranslateEnlistmentPath)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszPath);

		VSL_SET_VALIDVALUE(pfAlternateIsDisplay);

		VSL_SET_VALIDVALUE_BSTR(pbstrAlternatePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProviderBindingOptionsValidValues
	{
		/*[out,retval]*/ VSSCCPROVIDERBINDINGOPTIONS* pvscpboOptions;
		HRESULT retValue;
	};

	STDMETHOD(GetProviderBindingOptions)(
		/*[out,retval]*/ VSSCCPROVIDERBINDINGOPTIONS* pvscpboOptions)
	{
		VSL_DEFINE_MOCK_METHOD(GetProviderBindingOptions)

		VSL_SET_VALIDVALUE(pvscpboOptions);

		VSL_RETURN_VALIDVALUES();
	}
	struct ValidateServerPathEditValidValues
	{
		/*[in]*/ BOOL fQuick;
		/*[in]*/ LPCOLESTR lpszServerPath;
		/*[out,retval]*/ BOOL* pfValidServer;
		HRESULT retValue;
	};

	STDMETHOD(ValidateServerPathEdit)(
		/*[in]*/ BOOL fQuick,
		/*[in]*/ LPCOLESTR lpszServerPath,
		/*[out,retval]*/ BOOL* pfValidServer)
	{
		VSL_DEFINE_MOCK_METHOD(ValidateServerPathEdit)

		VSL_CHECK_VALIDVALUE(fQuick);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszServerPath);

		VSL_SET_VALIDVALUE(pfValidServer);

		VSL_RETURN_VALIDVALUES();
	}
	struct BrowseServerPathValidValues
	{
		/*[in]*/ LPCOLESTR lpszServerPath;
		/*[out,retval]*/ BSTR* pbstrNewServerPath;
		HRESULT retValue;
	};

	STDMETHOD(BrowseServerPath)(
		/*[in]*/ LPCOLESTR lpszServerPath,
		/*[out,retval]*/ BSTR* pbstrNewServerPath)
	{
		VSL_DEFINE_MOCK_METHOD(BrowseServerPath)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszServerPath);

		VSL_SET_VALIDVALUE_BSTR(pbstrNewServerPath);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSCCPROJECTPROVIDERBINDING_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSccProviderFactory.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSCCPROVIDERFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSCCPROVIDERFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "IVsSccProviderFactory.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSccProviderFactoryNotImpl :
	public IVsSccProviderFactory
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSccProviderFactoryNotImpl)

public:

	typedef IVsSccProviderFactory Interface;

	STDMETHOD(CreateProvider)(
		/*[in]*/ LPCOLESTR /*lpszProjectServerPath*/,
		/*[in]*/ LPCOLESTR /*lpszProjectLocalPath*/,
		/*[out,retval]*/ IUnknown** /*punkSession*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSccProviderFactoryMockImpl :
	public IVsSccProviderFactory,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSccProviderFactoryMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSccProviderFactoryMockImpl)

	typedef IVsSccProviderFactory Interface;
	struct CreateProviderValidValues
	{
		/*[in]*/ LPCOLESTR lpszProjectServerPath;
		/*[in]*/ LPCOLESTR lpszProjectLocalPath;
		/*[out,retval]*/ IUnknown** punkSession;
		HRESULT retValue;
	};

	STDMETHOD(CreateProvider)(
		/*[in]*/ LPCOLESTR lpszProjectServerPath,
		/*[in]*/ LPCOLESTR lpszProjectLocalPath,
		/*[out,retval]*/ IUnknown** punkSession)
	{
		VSL_DEFINE_MOCK_METHOD(CreateProvider)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszProjectServerPath);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszProjectLocalPath);

		VSL_SET_VALIDVALUE_INTERFACE(punkSession);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSCCPROVIDERFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSccProvider.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSCCPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSCCPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "IVsSccProvider.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSccProviderNotImpl :
	public IVsSccProvider
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSccProviderNotImpl)

public:

	typedef IVsSccProvider Interface;

	STDMETHOD(SetActive)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetInactive)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AnyItemsUnderSourceControl)(
		/*[out]*/ BOOL* /*pfResult*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSccProviderMockImpl :
	public IVsSccProvider,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSccProviderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSccProviderMockImpl)

	typedef IVsSccProvider Interface;
	struct SetActiveValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(SetActive)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(SetActive)

		VSL_RETURN_VALIDVALUES();
	}
	struct SetInactiveValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(SetInactive)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(SetInactive)

		VSL_RETURN_VALIDVALUES();
	}
	struct AnyItemsUnderSourceControlValidValues
	{
		/*[out]*/ BOOL* pfResult;
		HRESULT retValue;
	};

	STDMETHOD(AnyItemsUnderSourceControl)(
		/*[out]*/ BOOL* pfResult)
	{
		VSL_DEFINE_MOCK_METHOD(AnyItemsUnderSourceControl)

		VSL_SET_VALIDVALUE(pfResult);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSCCPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSelectedSymbol.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSELECTEDSYMBOL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSELECTEDSYMBOL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSelectedSymbolNotImpl :
	public IVsSelectedSymbol
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSelectedSymbolNotImpl)

public:

	typedef IVsSelectedSymbol Interface;

	STDMETHOD(GetNavInfo)(
		/*[out]*/ IVsNavInfo** /*ppNavInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetName)(
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSelectedSymbolMockImpl :
	public IVsSelectedSymbol,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSelectedSymbolMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSelectedSymbolMockImpl)

	typedef IVsSelectedSymbol Interface;
	struct GetNavInfoValidValues
	{
		/*[out]*/ IVsNavInfo** ppNavInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetNavInfo)(
		/*[out]*/ IVsNavInfo** ppNavInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetNavInfo)

		VSL_SET_VALIDVALUE_INTERFACE(ppNavInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNameValidValues
	{
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetName)(
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSELECTEDSYMBOL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSccToolsOptions.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSCCTOOLSOPTIONS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSCCTOOLSOPTIONS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "IVsSccToolsOptions.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSccToolsOptionsNotImpl :
	public IVsSccToolsOptions
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSccToolsOptionsNotImpl)

public:

	typedef IVsSccToolsOptions Interface;

	STDMETHOD(SetSccToolsOption)(
		/*[in]*/ SccToolsOptionsEnum /*sctoOptionToBeSet*/,
		/*[in]*/ VARIANT /*varValueToBeSet*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSccToolsOption)(
		/*[in]*/ SccToolsOptionsEnum /*sctoOptionToBeSet*/,
		/*[out,retval]*/ VARIANT* /*pvarValueToGet*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSccToolsOptionsMockImpl :
	public IVsSccToolsOptions,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSccToolsOptionsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSccToolsOptionsMockImpl)

	typedef IVsSccToolsOptions Interface;
	struct SetSccToolsOptionValidValues
	{
		/*[in]*/ SccToolsOptionsEnum sctoOptionToBeSet;
		/*[in]*/ VARIANT varValueToBeSet;
		HRESULT retValue;
	};

	STDMETHOD(SetSccToolsOption)(
		/*[in]*/ SccToolsOptionsEnum sctoOptionToBeSet,
		/*[in]*/ VARIANT varValueToBeSet)
	{
		VSL_DEFINE_MOCK_METHOD(SetSccToolsOption)

		VSL_CHECK_VALIDVALUE(sctoOptionToBeSet);

		VSL_CHECK_VALIDVALUE(varValueToBeSet);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSccToolsOptionValidValues
	{
		/*[in]*/ SccToolsOptionsEnum sctoOptionToBeSet;
		/*[out,retval]*/ VARIANT* pvarValueToGet;
		HRESULT retValue;
	};

	STDMETHOD(GetSccToolsOption)(
		/*[in]*/ SccToolsOptionsEnum sctoOptionToBeSet,
		/*[out,retval]*/ VARIANT* pvarValueToGet)
	{
		VSL_DEFINE_MOCK_METHOD(GetSccToolsOption)

		VSL_CHECK_VALIDVALUE(sctoOptionToBeSet);

		VSL_SET_VALIDVALUE_VARIANT(pvarValueToGet);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSCCTOOLSOPTIONS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSccVirtualFolders.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSCCVIRTUALFOLDERS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSCCVIRTUALFOLDERS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "IVsSccVirtualFolders.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSccVirtualFoldersNotImpl :
	public IVsSccVirtualFolders
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSccVirtualFoldersNotImpl)

public:

	typedef IVsSccVirtualFolders Interface;

	STDMETHOD(GetVirtualFolders)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[out]*/ CALPOLESTR* /*pCaStringsOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsItemChildOfVirtualFolder)(
		/*[in]*/ LPCOLESTR /*pszItemName*/,
		/*[out]*/ VARIANT_BOOL* /*pfResult*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSccVirtualFoldersMockImpl :
	public IVsSccVirtualFolders,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSccVirtualFoldersMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSccVirtualFoldersMockImpl)

	typedef IVsSccVirtualFolders Interface;
	struct GetVirtualFoldersValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[out]*/ CALPOLESTR* pCaStringsOut;
		HRESULT retValue;
	};

	STDMETHOD(GetVirtualFolders)(
		/*[in]*/ VSITEMID itemid,
		/*[out]*/ CALPOLESTR* pCaStringsOut)
	{
		VSL_DEFINE_MOCK_METHOD(GetVirtualFolders)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_SET_VALIDVALUE(pCaStringsOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsItemChildOfVirtualFolderValidValues
	{
		/*[in]*/ LPCOLESTR pszItemName;
		/*[out]*/ VARIANT_BOOL* pfResult;
		HRESULT retValue;
	};

	STDMETHOD(IsItemChildOfVirtualFolder)(
		/*[in]*/ LPCOLESTR pszItemName,
		/*[out]*/ VARIANT_BOOL* pfResult)
	{
		VSL_DEFINE_MOCK_METHOD(IsItemChildOfVirtualFolder)

		VSL_CHECK_VALIDVALUE_STRINGW(pszItemName);

		VSL_SET_VALIDVALUE(pfResult);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSCCVIRTUALFOLDERS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSelectedSymbols.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSELECTEDSYMBOLS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSELECTEDSYMBOLS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSelectedSymbolsNotImpl :
	public IVsSelectedSymbols
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSelectedSymbolsNotImpl)

public:

	typedef IVsSelectedSymbols Interface;

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* /*pcItems*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetItem)(
		/*[in]*/ ULONG /*iItem*/,
		/*[out]*/ IVsSelectedSymbol** /*ppIVsSelectedSymbol*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumSelectedSymbols)(
		/*[out]*/ IVsEnumSelectedSymbols** /*ppIVsEnumSelectedSymbols*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetItemTypes)(
		/*[out]*/ DWORD* /*pgrfTypes*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSelectedSymbolsMockImpl :
	public IVsSelectedSymbols,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSelectedSymbolsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSelectedSymbolsMockImpl)

	typedef IVsSelectedSymbols Interface;
	struct GetCountValidValues
	{
		/*[out]*/ ULONG* pcItems;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out]*/ ULONG* pcItems)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pcItems);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetItemValidValues
	{
		/*[in]*/ ULONG iItem;
		/*[out]*/ IVsSelectedSymbol** ppIVsSelectedSymbol;
		HRESULT retValue;
	};

	STDMETHOD(GetItem)(
		/*[in]*/ ULONG iItem,
		/*[out]*/ IVsSelectedSymbol** ppIVsSelectedSymbol)
	{
		VSL_DEFINE_MOCK_METHOD(GetItem)

		VSL_CHECK_VALIDVALUE(iItem);

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsSelectedSymbol);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumSelectedSymbolsValidValues
	{
		/*[out]*/ IVsEnumSelectedSymbols** ppIVsEnumSelectedSymbols;
		HRESULT retValue;
	};

	STDMETHOD(EnumSelectedSymbols)(
		/*[out]*/ IVsEnumSelectedSymbols** ppIVsEnumSelectedSymbols)
	{
		VSL_DEFINE_MOCK_METHOD(EnumSelectedSymbols)

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsEnumSelectedSymbols);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetItemTypesValidValues
	{
		/*[out]*/ DWORD* pgrfTypes;
		HRESULT retValue;
	};

	STDMETHOD(GetItemTypes)(
		/*[out]*/ DWORD* pgrfTypes)
	{
		VSL_DEFINE_MOCK_METHOD(GetItemTypes)

		VSL_SET_VALIDVALUE(pgrfTypes);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSELECTEDSYMBOLS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSelectionEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSELECTIONEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSELECTIONEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSelectionEventsNotImpl :
	public IVsSelectionEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSelectionEventsNotImpl)

public:

	typedef IVsSelectionEvents Interface;

	STDMETHOD(OnSelectionChanged)(
		/*[in]*/ IVsHierarchy* /*pHierOld*/,
		/*[in]*/ VSITEMID /*itemidOld*/,
		/*[in]*/ IVsMultiItemSelect* /*pMISOld*/,
		/*[in]*/ ISelectionContainer* /*pSCOld*/,
		/*[in]*/ IVsHierarchy* /*pHierNew*/,
		/*[in]*/ VSITEMID /*itemidNew*/,
		/*[in]*/ IVsMultiItemSelect* /*pMISNew*/,
		/*[in]*/ ISelectionContainer* /*pSCNew*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnElementValueChanged)(
		/*[in]*/ VSSELELEMID /*elementid*/,
		/*[in]*/ VARIANT /*varValueOld*/,
		/*[in]*/ VARIANT /*varValueNew*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnCmdUIContextChanged)(
		/*[in]*/ VSCOOKIE /*dwCmdUICookie*/,
		/*[in]*/ BOOL /*fActive*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSelectionEventsMockImpl :
	public IVsSelectionEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSelectionEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSelectionEventsMockImpl)

	typedef IVsSelectionEvents Interface;
	struct OnSelectionChangedValidValues
	{
		/*[in]*/ IVsHierarchy* pHierOld;
		/*[in]*/ VSITEMID itemidOld;
		/*[in]*/ IVsMultiItemSelect* pMISOld;
		/*[in]*/ ISelectionContainer* pSCOld;
		/*[in]*/ IVsHierarchy* pHierNew;
		/*[in]*/ VSITEMID itemidNew;
		/*[in]*/ IVsMultiItemSelect* pMISNew;
		/*[in]*/ ISelectionContainer* pSCNew;
		HRESULT retValue;
	};

	STDMETHOD(OnSelectionChanged)(
		/*[in]*/ IVsHierarchy* pHierOld,
		/*[in]*/ VSITEMID itemidOld,
		/*[in]*/ IVsMultiItemSelect* pMISOld,
		/*[in]*/ ISelectionContainer* pSCOld,
		/*[in]*/ IVsHierarchy* pHierNew,
		/*[in]*/ VSITEMID itemidNew,
		/*[in]*/ IVsMultiItemSelect* pMISNew,
		/*[in]*/ ISelectionContainer* pSCNew)
	{
		VSL_DEFINE_MOCK_METHOD(OnSelectionChanged)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierOld);

		VSL_CHECK_VALIDVALUE(itemidOld);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pMISOld);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSCOld);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierNew);

		VSL_CHECK_VALIDVALUE(itemidNew);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pMISNew);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSCNew);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnElementValueChangedValidValues
	{
		/*[in]*/ VSSELELEMID elementid;
		/*[in]*/ VARIANT varValueOld;
		/*[in]*/ VARIANT varValueNew;
		HRESULT retValue;
	};

	STDMETHOD(OnElementValueChanged)(
		/*[in]*/ VSSELELEMID elementid,
		/*[in]*/ VARIANT varValueOld,
		/*[in]*/ VARIANT varValueNew)
	{
		VSL_DEFINE_MOCK_METHOD(OnElementValueChanged)

		VSL_CHECK_VALIDVALUE(elementid);

		VSL_CHECK_VALIDVALUE(varValueOld);

		VSL_CHECK_VALIDVALUE(varValueNew);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnCmdUIContextChangedValidValues
	{
		/*[in]*/ VSCOOKIE dwCmdUICookie;
		/*[in]*/ BOOL fActive;
		HRESULT retValue;
	};

	STDMETHOD(OnCmdUIContextChanged)(
		/*[in]*/ VSCOOKIE dwCmdUICookie,
		/*[in]*/ BOOL fActive)
	{
		VSL_DEFINE_MOCK_METHOD(OnCmdUIContextChanged)

		VSL_CHECK_VALIDVALUE(dwCmdUICookie);

		VSL_CHECK_VALIDVALUE(fActive);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSELECTIONEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSetSpanMappingEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSETSPANMAPPINGEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSETSPANMAPPINGEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "singlefileeditor.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSetSpanMappingEventsNotImpl :
	public IVsSetSpanMappingEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSetSpanMappingEventsNotImpl)

public:

	typedef IVsSetSpanMappingEvents Interface;

	STDMETHOD(OnBeginSetSpanMappings)(
		/*[in]*/ long /*cSpans*/,
		/*[in,size_is(cSpans)]*/ NewSpanMapping* /*rgSpans*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnEndSetSpanMappings)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnMarkerInvalidated)(
		/*[in]*/ IVsTextLines* /*pBuffer*/,
		/*[in]*/ IVsTextMarker* /*pMarker*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSetSpanMappingEventsMockImpl :
	public IVsSetSpanMappingEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSetSpanMappingEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSetSpanMappingEventsMockImpl)

	typedef IVsSetSpanMappingEvents Interface;
	struct OnBeginSetSpanMappingsValidValues
	{
		/*[in]*/ long cSpans;
		/*[in,size_is(cSpans)]*/ NewSpanMapping* rgSpans;
		HRESULT retValue;
	};

	STDMETHOD(OnBeginSetSpanMappings)(
		/*[in]*/ long cSpans,
		/*[in,size_is(cSpans)]*/ NewSpanMapping* rgSpans)
	{
		VSL_DEFINE_MOCK_METHOD(OnBeginSetSpanMappings)

		VSL_CHECK_VALIDVALUE(cSpans);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgSpans, cSpans*sizeof(rgSpans[0]), validValues.cSpans*sizeof(validValues.rgSpans[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct OnEndSetSpanMappingsValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnEndSetSpanMappings)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnEndSetSpanMappings)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnMarkerInvalidatedValidValues
	{
		/*[in]*/ IVsTextLines* pBuffer;
		/*[in]*/ IVsTextMarker* pMarker;
		HRESULT retValue;
	};

	STDMETHOD(OnMarkerInvalidated)(
		/*[in]*/ IVsTextLines* pBuffer,
		/*[in]*/ IVsTextMarker* pMarker)
	{
		VSL_DEFINE_MOCK_METHOD(OnMarkerInvalidated)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pMarker);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSETSPANMAPPINGEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsShell2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSHELL2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSHELL2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsShell2NotImpl :
	public IVsShell2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsShell2NotImpl)

public:

	typedef IVsShell2 Interface;

	STDMETHOD(LoadPackageStringWithLCID)(
		/*[in]*/ REFGUID /*guidPackage*/,
		/*[in]*/ ULONG /*resid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,retval]*/ BSTR* /*pbstrOut*/)VSL_STDMETHOD_NOTIMPL
};

class IVsShell2MockImpl :
	public IVsShell2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsShell2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsShell2MockImpl)

	typedef IVsShell2 Interface;
	struct LoadPackageStringWithLCIDValidValues
	{
		/*[in]*/ REFGUID guidPackage;
		/*[in]*/ ULONG resid;
		/*[in]*/ LCID lcid;
		/*[out,retval]*/ BSTR* pbstrOut;
		HRESULT retValue;
	};

	STDMETHOD(LoadPackageStringWithLCID)(
		/*[in]*/ REFGUID guidPackage,
		/*[in]*/ ULONG resid,
		/*[in]*/ LCID lcid,
		/*[out,retval]*/ BSTR* pbstrOut)
	{
		VSL_DEFINE_MOCK_METHOD(LoadPackageStringWithLCID)

		VSL_CHECK_VALIDVALUE(guidPackage);

		VSL_CHECK_VALIDVALUE(resid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_BSTR(pbstrOut);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSHELL2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSettingsReader.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSETTINGSREADER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSETTINGSREADER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSettingsReaderNotImpl :
	public IVsSettingsReader
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSettingsReaderNotImpl)

public:

	typedef IVsSettingsReader Interface;

	STDMETHOD(ReadSettingString)(
		/*[in]*/ LPCOLESTR /*pszSettingName*/,
		/*[out,retval]*/ BSTR* /*pbstrSettingValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReadSettingLong)(
		/*[in]*/ LPCOLESTR /*pszSettingName*/,
		/*[out,retval]*/ long* /*plSettingValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReadSettingBoolean)(
		/*[in]*/ LPCOLESTR /*pszSettingName*/,
		/*[out,retval]*/ BOOL* /*pfSettingValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReadSettingBytes)(
		/*[in]*/ LPCOLESTR /*pszSettingName*/,
		/*[in,out]*/ BYTE* /*pSettingValue*/,
		/*[out]*/ long* /*plDataLength*/,
		/*[in]*/ long /*lDataMax*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReadSettingAttribute)(
		/*[in]*/ LPCOLESTR /*pszSettingName*/,
		/*[in]*/ LPCOLESTR /*pszAttributeName*/,
		/*[out,retval]*/ BSTR* /*pbstrSettingValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReadSettingXml)(
		/*[in]*/ LPCOLESTR /*pszSettingName*/,
		/*[out,retval]*/ IUnknown** /*ppIXMLDOMNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReadSettingXmlAsString)(
		/*[in]*/ LPCOLESTR /*pszSettingName*/,
		/*[out,retval]*/ BSTR* /*pbstrXML*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReadCategoryVersion)(
		/*[out]*/ int* /*pnMajor*/,
		/*[out]*/ int* /*pnMinor*/,
		/*[out]*/ int* /*pnBuild*/,
		/*[out]*/ int* /*pnRevision*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReadFileVersion)(
		/*[out]*/ int* /*pnMajor*/,
		/*[out]*/ int* /*pnMinor*/,
		/*[out]*/ int* /*pnBuild*/,
		/*[out]*/ int* /*pnRevision*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReportError)(
		/*[in]*/ LPCOLESTR /*pszError*/,
		/*[in]*/ VSSETTINGSERRORTYPES /*dwErrorType*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSettingsReaderMockImpl :
	public IVsSettingsReader,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSettingsReaderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSettingsReaderMockImpl)

	typedef IVsSettingsReader Interface;
	struct ReadSettingStringValidValues
	{
		/*[in]*/ LPCOLESTR pszSettingName;
		/*[out,retval]*/ BSTR* pbstrSettingValue;
		HRESULT retValue;
	};

	STDMETHOD(ReadSettingString)(
		/*[in]*/ LPCOLESTR pszSettingName,
		/*[out,retval]*/ BSTR* pbstrSettingValue)
	{
		VSL_DEFINE_MOCK_METHOD(ReadSettingString)

		VSL_CHECK_VALIDVALUE_STRINGW(pszSettingName);

		VSL_SET_VALIDVALUE_BSTR(pbstrSettingValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReadSettingLongValidValues
	{
		/*[in]*/ LPCOLESTR pszSettingName;
		/*[out,retval]*/ long* plSettingValue;
		HRESULT retValue;
	};

	STDMETHOD(ReadSettingLong)(
		/*[in]*/ LPCOLESTR pszSettingName,
		/*[out,retval]*/ long* plSettingValue)
	{
		VSL_DEFINE_MOCK_METHOD(ReadSettingLong)

		VSL_CHECK_VALIDVALUE_STRINGW(pszSettingName);

		VSL_SET_VALIDVALUE(plSettingValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReadSettingBooleanValidValues
	{
		/*[in]*/ LPCOLESTR pszSettingName;
		/*[out,retval]*/ BOOL* pfSettingValue;
		HRESULT retValue;
	};

	STDMETHOD(ReadSettingBoolean)(
		/*[in]*/ LPCOLESTR pszSettingName,
		/*[out,retval]*/ BOOL* pfSettingValue)
	{
		VSL_DEFINE_MOCK_METHOD(ReadSettingBoolean)

		VSL_CHECK_VALIDVALUE_STRINGW(pszSettingName);

		VSL_SET_VALIDVALUE(pfSettingValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReadSettingBytesValidValues
	{
		/*[in]*/ LPCOLESTR pszSettingName;
		/*[in,out]*/ BYTE* pSettingValue;
		/*[out]*/ long* plDataLength;
		/*[in]*/ long lDataMax;
		HRESULT retValue;
	};

	STDMETHOD(ReadSettingBytes)(
		/*[in]*/ LPCOLESTR pszSettingName,
		/*[in,out]*/ BYTE* pSettingValue,
		/*[out]*/ long* plDataLength,
		/*[in]*/ long lDataMax)
	{
		VSL_DEFINE_MOCK_METHOD(ReadSettingBytes)

		VSL_CHECK_VALIDVALUE_STRINGW(pszSettingName);

		VSL_SET_VALIDVALUE(pSettingValue);

		VSL_SET_VALIDVALUE(plDataLength);

		VSL_CHECK_VALIDVALUE(lDataMax);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReadSettingAttributeValidValues
	{
		/*[in]*/ LPCOLESTR pszSettingName;
		/*[in]*/ LPCOLESTR pszAttributeName;
		/*[out,retval]*/ BSTR* pbstrSettingValue;
		HRESULT retValue;
	};

	STDMETHOD(ReadSettingAttribute)(
		/*[in]*/ LPCOLESTR pszSettingName,
		/*[in]*/ LPCOLESTR pszAttributeName,
		/*[out,retval]*/ BSTR* pbstrSettingValue)
	{
		VSL_DEFINE_MOCK_METHOD(ReadSettingAttribute)

		VSL_CHECK_VALIDVALUE_STRINGW(pszSettingName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszAttributeName);

		VSL_SET_VALIDVALUE_BSTR(pbstrSettingValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReadSettingXmlValidValues
	{
		/*[in]*/ LPCOLESTR pszSettingName;
		/*[out,retval]*/ IUnknown** ppIXMLDOMNode;
		HRESULT retValue;
	};

	STDMETHOD(ReadSettingXml)(
		/*[in]*/ LPCOLESTR pszSettingName,
		/*[out,retval]*/ IUnknown** ppIXMLDOMNode)
	{
		VSL_DEFINE_MOCK_METHOD(ReadSettingXml)

		VSL_CHECK_VALIDVALUE_STRINGW(pszSettingName);

		VSL_SET_VALIDVALUE_INTERFACE(ppIXMLDOMNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReadSettingXmlAsStringValidValues
	{
		/*[in]*/ LPCOLESTR pszSettingName;
		/*[out,retval]*/ BSTR* pbstrXML;
		HRESULT retValue;
	};

	STDMETHOD(ReadSettingXmlAsString)(
		/*[in]*/ LPCOLESTR pszSettingName,
		/*[out,retval]*/ BSTR* pbstrXML)
	{
		VSL_DEFINE_MOCK_METHOD(ReadSettingXmlAsString)

		VSL_CHECK_VALIDVALUE_STRINGW(pszSettingName);

		VSL_SET_VALIDVALUE_BSTR(pbstrXML);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReadCategoryVersionValidValues
	{
		/*[out]*/ int* pnMajor;
		/*[out]*/ int* pnMinor;
		/*[out]*/ int* pnBuild;
		/*[out]*/ int* pnRevision;
		HRESULT retValue;
	};

	STDMETHOD(ReadCategoryVersion)(
		/*[out]*/ int* pnMajor,
		/*[out]*/ int* pnMinor,
		/*[out]*/ int* pnBuild,
		/*[out]*/ int* pnRevision)
	{
		VSL_DEFINE_MOCK_METHOD(ReadCategoryVersion)

		VSL_SET_VALIDVALUE(pnMajor);

		VSL_SET_VALIDVALUE(pnMinor);

		VSL_SET_VALIDVALUE(pnBuild);

		VSL_SET_VALIDVALUE(pnRevision);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReadFileVersionValidValues
	{
		/*[out]*/ int* pnMajor;
		/*[out]*/ int* pnMinor;
		/*[out]*/ int* pnBuild;
		/*[out]*/ int* pnRevision;
		HRESULT retValue;
	};

	STDMETHOD(ReadFileVersion)(
		/*[out]*/ int* pnMajor,
		/*[out]*/ int* pnMinor,
		/*[out]*/ int* pnBuild,
		/*[out]*/ int* pnRevision)
	{
		VSL_DEFINE_MOCK_METHOD(ReadFileVersion)

		VSL_SET_VALIDVALUE(pnMajor);

		VSL_SET_VALIDVALUE(pnMinor);

		VSL_SET_VALIDVALUE(pnBuild);

		VSL_SET_VALIDVALUE(pnRevision);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReportErrorValidValues
	{
		/*[in]*/ LPCOLESTR pszError;
		/*[in]*/ VSSETTINGSERRORTYPES dwErrorType;
		HRESULT retValue;
	};

	STDMETHOD(ReportError)(
		/*[in]*/ LPCOLESTR pszError,
		/*[in]*/ VSSETTINGSERRORTYPES dwErrorType)
	{
		VSL_DEFINE_MOCK_METHOD(ReportError)

		VSL_CHECK_VALIDVALUE_STRINGW(pszError);

		VSL_CHECK_VALIDVALUE(dwErrorType);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSETTINGSREADER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSettingsErrorInformation.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSETTINGSERRORINFORMATION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSETTINGSERRORINFORMATION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSettingsErrorInformationNotImpl :
	public IVsSettingsErrorInformation
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSettingsErrorInformationNotImpl)

public:

	typedef IVsSettingsErrorInformation Interface;

	STDMETHOD(GetCompletionStatus)(
		/*[out,retval]*/ VSSETTINGSCOMPLETIONSTATUS* /*pdwCompletionStatus*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetErrorCount)(
		/*[out,retval]*/ int* /*pnErrors*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetErrorInfo)(
		/*[in]*/ int /*nErrorIndex*/,
		/*[out]*/ VSSETTINGSERRORTYPES* /*pdwErrorType*/,
		/*[out]*/ BSTR* /*pbstrError*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSettingsErrorInformationMockImpl :
	public IVsSettingsErrorInformation,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSettingsErrorInformationMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSettingsErrorInformationMockImpl)

	typedef IVsSettingsErrorInformation Interface;
	struct GetCompletionStatusValidValues
	{
		/*[out,retval]*/ VSSETTINGSCOMPLETIONSTATUS* pdwCompletionStatus;
		HRESULT retValue;
	};

	STDMETHOD(GetCompletionStatus)(
		/*[out,retval]*/ VSSETTINGSCOMPLETIONSTATUS* pdwCompletionStatus)
	{
		VSL_DEFINE_MOCK_METHOD(GetCompletionStatus)

		VSL_SET_VALIDVALUE(pdwCompletionStatus);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetErrorCountValidValues
	{
		/*[out,retval]*/ int* pnErrors;
		HRESULT retValue;
	};

	STDMETHOD(GetErrorCount)(
		/*[out,retval]*/ int* pnErrors)
	{
		VSL_DEFINE_MOCK_METHOD(GetErrorCount)

		VSL_SET_VALIDVALUE(pnErrors);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetErrorInfoValidValues
	{
		/*[in]*/ int nErrorIndex;
		/*[out]*/ VSSETTINGSERRORTYPES* pdwErrorType;
		/*[out]*/ BSTR* pbstrError;
		HRESULT retValue;
	};

	STDMETHOD(GetErrorInfo)(
		/*[in]*/ int nErrorIndex,
		/*[out]*/ VSSETTINGSERRORTYPES* pdwErrorType,
		/*[out]*/ BSTR* pbstrError)
	{
		VSL_DEFINE_MOCK_METHOD(GetErrorInfo)

		VSL_CHECK_VALIDVALUE(nErrorIndex);

		VSL_SET_VALIDVALUE(pdwErrorType);

		VSL_SET_VALIDVALUE_BSTR(pbstrError);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSETTINGSERRORINFORMATION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSettingsWriter.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSETTINGSWRITER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSETTINGSWRITER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSettingsWriterNotImpl :
	public IVsSettingsWriter
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSettingsWriterNotImpl)

public:

	typedef IVsSettingsWriter Interface;

	STDMETHOD(WriteSettingString)(
		/*[in]*/ LPCOLESTR /*pszSettingName*/,
		/*[in]*/ LPCOLESTR /*pszSettingValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(WriteSettingLong)(
		/*[in]*/ LPCOLESTR /*pszSettingName*/,
		/*[in]*/ long /*lSettingValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(WriteSettingBoolean)(
		/*[in]*/ LPCOLESTR /*pszSettingName*/,
		/*[in]*/ BOOL /*fSettingValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(WriteSettingBytes)(
		/*[in]*/ LPCOLESTR /*pszSettingName*/,
		/*[in,size_is(lDataLength)]*/ BYTE* /*pSettingValue*/,
		/*[in]*/ long /*lDataLength*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(WriteSettingAttribute)(
		/*[in]*/ LPCOLESTR /*pszSettingName*/,
		/*[in]*/ LPCOLESTR /*pszAttributeName*/,
		/*[in]*/ LPCOLESTR /*pszSettingValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(WriteSettingXml)(
		/*[in]*/ IUnknown* /*pIXMLDOMNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(WriteSettingXmlFromString)(
		/*[in]*/ LPCOLESTR /*szXML*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(WriteCategoryVersion)(
		/*[in]*/ int /*nMajor*/,
		/*[in]*/ int /*nMinor*/,
		/*[in]*/ int /*nBuild*/,
		/*[in]*/ int /*nRevision*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReportError)(
		/*[in]*/ LPCOLESTR /*pszError*/,
		/*[in]*/ VSSETTINGSERRORTYPES /*dwErrorType*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSettingsWriterMockImpl :
	public IVsSettingsWriter,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSettingsWriterMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSettingsWriterMockImpl)

	typedef IVsSettingsWriter Interface;
	struct WriteSettingStringValidValues
	{
		/*[in]*/ LPCOLESTR pszSettingName;
		/*[in]*/ LPCOLESTR pszSettingValue;
		HRESULT retValue;
	};

	STDMETHOD(WriteSettingString)(
		/*[in]*/ LPCOLESTR pszSettingName,
		/*[in]*/ LPCOLESTR pszSettingValue)
	{
		VSL_DEFINE_MOCK_METHOD(WriteSettingString)

		VSL_CHECK_VALIDVALUE_STRINGW(pszSettingName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszSettingValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct WriteSettingLongValidValues
	{
		/*[in]*/ LPCOLESTR pszSettingName;
		/*[in]*/ long lSettingValue;
		HRESULT retValue;
	};

	STDMETHOD(WriteSettingLong)(
		/*[in]*/ LPCOLESTR pszSettingName,
		/*[in]*/ long lSettingValue)
	{
		VSL_DEFINE_MOCK_METHOD(WriteSettingLong)

		VSL_CHECK_VALIDVALUE_STRINGW(pszSettingName);

		VSL_CHECK_VALIDVALUE(lSettingValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct WriteSettingBooleanValidValues
	{
		/*[in]*/ LPCOLESTR pszSettingName;
		/*[in]*/ BOOL fSettingValue;
		HRESULT retValue;
	};

	STDMETHOD(WriteSettingBoolean)(
		/*[in]*/ LPCOLESTR pszSettingName,
		/*[in]*/ BOOL fSettingValue)
	{
		VSL_DEFINE_MOCK_METHOD(WriteSettingBoolean)

		VSL_CHECK_VALIDVALUE_STRINGW(pszSettingName);

		VSL_CHECK_VALIDVALUE(fSettingValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct WriteSettingBytesValidValues
	{
		/*[in]*/ LPCOLESTR pszSettingName;
		/*[in,size_is(lDataLength)]*/ BYTE* pSettingValue;
		/*[in]*/ long lDataLength;
		HRESULT retValue;
	};

	STDMETHOD(WriteSettingBytes)(
		/*[in]*/ LPCOLESTR pszSettingName,
		/*[in,size_is(lDataLength)]*/ BYTE* pSettingValue,
		/*[in]*/ long lDataLength)
	{
		VSL_DEFINE_MOCK_METHOD(WriteSettingBytes)

		VSL_CHECK_VALIDVALUE_STRINGW(pszSettingName);

		VSL_CHECK_VALIDVALUE_MEMCMP(pSettingValue, lDataLength*sizeof(pSettingValue[0]), validValues.lDataLength*sizeof(validValues.pSettingValue[0]));

		VSL_CHECK_VALIDVALUE(lDataLength);

		VSL_RETURN_VALIDVALUES();
	}
	struct WriteSettingAttributeValidValues
	{
		/*[in]*/ LPCOLESTR pszSettingName;
		/*[in]*/ LPCOLESTR pszAttributeName;
		/*[in]*/ LPCOLESTR pszSettingValue;
		HRESULT retValue;
	};

	STDMETHOD(WriteSettingAttribute)(
		/*[in]*/ LPCOLESTR pszSettingName,
		/*[in]*/ LPCOLESTR pszAttributeName,
		/*[in]*/ LPCOLESTR pszSettingValue)
	{
		VSL_DEFINE_MOCK_METHOD(WriteSettingAttribute)

		VSL_CHECK_VALIDVALUE_STRINGW(pszSettingName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszAttributeName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszSettingValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct WriteSettingXmlValidValues
	{
		/*[in]*/ IUnknown* pIXMLDOMNode;
		HRESULT retValue;
	};

	STDMETHOD(WriteSettingXml)(
		/*[in]*/ IUnknown* pIXMLDOMNode)
	{
		VSL_DEFINE_MOCK_METHOD(WriteSettingXml)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIXMLDOMNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct WriteSettingXmlFromStringValidValues
	{
		/*[in]*/ LPCOLESTR szXML;
		HRESULT retValue;
	};

	STDMETHOD(WriteSettingXmlFromString)(
		/*[in]*/ LPCOLESTR szXML)
	{
		VSL_DEFINE_MOCK_METHOD(WriteSettingXmlFromString)

		VSL_CHECK_VALIDVALUE_STRINGW(szXML);

		VSL_RETURN_VALIDVALUES();
	}
	struct WriteCategoryVersionValidValues
	{
		/*[in]*/ int nMajor;
		/*[in]*/ int nMinor;
		/*[in]*/ int nBuild;
		/*[in]*/ int nRevision;
		HRESULT retValue;
	};

	STDMETHOD(WriteCategoryVersion)(
		/*[in]*/ int nMajor,
		/*[in]*/ int nMinor,
		/*[in]*/ int nBuild,
		/*[in]*/ int nRevision)
	{
		VSL_DEFINE_MOCK_METHOD(WriteCategoryVersion)

		VSL_CHECK_VALIDVALUE(nMajor);

		VSL_CHECK_VALIDVALUE(nMinor);

		VSL_CHECK_VALIDVALUE(nBuild);

		VSL_CHECK_VALIDVALUE(nRevision);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReportErrorValidValues
	{
		/*[in]*/ LPCOLESTR pszError;
		/*[in]*/ VSSETTINGSERRORTYPES dwErrorType;
		HRESULT retValue;
	};

	STDMETHOD(ReportError)(
		/*[in]*/ LPCOLESTR pszError,
		/*[in]*/ VSSETTINGSERRORTYPES dwErrorType)
	{
		VSL_DEFINE_MOCK_METHOD(ReportError)

		VSL_CHECK_VALIDVALUE_STRINGW(pszError);

		VSL_CHECK_VALIDVALUE(dwErrorType);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSETTINGSWRITER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsShortcutManager.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSHORTCUTMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSHORTCUTMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsShortcutManagerNotImpl :
	public IVsShortcutManager
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsShortcutManagerNotImpl)

public:

	typedef IVsShortcutManager Interface;

	STDMETHOD(CreateItem)(
		/*[in]*/ long /*iShortcutLine*/,
		/*[in]*/ IVsTextLines* /*pBuffer*/,
		/*[in]*/ LPCOLESTR /*pszBufMoniker*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveItem)(
		/*[in]*/ IVsTextLineMarker* /*pMarker*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(WriteUserOptions)(
		/*[in]*/ IStream* /*pOptionsStream*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReadUserOptions)(
		/*[in]*/ IStream* /*pOptionsStream*/)VSL_STDMETHOD_NOTIMPL
};

class IVsShortcutManagerMockImpl :
	public IVsShortcutManager,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsShortcutManagerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsShortcutManagerMockImpl)

	typedef IVsShortcutManager Interface;
	struct CreateItemValidValues
	{
		/*[in]*/ long iShortcutLine;
		/*[in]*/ IVsTextLines* pBuffer;
		/*[in]*/ LPCOLESTR pszBufMoniker;
		HRESULT retValue;
	};

	STDMETHOD(CreateItem)(
		/*[in]*/ long iShortcutLine,
		/*[in]*/ IVsTextLines* pBuffer,
		/*[in]*/ LPCOLESTR pszBufMoniker)
	{
		VSL_DEFINE_MOCK_METHOD(CreateItem)

		VSL_CHECK_VALIDVALUE(iShortcutLine);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_CHECK_VALIDVALUE_STRINGW(pszBufMoniker);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveItemValidValues
	{
		/*[in]*/ IVsTextLineMarker* pMarker;
		HRESULT retValue;
	};

	STDMETHOD(RemoveItem)(
		/*[in]*/ IVsTextLineMarker* pMarker)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveItem)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pMarker);

		VSL_RETURN_VALIDVALUES();
	}
	struct WriteUserOptionsValidValues
	{
		/*[in]*/ IStream* pOptionsStream;
		HRESULT retValue;
	};

	STDMETHOD(WriteUserOptions)(
		/*[in]*/ IStream* pOptionsStream)
	{
		VSL_DEFINE_MOCK_METHOD(WriteUserOptions)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pOptionsStream);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReadUserOptionsValidValues
	{
		/*[in]*/ IStream* pOptionsStream;
		HRESULT retValue;
	};

	STDMETHOD(ReadUserOptions)(
		/*[in]*/ IStream* pOptionsStream)
	{
		VSL_DEFINE_MOCK_METHOD(ReadUserOptions)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pOptionsStream);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSHORTCUTMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsShell.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSHELL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSHELL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsShellNotImpl :
	public IVsShell
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsShellNotImpl)

public:

	typedef IVsShell Interface;

	STDMETHOD(GetPackageEnum)(
		/*[out]*/ IEnumPackages** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProperty)(
		/*[in]*/ VSSPROPID /*propid*/,
		/*[out]*/ VARIANT* /*pvar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetProperty)(
		/*[in]*/ VSSPROPID /*propid*/,
		/*[in]*/ VARIANT /*var*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AdviseBroadcastMessages)(
		/*[in]*/ IVsBroadcastMessageEvents* /*pSink*/,
		/*[out]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseBroadcastMessages)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AdviseShellPropertyChanges)(
		/*[in]*/ IVsShellPropertyEvents* /*pSink*/,
		/*[out]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseShellPropertyChanges)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LoadPackage)(
		/*[in]*/ REFGUID /*guidPackage*/,
		/*[out,retval]*/ IVsPackage** /*ppPackage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LoadPackageString)(
		/*[in]*/ REFGUID /*guidPackage*/,
		/*[in]*/ ULONG /*resid*/,
		/*[out,retval]*/ BSTR* /*pbstrOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LoadUILibrary)(
		/*[in]*/ REFGUID /*guidPackage*/,
		/*[in]*/ DWORD /*dwExFlags*/,
		/*[out,retval]*/ DWORD_PTR* /*phinstOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsPackageInstalled)(
		/*[in]*/ REFGUID /*guidPackage*/,
		/*[out,retval]*/ BOOL* /*pfInstalled*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsPackageLoaded)(
		/*[in]*/ REFGUID /*guidPackage*/,
		/*[out,retval]*/ IVsPackage** /*ppPackage*/)VSL_STDMETHOD_NOTIMPL
};

class IVsShellMockImpl :
	public IVsShell,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsShellMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsShellMockImpl)

	typedef IVsShell Interface;
	struct GetPackageEnumValidValues
	{
		/*[out]*/ IEnumPackages** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(GetPackageEnum)(
		/*[out]*/ IEnumPackages** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(GetPackageEnum)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPropertyValidValues
	{
		/*[in]*/ VSSPROPID propid;
		/*[out]*/ VARIANT* pvar;
		HRESULT retValue;
	};

	STDMETHOD(GetProperty)(
		/*[in]*/ VSSPROPID propid,
		/*[out]*/ VARIANT* pvar)
	{
		VSL_DEFINE_MOCK_METHOD(GetProperty)

		VSL_CHECK_VALIDVALUE(propid);

		VSL_SET_VALIDVALUE_VARIANT(pvar);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetPropertyValidValues
	{
		/*[in]*/ VSSPROPID propid;
		/*[in]*/ VARIANT var;
		HRESULT retValue;
	};

	STDMETHOD(SetProperty)(
		/*[in]*/ VSSPROPID propid,
		/*[in]*/ VARIANT var)
	{
		VSL_DEFINE_MOCK_METHOD(SetProperty)

		VSL_CHECK_VALIDVALUE(propid);

		VSL_CHECK_VALIDVALUE(var);

		VSL_RETURN_VALIDVALUES();
	}
	struct AdviseBroadcastMessagesValidValues
	{
		/*[in]*/ IVsBroadcastMessageEvents* pSink;
		/*[out]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(AdviseBroadcastMessages)(
		/*[in]*/ IVsBroadcastMessageEvents* pSink,
		/*[out]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(AdviseBroadcastMessages)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSink);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseBroadcastMessagesValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnadviseBroadcastMessages)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnadviseBroadcastMessages)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct AdviseShellPropertyChangesValidValues
	{
		/*[in]*/ IVsShellPropertyEvents* pSink;
		/*[out]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(AdviseShellPropertyChanges)(
		/*[in]*/ IVsShellPropertyEvents* pSink,
		/*[out]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(AdviseShellPropertyChanges)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSink);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseShellPropertyChangesValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnadviseShellPropertyChanges)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnadviseShellPropertyChanges)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadPackageValidValues
	{
		/*[in]*/ REFGUID guidPackage;
		/*[out,retval]*/ IVsPackage** ppPackage;
		HRESULT retValue;
	};

	STDMETHOD(LoadPackage)(
		/*[in]*/ REFGUID guidPackage,
		/*[out,retval]*/ IVsPackage** ppPackage)
	{
		VSL_DEFINE_MOCK_METHOD(LoadPackage)

		VSL_CHECK_VALIDVALUE(guidPackage);

		VSL_SET_VALIDVALUE_INTERFACE(ppPackage);

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadPackageStringValidValues
	{
		/*[in]*/ REFGUID guidPackage;
		/*[in]*/ ULONG resid;
		/*[out,retval]*/ BSTR* pbstrOut;
		HRESULT retValue;
	};

	STDMETHOD(LoadPackageString)(
		/*[in]*/ REFGUID guidPackage,
		/*[in]*/ ULONG resid,
		/*[out,retval]*/ BSTR* pbstrOut)
	{
		VSL_DEFINE_MOCK_METHOD(LoadPackageString)

		VSL_CHECK_VALIDVALUE(guidPackage);

		VSL_CHECK_VALIDVALUE(resid);

		VSL_SET_VALIDVALUE_BSTR(pbstrOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadUILibraryValidValues
	{
		/*[in]*/ REFGUID guidPackage;
		/*[in]*/ DWORD dwExFlags;
		/*[out,retval]*/ DWORD_PTR* phinstOut;
		HRESULT retValue;
	};

	STDMETHOD(LoadUILibrary)(
		/*[in]*/ REFGUID guidPackage,
		/*[in]*/ DWORD dwExFlags,
		/*[out,retval]*/ DWORD_PTR* phinstOut)
	{
		VSL_DEFINE_MOCK_METHOD(LoadUILibrary)

		VSL_CHECK_VALIDVALUE(guidPackage);

		VSL_CHECK_VALIDVALUE(dwExFlags);

		VSL_SET_VALIDVALUE(phinstOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsPackageInstalledValidValues
	{
		/*[in]*/ REFGUID guidPackage;
		/*[out,retval]*/ BOOL* pfInstalled;
		HRESULT retValue;
	};

	STDMETHOD(IsPackageInstalled)(
		/*[in]*/ REFGUID guidPackage,
		/*[out,retval]*/ BOOL* pfInstalled)
	{
		VSL_DEFINE_MOCK_METHOD(IsPackageInstalled)

		VSL_CHECK_VALIDVALUE(guidPackage);

		VSL_SET_VALIDVALUE(pfInstalled);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsPackageLoadedValidValues
	{
		/*[in]*/ REFGUID guidPackage;
		/*[out,retval]*/ IVsPackage** ppPackage;
		HRESULT retValue;
	};

	STDMETHOD(IsPackageLoaded)(
		/*[in]*/ REFGUID guidPackage,
		/*[out,retval]*/ IVsPackage** ppPackage)
	{
		VSL_DEFINE_MOCK_METHOD(IsPackageLoaded)

		VSL_CHECK_VALIDVALUE(guidPackage);

		VSL_SET_VALIDVALUE_INTERFACE(ppPackage);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSHELL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSimpleBrowseComponentSet.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSIMPLEBROWSECOMPONENTSET_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSIMPLEBROWSECOMPONENTSET_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSimpleBrowseComponentSetNotImpl :
	public IVsSimpleBrowseComponentSet
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSimpleBrowseComponentSetNotImpl)

public:

	typedef IVsSimpleBrowseComponentSet Interface;

	STDMETHOD(put_RootNavInfo)(
		/*[in]*/ IVsNavInfo* /*pRootNavInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RootNavInfo)(
		/*[out,retval]*/ IVsNavInfo** /*pRootNavInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Owner)(
		/*[in]*/ IUnknown* /*pOwner*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Owner)(
		/*[out,retval]*/ IUnknown** /*ppOwner*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FindComponent)(
		/*[in]*/ REFGUID /*guidLib*/,
		/*[in]*/ VSCOMPONENTSELECTORDATA* /*pcsdComponent*/,
		/*[out]*/ IVsNavInfo** /*ppRealLibNavInfo*/,
		/*[out]*/ VSCOMPONENTSELECTORDATA* /*pcsdExistingComponent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddComponent)(
		/*[in]*/ REFGUID /*guidLib*/,
		/*[in]*/ VSCOMPONENTSELECTORDATA* /*pcsdComponent*/,
		/*[out]*/ IVsNavInfo** /*ppRealLibNavInfo*/,
		/*[out]*/ VSCOMPONENTSELECTORDATA* /*pcsdAddedComponent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveComponent)(
		/*[in]*/ IVsNavInfo* /*pRealLibNavInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveAllComponents)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_ComponentsListOptions)(
		/*[in]*/ BROWSE_COMPONENT_SET_OPTIONS /*dwOptions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ComponentsListOptions)(
		/*[out,retval]*/ BROWSE_COMPONENT_SET_OPTIONS* /*pdwOptions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_ChildListOptions)(
		/*[in]*/ BROWSE_COMPONENT_SET_OPTIONS /*dwOptions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ChildListOptions)(
		/*[out,retval]*/ BROWSE_COMPONENT_SET_OPTIONS* /*pdwOptions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetList2)(
		/*[in]*/ LIB_LISTTYPE2 /*ListType*/,
		/*[in]*/ LIB_LISTFLAGS /*Flags*/,
		/*[in]*/ VSOBSEARCHCRITERIA2* /*pobSrch*/,
		/*[in]*/ IVsObjectList2* /*pExtraListToCombineWith*/,
		/*[out,retval]*/ IVsObjectList2** /*ppIVsObjectList2*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSupportedCategoryFields2)(
		/*[in]*/ LIB_CATEGORY2 /*Category*/,
		/*[out,retval]*/ DWORD* /*pgrfCatField*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateNavInfo)(
		/*[in]*/ REFGUID /*guidLib*/,
		/*[in,size_is(ulcNodes)]*/ SYMBOL_DESCRIPTION_NODE[] /*rgSymbolNodes*/,
		/*[in]*/ ULONG /*ulcNodes*/,
		/*[out,retval]*/ IVsNavInfo** /*ppNavInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateCounter)(
		/*[out]*/ ULONG* /*pCurUpdate*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSimpleBrowseComponentSetMockImpl :
	public IVsSimpleBrowseComponentSet,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSimpleBrowseComponentSetMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSimpleBrowseComponentSetMockImpl)

	typedef IVsSimpleBrowseComponentSet Interface;
	struct put_RootNavInfoValidValues
	{
		/*[in]*/ IVsNavInfo* pRootNavInfo;
		HRESULT retValue;
	};

	STDMETHOD(put_RootNavInfo)(
		/*[in]*/ IVsNavInfo* pRootNavInfo)
	{
		VSL_DEFINE_MOCK_METHOD(put_RootNavInfo)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pRootNavInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RootNavInfoValidValues
	{
		/*[out,retval]*/ IVsNavInfo** pRootNavInfo;
		HRESULT retValue;
	};

	STDMETHOD(get_RootNavInfo)(
		/*[out,retval]*/ IVsNavInfo** pRootNavInfo)
	{
		VSL_DEFINE_MOCK_METHOD(get_RootNavInfo)

		VSL_SET_VALIDVALUE_INTERFACE(pRootNavInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_OwnerValidValues
	{
		/*[in]*/ IUnknown* pOwner;
		HRESULT retValue;
	};

	STDMETHOD(put_Owner)(
		/*[in]*/ IUnknown* pOwner)
	{
		VSL_DEFINE_MOCK_METHOD(put_Owner)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pOwner);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OwnerValidValues
	{
		/*[out,retval]*/ IUnknown** ppOwner;
		HRESULT retValue;
	};

	STDMETHOD(get_Owner)(
		/*[out,retval]*/ IUnknown** ppOwner)
	{
		VSL_DEFINE_MOCK_METHOD(get_Owner)

		VSL_SET_VALIDVALUE_INTERFACE(ppOwner);

		VSL_RETURN_VALIDVALUES();
	}
	struct FindComponentValidValues
	{
		/*[in]*/ REFGUID guidLib;
		/*[in]*/ VSCOMPONENTSELECTORDATA* pcsdComponent;
		/*[out]*/ IVsNavInfo** ppRealLibNavInfo;
		/*[out]*/ VSCOMPONENTSELECTORDATA* pcsdExistingComponent;
		HRESULT retValue;
	};

	STDMETHOD(FindComponent)(
		/*[in]*/ REFGUID guidLib,
		/*[in]*/ VSCOMPONENTSELECTORDATA* pcsdComponent,
		/*[out]*/ IVsNavInfo** ppRealLibNavInfo,
		/*[out]*/ VSCOMPONENTSELECTORDATA* pcsdExistingComponent)
	{
		VSL_DEFINE_MOCK_METHOD(FindComponent)

		VSL_CHECK_VALIDVALUE(guidLib);

		VSL_CHECK_VALIDVALUE_POINTER(pcsdComponent);

		VSL_SET_VALIDVALUE_INTERFACE(ppRealLibNavInfo);

		VSL_SET_VALIDVALUE(pcsdExistingComponent);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddComponentValidValues
	{
		/*[in]*/ REFGUID guidLib;
		/*[in]*/ VSCOMPONENTSELECTORDATA* pcsdComponent;
		/*[out]*/ IVsNavInfo** ppRealLibNavInfo;
		/*[out]*/ VSCOMPONENTSELECTORDATA* pcsdAddedComponent;
		HRESULT retValue;
	};

	STDMETHOD(AddComponent)(
		/*[in]*/ REFGUID guidLib,
		/*[in]*/ VSCOMPONENTSELECTORDATA* pcsdComponent,
		/*[out]*/ IVsNavInfo** ppRealLibNavInfo,
		/*[out]*/ VSCOMPONENTSELECTORDATA* pcsdAddedComponent)
	{
		VSL_DEFINE_MOCK_METHOD(AddComponent)

		VSL_CHECK_VALIDVALUE(guidLib);

		VSL_CHECK_VALIDVALUE_POINTER(pcsdComponent);

		VSL_SET_VALIDVALUE_INTERFACE(ppRealLibNavInfo);

		VSL_SET_VALIDVALUE(pcsdAddedComponent);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveComponentValidValues
	{
		/*[in]*/ IVsNavInfo* pRealLibNavInfo;
		HRESULT retValue;
	};

	STDMETHOD(RemoveComponent)(
		/*[in]*/ IVsNavInfo* pRealLibNavInfo)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveComponent)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pRealLibNavInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveAllComponentsValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(RemoveAllComponents)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(RemoveAllComponents)

		VSL_RETURN_VALIDVALUES();
	}
	struct put_ComponentsListOptionsValidValues
	{
		/*[in]*/ BROWSE_COMPONENT_SET_OPTIONS dwOptions;
		HRESULT retValue;
	};

	STDMETHOD(put_ComponentsListOptions)(
		/*[in]*/ BROWSE_COMPONENT_SET_OPTIONS dwOptions)
	{
		VSL_DEFINE_MOCK_METHOD(put_ComponentsListOptions)

		VSL_CHECK_VALIDVALUE(dwOptions);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ComponentsListOptionsValidValues
	{
		/*[out,retval]*/ BROWSE_COMPONENT_SET_OPTIONS* pdwOptions;
		HRESULT retValue;
	};

	STDMETHOD(get_ComponentsListOptions)(
		/*[out,retval]*/ BROWSE_COMPONENT_SET_OPTIONS* pdwOptions)
	{
		VSL_DEFINE_MOCK_METHOD(get_ComponentsListOptions)

		VSL_SET_VALIDVALUE(pdwOptions);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_ChildListOptionsValidValues
	{
		/*[in]*/ BROWSE_COMPONENT_SET_OPTIONS dwOptions;
		HRESULT retValue;
	};

	STDMETHOD(put_ChildListOptions)(
		/*[in]*/ BROWSE_COMPONENT_SET_OPTIONS dwOptions)
	{
		VSL_DEFINE_MOCK_METHOD(put_ChildListOptions)

		VSL_CHECK_VALIDVALUE(dwOptions);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ChildListOptionsValidValues
	{
		/*[out,retval]*/ BROWSE_COMPONENT_SET_OPTIONS* pdwOptions;
		HRESULT retValue;
	};

	STDMETHOD(get_ChildListOptions)(
		/*[out,retval]*/ BROWSE_COMPONENT_SET_OPTIONS* pdwOptions)
	{
		VSL_DEFINE_MOCK_METHOD(get_ChildListOptions)

		VSL_SET_VALIDVALUE(pdwOptions);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetList2ValidValues
	{
		/*[in]*/ LIB_LISTTYPE2 ListType;
		/*[in]*/ LIB_LISTFLAGS Flags;
		/*[in]*/ VSOBSEARCHCRITERIA2* pobSrch;
		/*[in]*/ IVsObjectList2* pExtraListToCombineWith;
		/*[out,retval]*/ IVsObjectList2** ppIVsObjectList2;
		HRESULT retValue;
	};

	STDMETHOD(GetList2)(
		/*[in]*/ LIB_LISTTYPE2 ListType,
		/*[in]*/ LIB_LISTFLAGS Flags,
		/*[in]*/ VSOBSEARCHCRITERIA2* pobSrch,
		/*[in]*/ IVsObjectList2* pExtraListToCombineWith,
		/*[out,retval]*/ IVsObjectList2** ppIVsObjectList2)
	{
		VSL_DEFINE_MOCK_METHOD(GetList2)

		VSL_CHECK_VALIDVALUE(ListType);

		VSL_CHECK_VALIDVALUE(Flags);

		VSL_CHECK_VALIDVALUE_POINTER(pobSrch);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pExtraListToCombineWith);

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsObjectList2);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSupportedCategoryFields2ValidValues
	{
		/*[in]*/ LIB_CATEGORY2 Category;
		/*[out,retval]*/ DWORD* pgrfCatField;
		HRESULT retValue;
	};

	STDMETHOD(GetSupportedCategoryFields2)(
		/*[in]*/ LIB_CATEGORY2 Category,
		/*[out,retval]*/ DWORD* pgrfCatField)
	{
		VSL_DEFINE_MOCK_METHOD(GetSupportedCategoryFields2)

		VSL_CHECK_VALIDVALUE(Category);

		VSL_SET_VALIDVALUE(pgrfCatField);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateNavInfoValidValues
	{
		/*[in]*/ REFGUID guidLib;
		/*[in,size_is(ulcNodes)]*/ SYMBOL_DESCRIPTION_NODE* rgSymbolNodes;
		/*[in]*/ ULONG ulcNodes;
		/*[out,retval]*/ IVsNavInfo** ppNavInfo;
		HRESULT retValue;
	};

	STDMETHOD(CreateNavInfo)(
		/*[in]*/ REFGUID guidLib,
		/*[in,size_is(ulcNodes)]*/ SYMBOL_DESCRIPTION_NODE rgSymbolNodes[],
		/*[in]*/ ULONG ulcNodes,
		/*[out,retval]*/ IVsNavInfo** ppNavInfo)
	{
		VSL_DEFINE_MOCK_METHOD(CreateNavInfo)

		VSL_CHECK_VALIDVALUE(guidLib);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgSymbolNodes, ulcNodes*sizeof(rgSymbolNodes[0]), validValues.ulcNodes*sizeof(validValues.rgSymbolNodes[0]));

		VSL_CHECK_VALIDVALUE(ulcNodes);

		VSL_SET_VALIDVALUE_INTERFACE(ppNavInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateCounterValidValues
	{
		/*[out]*/ ULONG* pCurUpdate;
		HRESULT retValue;
	};

	STDMETHOD(UpdateCounter)(
		/*[out]*/ ULONG* pCurUpdate)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateCounter)

		VSL_SET_VALIDVALUE(pCurUpdate);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSIMPLEBROWSECOMPONENTSET_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsShellPropertyEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSHELLPROPERTYEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSHELLPROPERTYEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsShellPropertyEventsNotImpl :
	public IVsShellPropertyEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsShellPropertyEventsNotImpl)

public:

	typedef IVsShellPropertyEvents Interface;

	STDMETHOD(OnShellPropertyChange)(
		/*[in]*/ VSSPROPID /*propid*/,
		/*[in]*/ VARIANT /*var*/)VSL_STDMETHOD_NOTIMPL
};

class IVsShellPropertyEventsMockImpl :
	public IVsShellPropertyEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsShellPropertyEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsShellPropertyEventsMockImpl)

	typedef IVsShellPropertyEvents Interface;
	struct OnShellPropertyChangeValidValues
	{
		/*[in]*/ VSSPROPID propid;
		/*[in]*/ VARIANT var;
		HRESULT retValue;
	};

	STDMETHOD(OnShellPropertyChange)(
		/*[in]*/ VSSPROPID propid,
		/*[in]*/ VARIANT var)
	{
		VSL_DEFINE_MOCK_METHOD(OnShellPropertyChange)

		VSL_CHECK_VALIDVALUE(propid);

		VSL_CHECK_VALIDVALUE(var);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSHELLPROPERTYEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSimpleObjectList2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSIMPLEOBJECTLIST2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSIMPLEOBJECTLIST2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSimpleObjectList2NotImpl :
	public IVsSimpleObjectList2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSimpleObjectList2NotImpl)

public:

	typedef IVsSimpleObjectList2 Interface;

	STDMETHOD(GetFlags)(
		/*[out]*/ VSTREEFLAGS* /*pFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCapabilities2)(
		/*[out]*/ LIB_LISTCAPABILITIES2* /*pgrfCapabilities*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateCounter)(
		/*[out]*/ ULONG* /*pCurUpdate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetItemCount)(
		/*[out]*/ ULONG* /*pCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDisplayData)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ VSTREEDISPLAYDATA* /*pData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTextWithOwnership)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSTREETEXTOPTIONS /*tto*/,
		/*[out]*/ BSTR* /*pbstrText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTipTextWithOwnership)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSTREETOOLTIPTYPE /*eTipType*/,
		/*[out]*/ BSTR* /*pbstrText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCategoryField2)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ LIB_CATEGORY2 /*Category*/,
		/*[out,retval]*/ DWORD* /*pfCatField*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBrowseObject)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ IDispatch** /*ppdispBrowseObj*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetUserContext)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ IUnknown** /*ppunkUserCtx*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ShowHelp)(
		/*[in]*/ ULONG /*Index*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSourceContextWithOwnership)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ BSTR* /*pbstrFileName*/,
		/*[out]*/ ULONG* /*pulLineNum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CountSourceItems)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ IVsHierarchy** /*ppHier*/,
		/*[out]*/ VSITEMID* /*pitemid*/,
		/*[out,retval]*/ ULONG* /*pcItems*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMultipleSourceItems)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSGSIFLAGS /*grfGSI*/,
		/*[in]*/ ULONG /*cItems*/,
		/*[out,size_is(cItems)]*/ VSITEMSELECTION[] /*rgItemSel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanGoToSource)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSOBJGOTOSRCTYPE /*SrcType*/,
		/*[out]*/ BOOL* /*pfOK*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GoToSource)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSOBJGOTOSRCTYPE /*SrcType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetContextMenu)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ CLSID* /*pclsidActive*/,
		/*[out]*/ LONG* /*pnMenuId*/,
		/*[out]*/ IOleCommandTarget** /*ppCmdTrgtActive*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryDragDrop)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ IDataObject* /*pDataObject*/,
		/*[in]*/ DWORD /*grfKeyState*/,
		/*[in,out]*/ DWORD* /*pdwEffect*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DoDragDrop)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ IDataObject* /*pDataObject*/,
		/*[in]*/ DWORD /*grfKeyState*/,
		/*[in,out]*/ DWORD* /*pdwEffect*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanRename)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ LPCOLESTR /*pszNewName*/,
		/*[out]*/ BOOL* /*pfOK*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DoRename)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ LPCOLESTR /*pszNewName*/,
		/*[in]*/ VSOBJOPFLAGS /*grfFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanDelete)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ BOOL* /*pfOK*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DoDelete)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSOBJOPFLAGS /*grfFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FillDescription2)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSOBJDESCOPTIONS /*grfOptions*/,
		/*[in]*/ IVsObjectBrowserDescription3* /*pobDesc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumClipboardFormats)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSOBJCFFLAGS /*grfFlags*/,
		/*[in]*/ ULONG /*celt*/,
		/*[in,out,size_is(celt)]*/ VSOBJCLIPFORMAT[] /*rgcfFormats*/,
		/*[out,optional]*/ ULONG* /*pcActual*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetClipboardFormat)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSOBJCFFLAGS /*grfFlags*/,
		/*[in]*/ FORMATETC* /*pFormatetc*/,
		/*[in]*/ STGMEDIUM* /*pMedium*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExtendedClipboardVariant)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSOBJCFFLAGS /*grfFlags*/,
		/*[in]*/ const VSOBJCLIPFORMAT* /*pcfFormat*/,
		/*[out]*/ VARIANT* /*pvarFormat*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProperty)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSOBJLISTELEMPROPID /*propid*/,
		/*[out]*/ VARIANT* /*pvar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetNavInfo)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ IVsNavInfo** /*ppNavInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetNavInfoNode)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ IVsNavInfoNode** /*ppNavInfoNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LocateNavInfoNode)(
		/*[in]*/ IVsNavInfoNode* /*pNavInfoNode*/,
		/*[out]*/ ULONG* /*pulIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExpandable3)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ LIB_LISTTYPE2 /*ListTypeExcluded*/,
		/*[out]*/ BOOL* /*pfExpandable*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetList2)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ LIB_LISTTYPE2 /*ListType*/,
		/*[in]*/ LIB_LISTFLAGS /*Flags*/,
		/*[in]*/ VSOBSEARCHCRITERIA2* /*pobSrch*/,
		/*[out,retval]*/ IVsSimpleObjectList2** /*ppIVsSimpleObjectList2*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnClose)(
		/*[out]*/ VSTREECLOSEACTIONS* /*ptca*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSimpleObjectList2MockImpl :
	public IVsSimpleObjectList2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSimpleObjectList2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSimpleObjectList2MockImpl)

	typedef IVsSimpleObjectList2 Interface;
	struct GetFlagsValidValues
	{
		/*[out]*/ VSTREEFLAGS* pFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetFlags)(
		/*[out]*/ VSTREEFLAGS* pFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetFlags)

		VSL_SET_VALIDVALUE(pFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCapabilities2ValidValues
	{
		/*[out]*/ LIB_LISTCAPABILITIES2* pgrfCapabilities;
		HRESULT retValue;
	};

	STDMETHOD(GetCapabilities2)(
		/*[out]*/ LIB_LISTCAPABILITIES2* pgrfCapabilities)
	{
		VSL_DEFINE_MOCK_METHOD(GetCapabilities2)

		VSL_SET_VALIDVALUE(pgrfCapabilities);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateCounterValidValues
	{
		/*[out]*/ ULONG* pCurUpdate;
		HRESULT retValue;
	};

	STDMETHOD(UpdateCounter)(
		/*[out]*/ ULONG* pCurUpdate)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateCounter)

		VSL_SET_VALIDVALUE(pCurUpdate);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetItemCountValidValues
	{
		/*[out]*/ ULONG* pCount;
		HRESULT retValue;
	};

	STDMETHOD(GetItemCount)(
		/*[out]*/ ULONG* pCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetItemCount)

		VSL_SET_VALIDVALUE(pCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDisplayDataValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ VSTREEDISPLAYDATA* pData;
		HRESULT retValue;
	};

	STDMETHOD(GetDisplayData)(
		/*[in]*/ ULONG Index,
		/*[out]*/ VSTREEDISPLAYDATA* pData)
	{
		VSL_DEFINE_MOCK_METHOD(GetDisplayData)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE(pData);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTextWithOwnershipValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSTREETEXTOPTIONS tto;
		/*[out]*/ BSTR* pbstrText;
		HRESULT retValue;
	};

	STDMETHOD(GetTextWithOwnership)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSTREETEXTOPTIONS tto,
		/*[out]*/ BSTR* pbstrText)
	{
		VSL_DEFINE_MOCK_METHOD(GetTextWithOwnership)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(tto);

		VSL_SET_VALIDVALUE_BSTR(pbstrText);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTipTextWithOwnershipValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSTREETOOLTIPTYPE eTipType;
		/*[out]*/ BSTR* pbstrText;
		HRESULT retValue;
	};

	STDMETHOD(GetTipTextWithOwnership)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSTREETOOLTIPTYPE eTipType,
		/*[out]*/ BSTR* pbstrText)
	{
		VSL_DEFINE_MOCK_METHOD(GetTipTextWithOwnership)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(eTipType);

		VSL_SET_VALIDVALUE_BSTR(pbstrText);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCategoryField2ValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ LIB_CATEGORY2 Category;
		/*[out,retval]*/ DWORD* pfCatField;
		HRESULT retValue;
	};

	STDMETHOD(GetCategoryField2)(
		/*[in]*/ ULONG Index,
		/*[in]*/ LIB_CATEGORY2 Category,
		/*[out,retval]*/ DWORD* pfCatField)
	{
		VSL_DEFINE_MOCK_METHOD(GetCategoryField2)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(Category);

		VSL_SET_VALIDVALUE(pfCatField);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBrowseObjectValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ IDispatch** ppdispBrowseObj;
		HRESULT retValue;
	};

	STDMETHOD(GetBrowseObject)(
		/*[in]*/ ULONG Index,
		/*[out]*/ IDispatch** ppdispBrowseObj)
	{
		VSL_DEFINE_MOCK_METHOD(GetBrowseObject)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE_INTERFACE(ppdispBrowseObj);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetUserContextValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ IUnknown** ppunkUserCtx;
		HRESULT retValue;
	};

	STDMETHOD(GetUserContext)(
		/*[in]*/ ULONG Index,
		/*[out]*/ IUnknown** ppunkUserCtx)
	{
		VSL_DEFINE_MOCK_METHOD(GetUserContext)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE_INTERFACE(ppunkUserCtx);

		VSL_RETURN_VALIDVALUES();
	}
	struct ShowHelpValidValues
	{
		/*[in]*/ ULONG Index;
		HRESULT retValue;
	};

	STDMETHOD(ShowHelp)(
		/*[in]*/ ULONG Index)
	{
		VSL_DEFINE_MOCK_METHOD(ShowHelp)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSourceContextWithOwnershipValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ BSTR* pbstrFileName;
		/*[out]*/ ULONG* pulLineNum;
		HRESULT retValue;
	};

	STDMETHOD(GetSourceContextWithOwnership)(
		/*[in]*/ ULONG Index,
		/*[out]*/ BSTR* pbstrFileName,
		/*[out]*/ ULONG* pulLineNum)
	{
		VSL_DEFINE_MOCK_METHOD(GetSourceContextWithOwnership)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE_BSTR(pbstrFileName);

		VSL_SET_VALIDVALUE(pulLineNum);

		VSL_RETURN_VALIDVALUES();
	}
	struct CountSourceItemsValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ IVsHierarchy** ppHier;
		/*[out]*/ VSITEMID* pitemid;
		/*[out,retval]*/ ULONG* pcItems;
		HRESULT retValue;
	};

	STDMETHOD(CountSourceItems)(
		/*[in]*/ ULONG Index,
		/*[out]*/ IVsHierarchy** ppHier,
		/*[out]*/ VSITEMID* pitemid,
		/*[out,retval]*/ ULONG* pcItems)
	{
		VSL_DEFINE_MOCK_METHOD(CountSourceItems)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE_INTERFACE(ppHier);

		VSL_SET_VALIDVALUE(pitemid);

		VSL_SET_VALIDVALUE(pcItems);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMultipleSourceItemsValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSGSIFLAGS grfGSI;
		/*[in]*/ ULONG cItems;
		/*[out,size_is(cItems)]*/ VSITEMSELECTION* rgItemSel;
		HRESULT retValue;
	};

	STDMETHOD(GetMultipleSourceItems)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSGSIFLAGS grfGSI,
		/*[in]*/ ULONG cItems,
		/*[out,size_is(cItems)]*/ VSITEMSELECTION rgItemSel[])
	{
		VSL_DEFINE_MOCK_METHOD(GetMultipleSourceItems)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(grfGSI);

		VSL_CHECK_VALIDVALUE(cItems);

		VSL_SET_VALIDVALUE_MEMCPY(rgItemSel, cItems*sizeof(rgItemSel[0]), validValues.cItems*sizeof(validValues.rgItemSel[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct CanGoToSourceValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSOBJGOTOSRCTYPE SrcType;
		/*[out]*/ BOOL* pfOK;
		HRESULT retValue;
	};

	STDMETHOD(CanGoToSource)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSOBJGOTOSRCTYPE SrcType,
		/*[out]*/ BOOL* pfOK)
	{
		VSL_DEFINE_MOCK_METHOD(CanGoToSource)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(SrcType);

		VSL_SET_VALIDVALUE(pfOK);

		VSL_RETURN_VALIDVALUES();
	}
	struct GoToSourceValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSOBJGOTOSRCTYPE SrcType;
		HRESULT retValue;
	};

	STDMETHOD(GoToSource)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSOBJGOTOSRCTYPE SrcType)
	{
		VSL_DEFINE_MOCK_METHOD(GoToSource)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(SrcType);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetContextMenuValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ CLSID* pclsidActive;
		/*[out]*/ LONG* pnMenuId;
		/*[out]*/ IOleCommandTarget** ppCmdTrgtActive;
		HRESULT retValue;
	};

	STDMETHOD(GetContextMenu)(
		/*[in]*/ ULONG Index,
		/*[out]*/ CLSID* pclsidActive,
		/*[out]*/ LONG* pnMenuId,
		/*[out]*/ IOleCommandTarget** ppCmdTrgtActive)
	{
		VSL_DEFINE_MOCK_METHOD(GetContextMenu)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE(pclsidActive);

		VSL_SET_VALIDVALUE(pnMenuId);

		VSL_SET_VALIDVALUE_INTERFACE(ppCmdTrgtActive);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryDragDropValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ IDataObject* pDataObject;
		/*[in]*/ DWORD grfKeyState;
		/*[in,out]*/ DWORD* pdwEffect;
		HRESULT retValue;
	};

	STDMETHOD(QueryDragDrop)(
		/*[in]*/ ULONG Index,
		/*[in]*/ IDataObject* pDataObject,
		/*[in]*/ DWORD grfKeyState,
		/*[in,out]*/ DWORD* pdwEffect)
	{
		VSL_DEFINE_MOCK_METHOD(QueryDragDrop)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDataObject);

		VSL_CHECK_VALIDVALUE(grfKeyState);

		VSL_SET_VALIDVALUE(pdwEffect);

		VSL_RETURN_VALIDVALUES();
	}
	struct DoDragDropValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ IDataObject* pDataObject;
		/*[in]*/ DWORD grfKeyState;
		/*[in,out]*/ DWORD* pdwEffect;
		HRESULT retValue;
	};

	STDMETHOD(DoDragDrop)(
		/*[in]*/ ULONG Index,
		/*[in]*/ IDataObject* pDataObject,
		/*[in]*/ DWORD grfKeyState,
		/*[in,out]*/ DWORD* pdwEffect)
	{
		VSL_DEFINE_MOCK_METHOD(DoDragDrop)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDataObject);

		VSL_CHECK_VALIDVALUE(grfKeyState);

		VSL_SET_VALIDVALUE(pdwEffect);

		VSL_RETURN_VALIDVALUES();
	}
	struct CanRenameValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ LPCOLESTR pszNewName;
		/*[out]*/ BOOL* pfOK;
		HRESULT retValue;
	};

	STDMETHOD(CanRename)(
		/*[in]*/ ULONG Index,
		/*[in]*/ LPCOLESTR pszNewName,
		/*[out]*/ BOOL* pfOK)
	{
		VSL_DEFINE_MOCK_METHOD(CanRename)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE_STRINGW(pszNewName);

		VSL_SET_VALIDVALUE(pfOK);

		VSL_RETURN_VALIDVALUES();
	}
	struct DoRenameValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ LPCOLESTR pszNewName;
		/*[in]*/ VSOBJOPFLAGS grfFlags;
		HRESULT retValue;
	};

	STDMETHOD(DoRename)(
		/*[in]*/ ULONG Index,
		/*[in]*/ LPCOLESTR pszNewName,
		/*[in]*/ VSOBJOPFLAGS grfFlags)
	{
		VSL_DEFINE_MOCK_METHOD(DoRename)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE_STRINGW(pszNewName);

		VSL_CHECK_VALIDVALUE(grfFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct CanDeleteValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ BOOL* pfOK;
		HRESULT retValue;
	};

	STDMETHOD(CanDelete)(
		/*[in]*/ ULONG Index,
		/*[out]*/ BOOL* pfOK)
	{
		VSL_DEFINE_MOCK_METHOD(CanDelete)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE(pfOK);

		VSL_RETURN_VALIDVALUES();
	}
	struct DoDeleteValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSOBJOPFLAGS grfFlags;
		HRESULT retValue;
	};

	STDMETHOD(DoDelete)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSOBJOPFLAGS grfFlags)
	{
		VSL_DEFINE_MOCK_METHOD(DoDelete)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(grfFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct FillDescription2ValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSOBJDESCOPTIONS grfOptions;
		/*[in]*/ IVsObjectBrowserDescription3* pobDesc;
		HRESULT retValue;
	};

	STDMETHOD(FillDescription2)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSOBJDESCOPTIONS grfOptions,
		/*[in]*/ IVsObjectBrowserDescription3* pobDesc)
	{
		VSL_DEFINE_MOCK_METHOD(FillDescription2)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(grfOptions);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pobDesc);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumClipboardFormatsValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSOBJCFFLAGS grfFlags;
		/*[in]*/ ULONG celt;
		/*[in,out,size_is(celt)]*/ VSOBJCLIPFORMAT* rgcfFormats;
		/*[out,optional]*/ ULONG* pcActual;
		HRESULT retValue;
	};

	STDMETHOD(EnumClipboardFormats)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSOBJCFFLAGS grfFlags,
		/*[in]*/ ULONG celt,
		/*[in,out,size_is(celt)]*/ VSOBJCLIPFORMAT rgcfFormats[],
		/*[out,optional]*/ ULONG* pcActual)
	{
		VSL_DEFINE_MOCK_METHOD(EnumClipboardFormats)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(grfFlags);

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(rgcfFormats, celt*sizeof(rgcfFormats[0]), validValues.celt*sizeof(validValues.rgcfFormats[0]));

		VSL_SET_VALIDVALUE(pcActual);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetClipboardFormatValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSOBJCFFLAGS grfFlags;
		/*[in]*/ FORMATETC* pFormatetc;
		/*[in]*/ STGMEDIUM* pMedium;
		HRESULT retValue;
	};

	STDMETHOD(GetClipboardFormat)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSOBJCFFLAGS grfFlags,
		/*[in]*/ FORMATETC* pFormatetc,
		/*[in]*/ STGMEDIUM* pMedium)
	{
		VSL_DEFINE_MOCK_METHOD(GetClipboardFormat)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(grfFlags);

		VSL_CHECK_VALIDVALUE_POINTER(pFormatetc);

		VSL_CHECK_VALIDVALUE_POINTER(pMedium);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExtendedClipboardVariantValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSOBJCFFLAGS grfFlags;
		/*[in]*/ VSOBJCLIPFORMAT* pcfFormat;
		/*[out]*/ VARIANT* pvarFormat;
		HRESULT retValue;
	};

	STDMETHOD(GetExtendedClipboardVariant)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSOBJCFFLAGS grfFlags,
		/*[in]*/ const VSOBJCLIPFORMAT* pcfFormat,
		/*[out]*/ VARIANT* pvarFormat)
	{
		VSL_DEFINE_MOCK_METHOD(GetExtendedClipboardVariant)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(grfFlags);

		VSL_CHECK_VALIDVALUE_POINTER(pcfFormat);

		VSL_SET_VALIDVALUE_VARIANT(pvarFormat);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPropertyValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSOBJLISTELEMPROPID propid;
		/*[out]*/ VARIANT* pvar;
		HRESULT retValue;
	};

	STDMETHOD(GetProperty)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSOBJLISTELEMPROPID propid,
		/*[out]*/ VARIANT* pvar)
	{
		VSL_DEFINE_MOCK_METHOD(GetProperty)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(propid);

		VSL_SET_VALIDVALUE_VARIANT(pvar);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNavInfoValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ IVsNavInfo** ppNavInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetNavInfo)(
		/*[in]*/ ULONG Index,
		/*[out]*/ IVsNavInfo** ppNavInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetNavInfo)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE_INTERFACE(ppNavInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNavInfoNodeValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ IVsNavInfoNode** ppNavInfoNode;
		HRESULT retValue;
	};

	STDMETHOD(GetNavInfoNode)(
		/*[in]*/ ULONG Index,
		/*[out]*/ IVsNavInfoNode** ppNavInfoNode)
	{
		VSL_DEFINE_MOCK_METHOD(GetNavInfoNode)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE_INTERFACE(ppNavInfoNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct LocateNavInfoNodeValidValues
	{
		/*[in]*/ IVsNavInfoNode* pNavInfoNode;
		/*[out]*/ ULONG* pulIndex;
		HRESULT retValue;
	};

	STDMETHOD(LocateNavInfoNode)(
		/*[in]*/ IVsNavInfoNode* pNavInfoNode,
		/*[out]*/ ULONG* pulIndex)
	{
		VSL_DEFINE_MOCK_METHOD(LocateNavInfoNode)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pNavInfoNode);

		VSL_SET_VALIDVALUE(pulIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExpandable3ValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ LIB_LISTTYPE2 ListTypeExcluded;
		/*[out]*/ BOOL* pfExpandable;
		HRESULT retValue;
	};

	STDMETHOD(GetExpandable3)(
		/*[in]*/ ULONG Index,
		/*[in]*/ LIB_LISTTYPE2 ListTypeExcluded,
		/*[out]*/ BOOL* pfExpandable)
	{
		VSL_DEFINE_MOCK_METHOD(GetExpandable3)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(ListTypeExcluded);

		VSL_SET_VALIDVALUE(pfExpandable);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetList2ValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ LIB_LISTTYPE2 ListType;
		/*[in]*/ LIB_LISTFLAGS Flags;
		/*[in]*/ VSOBSEARCHCRITERIA2* pobSrch;
		/*[out,retval]*/ IVsSimpleObjectList2** ppIVsSimpleObjectList2;
		HRESULT retValue;
	};

	STDMETHOD(GetList2)(
		/*[in]*/ ULONG Index,
		/*[in]*/ LIB_LISTTYPE2 ListType,
		/*[in]*/ LIB_LISTFLAGS Flags,
		/*[in]*/ VSOBSEARCHCRITERIA2* pobSrch,
		/*[out,retval]*/ IVsSimpleObjectList2** ppIVsSimpleObjectList2)
	{
		VSL_DEFINE_MOCK_METHOD(GetList2)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(ListType);

		VSL_CHECK_VALIDVALUE(Flags);

		VSL_CHECK_VALIDVALUE_POINTER(pobSrch);

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsSimpleObjectList2);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnCloseValidValues
	{
		/*[out]*/ VSTREECLOSEACTIONS* ptca;
		HRESULT retValue;
	};

	STDMETHOD(OnClose)(
		/*[out]*/ VSTREECLOSEACTIONS* ptca)
	{
		VSL_DEFINE_MOCK_METHOD(OnClose)

		VSL_SET_VALIDVALUE(ptca);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSIMPLEOBJECTLIST2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSimpleLibrary2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSIMPLELIBRARY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSIMPLELIBRARY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSimpleLibrary2NotImpl :
	public IVsSimpleLibrary2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSimpleLibrary2NotImpl)

public:

	typedef IVsSimpleLibrary2 Interface;

	STDMETHOD(GetSupportedCategoryFields2)(
		/*[in]*/ LIB_CATEGORY2 /*Category*/,
		/*[out,retval]*/ DWORD* /*pgrfCatField*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetList2)(
		/*[in]*/ LIB_LISTTYPE2 /*ListType*/,
		/*[in]*/ LIB_LISTFLAGS /*Flags*/,
		/*[in]*/ VSOBSEARCHCRITERIA2* /*pobSrch*/,
		/*[out,retval]*/ IVsSimpleObjectList2** /*ppIVsSimpleObjectList2*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLibFlags2)(
		/*[out,retval]*/ LIB_FLAGS2* /*pgrfFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateCounter)(
		/*[out]*/ ULONG* /*pCurUpdate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetGuid)(
		/*[out]*/ GUID* /*pguidLib*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSeparatorStringWithOwnership)(
		/*[out]*/ BSTR* /*pbstrSeparator*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LoadState)(
		/*[in]*/ IStream* /*pIStream*/,
		/*[in]*/ LIB_PERSISTTYPE /*lptType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SaveState)(
		/*[in]*/ IStream* /*pIStream*/,
		/*[in]*/ LIB_PERSISTTYPE /*lptType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBrowseContainersForHierarchy)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ ULONG /*celt*/,
		/*[in,out,size_is(celt)]*/ VSBROWSECONTAINER[] /*rgBrowseContainers*/,
		/*[out,optional]*/ ULONG* /*pcActual*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddBrowseContainer)(
		/*[in]*/ PVSCOMPONENTSELECTORDATA /*pcdComponent*/,
		/*[in,out]*/ LIB_ADDREMOVEOPTIONS* /*pgrfOptions*/,
		/*[out]*/ BSTR* /*pbstrComponentAdded*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveBrowseContainer)(
		/*[in]*/ DWORD /*dwReserved*/,
		/*[in]*/ LPCWSTR /*pszLibName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateNavInfo)(
		/*[in,size_is(ulcNodes)]*/ SYMBOL_DESCRIPTION_NODE[] /*rgSymbolNodes*/,
		/*[in]*/ ULONG /*ulcNodes*/,
		/*[out]*/ IVsNavInfo** /*ppNavInfo*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSimpleLibrary2MockImpl :
	public IVsSimpleLibrary2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSimpleLibrary2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSimpleLibrary2MockImpl)

	typedef IVsSimpleLibrary2 Interface;
	struct GetSupportedCategoryFields2ValidValues
	{
		/*[in]*/ LIB_CATEGORY2 Category;
		/*[out,retval]*/ DWORD* pgrfCatField;
		HRESULT retValue;
	};

	STDMETHOD(GetSupportedCategoryFields2)(
		/*[in]*/ LIB_CATEGORY2 Category,
		/*[out,retval]*/ DWORD* pgrfCatField)
	{
		VSL_DEFINE_MOCK_METHOD(GetSupportedCategoryFields2)

		VSL_CHECK_VALIDVALUE(Category);

		VSL_SET_VALIDVALUE(pgrfCatField);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetList2ValidValues
	{
		/*[in]*/ LIB_LISTTYPE2 ListType;
		/*[in]*/ LIB_LISTFLAGS Flags;
		/*[in]*/ VSOBSEARCHCRITERIA2* pobSrch;
		/*[out,retval]*/ IVsSimpleObjectList2** ppIVsSimpleObjectList2;
		HRESULT retValue;
	};

	STDMETHOD(GetList2)(
		/*[in]*/ LIB_LISTTYPE2 ListType,
		/*[in]*/ LIB_LISTFLAGS Flags,
		/*[in]*/ VSOBSEARCHCRITERIA2* pobSrch,
		/*[out,retval]*/ IVsSimpleObjectList2** ppIVsSimpleObjectList2)
	{
		VSL_DEFINE_MOCK_METHOD(GetList2)

		VSL_CHECK_VALIDVALUE(ListType);

		VSL_CHECK_VALIDVALUE(Flags);

		VSL_CHECK_VALIDVALUE_POINTER(pobSrch);

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsSimpleObjectList2);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLibFlags2ValidValues
	{
		/*[out,retval]*/ LIB_FLAGS2* pgrfFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetLibFlags2)(
		/*[out,retval]*/ LIB_FLAGS2* pgrfFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetLibFlags2)

		VSL_SET_VALIDVALUE(pgrfFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateCounterValidValues
	{
		/*[out]*/ ULONG* pCurUpdate;
		HRESULT retValue;
	};

	STDMETHOD(UpdateCounter)(
		/*[out]*/ ULONG* pCurUpdate)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateCounter)

		VSL_SET_VALIDVALUE(pCurUpdate);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetGuidValidValues
	{
		/*[out]*/ GUID* pguidLib;
		HRESULT retValue;
	};

	STDMETHOD(GetGuid)(
		/*[out]*/ GUID* pguidLib)
	{
		VSL_DEFINE_MOCK_METHOD(GetGuid)

		VSL_SET_VALIDVALUE(pguidLib);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSeparatorStringWithOwnershipValidValues
	{
		/*[out]*/ BSTR* pbstrSeparator;
		HRESULT retValue;
	};

	STDMETHOD(GetSeparatorStringWithOwnership)(
		/*[out]*/ BSTR* pbstrSeparator)
	{
		VSL_DEFINE_MOCK_METHOD(GetSeparatorStringWithOwnership)

		VSL_SET_VALIDVALUE_BSTR(pbstrSeparator);

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadStateValidValues
	{
		/*[in]*/ IStream* pIStream;
		/*[in]*/ LIB_PERSISTTYPE lptType;
		HRESULT retValue;
	};

	STDMETHOD(LoadState)(
		/*[in]*/ IStream* pIStream,
		/*[in]*/ LIB_PERSISTTYPE lptType)
	{
		VSL_DEFINE_MOCK_METHOD(LoadState)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIStream);

		VSL_CHECK_VALIDVALUE(lptType);

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveStateValidValues
	{
		/*[in]*/ IStream* pIStream;
		/*[in]*/ LIB_PERSISTTYPE lptType;
		HRESULT retValue;
	};

	STDMETHOD(SaveState)(
		/*[in]*/ IStream* pIStream,
		/*[in]*/ LIB_PERSISTTYPE lptType)
	{
		VSL_DEFINE_MOCK_METHOD(SaveState)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIStream);

		VSL_CHECK_VALIDVALUE(lptType);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBrowseContainersForHierarchyValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ ULONG celt;
		/*[in,out,size_is(celt)]*/ VSBROWSECONTAINER* rgBrowseContainers;
		/*[out,optional]*/ ULONG* pcActual;
		HRESULT retValue;
	};

	STDMETHOD(GetBrowseContainersForHierarchy)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ ULONG celt,
		/*[in,out,size_is(celt)]*/ VSBROWSECONTAINER rgBrowseContainers[],
		/*[out,optional]*/ ULONG* pcActual)
	{
		VSL_DEFINE_MOCK_METHOD(GetBrowseContainersForHierarchy)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(rgBrowseContainers, celt*sizeof(rgBrowseContainers[0]), validValues.celt*sizeof(validValues.rgBrowseContainers[0]));

		VSL_SET_VALIDVALUE(pcActual);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddBrowseContainerValidValues
	{
		/*[in]*/ PVSCOMPONENTSELECTORDATA pcdComponent;
		/*[in,out]*/ LIB_ADDREMOVEOPTIONS* pgrfOptions;
		/*[out]*/ BSTR* pbstrComponentAdded;
		HRESULT retValue;
	};

	STDMETHOD(AddBrowseContainer)(
		/*[in]*/ PVSCOMPONENTSELECTORDATA pcdComponent,
		/*[in,out]*/ LIB_ADDREMOVEOPTIONS* pgrfOptions,
		/*[out]*/ BSTR* pbstrComponentAdded)
	{
		VSL_DEFINE_MOCK_METHOD(AddBrowseContainer)

		VSL_CHECK_VALIDVALUE(pcdComponent);

		VSL_SET_VALIDVALUE(pgrfOptions);

		VSL_SET_VALIDVALUE_BSTR(pbstrComponentAdded);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveBrowseContainerValidValues
	{
		/*[in]*/ DWORD dwReserved;
		/*[in]*/ LPCWSTR pszLibName;
		HRESULT retValue;
	};

	STDMETHOD(RemoveBrowseContainer)(
		/*[in]*/ DWORD dwReserved,
		/*[in]*/ LPCWSTR pszLibName)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveBrowseContainer)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_CHECK_VALIDVALUE_STRINGW(pszLibName);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateNavInfoValidValues
	{
		/*[in,size_is(ulcNodes)]*/ SYMBOL_DESCRIPTION_NODE* rgSymbolNodes;
		/*[in]*/ ULONG ulcNodes;
		/*[out]*/ IVsNavInfo** ppNavInfo;
		HRESULT retValue;
	};

	STDMETHOD(CreateNavInfo)(
		/*[in,size_is(ulcNodes)]*/ SYMBOL_DESCRIPTION_NODE rgSymbolNodes[],
		/*[in]*/ ULONG ulcNodes,
		/*[out]*/ IVsNavInfo** ppNavInfo)
	{
		VSL_DEFINE_MOCK_METHOD(CreateNavInfo)

		VSL_CHECK_VALIDVALUE_MEMCMP(rgSymbolNodes, ulcNodes*sizeof(rgSymbolNodes[0]), validValues.ulcNodes*sizeof(validValues.rgSymbolNodes[0]));

		VSL_CHECK_VALIDVALUE(ulcNodes);

		VSL_SET_VALIDVALUE_INTERFACE(ppNavInfo);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSIMPLELIBRARY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSimpleDocFactory.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSIMPLEDOCFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSIMPLEDOCFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSimpleDocFactoryNotImpl :
	public IVsSimpleDocFactory
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSimpleDocFactoryNotImpl)

public:

	typedef IVsSimpleDocFactory Interface;

	STDMETHOD(LoadDocument)(
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[in]*/ REFIID /*riid*/,
		/*[out,iid_is(riid)]*/ void** /*ppDocData*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSimpleDocFactoryMockImpl :
	public IVsSimpleDocFactory,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSimpleDocFactoryMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSimpleDocFactoryMockImpl)

	typedef IVsSimpleDocFactory Interface;
	struct LoadDocumentValidValues
	{
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[in]*/ REFIID riid;
		/*[out,iid_is(riid)]*/ void** ppDocData;
		HRESULT retValue;
	};

	STDMETHOD(LoadDocument)(
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[in]*/ REFIID riid,
		/*[out,iid_is(riid)]*/ void** ppDocData)
	{
		VSL_DEFINE_MOCK_METHOD(LoadDocument)

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_SET_VALIDVALUE(ppDocData);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSIMPLEDOCFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSimplePreviewChangesList.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSIMPLEPREVIEWCHANGESLIST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSIMPLEPREVIEWCHANGESLIST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSimplePreviewChangesListNotImpl :
	public IVsSimplePreviewChangesList
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSimplePreviewChangesListNotImpl)

public:

	typedef IVsSimplePreviewChangesList Interface;

	STDMETHOD(GetItemCount)(
		/*[out]*/ ULONG* /*pCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDisplayData)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ VSTREEDISPLAYDATA* /*pData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTextWithOwnership)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSTREETEXTOPTIONS /*tto*/,
		/*[out]*/ BSTR* /*pbstrText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTipTextWithOwnership)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ VSTREETOOLTIPTYPE /*eTipType*/,
		/*[out]*/ BSTR* /*pbstrText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExpandable)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ BOOL* /*pfExpandable*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExpandedList)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ BOOL* /*pfCanRecurse*/,
		/*[out]*/ IVsSimplePreviewChangesList** /*ppIVsSimplePreviewChangesList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LocateExpandedList)(
		/*[in]*/ IVsSimplePreviewChangesList* /*pIVsSimplePreviewChangesListChild*/,
		/*[out]*/ ULONG* /*piIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ToggleState)(
		/*[in]*/ ULONG /*Index*/,
		/*[out]*/ VSTREESTATECHANGEREFRESH* /*ptscr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnRequestSource)(
		/*[in]*/ ULONG /*Index*/,
		/*[in]*/ IUnknown* /*pIUnknownTextView*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnClose)(
		/*[out]*/ VSTREECLOSEACTIONS* /*ptca*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSimplePreviewChangesListMockImpl :
	public IVsSimplePreviewChangesList,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSimplePreviewChangesListMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSimplePreviewChangesListMockImpl)

	typedef IVsSimplePreviewChangesList Interface;
	struct GetItemCountValidValues
	{
		/*[out]*/ ULONG* pCount;
		HRESULT retValue;
	};

	STDMETHOD(GetItemCount)(
		/*[out]*/ ULONG* pCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetItemCount)

		VSL_SET_VALIDVALUE(pCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDisplayDataValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ VSTREEDISPLAYDATA* pData;
		HRESULT retValue;
	};

	STDMETHOD(GetDisplayData)(
		/*[in]*/ ULONG Index,
		/*[out]*/ VSTREEDISPLAYDATA* pData)
	{
		VSL_DEFINE_MOCK_METHOD(GetDisplayData)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE(pData);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTextWithOwnershipValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSTREETEXTOPTIONS tto;
		/*[out]*/ BSTR* pbstrText;
		HRESULT retValue;
	};

	STDMETHOD(GetTextWithOwnership)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSTREETEXTOPTIONS tto,
		/*[out]*/ BSTR* pbstrText)
	{
		VSL_DEFINE_MOCK_METHOD(GetTextWithOwnership)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(tto);

		VSL_SET_VALIDVALUE_BSTR(pbstrText);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTipTextWithOwnershipValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ VSTREETOOLTIPTYPE eTipType;
		/*[out]*/ BSTR* pbstrText;
		HRESULT retValue;
	};

	STDMETHOD(GetTipTextWithOwnership)(
		/*[in]*/ ULONG Index,
		/*[in]*/ VSTREETOOLTIPTYPE eTipType,
		/*[out]*/ BSTR* pbstrText)
	{
		VSL_DEFINE_MOCK_METHOD(GetTipTextWithOwnership)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE(eTipType);

		VSL_SET_VALIDVALUE_BSTR(pbstrText);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExpandableValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ BOOL* pfExpandable;
		HRESULT retValue;
	};

	STDMETHOD(GetExpandable)(
		/*[in]*/ ULONG Index,
		/*[out]*/ BOOL* pfExpandable)
	{
		VSL_DEFINE_MOCK_METHOD(GetExpandable)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE(pfExpandable);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExpandedListValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ BOOL* pfCanRecurse;
		/*[out]*/ IVsSimplePreviewChangesList** ppIVsSimplePreviewChangesList;
		HRESULT retValue;
	};

	STDMETHOD(GetExpandedList)(
		/*[in]*/ ULONG Index,
		/*[out]*/ BOOL* pfCanRecurse,
		/*[out]*/ IVsSimplePreviewChangesList** ppIVsSimplePreviewChangesList)
	{
		VSL_DEFINE_MOCK_METHOD(GetExpandedList)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE(pfCanRecurse);

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsSimplePreviewChangesList);

		VSL_RETURN_VALIDVALUES();
	}
	struct LocateExpandedListValidValues
	{
		/*[in]*/ IVsSimplePreviewChangesList* pIVsSimplePreviewChangesListChild;
		/*[out]*/ ULONG* piIndex;
		HRESULT retValue;
	};

	STDMETHOD(LocateExpandedList)(
		/*[in]*/ IVsSimplePreviewChangesList* pIVsSimplePreviewChangesListChild,
		/*[out]*/ ULONG* piIndex)
	{
		VSL_DEFINE_MOCK_METHOD(LocateExpandedList)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsSimplePreviewChangesListChild);

		VSL_SET_VALIDVALUE(piIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct ToggleStateValidValues
	{
		/*[in]*/ ULONG Index;
		/*[out]*/ VSTREESTATECHANGEREFRESH* ptscr;
		HRESULT retValue;
	};

	STDMETHOD(ToggleState)(
		/*[in]*/ ULONG Index,
		/*[out]*/ VSTREESTATECHANGEREFRESH* ptscr)
	{
		VSL_DEFINE_MOCK_METHOD(ToggleState)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_SET_VALIDVALUE(ptscr);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnRequestSourceValidValues
	{
		/*[in]*/ ULONG Index;
		/*[in]*/ IUnknown* pIUnknownTextView;
		HRESULT retValue;
	};

	STDMETHOD(OnRequestSource)(
		/*[in]*/ ULONG Index,
		/*[in]*/ IUnknown* pIUnknownTextView)
	{
		VSL_DEFINE_MOCK_METHOD(OnRequestSource)

		VSL_CHECK_VALIDVALUE(Index);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIUnknownTextView);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnCloseValidValues
	{
		/*[out]*/ VSTREECLOSEACTIONS* ptca;
		HRESULT retValue;
	};

	STDMETHOD(OnClose)(
		/*[out]*/ VSTREECLOSEACTIONS* ptca)
	{
		VSL_DEFINE_MOCK_METHOD(OnClose)

		VSL_SET_VALIDVALUE(ptca);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSIMPLEPREVIEWCHANGESLIST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSingleFileGeneratorFactory.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSINGLEFILEGENERATORFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSINGLEFILEGENERATORFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSingleFileGeneratorFactoryNotImpl :
	public IVsSingleFileGeneratorFactory
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSingleFileGeneratorFactoryNotImpl)

public:

	typedef IVsSingleFileGeneratorFactory Interface;

	STDMETHOD(GetDefaultGenerator)(
		/*[in]*/ LPCOLESTR /*wszFilename*/,
		/*[out,retval]*/ BSTR* /*pbstrGenProgID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateGeneratorInstance)(
		/*[in]*/ LPCOLESTR /*wszProgId*/,
		/*[out]*/ BOOL* /*pbGeneratesDesignTimeSource*/,
		/*[out]*/ BOOL* /*pbGeneratesSharedDesignTimeSource*/,
		/*[out]*/ BOOL* /*pbUseTempPEFlag*/,
		/*[out]*/ IVsSingleFileGenerator** /*ppGenerate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetGeneratorInformation)(
		/*[in]*/ LPCWSTR /*wszProgID*/,
		/*[out]*/ BOOL* /*pbGeneratesDesignTimeSource*/,
		/*[out]*/ BOOL* /*pbGeneratesSharedDesignTimeSource*/,
		/*[out]*/ BOOL* /*pbUseTempPEFlag*/,
		/*[out]*/ GUID* /*pguidGenerator*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSingleFileGeneratorFactoryMockImpl :
	public IVsSingleFileGeneratorFactory,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSingleFileGeneratorFactoryMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSingleFileGeneratorFactoryMockImpl)

	typedef IVsSingleFileGeneratorFactory Interface;
	struct GetDefaultGeneratorValidValues
	{
		/*[in]*/ LPCOLESTR wszFilename;
		/*[out,retval]*/ BSTR* pbstrGenProgID;
		HRESULT retValue;
	};

	STDMETHOD(GetDefaultGenerator)(
		/*[in]*/ LPCOLESTR wszFilename,
		/*[out,retval]*/ BSTR* pbstrGenProgID)
	{
		VSL_DEFINE_MOCK_METHOD(GetDefaultGenerator)

		VSL_CHECK_VALIDVALUE_STRINGW(wszFilename);

		VSL_SET_VALIDVALUE_BSTR(pbstrGenProgID);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateGeneratorInstanceValidValues
	{
		/*[in]*/ LPCOLESTR wszProgId;
		/*[out]*/ BOOL* pbGeneratesDesignTimeSource;
		/*[out]*/ BOOL* pbGeneratesSharedDesignTimeSource;
		/*[out]*/ BOOL* pbUseTempPEFlag;
		/*[out]*/ IVsSingleFileGenerator** ppGenerate;
		HRESULT retValue;
	};

	STDMETHOD(CreateGeneratorInstance)(
		/*[in]*/ LPCOLESTR wszProgId,
		/*[out]*/ BOOL* pbGeneratesDesignTimeSource,
		/*[out]*/ BOOL* pbGeneratesSharedDesignTimeSource,
		/*[out]*/ BOOL* pbUseTempPEFlag,
		/*[out]*/ IVsSingleFileGenerator** ppGenerate)
	{
		VSL_DEFINE_MOCK_METHOD(CreateGeneratorInstance)

		VSL_CHECK_VALIDVALUE_STRINGW(wszProgId);

		VSL_SET_VALIDVALUE(pbGeneratesDesignTimeSource);

		VSL_SET_VALIDVALUE(pbGeneratesSharedDesignTimeSource);

		VSL_SET_VALIDVALUE(pbUseTempPEFlag);

		VSL_SET_VALIDVALUE_INTERFACE(ppGenerate);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetGeneratorInformationValidValues
	{
		/*[in]*/ LPCWSTR wszProgID;
		/*[out]*/ BOOL* pbGeneratesDesignTimeSource;
		/*[out]*/ BOOL* pbGeneratesSharedDesignTimeSource;
		/*[out]*/ BOOL* pbUseTempPEFlag;
		/*[out]*/ GUID* pguidGenerator;
		HRESULT retValue;
	};

	STDMETHOD(GetGeneratorInformation)(
		/*[in]*/ LPCWSTR wszProgID,
		/*[out]*/ BOOL* pbGeneratesDesignTimeSource,
		/*[out]*/ BOOL* pbGeneratesSharedDesignTimeSource,
		/*[out]*/ BOOL* pbUseTempPEFlag,
		/*[out]*/ GUID* pguidGenerator)
	{
		VSL_DEFINE_MOCK_METHOD(GetGeneratorInformation)

		VSL_CHECK_VALIDVALUE_STRINGW(wszProgID);

		VSL_SET_VALIDVALUE(pbGeneratesDesignTimeSource);

		VSL_SET_VALIDVALUE(pbGeneratesSharedDesignTimeSource);

		VSL_SET_VALIDVALUE(pbUseTempPEFlag);

		VSL_SET_VALIDVALUE(pguidGenerator);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSINGLEFILEGENERATORFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSingleFileGenerator.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSINGLEFILEGENERATOR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSINGLEFILEGENERATOR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSingleFileGeneratorNotImpl :
	public IVsSingleFileGenerator
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSingleFileGeneratorNotImpl)

public:

	typedef IVsSingleFileGenerator Interface;

	STDMETHOD(get_DefaultExtension)(
		/*[out,retval]*/ BSTR* /*pbstrDefaultExtension*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Generate)(
		/*[in]*/ LPCOLESTR /*wszInputFilePath*/,
		/*[in]*/ BSTR /*bstrInputFileContents*/,
		/*[in]*/ LPCOLESTR /*wszDefaultNamespace*/,
		/*[out]*/ BYTE** /*rgbOutputFileContents*/,
		/*[out]*/ ULONG* /*pcbOutput*/,
		/*[in]*/ IVsGeneratorProgress* /*pGenerateProgress*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSingleFileGeneratorMockImpl :
	public IVsSingleFileGenerator,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSingleFileGeneratorMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSingleFileGeneratorMockImpl)

	typedef IVsSingleFileGenerator Interface;
	struct get_DefaultExtensionValidValues
	{
		/*[out,retval]*/ BSTR* pbstrDefaultExtension;
		HRESULT retValue;
	};

	STDMETHOD(get_DefaultExtension)(
		/*[out,retval]*/ BSTR* pbstrDefaultExtension)
	{
		VSL_DEFINE_MOCK_METHOD(get_DefaultExtension)

		VSL_SET_VALIDVALUE_BSTR(pbstrDefaultExtension);

		VSL_RETURN_VALIDVALUES();
	}
	struct GenerateValidValues
	{
		/*[in]*/ LPCOLESTR wszInputFilePath;
		/*[in]*/ BSTR bstrInputFileContents;
		/*[in]*/ LPCOLESTR wszDefaultNamespace;
		/*[out]*/ BYTE** rgbOutputFileContents;
		/*[out]*/ ULONG* pcbOutput;
		/*[in]*/ IVsGeneratorProgress* pGenerateProgress;
		HRESULT retValue;
	};

	STDMETHOD(Generate)(
		/*[in]*/ LPCOLESTR wszInputFilePath,
		/*[in]*/ BSTR bstrInputFileContents,
		/*[in]*/ LPCOLESTR wszDefaultNamespace,
		/*[out]*/ BYTE** rgbOutputFileContents,
		/*[out]*/ ULONG* pcbOutput,
		/*[in]*/ IVsGeneratorProgress* pGenerateProgress)
	{
		VSL_DEFINE_MOCK_METHOD(Generate)

		VSL_CHECK_VALIDVALUE_STRINGW(wszInputFilePath);

		VSL_CHECK_VALIDVALUE_BSTR(bstrInputFileContents);

		VSL_CHECK_VALIDVALUE_STRINGW(wszDefaultNamespace);

		VSL_SET_VALIDVALUE(rgbOutputFileContents);

		VSL_SET_VALIDVALUE(pcbOutput);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pGenerateProgress);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSINGLEFILEGENERATOR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSmartOpenScope.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSMARTOPENSCOPE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSMARTOPENSCOPE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "compsvcspkg80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSmartOpenScopeNotImpl :
	public IVsSmartOpenScope
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSmartOpenScopeNotImpl)

public:

	typedef IVsSmartOpenScope Interface;

	STDMETHOD(OpenScope)(
		/*[in]*/ LPCOLESTR /*wszScope*/,
		/*[in]*/ DWORD /*dwOpenFlags*/,
		/*[in]*/ REFIID /*riid*/,
		/*[out]*/ IUnknown** /*ppIUnk*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSmartOpenScopeMockImpl :
	public IVsSmartOpenScope,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSmartOpenScopeMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSmartOpenScopeMockImpl)

	typedef IVsSmartOpenScope Interface;
	struct OpenScopeValidValues
	{
		/*[in]*/ LPCOLESTR wszScope;
		/*[in]*/ DWORD dwOpenFlags;
		/*[in]*/ REFIID riid;
		/*[out]*/ IUnknown** ppIUnk;
		HRESULT retValue;
	};

	STDMETHOD(OpenScope)(
		/*[in]*/ LPCOLESTR wszScope,
		/*[in]*/ DWORD dwOpenFlags,
		/*[in]*/ REFIID riid,
		/*[out]*/ IUnknown** ppIUnk)
	{
		VSL_DEFINE_MOCK_METHOD(OpenScope)

		VSL_CHECK_VALIDVALUE_STRINGW(wszScope);

		VSL_CHECK_VALIDVALUE(dwOpenFlags);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_SET_VALIDVALUE_INTERFACE(ppIUnk);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSMARTOPENSCOPE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSmartTagTipWindow.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSMARTTAGTIPWINDOW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSMARTTAGTIPWINDOW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSmartTagTipWindowNotImpl :
	public IVsSmartTagTipWindow
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSmartTagTipWindowNotImpl)

public:

	typedef IVsSmartTagTipWindow Interface;

	STDMETHOD(GetContextStream)(
		/*[out]*/ long* /*piPos*/,
		/*[out]*/ long* /*piLength*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSizePreferences)(
		/*[in]*/ const RECT* /*prcCtxBounds*/,
		/*[out]*/ SMARTTAGSIZEDATA* /*pSizeData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Paint)(
		/*[in]*/ HDC /*hdc*/,
		/*[in]*/ const RECT* /*prc*/,
		/*[in]*/ COLORREF /*pColor*/,
		/*[in]*/ COLORREF /*pColorText*/,
		/*[in]*/ BOOL /*fSel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Dismiss)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(WndProc)(
		/*[in]*/ HWND /*hwnd*/,
		/*[in]*/ UINT /*iMsg*/,
		/*[in]*/ WPARAM /*wParam*/,
		/*[in]*/ LPARAM /*lParam*/,
		/*[in]*/ LRESULT* /*pLResult*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetSmartTagData)(
		/*[in]*/ IVsSmartTagData* /*pSmartTagData*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSmartTagTipWindowMockImpl :
	public IVsSmartTagTipWindow,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSmartTagTipWindowMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSmartTagTipWindowMockImpl)

	typedef IVsSmartTagTipWindow Interface;
	struct GetContextStreamValidValues
	{
		/*[out]*/ long* piPos;
		/*[out]*/ long* piLength;
		HRESULT retValue;
	};

	STDMETHOD(GetContextStream)(
		/*[out]*/ long* piPos,
		/*[out]*/ long* piLength)
	{
		VSL_DEFINE_MOCK_METHOD(GetContextStream)

		VSL_SET_VALIDVALUE(piPos);

		VSL_SET_VALIDVALUE(piLength);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSizePreferencesValidValues
	{
		/*[in]*/ RECT* prcCtxBounds;
		/*[out]*/ SMARTTAGSIZEDATA* pSizeData;
		HRESULT retValue;
	};

	STDMETHOD(GetSizePreferences)(
		/*[in]*/ const RECT* prcCtxBounds,
		/*[out]*/ SMARTTAGSIZEDATA* pSizeData)
	{
		VSL_DEFINE_MOCK_METHOD(GetSizePreferences)

		VSL_CHECK_VALIDVALUE_POINTER(prcCtxBounds);

		VSL_SET_VALIDVALUE(pSizeData);

		VSL_RETURN_VALIDVALUES();
	}
	struct PaintValidValues
	{
		/*[in]*/ HDC hdc;
		/*[in]*/ RECT* prc;
		/*[in]*/ COLORREF pColor;
		/*[in]*/ COLORREF pColorText;
		/*[in]*/ BOOL fSel;
		HRESULT retValue;
	};

	STDMETHOD(Paint)(
		/*[in]*/ HDC hdc,
		/*[in]*/ const RECT* prc,
		/*[in]*/ COLORREF pColor,
		/*[in]*/ COLORREF pColorText,
		/*[in]*/ BOOL fSel)
	{
		VSL_DEFINE_MOCK_METHOD(Paint)

		VSL_CHECK_VALIDVALUE(hdc);

		VSL_CHECK_VALIDVALUE_POINTER(prc);

		VSL_CHECK_VALIDVALUE(pColor);

		VSL_CHECK_VALIDVALUE(pColorText);

		VSL_CHECK_VALIDVALUE(fSel);

		VSL_RETURN_VALIDVALUES();
	}
	struct DismissValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Dismiss)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Dismiss)

		VSL_RETURN_VALIDVALUES();
	}
	struct WndProcValidValues
	{
		/*[in]*/ HWND hwnd;
		/*[in]*/ UINT iMsg;
		/*[in]*/ WPARAM wParam;
		/*[in]*/ LPARAM lParam;
		/*[in]*/ LRESULT* pLResult;
		HRESULT retValue;
	};

	STDMETHOD(WndProc)(
		/*[in]*/ HWND hwnd,
		/*[in]*/ UINT iMsg,
		/*[in]*/ WPARAM wParam,
		/*[in]*/ LPARAM lParam,
		/*[in]*/ LRESULT* pLResult)
	{
		VSL_DEFINE_MOCK_METHOD(WndProc)

		VSL_CHECK_VALIDVALUE(hwnd);

		VSL_CHECK_VALIDVALUE(iMsg);

		VSL_CHECK_VALIDVALUE(wParam);

		VSL_CHECK_VALIDVALUE(lParam);

		VSL_CHECK_VALIDVALUE_POINTER(pLResult);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetSmartTagDataValidValues
	{
		/*[in]*/ IVsSmartTagData* pSmartTagData;
		HRESULT retValue;
	};

	STDMETHOD(SetSmartTagData)(
		/*[in]*/ IVsSmartTagData* pSmartTagData)
	{
		VSL_DEFINE_MOCK_METHOD(SetSmartTagData)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSmartTagData);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSMARTTAGTIPWINDOW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSmartTagData.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSMARTTAGDATA_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSMARTTAGDATA_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSmartTagDataNotImpl :
	public IVsSmartTagData
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSmartTagDataNotImpl)

public:

	typedef IVsSmartTagData Interface;

	STDMETHOD(GetImageIndex)(
		/*[out]*/ long* /*piIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetContextMenuInfo)(
		/*[out]*/ GUID* /*guidID*/,
		/*[out]*/ long* /*nMenuID*/,
		/*[out]*/ IOleCommandTarget** /*pCmdTarget*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetContextStream)(
		/*[out]*/ long* /*piPos*/,
		/*[out]*/ long* /*piLength*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnDismiss)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnInvocation)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateView)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTimerInterval)(
		/*[out]*/ long* /*piTime*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsLeftJustified)(
		/*[out]*/ BOOL* /*pfIsLeftJustified*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTipText)(
		/*[out]*/ BSTR* /*pbstrTipText*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSmartTagDataMockImpl :
	public IVsSmartTagData,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSmartTagDataMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSmartTagDataMockImpl)

	typedef IVsSmartTagData Interface;
	struct GetImageIndexValidValues
	{
		/*[out]*/ long* piIndex;
		HRESULT retValue;
	};

	STDMETHOD(GetImageIndex)(
		/*[out]*/ long* piIndex)
	{
		VSL_DEFINE_MOCK_METHOD(GetImageIndex)

		VSL_SET_VALIDVALUE(piIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetContextMenuInfoValidValues
	{
		/*[out]*/ GUID* guidID;
		/*[out]*/ long* nMenuID;
		/*[out]*/ IOleCommandTarget** pCmdTarget;
		HRESULT retValue;
	};

	STDMETHOD(GetContextMenuInfo)(
		/*[out]*/ GUID* guidID,
		/*[out]*/ long* nMenuID,
		/*[out]*/ IOleCommandTarget** pCmdTarget)
	{
		VSL_DEFINE_MOCK_METHOD(GetContextMenuInfo)

		VSL_SET_VALIDVALUE(guidID);

		VSL_SET_VALIDVALUE(nMenuID);

		VSL_SET_VALIDVALUE_INTERFACE(pCmdTarget);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetContextStreamValidValues
	{
		/*[out]*/ long* piPos;
		/*[out]*/ long* piLength;
		HRESULT retValue;
	};

	STDMETHOD(GetContextStream)(
		/*[out]*/ long* piPos,
		/*[out]*/ long* piLength)
	{
		VSL_DEFINE_MOCK_METHOD(GetContextStream)

		VSL_SET_VALIDVALUE(piPos);

		VSL_SET_VALIDVALUE(piLength);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnDismissValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnDismiss)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnDismiss)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnInvocationValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnInvocation)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnInvocation)

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateViewValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(UpdateView)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(UpdateView)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTimerIntervalValidValues
	{
		/*[out]*/ long* piTime;
		HRESULT retValue;
	};

	STDMETHOD(GetTimerInterval)(
		/*[out]*/ long* piTime)
	{
		VSL_DEFINE_MOCK_METHOD(GetTimerInterval)

		VSL_SET_VALIDVALUE(piTime);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsLeftJustifiedValidValues
	{
		/*[out]*/ BOOL* pfIsLeftJustified;
		HRESULT retValue;
	};

	STDMETHOD(IsLeftJustified)(
		/*[out]*/ BOOL* pfIsLeftJustified)
	{
		VSL_DEFINE_MOCK_METHOD(IsLeftJustified)

		VSL_SET_VALIDVALUE(pfIsLeftJustified);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTipTextValidValues
	{
		/*[out]*/ BSTR* pbstrTipText;
		HRESULT retValue;
	};

	STDMETHOD(GetTipText)(
		/*[out]*/ BSTR* pbstrTipText)
	{
		VSL_DEFINE_MOCK_METHOD(GetTipText)

		VSL_SET_VALIDVALUE_BSTR(pbstrTipText);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSMARTTAGDATA_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSolution.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSOLUTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSOLUTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSolutionNotImpl :
	public IVsSolution
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSolutionNotImpl)

public:

	typedef IVsSolution Interface;

	STDMETHOD(GetProjectEnum)(
		/*[in]*/ VSENUMPROJFLAGS /*grfEnumFlags*/,
		/*[in]*/ REFGUID /*rguidEnumOnlyThisType*/,
		/*[out]*/ IEnumHierarchies** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateProject)(
		/*[in]*/ REFGUID /*rguidProjectType*/,
		/*[in]*/ LPCOLESTR /*lpszMoniker*/,
		/*[in]*/ LPCOLESTR /*lpszLocation*/,
		/*[in]*/ LPCOLESTR /*lpszName*/,
		/*[in]*/ VSCREATEPROJFLAGS /*grfCreateFlags*/,
		/*[in]*/ REFIID /*iidProject*/,
		/*[out,iid_is(iidProject)]*/ void** /*ppProject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GenerateUniqueProjectName)(
		/*[in]*/ LPCOLESTR /*lpszRoot*/,
		/*[out]*/ BSTR* /*pbstrProjectName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProjectOfGuid)(
		/*[in]*/ REFGUID /*rguidProjectID*/,
		/*[out]*/ IVsHierarchy** /*ppHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetGuidOfProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[out]*/ GUID* /*pguidProjectID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSolutionInfo)(
		/*[out]*/ BSTR* /*pbstrSolutionDirectory*/,
		/*[out]*/ BSTR* /*pbstrSolutionFile*/,
		/*[out]*/ BSTR* /*pbstrUserOptsFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AdviseSolutionEvents)(
		/*[in]*/ IVsSolutionEvents* /*pSink*/,
		/*[out]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseSolutionEvents)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SaveSolutionElement)(
		/*[in]*/ VSSLNSAVEOPTIONS /*grfSaveOpts*/,
		/*[in]*/ IVsHierarchy* /*pHier*/,
		/*[in]*/ VSCOOKIE /*docCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CloseSolutionElement)(
		/*[in]*/ VSSLNCLOSEOPTIONS /*grfCloseOpts*/,
		/*[in]*/ IVsHierarchy* /*pHier*/,
		/*[in]*/ VSCOOKIE /*docCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProjectOfProjref)(
		/*[in]*/ LPCOLESTR /*pszProjref*/,
		/*[out]*/ IVsHierarchy** /*ppHierarchy*/,
		/*[out]*/ BSTR* /*pbstrUpdatedProjref*/,
		/*[out]*/ VSUPDATEPROJREFREASON* /*puprUpdateReason*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProjrefOfProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[out]*/ BSTR* /*pbstrProjref*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProjectInfoOfProjref)(
		/*[in]*/ LPCOLESTR /*pszProjref*/,
		/*[in]*/ VSHPROPID /*propid*/,
		/*[out]*/ VARIANT* /*pvar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddVirtualProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ VSADDVPFLAGS /*grfAddVPFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetItemOfProjref)(
		/*[in]*/ LPCOLESTR /*pszProjref*/,
		/*[out]*/ IVsHierarchy** /*ppHierarchy*/,
		/*[out]*/ VSITEMID* /*pitemid*/,
		/*[out]*/ BSTR* /*pbstrUpdatedProjref*/,
		/*[out]*/ VSUPDATEPROJREFREASON* /*puprUpdateReason*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProjrefOfItem)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[out]*/ BSTR* /*pbstrProjref*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetItemInfoOfProjref)(
		/*[in]*/ LPCOLESTR /*pszProjref*/,
		/*[in]*/ VSHPROPID /*propid*/,
		/*[out]*/ VARIANT* /*pvar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProjectOfUniqueName)(
		/*[in]*/ LPCOLESTR /*pszUniqueName*/,
		/*[out]*/ IVsHierarchy** /*ppHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetUniqueNameOfProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[out]*/ BSTR* /*pbstrUniqueName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProperty)(
		/*[in]*/ VSPROPID /*propid*/,
		/*[out]*/ VARIANT* /*pvar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetProperty)(
		/*[in]*/ VSPROPID /*propid*/,
		/*[in]*/ VARIANT /*var*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OpenSolutionFile)(
		/*[in]*/ VSSLNOPENOPTIONS /*grfOpenOpts*/,
		/*[in]*/ LPCOLESTR /*pszFilename*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryEditSolutionFile)(
		/*[out]*/ DWORD* /*pdwEditResult*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateSolution)(
		/*[in,unique]*/ LPCOLESTR /*lpszLocation*/,
		/*[in,unique]*/ LPCOLESTR /*lpszName*/,
		/*[in]*/ VSCREATESOLUTIONFLAGS /*grfCreateFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProjectFactory)(
		/*[in]*/ DWORD /*dwReserved*/,
		/*[in,out]*/ GUID* /*pguidProjectType*/,
		/*[in]*/ LPCOLESTR /*pszMkProject*/,
		/*[out,retval]*/ IVsProjectFactory** /*ppProjectFactory*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProjectTypeGuid)(
		/*[in]*/ DWORD /*dwReserved*/,
		/*[in]*/ LPCOLESTR /*pszMkProject*/,
		/*[out,retval]*/ GUID* /*pguidProjectType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OpenSolutionViaDlg)(
		/*[in]*/ LPCOLESTR /*pszStartDirectory*/,
		/*[in]*/ BOOL /*fDefaultToAllProjectsFilter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddVirtualProjectEx)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ VSADDVPFLAGS /*grfAddVPFlags*/,
		/*[in]*/ REFGUID /*rguidProjectID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryRenameProject)(
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ LPCOLESTR /*pszMkOldName*/,
		/*[in]*/ LPCOLESTR /*pszMkNewName*/,
		/*[in]*/ DWORD /*dwReserved*/,
		/*[out]*/ BOOL* /*pfRenameCanContinue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterRenameProject)(
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ LPCOLESTR /*pszMkOldName*/,
		/*[in]*/ LPCOLESTR /*pszMkNewName*/,
		/*[in]*/ DWORD /*dwReserved*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveVirtualProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ VSREMOVEVPFLAGS /*grfRemoveVPFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateNewProjectViaDlg)(
		/*[in]*/ LPCOLESTR /*pszExpand*/,
		/*[in]*/ LPCOLESTR /*pszSelect*/,
		/*[in]*/ DWORD /*dwReserved*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetVirtualProjectFlags)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[out]*/ VSADDVPFLAGS* /*pgrfAddVPFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GenerateNextDefaultProjectName)(
		/*[in]*/ LPCOLESTR /*pszBaseName*/,
		/*[in]*/ LPCOLESTR /*pszLocation*/,
		/*[out]*/ BSTR* /*pbstrProjectName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProjectFilesInSolution)(
		/*[in]*/ VSGETPROJFILESFLAGS /*grfGetOpts*/,
		/*[in]*/ ULONG /*cProjects*/,
		/*[out,size_is(cProjects),length_is(*pcProjectsFetched)]*/ BSTR* /*rgbstrProjectNames*/,
		/*[out]*/ ULONG* /*pcProjectsFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanCreateNewProjectAtLocation)(
		/*[in]*/ BOOL /*fCreateNewSolution*/,
		/*[in]*/ LPCOLESTR /*pszFullProjectFilePath*/,
		/*[out]*/ BOOL* /*pfCanCreate*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSolutionMockImpl :
	public IVsSolution,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSolutionMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSolutionMockImpl)

	typedef IVsSolution Interface;
	struct GetProjectEnumValidValues
	{
		/*[in]*/ VSENUMPROJFLAGS grfEnumFlags;
		/*[in]*/ REFGUID rguidEnumOnlyThisType;
		/*[out]*/ IEnumHierarchies** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(GetProjectEnum)(
		/*[in]*/ VSENUMPROJFLAGS grfEnumFlags,
		/*[in]*/ REFGUID rguidEnumOnlyThisType,
		/*[out]*/ IEnumHierarchies** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(GetProjectEnum)

		VSL_CHECK_VALIDVALUE(grfEnumFlags);

		VSL_CHECK_VALIDVALUE(rguidEnumOnlyThisType);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateProjectValidValues
	{
		/*[in]*/ REFGUID rguidProjectType;
		/*[in]*/ LPCOLESTR lpszMoniker;
		/*[in]*/ LPCOLESTR lpszLocation;
		/*[in]*/ LPCOLESTR lpszName;
		/*[in]*/ VSCREATEPROJFLAGS grfCreateFlags;
		/*[in]*/ REFIID iidProject;
		/*[out,iid_is(iidProject)]*/ void** ppProject;
		HRESULT retValue;
	};

	STDMETHOD(CreateProject)(
		/*[in]*/ REFGUID rguidProjectType,
		/*[in]*/ LPCOLESTR lpszMoniker,
		/*[in]*/ LPCOLESTR lpszLocation,
		/*[in]*/ LPCOLESTR lpszName,
		/*[in]*/ VSCREATEPROJFLAGS grfCreateFlags,
		/*[in]*/ REFIID iidProject,
		/*[out,iid_is(iidProject)]*/ void** ppProject)
	{
		VSL_DEFINE_MOCK_METHOD(CreateProject)

		VSL_CHECK_VALIDVALUE(rguidProjectType);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszMoniker);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszLocation);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszName);

		VSL_CHECK_VALIDVALUE(grfCreateFlags);

		VSL_CHECK_VALIDVALUE(iidProject);

		VSL_SET_VALIDVALUE(ppProject);

		VSL_RETURN_VALIDVALUES();
	}
	struct GenerateUniqueProjectNameValidValues
	{
		/*[in]*/ LPCOLESTR lpszRoot;
		/*[out]*/ BSTR* pbstrProjectName;
		HRESULT retValue;
	};

	STDMETHOD(GenerateUniqueProjectName)(
		/*[in]*/ LPCOLESTR lpszRoot,
		/*[out]*/ BSTR* pbstrProjectName)
	{
		VSL_DEFINE_MOCK_METHOD(GenerateUniqueProjectName)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszRoot);

		VSL_SET_VALIDVALUE_BSTR(pbstrProjectName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProjectOfGuidValidValues
	{
		/*[in]*/ REFGUID rguidProjectID;
		/*[out]*/ IVsHierarchy** ppHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(GetProjectOfGuid)(
		/*[in]*/ REFGUID rguidProjectID,
		/*[out]*/ IVsHierarchy** ppHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(GetProjectOfGuid)

		VSL_CHECK_VALIDVALUE(rguidProjectID);

		VSL_SET_VALIDVALUE_INTERFACE(ppHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetGuidOfProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[out]*/ GUID* pguidProjectID;
		HRESULT retValue;
	};

	STDMETHOD(GetGuidOfProject)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[out]*/ GUID* pguidProjectID)
	{
		VSL_DEFINE_MOCK_METHOD(GetGuidOfProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_SET_VALIDVALUE(pguidProjectID);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSolutionInfoValidValues
	{
		/*[out]*/ BSTR* pbstrSolutionDirectory;
		/*[out]*/ BSTR* pbstrSolutionFile;
		/*[out]*/ BSTR* pbstrUserOptsFile;
		HRESULT retValue;
	};

	STDMETHOD(GetSolutionInfo)(
		/*[out]*/ BSTR* pbstrSolutionDirectory,
		/*[out]*/ BSTR* pbstrSolutionFile,
		/*[out]*/ BSTR* pbstrUserOptsFile)
	{
		VSL_DEFINE_MOCK_METHOD(GetSolutionInfo)

		VSL_SET_VALIDVALUE_BSTR(pbstrSolutionDirectory);

		VSL_SET_VALIDVALUE_BSTR(pbstrSolutionFile);

		VSL_SET_VALIDVALUE_BSTR(pbstrUserOptsFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct AdviseSolutionEventsValidValues
	{
		/*[in]*/ IVsSolutionEvents* pSink;
		/*[out]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(AdviseSolutionEvents)(
		/*[in]*/ IVsSolutionEvents* pSink,
		/*[out]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(AdviseSolutionEvents)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSink);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseSolutionEventsValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnadviseSolutionEvents)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnadviseSolutionEvents)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveSolutionElementValidValues
	{
		/*[in]*/ VSSLNSAVEOPTIONS grfSaveOpts;
		/*[in]*/ IVsHierarchy* pHier;
		/*[in]*/ VSCOOKIE docCookie;
		HRESULT retValue;
	};

	STDMETHOD(SaveSolutionElement)(
		/*[in]*/ VSSLNSAVEOPTIONS grfSaveOpts,
		/*[in]*/ IVsHierarchy* pHier,
		/*[in]*/ VSCOOKIE docCookie)
	{
		VSL_DEFINE_MOCK_METHOD(SaveSolutionElement)

		VSL_CHECK_VALIDVALUE(grfSaveOpts);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHier);

		VSL_CHECK_VALIDVALUE(docCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct CloseSolutionElementValidValues
	{
		/*[in]*/ VSSLNCLOSEOPTIONS grfCloseOpts;
		/*[in]*/ IVsHierarchy* pHier;
		/*[in]*/ VSCOOKIE docCookie;
		HRESULT retValue;
	};

	STDMETHOD(CloseSolutionElement)(
		/*[in]*/ VSSLNCLOSEOPTIONS grfCloseOpts,
		/*[in]*/ IVsHierarchy* pHier,
		/*[in]*/ VSCOOKIE docCookie)
	{
		VSL_DEFINE_MOCK_METHOD(CloseSolutionElement)

		VSL_CHECK_VALIDVALUE(grfCloseOpts);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHier);

		VSL_CHECK_VALIDVALUE(docCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProjectOfProjrefValidValues
	{
		/*[in]*/ LPCOLESTR pszProjref;
		/*[out]*/ IVsHierarchy** ppHierarchy;
		/*[out]*/ BSTR* pbstrUpdatedProjref;
		/*[out]*/ VSUPDATEPROJREFREASON* puprUpdateReason;
		HRESULT retValue;
	};

	STDMETHOD(GetProjectOfProjref)(
		/*[in]*/ LPCOLESTR pszProjref,
		/*[out]*/ IVsHierarchy** ppHierarchy,
		/*[out]*/ BSTR* pbstrUpdatedProjref,
		/*[out]*/ VSUPDATEPROJREFREASON* puprUpdateReason)
	{
		VSL_DEFINE_MOCK_METHOD(GetProjectOfProjref)

		VSL_CHECK_VALIDVALUE_STRINGW(pszProjref);

		VSL_SET_VALIDVALUE_INTERFACE(ppHierarchy);

		VSL_SET_VALIDVALUE_BSTR(pbstrUpdatedProjref);

		VSL_SET_VALIDVALUE(puprUpdateReason);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProjrefOfProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[out]*/ BSTR* pbstrProjref;
		HRESULT retValue;
	};

	STDMETHOD(GetProjrefOfProject)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[out]*/ BSTR* pbstrProjref)
	{
		VSL_DEFINE_MOCK_METHOD(GetProjrefOfProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_SET_VALIDVALUE_BSTR(pbstrProjref);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProjectInfoOfProjrefValidValues
	{
		/*[in]*/ LPCOLESTR pszProjref;
		/*[in]*/ VSHPROPID propid;
		/*[out]*/ VARIANT* pvar;
		HRESULT retValue;
	};

	STDMETHOD(GetProjectInfoOfProjref)(
		/*[in]*/ LPCOLESTR pszProjref,
		/*[in]*/ VSHPROPID propid,
		/*[out]*/ VARIANT* pvar)
	{
		VSL_DEFINE_MOCK_METHOD(GetProjectInfoOfProjref)

		VSL_CHECK_VALIDVALUE_STRINGW(pszProjref);

		VSL_CHECK_VALIDVALUE(propid);

		VSL_SET_VALIDVALUE_VARIANT(pvar);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddVirtualProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ VSADDVPFLAGS grfAddVPFlags;
		HRESULT retValue;
	};

	STDMETHOD(AddVirtualProject)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ VSADDVPFLAGS grfAddVPFlags)
	{
		VSL_DEFINE_MOCK_METHOD(AddVirtualProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE(grfAddVPFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetItemOfProjrefValidValues
	{
		/*[in]*/ LPCOLESTR pszProjref;
		/*[out]*/ IVsHierarchy** ppHierarchy;
		/*[out]*/ VSITEMID* pitemid;
		/*[out]*/ BSTR* pbstrUpdatedProjref;
		/*[out]*/ VSUPDATEPROJREFREASON* puprUpdateReason;
		HRESULT retValue;
	};

	STDMETHOD(GetItemOfProjref)(
		/*[in]*/ LPCOLESTR pszProjref,
		/*[out]*/ IVsHierarchy** ppHierarchy,
		/*[out]*/ VSITEMID* pitemid,
		/*[out]*/ BSTR* pbstrUpdatedProjref,
		/*[out]*/ VSUPDATEPROJREFREASON* puprUpdateReason)
	{
		VSL_DEFINE_MOCK_METHOD(GetItemOfProjref)

		VSL_CHECK_VALIDVALUE_STRINGW(pszProjref);

		VSL_SET_VALIDVALUE_INTERFACE(ppHierarchy);

		VSL_SET_VALIDVALUE(pitemid);

		VSL_SET_VALIDVALUE_BSTR(pbstrUpdatedProjref);

		VSL_SET_VALIDVALUE(puprUpdateReason);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProjrefOfItemValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ VSITEMID itemid;
		/*[out]*/ BSTR* pbstrProjref;
		HRESULT retValue;
	};

	STDMETHOD(GetProjrefOfItem)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ VSITEMID itemid,
		/*[out]*/ BSTR* pbstrProjref)
	{
		VSL_DEFINE_MOCK_METHOD(GetProjrefOfItem)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_SET_VALIDVALUE_BSTR(pbstrProjref);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetItemInfoOfProjrefValidValues
	{
		/*[in]*/ LPCOLESTR pszProjref;
		/*[in]*/ VSHPROPID propid;
		/*[out]*/ VARIANT* pvar;
		HRESULT retValue;
	};

	STDMETHOD(GetItemInfoOfProjref)(
		/*[in]*/ LPCOLESTR pszProjref,
		/*[in]*/ VSHPROPID propid,
		/*[out]*/ VARIANT* pvar)
	{
		VSL_DEFINE_MOCK_METHOD(GetItemInfoOfProjref)

		VSL_CHECK_VALIDVALUE_STRINGW(pszProjref);

		VSL_CHECK_VALIDVALUE(propid);

		VSL_SET_VALIDVALUE_VARIANT(pvar);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProjectOfUniqueNameValidValues
	{
		/*[in]*/ LPCOLESTR pszUniqueName;
		/*[out]*/ IVsHierarchy** ppHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(GetProjectOfUniqueName)(
		/*[in]*/ LPCOLESTR pszUniqueName,
		/*[out]*/ IVsHierarchy** ppHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(GetProjectOfUniqueName)

		VSL_CHECK_VALIDVALUE_STRINGW(pszUniqueName);

		VSL_SET_VALIDVALUE_INTERFACE(ppHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetUniqueNameOfProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[out]*/ BSTR* pbstrUniqueName;
		HRESULT retValue;
	};

	STDMETHOD(GetUniqueNameOfProject)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[out]*/ BSTR* pbstrUniqueName)
	{
		VSL_DEFINE_MOCK_METHOD(GetUniqueNameOfProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_SET_VALIDVALUE_BSTR(pbstrUniqueName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPropertyValidValues
	{
		/*[in]*/ VSPROPID propid;
		/*[out]*/ VARIANT* pvar;
		HRESULT retValue;
	};

	STDMETHOD(GetProperty)(
		/*[in]*/ VSPROPID propid,
		/*[out]*/ VARIANT* pvar)
	{
		VSL_DEFINE_MOCK_METHOD(GetProperty)

		VSL_CHECK_VALIDVALUE(propid);

		VSL_SET_VALIDVALUE_VARIANT(pvar);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetPropertyValidValues
	{
		/*[in]*/ VSPROPID propid;
		/*[in]*/ VARIANT var;
		HRESULT retValue;
	};

	STDMETHOD(SetProperty)(
		/*[in]*/ VSPROPID propid,
		/*[in]*/ VARIANT var)
	{
		VSL_DEFINE_MOCK_METHOD(SetProperty)

		VSL_CHECK_VALIDVALUE(propid);

		VSL_CHECK_VALIDVALUE(var);

		VSL_RETURN_VALIDVALUES();
	}
	struct OpenSolutionFileValidValues
	{
		/*[in]*/ VSSLNOPENOPTIONS grfOpenOpts;
		/*[in]*/ LPCOLESTR pszFilename;
		HRESULT retValue;
	};

	STDMETHOD(OpenSolutionFile)(
		/*[in]*/ VSSLNOPENOPTIONS grfOpenOpts,
		/*[in]*/ LPCOLESTR pszFilename)
	{
		VSL_DEFINE_MOCK_METHOD(OpenSolutionFile)

		VSL_CHECK_VALIDVALUE(grfOpenOpts);

		VSL_CHECK_VALIDVALUE_STRINGW(pszFilename);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryEditSolutionFileValidValues
	{
		/*[out]*/ DWORD* pdwEditResult;
		HRESULT retValue;
	};

	STDMETHOD(QueryEditSolutionFile)(
		/*[out]*/ DWORD* pdwEditResult)
	{
		VSL_DEFINE_MOCK_METHOD(QueryEditSolutionFile)

		VSL_SET_VALIDVALUE(pdwEditResult);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateSolutionValidValues
	{
		/*[in,unique]*/ LPCOLESTR lpszLocation;
		/*[in,unique]*/ LPCOLESTR lpszName;
		/*[in]*/ VSCREATESOLUTIONFLAGS grfCreateFlags;
		HRESULT retValue;
	};

	STDMETHOD(CreateSolution)(
		/*[in,unique]*/ LPCOLESTR lpszLocation,
		/*[in,unique]*/ LPCOLESTR lpszName,
		/*[in]*/ VSCREATESOLUTIONFLAGS grfCreateFlags)
	{
		VSL_DEFINE_MOCK_METHOD(CreateSolution)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszLocation);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszName);

		VSL_CHECK_VALIDVALUE(grfCreateFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProjectFactoryValidValues
	{
		/*[in]*/ DWORD dwReserved;
		/*[in,out]*/ GUID* pguidProjectType;
		/*[in]*/ LPCOLESTR pszMkProject;
		/*[out,retval]*/ IVsProjectFactory** ppProjectFactory;
		HRESULT retValue;
	};

	STDMETHOD(GetProjectFactory)(
		/*[in]*/ DWORD dwReserved,
		/*[in,out]*/ GUID* pguidProjectType,
		/*[in]*/ LPCOLESTR pszMkProject,
		/*[out,retval]*/ IVsProjectFactory** ppProjectFactory)
	{
		VSL_DEFINE_MOCK_METHOD(GetProjectFactory)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_SET_VALIDVALUE(pguidProjectType);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkProject);

		VSL_SET_VALIDVALUE_INTERFACE(ppProjectFactory);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProjectTypeGuidValidValues
	{
		/*[in]*/ DWORD dwReserved;
		/*[in]*/ LPCOLESTR pszMkProject;
		/*[out,retval]*/ GUID* pguidProjectType;
		HRESULT retValue;
	};

	STDMETHOD(GetProjectTypeGuid)(
		/*[in]*/ DWORD dwReserved,
		/*[in]*/ LPCOLESTR pszMkProject,
		/*[out,retval]*/ GUID* pguidProjectType)
	{
		VSL_DEFINE_MOCK_METHOD(GetProjectTypeGuid)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkProject);

		VSL_SET_VALIDVALUE(pguidProjectType);

		VSL_RETURN_VALIDVALUES();
	}
	struct OpenSolutionViaDlgValidValues
	{
		/*[in]*/ LPCOLESTR pszStartDirectory;
		/*[in]*/ BOOL fDefaultToAllProjectsFilter;
		HRESULT retValue;
	};

	STDMETHOD(OpenSolutionViaDlg)(
		/*[in]*/ LPCOLESTR pszStartDirectory,
		/*[in]*/ BOOL fDefaultToAllProjectsFilter)
	{
		VSL_DEFINE_MOCK_METHOD(OpenSolutionViaDlg)

		VSL_CHECK_VALIDVALUE_STRINGW(pszStartDirectory);

		VSL_CHECK_VALIDVALUE(fDefaultToAllProjectsFilter);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddVirtualProjectExValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ VSADDVPFLAGS grfAddVPFlags;
		/*[in]*/ REFGUID rguidProjectID;
		HRESULT retValue;
	};

	STDMETHOD(AddVirtualProjectEx)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ VSADDVPFLAGS grfAddVPFlags,
		/*[in]*/ REFGUID rguidProjectID)
	{
		VSL_DEFINE_MOCK_METHOD(AddVirtualProjectEx)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE(grfAddVPFlags);

		VSL_CHECK_VALIDVALUE(rguidProjectID);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryRenameProjectValidValues
	{
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ LPCOLESTR pszMkOldName;
		/*[in]*/ LPCOLESTR pszMkNewName;
		/*[in]*/ DWORD dwReserved;
		/*[out]*/ BOOL* pfRenameCanContinue;
		HRESULT retValue;
	};

	STDMETHOD(QueryRenameProject)(
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ LPCOLESTR pszMkOldName,
		/*[in]*/ LPCOLESTR pszMkNewName,
		/*[in]*/ DWORD dwReserved,
		/*[out]*/ BOOL* pfRenameCanContinue)
	{
		VSL_DEFINE_MOCK_METHOD(QueryRenameProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkOldName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkNewName);

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_SET_VALIDVALUE(pfRenameCanContinue);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterRenameProjectValidValues
	{
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ LPCOLESTR pszMkOldName;
		/*[in]*/ LPCOLESTR pszMkNewName;
		/*[in]*/ DWORD dwReserved;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterRenameProject)(
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ LPCOLESTR pszMkOldName,
		/*[in]*/ LPCOLESTR pszMkNewName,
		/*[in]*/ DWORD dwReserved)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterRenameProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkOldName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkNewName);

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveVirtualProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ VSREMOVEVPFLAGS grfRemoveVPFlags;
		HRESULT retValue;
	};

	STDMETHOD(RemoveVirtualProject)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ VSREMOVEVPFLAGS grfRemoveVPFlags)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveVirtualProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE(grfRemoveVPFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateNewProjectViaDlgValidValues
	{
		/*[in]*/ LPCOLESTR pszExpand;
		/*[in]*/ LPCOLESTR pszSelect;
		/*[in]*/ DWORD dwReserved;
		HRESULT retValue;
	};

	STDMETHOD(CreateNewProjectViaDlg)(
		/*[in]*/ LPCOLESTR pszExpand,
		/*[in]*/ LPCOLESTR pszSelect,
		/*[in]*/ DWORD dwReserved)
	{
		VSL_DEFINE_MOCK_METHOD(CreateNewProjectViaDlg)

		VSL_CHECK_VALIDVALUE_STRINGW(pszExpand);

		VSL_CHECK_VALIDVALUE_STRINGW(pszSelect);

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetVirtualProjectFlagsValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[out]*/ VSADDVPFLAGS* pgrfAddVPFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetVirtualProjectFlags)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[out]*/ VSADDVPFLAGS* pgrfAddVPFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetVirtualProjectFlags)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_SET_VALIDVALUE(pgrfAddVPFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GenerateNextDefaultProjectNameValidValues
	{
		/*[in]*/ LPCOLESTR pszBaseName;
		/*[in]*/ LPCOLESTR pszLocation;
		/*[out]*/ BSTR* pbstrProjectName;
		HRESULT retValue;
	};

	STDMETHOD(GenerateNextDefaultProjectName)(
		/*[in]*/ LPCOLESTR pszBaseName,
		/*[in]*/ LPCOLESTR pszLocation,
		/*[out]*/ BSTR* pbstrProjectName)
	{
		VSL_DEFINE_MOCK_METHOD(GenerateNextDefaultProjectName)

		VSL_CHECK_VALIDVALUE_STRINGW(pszBaseName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszLocation);

		VSL_SET_VALIDVALUE_BSTR(pbstrProjectName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProjectFilesInSolutionValidValues
	{
		/*[in]*/ VSGETPROJFILESFLAGS grfGetOpts;
		/*[in]*/ ULONG cProjects;
		/*[out,size_is(cProjects),length_is(*pcProjectsFetched)]*/ BSTR* rgbstrProjectNames;
		/*[out]*/ ULONG* pcProjectsFetched;
		HRESULT retValue;
	};

	STDMETHOD(GetProjectFilesInSolution)(
		/*[in]*/ VSGETPROJFILESFLAGS grfGetOpts,
		/*[in]*/ ULONG cProjects,
		/*[out,size_is(cProjects),length_is(*pcProjectsFetched)]*/ BSTR* rgbstrProjectNames,
		/*[out]*/ ULONG* pcProjectsFetched)
	{
		VSL_DEFINE_MOCK_METHOD(GetProjectFilesInSolution)

		VSL_CHECK_VALIDVALUE(grfGetOpts);

		VSL_CHECK_VALIDVALUE(cProjects);

		VSL_SET_VALIDVALUE_MEMCPY(rgbstrProjectNames, cProjects*sizeof(rgbstrProjectNames[0]), *(validValues.pcProjectsFetched)*sizeof(validValues.rgbstrProjectNames[0]));

		VSL_SET_VALIDVALUE(pcProjectsFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct CanCreateNewProjectAtLocationValidValues
	{
		/*[in]*/ BOOL fCreateNewSolution;
		/*[in]*/ LPCOLESTR pszFullProjectFilePath;
		/*[out]*/ BOOL* pfCanCreate;
		HRESULT retValue;
	};

	STDMETHOD(CanCreateNewProjectAtLocation)(
		/*[in]*/ BOOL fCreateNewSolution,
		/*[in]*/ LPCOLESTR pszFullProjectFilePath,
		/*[out]*/ BOOL* pfCanCreate)
	{
		VSL_DEFINE_MOCK_METHOD(CanCreateNewProjectAtLocation)

		VSL_CHECK_VALIDVALUE(fCreateNewSolution);

		VSL_CHECK_VALIDVALUE_STRINGW(pszFullProjectFilePath);

		VSL_SET_VALIDVALUE(pfCanCreate);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSOLUTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSolution2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSOLUTION2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSOLUTION2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSolution2NotImpl :
	public IVsSolution2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSolution2NotImpl)

public:

	typedef IVsSolution2 Interface;

	STDMETHOD(UpdateProjectFileLocation)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProjectEnum)(
		/*[in]*/ VSENUMPROJFLAGS /*grfEnumFlags*/,
		/*[in]*/ REFGUID /*rguidEnumOnlyThisType*/,
		/*[out]*/ IEnumHierarchies** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateProject)(
		/*[in]*/ REFGUID /*rguidProjectType*/,
		/*[in]*/ LPCOLESTR /*lpszMoniker*/,
		/*[in]*/ LPCOLESTR /*lpszLocation*/,
		/*[in]*/ LPCOLESTR /*lpszName*/,
		/*[in]*/ VSCREATEPROJFLAGS /*grfCreateFlags*/,
		/*[in]*/ REFIID /*iidProject*/,
		/*[out,iid_is(iidProject)]*/ void** /*ppProject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GenerateUniqueProjectName)(
		/*[in]*/ LPCOLESTR /*lpszRoot*/,
		/*[out]*/ BSTR* /*pbstrProjectName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProjectOfGuid)(
		/*[in]*/ REFGUID /*rguidProjectID*/,
		/*[out]*/ IVsHierarchy** /*ppHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetGuidOfProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[out]*/ GUID* /*pguidProjectID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSolutionInfo)(
		/*[out]*/ BSTR* /*pbstrSolutionDirectory*/,
		/*[out]*/ BSTR* /*pbstrSolutionFile*/,
		/*[out]*/ BSTR* /*pbstrUserOptsFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AdviseSolutionEvents)(
		/*[in]*/ IVsSolutionEvents* /*pSink*/,
		/*[out]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseSolutionEvents)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SaveSolutionElement)(
		/*[in]*/ VSSLNSAVEOPTIONS /*grfSaveOpts*/,
		/*[in]*/ IVsHierarchy* /*pHier*/,
		/*[in]*/ VSCOOKIE /*docCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CloseSolutionElement)(
		/*[in]*/ VSSLNCLOSEOPTIONS /*grfCloseOpts*/,
		/*[in]*/ IVsHierarchy* /*pHier*/,
		/*[in]*/ VSCOOKIE /*docCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProjectOfProjref)(
		/*[in]*/ LPCOLESTR /*pszProjref*/,
		/*[out]*/ IVsHierarchy** /*ppHierarchy*/,
		/*[out]*/ BSTR* /*pbstrUpdatedProjref*/,
		/*[out]*/ VSUPDATEPROJREFREASON* /*puprUpdateReason*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProjrefOfProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[out]*/ BSTR* /*pbstrProjref*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProjectInfoOfProjref)(
		/*[in]*/ LPCOLESTR /*pszProjref*/,
		/*[in]*/ VSHPROPID /*propid*/,
		/*[out]*/ VARIANT* /*pvar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddVirtualProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ VSADDVPFLAGS /*grfAddVPFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetItemOfProjref)(
		/*[in]*/ LPCOLESTR /*pszProjref*/,
		/*[out]*/ IVsHierarchy** /*ppHierarchy*/,
		/*[out]*/ VSITEMID* /*pitemid*/,
		/*[out]*/ BSTR* /*pbstrUpdatedProjref*/,
		/*[out]*/ VSUPDATEPROJREFREASON* /*puprUpdateReason*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProjrefOfItem)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[out]*/ BSTR* /*pbstrProjref*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetItemInfoOfProjref)(
		/*[in]*/ LPCOLESTR /*pszProjref*/,
		/*[in]*/ VSHPROPID /*propid*/,
		/*[out]*/ VARIANT* /*pvar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProjectOfUniqueName)(
		/*[in]*/ LPCOLESTR /*pszUniqueName*/,
		/*[out]*/ IVsHierarchy** /*ppHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetUniqueNameOfProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[out]*/ BSTR* /*pbstrUniqueName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProperty)(
		/*[in]*/ VSPROPID /*propid*/,
		/*[out]*/ VARIANT* /*pvar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetProperty)(
		/*[in]*/ VSPROPID /*propid*/,
		/*[in]*/ VARIANT /*var*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OpenSolutionFile)(
		/*[in]*/ VSSLNOPENOPTIONS /*grfOpenOpts*/,
		/*[in]*/ LPCOLESTR /*pszFilename*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryEditSolutionFile)(
		/*[out]*/ DWORD* /*pdwEditResult*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateSolution)(
		/*[in,unique]*/ LPCOLESTR /*lpszLocation*/,
		/*[in,unique]*/ LPCOLESTR /*lpszName*/,
		/*[in]*/ VSCREATESOLUTIONFLAGS /*grfCreateFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProjectFactory)(
		/*[in]*/ DWORD /*dwReserved*/,
		/*[in,out]*/ GUID* /*pguidProjectType*/,
		/*[in]*/ LPCOLESTR /*pszMkProject*/,
		/*[out,retval]*/ IVsProjectFactory** /*ppProjectFactory*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProjectTypeGuid)(
		/*[in]*/ DWORD /*dwReserved*/,
		/*[in]*/ LPCOLESTR /*pszMkProject*/,
		/*[out,retval]*/ GUID* /*pguidProjectType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OpenSolutionViaDlg)(
		/*[in]*/ LPCOLESTR /*pszStartDirectory*/,
		/*[in]*/ BOOL /*fDefaultToAllProjectsFilter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddVirtualProjectEx)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ VSADDVPFLAGS /*grfAddVPFlags*/,
		/*[in]*/ REFGUID /*rguidProjectID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryRenameProject)(
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ LPCOLESTR /*pszMkOldName*/,
		/*[in]*/ LPCOLESTR /*pszMkNewName*/,
		/*[in]*/ DWORD /*dwReserved*/,
		/*[out]*/ BOOL* /*pfRenameCanContinue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterRenameProject)(
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ LPCOLESTR /*pszMkOldName*/,
		/*[in]*/ LPCOLESTR /*pszMkNewName*/,
		/*[in]*/ DWORD /*dwReserved*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveVirtualProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ VSREMOVEVPFLAGS /*grfRemoveVPFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateNewProjectViaDlg)(
		/*[in]*/ LPCOLESTR /*pszExpand*/,
		/*[in]*/ LPCOLESTR /*pszSelect*/,
		/*[in]*/ DWORD /*dwReserved*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetVirtualProjectFlags)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[out]*/ VSADDVPFLAGS* /*pgrfAddVPFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GenerateNextDefaultProjectName)(
		/*[in]*/ LPCOLESTR /*pszBaseName*/,
		/*[in]*/ LPCOLESTR /*pszLocation*/,
		/*[out]*/ BSTR* /*pbstrProjectName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProjectFilesInSolution)(
		/*[in]*/ VSGETPROJFILESFLAGS /*grfGetOpts*/,
		/*[in]*/ ULONG /*cProjects*/,
		/*[out,size_is(cProjects),length_is(*pcProjectsFetched)]*/ BSTR* /*rgbstrProjectNames*/,
		/*[out]*/ ULONG* /*pcProjectsFetched*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanCreateNewProjectAtLocation)(
		/*[in]*/ BOOL /*fCreateNewSolution*/,
		/*[in]*/ LPCOLESTR /*pszFullProjectFilePath*/,
		/*[out]*/ BOOL* /*pfCanCreate*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSolution2MockImpl :
	public IVsSolution2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSolution2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSolution2MockImpl)

	typedef IVsSolution2 Interface;
	struct UpdateProjectFileLocationValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(UpdateProjectFileLocation)(
		/*[in]*/ IVsHierarchy* pHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateProjectFileLocation)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProjectEnumValidValues
	{
		/*[in]*/ VSENUMPROJFLAGS grfEnumFlags;
		/*[in]*/ REFGUID rguidEnumOnlyThisType;
		/*[out]*/ IEnumHierarchies** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(GetProjectEnum)(
		/*[in]*/ VSENUMPROJFLAGS grfEnumFlags,
		/*[in]*/ REFGUID rguidEnumOnlyThisType,
		/*[out]*/ IEnumHierarchies** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(GetProjectEnum)

		VSL_CHECK_VALIDVALUE(grfEnumFlags);

		VSL_CHECK_VALIDVALUE(rguidEnumOnlyThisType);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateProjectValidValues
	{
		/*[in]*/ REFGUID rguidProjectType;
		/*[in]*/ LPCOLESTR lpszMoniker;
		/*[in]*/ LPCOLESTR lpszLocation;
		/*[in]*/ LPCOLESTR lpszName;
		/*[in]*/ VSCREATEPROJFLAGS grfCreateFlags;
		/*[in]*/ REFIID iidProject;
		/*[out,iid_is(iidProject)]*/ void** ppProject;
		HRESULT retValue;
	};

	STDMETHOD(CreateProject)(
		/*[in]*/ REFGUID rguidProjectType,
		/*[in]*/ LPCOLESTR lpszMoniker,
		/*[in]*/ LPCOLESTR lpszLocation,
		/*[in]*/ LPCOLESTR lpszName,
		/*[in]*/ VSCREATEPROJFLAGS grfCreateFlags,
		/*[in]*/ REFIID iidProject,
		/*[out,iid_is(iidProject)]*/ void** ppProject)
	{
		VSL_DEFINE_MOCK_METHOD(CreateProject)

		VSL_CHECK_VALIDVALUE(rguidProjectType);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszMoniker);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszLocation);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszName);

		VSL_CHECK_VALIDVALUE(grfCreateFlags);

		VSL_CHECK_VALIDVALUE(iidProject);

		VSL_SET_VALIDVALUE(ppProject);

		VSL_RETURN_VALIDVALUES();
	}
	struct GenerateUniqueProjectNameValidValues
	{
		/*[in]*/ LPCOLESTR lpszRoot;
		/*[out]*/ BSTR* pbstrProjectName;
		HRESULT retValue;
	};

	STDMETHOD(GenerateUniqueProjectName)(
		/*[in]*/ LPCOLESTR lpszRoot,
		/*[out]*/ BSTR* pbstrProjectName)
	{
		VSL_DEFINE_MOCK_METHOD(GenerateUniqueProjectName)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszRoot);

		VSL_SET_VALIDVALUE_BSTR(pbstrProjectName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProjectOfGuidValidValues
	{
		/*[in]*/ REFGUID rguidProjectID;
		/*[out]*/ IVsHierarchy** ppHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(GetProjectOfGuid)(
		/*[in]*/ REFGUID rguidProjectID,
		/*[out]*/ IVsHierarchy** ppHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(GetProjectOfGuid)

		VSL_CHECK_VALIDVALUE(rguidProjectID);

		VSL_SET_VALIDVALUE_INTERFACE(ppHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetGuidOfProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[out]*/ GUID* pguidProjectID;
		HRESULT retValue;
	};

	STDMETHOD(GetGuidOfProject)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[out]*/ GUID* pguidProjectID)
	{
		VSL_DEFINE_MOCK_METHOD(GetGuidOfProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_SET_VALIDVALUE(pguidProjectID);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSolutionInfoValidValues
	{
		/*[out]*/ BSTR* pbstrSolutionDirectory;
		/*[out]*/ BSTR* pbstrSolutionFile;
		/*[out]*/ BSTR* pbstrUserOptsFile;
		HRESULT retValue;
	};

	STDMETHOD(GetSolutionInfo)(
		/*[out]*/ BSTR* pbstrSolutionDirectory,
		/*[out]*/ BSTR* pbstrSolutionFile,
		/*[out]*/ BSTR* pbstrUserOptsFile)
	{
		VSL_DEFINE_MOCK_METHOD(GetSolutionInfo)

		VSL_SET_VALIDVALUE_BSTR(pbstrSolutionDirectory);

		VSL_SET_VALIDVALUE_BSTR(pbstrSolutionFile);

		VSL_SET_VALIDVALUE_BSTR(pbstrUserOptsFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct AdviseSolutionEventsValidValues
	{
		/*[in]*/ IVsSolutionEvents* pSink;
		/*[out]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(AdviseSolutionEvents)(
		/*[in]*/ IVsSolutionEvents* pSink,
		/*[out]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(AdviseSolutionEvents)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSink);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseSolutionEventsValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnadviseSolutionEvents)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnadviseSolutionEvents)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveSolutionElementValidValues
	{
		/*[in]*/ VSSLNSAVEOPTIONS grfSaveOpts;
		/*[in]*/ IVsHierarchy* pHier;
		/*[in]*/ VSCOOKIE docCookie;
		HRESULT retValue;
	};

	STDMETHOD(SaveSolutionElement)(
		/*[in]*/ VSSLNSAVEOPTIONS grfSaveOpts,
		/*[in]*/ IVsHierarchy* pHier,
		/*[in]*/ VSCOOKIE docCookie)
	{
		VSL_DEFINE_MOCK_METHOD(SaveSolutionElement)

		VSL_CHECK_VALIDVALUE(grfSaveOpts);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHier);

		VSL_CHECK_VALIDVALUE(docCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct CloseSolutionElementValidValues
	{
		/*[in]*/ VSSLNCLOSEOPTIONS grfCloseOpts;
		/*[in]*/ IVsHierarchy* pHier;
		/*[in]*/ VSCOOKIE docCookie;
		HRESULT retValue;
	};

	STDMETHOD(CloseSolutionElement)(
		/*[in]*/ VSSLNCLOSEOPTIONS grfCloseOpts,
		/*[in]*/ IVsHierarchy* pHier,
		/*[in]*/ VSCOOKIE docCookie)
	{
		VSL_DEFINE_MOCK_METHOD(CloseSolutionElement)

		VSL_CHECK_VALIDVALUE(grfCloseOpts);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHier);

		VSL_CHECK_VALIDVALUE(docCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProjectOfProjrefValidValues
	{
		/*[in]*/ LPCOLESTR pszProjref;
		/*[out]*/ IVsHierarchy** ppHierarchy;
		/*[out]*/ BSTR* pbstrUpdatedProjref;
		/*[out]*/ VSUPDATEPROJREFREASON* puprUpdateReason;
		HRESULT retValue;
	};

	STDMETHOD(GetProjectOfProjref)(
		/*[in]*/ LPCOLESTR pszProjref,
		/*[out]*/ IVsHierarchy** ppHierarchy,
		/*[out]*/ BSTR* pbstrUpdatedProjref,
		/*[out]*/ VSUPDATEPROJREFREASON* puprUpdateReason)
	{
		VSL_DEFINE_MOCK_METHOD(GetProjectOfProjref)

		VSL_CHECK_VALIDVALUE_STRINGW(pszProjref);

		VSL_SET_VALIDVALUE_INTERFACE(ppHierarchy);

		VSL_SET_VALIDVALUE_BSTR(pbstrUpdatedProjref);

		VSL_SET_VALIDVALUE(puprUpdateReason);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProjrefOfProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[out]*/ BSTR* pbstrProjref;
		HRESULT retValue;
	};

	STDMETHOD(GetProjrefOfProject)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[out]*/ BSTR* pbstrProjref)
	{
		VSL_DEFINE_MOCK_METHOD(GetProjrefOfProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_SET_VALIDVALUE_BSTR(pbstrProjref);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProjectInfoOfProjrefValidValues
	{
		/*[in]*/ LPCOLESTR pszProjref;
		/*[in]*/ VSHPROPID propid;
		/*[out]*/ VARIANT* pvar;
		HRESULT retValue;
	};

	STDMETHOD(GetProjectInfoOfProjref)(
		/*[in]*/ LPCOLESTR pszProjref,
		/*[in]*/ VSHPROPID propid,
		/*[out]*/ VARIANT* pvar)
	{
		VSL_DEFINE_MOCK_METHOD(GetProjectInfoOfProjref)

		VSL_CHECK_VALIDVALUE_STRINGW(pszProjref);

		VSL_CHECK_VALIDVALUE(propid);

		VSL_SET_VALIDVALUE_VARIANT(pvar);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddVirtualProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ VSADDVPFLAGS grfAddVPFlags;
		HRESULT retValue;
	};

	STDMETHOD(AddVirtualProject)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ VSADDVPFLAGS grfAddVPFlags)
	{
		VSL_DEFINE_MOCK_METHOD(AddVirtualProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE(grfAddVPFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetItemOfProjrefValidValues
	{
		/*[in]*/ LPCOLESTR pszProjref;
		/*[out]*/ IVsHierarchy** ppHierarchy;
		/*[out]*/ VSITEMID* pitemid;
		/*[out]*/ BSTR* pbstrUpdatedProjref;
		/*[out]*/ VSUPDATEPROJREFREASON* puprUpdateReason;
		HRESULT retValue;
	};

	STDMETHOD(GetItemOfProjref)(
		/*[in]*/ LPCOLESTR pszProjref,
		/*[out]*/ IVsHierarchy** ppHierarchy,
		/*[out]*/ VSITEMID* pitemid,
		/*[out]*/ BSTR* pbstrUpdatedProjref,
		/*[out]*/ VSUPDATEPROJREFREASON* puprUpdateReason)
	{
		VSL_DEFINE_MOCK_METHOD(GetItemOfProjref)

		VSL_CHECK_VALIDVALUE_STRINGW(pszProjref);

		VSL_SET_VALIDVALUE_INTERFACE(ppHierarchy);

		VSL_SET_VALIDVALUE(pitemid);

		VSL_SET_VALIDVALUE_BSTR(pbstrUpdatedProjref);

		VSL_SET_VALIDVALUE(puprUpdateReason);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProjrefOfItemValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ VSITEMID itemid;
		/*[out]*/ BSTR* pbstrProjref;
		HRESULT retValue;
	};

	STDMETHOD(GetProjrefOfItem)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ VSITEMID itemid,
		/*[out]*/ BSTR* pbstrProjref)
	{
		VSL_DEFINE_MOCK_METHOD(GetProjrefOfItem)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_SET_VALIDVALUE_BSTR(pbstrProjref);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetItemInfoOfProjrefValidValues
	{
		/*[in]*/ LPCOLESTR pszProjref;
		/*[in]*/ VSHPROPID propid;
		/*[out]*/ VARIANT* pvar;
		HRESULT retValue;
	};

	STDMETHOD(GetItemInfoOfProjref)(
		/*[in]*/ LPCOLESTR pszProjref,
		/*[in]*/ VSHPROPID propid,
		/*[out]*/ VARIANT* pvar)
	{
		VSL_DEFINE_MOCK_METHOD(GetItemInfoOfProjref)

		VSL_CHECK_VALIDVALUE_STRINGW(pszProjref);

		VSL_CHECK_VALIDVALUE(propid);

		VSL_SET_VALIDVALUE_VARIANT(pvar);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProjectOfUniqueNameValidValues
	{
		/*[in]*/ LPCOLESTR pszUniqueName;
		/*[out]*/ IVsHierarchy** ppHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(GetProjectOfUniqueName)(
		/*[in]*/ LPCOLESTR pszUniqueName,
		/*[out]*/ IVsHierarchy** ppHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(GetProjectOfUniqueName)

		VSL_CHECK_VALIDVALUE_STRINGW(pszUniqueName);

		VSL_SET_VALIDVALUE_INTERFACE(ppHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetUniqueNameOfProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[out]*/ BSTR* pbstrUniqueName;
		HRESULT retValue;
	};

	STDMETHOD(GetUniqueNameOfProject)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[out]*/ BSTR* pbstrUniqueName)
	{
		VSL_DEFINE_MOCK_METHOD(GetUniqueNameOfProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_SET_VALIDVALUE_BSTR(pbstrUniqueName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPropertyValidValues
	{
		/*[in]*/ VSPROPID propid;
		/*[out]*/ VARIANT* pvar;
		HRESULT retValue;
	};

	STDMETHOD(GetProperty)(
		/*[in]*/ VSPROPID propid,
		/*[out]*/ VARIANT* pvar)
	{
		VSL_DEFINE_MOCK_METHOD(GetProperty)

		VSL_CHECK_VALIDVALUE(propid);

		VSL_SET_VALIDVALUE_VARIANT(pvar);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetPropertyValidValues
	{
		/*[in]*/ VSPROPID propid;
		/*[in]*/ VARIANT var;
		HRESULT retValue;
	};

	STDMETHOD(SetProperty)(
		/*[in]*/ VSPROPID propid,
		/*[in]*/ VARIANT var)
	{
		VSL_DEFINE_MOCK_METHOD(SetProperty)

		VSL_CHECK_VALIDVALUE(propid);

		VSL_CHECK_VALIDVALUE(var);

		VSL_RETURN_VALIDVALUES();
	}
	struct OpenSolutionFileValidValues
	{
		/*[in]*/ VSSLNOPENOPTIONS grfOpenOpts;
		/*[in]*/ LPCOLESTR pszFilename;
		HRESULT retValue;
	};

	STDMETHOD(OpenSolutionFile)(
		/*[in]*/ VSSLNOPENOPTIONS grfOpenOpts,
		/*[in]*/ LPCOLESTR pszFilename)
	{
		VSL_DEFINE_MOCK_METHOD(OpenSolutionFile)

		VSL_CHECK_VALIDVALUE(grfOpenOpts);

		VSL_CHECK_VALIDVALUE_STRINGW(pszFilename);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryEditSolutionFileValidValues
	{
		/*[out]*/ DWORD* pdwEditResult;
		HRESULT retValue;
	};

	STDMETHOD(QueryEditSolutionFile)(
		/*[out]*/ DWORD* pdwEditResult)
	{
		VSL_DEFINE_MOCK_METHOD(QueryEditSolutionFile)

		VSL_SET_VALIDVALUE(pdwEditResult);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateSolutionValidValues
	{
		/*[in,unique]*/ LPCOLESTR lpszLocation;
		/*[in,unique]*/ LPCOLESTR lpszName;
		/*[in]*/ VSCREATESOLUTIONFLAGS grfCreateFlags;
		HRESULT retValue;
	};

	STDMETHOD(CreateSolution)(
		/*[in,unique]*/ LPCOLESTR lpszLocation,
		/*[in,unique]*/ LPCOLESTR lpszName,
		/*[in]*/ VSCREATESOLUTIONFLAGS grfCreateFlags)
	{
		VSL_DEFINE_MOCK_METHOD(CreateSolution)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszLocation);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszName);

		VSL_CHECK_VALIDVALUE(grfCreateFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProjectFactoryValidValues
	{
		/*[in]*/ DWORD dwReserved;
		/*[in,out]*/ GUID* pguidProjectType;
		/*[in]*/ LPCOLESTR pszMkProject;
		/*[out,retval]*/ IVsProjectFactory** ppProjectFactory;
		HRESULT retValue;
	};

	STDMETHOD(GetProjectFactory)(
		/*[in]*/ DWORD dwReserved,
		/*[in,out]*/ GUID* pguidProjectType,
		/*[in]*/ LPCOLESTR pszMkProject,
		/*[out,retval]*/ IVsProjectFactory** ppProjectFactory)
	{
		VSL_DEFINE_MOCK_METHOD(GetProjectFactory)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_SET_VALIDVALUE(pguidProjectType);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkProject);

		VSL_SET_VALIDVALUE_INTERFACE(ppProjectFactory);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProjectTypeGuidValidValues
	{
		/*[in]*/ DWORD dwReserved;
		/*[in]*/ LPCOLESTR pszMkProject;
		/*[out,retval]*/ GUID* pguidProjectType;
		HRESULT retValue;
	};

	STDMETHOD(GetProjectTypeGuid)(
		/*[in]*/ DWORD dwReserved,
		/*[in]*/ LPCOLESTR pszMkProject,
		/*[out,retval]*/ GUID* pguidProjectType)
	{
		VSL_DEFINE_MOCK_METHOD(GetProjectTypeGuid)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkProject);

		VSL_SET_VALIDVALUE(pguidProjectType);

		VSL_RETURN_VALIDVALUES();
	}
	struct OpenSolutionViaDlgValidValues
	{
		/*[in]*/ LPCOLESTR pszStartDirectory;
		/*[in]*/ BOOL fDefaultToAllProjectsFilter;
		HRESULT retValue;
	};

	STDMETHOD(OpenSolutionViaDlg)(
		/*[in]*/ LPCOLESTR pszStartDirectory,
		/*[in]*/ BOOL fDefaultToAllProjectsFilter)
	{
		VSL_DEFINE_MOCK_METHOD(OpenSolutionViaDlg)

		VSL_CHECK_VALIDVALUE_STRINGW(pszStartDirectory);

		VSL_CHECK_VALIDVALUE(fDefaultToAllProjectsFilter);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddVirtualProjectExValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ VSADDVPFLAGS grfAddVPFlags;
		/*[in]*/ REFGUID rguidProjectID;
		HRESULT retValue;
	};

	STDMETHOD(AddVirtualProjectEx)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ VSADDVPFLAGS grfAddVPFlags,
		/*[in]*/ REFGUID rguidProjectID)
	{
		VSL_DEFINE_MOCK_METHOD(AddVirtualProjectEx)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE(grfAddVPFlags);

		VSL_CHECK_VALIDVALUE(rguidProjectID);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryRenameProjectValidValues
	{
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ LPCOLESTR pszMkOldName;
		/*[in]*/ LPCOLESTR pszMkNewName;
		/*[in]*/ DWORD dwReserved;
		/*[out]*/ BOOL* pfRenameCanContinue;
		HRESULT retValue;
	};

	STDMETHOD(QueryRenameProject)(
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ LPCOLESTR pszMkOldName,
		/*[in]*/ LPCOLESTR pszMkNewName,
		/*[in]*/ DWORD dwReserved,
		/*[out]*/ BOOL* pfRenameCanContinue)
	{
		VSL_DEFINE_MOCK_METHOD(QueryRenameProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkOldName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkNewName);

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_SET_VALIDVALUE(pfRenameCanContinue);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterRenameProjectValidValues
	{
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ LPCOLESTR pszMkOldName;
		/*[in]*/ LPCOLESTR pszMkNewName;
		/*[in]*/ DWORD dwReserved;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterRenameProject)(
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ LPCOLESTR pszMkOldName,
		/*[in]*/ LPCOLESTR pszMkNewName,
		/*[in]*/ DWORD dwReserved)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterRenameProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkOldName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkNewName);

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveVirtualProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ VSREMOVEVPFLAGS grfRemoveVPFlags;
		HRESULT retValue;
	};

	STDMETHOD(RemoveVirtualProject)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ VSREMOVEVPFLAGS grfRemoveVPFlags)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveVirtualProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE(grfRemoveVPFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateNewProjectViaDlgValidValues
	{
		/*[in]*/ LPCOLESTR pszExpand;
		/*[in]*/ LPCOLESTR pszSelect;
		/*[in]*/ DWORD dwReserved;
		HRESULT retValue;
	};

	STDMETHOD(CreateNewProjectViaDlg)(
		/*[in]*/ LPCOLESTR pszExpand,
		/*[in]*/ LPCOLESTR pszSelect,
		/*[in]*/ DWORD dwReserved)
	{
		VSL_DEFINE_MOCK_METHOD(CreateNewProjectViaDlg)

		VSL_CHECK_VALIDVALUE_STRINGW(pszExpand);

		VSL_CHECK_VALIDVALUE_STRINGW(pszSelect);

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetVirtualProjectFlagsValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[out]*/ VSADDVPFLAGS* pgrfAddVPFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetVirtualProjectFlags)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[out]*/ VSADDVPFLAGS* pgrfAddVPFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetVirtualProjectFlags)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_SET_VALIDVALUE(pgrfAddVPFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GenerateNextDefaultProjectNameValidValues
	{
		/*[in]*/ LPCOLESTR pszBaseName;
		/*[in]*/ LPCOLESTR pszLocation;
		/*[out]*/ BSTR* pbstrProjectName;
		HRESULT retValue;
	};

	STDMETHOD(GenerateNextDefaultProjectName)(
		/*[in]*/ LPCOLESTR pszBaseName,
		/*[in]*/ LPCOLESTR pszLocation,
		/*[out]*/ BSTR* pbstrProjectName)
	{
		VSL_DEFINE_MOCK_METHOD(GenerateNextDefaultProjectName)

		VSL_CHECK_VALIDVALUE_STRINGW(pszBaseName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszLocation);

		VSL_SET_VALIDVALUE_BSTR(pbstrProjectName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProjectFilesInSolutionValidValues
	{
		/*[in]*/ VSGETPROJFILESFLAGS grfGetOpts;
		/*[in]*/ ULONG cProjects;
		/*[out,size_is(cProjects),length_is(*pcProjectsFetched)]*/ BSTR* rgbstrProjectNames;
		/*[out]*/ ULONG* pcProjectsFetched;
		HRESULT retValue;
	};

	STDMETHOD(GetProjectFilesInSolution)(
		/*[in]*/ VSGETPROJFILESFLAGS grfGetOpts,
		/*[in]*/ ULONG cProjects,
		/*[out,size_is(cProjects),length_is(*pcProjectsFetched)]*/ BSTR* rgbstrProjectNames,
		/*[out]*/ ULONG* pcProjectsFetched)
	{
		VSL_DEFINE_MOCK_METHOD(GetProjectFilesInSolution)

		VSL_CHECK_VALIDVALUE(grfGetOpts);

		VSL_CHECK_VALIDVALUE(cProjects);

		VSL_SET_VALIDVALUE_MEMCPY(rgbstrProjectNames, cProjects*sizeof(rgbstrProjectNames[0]), *(validValues.pcProjectsFetched)*sizeof(validValues.rgbstrProjectNames[0]));

		VSL_SET_VALIDVALUE(pcProjectsFetched);

		VSL_RETURN_VALIDVALUES();
	}
	struct CanCreateNewProjectAtLocationValidValues
	{
		/*[in]*/ BOOL fCreateNewSolution;
		/*[in]*/ LPCOLESTR pszFullProjectFilePath;
		/*[out]*/ BOOL* pfCanCreate;
		HRESULT retValue;
	};

	STDMETHOD(CanCreateNewProjectAtLocation)(
		/*[in]*/ BOOL fCreateNewSolution,
		/*[in]*/ LPCOLESTR pszFullProjectFilePath,
		/*[out]*/ BOOL* pfCanCreate)
	{
		VSL_DEFINE_MOCK_METHOD(CanCreateNewProjectAtLocation)

		VSL_CHECK_VALIDVALUE(fCreateNewSolution);

		VSL_CHECK_VALIDVALUE_STRINGW(pszFullProjectFilePath);

		VSL_SET_VALIDVALUE(pfCanCreate);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSOLUTION2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSolution3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSOLUTION3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSOLUTION3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSolution3NotImpl :
	public IVsSolution3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSolution3NotImpl)

public:

	typedef IVsSolution3 Interface;

	STDMETHOD(CreateNewProjectViaDlgEx)(
		/*[in]*/ LPCOLESTR /*pszDlgTitle*/,
		/*[in]*/ LPCOLESTR /*pszTemplateDir*/,
		/*[in]*/ LPCOLESTR /*pszExpand*/,
		/*[in]*/ LPCOLESTR /*pszSelect*/,
		/*[in]*/ LPCOLESTR /*pszHelpTopic*/,
		/*[in]*/ VSCREATENEWPROJVIADLGEXFLAGS /*cnpvdeFlags*/,
		/*[in]*/ IVsBrowseProjectLocation* /*pBrowse*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetUniqueUINameOfProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[out]*/ BSTR* /*pbstrUniqueName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CheckForAndSaveDeferredSaveSolution)(
		/*[in]*/ BOOL /*fCloseSolution*/,
		/*[in]*/ LPCOLESTR /*pszMessage*/,
		/*[in]*/ LPCOLESTR /*pszTitle*/,
		/*[in]*/ VSSAVEDEFERREDSAVEFLAGS /*grfFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateProjectFileLocationForUpgrade)(
		/*[in]*/ LPCOLESTR /*pszCurrentLocation*/,
		/*[in]*/ LPCOLESTR /*pszUpgradedLocation*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSolution3MockImpl :
	public IVsSolution3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSolution3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSolution3MockImpl)

	typedef IVsSolution3 Interface;
	struct CreateNewProjectViaDlgExValidValues
	{
		/*[in]*/ LPCOLESTR pszDlgTitle;
		/*[in]*/ LPCOLESTR pszTemplateDir;
		/*[in]*/ LPCOLESTR pszExpand;
		/*[in]*/ LPCOLESTR pszSelect;
		/*[in]*/ LPCOLESTR pszHelpTopic;
		/*[in]*/ VSCREATENEWPROJVIADLGEXFLAGS cnpvdeFlags;
		/*[in]*/ IVsBrowseProjectLocation* pBrowse;
		HRESULT retValue;
	};

	STDMETHOD(CreateNewProjectViaDlgEx)(
		/*[in]*/ LPCOLESTR pszDlgTitle,
		/*[in]*/ LPCOLESTR pszTemplateDir,
		/*[in]*/ LPCOLESTR pszExpand,
		/*[in]*/ LPCOLESTR pszSelect,
		/*[in]*/ LPCOLESTR pszHelpTopic,
		/*[in]*/ VSCREATENEWPROJVIADLGEXFLAGS cnpvdeFlags,
		/*[in]*/ IVsBrowseProjectLocation* pBrowse)
	{
		VSL_DEFINE_MOCK_METHOD(CreateNewProjectViaDlgEx)

		VSL_CHECK_VALIDVALUE_STRINGW(pszDlgTitle);

		VSL_CHECK_VALIDVALUE_STRINGW(pszTemplateDir);

		VSL_CHECK_VALIDVALUE_STRINGW(pszExpand);

		VSL_CHECK_VALIDVALUE_STRINGW(pszSelect);

		VSL_CHECK_VALIDVALUE_STRINGW(pszHelpTopic);

		VSL_CHECK_VALIDVALUE(cnpvdeFlags);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBrowse);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetUniqueUINameOfProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[out]*/ BSTR* pbstrUniqueName;
		HRESULT retValue;
	};

	STDMETHOD(GetUniqueUINameOfProject)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[out]*/ BSTR* pbstrUniqueName)
	{
		VSL_DEFINE_MOCK_METHOD(GetUniqueUINameOfProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_SET_VALIDVALUE_BSTR(pbstrUniqueName);

		VSL_RETURN_VALIDVALUES();
	}
	struct CheckForAndSaveDeferredSaveSolutionValidValues
	{
		/*[in]*/ BOOL fCloseSolution;
		/*[in]*/ LPCOLESTR pszMessage;
		/*[in]*/ LPCOLESTR pszTitle;
		/*[in]*/ VSSAVEDEFERREDSAVEFLAGS grfFlags;
		HRESULT retValue;
	};

	STDMETHOD(CheckForAndSaveDeferredSaveSolution)(
		/*[in]*/ BOOL fCloseSolution,
		/*[in]*/ LPCOLESTR pszMessage,
		/*[in]*/ LPCOLESTR pszTitle,
		/*[in]*/ VSSAVEDEFERREDSAVEFLAGS grfFlags)
	{
		VSL_DEFINE_MOCK_METHOD(CheckForAndSaveDeferredSaveSolution)

		VSL_CHECK_VALIDVALUE(fCloseSolution);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMessage);

		VSL_CHECK_VALIDVALUE_STRINGW(pszTitle);

		VSL_CHECK_VALIDVALUE(grfFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateProjectFileLocationForUpgradeValidValues
	{
		/*[in]*/ LPCOLESTR pszCurrentLocation;
		/*[in]*/ LPCOLESTR pszUpgradedLocation;
		HRESULT retValue;
	};

	STDMETHOD(UpdateProjectFileLocationForUpgrade)(
		/*[in]*/ LPCOLESTR pszCurrentLocation,
		/*[in]*/ LPCOLESTR pszUpgradedLocation)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateProjectFileLocationForUpgrade)

		VSL_CHECK_VALIDVALUE_STRINGW(pszCurrentLocation);

		VSL_CHECK_VALIDVALUE_STRINGW(pszUpgradedLocation);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSOLUTION3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSolutionBuildManager3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSOLUTIONBUILDMANAGER3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSOLUTIONBUILDMANAGER3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSolutionBuildManager3NotImpl :
	public IVsSolutionBuildManager3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSolutionBuildManager3NotImpl)

public:

	typedef IVsSolutionBuildManager3 Interface;

	STDMETHOD(AdviseUpdateSolutionEvents3)(
		/*[in]*/ IVsUpdateSolutionEvents3* /*pIVsUpdateSolutionEvents3*/,
		/*[out]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseUpdateSolutionEvents3)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AreProjectsUpToDate)(
		/*[in]*/ DWORD /*dwOptions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(HasHierarchyChangedSinceLastDTEE)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryBuildManagerBusyEx)(
		/*[out]*/ DWORD* /*pdwBuildManagerOperation*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSolutionBuildManager3MockImpl :
	public IVsSolutionBuildManager3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSolutionBuildManager3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSolutionBuildManager3MockImpl)

	typedef IVsSolutionBuildManager3 Interface;
	struct AdviseUpdateSolutionEvents3ValidValues
	{
		/*[in]*/ IVsUpdateSolutionEvents3* pIVsUpdateSolutionEvents3;
		/*[out]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(AdviseUpdateSolutionEvents3)(
		/*[in]*/ IVsUpdateSolutionEvents3* pIVsUpdateSolutionEvents3,
		/*[out]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(AdviseUpdateSolutionEvents3)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsUpdateSolutionEvents3);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseUpdateSolutionEvents3ValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnadviseUpdateSolutionEvents3)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnadviseUpdateSolutionEvents3)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct AreProjectsUpToDateValidValues
	{
		/*[in]*/ DWORD dwOptions;
		HRESULT retValue;
	};

	STDMETHOD(AreProjectsUpToDate)(
		/*[in]*/ DWORD dwOptions)
	{
		VSL_DEFINE_MOCK_METHOD(AreProjectsUpToDate)

		VSL_CHECK_VALIDVALUE(dwOptions);

		VSL_RETURN_VALIDVALUES();
	}
	struct HasHierarchyChangedSinceLastDTEEValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(HasHierarchyChangedSinceLastDTEE)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(HasHierarchyChangedSinceLastDTEE)

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryBuildManagerBusyExValidValues
	{
		/*[out]*/ DWORD* pdwBuildManagerOperation;
		HRESULT retValue;
	};

	STDMETHOD(QueryBuildManagerBusyEx)(
		/*[out]*/ DWORD* pdwBuildManagerOperation)
	{
		VSL_DEFINE_MOCK_METHOD(QueryBuildManagerBusyEx)

		VSL_SET_VALIDVALUE(pdwBuildManagerOperation);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSOLUTIONBUILDMANAGER3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSolutionEvents3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSOLUTIONEVENTS3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSOLUTIONEVENTS3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSolutionEvents3NotImpl :
	public IVsSolutionEvents3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSolutionEvents3NotImpl)

public:

	typedef IVsSolutionEvents3 Interface;

	STDMETHOD(OnBeforeOpeningChildren)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterOpeningChildren)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnBeforeClosingChildren)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterClosingChildren)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterMergeSolution)(
		/*[in]*/ IUnknown* /*pUnkReserved*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterOpenProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ BOOL /*fAdded*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnQueryCloseProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ BOOL /*fRemoving*/,
		/*[in,out]*/ BOOL* /*pfCancel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnBeforeCloseProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ BOOL /*fRemoved*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterLoadProject)(
		/*[in]*/ IVsHierarchy* /*pStubHierarchy*/,
		/*[in]*/ IVsHierarchy* /*pRealHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnQueryUnloadProject)(
		/*[in]*/ IVsHierarchy* /*pRealHierarchy*/,
		/*[in,out]*/ BOOL* /*pfCancel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnBeforeUnloadProject)(
		/*[in]*/ IVsHierarchy* /*pRealHierarchy*/,
		/*[in]*/ IVsHierarchy* /*pStubHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterOpenSolution)(
		/*[in]*/ IUnknown* /*pUnkReserved*/,
		/*[in]*/ BOOL /*fNewSolution*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnQueryCloseSolution)(
		/*[in]*/ IUnknown* /*pUnkReserved*/,
		/*[in,out]*/ BOOL* /*pfCancel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnBeforeCloseSolution)(
		/*[in]*/ IUnknown* /*pUnkReserved*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterCloseSolution)(
		/*[in]*/ IUnknown* /*pUnkReserved*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSolutionEvents3MockImpl :
	public IVsSolutionEvents3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSolutionEvents3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSolutionEvents3MockImpl)

	typedef IVsSolutionEvents3 Interface;
	struct OnBeforeOpeningChildrenValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(OnBeforeOpeningChildren)(
		/*[in]*/ IVsHierarchy* pHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(OnBeforeOpeningChildren)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterOpeningChildrenValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterOpeningChildren)(
		/*[in]*/ IVsHierarchy* pHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterOpeningChildren)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnBeforeClosingChildrenValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(OnBeforeClosingChildren)(
		/*[in]*/ IVsHierarchy* pHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(OnBeforeClosingChildren)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterClosingChildrenValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterClosingChildren)(
		/*[in]*/ IVsHierarchy* pHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterClosingChildren)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterMergeSolutionValidValues
	{
		/*[in]*/ IUnknown* pUnkReserved;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterMergeSolution)(
		/*[in]*/ IUnknown* pUnkReserved)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterMergeSolution)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnkReserved);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterOpenProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ BOOL fAdded;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterOpenProject)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ BOOL fAdded)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterOpenProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE(fAdded);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnQueryCloseProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ BOOL fRemoving;
		/*[in,out]*/ BOOL* pfCancel;
		HRESULT retValue;
	};

	STDMETHOD(OnQueryCloseProject)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ BOOL fRemoving,
		/*[in,out]*/ BOOL* pfCancel)
	{
		VSL_DEFINE_MOCK_METHOD(OnQueryCloseProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE(fRemoving);

		VSL_SET_VALIDVALUE(pfCancel);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnBeforeCloseProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ BOOL fRemoved;
		HRESULT retValue;
	};

	STDMETHOD(OnBeforeCloseProject)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ BOOL fRemoved)
	{
		VSL_DEFINE_MOCK_METHOD(OnBeforeCloseProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE(fRemoved);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterLoadProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pStubHierarchy;
		/*[in]*/ IVsHierarchy* pRealHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterLoadProject)(
		/*[in]*/ IVsHierarchy* pStubHierarchy,
		/*[in]*/ IVsHierarchy* pRealHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterLoadProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStubHierarchy);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pRealHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnQueryUnloadProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pRealHierarchy;
		/*[in,out]*/ BOOL* pfCancel;
		HRESULT retValue;
	};

	STDMETHOD(OnQueryUnloadProject)(
		/*[in]*/ IVsHierarchy* pRealHierarchy,
		/*[in,out]*/ BOOL* pfCancel)
	{
		VSL_DEFINE_MOCK_METHOD(OnQueryUnloadProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pRealHierarchy);

		VSL_SET_VALIDVALUE(pfCancel);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnBeforeUnloadProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pRealHierarchy;
		/*[in]*/ IVsHierarchy* pStubHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(OnBeforeUnloadProject)(
		/*[in]*/ IVsHierarchy* pRealHierarchy,
		/*[in]*/ IVsHierarchy* pStubHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(OnBeforeUnloadProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pRealHierarchy);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStubHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterOpenSolutionValidValues
	{
		/*[in]*/ IUnknown* pUnkReserved;
		/*[in]*/ BOOL fNewSolution;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterOpenSolution)(
		/*[in]*/ IUnknown* pUnkReserved,
		/*[in]*/ BOOL fNewSolution)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterOpenSolution)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnkReserved);

		VSL_CHECK_VALIDVALUE(fNewSolution);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnQueryCloseSolutionValidValues
	{
		/*[in]*/ IUnknown* pUnkReserved;
		/*[in,out]*/ BOOL* pfCancel;
		HRESULT retValue;
	};

	STDMETHOD(OnQueryCloseSolution)(
		/*[in]*/ IUnknown* pUnkReserved,
		/*[in,out]*/ BOOL* pfCancel)
	{
		VSL_DEFINE_MOCK_METHOD(OnQueryCloseSolution)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnkReserved);

		VSL_SET_VALIDVALUE(pfCancel);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnBeforeCloseSolutionValidValues
	{
		/*[in]*/ IUnknown* pUnkReserved;
		HRESULT retValue;
	};

	STDMETHOD(OnBeforeCloseSolution)(
		/*[in]*/ IUnknown* pUnkReserved)
	{
		VSL_DEFINE_MOCK_METHOD(OnBeforeCloseSolution)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnkReserved);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterCloseSolutionValidValues
	{
		/*[in]*/ IUnknown* pUnkReserved;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterCloseSolution)(
		/*[in]*/ IUnknown* pUnkReserved)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterCloseSolution)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnkReserved);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSOLUTIONEVENTS3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSolutionBuildManager.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSOLUTIONBUILDMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSOLUTIONBUILDMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSolutionBuildManagerNotImpl :
	public IVsSolutionBuildManager
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSolutionBuildManagerNotImpl)

public:

	typedef IVsSolutionBuildManager Interface;

	STDMETHOD(DebugLaunch)(
		/*[in]*/ VSDBGLAUNCHFLAGS /*grfLaunch*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(StartSimpleUpdateSolutionConfiguration)(
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in]*/ DWORD /*dwDefQueryResults*/,
		/*[in]*/ BOOL /*fSuppressUI*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AdviseUpdateSolutionEvents)(
		/*[in]*/ IVsUpdateSolutionEvents* /*pIVsUpdateSolutionEvents*/,
		/*[out]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseUpdateSolutionEvents)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateSolutionConfigurationIsActive)(
		/*[out]*/ BOOL* /*pfIsActive*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanCancelUpdateSolutionConfiguration)(
		/*[out]*/ BOOL* /*pfCanCancel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CancelUpdateSolutionConfiguration)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryDebugLaunch)(
		/*[in]*/ VSDBGLAUNCHFLAGS /*grfLaunch*/,
		/*[out]*/ BOOL* /*pfCanLaunch*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryBuildManagerBusy)(
		/*[out]*/ BOOL* /*pfBuildManagerBusy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FindActiveProjectCfg)(
		/*[in,unique]*/ IVsHierarchy* /*pvReserved1*/,
		/*[in,unique]*/ LPCOLESTR /*pvReserved2*/,
		/*[in,unique]*/ IVsHierarchy* /*pIVsHierarchy_RequestedProject*/,
		/*[out,optional]*/ IVsProjectCfg** /*ppIVsProjectCfg_Active*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IsDebug)(
		/*[out]*/ BOOL* /*pfIsDebug*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_IsDebug)(
		/*[in]*/ BOOL /*fIsDebug*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CodePage)(
		/*[out]*/ UINT* /*puiCodePage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CodePage)(
		/*[in]*/ UINT /*uiCodePage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(StartSimpleUpdateProjectConfiguration)(
		/*[in]*/ IVsHierarchy* /*pIVsHierarchyToBuild*/,
		/*[in]*/ IVsHierarchy* /*pIVsHierarchyDependent*/,
		/*[in]*/ LPCOLESTR /*pszDependentConfigurationCanonicalName*/,
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in]*/ DWORD /*dwDefQueryResults*/,
		/*[in]*/ BOOL /*fSuppressUI*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartupProject)(
		/*[out]*/ IVsHierarchy** /*ppHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(set_StartupProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProjectDependencies)(
		/*[in]*/ IVsHierarchy* /*pHier*/,
		/*[in]*/ ULONG /*celt*/,
		/*[in,out,size_is(celt)]*/ IVsHierarchy*[] /*rgpHier*/,
		/*[out,optional]*/ ULONG* /*pcActual*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSolutionBuildManagerMockImpl :
	public IVsSolutionBuildManager,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSolutionBuildManagerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSolutionBuildManagerMockImpl)

	typedef IVsSolutionBuildManager Interface;
	struct DebugLaunchValidValues
	{
		/*[in]*/ VSDBGLAUNCHFLAGS grfLaunch;
		HRESULT retValue;
	};

	STDMETHOD(DebugLaunch)(
		/*[in]*/ VSDBGLAUNCHFLAGS grfLaunch)
	{
		VSL_DEFINE_MOCK_METHOD(DebugLaunch)

		VSL_CHECK_VALIDVALUE(grfLaunch);

		VSL_RETURN_VALIDVALUES();
	}
	struct StartSimpleUpdateSolutionConfigurationValidValues
	{
		/*[in]*/ DWORD dwFlags;
		/*[in]*/ DWORD dwDefQueryResults;
		/*[in]*/ BOOL fSuppressUI;
		HRESULT retValue;
	};

	STDMETHOD(StartSimpleUpdateSolutionConfiguration)(
		/*[in]*/ DWORD dwFlags,
		/*[in]*/ DWORD dwDefQueryResults,
		/*[in]*/ BOOL fSuppressUI)
	{
		VSL_DEFINE_MOCK_METHOD(StartSimpleUpdateSolutionConfiguration)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE(dwDefQueryResults);

		VSL_CHECK_VALIDVALUE(fSuppressUI);

		VSL_RETURN_VALIDVALUES();
	}
	struct AdviseUpdateSolutionEventsValidValues
	{
		/*[in]*/ IVsUpdateSolutionEvents* pIVsUpdateSolutionEvents;
		/*[out]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(AdviseUpdateSolutionEvents)(
		/*[in]*/ IVsUpdateSolutionEvents* pIVsUpdateSolutionEvents,
		/*[out]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(AdviseUpdateSolutionEvents)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsUpdateSolutionEvents);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseUpdateSolutionEventsValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnadviseUpdateSolutionEvents)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnadviseUpdateSolutionEvents)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateSolutionConfigurationIsActiveValidValues
	{
		/*[out]*/ BOOL* pfIsActive;
		HRESULT retValue;
	};

	STDMETHOD(UpdateSolutionConfigurationIsActive)(
		/*[out]*/ BOOL* pfIsActive)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateSolutionConfigurationIsActive)

		VSL_SET_VALIDVALUE(pfIsActive);

		VSL_RETURN_VALIDVALUES();
	}
	struct CanCancelUpdateSolutionConfigurationValidValues
	{
		/*[out]*/ BOOL* pfCanCancel;
		HRESULT retValue;
	};

	STDMETHOD(CanCancelUpdateSolutionConfiguration)(
		/*[out]*/ BOOL* pfCanCancel)
	{
		VSL_DEFINE_MOCK_METHOD(CanCancelUpdateSolutionConfiguration)

		VSL_SET_VALIDVALUE(pfCanCancel);

		VSL_RETURN_VALIDVALUES();
	}
	struct CancelUpdateSolutionConfigurationValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CancelUpdateSolutionConfiguration)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CancelUpdateSolutionConfiguration)

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryDebugLaunchValidValues
	{
		/*[in]*/ VSDBGLAUNCHFLAGS grfLaunch;
		/*[out]*/ BOOL* pfCanLaunch;
		HRESULT retValue;
	};

	STDMETHOD(QueryDebugLaunch)(
		/*[in]*/ VSDBGLAUNCHFLAGS grfLaunch,
		/*[out]*/ BOOL* pfCanLaunch)
	{
		VSL_DEFINE_MOCK_METHOD(QueryDebugLaunch)

		VSL_CHECK_VALIDVALUE(grfLaunch);

		VSL_SET_VALIDVALUE(pfCanLaunch);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryBuildManagerBusyValidValues
	{
		/*[out]*/ BOOL* pfBuildManagerBusy;
		HRESULT retValue;
	};

	STDMETHOD(QueryBuildManagerBusy)(
		/*[out]*/ BOOL* pfBuildManagerBusy)
	{
		VSL_DEFINE_MOCK_METHOD(QueryBuildManagerBusy)

		VSL_SET_VALIDVALUE(pfBuildManagerBusy);

		VSL_RETURN_VALIDVALUES();
	}
	struct FindActiveProjectCfgValidValues
	{
		/*[in,unique]*/ IVsHierarchy* pvReserved1;
		/*[in,unique]*/ LPCOLESTR pvReserved2;
		/*[in,unique]*/ IVsHierarchy* pIVsHierarchy_RequestedProject;
		/*[out,optional]*/ IVsProjectCfg** ppIVsProjectCfg_Active;
		HRESULT retValue;
	};

	STDMETHOD(FindActiveProjectCfg)(
		/*[in,unique]*/ IVsHierarchy* pvReserved1,
		/*[in,unique]*/ LPCOLESTR pvReserved2,
		/*[in,unique]*/ IVsHierarchy* pIVsHierarchy_RequestedProject,
		/*[out,optional]*/ IVsProjectCfg** ppIVsProjectCfg_Active)
	{
		VSL_DEFINE_MOCK_METHOD(FindActiveProjectCfg)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pvReserved1);

		VSL_CHECK_VALIDVALUE_STRINGW(pvReserved2);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsHierarchy_RequestedProject);

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsProjectCfg_Active);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IsDebugValidValues
	{
		/*[out]*/ BOOL* pfIsDebug;
		HRESULT retValue;
	};

	STDMETHOD(get_IsDebug)(
		/*[out]*/ BOOL* pfIsDebug)
	{
		VSL_DEFINE_MOCK_METHOD(get_IsDebug)

		VSL_SET_VALIDVALUE(pfIsDebug);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_IsDebugValidValues
	{
		/*[in]*/ BOOL fIsDebug;
		HRESULT retValue;
	};

	STDMETHOD(put_IsDebug)(
		/*[in]*/ BOOL fIsDebug)
	{
		VSL_DEFINE_MOCK_METHOD(put_IsDebug)

		VSL_CHECK_VALIDVALUE(fIsDebug);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CodePageValidValues
	{
		/*[out]*/ UINT* puiCodePage;
		HRESULT retValue;
	};

	STDMETHOD(get_CodePage)(
		/*[out]*/ UINT* puiCodePage)
	{
		VSL_DEFINE_MOCK_METHOD(get_CodePage)

		VSL_SET_VALIDVALUE(puiCodePage);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CodePageValidValues
	{
		/*[in]*/ UINT uiCodePage;
		HRESULT retValue;
	};

	STDMETHOD(put_CodePage)(
		/*[in]*/ UINT uiCodePage)
	{
		VSL_DEFINE_MOCK_METHOD(put_CodePage)

		VSL_CHECK_VALIDVALUE(uiCodePage);

		VSL_RETURN_VALIDVALUES();
	}
	struct StartSimpleUpdateProjectConfigurationValidValues
	{
		/*[in]*/ IVsHierarchy* pIVsHierarchyToBuild;
		/*[in]*/ IVsHierarchy* pIVsHierarchyDependent;
		/*[in]*/ LPCOLESTR pszDependentConfigurationCanonicalName;
		/*[in]*/ DWORD dwFlags;
		/*[in]*/ DWORD dwDefQueryResults;
		/*[in]*/ BOOL fSuppressUI;
		HRESULT retValue;
	};

	STDMETHOD(StartSimpleUpdateProjectConfiguration)(
		/*[in]*/ IVsHierarchy* pIVsHierarchyToBuild,
		/*[in]*/ IVsHierarchy* pIVsHierarchyDependent,
		/*[in]*/ LPCOLESTR pszDependentConfigurationCanonicalName,
		/*[in]*/ DWORD dwFlags,
		/*[in]*/ DWORD dwDefQueryResults,
		/*[in]*/ BOOL fSuppressUI)
	{
		VSL_DEFINE_MOCK_METHOD(StartSimpleUpdateProjectConfiguration)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsHierarchyToBuild);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsHierarchyDependent);

		VSL_CHECK_VALIDVALUE_STRINGW(pszDependentConfigurationCanonicalName);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE(dwDefQueryResults);

		VSL_CHECK_VALIDVALUE(fSuppressUI);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartupProjectValidValues
	{
		/*[out]*/ IVsHierarchy** ppHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(get_StartupProject)(
		/*[out]*/ IVsHierarchy** ppHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartupProject)

		VSL_SET_VALIDVALUE_INTERFACE(ppHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct set_StartupProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(set_StartupProject)(
		/*[in]*/ IVsHierarchy* pHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(set_StartupProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProjectDependenciesValidValues
	{
		/*[in]*/ IVsHierarchy* pHier;
		/*[in]*/ ULONG celt;
		/*[in,out,size_is(celt)]*/ IVsHierarchy** rgpHier;
		/*[out,optional]*/ ULONG* pcActual;
		HRESULT retValue;
	};

	STDMETHOD(GetProjectDependencies)(
		/*[in]*/ IVsHierarchy* pHier,
		/*[in]*/ ULONG celt,
		/*[in,out,size_is(celt)]*/ IVsHierarchy* rgpHier[],
		/*[out,optional]*/ ULONG* pcActual)
	{
		VSL_DEFINE_MOCK_METHOD(GetProjectDependencies)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHier);

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgpHier, celt, validValues.celt);

		VSL_SET_VALIDVALUE(pcActual);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSOLUTIONBUILDMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSolutionBuildManager2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSOLUTIONBUILDMANAGER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSOLUTIONBUILDMANAGER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSolutionBuildManager2NotImpl :
	public IVsSolutionBuildManager2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSolutionBuildManager2NotImpl)

public:

	typedef IVsSolutionBuildManager2 Interface;

	STDMETHOD(StartUpdateProjectConfigurations)(
		/*[in]*/ UINT /*cProjs*/,
		/*[in,size_is(cProjs)]*/ IVsHierarchy*[] /*rgpHierProjs*/,
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in]*/ BOOL /*fSuppressUI*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CalculateProjectDependencies)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryProjectDependency)(
		/*[in]*/ IVsHierarchy* /*pHier*/,
		/*[in]*/ IVsHierarchy* /*pHierDependentOn*/,
		/*[out]*/ BOOL* /*pfIsDependentOn*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SaveDocumentsBeforeBuild)(
		/*[in]*/ IVsHierarchy* /*pHier*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ VSCOOKIE /*docCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(StartUpdateSpecificProjectConfigurations)(
		/*[in]*/ UINT /*cProjs*/,
		/*[in,size_is(cProjs)]*/ IVsHierarchy*[] /*rgpHier*/,
		/*[in,size_is(cProjs)]*/ IVsCfg*[] /*rgpCfg*/,
		/*[in,size_is(cProjs)]*/ DWORD[] /*rgdwCleanFlags*/,
		/*[in,size_is(cProjs)]*/ DWORD[] /*rgdwBuildFlags*/,
		/*[in,size_is(cProjs)]*/ DWORD[] /*rgdwDeployFlags*/,
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in]*/ BOOL /*fSuppressUI*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DebugLaunch)(
		/*[in]*/ VSDBGLAUNCHFLAGS /*grfLaunch*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(StartSimpleUpdateSolutionConfiguration)(
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in]*/ DWORD /*dwDefQueryResults*/,
		/*[in]*/ BOOL /*fSuppressUI*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AdviseUpdateSolutionEvents)(
		/*[in]*/ IVsUpdateSolutionEvents* /*pIVsUpdateSolutionEvents*/,
		/*[out]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseUpdateSolutionEvents)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateSolutionConfigurationIsActive)(
		/*[out]*/ BOOL* /*pfIsActive*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanCancelUpdateSolutionConfiguration)(
		/*[out]*/ BOOL* /*pfCanCancel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CancelUpdateSolutionConfiguration)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryDebugLaunch)(
		/*[in]*/ VSDBGLAUNCHFLAGS /*grfLaunch*/,
		/*[out]*/ BOOL* /*pfCanLaunch*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryBuildManagerBusy)(
		/*[out]*/ BOOL* /*pfBuildManagerBusy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FindActiveProjectCfg)(
		/*[in,unique]*/ IVsHierarchy* /*pvReserved1*/,
		/*[in,unique]*/ LPCOLESTR /*pvReserved2*/,
		/*[in,unique]*/ IVsHierarchy* /*pIVsHierarchy_RequestedProject*/,
		/*[out,optional]*/ IVsProjectCfg** /*ppIVsProjectCfg_Active*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IsDebug)(
		/*[out]*/ BOOL* /*pfIsDebug*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_IsDebug)(
		/*[in]*/ BOOL /*fIsDebug*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CodePage)(
		/*[out]*/ UINT* /*puiCodePage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CodePage)(
		/*[in]*/ UINT /*uiCodePage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(StartSimpleUpdateProjectConfiguration)(
		/*[in]*/ IVsHierarchy* /*pIVsHierarchyToBuild*/,
		/*[in]*/ IVsHierarchy* /*pIVsHierarchyDependent*/,
		/*[in]*/ LPCOLESTR /*pszDependentConfigurationCanonicalName*/,
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in]*/ DWORD /*dwDefQueryResults*/,
		/*[in]*/ BOOL /*fSuppressUI*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartupProject)(
		/*[out]*/ IVsHierarchy** /*ppHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(set_StartupProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProjectDependencies)(
		/*[in]*/ IVsHierarchy* /*pHier*/,
		/*[in]*/ ULONG /*celt*/,
		/*[in,out,size_is(celt)]*/ IVsHierarchy*[] /*rgpHier*/,
		/*[out,optional]*/ ULONG* /*pcActual*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSolutionBuildManager2MockImpl :
	public IVsSolutionBuildManager2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSolutionBuildManager2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSolutionBuildManager2MockImpl)

	typedef IVsSolutionBuildManager2 Interface;
	struct StartUpdateProjectConfigurationsValidValues
	{
		/*[in]*/ UINT cProjs;
		/*[in,size_is(cProjs)]*/ IVsHierarchy** rgpHierProjs;
		/*[in]*/ DWORD dwFlags;
		/*[in]*/ BOOL fSuppressUI;
		HRESULT retValue;
	};

	STDMETHOD(StartUpdateProjectConfigurations)(
		/*[in]*/ UINT cProjs,
		/*[in,size_is(cProjs)]*/ IVsHierarchy* rgpHierProjs[],
		/*[in]*/ DWORD dwFlags,
		/*[in]*/ BOOL fSuppressUI)
	{
		VSL_DEFINE_MOCK_METHOD(StartUpdateProjectConfigurations)

		VSL_CHECK_VALIDVALUE(cProjs);

		VSL_CHECK_VALIDVALUE_ARRAY(rgpHierProjs, cProjs, validValues.cProjs);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE(fSuppressUI);

		VSL_RETURN_VALIDVALUES();
	}
	struct CalculateProjectDependenciesValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CalculateProjectDependencies)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CalculateProjectDependencies)

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryProjectDependencyValidValues
	{
		/*[in]*/ IVsHierarchy* pHier;
		/*[in]*/ IVsHierarchy* pHierDependentOn;
		/*[out]*/ BOOL* pfIsDependentOn;
		HRESULT retValue;
	};

	STDMETHOD(QueryProjectDependency)(
		/*[in]*/ IVsHierarchy* pHier,
		/*[in]*/ IVsHierarchy* pHierDependentOn,
		/*[out]*/ BOOL* pfIsDependentOn)
	{
		VSL_DEFINE_MOCK_METHOD(QueryProjectDependency)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHier);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierDependentOn);

		VSL_SET_VALIDVALUE(pfIsDependentOn);

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveDocumentsBeforeBuildValidValues
	{
		/*[in]*/ IVsHierarchy* pHier;
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ VSCOOKIE docCookie;
		HRESULT retValue;
	};

	STDMETHOD(SaveDocumentsBeforeBuild)(
		/*[in]*/ IVsHierarchy* pHier,
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ VSCOOKIE docCookie)
	{
		VSL_DEFINE_MOCK_METHOD(SaveDocumentsBeforeBuild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHier);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE(docCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct StartUpdateSpecificProjectConfigurationsValidValues
	{
		/*[in]*/ UINT cProjs;
		/*[in,size_is(cProjs)]*/ IVsHierarchy** rgpHier;
		/*[in,size_is(cProjs)]*/ IVsCfg** rgpCfg;
		/*[in,size_is(cProjs)]*/ DWORD* rgdwCleanFlags;
		/*[in,size_is(cProjs)]*/ DWORD* rgdwBuildFlags;
		/*[in,size_is(cProjs)]*/ DWORD* rgdwDeployFlags;
		/*[in]*/ DWORD dwFlags;
		/*[in]*/ BOOL fSuppressUI;
		HRESULT retValue;
	};

	STDMETHOD(StartUpdateSpecificProjectConfigurations)(
		/*[in]*/ UINT cProjs,
		/*[in,size_is(cProjs)]*/ IVsHierarchy* rgpHier[],
		/*[in,size_is(cProjs)]*/ IVsCfg* rgpCfg[],
		/*[in,size_is(cProjs)]*/ DWORD rgdwCleanFlags[],
		/*[in,size_is(cProjs)]*/ DWORD rgdwBuildFlags[],
		/*[in,size_is(cProjs)]*/ DWORD rgdwDeployFlags[],
		/*[in]*/ DWORD dwFlags,
		/*[in]*/ BOOL fSuppressUI)
	{
		VSL_DEFINE_MOCK_METHOD(StartUpdateSpecificProjectConfigurations)

		VSL_CHECK_VALIDVALUE(cProjs);

		VSL_CHECK_VALIDVALUE_ARRAY(rgpHier, cProjs, validValues.cProjs);

		VSL_CHECK_VALIDVALUE_ARRAY(rgpCfg, cProjs, validValues.cProjs);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgdwCleanFlags, cProjs*sizeof(rgdwCleanFlags[0]), validValues.cProjs*sizeof(validValues.rgdwCleanFlags[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgdwBuildFlags, cProjs*sizeof(rgdwBuildFlags[0]), validValues.cProjs*sizeof(validValues.rgdwBuildFlags[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgdwDeployFlags, cProjs*sizeof(rgdwDeployFlags[0]), validValues.cProjs*sizeof(validValues.rgdwDeployFlags[0]));

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE(fSuppressUI);

		VSL_RETURN_VALIDVALUES();
	}
	struct DebugLaunchValidValues
	{
		/*[in]*/ VSDBGLAUNCHFLAGS grfLaunch;
		HRESULT retValue;
	};

	STDMETHOD(DebugLaunch)(
		/*[in]*/ VSDBGLAUNCHFLAGS grfLaunch)
	{
		VSL_DEFINE_MOCK_METHOD(DebugLaunch)

		VSL_CHECK_VALIDVALUE(grfLaunch);

		VSL_RETURN_VALIDVALUES();
	}
	struct StartSimpleUpdateSolutionConfigurationValidValues
	{
		/*[in]*/ DWORD dwFlags;
		/*[in]*/ DWORD dwDefQueryResults;
		/*[in]*/ BOOL fSuppressUI;
		HRESULT retValue;
	};

	STDMETHOD(StartSimpleUpdateSolutionConfiguration)(
		/*[in]*/ DWORD dwFlags,
		/*[in]*/ DWORD dwDefQueryResults,
		/*[in]*/ BOOL fSuppressUI)
	{
		VSL_DEFINE_MOCK_METHOD(StartSimpleUpdateSolutionConfiguration)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE(dwDefQueryResults);

		VSL_CHECK_VALIDVALUE(fSuppressUI);

		VSL_RETURN_VALIDVALUES();
	}
	struct AdviseUpdateSolutionEventsValidValues
	{
		/*[in]*/ IVsUpdateSolutionEvents* pIVsUpdateSolutionEvents;
		/*[out]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(AdviseUpdateSolutionEvents)(
		/*[in]*/ IVsUpdateSolutionEvents* pIVsUpdateSolutionEvents,
		/*[out]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(AdviseUpdateSolutionEvents)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsUpdateSolutionEvents);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseUpdateSolutionEventsValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnadviseUpdateSolutionEvents)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnadviseUpdateSolutionEvents)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateSolutionConfigurationIsActiveValidValues
	{
		/*[out]*/ BOOL* pfIsActive;
		HRESULT retValue;
	};

	STDMETHOD(UpdateSolutionConfigurationIsActive)(
		/*[out]*/ BOOL* pfIsActive)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateSolutionConfigurationIsActive)

		VSL_SET_VALIDVALUE(pfIsActive);

		VSL_RETURN_VALIDVALUES();
	}
	struct CanCancelUpdateSolutionConfigurationValidValues
	{
		/*[out]*/ BOOL* pfCanCancel;
		HRESULT retValue;
	};

	STDMETHOD(CanCancelUpdateSolutionConfiguration)(
		/*[out]*/ BOOL* pfCanCancel)
	{
		VSL_DEFINE_MOCK_METHOD(CanCancelUpdateSolutionConfiguration)

		VSL_SET_VALIDVALUE(pfCanCancel);

		VSL_RETURN_VALIDVALUES();
	}
	struct CancelUpdateSolutionConfigurationValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CancelUpdateSolutionConfiguration)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CancelUpdateSolutionConfiguration)

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryDebugLaunchValidValues
	{
		/*[in]*/ VSDBGLAUNCHFLAGS grfLaunch;
		/*[out]*/ BOOL* pfCanLaunch;
		HRESULT retValue;
	};

	STDMETHOD(QueryDebugLaunch)(
		/*[in]*/ VSDBGLAUNCHFLAGS grfLaunch,
		/*[out]*/ BOOL* pfCanLaunch)
	{
		VSL_DEFINE_MOCK_METHOD(QueryDebugLaunch)

		VSL_CHECK_VALIDVALUE(grfLaunch);

		VSL_SET_VALIDVALUE(pfCanLaunch);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryBuildManagerBusyValidValues
	{
		/*[out]*/ BOOL* pfBuildManagerBusy;
		HRESULT retValue;
	};

	STDMETHOD(QueryBuildManagerBusy)(
		/*[out]*/ BOOL* pfBuildManagerBusy)
	{
		VSL_DEFINE_MOCK_METHOD(QueryBuildManagerBusy)

		VSL_SET_VALIDVALUE(pfBuildManagerBusy);

		VSL_RETURN_VALIDVALUES();
	}
	struct FindActiveProjectCfgValidValues
	{
		/*[in,unique]*/ IVsHierarchy* pvReserved1;
		/*[in,unique]*/ LPCOLESTR pvReserved2;
		/*[in,unique]*/ IVsHierarchy* pIVsHierarchy_RequestedProject;
		/*[out,optional]*/ IVsProjectCfg** ppIVsProjectCfg_Active;
		HRESULT retValue;
	};

	STDMETHOD(FindActiveProjectCfg)(
		/*[in,unique]*/ IVsHierarchy* pvReserved1,
		/*[in,unique]*/ LPCOLESTR pvReserved2,
		/*[in,unique]*/ IVsHierarchy* pIVsHierarchy_RequestedProject,
		/*[out,optional]*/ IVsProjectCfg** ppIVsProjectCfg_Active)
	{
		VSL_DEFINE_MOCK_METHOD(FindActiveProjectCfg)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pvReserved1);

		VSL_CHECK_VALIDVALUE_STRINGW(pvReserved2);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsHierarchy_RequestedProject);

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsProjectCfg_Active);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IsDebugValidValues
	{
		/*[out]*/ BOOL* pfIsDebug;
		HRESULT retValue;
	};

	STDMETHOD(get_IsDebug)(
		/*[out]*/ BOOL* pfIsDebug)
	{
		VSL_DEFINE_MOCK_METHOD(get_IsDebug)

		VSL_SET_VALIDVALUE(pfIsDebug);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_IsDebugValidValues
	{
		/*[in]*/ BOOL fIsDebug;
		HRESULT retValue;
	};

	STDMETHOD(put_IsDebug)(
		/*[in]*/ BOOL fIsDebug)
	{
		VSL_DEFINE_MOCK_METHOD(put_IsDebug)

		VSL_CHECK_VALIDVALUE(fIsDebug);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CodePageValidValues
	{
		/*[out]*/ UINT* puiCodePage;
		HRESULT retValue;
	};

	STDMETHOD(get_CodePage)(
		/*[out]*/ UINT* puiCodePage)
	{
		VSL_DEFINE_MOCK_METHOD(get_CodePage)

		VSL_SET_VALIDVALUE(puiCodePage);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CodePageValidValues
	{
		/*[in]*/ UINT uiCodePage;
		HRESULT retValue;
	};

	STDMETHOD(put_CodePage)(
		/*[in]*/ UINT uiCodePage)
	{
		VSL_DEFINE_MOCK_METHOD(put_CodePage)

		VSL_CHECK_VALIDVALUE(uiCodePage);

		VSL_RETURN_VALIDVALUES();
	}
	struct StartSimpleUpdateProjectConfigurationValidValues
	{
		/*[in]*/ IVsHierarchy* pIVsHierarchyToBuild;
		/*[in]*/ IVsHierarchy* pIVsHierarchyDependent;
		/*[in]*/ LPCOLESTR pszDependentConfigurationCanonicalName;
		/*[in]*/ DWORD dwFlags;
		/*[in]*/ DWORD dwDefQueryResults;
		/*[in]*/ BOOL fSuppressUI;
		HRESULT retValue;
	};

	STDMETHOD(StartSimpleUpdateProjectConfiguration)(
		/*[in]*/ IVsHierarchy* pIVsHierarchyToBuild,
		/*[in]*/ IVsHierarchy* pIVsHierarchyDependent,
		/*[in]*/ LPCOLESTR pszDependentConfigurationCanonicalName,
		/*[in]*/ DWORD dwFlags,
		/*[in]*/ DWORD dwDefQueryResults,
		/*[in]*/ BOOL fSuppressUI)
	{
		VSL_DEFINE_MOCK_METHOD(StartSimpleUpdateProjectConfiguration)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsHierarchyToBuild);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsHierarchyDependent);

		VSL_CHECK_VALIDVALUE_STRINGW(pszDependentConfigurationCanonicalName);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE(dwDefQueryResults);

		VSL_CHECK_VALIDVALUE(fSuppressUI);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartupProjectValidValues
	{
		/*[out]*/ IVsHierarchy** ppHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(get_StartupProject)(
		/*[out]*/ IVsHierarchy** ppHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartupProject)

		VSL_SET_VALIDVALUE_INTERFACE(ppHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct set_StartupProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(set_StartupProject)(
		/*[in]*/ IVsHierarchy* pHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(set_StartupProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProjectDependenciesValidValues
	{
		/*[in]*/ IVsHierarchy* pHier;
		/*[in]*/ ULONG celt;
		/*[in,out,size_is(celt)]*/ IVsHierarchy** rgpHier;
		/*[out,optional]*/ ULONG* pcActual;
		HRESULT retValue;
	};

	STDMETHOD(GetProjectDependencies)(
		/*[in]*/ IVsHierarchy* pHier,
		/*[in]*/ ULONG celt,
		/*[in,out,size_is(celt)]*/ IVsHierarchy* rgpHier[],
		/*[out,optional]*/ ULONG* pcActual)
	{
		VSL_DEFINE_MOCK_METHOD(GetProjectDependencies)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHier);

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_INTERFACEARRAY(rgpHier, celt, validValues.celt);

		VSL_SET_VALIDVALUE(pcActual);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSOLUTIONBUILDMANAGER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSolutionEvents4.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSOLUTIONEVENTS4_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSOLUTIONEVENTS4_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSolutionEvents4NotImpl :
	public IVsSolutionEvents4
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSolutionEvents4NotImpl)

public:

	typedef IVsSolutionEvents4 Interface;

	STDMETHOD(OnAfterRenameProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnQueryChangeProjectParent)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ IVsHierarchy* /*pNewParentHier*/,
		/*[in,out]*/ BOOL* /*pfCancel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterChangeProjectParent)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterAsynchOpenProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ BOOL /*fAdded*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSolutionEvents4MockImpl :
	public IVsSolutionEvents4,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSolutionEvents4MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSolutionEvents4MockImpl)

	typedef IVsSolutionEvents4 Interface;
	struct OnAfterRenameProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterRenameProject)(
		/*[in]*/ IVsHierarchy* pHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterRenameProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnQueryChangeProjectParentValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ IVsHierarchy* pNewParentHier;
		/*[in,out]*/ BOOL* pfCancel;
		HRESULT retValue;
	};

	STDMETHOD(OnQueryChangeProjectParent)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ IVsHierarchy* pNewParentHier,
		/*[in,out]*/ BOOL* pfCancel)
	{
		VSL_DEFINE_MOCK_METHOD(OnQueryChangeProjectParent)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pNewParentHier);

		VSL_SET_VALIDVALUE(pfCancel);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterChangeProjectParentValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterChangeProjectParent)(
		/*[in]*/ IVsHierarchy* pHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterChangeProjectParent)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterAsynchOpenProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ BOOL fAdded;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterAsynchOpenProject)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ BOOL fAdded)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterAsynchOpenProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE(fAdded);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSOLUTIONEVENTS4_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSolutionEvents2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSOLUTIONEVENTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSOLUTIONEVENTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSolutionEvents2NotImpl :
	public IVsSolutionEvents2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSolutionEvents2NotImpl)

public:

	typedef IVsSolutionEvents2 Interface;

	STDMETHOD(OnAfterMergeSolution)(
		/*[in]*/ IUnknown* /*pUnkReserved*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterOpenProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ BOOL /*fAdded*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnQueryCloseProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ BOOL /*fRemoving*/,
		/*[in,out]*/ BOOL* /*pfCancel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnBeforeCloseProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ BOOL /*fRemoved*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterLoadProject)(
		/*[in]*/ IVsHierarchy* /*pStubHierarchy*/,
		/*[in]*/ IVsHierarchy* /*pRealHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnQueryUnloadProject)(
		/*[in]*/ IVsHierarchy* /*pRealHierarchy*/,
		/*[in,out]*/ BOOL* /*pfCancel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnBeforeUnloadProject)(
		/*[in]*/ IVsHierarchy* /*pRealHierarchy*/,
		/*[in]*/ IVsHierarchy* /*pStubHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterOpenSolution)(
		/*[in]*/ IUnknown* /*pUnkReserved*/,
		/*[in]*/ BOOL /*fNewSolution*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnQueryCloseSolution)(
		/*[in]*/ IUnknown* /*pUnkReserved*/,
		/*[in,out]*/ BOOL* /*pfCancel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnBeforeCloseSolution)(
		/*[in]*/ IUnknown* /*pUnkReserved*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterCloseSolution)(
		/*[in]*/ IUnknown* /*pUnkReserved*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSolutionEvents2MockImpl :
	public IVsSolutionEvents2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSolutionEvents2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSolutionEvents2MockImpl)

	typedef IVsSolutionEvents2 Interface;
	struct OnAfterMergeSolutionValidValues
	{
		/*[in]*/ IUnknown* pUnkReserved;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterMergeSolution)(
		/*[in]*/ IUnknown* pUnkReserved)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterMergeSolution)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnkReserved);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterOpenProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ BOOL fAdded;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterOpenProject)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ BOOL fAdded)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterOpenProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE(fAdded);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnQueryCloseProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ BOOL fRemoving;
		/*[in,out]*/ BOOL* pfCancel;
		HRESULT retValue;
	};

	STDMETHOD(OnQueryCloseProject)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ BOOL fRemoving,
		/*[in,out]*/ BOOL* pfCancel)
	{
		VSL_DEFINE_MOCK_METHOD(OnQueryCloseProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE(fRemoving);

		VSL_SET_VALIDVALUE(pfCancel);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnBeforeCloseProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ BOOL fRemoved;
		HRESULT retValue;
	};

	STDMETHOD(OnBeforeCloseProject)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ BOOL fRemoved)
	{
		VSL_DEFINE_MOCK_METHOD(OnBeforeCloseProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE(fRemoved);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterLoadProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pStubHierarchy;
		/*[in]*/ IVsHierarchy* pRealHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterLoadProject)(
		/*[in]*/ IVsHierarchy* pStubHierarchy,
		/*[in]*/ IVsHierarchy* pRealHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterLoadProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStubHierarchy);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pRealHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnQueryUnloadProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pRealHierarchy;
		/*[in,out]*/ BOOL* pfCancel;
		HRESULT retValue;
	};

	STDMETHOD(OnQueryUnloadProject)(
		/*[in]*/ IVsHierarchy* pRealHierarchy,
		/*[in,out]*/ BOOL* pfCancel)
	{
		VSL_DEFINE_MOCK_METHOD(OnQueryUnloadProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pRealHierarchy);

		VSL_SET_VALIDVALUE(pfCancel);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnBeforeUnloadProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pRealHierarchy;
		/*[in]*/ IVsHierarchy* pStubHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(OnBeforeUnloadProject)(
		/*[in]*/ IVsHierarchy* pRealHierarchy,
		/*[in]*/ IVsHierarchy* pStubHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(OnBeforeUnloadProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pRealHierarchy);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStubHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterOpenSolutionValidValues
	{
		/*[in]*/ IUnknown* pUnkReserved;
		/*[in]*/ BOOL fNewSolution;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterOpenSolution)(
		/*[in]*/ IUnknown* pUnkReserved,
		/*[in]*/ BOOL fNewSolution)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterOpenSolution)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnkReserved);

		VSL_CHECK_VALIDVALUE(fNewSolution);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnQueryCloseSolutionValidValues
	{
		/*[in]*/ IUnknown* pUnkReserved;
		/*[in,out]*/ BOOL* pfCancel;
		HRESULT retValue;
	};

	STDMETHOD(OnQueryCloseSolution)(
		/*[in]*/ IUnknown* pUnkReserved,
		/*[in,out]*/ BOOL* pfCancel)
	{
		VSL_DEFINE_MOCK_METHOD(OnQueryCloseSolution)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnkReserved);

		VSL_SET_VALIDVALUE(pfCancel);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnBeforeCloseSolutionValidValues
	{
		/*[in]*/ IUnknown* pUnkReserved;
		HRESULT retValue;
	};

	STDMETHOD(OnBeforeCloseSolution)(
		/*[in]*/ IUnknown* pUnkReserved)
	{
		VSL_DEFINE_MOCK_METHOD(OnBeforeCloseSolution)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnkReserved);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterCloseSolutionValidValues
	{
		/*[in]*/ IUnknown* pUnkReserved;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterCloseSolution)(
		/*[in]*/ IUnknown* pUnkReserved)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterCloseSolution)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnkReserved);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSOLUTIONEVENTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSolutionEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSOLUTIONEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSOLUTIONEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSolutionEventsNotImpl :
	public IVsSolutionEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSolutionEventsNotImpl)

public:

	typedef IVsSolutionEvents Interface;

	STDMETHOD(OnAfterOpenProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ BOOL /*fAdded*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnQueryCloseProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ BOOL /*fRemoving*/,
		/*[in,out]*/ BOOL* /*pfCancel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnBeforeCloseProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ BOOL /*fRemoved*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterLoadProject)(
		/*[in]*/ IVsHierarchy* /*pStubHierarchy*/,
		/*[in]*/ IVsHierarchy* /*pRealHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnQueryUnloadProject)(
		/*[in]*/ IVsHierarchy* /*pRealHierarchy*/,
		/*[in,out]*/ BOOL* /*pfCancel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnBeforeUnloadProject)(
		/*[in]*/ IVsHierarchy* /*pRealHierarchy*/,
		/*[in]*/ IVsHierarchy* /*pStubHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterOpenSolution)(
		/*[in]*/ IUnknown* /*pUnkReserved*/,
		/*[in]*/ BOOL /*fNewSolution*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnQueryCloseSolution)(
		/*[in]*/ IUnknown* /*pUnkReserved*/,
		/*[in,out]*/ BOOL* /*pfCancel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnBeforeCloseSolution)(
		/*[in]*/ IUnknown* /*pUnkReserved*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterCloseSolution)(
		/*[in]*/ IUnknown* /*pUnkReserved*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSolutionEventsMockImpl :
	public IVsSolutionEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSolutionEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSolutionEventsMockImpl)

	typedef IVsSolutionEvents Interface;
	struct OnAfterOpenProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ BOOL fAdded;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterOpenProject)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ BOOL fAdded)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterOpenProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE(fAdded);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnQueryCloseProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ BOOL fRemoving;
		/*[in,out]*/ BOOL* pfCancel;
		HRESULT retValue;
	};

	STDMETHOD(OnQueryCloseProject)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ BOOL fRemoving,
		/*[in,out]*/ BOOL* pfCancel)
	{
		VSL_DEFINE_MOCK_METHOD(OnQueryCloseProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE(fRemoving);

		VSL_SET_VALIDVALUE(pfCancel);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnBeforeCloseProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ BOOL fRemoved;
		HRESULT retValue;
	};

	STDMETHOD(OnBeforeCloseProject)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ BOOL fRemoved)
	{
		VSL_DEFINE_MOCK_METHOD(OnBeforeCloseProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE(fRemoved);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterLoadProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pStubHierarchy;
		/*[in]*/ IVsHierarchy* pRealHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterLoadProject)(
		/*[in]*/ IVsHierarchy* pStubHierarchy,
		/*[in]*/ IVsHierarchy* pRealHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterLoadProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStubHierarchy);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pRealHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnQueryUnloadProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pRealHierarchy;
		/*[in,out]*/ BOOL* pfCancel;
		HRESULT retValue;
	};

	STDMETHOD(OnQueryUnloadProject)(
		/*[in]*/ IVsHierarchy* pRealHierarchy,
		/*[in,out]*/ BOOL* pfCancel)
	{
		VSL_DEFINE_MOCK_METHOD(OnQueryUnloadProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pRealHierarchy);

		VSL_SET_VALIDVALUE(pfCancel);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnBeforeUnloadProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pRealHierarchy;
		/*[in]*/ IVsHierarchy* pStubHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(OnBeforeUnloadProject)(
		/*[in]*/ IVsHierarchy* pRealHierarchy,
		/*[in]*/ IVsHierarchy* pStubHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(OnBeforeUnloadProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pRealHierarchy);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStubHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterOpenSolutionValidValues
	{
		/*[in]*/ IUnknown* pUnkReserved;
		/*[in]*/ BOOL fNewSolution;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterOpenSolution)(
		/*[in]*/ IUnknown* pUnkReserved,
		/*[in]*/ BOOL fNewSolution)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterOpenSolution)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnkReserved);

		VSL_CHECK_VALIDVALUE(fNewSolution);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnQueryCloseSolutionValidValues
	{
		/*[in]*/ IUnknown* pUnkReserved;
		/*[in,out]*/ BOOL* pfCancel;
		HRESULT retValue;
	};

	STDMETHOD(OnQueryCloseSolution)(
		/*[in]*/ IUnknown* pUnkReserved,
		/*[in,out]*/ BOOL* pfCancel)
	{
		VSL_DEFINE_MOCK_METHOD(OnQueryCloseSolution)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnkReserved);

		VSL_SET_VALIDVALUE(pfCancel);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnBeforeCloseSolutionValidValues
	{
		/*[in]*/ IUnknown* pUnkReserved;
		HRESULT retValue;
	};

	STDMETHOD(OnBeforeCloseSolution)(
		/*[in]*/ IUnknown* pUnkReserved)
	{
		VSL_DEFINE_MOCK_METHOD(OnBeforeCloseSolution)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnkReserved);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterCloseSolutionValidValues
	{
		/*[in]*/ IUnknown* pUnkReserved;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterCloseSolution)(
		/*[in]*/ IUnknown* pUnkReserved)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterCloseSolution)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnkReserved);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSOLUTIONEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSolutionEventsProjectUpgrade.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSOLUTIONEVENTSPROJECTUPGRADE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSOLUTIONEVENTSPROJECTUPGRADE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSolutionEventsProjectUpgradeNotImpl :
	public IVsSolutionEventsProjectUpgrade
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSolutionEventsProjectUpgradeNotImpl)

public:

	typedef IVsSolutionEventsProjectUpgrade Interface;

	STDMETHOD(OnAfterUpgradeProject)(
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ VSPUVF_FLAGS /*fUpgradeFlag*/,
		/*[in]*/ BSTR /*bstrCopyLocation*/,
		/*[in]*/ SYSTEMTIME /*stUpgradeTime*/,
		/*[in]*/ IVsUpgradeLogger* /*pLogger*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSolutionEventsProjectUpgradeMockImpl :
	public IVsSolutionEventsProjectUpgrade,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSolutionEventsProjectUpgradeMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSolutionEventsProjectUpgradeMockImpl)

	typedef IVsSolutionEventsProjectUpgrade Interface;
	struct OnAfterUpgradeProjectValidValues
	{
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ VSPUVF_FLAGS fUpgradeFlag;
		/*[in]*/ BSTR bstrCopyLocation;
		/*[in]*/ SYSTEMTIME stUpgradeTime;
		/*[in]*/ IVsUpgradeLogger* pLogger;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterUpgradeProject)(
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ VSPUVF_FLAGS fUpgradeFlag,
		/*[in]*/ BSTR bstrCopyLocation,
		/*[in]*/ SYSTEMTIME stUpgradeTime,
		/*[in]*/ IVsUpgradeLogger* pLogger)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterUpgradeProject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE(fUpgradeFlag);

		VSL_CHECK_VALIDVALUE_BSTR(bstrCopyLocation);

		VSL_CHECK_VALIDVALUE(stUpgradeTime);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pLogger);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSOLUTIONEVENTSPROJECTUPGRADE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSolutionPersistence.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSOLUTIONPERSISTENCE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSOLUTIONPERSISTENCE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSolutionPersistenceNotImpl :
	public IVsSolutionPersistence
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSolutionPersistenceNotImpl)

public:

	typedef IVsSolutionPersistence Interface;

	STDMETHOD(SavePackageSolutionProps)(
		/*[in]*/ BOOL /*fPreLoad*/,
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ IVsPersistSolutionProps* /*pPSP*/,
		/*[in]*/ LPCOLESTR /*pszKey*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SavePackageUserOpts)(
		/*[in]*/ IVsPersistSolutionOpts* /*pPSO*/,
		/*[in]*/ LPCOLESTR /*pszKey*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LoadPackageUserOpts)(
		/*[in]*/ IVsPersistSolutionOpts* /*pPSO*/,
		/*[in]*/ LPCOLESTR /*pszKey*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSolutionPersistenceMockImpl :
	public IVsSolutionPersistence,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSolutionPersistenceMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSolutionPersistenceMockImpl)

	typedef IVsSolutionPersistence Interface;
	struct SavePackageSolutionPropsValidValues
	{
		/*[in]*/ BOOL fPreLoad;
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ IVsPersistSolutionProps* pPSP;
		/*[in]*/ LPCOLESTR pszKey;
		HRESULT retValue;
	};

	STDMETHOD(SavePackageSolutionProps)(
		/*[in]*/ BOOL fPreLoad,
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ IVsPersistSolutionProps* pPSP,
		/*[in]*/ LPCOLESTR pszKey)
	{
		VSL_DEFINE_MOCK_METHOD(SavePackageSolutionProps)

		VSL_CHECK_VALIDVALUE(fPreLoad);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPSP);

		VSL_CHECK_VALIDVALUE_STRINGW(pszKey);

		VSL_RETURN_VALIDVALUES();
	}
	struct SavePackageUserOptsValidValues
	{
		/*[in]*/ IVsPersistSolutionOpts* pPSO;
		/*[in]*/ LPCOLESTR pszKey;
		HRESULT retValue;
	};

	STDMETHOD(SavePackageUserOpts)(
		/*[in]*/ IVsPersistSolutionOpts* pPSO,
		/*[in]*/ LPCOLESTR pszKey)
	{
		VSL_DEFINE_MOCK_METHOD(SavePackageUserOpts)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPSO);

		VSL_CHECK_VALIDVALUE_STRINGW(pszKey);

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadPackageUserOptsValidValues
	{
		/*[in]*/ IVsPersistSolutionOpts* pPSO;
		/*[in]*/ LPCOLESTR pszKey;
		HRESULT retValue;
	};

	STDMETHOD(LoadPackageUserOpts)(
		/*[in]*/ IVsPersistSolutionOpts* pPSO,
		/*[in]*/ LPCOLESTR pszKey)
	{
		VSL_DEFINE_MOCK_METHOD(LoadPackageUserOpts)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPSO);

		VSL_CHECK_VALIDVALUE_STRINGW(pszKey);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSOLUTIONPERSISTENCE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSplitRoot.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSPLITROOT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSPLITROOT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSplitRootNotImpl :
	public IVsSplitRoot
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSplitRootNotImpl)

public:

	typedef IVsSplitRoot Interface;

	STDMETHOD(GetRootSplitter)(
		/*[out]*/ IVsSplitter** /*ppPane*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetWindowHandle)(
		/*[out]*/ HWND* /*phwnd*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPane)(
		/*[in]*/ PANETYPE /*paneType*/,
		/*[out]*/ IVsSplitPane** /*ppPane*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSplitRootMockImpl :
	public IVsSplitRoot,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSplitRootMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSplitRootMockImpl)

	typedef IVsSplitRoot Interface;
	struct GetRootSplitterValidValues
	{
		/*[out]*/ IVsSplitter** ppPane;
		HRESULT retValue;
	};

	STDMETHOD(GetRootSplitter)(
		/*[out]*/ IVsSplitter** ppPane)
	{
		VSL_DEFINE_MOCK_METHOD(GetRootSplitter)

		VSL_SET_VALIDVALUE_INTERFACE(ppPane);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetWindowHandleValidValues
	{
		/*[out]*/ HWND* phwnd;
		HRESULT retValue;
	};

	STDMETHOD(GetWindowHandle)(
		/*[out]*/ HWND* phwnd)
	{
		VSL_DEFINE_MOCK_METHOD(GetWindowHandle)

		VSL_SET_VALIDVALUE(phwnd);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPaneValidValues
	{
		/*[in]*/ PANETYPE paneType;
		/*[out]*/ IVsSplitPane** ppPane;
		HRESULT retValue;
	};

	STDMETHOD(GetPane)(
		/*[in]*/ PANETYPE paneType,
		/*[out]*/ IVsSplitPane** ppPane)
	{
		VSL_DEFINE_MOCK_METHOD(GetPane)

		VSL_CHECK_VALIDVALUE(paneType);

		VSL_SET_VALIDVALUE_INTERFACE(ppPane);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSPLITROOT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSpecifyProjectDesignerPages.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license ter